module Capistrano
  class VersionValidator
    def initialize(version)
      @version = version
    end

    def verify
      return self if match?
      raise "Capfile locked at #{version}, but #{current_version} is loaded"
    end

    private

    attr_reader :version

    def match?
      available =~ requested
    end

    def current_version
      VERSION
    end

    def available
      Gem::Dependency.new("cap", version)
    end

    def requested
      Gem::Dependency.new("cap", current_version)
    end
module Capistrano
  # Base class for SCM strategy providers.
  #
  # @abstract
  #
  # @attr_reader [Rake] context
  #
  # @author Hartog de Mik
  #
  class SCM
    attr_reader :context

    # Provide a wrapper for the SCM that loads a strategy for the user.
    #
    # @param [Rake] context     The context in which the strategy should run
    # @param [Module] strategy  A module to include into the SCM instance. The
    #    module should provide the abstract methods of Capistrano::SCM
    #
    def initialize(context, strategy)
      @context = context
      singleton = class << self; self; end
      singleton.send(:include, strategy)
    end

    # Call test in context
    def test!(*args)
      context.test(*args)
    end

    # The repository URL according to the context
    def repo_url
      context.repo_url
    end

    # The repository path according to the context
    def repo_path
      context.repo_path
    end

    # The release path according to the context
    def release_path
      context.release_path
    end

    # Fetch a var from the context
    # @param [Symbol] variable The variable to fetch
    # @param [Object] default  The default value if not found
    #
    def fetch(*args)
      context.fetch(*args)
    end

    # @abstract
    #
    # Your implementation should check the existence of a cache repository on
    # the deployment target
    #
    # @return [Boolean]
    #
    def test
      raise NotImplementedError, "Your SCM strategy module should provide a #test method"
    end

    # @abstract
    #
    # Your implementation should check if the specified remote-repository is
    # available.
    #
    # @return [Boolean]
    #
    def check
      raise NotImplementedError, "Your SCM strategy module should provide a #check method"
    end

    # @abstract
    #
    # Create a (new) clone of the remote-repository on the deployment target
    #
    # @return void
    #
    def clone
      raise NotImplementedError, "Your SCM strategy module should provide a #clone method"
    end

    # @abstract
    #
    # Update the clone on the deployment target
    #
    # @return void
    #
    def update
      raise NotImplementedError, "Your SCM strategy module should provide a #update method"
    end

    # @abstract
    #
    # Copy the contents of the cache-repository onto the release path
    #
    # @return void
    #
    def release
      raise NotImplementedError, "Your SCM strategy module should provide a #release method"
    end

    # @abstract
    #
    # Identify the SHA of the commit that will be deployed.  This will most likely involve SshKit's capture method.
    #
    # @return void
    #
module Capistrano
  class Application < Rake::Application
    def initialize
      super
      @rakefiles = %w{capfile Capfile capfile.rb Capfile.rb}
    end

    def name
      "cap"
    end

    def run
      Rake.application = self
      super
    end

    def sort_options(options)
      not_applicable_to_capistrano = %w(quiet silent verbose)
      options.reject! do |(switch, *)|
        switch =~ /--#{Regexp.union(not_applicable_to_capistrano)}/
      end

      super.push(version, dry_run, roles, hostfilter, print_config_variables)
    end

    def handle_options
      options.rakelib = ["rakelib"]
      options.trace_output = $stderr

      OptionParser.new do |opts|
        opts.banner = "See full documentation at http://capistranorb.com/."
        opts.separator ""
        opts.separator "Install capistrano in a project:"
        opts.separator "    bundle exec cap install [STAGES=qa,staging,production,...]"
        opts.separator ""
        opts.separator "Show available tasks:"
        opts.separator "    bundle exec cap -T"
        opts.separator ""
        opts.separator "Invoke (or simulate invoking) a task:"
        opts.separator "    bundle exec cap [--dry-run] STAGE TASK"
        opts.separator ""
        opts.separator "Advanced options:"

        opts.on_tail("-h", "--help", "-H", "Display this help message.") do
          puts opts
          exit
        end

        standard_rake_options.each { |args| opts.on(*args) }
        opts.environment("RAKEOPT")
      end.parse!
    end

    def top_level_tasks
      if tasks_without_stage_dependency.include?(@top_level_tasks.first)
        @top_level_tasks
      else
        @top_level_tasks.unshift(ensure_stage.to_s)
      end
    end

    def display_error_message(ex)
      unless options.backtrace
        Rake.application.options.suppress_backtrace_pattern = backtrace_pattern if backtrace_pattern
        trace "(Backtrace restricted to imported tasks)"
      end

      super
    end

    def exit_because_of_exception(ex)
      if respond_to?(:deploying?) && deploying?
        exit_deploy_because_of_exception(ex)
      else
        super
      end
    end

    # allows the `cap install` task to load without a capfile
    def find_rakefile_location
      if (location = super).nil?
        [capfile, Dir.pwd]
      else
        location
      end
    end

    private

    def backtrace_pattern
      loc = Rake.application.find_rakefile_location
      return unless loc

      whitelist = (@imported.dup << loc[0]).map { |f| File.absolute_path(f, loc[1]) }
      /^(?!#{whitelist.map { |p| Regexp.quote(p) }.join('|')})/
    end

    def load_imports
      if options.show_tasks && Rake::Task.task_defined?("load:defaults")
        invoke "load:defaults"
        set(:stage, "")
        Dir[deploy_config_path].each { |f| add_import f }
      end

      super
    end

    def capfile
      File.expand_path(File.join(File.dirname(__FILE__), "..", "Capfile"))
    end

    def version
      ["--version", "-V",
       "Display the program version.",
       lambda do |_value|
         puts "Capistrano Version: #{Capistrano::VERSION} (Rake Version: #{Rake::VERSION})"
         exit
       end]
    end

    def dry_run
      ["--dry-run", "-n",
       "Do a dry run without executing actions",
       lambda do |_value|
         Configuration.env.set(:sshkit_backend, SSHKit::Backend::Printer)
       end]
    end

    def roles
      ["--roles ROLES", "-r",
       "Run SSH commands only on hosts matching these roles",
       lambda do |value|
         Configuration.env.add_cmdline_filter(:role, value)
       end]
    end

    def hostfilter
      ["--hosts HOSTS", "-z",
       "Run SSH commands only on matching hosts",
       lambda do |value|
         Configuration.env.add_cmdline_filter(:host, value)
       end]
    end

    def print_config_variables
      ["--print-config-variables", "-p",
       "Display the defined config variables before starting the deployment tasks.",
       lambda do |_value|
         Configuration.env.set(:print_config_variables, true)
       end]
require "rake"
require "sshkit"

require "io/console"

Rake.application.options.trace = true

require "capistrano/version"
require "capistrano/version_validator"
require "capistrano/i18n"
require "capistrano/dsl"
require "capistrano/application"
require "capistrano/configuration"
require "capistrano/configuration/scm_resolver"

require "i18n"

en = {
  starting: "Starting",
  capified: "Capified",
  start: "Start",
  update: "Update",
  finalize: "Finalise",
  finishing: "Finishing",
  finished: "Finished",
  stage_not_set: "Stage not set, please call something such as `cap production deploy`, where production is a stage you have defined.",
  written_file: "create %{file}",
  question: "Please enter %{key}: ",
  question_default: "Please enter %{key} (%{default_value}): ",
  question_prompt: "%{key}: ",
  question_prompt_default: "%{key} (%{default_value}): ",
  keeping_releases: "Keeping %{keep_releases} of %{releases} deployed releases on %{host}",
  skip_cleanup: "Skipping cleanup of invalid releases on %{host}; unexpected foldername found (should be timestamp)",
  wont_delete_current_release: "Current release was marked for being removed but it's going to be skipped on %{host}",
  no_current_release: "There is no current release present on %{host}",
  no_old_releases: "No old releases (keeping newest %{keep_releases}) on %{host}",
  linked_file_does_not_exist: "linked file %{file} does not exist on %{host}",
  cannot_rollback: "There are no older releases to rollback to",
  cannot_found_rollback_release: "Cannot rollback because release %{release} does not exist",
  mirror_exists: "The repository mirror is at %{at}",
  revision_log_message: "Branch %{branch} (at %{sha}) deployed as release %{release} by %{user}",
  rollback_log_message: "%{user} rolled back to release %{release}",
  deploy_failed: "The deploy has failed with an error: %{ex}",
  console: {
    welcome: "capistrano console - enter command to execute on %{stage}",
    bye: "bye"
  },
  error: {
    invalid_stage_name: '"%{name}" is a reserved word and cannot be used as a stage. Rename "%{path}" to something else.',
    user: {
      does_not_exist: "User %{user} does not exists",
      cannot_switch: "Cannot switch to user %{user}"
    }
  }
}

I18n.backend.store_translations(:en, capistrano: en)

if I18n.respond_to?(:enforce_available_locales=)
  I18n.enforce_available_locales = true
require "capistrano/doctor/environment_doctor"
require "capistrano/doctor/gems_doctor"
require "capistrano/doctor/variables_doctor"
require "capistrano/doctor/servers_doctor"

module Capistrano
  module DSL
    module Stages
      RESERVED_NAMES = %w(deploy doctor install).freeze
      private_constant :RESERVED_NAMES

      def stages
        names = Dir[stage_definitions].map { |f| File.basename(f, ".rb") }
        assert_valid_stage_names(names)
        names
      end

      def stage_definitions
        stage_config_path.join("*.rb")
      end

      def stage_set?
        !!fetch(:stage, false)
      end

      private

      def assert_valid_stage_names(names)
        invalid = names.find { |n| RESERVED_NAMES.include?(n) }
        return if invalid.nil?

        raise t("error.invalid_stage_name", name: invalid, path: stage_config_path.join("#{invalid}.rb"))
      end
    end
  end
require "capistrano/upload_task"

module Capistrano
  module TaskEnhancements
    def before(task, prerequisite, *args, &block)
      prerequisite = Rake::Task.define_task(prerequisite, *args, &block) if block_given?
      Rake::Task[task].enhance [prerequisite]
    end

    def after(task, post_task, *args, &block)
      Rake::Task.define_task(post_task, *args, &block) if block_given?
      task = Rake::Task[task]
      task.enhance do
        post = Rake.application.lookup(post_task, task.scope)
        raise ArgumentError, "Task #{post_task.inspect} not found" unless post
        post.invoke
      end
    end

    def define_remote_file_task(task, target_roles)
      Capistrano::UploadTask.define_task(task) do |t|
        prerequisite_file = t.prerequisites.first
        file = shared_path.join(t.name)

        on roles(target_roles) do
          unless test "[ -f #{file.to_s.shellescape} ]"
            info "Uploading #{prerequisite_file} to #{file}"
            upload! File.open(prerequisite_file), file
          end
        end
      end
    end

    def ensure_stage
      Rake::Task.define_task(:ensure_stage) do
        unless stage_set?
          puts t(:stage_not_set)
          exit 1
        end
      end
    end

    def tasks_without_stage_dependency
      stages + default_tasks
    end

    def default_tasks
      %w{install}
    end

    def exit_deploy_because_of_exception(ex)
      warn t(:deploy_failed, ex: ex.message)
      invoke "deploy:failed"
      exit(false)
    end

    def deploying?
      fetch(:deploying, false)
    end
  end
require "forwardable"

module Capistrano
  module DSL
    module Env
      extend Forwardable
      def_delegators :env,
                     :configure_backend, :fetch, :set, :set_if_empty, :delete,
                     :ask, :role, :server, :primary, :validate, :append,
                     :remove, :dry_run?, :install_plugin, :any?, :is_question?,
                     :configure_scm, :scm_plugin_installed?

      def roles(*names)
        env.roles_for(names.flatten)
      end

      def role_properties(*names, &block)
        env.role_properties_for(names, &block)
      end

      def release_roles(*names)
        if names.last.is_a? Hash
          names.last[:exclude] = :no_release
        else
          names << { exclude: :no_release }
        end
        roles(*names)
      end

      def env
        Configuration.env
      end

      def release_timestamp
        env.timestamp.strftime("%Y%m%d%H%M%S")
      end

      def asset_timestamp
        env.timestamp.strftime("%Y%m%d%H%M.%S")
      end
require "pathname"
module Capistrano
  module DSL
    module Paths
      def deploy_to
        fetch(:deploy_to)
      end

      def deploy_path
        Pathname.new(deploy_to)
      end

      def current_path
        deploy_path.join(fetch(:current_directory, "current"))
      end

      def releases_path
        deploy_path.join(fetch(:releases_directory, "releases"))
      end

      def release_path
        fetch(:release_path) { current_path }
      end

      def set_release_path(timestamp=now)
        set(:release_timestamp, timestamp)
        set(:release_path, releases_path.join(timestamp))
      end

      def stage_config_path
        Pathname.new fetch(:stage_config_path, "config/deploy")
      end

      def deploy_config_path
        Pathname.new fetch(:deploy_config_path, "config/deploy.rb")
      end

      def repo_url
        fetch(:repo_url)
      end

      def repo_path
        Pathname.new(fetch(:repo_path, ->() { deploy_path.join("repo") }))
      end

      def shared_path
        deploy_path.join(fetch(:shared_directory, "shared"))
      end

      def revision_log
        deploy_path.join("revisions.log")
      end

      def now
        env.timestamp.strftime("%Y%m%d%H%M%S")
      end

      def asset_timestamp
        env.timestamp.strftime("%Y%m%d%H%M.%S")
      end

      def linked_dirs(parent)
        paths = fetch(:linked_dirs)
        join_paths(parent, paths)
      end

      def linked_files(parent)
        paths = fetch(:linked_files)
        join_paths(parent, paths)
      end

      def linked_file_dirs(parent)
        map_dirnames(linked_files(parent))
      end

      def linked_dir_parents(parent)
        map_dirnames(linked_dirs(parent))
      end

      def join_paths(parent, paths)
        paths.map { |path| parent.join(path) }
      end

      def map_dirnames(paths)
        paths.map(&:dirname).uniq
module Capistrano
  # This module extends a Rake::Task to freeze it to prevent it from being
  # enhanced. This is used to prevent users from enhancing a task at the wrong
  # point of Capistrano's boot process, which can happen if a Capistrano plugin
  # is loaded in deploy.rb by mistake (instead of in the Capfile).
  #
  # Usage:
  #
  # task = Rake.application["load:defaults"]
  # task.invoke
  # task.extend(Capistrano::ImmutableTask) # prevent further modifications
  #
  module ImmutableTask
    def self.extended(task)
      task.freeze
    end

    def enhance(*args, &block)
      $stderr.puts <<-MESSAGE
ERROR: #{name} has already been invoked and can no longer be modified.
Check that you haven't loaded a Capistrano plugin in deploy.rb or a stage
(e.g. deploy/production.rb) by mistake.
Plugins must be loaded in the Capfile to initialize properly.
MESSAGE

require_relative "configuration/filter"
require_relative "configuration/question"
require_relative "configuration/plugin_installer"
require_relative "configuration/server"
require_relative "configuration/servers"
require_relative "configuration/validated_variables"
require_relative "configuration/variables"

module Capistrano
  class ValidationError < RuntimeError; end

  class Configuration
    def self.env
      @env ||= new
    end

    def self.reset!
      @env = new
    end

    extend Forwardable
    attr_reader :variables
    def_delegators :variables,
                   :set, :fetch, :fetch_for, :delete, :keys, :validate

    def initialize(values={})
      @variables = ValidatedVariables.new(Variables.new(values))
    end

    def ask(key, default=nil, options={})
      question = Question.new(key, default, options)
      set(key, question)
    end

    def set_if_empty(key, value=nil, &block)
      set(key, value, &block) unless keys.include?(key)
    end

    def append(key, *values)
      set(key, Array(fetch(key)).concat(values))
    end

    def remove(key, *values)
      set(key, Array(fetch(key)) - values)
    end

    def any?(key)
      value = fetch(key)
      if value && value.respond_to?(:any?)
        begin
          return value.any?
        rescue ArgumentError # rubocop:disable Lint/HandleExceptions
          # Gracefully ignore values whose `any?` method doesn't accept 0 args
        end
      end

      !value.nil?
    end

    def is_question?(key)
      value = fetch_for(key, nil)
      !value.nil? && value.is_a?(Question)
    end

    def role(name, hosts, options={})
      if name == :all
        raise ArgumentError, "#{name} reserved name for role. Please choose another name"
      end

      servers.add_role(name, hosts, options)
    end

    def server(name, properties={})
      servers.add_host(name, properties)
    end

    def roles_for(names)
      servers.roles_for(names)
    end

    def role_properties_for(names, &block)
      servers.role_properties_for(names, &block)
    end

    def primary(role)
      servers.fetch_primary(role)
    end

    def backend
      @backend ||= SSHKit
    end

    attr_writer :backend

    def configure_backend
      backend.configure do |sshkit|
        configure_sshkit_output(sshkit)
        sshkit.output_verbosity = fetch(:log_level)
        sshkit.default_env      = fetch(:default_env)
        sshkit.backend          = fetch(:sshkit_backend, SSHKit::Backend::Netssh)
        sshkit.backend.configure do |backend|
          backend.pty                = fetch(:pty)
          backend.connection_timeout = fetch(:connection_timeout)
          backend.ssh_options        = (backend.ssh_options || {}).merge(fetch(:ssh_options, {}))
        end
      end
    end

    def configure_scm
      Capistrano::Configuration::SCMResolver.new.resolve
    end

    def timestamp
      @timestamp ||= Time.now.utc
    end

    def add_filter(filter=nil, &block)
      if block
        raise ArgumentError, "Both a block and an object were given" if filter

        filter = Object.new
        def filter.filter(servers)
          block.call(servers)
        end
      elsif !filter.respond_to? :filter
        raise TypeError, "Provided custom filter <#{filter.inspect}> does " \
                         "not have a public 'filter' method"
      end
      @custom_filters ||= []
      @custom_filters << filter
    end

    def setup_filters
      @filters = cmdline_filters
      @filters += @custom_filters if @custom_filters
      @filters << Filter.new(:role, ENV["ROLES"]) if ENV["ROLES"]
      @filters << Filter.new(:host, ENV["HOSTS"]) if ENV["HOSTS"]
      fh = fetch_for(:filter, {}) || {}
      @filters << Filter.new(:host, fh[:hosts]) if fh[:hosts]
      @filters << Filter.new(:role, fh[:roles]) if fh[:roles]
      @filters << Filter.new(:host, fh[:host]) if fh[:host]
      @filters << Filter.new(:role, fh[:role]) if fh[:role]
    end

    def add_cmdline_filter(type, values)
      cmdline_filters << Filter.new(type, values)
    end

    def filter(list)
      setup_filters if @filters.nil?
      @filters.reduce(list) { |l, f| f.filter l }
    end

    def dry_run?
      fetch(:sshkit_backend) == SSHKit::Backend::Printer
    end

    def install_plugin(plugin, load_hooks: true, load_immediately: false)
      installer.install(plugin,
                        load_hooks: load_hooks,
                        load_immediately: load_immediately)
    end

    def scm_plugin_installed?
      installer.scm_installed?
    end

    def servers
      @servers ||= Servers.new
    end

    private

    def cmdline_filters
      @cmdline_filters ||= []
    end

    def installer
      @installer ||= PluginInstaller.new
    end

    def configure_sshkit_output(sshkit)
      format_args = [fetch(:format)]
      format_args.push(fetch(:format_options)) if any?(:format_options)

require "rake/file_creation_task"

module Capistrano
  class UploadTask < Rake::FileCreationTask
    def needed?
module Capistrano
  class Configuration
    class NullFilter
      def filter(servers)
        servers
require "set"
module Capistrano
  class Configuration
    class Server < SSHKit::Host
      extend Forwardable
      def_delegators :properties, :roles, :fetch, :set

      def self.[](host)
        host.is_a?(Server) ? host : new(host)
      end

      def add_roles(roles)
        Array(roles).each { |role| add_role(role) }
        self
      end
      alias roles= add_roles

      def add_role(role)
        roles.add role.to_sym
        self
      end

      def has_role?(role)
        roles.include? role.to_sym
      end

      def select?(options)
        options.each do |k, v|
          callable = v.respond_to?(:call) ? v : ->(server) { server.fetch(v) }
          result = \
            case k
            when :filter, :select
              callable.call(self)
            when :exclude
              !callable.call(self)
            else
              fetch(k) == v
            end
          return false unless result
        end

        true
      end

      def primary
        self if fetch(:primary)
      end

      def with(properties)
        properties.each { |key, value| add_property(key, value) }
        self
      end

      def properties
        @properties ||= Properties.new
      end

      def netssh_options
        @netssh_options ||= super.merge(fetch(:ssh_options) || {})
      end

      def roles_array
        roles.to_a
      end

      def matches?(other)
        # This matching logic must stay in sync with `Servers#add_host`.
        hostname == other.hostname && port == other.port
      end

      private

      def add_property(key, value)
        if respond_to?("#{key}=")
          send("#{key}=", value)
        else
          set(key, value)
        end
      end

      class Properties
        def initialize
          @properties = {}
        end

        def set(key, value)
          pval = @properties[key]
          if pval.is_a?(Hash) && value.is_a?(Hash)
            pval.merge!(value)
          elsif pval.is_a?(Set) && value.is_a?(Set)
            pval.merge(value)
          elsif pval.is_a?(Array) && value.is_a?(Array)
            pval.concat value
          else
            @properties[key] = value
          end
        end

        def fetch(key)
          @properties[key]
        end

        def respond_to_missing?(method, _include_all=false)
          @properties.key?(method) || super
        end

        def roles
          @roles ||= Set.new
        end

        def keys
          @properties.keys
        end

        # rubocop:disable Style/MethodMissing
        def method_missing(key, value=nil)
          if value
            set(lvalue(key), value)
          else
            fetch(key)
          end
        end
        # rubocop:enable Style/MethodMissing

        def to_h
          @properties
        end

        private

        def lvalue(key)
          key.to_s.chomp("=").to_sym
        end
      end
    end
module Capistrano
  class Configuration
    class RoleFilter
      def initialize(values)
        av = Array(values).dup
        av = av.flat_map { |v| v.is_a?(String) ? v.split(",") : v }
        @rex = regex_matcher(av)
      end

      def filter(servers)
        Array(servers).select { |s| s.is_a?(String) ? false : s.roles.any? { |r| @rex.match r } }
      end

      private

      def regex_matcher(values)
        values.map! do |v|
          case v
          when Regexp then v
          else
            vs = v.to_s
            vs =~ %r{^/(.+)/$} ? Regexp.new($1) : /^#{Regexp.quote(vs)}$/
          end
        end
        Regexp.union values
require "capistrano/configuration"
require "capistrano/configuration/empty_filter"
require "capistrano/configuration/host_filter"
require "capistrano/configuration/null_filter"
require "capistrano/configuration/role_filter"

module Capistrano
  class Configuration
    class Filter
      def initialize(type, values=nil)
        raise "Invalid filter type #{type}" unless %i(host role).include? type
        av = Array(values)
        @strategy = if av.empty? then EmptyFilter.new
                    elsif av.include?(:all) || av.include?("all") then NullFilter.new
                    elsif type == :host then HostFilter.new(values)
                    elsif type == :role then RoleFilter.new(values)
                    else NullFilter.new
                    end
      end

      def filter(servers)
        @strategy.filter servers
      end
    end
  end
module Capistrano
  class Configuration
    # In earlier versions of Capistrano, users would specify the desired SCM
    # implementation using `set :scm, :git`, for example. Capistrano would then
    # load the matching .rb file based on this variable.
    #
    # Now we expect users to explicitly `require` and call `new` on the desired
    # SCM implementation in their Capfile. The `set` technique is deprecated.
    #
    # This SCMResolver class takes care of managing the transition from the old
    # to new system. It maintains the legacy behavior, but prints deprecation
    # warnings when it is used.
    #
    # To maintain backwards compatibility, the resolver will load the Git SCM by
    # if default it determines that no SCM has been explicitly specified or
    # loaded. To force no SCM to be used at all, use `set :scm, nil`. This hack
    # won't be necessary once backwards compatibility is removed in a future
    # version.
    #
    # TODO: Remove this class entirely in Capistrano 4.0.
    #
    class SCMResolver
      DEFAULT_GIT = :"default-git"

      include Capistrano::DSL

      def resolve
        return if scm_name.nil?
        set(:scm, :git) if using_default_scm?

        print_deprecation_warnings_if_applicable

        # Note that `scm_plugin_installed?` comes from Capistrano::DSL
        if scm_plugin_installed?
          delete(:scm)
          return
        end

        if built_in_scm_name?
          load_built_in_scm
        else
          # Compatibility with existing 3.x third-party SCMs
          register_legacy_scm_hooks
          load_legacy_scm_by_name
        end
      end

      private

      def using_default_scm?
        return @using_default_scm if defined? @using_default_scm
        @using_default_scm = (fetch(:scm) == DEFAULT_GIT)
      end

      def scm_name
        fetch(:scm)
      end

      def load_built_in_scm
        require "capistrano/scm/#{scm_name}"
        scm_class = Object.const_get(built_in_scm_plugin_class_name)
        # We use :load_immediately because we are initializing the SCM plugin
        # late in the load process and therefore can't use the standard
        # load:defaults technique.
        install_plugin(scm_class, load_immediately: true)
      end

      def load_legacy_scm_by_name
        load("capistrano/#{scm_name}.rb")
      end

      def third_party_scm_name?
        !built_in_scm_name?
      end

      def built_in_scm_name?
        %w(git hg svn).include?(scm_name.to_s.downcase)
      end

      def built_in_scm_plugin_class_name
        "Capistrano::SCM::#{scm_name.to_s.capitalize}"
      end

      # rubocop:disable Style/GuardClause
      def register_legacy_scm_hooks
        if Rake::Task.task_defined?("deploy:new_release_path")
          after "deploy:new_release_path", "#{scm_name}:create_release"
        end

        if Rake::Task.task_defined?("deploy:check")
          before "deploy:check", "#{scm_name}:check"
        end

        if Rake::Task.task_defined?("deploy:set_current_revision")
          before "deploy:set_current_revision",
                 "#{scm_name}:set_current_revision"
        end
      end
      # rubocop:enable Style/GuardClause

      def print_deprecation_warnings_if_applicable
        if using_default_scm?
          warn_add_git_to_capfile unless scm_plugin_installed?
        elsif built_in_scm_name?
          warn_set_scm_is_deprecated
        elsif third_party_scm_name?
          warn_third_party_scm_must_be_upgraded
        end
      end

      def warn_set_scm_is_deprecated
        $stderr.puts(<<-MESSAGE)
[Deprecation Notice] `set :scm, #{scm_name.inspect}` is deprecated.
To ensure your project is compatible with future versions of Capistrano,
remove the :scm setting and instead add these lines to your Capfile after
`require "capistrano/deploy"`:

    require "capistrano/scm/#{scm_name}"
    install_plugin #{built_in_scm_plugin_class_name}

MESSAGE
      end

      def warn_add_git_to_capfile
        $stderr.puts(<<-MESSAGE)
[Deprecation Notice] Future versions of Capistrano will not load the Git SCM
plugin by default. To silence this deprecation warning, add the following to
your Capfile after `require "capistrano/deploy"`:

    require "capistrano/scm/git"
    install_plugin Capistrano::SCM::Git

MESSAGE
      end

      def warn_third_party_scm_must_be_upgraded
        $stderr.puts(<<-MESSAGE)
[Deprecation Notice] `set :scm, #{scm_name.inspect}` is deprecated.
To ensure this custom SCM will work with future versions of Capistrano,
please upgrade it to a version that uses the new SCM plugin mechanism
documented here:

http://capistranorb.com/documentation/advanced-features/custom-scm

MESSAGE
require "set"
require "capistrano/configuration"
require "capistrano/configuration/filter"

module Capistrano
  class Configuration
    class Servers
      include Enumerable

      def add_host(host, properties={})
        new_host = Server[host]
        new_host.port = properties[:port] if properties.key?(:port)
        # This matching logic must stay in sync with `Server#matches?`.
        key = ServerKey.new(new_host.hostname, new_host.port)
        existing = servers_by_key[key]
        if existing
          existing.user = new_host.user if new_host.user
          existing.with(properties)
        else
          servers_by_key[key] = new_host.with(properties)
        end
      end

      # rubocop:disable Security/MarshalLoad
      def add_role(role, hosts, options={})
        options_deepcopy = Marshal.dump(options.merge(roles: role))
        Array(hosts).each { |host| add_host(host, Marshal.load(options_deepcopy)) }
      end
      # rubocop:enable Security/MarshalLoad

      def roles_for(names)
        options = extract_options(names)
        s = Filter.new(:role, names).filter(servers_by_key.values)
        s.select { |server| server.select?(options) }
      end

      def role_properties_for(rolenames)
        roles = rolenames.to_set
        rps = Set.new unless block_given?
        roles_for(rolenames).each do |host|
          host.roles.intersection(roles).each do |role|
            [host.properties.fetch(role)].flatten(1).each do |props|
              if block_given?
                yield host, role, props
              else
                rps << (props || {}).merge(role: role, hostname: host.hostname)
              end
            end
          end
        end
        block_given? ? nil : rps
      end

      def fetch_primary(role)
        hosts = roles_for([role])
        hosts.find(&:primary) || hosts.first
      end

      def each
        servers_by_key.values.each { |server| yield server }
      end

      private

      ServerKey = Struct.new(:hostname, :port)

      def servers_by_key
        @servers_by_key ||= {}
      end

      def extract_options(array)
        array.last.is_a?(::Hash) ? array.pop : {}
      end
    end
  end
module Capistrano
  class Configuration
    class Question
      def initialize(key, default, options={})
        @key = key
        @default = default
        @options = options
      end

      def call
        ask_question
        value_or_default
      end

      private

      attr_reader :key, :default, :options

      def ask_question
        $stdout.print question
        $stdout.flush
      end

      def value_or_default
        if response.empty?
          default
        else
          response
        end
      end

      def response
        return @response if defined? @response

        @response = (gets || "").chomp
      end

      def gets
        return unless stdin.tty?

        if echo?
          stdin.gets
        else
          stdin.noecho(&:gets).tap { $stdout.print "\n" }
        end
      rescue Errno::EIO
        # when stdio gets closed
        return
      end

      def question
        if prompt && default.nil?
          I18n.t(:question_prompt, key: prompt, scope: :capistrano)
        elsif prompt
          I18n.t(:question_prompt_default, key: prompt, default_value: default, scope: :capistrano)
        elsif default.nil?
          I18n.t(:question, key: key, scope: :capistrano)
        else
          I18n.t(:question_default, key: key, default_value: default, scope: :capistrano)
        end
      end

      def echo?
        (options || {}).fetch(:echo, true)
      end

      def stdin
        (options || {}).fetch(:stdin, $stdin)
      end

      def prompt
        (options || {}).fetch(:prompt, nil)
      end
    end
  end
module Capistrano
  class Configuration
    class EmptyFilter
      def filter(_servers)
        []
require "capistrano/proc_helpers"

module Capistrano
  class Configuration
    # Holds the variables assigned at Capistrano runtime via `set` and retrieved
    # with `fetch`. Does internal bookkeeping to help identify user mistakes
    # like spelling errors or unused variables that may lead to unexpected
    # behavior.
    class Variables
      CAPISTRANO_LOCATION = File.expand_path("../..", __FILE__).freeze
      IGNORED_LOCATIONS = [
        "#{CAPISTRANO_LOCATION}/configuration/variables.rb:",
        "#{CAPISTRANO_LOCATION}/configuration.rb:",
        "#{CAPISTRANO_LOCATION}/dsl/env.rb:",
        "/dsl.rb:",
        "/forwardable.rb:"
      ].freeze
      private_constant :CAPISTRANO_LOCATION, :IGNORED_LOCATIONS

      include Capistrano::ProcHelpers

      def initialize(values={})
        @trusted_keys = []
        @fetched_keys = []
        @locations = {}
        @values = values
        @trusted = true
      end

      def untrusted!
        @trusted = false
        yield
      ensure
        @trusted = true
      end

      def set(key, value=nil, &block)
        @trusted_keys << key if trusted? && !@trusted_keys.include?(key)
        remember_location(key)
        values[key] = block || value
        trace_set(key)
        values[key]
      end

      def fetch(key, default=nil, &block)
        fetched_keys << key unless fetched_keys.include?(key)
        peek(key, default, &block)
      end

      # Internal use only.
      def peek(key, default=nil, &block)
        value = fetch_for(key, default, &block)
        while callable_without_parameters?(value)
          value = (values[key] = value.call)
        end
        value
      end

      def fetch_for(key, default, &block)
        block ? values.fetch(key, &block) : values.fetch(key, default)
      end

      def delete(key)
        values.delete(key)
      end

      def trusted_keys
        @trusted_keys.dup
      end

      def untrusted_keys
        keys - @trusted_keys
      end

      def keys
        values.keys
      end

      # Keys that have been set, but which have never been fetched.
      def unused_keys
        keys - fetched_keys
      end

      # Returns an array of source file location(s) where the given key was
      # assigned (i.e. where `set` was called). If the key was never assigned,
      # returns `nil`.
      def source_locations(key)
        locations[key]
      end

      private

      attr_reader :locations, :values, :fetched_keys

      def trusted?
        @trusted
      end

      def remember_location(key)
        location = caller.find do |line|
          IGNORED_LOCATIONS.none? { |i| line.include?(i) }
        end
        (locations[key] ||= []) << location
      end

      def trace_set(key)
        return unless fetch(:print_config_variables, false)
        puts "Config variable set: #{key.inspect} => #{values[key].inspect}"
      end
    end
module Capistrano
  class Configuration
    class HostFilter
      def initialize(values)
        av = Array(values).dup
        av = av.flat_map { |v| v.is_a?(String) && v =~ /^(?<name>[-A-Za-z0-9.]+)(,\g<name>)*$/ ? v.split(",") : v }
        @rex = regex_matcher(av)
      end

      def filter(servers)
        Array(servers).select { |s| @rex.match s.to_s }
      end

      private

      def regex_matcher(values)
        values.map! do |v|
          case v
          when Regexp then v
          else
            vs = v.to_s
            vs =~ /^[-A-Za-z0-9.]+$/ ? /^#{Regexp.quote(vs)}$/ : Regexp.new(vs)
          end
        end
        Regexp.union values
# Encapsulates the logic for installing plugins into Capistrano. Plugins must
# simply conform to a basic API; the PluginInstaller takes care of invoking the
# API at appropriate times.
#
# This class is not used directly; instead it is typically accessed via the
# `install_plugin` method of the Capistrano DSL.
#
module Capistrano
  class Configuration
    class PluginInstaller
      # "Installs" a Plugin into Capistrano by loading its tasks, hooks, and
      # defaults at the appropriate time. The hooks in particular can be
      # skipped, if you want full control over when and how the plugin's tasks
      # are executed. Simply pass `load_hooks:false` to opt out.
      #
      # The plugin class or instance may be provided. These are equivalent:
      #
      # install(Capistrano::SCM::Git)
      # install(Capistrano::SCM::Git.new)
      #
      # Note that the :load_immediately flag is for internal use only and will
      # be removed in an upcoming release.
      #
      def install(plugin, load_hooks: true, load_immediately: false)
        plugin = plugin.is_a?(Class) ? plugin.new : plugin

        plugin.define_tasks
        plugin.register_hooks if load_hooks
        @scm_installed ||= provides_scm?(plugin)

        if load_immediately
          plugin.set_defaults
        else
          Rake::Task.define_task("load:defaults") do
            plugin.set_defaults
          end
        end
      end

      def scm_installed?
        @scm_installed
      end

      private

      def provides_scm?(plugin)
        plugin.respond_to?(:scm?) && plugin.scm?
      end
    end
  end
require "capistrano/proc_helpers"
require "delegate"

module Capistrano
  class Configuration
    # Decorates a Variables object to additionally perform an optional set of
    # user-supplied validation rules. Each rule for a given key is invoked
    # immediately whenever `set` is called with a value for that key.
    #
    # If `set` is called with a callable value or a block, validation is not
    # performed immediately. Instead, the validation rules are invoked the first
    # time `fetch` is used to access the value.
    #
    # A rule is simply a block that accepts two arguments: key and value. It is
    # up to the rule to raise an exception when it deems the value is invalid
    # (or just print a warning).
    #
    # Rules can be registered using the DSL like this:
    #
    #   validate(:my_key) do |key, value|
    #     # rule goes here
    #   end
    #
    class ValidatedVariables < SimpleDelegator
      include Capistrano::ProcHelpers

      def initialize(variables)
        super(variables)
        @validators = {}
      end

      # Decorate Variables#set to add validation behavior.
      def set(key, value=nil, &block)
        assert_value_or_block_not_both(value, block)

        # Skip validation behavior if no validators are registered for this key
        return super unless validators.key?(key)

        value_to_evaluate = block || value

        if callable_without_parameters?(value_to_evaluate)
          super(key, assert_valid_later(key, value_to_evaluate), &nil)
        else
          assert_valid_now(key, value_to_evaluate)
          super
        end
      end

      # Register a validation rule for the given key.
      def validate(key, &validator)
        vs = (validators[key] || [])
        vs << validator
        validators[key] = vs
      end

      private

      attr_reader :validators

      # Given a callable that provides a value, wrap the callable with another
      # object that responds to `call`. This new object will perform validation
      # and then return the original callable's value.
      #
      # If the callable is a `Question`, the object returned by this method will
      # also be a `Question` (a `ValidatedQuestion`, to be precise). This
      # ensures that `is_a?(Question)` remains true even after the validation
      # wrapper is applied. This is needed so that `Configuration#is_question?`
      # works as expected.
      #
      def assert_valid_later(key, callable)
        validation_callback = lambda do
          value = callable.call
          assert_valid_now(key, value)
          value
        end

        if callable.is_a?(Question)
          ValidatedQuestion.new(validation_callback)
        else
          validation_callback
        end
      end

      # Runs all validation rules registered for the given key against the
      # user-supplied value for that variable. If no validator raises an
      # exception, the value is assumed to be valid.
      def assert_valid_now(key, value)
        validators[key].each do |validator|
          validator.call(key, value)
        end
      end

      def assert_value_or_block_not_both(value, block)
        return if value.nil? || block.nil?
        raise Capistrano::ValidationError,
              "Value and block both passed to Configuration#set"
      end

      class ValidatedQuestion < Question
        def initialize(validator)
          @validator = validator
        end

        def call
          @validator.call
require "capistrano/doctor/output_helpers"

module Capistrano
  module Doctor
    class ServersDoctor
      include Capistrano::Doctor::OutputHelpers

      def initialize(env=Capistrano::Configuration.env)
        @servers = env.servers.to_a
      end

      def call
        title("Servers (#{servers.size})")
        rwc = RoleWhitespaceChecker.new(servers)

        table(servers) do |server, row|
          sd = ServerDecorator.new(server)

          row << sd.uri_form
          row << sd.roles
          row << sd.properties
          row.yellow if rwc.any_has_whitespace?(server.roles)
        end

        if rwc.whitespace_roles.any?
          warning "\nWhitespace detected in role(s) #{rwc.whitespace_roles_decorated}. " \
            "This might be a result of a mistyped \"%w()\" array literal."
        end
        puts
      end

      private

      attr_reader :servers

      class RoleWhitespaceChecker
        attr_reader :whitespace_roles, :servers

        def initialize(servers)
          @servers = servers
          @whitespace_roles = find_whitespace_roles
        end

        def any_has_whitespace?(roles)
          roles.any? { |role| include_whitespace?(role) }
        end

        def include_whitespace?(role)
          role =~ /\s/
        end

        def whitespace_roles_decorated
          whitespace_roles.map(&:inspect).join(", ")
        end

        private

        def find_whitespace_roles
          servers.map(&:roles).flat_map(&:to_a).uniq
                 .select { |role| include_whitespace?(role) }
        end
      end

      class ServerDecorator
        def initialize(server)
          @server = server
        end

        def uri_form
          [
            server.user,
            server.user && "@",
            server.hostname,
            server.port && ":",
            server.port
          ].compact.join
        end

        def roles
          server.roles.to_a.inspect
        end

        def properties
          return "" unless server.properties.keys.any?
          pretty_inspect(server.properties.to_h)
        end

        private

        attr_reader :server

        # Hashes with proper padding
        def pretty_inspect(element)
          return element.inspect unless element.is_a?(Hash)

          pairs_string = element.keys.map do |key|
            [pretty_inspect(key), pretty_inspect(element.fetch(key))].join(" => ")
          end.join(", ")

          "{ #{pairs_string} }"
require "capistrano/doctor/output_helpers"

module Capistrano
  module Doctor
    class EnvironmentDoctor
      include Capistrano::Doctor::OutputHelpers

      def call
        title("Environment")
        puts <<-OUT.gsub(/^\s+/, "")
          Ruby     #{RUBY_DESCRIPTION}
          Rubygems #{Gem::VERSION}
          Bundler  #{defined?(Bundler::VERSION) ? Bundler::VERSION : 'N/A'}
          Command  #{$PROGRAM_NAME} #{ARGV.join(' ')}
        OUT
module Capistrano
  module Doctor
    # Helper methods for pretty-printing doctor output to stdout. All output
    # (other than `title`) is indented by four spaces to facilitate copying and
    # pasting this output into e.g. GitHub or Stack Overflow to achieve code
    # formatting.
    module OutputHelpers
      class Row
        attr_reader :color
        attr_reader :values

        def initialize
          @values = []
        end

        def <<(value)
          values << value
        end

        def yellow
          @color = :yellow
        end
      end

      # Prints a table for a given array of records. For each record, the block
      # is yielded two arguments: the record and a Row object. To print values
      # for that record, add values using `row << "some value"`. A row can
      # optionally be highlighted in yellow using `row.yellow`.
      def table(records, &block)
        return if records.empty?
        rows = collect_rows(records, &block)
        col_widths = calculate_column_widths(rows)

        rows.each do |row|
          line = row.values.each_with_index.map do |value, col|
            value.to_s.ljust(col_widths[col])
          end.join(" ").rstrip
          line = color.colorize(line, row.color) if row.color
          puts line
        end
      end

      # Prints a title in blue with surrounding newlines.
      def title(text)
        # Use $stdout directly to bypass the indentation that our `puts` does.
        $stdout.puts(color.colorize("\n#{text}\n", :blue))
      end

      # Prints text in yellow.
      def warning(text)
        puts color.colorize(text, :yellow)
      end

      # Override `Kernel#puts` to prepend four spaces to each line.
      def puts(string=nil)
        $stdout.puts(string.to_s.gsub(/^/, "    "))
      end

      private

      def collect_rows(records)
        records.map do |rec|
          Row.new.tap { |row| yield(rec, row) }
        end
      end

      def calculate_column_widths(rows)
        num_columns = rows.map { |row| row.values.length }.max
        Array.new(num_columns) do |col|
          rows.map { |row| row.values[col].to_s.length }.max
        end
      end

      def color
        @color ||= SSHKit::Color.new($stdout)
require "capistrano/doctor/output_helpers"

module Capistrano
  module Doctor
    # Prints table of all Capistrano-related gems and their version numbers. If
    # there is a newer version of a gem available, call attention to it.
    class GemsDoctor
      include Capistrano::Doctor::OutputHelpers

      def call
        title("Gems")
        table(all_gem_names) do |gem, row|
          row.yellow if update_available?(gem)
          row << gem
          row << installed_gem_version(gem)
          row << "(update available)" if update_available?(gem)
        end
      end

      private

      def installed_gem_version(gem_name)
        Gem.loaded_specs[gem_name].version
      end

      def update_available?(gem_name)
        latest = Gem.latest_version_for(gem_name)
        return false if latest.nil?
        latest > installed_gem_version(gem_name)
      end

      def all_gem_names
        core_gem_names + plugin_gem_names
      end

      def core_gem_names
        %w(capistrano airbrussh rake sshkit net-ssh) & Gem.loaded_specs.keys
      end

      def plugin_gem_names
require "capistrano/doctor/output_helpers"

module Capistrano
  module Doctor
    # Prints a table of all Capistrano variables and their current values. If
    # there are unrecognized variables, print warnings for them.
    class VariablesDoctor
      # These are keys that are recognized by Capistrano, but do not have values
      # set by default.
      WHITELIST = %i(
        application
        current_directory
        releases_directory
        repo_url
        repo_tree
        shared_directory
      ).freeze
      private_constant :WHITELIST

      include Capistrano::Doctor::OutputHelpers

      def initialize(env=Capistrano::Configuration.env)
        @env = env
      end

      def call
        title("Variables")
        values = inspect_all_values

        table(variables.keys.sort_by(&:to_s)) do |key, row|
          row.yellow if suspicious_keys.include?(key)
          row << key.inspect
          row << values[key]
        end

        puts if suspicious_keys.any?

        suspicious_keys.sort_by(&:to_s).each do |key|
          warning("#{key.inspect} is not a recognized Capistrano setting "\
                  "(#{location(key)})")
        end
      end

      private

      attr_reader :env

      def variables
        env.variables
      end

      def inspect_all_values
        variables.keys.each_with_object({}) do |key, inspected|
          inspected[key] = if env.is_question?(key)
                             "<ask>"
                           else
                             variables.peek(key).inspect
                           end
        end
      end

      def suspicious_keys
        (variables.untrusted_keys & variables.unused_keys) - WHITELIST
      end

      def location(key)
        loc = variables.source_locations(key).first
        loc && loc.sub(/^#{Regexp.quote(Dir.pwd)}/, "").sub(/:in.*/, "")
      end
    end
require "capistrano/dsl/task_enhancements"
require "capistrano/dsl/paths"
require "capistrano/dsl/stages"
require "capistrano/dsl/env"
require "capistrano/configuration/filter"

module Capistrano
  module DSL
    include TaskEnhancements
    include Env
    include Paths
    include Stages

    def invoke(task_name, *args)
      task = Rake::Task[task_name]
      # NOTE: We access instance variable since the accessor was only added recently. Once Capistrano depends on rake 11+, we can revert the following line
      if task && task.instance_variable_get(:@already_invoked)
        file, line, = caller.first.split(":")
        colors = SSHKit::Color.new($stderr)
        $stderr.puts colors.colorize("Skipping task `#{task_name}'.", :yellow)
        $stderr.puts "Capistrano tasks may only be invoked once. Since task `#{task}' was previously invoked, invoke(\"#{task_name}\") at #{file}:#{line} will be skipped."
        $stderr.puts "If you really meant to run this task again, use invoke!(\"#{task_name}\")"
        $stderr.puts colors.colorize("THIS BEHAVIOR MAY CHANGE IN A FUTURE VERSION OF CAPISTRANO. Please join the conversation here if this affects you.", :red)
        $stderr.puts colors.colorize("https://github.com/capistrano/capistrano/issues/1686", :red)
      end
      task.invoke(*args)
    end

    def invoke!(task_name, *args)
      task = Rake::Task[task_name]
      task.reenable
      task.invoke(*args)
    end

    def t(key, options={})
      I18n.t(key, **options.merge(scope: :capistrano))
    end

    def scm
      fetch(:scm)
    end

    def sudo(*args)
      execute :sudo, *args
    end

    def revision_log_message
      fetch(:revision_log_message,
            t(:revision_log_message,
              branch: fetch(:branch),
              user: local_user,
              sha: fetch(:current_revision),
              release: fetch(:release_timestamp)))
    end

    def rollback_log_message
      t(:rollback_log_message, user: local_user, release: fetch(:rollback_timestamp))
    end

    def local_user
      fetch(:local_user)
    end

    def lock(locked_version)
      VersionValidator.new(locked_version).verify
    end

    # rubocop:disable Security/MarshalLoad
    def on(hosts, options={}, &block)
      subset_copy = Marshal.dump(Configuration.env.filter(hosts))
      SSHKit::Coordinator.new(Marshal.load(subset_copy)).each(options, &block)
    end
    # rubocop:enable Security/MarshalLoad

    def run_locally(&block)
      SSHKit::Backend::Local.new(&block).run
    end

    # Catch common beginner mistake and give a helpful error message on stderr
    def execute(*)
      file, line, = caller.first.split(":")
      colors = SSHKit::Color.new($stderr)
      $stderr.puts colors.colorize("Warning: `execute' should be wrapped in an `on' scope in #{file}:#{line}.", :red)
      $stderr.puts
      $stderr.puts "  task :example do"
      $stderr.puts colors.colorize("    on roles(:app) do", :yellow)
      $stderr.puts "      execute 'whoami'"
      $stderr.puts colors.colorize("    end", :yellow)
      $stderr.puts "  end"
      $stderr.puts
validate :application do |_key, value|
  changed_value = value.gsub(/[^A-Z0-9\.\-]/i, "_")
  if value != changed_value
    warn %Q(The :application value "#{value}" is invalid!)
    warn "Use only letters, numbers, hyphens, dots, and underscores. For example:"
    warn "  set :application, '#{changed_value}'"
    raise Capistrano::ValidationError
  end
end

%i(git_strategy hg_strategy svn_strategy).each do |strategy|
  validate(strategy) do |key, _value|
    warn(
      "[Deprecation Warning] #{key} is deprecated and will be removed in "\
      "Capistrano 3.7.0.\n"\
      "https://github.com/capistrano/capistrano/blob/master/UPGRADING-3.7.md"
    )
  end
end

# We use a special :_default_git value so that SCMResolver can tell whether the
# default has been replaced by the user via `set`.
set_if_empty :scm, Capistrano::Configuration::SCMResolver::DEFAULT_GIT
set_if_empty :branch, "master"
set_if_empty :deploy_to, -> { "/var/www/#{fetch(:application)}" }
set_if_empty :tmp_dir, "/tmp"

set_if_empty :default_env, {}
set_if_empty :keep_releases, 5

set_if_empty :format, :airbrussh
set_if_empty :log_level, :debug

set_if_empty :pty, false

require "capistrano/all"
require "rake/tasklib"

# IMPORTANT: The Capistrano::Plugin system is not yet considered a stable,
# public API, and is subject to change without notice. Eventually it will be
# officially documented and supported, but for now, use it at your own risk.
#
# Base class for Capistrano plugins. Makes building a Capistrano plugin as easy
# as writing a `Capistrano::Plugin` subclass and overriding any or all of its
# three template methods:
#
# * set_defaults
# * register_hooks
# * define_tasks
#
# Within the plugin you can use any methods of the Rake or Capistrano DSLs, like
# `fetch`, `invoke`, etc. In cases when you need to use SSHKit's backend outside
# of an `on` block, use the `backend` convenience method. E.g. `backend.test`,
# `backend.execute`, or `backend.capture`.
#
# Package up and distribute your plugin class as a gem and you're good to go!
#
# To use a plugin, all a user has to do is install it in the Capfile, like this:
#
#   # Capfile
#   require "capistrano/superfancy"
#   install_plugin Capistrano::Superfancy
#
# Or, to install the plugin without its hooks:
#
#   # Capfile
#   require "capistrano/superfancy"
#   install_plugin Capistrano::Superfancy, load_hooks: false
#
class Capistrano::Plugin < Rake::TaskLib
  include Capistrano::DSL

  # Implemented by subclasses to provide default values for settings needed by
  # this plugin. Typically done using the `set_if_empty` Capistrano DSL method.
  #
  # Example:
  #
  #   def set_defaults
  #     set_if_empty :my_plugin_option, true
  #   end
  #
  def set_defaults; end

  # Implemented by subclasses to hook into Capistrano's deployment flow using
  # using the `before` and `after` DSL methods. Note that `register_hooks` will
  # not be called if the user has opted-out of hooks when installing the plugin.
  #
  # Example:
  #
  #   def register_hooks
  #     after "deploy:updated", "my_plugin:do_something"
  #   end
  #
  def register_hooks; end

  # Implemented by subclasses to define Rake tasks. Typically a plugin will call
  # `eval_rakefile` to load Rake tasks from a separate .rake file.
  #
  # Example:
  #
  #   def define_tasks
  #     eval_rakefile File.expand_path("../tasks.rake", __FILE__)
  #   end
  #
  # For simple tasks, you can define them inline. No need for a separate file.
  #
  #   def define_tasks
  #     desc "Do something fantastic."
  #     task "my_plugin:fantastic" do
  #       ...
  #     end
  #   end
  #
  def define_tasks; end

  private

  # Read and eval a .rake file in such a way that `self` within the .rake file
  # refers to this plugin instance. This gives the tasks in the file access to
  # helper methods defined by the plugin.
  def eval_rakefile(path)
    contents = IO.read(path)
    instance_eval(contents, path, 1)
  end

require "capistrano/doctor"
require "capistrano/immutable_task"
include Capistrano::DSL

namespace :load do
  task :defaults do
    load "capistrano/defaults.rb"
  end
end

require "airbrussh/capistrano"
# We don't need to show the "using Airbrussh" banner announcement since
# Airbrussh is now the built-in formatter. Also enable command output by
# default; hiding the output might be confusing to users new to Capistrano.
Airbrussh.configure do |airbrussh|
  airbrussh.banner = false
  airbrussh.command_output = true
end

stages.each do |stage|
  Rake::Task.define_task(stage) do
    set(:stage, stage.to_sym)

    invoke "load:defaults"
    Rake.application["load:defaults"].extend(Capistrano::ImmutableTask)
    env.variables.untrusted! do
      load deploy_config_path
      load stage_config_path.join("#{stage}.rb")
    end
    configure_scm
    I18n.locale = fetch(:locale, :en)
    configure_backend
  end
end

require "capistrano/scm/plugin"
require "cgi"
require "securerandom"
require "shellwords"
require "uri"

class Capistrano::SCM::Git < Capistrano::SCM::Plugin
  def set_defaults
    set_if_empty :git_shallow_clone, false
    set_if_empty :git_wrapper_path, lambda {
      # Use a unique name that won't collide with other deployments, and
      # that cannot be guessed by other processes that have access to /tmp.
      "#{fetch(:tmp_dir)}/git-ssh-#{SecureRandom.hex(10)}.sh"
    }
    set_if_empty :git_environmental_variables, lambda {
      {
        git_askpass: "/bin/echo",
        git_ssh: fetch(:git_wrapper_path)
      }
    }
    set_if_empty :git_max_concurrent_connections, 10
    set_if_empty :git_wait_interval, 0
  end

  def register_hooks
    after "deploy:new_release_path", "git:create_release"
    before "deploy:check", "git:check"
    before "deploy:set_current_revision", "git:set_current_revision"
  end

  def define_tasks
    eval_rakefile File.expand_path("../tasks/git.rake", __FILE__)
  end

  def repo_mirror_exists?
    backend.test " [ -f #{repo_path}/HEAD ] "
  end

  def check_repo_is_reachable
    git :'ls-remote', git_repo_url, "HEAD"
  end

  def clone_repo
    if (depth = fetch(:git_shallow_clone))
      git :clone, "--mirror", "--depth", depth, "--no-single-branch", git_repo_url, repo_path.to_s
    else
      git :clone, "--mirror", git_repo_url, repo_path.to_s
    end
  end

  def update_mirror
    # Update the origin URL if necessary.
    git :remote, "set-url", "origin", git_repo_url

    # Note: Requires git version 1.9 or greater
    if (depth = fetch(:git_shallow_clone))
      git :fetch, "--depth", depth, "origin", fetch(:branch)
    else
      git :remote, :update, "--prune"
    end
  end

  def archive_to_release_path
    if (tree = fetch(:repo_tree))
      tree = tree.slice %r#^/?(.*?)/?$#, 1
      components = tree.split("/").size
      git :archive, fetch(:branch), tree, "| #{SSHKit.config.command_map[:tar]} -x --strip-components #{components} -f - -C", release_path
    else
      git :archive, fetch(:branch), "| #{SSHKit.config.command_map[:tar]} -x -f - -C", release_path
    end
  end

  def fetch_revision
    backend.capture(:git, "rev-list --max-count=1 #{fetch(:branch)}")
  end

  def git(*args)
    args.unshift :git
    backend.execute(*args)
  end

  def git_repo_url
    if fetch(:git_http_username) && fetch(:git_http_password)
      URI.parse(repo_url).tap do |repo_uri|
        repo_uri.user     = fetch(:git_http_username)
        repo_uri.password = CGI.escape(fetch(:git_http_password))
      end.to_s
    elsif fetch(:git_http_username)
      URI.parse(repo_url).tap do |repo_uri|
        repo_uri.user = fetch(:git_http_username)
      end.to_s
    else
      repo_url
    end
  end
require "capistrano/scm/plugin"

class Capistrano::SCM::Svn < Capistrano::SCM::Plugin
  def register_hooks
    after "deploy:new_release_path", "svn:create_release"
    before "deploy:check", "svn:check"
    before "deploy:set_current_revision", "svn:set_current_revision"
  end

  def define_tasks
    eval_rakefile File.expand_path("../tasks/svn.rake", __FILE__)
  end

  def svn(*args)
    args.unshift(:svn)
    args.push "--username #{fetch(:svn_username)}" if fetch(:svn_username)
    args.push "--password #{fetch(:svn_password)}" if fetch(:svn_password)
    args.push "--revision #{fetch(:svn_revision)}" if fetch(:svn_revision)
    backend.execute(*args)
  end

  def repo_mirror_exists?
    backend.test " [ -d #{repo_path}/.svn ] "
  end

  def check_repo_is_reachable
    svn_username = fetch(:svn_username) ? "--username #{fetch(:svn_username)}" : ""
    svn_password = fetch(:svn_password) ? "--password #{fetch(:svn_password)}" : ""
    backend.test :svn, :info, repo_url, svn_username, svn_password
  end

  def clone_repo
    svn :checkout, repo_url, repo_path.to_s
  end

  def update_mirror
    # Switch the repository URL if necessary.
    repo_mirror_url = fetch_repo_mirror_url
    svn :switch, repo_url unless repo_mirror_url == repo_url
    svn :update
  end

  def archive_to_release_path
    svn :export, "--force", ".", release_path
  end

  def fetch_revision
    backend.capture(:svnversion, repo_path.to_s)
  end

  def fetch_repo_mirror_url
    backend.capture(:svn, :info, repo_path.to_s).each_line do |line|
      return $1 if /\AURL: (.*)\n\z/ =~ line
    end
  end
require "capistrano/scm/plugin"
require "securerandom"

class Capistrano::SCM::Hg < Capistrano::SCM::Plugin
  def register_hooks
    after "deploy:new_release_path", "hg:create_release"
    before "deploy:check", "hg:check"
    before "deploy:set_current_revision", "hg:set_current_revision"
  end

  def define_tasks
    eval_rakefile File.expand_path("../tasks/hg.rake", __FILE__)
  end

  def hg(*args)
    args.unshift(:hg)
    backend.execute(*args)
  end

  def repo_mirror_exists?
    backend.test " [ -d #{repo_path}/.hg ] "
  end

  def check_repo_is_reachable
    hg "id", repo_url
  end

  def clone_repo
    hg "clone", "--noupdate", repo_url, repo_path.to_s
  end

  def update_mirror
    hg "pull"
  end

  def archive_to_release_path
    if (tree = fetch(:repo_tree))
      tree = tree.slice %r#^/?(.*?)/?$#, 1
      components = tree.split("/").size
      temp_tar = "#{fetch(:tmp_dir)}/#{SecureRandom.hex(10)}.tar"

      hg "archive -p . -I", tree, "--rev", fetch(:branch), temp_tar

      backend.execute :mkdir, "-p", release_path
      backend.execute :tar, "-x --strip-components #{components} -f", temp_tar, "-C", release_path
      backend.execute :rm, temp_tar
    else
      hg "archive", release_path, "--rev", fetch(:branch)
    end
  end
require "capistrano/plugin"
require "capistrano/scm"

# Base class for all built-in and third-party SCM plugins. Notice that this
# class doesn't really do anything other than provide an `scm?` predicate. This
# tells Capistrano that the plugin provides SCM functionality. All other plugin
# features are inherited from Capistrano::Plugin.
#
class Capistrano::SCM::Plugin < Capistrano::Plugin
  def scm?
module Capistrano
  module ProcHelpers
    module_function

    # Tests whether the given object appears to respond to `call` with
    # zero parameters. In Capistrano, such a proc is used to represent a
    # "deferred value". That is, a value that is resolved by invoking `call` at
    # the time it is first needed.
    def callable_without_parameters?(x)
      x.respond_to?(:call) && (!x.respond_to?(:arity) || x.arity.zero?)
require "spec_helper"

describe Capistrano::Application do
  it "provides a --trace option which enables SSHKit/NetSSH trace output"

  it "provides a --format option which enables the choice of output formatting"

  it "displays documentation URL as help banner", capture_io: true do
    flags "--help", "-h"
    expect($stdout.string.each_line.first).to match(/capistranorb.com/)
  end

  %w(quiet silent verbose).each do |switch|
    it "doesn't include --#{switch} in help", capture_io: true do
      flags "--help", "-h"
      expect($stdout.string).not_to match(/--#{switch}/)
    end
  end

  it "overrides the rake method, but still prints the rake version", capture_io: true do
    flags "--version", "-V"
    out = $stdout.string
    expect(out).to match(/\bCapistrano Version\b/)
    expect(out).to match(/\b#{Capistrano::VERSION}\b/)
    expect(out).to match(/\bRake Version\b/)
    expect(out).to match(/\b#{Rake::VERSION}\b/)
  end

  it "overrides the rake method, and sets the sshkit_backend to SSHKit::Backend::Printer", capture_io: true do
    flags "--dry-run", "-n"
    sshkit_backend = Capistrano::Configuration.fetch(:sshkit_backend)
    expect(sshkit_backend).to eq(SSHKit::Backend::Printer)
  end

  it "enables printing all config variables on command line parameter", capture_io: true do
    begin
      flags "--print-config-variables", "-p"
      expect(Capistrano::Configuration.fetch(:print_config_variables)).to be true
    ensure
      Capistrano::Configuration.reset!
    end
  end

  def flags(*sets)
    sets.each do |set|
      ARGV.clear
      @exit = catch(:system_exit) { command_line(*set) }
    end
    yield(subject.options) if block_given?
  end

  def command_line(*options)
    options.each { |opt| ARGV << opt }
    subject.define_singleton_method(:exit) do |*_args|
      throw(:system_exit, :exit)
require "spec_helper"

describe Capistrano::UploadTask do
  let(:app) { Rake.application = Rake::Application.new }

  subject(:upload_task) { described_class.define_task("path/file.yml") }

  it { is_expected.to be_a(Rake::FileCreationTask) }
  it { is_expected.to be_needed }

  context "inside namespace" do
    let(:normal_task) { Rake::Task.define_task("path/other_file.yml") }

    around { |ex| app.in_namespace("namespace", &ex) }

require "spec_helper"

module Capistrano
  describe Configuration do
    let(:config) { Configuration.new }
    let(:servers) { stub }

    describe ".new" do
      it "accepts initial hash" do
        configuration = described_class.new(custom: "value")
        expect(configuration.fetch(:custom)).to eq("value")
      end
    end

    describe ".env" do
      it "is a global accessor to a single instance" do
        Configuration.env.set(:test, true)
        expect(Configuration.env.fetch(:test)).to be_truthy
      end
    end

    describe ".reset!" do
      it "blows away the existing `env` and creates a new one" do
        old_env = Configuration.env
        Configuration.reset!
        expect(Configuration.env).not_to be old_env
      end
    end

    describe "roles" do
      context "adding a role" do
        subject { config.role(:app, %w{server1 server2}) }

        before do
          Configuration::Servers.expects(:new).returns(servers)
          servers.expects(:add_role).with(:app, %w{server1 server2}, {})
        end

        it "adds the role" do
          expect(subject)
        end
      end
    end

    describe "setting and fetching" do
      subject { config.fetch(:key, :default) }

      context "set" do
        it "sets by value" do
          config.set(:key, :value)
          expect(subject).to eq :value
        end

        it "sets by block" do
          config.set(:key) { :value }
          expect(subject).to eq :value
        end

        it "raises an exception when given both a value and block" do
          expect { config.set(:key, :value) { :value } }.to raise_error(Capistrano::ValidationError)
        end
      end

      context "set_if_empty" do
        it "sets by value when none is present" do
          config.set_if_empty(:key, :value)
          expect(subject).to eq :value
        end

        it "sets by block when none is present" do
          config.set_if_empty(:key) { :value }
          expect(subject).to eq :value
        end

        it "does not overwrite existing values" do
          config.set(:key, :value)
          config.set_if_empty(:key, :update)
          config.set_if_empty(:key) { :update }
          expect(subject).to eq :value
        end
      end

      context "value is not set" do
        it "returns the default value" do
          expect(subject).to eq :default
        end
      end

      context "value is a proc" do
        subject { config.fetch(:key, proc { :proc }) }
        it "calls the proc" do
          expect(subject).to eq :proc
        end
      end

      context "value is a lambda" do
        subject { config.fetch(:key, -> { :lambda }) }
        it "calls the lambda" do
          expect(subject).to eq :lambda
        end
      end

      context "value inside proc inside a proc" do
        subject { config.fetch(:key, proc { proc { "some value" } }) }
        it "calls all procs and lambdas" do
          expect(subject).to eq "some value"
        end
      end

      context "value inside lambda inside a lambda" do
        subject { config.fetch(:key, -> { -> { "some value" } }) }
        it "calls all procs and lambdas" do
          expect(subject).to eq "some value"
        end
      end

      context "value inside lambda inside a proc" do
        subject { config.fetch(:key, proc { -> { "some value" } }) }
        it "calls all procs and lambdas" do
          expect(subject).to eq "some value"
        end
      end

      context "value inside proc inside a lambda" do
        subject { config.fetch(:key, -> { proc { "some value" } }) }
        it "calls all procs and lambdas" do
          expect(subject).to eq "some value"
        end
      end

      context "lambda with parameters" do
        subject { config.fetch(:key, ->(c) { c }).call(42) }
        it "is returned as a lambda" do
          expect(subject).to eq 42
        end
      end

      context "block is passed to fetch" do
        subject { config.fetch(:key, :default) { raise "we need this!" } }

        it "returns the block value" do
          expect { subject }.to raise_error(RuntimeError)
        end
      end

      context "validations" do
        before do
          config.validate :key do |_, value|
            raise Capistrano::ValidationError unless value.length > 3
          end
        end

        it "validates string without error" do
          config.set(:key, "longer_value")
        end

        it "validates block without error" do
          config.set(:key) { "longer_value" }
          expect(config.fetch(:key)).to eq "longer_value"
        end

        it "validates lambda without error" do
          config.set :key, -> { "longer_value" }
          expect(config.fetch(:key)).to eq "longer_value"
        end

        it "raises an exception on invalid string" do
          expect { config.set(:key, "sho") }.to raise_error(Capistrano::ValidationError)
        end

        it "raises an exception on invalid string provided by block" do
          config.set(:key) { "sho" }
          expect { config.fetch(:key) }.to raise_error(Capistrano::ValidationError)
        end

        it "raises an exception on invalid string provided by lambda" do
          config.set :key, -> { "sho" }
          expect { config.fetch(:key) }.to raise_error(Capistrano::ValidationError)
        end
      end

      context "appending" do
        subject { config.append(:linked_dirs, "vendor/bundle", "tmp") }

        it "returns appended value" do
          expect(subject).to eq ["vendor/bundle", "tmp"]
        end

        context "on non-array variable" do
          before { config.set(:linked_dirs, "string") }
          subject { config.append(:linked_dirs, "vendor/bundle") }

          it "returns appended value" do
            expect(subject).to eq ["string", "vendor/bundle"]
          end
        end
      end

      context "removing" do
        before :each do
          config.set(:linked_dirs, ["vendor/bundle", "tmp"])
        end

        subject { config.remove(:linked_dirs, "vendor/bundle") }

        it "returns without removed value" do
          expect(subject).to eq ["tmp"]
        end

        context "on non-array variable" do
          before { config.set(:linked_dirs, "string") }

          context "when removing same value" do
            subject { config.remove(:linked_dirs, "string") }

            it "returns without removed value" do
              expect(subject).to eq []
            end
          end

          context "when removing different value" do
            subject { config.remove(:linked_dirs, "othervalue") }

            it "returns without removed value" do
              expect(subject).to eq ["string"]
            end
          end
        end
      end
    end

    describe "keys" do
      subject { config.keys }

      before do
        config.set(:key1, :value1)
        config.set(:key2, :value2)
      end

      it "returns all set keys" do
        expect(subject).to match_array %i(key1 key2)
      end
    end

    describe "deleting" do
      before do
        config.set(:key, :value)
      end

      it "deletes the value" do
        config.delete(:key)
        expect(config.fetch(:key)).to be_nil
      end
    end

    describe "asking" do
      let(:question) { stub }
      let(:options) { {} }

      before do
        Configuration::Question.expects(:new).with(:branch, :default, options)
                               .returns(question)
      end

      it "prompts for the value when fetching" do
        config.ask(:branch, :default, options)
        expect(config.fetch(:branch)).to eq question
      end
    end

    describe "setting the backend" do
      it "by default, is SSHKit" do
        expect(config.backend).to eq SSHKit
      end

      it "can be set to another class" do
        config.backend = :test
        expect(config.backend).to eq :test
      end

      describe "ssh_options for Netssh" do
        it "merges them with the :ssh_options variable" do
          config.set :format, :pretty
          config.set :log_level, :debug
          config.set :ssh_options, user: "albert"
          SSHKit::Backend::Netssh.configure { |ssh| ssh.ssh_options = { password: "einstein" } }
          config.configure_backend

          expect(
            config.backend.config.backend.config.ssh_options
          ).to include(user: "albert", password: "einstein")
        end
      end
    end

    describe "dry_run?" do
      it "returns false when using default backend" do
        expect(config.dry_run?).to eq(false)
      end

      it "returns true when using printer backend" do
        config.set :sshkit_backend, SSHKit::Backend::Printer

        expect(config.dry_run?).to eq(true)
      end
    end

    describe "custom filtering" do
      it "accepts a custom filter object" do
        filter = Object.new
        def filter.filter(servers)
          servers
        end
        config.add_filter(filter)
      end

      it "accepts a custom filter as a block" do
        config.add_filter { |servers| servers }
      end

      it "raises an error if passed a block and an object" do
        filter = Object.new
        def filter.filter(servers)
          servers
        end

        expect { config.add_filter(filter) { |servers| servers } }.to raise_error(ArgumentError)
      end

      it "raises an error if the filter lacks a filter method" do
        filter = Object.new
        expect { config.add_filter(filter) }.to raise_error(TypeError)
      end

      it "calls the filter method of a custom filter" do
        ENV.delete "ROLES"
        ENV.delete "HOSTS"

        servers = Configuration::Servers.new

        servers.add_host("test1")
        servers.add_host("test2")
        servers.add_host("test3")

        filtered_servers = servers.take(2)

        filter = mock("custom filter")
        filter.expects(:filter)
              .with { |subset| subset.is_a? Configuration::Servers }
              .returns(filtered_servers)

        config.add_filter(filter)
        expect(config.filter(servers)).to eq(filtered_servers)
      end
    end
require "spec_helper"

describe Capistrano::DSL::Paths do
  let(:dsl) { Class.new.extend Capistrano::DSL }
  let(:parent) { Pathname.new("/var/shared") }
  let(:paths) { Class.new.extend Capistrano::DSL::Paths }

  let(:linked_dirs) { %w{log public/system} }
  let(:linked_files) { %w{config/database.yml log/my.log log/access.log} }

  before do
    dsl.set(:deploy_to, "/var/www")
  end

  describe "#linked_dirs" do
    subject { paths.linked_dirs(parent) }

    before do
      paths.expects(:fetch).with(:linked_dirs).returns(linked_dirs)
    end

    it "returns the full pathnames" do
      expect(subject).to eq [
        Pathname.new("/var/shared/log"),
        Pathname.new("/var/shared/public/system")
      ]
    end
  end

  describe "#linked_files" do
    subject { paths.linked_files(parent) }

    before do
      paths.expects(:fetch).with(:linked_files).returns(linked_files)
    end

    it "returns the full pathnames" do
      expect(subject).to eq [
        Pathname.new("/var/shared/config/database.yml"),
        Pathname.new("/var/shared/log/my.log"),
        Pathname.new("/var/shared/log/access.log")
      ]
    end
  end

  describe "#linked_file_dirs" do
    subject { paths.linked_file_dirs(parent) }

    before do
      paths.expects(:fetch).with(:linked_files).returns(linked_files)
    end

    it "returns the full paths names of the parent dirs" do
      expect(subject).to eq [
        Pathname.new("/var/shared/config"),
        Pathname.new("/var/shared/log")
      ]
    end
  end

  describe "#linked_dir_parents" do
    subject { paths.linked_dir_parents(parent) }

    before do
      paths.expects(:fetch).with(:linked_dirs).returns(linked_dirs)
    end

    it "returns the full paths names of the parent dirs" do
      expect(subject).to eq [
        Pathname.new("/var/shared"),
        Pathname.new("/var/shared/public")
      ]
    end
  end

  describe "#release path" do
    subject { dsl.release_path }

    context "where no release path has been set" do
      before do
        dsl.delete(:release_path)
      end

      it "returns the `current_path` value" do
        expect(subject.to_s).to eq "/var/www/current"
      end
    end

    context "where the release path has been set" do
      before do
        dsl.set(:release_path, "/var/www/release_path")
      end

      it "returns the set `release_path` value" do
        expect(subject.to_s).to eq "/var/www/release_path"
      end
    end
  end

  describe "#set_release_path" do
    let(:now) { Time.parse("Oct 21 16:29:00 2015") }
    subject { dsl.release_path }

    context "without a timestamp" do
      before do
        dsl.env.expects(:timestamp).returns(now)
        dsl.set_release_path
      end

      it "returns the release path with the current env timestamp" do
        expect(subject.to_s).to eq "/var/www/releases/20151021162900"
      end
    end

    context "with a timestamp" do
      before do
        dsl.set_release_path("timestamp")
      end

      it "returns the release path with the timestamp" do
        expect(subject.to_s).to eq "/var/www/releases/timestamp"
      end
    end
  end

  describe "#releases_path" do
    subject { paths.releases_path }

    context "with custom releases directory" do
      before do
        paths.expects(:fetch).with(:releases_directory, "releases").returns("test123")
        paths.expects(:fetch).with(:deploy_to).returns("/var/www")
      end

      it "returns the releases path with the custom directory" do
        expect(subject.to_s).to eq "/var/www/test123"
      end
    end
  end

  describe "#shared_path" do
    subject { paths.shared_path }

    context "with custom shared directory" do
      before do
        paths.expects(:fetch).with(:shared_directory, "shared").returns("test123")
        paths.expects(:fetch).with(:deploy_to).returns("/var/www")
      end

      it "returns the shared path with the custom directory" do
        expect(subject.to_s).to eq "/var/www/test123"
      end
    end
  end

  describe "#deploy_config_path" do
    subject { dsl.deploy_config_path.to_s }

    context "when not specified" do
      before do
        dsl.delete(:deploy_config_path)
      end

      it 'returns "config/deploy.rb"' do
        expect(subject).to eq "config/deploy.rb"
      end
    end

    context "when the variable :deploy_config_path is set" do
      before do
        dsl.set(:deploy_config_path, "my/custom/path.rb")
      end

      it "returns the custom path" do
        expect(subject).to eq "my/custom/path.rb"
      end
    end
  end

  describe "#stage_config_path" do
    subject { dsl.stage_config_path.to_s }

    context "when not specified" do
      before do
        dsl.delete(:stage_config_path)
      end

      it 'returns "config/deploy"' do
        expect(subject).to eq "config/deploy"
      end
    end

    context "when the variable :stage_config_path is set" do
      before do
        dsl.set(:stage_config_path, "my/custom/path")
      end

      it "returns the custom path" do
        expect(subject).to eq "my/custom/path"
      end
    end
  end

  describe "#repo_path" do
    subject { dsl.repo_path.to_s }

    context "when not specified" do
      before do
        dsl.delete(:repo_path)
      end

      it 'returns the default #{deploy_to}/repo' do
        dsl.set(:deploy_to, "/var/www")
        expect(subject).to eq "/var/www/repo"
      end
    end

    context "when the variable :repo_path is set" do
      before do
        dsl.set(:repo_path, "my/custom/path")
      end

      it "returns the custom path" do
        expect(subject).to eq "my/custom/path"
      end
require "spec_helper"

module Capistrano
  class DummyTaskEnhancements
    include TaskEnhancements
  end

  describe TaskEnhancements do
    let(:task_enhancements) { DummyTaskEnhancements.new }

    describe "ordering" do
      after do
        task.clear
        before_task.clear
        after_task.clear
        Rake::Task.clear
      end

      let(:order) { [] }
      let!(:task) do
        Rake::Task.define_task("task", [:order]) do |_t, args|
          args["order"].push "task"
        end
      end

      let!(:before_task) do
        Rake::Task.define_task("before_task") do
          order.push "before_task"
        end
      end

      let!(:after_task) do
        Rake::Task.define_task("after_task") do
          order.push "after_task"
        end
      end

      it "invokes in proper order if define after than before", capture_io: true do
        task_enhancements.after("task", "after_task")
        task_enhancements.before("task", "before_task")

        Rake::Task["task"].invoke order

        expect(order).to eq(%w(before_task task after_task))
      end

      it "invokes in proper order if define before than after", capture_io: true do
        task_enhancements.before("task", "before_task")
        task_enhancements.after("task", "after_task")

        Rake::Task["task"].invoke order

        expect(order).to eq(%w(before_task task after_task))
      end

      it "invokes in proper order when referring to as-yet undefined tasks", capture_io: true do
        task_enhancements.after("task", "not_loaded_task")

        Rake::Task.define_task("not_loaded_task") do
          order.push "not_loaded_task"
        end

        Rake::Task["task"].invoke order

        expect(order).to eq(%w(task not_loaded_task))
      end

      it "invokes in proper order and with arguments and block", capture_io: true do
        task_enhancements.after("task", "after_task_custom", :order) do |_t, _args|
          order.push "after_task"
        end

        task_enhancements.before("task", "before_task_custom", :order) do |_t, _args|
          order.push "before_task"
        end

        Rake::Task["task"].invoke(order)

        expect(order).to eq(%w(before_task task after_task))
      end

      it "invokes using the correct namespace when defined within a namespace", capture_io: true do
        Rake.application.in_namespace("namespace") do
          Rake::Task.define_task("task") do |t|
            order.push(t.name)
          end
          task_enhancements.before("task", "before_task", :order) do |t|
            order.push(t.name)
          end
          task_enhancements.after("task", "after_task", :order) do |t|
            order.push(t.name)
          end
        end

        Rake::Task["namespace:task"].invoke

        expect(order).to eq(
          ["namespace:before_task", "namespace:task", "namespace:after_task"]
        )
      end

      it "raises a sensible error if the task isn't found", capture_io: true do
        task_enhancements.after("task", "non_existent_task")
        expect { Rake::Task["task"].invoke order }.to raise_error(ArgumentError, 'Task "non_existent_task" not found')
      end
require "spec_helper"
require "capistrano/plugin"

module Capistrano
  describe Plugin do
    include Rake::DSL
    include Capistrano::DSL

    class DummyPlugin < Capistrano::Plugin
      def define_tasks
        task :hello do
        end
      end

      def register_hooks
        before "deploy:published", "hello"
      end
    end

    class ExternalTasksPlugin < Capistrano::Plugin
      def define_tasks
        eval_rakefile(
          File.expand_path("../../../support/tasks/plugin.rake", __FILE__)
        )
      end

      # Called from plugin.rake to demonstrate that helper methods work
      def hello
        set :plugin_result, "hello"
      end
    end

    before do
      # Define an example task to allow testing hooks
      task "deploy:published"
    end

    after do
      # Clean up any tasks or variables we created during the tests
      Rake::Task.clear
      Capistrano::Configuration.reset!
    end

    it "defines tasks when constructed" do
      install_plugin(DummyPlugin)
      expect(Rake::Task["hello"]).not_to be_nil
    end

    it "registers hooks when constructed" do
      install_plugin(DummyPlugin)
      expect(Rake::Task["deploy:published"].prerequisites).to include("hello")
    end

    it "skips registering hooks if load_hooks: false" do
      install_plugin(DummyPlugin, load_hooks: false)
      expect(Rake::Task["deploy:published"].prerequisites).to be_empty
    end

    it "doesn't call set_defaults immediately" do
      dummy = DummyPlugin.new
      install_plugin(dummy)
      dummy.expects(:set_defaults).never
    end

    it "calls set_defaults during load:defaults", capture_io: true do
      dummy = DummyPlugin.new
      dummy.expects(:set_defaults).once
      install_plugin(dummy)
      Rake::Task["load:defaults"].invoke
    end

    it "is able to load tasks from a .rake file", capture_io: true do
      install_plugin(ExternalTasksPlugin)
      Rake::Task["plugin_test"].invoke
      expect(fetch(:plugin_result)).to eq("hello")
    end

    it "exposes the SSHKit backend to subclasses" do
      SSHKit::Backend.expects(:current).returns(:backend)
      plugin = DummyPlugin.new
require "spec_helper"

module Capistrano
  describe VersionValidator do
    let(:validator) { VersionValidator.new(version) }
    let(:version) { stub }

    describe "#new" do
      it "takes a version" do
        expect(validator)
      end
    end

    describe "#verify" do
      let(:current_version) { "3.0.1" }

      subject { validator.verify }

      before do
        validator.stubs(:current_version).returns(current_version)
      end

      context "with exact version" do
        context "valid" do
          let(:version) { "3.0.1" }
          it { expect(subject).to be_truthy }
        end

        context "invalid - lower" do
          let(:version) { "3.0.0" }

          it "fails" do
            expect { subject }.to raise_error(RuntimeError)
          end
        end

        context "invalid - higher" do
          let(:version) { "3.0.2" }

          it "fails" do
            expect { subject }.to raise_error(RuntimeError)
          end
        end
      end

      context "with optimistic versioning" do
        context "valid" do
          let(:version) { ">= 3.0.0" }
          it { expect(subject).to be_truthy }
        end

        context "invalid - lower" do
          let(:version) { "<= 2.0.0" }

          it "fails" do
            expect { subject }.to raise_error(RuntimeError)
          end
        end
      end

      context "with pessimistic versioning" do
        context "2 decimal places" do
          context "valid" do
            let(:version) { "~> 3.0.0" }
            it { expect(subject).to be_truthy }
          end

          context "invalid" do
            let(:version) { "~> 3.1.0" }

            it "fails" do
              expect { subject }.to raise_error(RuntimeError)
            end
          end
        end

        context "1 decimal place" do
          let(:current_version) { "3.5.0" }

          context "valid" do
            let(:version) { "~> 3.1" }
            it { expect(subject).to be_truthy }
          end

          context "invalid" do
            let(:version) { "~> 3.6" }
            it "fails" do
              expect { subject }.to raise_error(RuntimeError)
            end
          end
        end

        context "with multiple versions" do
          let(:current_version) { "3.5.9" }

          context "valid" do
            let(:version) { [">= 3.5.0", "< 3.5.10"] }
            it { is_expected.to be_truthy }
          end

          context "invalid" do
            let(:version) { [">= 3.5.0", "< 3.5.8"] }
            it "fails" do
              expect { subject }.to raise_error(RuntimeError)
            end
          end

          context "invalid" do
            let(:version) { ["> 3.5.9", "< 3.5.13"] }
            it "fails" do
              expect { subject }.to raise_error(RuntimeError)
            end
          end
        end
      end
require "spec_helper"
require "capistrano/scm"

module Capistrano
  class Configuration
    describe SCMResolver do
      include Capistrano::DSL

      let(:resolver) { SCMResolver.new }

      before do
        Rake::Task.define_task("deploy:check")
        Rake::Task.define_task("deploy:new_release_path")
        Rake::Task.define_task("deploy:set_current_revision")
        set :scm, SCMResolver::DEFAULT_GIT
      end

      after do
        Rake::Task.clear
        Capistrano::Configuration.reset!
      end

      context "default scm, no plugin installed" do
        it "emits a warning" do
          expect { resolver.resolve }.to output(/will not load the git scm/i).to_stderr
        end

        it "activates the git scm", capture_io: true do
          resolver.resolve
          expect(Rake::Task["git:wrapper"]).not_to be_nil
        end

        it "sets :scm to :git", capture_io: true do
          resolver.resolve
          expect(fetch(:scm)).to eq(:git)
        end
      end

      context "default scm, git plugin installed" do
        before do
          install_plugin Capistrano::SCM::Git
        end

        it "emits no warning" do
          expect { resolver.resolve }.not_to output.to_stderr
        end

        it "deletes :scm" do
          resolver.resolve
          expect(fetch(:scm)).to be_nil
require "spec_helper"
require "capistrano/plugin"
require "capistrano/scm/plugin"

module Capistrano
  class Configuration
    class ExamplePlugin < Capistrano::Plugin
      def set_defaults
        set_if_empty :example_variable, "foo"
      end

      def define_tasks
        task :example
        task :example_prerequisite
      end

      def register_hooks
        before :example, :example_prerequisite
      end
    end

    class ExampleSCMPlugin < Capistrano::SCM::Plugin
    end

    describe PluginInstaller do
      include Capistrano::DSL

      let(:installer) { PluginInstaller.new }
      let(:options) { {} }
      let(:plugin) { ExamplePlugin.new }

      before do
        installer.install(plugin, **options)
      end

      after do
        Rake::Task.clear
        Capistrano::Configuration.reset!
      end

      context "installing plugin" do
        it "defines tasks" do
          expect(Rake::Task[:example]).to_not be_nil
          expect(Rake::Task[:example_prerequisite]).to_not be_nil
        end

        it "registers hooks" do
          task = Rake::Task[:example]
          expect(task.prerequisites).to eq([:example_prerequisite])
        end

        it "sets defaults when load:defaults is invoked", capture_io: true do
          expect(fetch(:example_variable)).to be_nil
          invoke "load:defaults"
          expect(fetch(:example_variable)).to eq("foo")
        end

        it "doesn't say an SCM is installed" do
          expect(installer.scm_installed?).to be_falsey
        end
      end

      context "installing plugin class" do
        let(:plugin) { ExamplePlugin }

        it "defines tasks" do
          expect(Rake::Task[:example]).to_not be_nil
          expect(Rake::Task[:example_prerequisite]).to_not be_nil
        end
      end

      context "installing plugin without hooks" do
        let(:options) { { load_hooks: false } }

        it "doesn't register hooks" do
          task = Rake::Task[:example]
          expect(task.prerequisites).to be_empty
        end
      end

      context "installing plugin and loading immediately" do
        let(:options) { { load_immediately: true } }

        it "sets defaults immediately" do
          expect(fetch(:example_variable)).to eq("foo")
        end
      end

      context "installing an SCM plugin" do
        let(:plugin) { ExampleSCMPlugin }

        it "says an SCM is installed" do
          expect(installer.scm_installed?).to be_truthy
        end
      end
require "spec_helper"

module Capistrano
  class Configuration
    describe RoleFilter do
      subject(:role_filter) { RoleFilter.new(values) }

      let(:available) do
        [
          Server.new("server1").add_roles(%i(web db)),
          Server.new("server2").add_role(:web),
          Server.new("server3").add_role(:redis),
          Server.new("server4").add_role(:db),
          Server.new("server5").add_role(:stageweb),
          Server.new("server6").add_role(:"db.new")
        ]
      end

      shared_examples "it filters roles correctly" do |expected_size, expected|
        it "filters correctly" do
          set = role_filter.filter(available)
          expect(set.size).to eq(expected_size)
          expect(set.map(&:hostname)).to eq(expected)
        end
      end

      describe "#filter" do
        context "with a single role string" do
          let(:values) { "web" }
          it_behaves_like "it filters roles correctly", 2, %w{server1 server2}
        end

        context "with a single role" do
          let(:values) { [:web] }
          it_behaves_like "it filters roles correctly", 2, %w{server1 server2}
        end

        context "with multiple roles in a string" do
          let(:values) { "web,db" }
          it_behaves_like "it filters roles correctly", 3, %w{server1 server2 server4}
        end

        context "with multiple roles" do
          let(:values) { %i(web db) }
          it_behaves_like "it filters roles correctly", 3, %w{server1 server2 server4}
        end

        context "with a regex" do
          let(:values) { /red/ }
          it_behaves_like "it filters roles correctly", 1, %w{server3}
        end

        context "with a regex string" do
          let(:values) { "/red|web/" }
          it_behaves_like "it filters roles correctly", 4, %w{server1 server2 server3 server5}
        end

        context "with both a string and regex" do
          let(:values) { "db,/red/" }
          it_behaves_like "it filters roles correctly", 3, %w{server1 server3 server4}
        end

        context "with a dot wildcard" do
          let(:values) { "db.*" }
          it_behaves_like "it filters roles correctly", 0, %w{}
        end

        context "with a dot" do
          let(:values) { "db.new" }
          it_behaves_like "it filters roles correctly", 1, %w{server6}
        end

        context "with a dot wildcard regex" do
          let(:values) { "/db.*/" }
          it_behaves_like "it filters roles correctly", 3, %w{server1 server4 server6}
require "spec_helper"

module Capistrano
  class Configuration
    describe Question do
      let(:question) { Question.new(key, default, stdin: stdin) }
      let(:question_without_echo) { Question.new(key, default, echo: false, stdin: stdin) }
      let(:question_without_default) { Question.new(key, nil, stdin: stdin) }
      let(:question_prompt) { Question.new(key, default, stdin: stdin, prompt: "Your favorite branch") }
      let(:question_prompt_without_default) { Question.new(key, nil, stdin: stdin, prompt: "Your favorite branch") }
      let(:default) { :default }
      let(:key) { :branch }
      let(:stdin) { stub(tty?: true) }

      describe ".new" do
        it "takes a key, default, options" do
          question
        end
      end

      describe "#call" do
        context "value is entered" do
          let(:branch) { "branch" }

          it "returns the echoed value" do
            $stdout.expects(:print).with("Please enter branch (default): ")
            stdin.expects(:gets).returns(branch)
            stdin.expects(:noecho).never

            expect(question.call).to eq(branch)
          end

          it "returns the value but does not echo it" do
            $stdout.expects(:print).with("Please enter branch (default): ")
            stdin.expects(:noecho).returns(branch)
            $stdout.expects(:print).with("\n")

            expect(question_without_echo.call).to eq(branch)
          end

          it "returns the value but has no default between parenthesis" do
            $stdout.expects(:print).with("Please enter branch: ")
            stdin.expects(:gets).returns(branch)
            stdin.expects(:noecho).never

            expect(question_without_default.call).to eq(branch)
          end

          it "uses prompt and returns the value" do
            $stdout.expects(:print).with("Your favorite branch (default): ")
            stdin.expects(:gets).returns(branch)
            stdin.expects(:noecho).never

            expect(question_prompt.call).to eq(branch)
          end

          it "uses prompt and returns the value but has no default between parenthesis" do
            $stdout.expects(:print).with("Your favorite branch: ")
            stdin.expects(:gets).returns(branch)
            stdin.expects(:noecho).never

            expect(question_prompt_without_default.call).to eq(branch)
          end
        end

        context "value is not entered" do
          let(:branch) { default }

          before do
            $stdout.expects(:print).with("Please enter branch (default): ")
            stdin.expects(:gets).returns("")
          end

          it "returns the default as the value" do
            expect(question.call).to eq(branch)
          end
        end

        context "tty unavailable", capture_io: true do
          before do
            stdin.expects(:gets).never
            stdin.expects(:tty?).returns(false)
          end

          it "returns the default as the value" do
            expect(question.call).to eq(default)
          end
        end
      end
    end
require "spec_helper"

module Capistrano
  class Configuration
    describe HostFilter do
      subject(:host_filter) { HostFilter.new(values) }

      let(:available) do
        [Server.new("server1"),
         Server.new("server2"),
         Server.new("server3"),
         Server.new("server4"),
         Server.new("server10")]
      end

      shared_examples "it filters hosts correctly" do |expected|
        it "filters correctly" do
          set = host_filter.filter(available)
          expect(set.map(&:hostname)).to eq(expected)
        end
      end

      describe "#filter" do
        context "with a string" do
          let(:values) { "server1" }
          it_behaves_like "it filters hosts correctly", %w{server1}

          context "and a single server" do
            let(:available) { Server.new("server1") }
            it_behaves_like "it filters hosts correctly", %w{server1}
          end
        end

        context "with a comma separated string" do
          let(:values) { "server1,server10" }
          it_behaves_like "it filters hosts correctly", %w{server1 server10}
        end

        context "with an array of strings" do
          let(:values) { %w{server1 server3} }
          it_behaves_like "it filters hosts correctly", %w{server1 server3}
        end

        context "with mixed splittable and unsplittable strings" do
          let(:values) { %w{server1 server2,server3} }
          it_behaves_like "it filters hosts correctly", %w{server1 server2 server3}
        end

        context "with a regexp" do
          let(:values) { "server[13]$" }
          it_behaves_like "it filters hosts correctly", %w{server1 server3}
        end

        context "with a regexp with line boundaries" do
          let(:values) { "^server" }
          it_behaves_like "it filters hosts correctly", %w{server1 server2 server3 server4 server10}
        end

        context "with a regexp with a comma" do
          let(:values) { 'server\d{1,3}$' }
          it_behaves_like "it filters hosts correctly", %w{server1 server2 server3 server4 server10}
        end

        context "without number" do
          let(:values) { "server" }
          it_behaves_like "it filters hosts correctly", %w{}
        end
      end
    end
  end
require "spec_helper"

module Capistrano
  class Configuration
    describe Servers do
      let(:servers) { Servers.new }

      describe "adding a role" do
        it "adds two new server instances" do
          expect { servers.add_role(:app, %w{1 2}) }
            .to change { servers.count }.from(0).to(2)
        end

        it "handles de-duplification within roles" do
          servers.add_role(:app, %w{1})
          servers.add_role(:app, %w{1})
          expect(servers.count).to eq 1
        end

        it "handles de-duplification within roles with users" do
          servers.add_role(:app, %w{1}, user: "nick")
          servers.add_role(:app, %w{1}, user: "fred")
          expect(servers.count).to eq 1
        end

        it "accepts instances of server objects" do
          servers.add_role(:app, [Capistrano::Configuration::Server.new("example.net"), "example.com"])
          expect(servers.roles_for([:app]).length).to eq 2
        end

        it "accepts non-enumerable types" do
          servers.add_role(:app, "1")
          expect(servers.roles_for([:app]).count).to eq 1
        end

        it "creates distinct server properties" do
          servers.add_role(:db, %w{1 2}, db: { port: 1234 })
          servers.add_host("1", db: { master: true })
          expect(servers.count).to eq(2)
          expect(servers.roles_for([:db]).count).to eq 2
          expect(servers.find { |s| s.hostname == "1" }.properties.db).to eq(port: 1234, master: true)
          expect(servers.find { |s| s.hostname == "2" }.properties.db).to eq(port: 1234)
        end
      end

      describe "adding a role to an existing server" do
        before do
          servers.add_role(:web, %w{1 2})
          servers.add_role(:app, %w{1 2})
        end

        it "adds new roles to existing servers" do
          expect(servers.count).to eq 2
        end
      end

      describe "collecting server roles" do
        let(:app) { Set.new([:app]) }
        let(:web_app) { Set.new(%i(web app)) }
        let(:web) { Set.new([:web]) }

        before do
          servers.add_role(:app, %w{1 2 3})
          servers.add_role(:web, %w{2 3 4})
        end

        it "returns an array of the roles" do
          expect(servers.roles_for([:app]).collect(&:roles)).to eq [app, web_app, web_app]
          expect(servers.roles_for([:web]).collect(&:roles)).to eq [web_app, web_app, web]
        end
      end

      describe "finding the primary server" do
        after do
          Configuration.reset!
        end
        it "takes the first server if none have the primary property" do
          servers.add_role(:app, %w{1 2})
          expect(servers.fetch_primary(:app).hostname).to eq("1")
        end

        it "takes the first server with the primary have the primary flag" do
          servers.add_role(:app, %w{1 2})
          servers.add_host("2", primary: true)
          expect(servers.fetch_primary(:app).hostname).to eq("2")
        end

        it "ignores any on_filters" do
          Configuration.env.set :filter, host: "1"
          servers.add_role(:app, %w{1 2})
          servers.add_host("2", primary: true)
          expect(servers.fetch_primary(:app).hostname).to eq("2")
        end
      end

      describe "fetching servers" do
        before do
          servers.add_role(:app, %w{1 2})
          servers.add_role(:web, %w{2 3})
        end

        it "returns the correct app servers" do
          expect(servers.roles_for([:app]).map(&:hostname)).to eq %w{1 2}
        end

        it "returns the correct web servers" do
          expect(servers.roles_for([:web]).map(&:hostname)).to eq %w{2 3}
        end

        it "returns the correct app and web servers" do
          expect(servers.roles_for(%i(app web)).map(&:hostname)).to eq %w{1 2 3}
        end

        it "returns all servers" do
          expect(servers.roles_for([:all]).map(&:hostname)).to eq %w{1 2 3}
        end
      end

      describe "adding a server" do
        before do
          servers.add_host("1", roles: [:app, "web"], test: :value)
        end

        it "can create a server with properties" do
          expect(servers.roles_for([:app]).first.hostname).to eq "1"
          expect(servers.roles_for([:web]).first.hostname).to eq "1"
          expect(servers.roles_for([:all]).first.properties.test).to eq :value
          expect(servers.roles_for([:all]).first.properties.keys).to eq [:test]
        end

        it "can accept multiple servers with the same hostname but different ports or users" do
          servers.add_host("1", roles: [:app, "web"], test: :value, port: 12)
          expect(servers.count).to eq(2)
          servers.add_host("1", roles: [:app, "web"], test: :value, port: 34)
          servers.add_host("1", roles: [:app, "web"], test: :value, user: "root")
          servers.add_host("1", roles: [:app, "web"], test: :value, user: "deployer")
          servers.add_host("1", roles: [:app, "web"], test: :value, user: "root", port: 34)
          servers.add_host("1", roles: [:app, "web"], test: :value, user: "deployer", port: 34)
          servers.add_host("1", roles: [:app, "web"], test: :value, user: "deployer", port: 56)
          expect(servers.count).to eq(4)
        end

        describe "with a :user property" do
          it "sets the server ssh username" do
            servers.add_host("1", roles: [:app, "web"], user: "nick")
            expect(servers.count).to eq(1)
            expect(servers.roles_for([:all]).first.user).to eq "nick"
          end

          it "overwrites the value of a user specified in the hostname" do
            servers.add_host("brian@1", roles: [:app, "web"], user: "nick")
            expect(servers.count).to eq(1)
            expect(servers.roles_for([:all]).first.user).to eq "nick"
          end
        end

        it "overwrites the value of a previously defined scalar property" do
          servers.add_host("1", roles: [:app, "web"], test: :volatile)
          expect(servers.count).to eq(1)
          expect(servers.roles_for([:all]).first.properties.test).to eq :volatile
        end

        it "merges previously defined hash properties" do
          servers.add_host("1", roles: [:b], db: { port: 1234 })
          servers.add_host("1", roles: [:b], db: { master: true })
          expect(servers.count).to eq(1)
          expect(servers.roles_for([:b]).first.properties.db).to eq(port: 1234, master: true)
        end

        it "concatenates previously defined array properties" do
          servers.add_host("1", roles: [:b], steps: [1, 3, 5])
          servers.add_host("1", roles: [:b], steps: [1, 9])
          expect(servers.count).to eq(1)
          expect(servers.roles_for([:b]).first.properties.steps).to eq([1, 3, 5, 1, 9])
        end

        it "merges previously defined set properties" do
          servers.add_host("1", roles: [:b], endpoints: Set[123, 333])
          servers.add_host("1", roles: [:b], endpoints: Set[222, 333])
          expect(servers.count).to eq(1)
          expect(servers.roles_for([:b]).first.properties.endpoints).to eq(Set[123, 222, 333])
        end

        it "adds array property value only ones for a new host" do
          servers.add_host("2", roles: [:array_test], array_property: [1, 2])
          expect(servers.roles_for([:array_test]).first.properties.array_property).to eq [1, 2]
        end

        it "updates roles when custom user defined" do
          servers.add_host("1", roles: ["foo"], user: "custom")
          servers.add_host("1", roles: ["bar"], user: "custom")
          expect(servers.roles_for([:foo]).first.hostname).to eq "1"
          expect(servers.roles_for([:bar]).first.hostname).to eq "1"
        end

        it "updates roles when custom port defined" do
          servers.add_host("1", roles: ["foo"], port: 1234)
          servers.add_host("1", roles: ["bar"], port: 1234)
          expect(servers.roles_for([:foo]).first.hostname).to eq "1"
          expect(servers.roles_for([:bar]).first.hostname).to eq "1"
        end
      end

      describe "selecting roles" do
        before do
          servers.add_host("1", roles: :app, active: true)
          servers.add_host("2", roles: :app)
        end

        it "is empty if the filter would remove all matching hosts" do
          expect(servers.roles_for([:app, select: :inactive])).to be_empty
        end

        it "can filter hosts by properties on the host object using symbol as shorthand" do
          expect(servers.roles_for([:app, filter: :active]).length).to eq 1
        end

        it "can select hosts by properties on the host object using symbol as shorthand" do
          expect(servers.roles_for([:app, select: :active]).length).to eq 1
        end

        it "can filter hosts by properties on the host using a regular proc" do
          expect(servers.roles_for([:app, filter: ->(h) { h.properties.active }]).length).to eq 1
        end

        it "can select hosts by properties on the host using a regular proc" do
          expect(servers.roles_for([:app, select: ->(h) { h.properties.active }]).length).to eq 1
        end

        it "is empty if the regular proc filter would remove all matching hosts" do
          expect(servers.roles_for([:app, select: ->(h) { h.properties.inactive }])).to be_empty
        end
      end

      describe "excluding by property" do
        before do
          servers.add_host("1", roles: :app, active: true)
          servers.add_host("2", roles: :app, active: true, no_release: true)
        end

        it "is empty if the filter would remove all matching hosts" do
          hosts = servers.roles_for([:app, exclude: :active])
          expect(hosts.map(&:hostname)).to be_empty
        end

        it "returns the servers without the attributes specified" do
          hosts = servers.roles_for([:app, exclude: :no_release])
          expect(hosts.map(&:hostname)).to eq %w{1}
        end

        it "can exclude hosts by properties on the host using a regular proc" do
          hosts = servers.roles_for([:app, exclude: ->(h) { h.properties.no_release }])
          expect(hosts.map(&:hostname)).to eq %w{1}
        end

        it "is empty if the regular proc filter would remove all matching hosts" do
          hosts = servers.roles_for([:app, exclude: ->(h) { h.properties.active }])
          expect(hosts.map(&:hostname)).to be_empty
        end
      end

      describe "filtering roles internally" do
        before do
          servers.add_host("1", roles: :app, active: true)
          servers.add_host("2", roles: :app)
          servers.add_host("3", roles: :web)
          servers.add_host("4", roles: :web)
          servers.add_host("5", roles: :db)
        end

        subject { servers.roles_for(roles).map(&:hostname) }

        context "with the ROLES environment variable set" do
          before do
            ENV.stubs(:[]).with("ROLES").returns("web,db")
            ENV.stubs(:[]).with("HOSTS").returns(nil)
          end

          context "when selecting all roles" do
            let(:roles) { [:all] }
            it "ignores it" do
              expect(subject).to eq %w{1 2 3 4 5}
            end
          end

          context "when selecting specific roles" do
            let(:roles) { %i(app web) }
            it "ignores it" do
              expect(subject).to eq %w{1 2 3 4}
            end
          end

          context "when selecting roles not included in ROLE" do
            let(:roles) { [:app] }
            it "ignores it" do
              expect(subject).to eq %w{1 2}
            end
          end
        end

        context "with the HOSTS environment variable set" do
          before do
            ENV.stubs(:[]).with("ROLES").returns(nil)
            ENV.stubs(:[]).with("HOSTS").returns("3,5")
          end

          context "when selecting all roles" do
            let(:roles) { [:all] }
            it "ignores it" do
              expect(subject).to eq %w{1 2 3 4 5}
            end
          end

          context "when selecting specific roles" do
            let(:roles) { %i(app web) }
            it "ignores it" do
              expect(subject).to eq %w{1 2 3 4}
            end
          end

          context "when selecting no roles" do
            let(:roles) { [] }
            it "ignores it" do
              expect(subject).to be_empty
            end
          end
        end
      end
    end
  end
require "spec_helper"

module Capistrano
  class Configuration
    describe Filter do
      let(:available) do
        [
          Server.new("server1").add_roles(%i(web db)),
          Server.new("server2").add_role(:web),
          Server.new("server3").add_role(:redis),
          Server.new("server4").add_role(:db),
          Server.new("server5").add_role(:stageweb)
        ]
      end

      describe "#new" do
        it "won't create an invalid type of filter" do
          expect do
            Filter.new(:zarg)
          end.to raise_error RuntimeError
        end

        context "with type :host" do
          context "and no values" do
            it "creates an EmptyFilter strategy" do
              expect(Filter.new(:host).instance_variable_get(:@strategy)).to be_a(EmptyFilter)
            end
          end

          context "and :all" do
            it "creates an NullFilter strategy" do
              expect(Filter.new(:host, :all).instance_variable_get(:@strategy)).to be_a(NullFilter)
            end
          end

          context "and [:all]" do
            it "creates an NullFilter strategy" do
              expect(Filter.new(:host, [:all]).instance_variable_get(:@strategy)).to be_a(NullFilter)
            end
          end

          context "and [:all]" do
            it "creates an NullFilter strategy" do
              expect(Filter.new(:host, "all").instance_variable_get(:@strategy)).to be_a(NullFilter)
            end
          end
        end

        context "with type :role" do
          context "and no values" do
            it "creates an EmptyFilter strategy" do
              expect(Filter.new(:role).instance_variable_get(:@strategy)).to be_a(EmptyFilter)
            end
          end

          context "and :all" do
            it "creates an NullFilter strategy" do
              expect(Filter.new(:role, :all).instance_variable_get(:@strategy)).to be_a(NullFilter)
            end
          end

          context "and [:all]" do
            it "creates an NullFilter strategy" do
              expect(Filter.new(:role, [:all]).instance_variable_get(:@strategy)).to be_a(NullFilter)
            end
          end

          context "and [:all]" do
            it "creates an NullFilter strategy" do
              expect(Filter.new(:role, "all").instance_variable_get(:@strategy)).to be_a(NullFilter)
            end
          end
        end
      end

      describe "#filter" do
        let(:strategy) { filter.instance_variable_get(:@strategy) }
        let(:results) { mock("result") }

        shared_examples "it calls #filter on its strategy" do
          it "calls #filter on its strategy" do
            strategy.expects(:filter).with(available).returns(results)
            expect(filter.filter(available)).to eq(results)
          end
        end

        context "for an empty filter" do
          let(:filter) { Filter.new(:role) }
          it_behaves_like "it calls #filter on its strategy"
        end

        context "for a null filter" do
          let(:filter) { Filter.new(:role, :all) }
          it_behaves_like "it calls #filter on its strategy"
        end

        context "for a role filter" do
          let(:filter) { Filter.new(:role, "web") }
          it_behaves_like "it calls #filter on its strategy"
        end

        context "for a host filter" do
          let(:filter) { Filter.new(:host, "server1") }
          it_behaves_like "it calls #filter on its strategy"
        end
require "spec_helper"

module Capistrano
  class Configuration
    describe Server do
      let(:server) { Server.new("root@hostname:1234") }

      describe "adding a role" do
        subject { server.add_role(:test) }
        it "adds the role" do
          expect { subject }.to change { server.roles.size }.from(0).to(1)
        end
      end

      describe "adding roles" do
        subject { server.add_roles(%i(things stuff)) }
        it "adds the roles" do
          expect { subject }.to change { server.roles.size }.from(0).to(2)
        end
      end

      describe "checking roles" do
        subject { server.has_role?(:test) }

        before do
          server.add_role(:test)
        end

        it "adds the role" do
          expect(subject).to be_truthy
        end
      end

      describe "comparing identity" do
        subject { server.hostname == Server[hostname].hostname }

        context "with the same user, hostname and port" do
          let(:hostname) { "root@hostname:1234" }
          it { expect(subject).to be_truthy }
        end

        context "with a different user" do
          let(:hostname) { "deployer@hostname:1234" }
          it { expect(subject).to be_truthy }
        end

        context "with a different port" do
          let(:hostname) { "root@hostname:5678" }
          it { expect(subject).to be_truthy }
        end

        context "with a different hostname" do
          let(:hostname) { "root@otherserver:1234" }
          it { expect(subject).to be_falsey }
        end
      end

      describe "identifying as primary" do
        subject { server.primary }
        context "server is primary" do
          before do
            server.set(:primary, true)
          end
          it "returns self" do
            expect(subject).to eq server
          end
        end

        context "server is not primary" do
          it "is falesy" do
            expect(subject).to be_falsey
          end
        end
      end

      describe "assigning properties" do
        before do
          server.with(properties)
        end

        context "properties contains roles" do
          let(:properties) { { roles: [:clouds] } }

          it "adds the roles" do
            expect(server.roles.first).to eq :clouds
          end
        end

        context "properties contains user" do
          let(:properties) { { user: "tomc" } }

          it "sets the user" do
            expect(server.user).to eq "tomc"
          end

          it "sets the netssh_options user" do
            expect(server.netssh_options[:user]).to eq "tomc"
          end
        end

        context "properties contains port" do
          let(:properties) { { port: 2222 } }

          it "sets the port" do
            expect(server.port).to eq 2222
          end
        end

        context "properties contains key" do
          let(:properties) { { key: "/key" } }

          it "adds the key" do
            expect(server.keys).to include "/key"
          end
        end

        context "properties contains password" do
          let(:properties) { { password: "supersecret" } }

          it "adds the key" do
            expect(server.password).to eq "supersecret"
          end
        end

        context "new properties" do
          let(:properties) { { webscales: 5 } }

          it "adds the properties" do
            expect(server.properties.webscales).to eq 5
          end
        end

        context "existing properties" do
          let(:properties) { { webscales: 6 } }

          it "keeps the existing properties" do
            expect(server.properties.webscales).to eq 6
            server.properties.webscales = 5
            expect(server.properties.webscales).to eq 5
          end
        end
      end

      describe "#include?" do
        let(:options) { {} }

        subject { server.select?(options) }

        before do
          server.properties.active = true
        end

        context "options are empty" do
          it { expect(subject).to be_truthy }
        end

        context "value is a symbol" do
          context "value matches server property" do
            context "with :filter" do
              let(:options) { { filter: :active } }
              it { expect(subject).to be_truthy }
            end

            context "with :select" do
              let(:options) { { select: :active } }
              it { expect(subject).to be_truthy }
            end

            context "with :exclude" do
              let(:options) { { exclude: :active } }
              it { expect(subject).to be_falsey }
            end
          end

          context "value does not match server properly" do
            context "with :active true" do
              let(:options) { { active: true } }
              it { expect(subject).to be_truthy }
            end

            context "with :active false" do
              let(:options) { { active: false } }
              it { expect(subject).to be_falsey }
            end
          end

          context "value does not match server properly" do
            context "with :filter" do
              let(:options) { { filter: :inactive } }
              it { expect(subject).to be_falsey }
            end

            context "with :select" do
              let(:options) { { select: :inactive } }
              it { expect(subject).to be_falsey }
            end

            context "with :exclude" do
              let(:options) { { exclude: :inactive } }
              it { expect(subject).to be_truthy }
            end
          end
        end

        context "key is a property" do
          context "with :active true" do
            let(:options) { { active: true } }
            it { expect(subject).to be_truthy }
          end

          context "with :active false" do
            let(:options) { { active: false } }
            it { expect(subject).to be_falsey }
          end
        end

        context "value is a proc" do
          context "value matches server property" do
            context "with :filter" do
              let(:options) { { filter: ->(s) { s.properties.active } } }
              it { expect(subject).to be_truthy }
            end

            context "with :select" do
              let(:options) { { select: ->(s) { s.properties.active } } }
              it { expect(subject).to be_truthy }
            end

            context "with :exclude" do
              let(:options) { { exclude: ->(s) { s.properties.active } } }
              it { expect(subject).to be_falsey }
            end
          end

          context "value does not match server properly" do
            context "with :filter" do
              let(:options) { { filter: ->(s) { s.properties.inactive } } }
              it { expect(subject).to be_falsey }
            end

            context "with :select" do
              let(:options) { { select: ->(s) { s.properties.inactive } } }
              it { expect(subject).to be_falsey }
            end

            context "with :exclude" do
              let(:options) { { exclude: ->(s) { s.properties.inactive } } }
              it { expect(subject).to be_truthy }
            end
          end
        end
      end

      describe "assign ssh_options" do
        let(:server) { Server.new("user_name@hostname") }

        context "defaults" do
          it "forward agent" do
            expect(server.netssh_options[:forward_agent]).to eq true
          end
          it "contains user" do
            expect(server.netssh_options[:user]).to eq "user_name"
          end
        end

        context "custom" do
          let(:properties) do
            { ssh_options: {
              user: "another_user",
              keys: %w(/home/another_user/.ssh/id_rsa),
              forward_agent: false,
              auth_methods: %w(publickey password)
            } }
          end

          before do
            server.with(properties)
          end

          it "not forward agent" do
            expect(server.netssh_options[:forward_agent]).to eq false
          end
          it "contains correct user" do
            expect(server.netssh_options[:user]).to eq "another_user"
          end
          it "does not affect server user in host" do
            expect(server.user).to eq "user_name"
          end
          it "contains keys" do
            expect(server.netssh_options[:keys]).to eq %w(/home/another_user/.ssh/id_rsa)
          end
          it "contains auth_methods" do
            expect(server.netssh_options[:auth_methods]).to eq %w(publickey password)
          end
        end
      end

      describe ".[]" do
        it "creates a server if its argument is not already a server" do
          expect(Server["hostname:1234"]).to be_a Server
        end

        it "returns its argument if it is already a server" do
          expect(Server[server]).to be server
        end
require "spec_helper"

module Capistrano
  class Configuration
    describe NullFilter do
      subject(:null_filter) { NullFilter.new }

      describe "#filter" do
        let(:servers) { mock("servers") }

        it "returns the servers passed in as arguments" do
          expect(null_filter.filter(servers)).to eq(servers)
        end
      end
    end
require "spec_helper"

module Capistrano
  class Configuration
    describe EmptyFilter do
      subject(:empty_filter) { EmptyFilter.new }

      describe "#filter" do
        let(:servers) { mock("servers") }

        it "returns an empty array" do
          expect(empty_filter.filter(servers)).to eq([])
        end
      end
    end
require "spec_helper"
require "capistrano/doctor/output_helpers"

module Capistrano
  module Doctor
    describe OutputHelpers do
      include OutputHelpers

      # Force color for the purpose of these tests
      before { ENV.stubs(:[]).with("SSHKIT_COLOR").returns("1") }

      it "prints titles in blue with newlines and without indentation" do
        expect { title("Hello!") }.to\
          output("\e[0;34;49m\nHello!\n\e[0m\n").to_stdout
      end

      it "prints warnings in yellow with 4-space indentation" do
        expect { warning("Yikes!") }.to\
          output("    \e[0;33;49mYikes!\e[0m\n").to_stdout
      end

      it "overrides puts to indent 4 spaces per line" do
        expect { puts("one\ntwo") }.to output("    one\n    two\n").to_stdout
      end

      it "formats tables with indent, aligned columns and per-row color" do
        data = [
          ["one", ".", "1"],
          ["two", "..", "2"],
          ["three", "...", "3"]
        ]
        block = proc do |record, row|
          row.yellow if record.first == "two"
          row << record[0]
          row << record[1]
          row << record[2]
        end
        expected_output = <<-OUT
    one   .   1
    \e[0;33;49mtwo   ..  2\e[0m
    three ... 3
        OUT
        expect { table(data, &block) }.to output(expected_output).to_stdout
      end
    end
require "spec_helper"
require "capistrano/doctor/variables_doctor"

module Capistrano
  module Doctor
    describe VariablesDoctor do
      include Capistrano::DSL

      let(:doc) { VariablesDoctor.new }

      before do
        set :branch, "master"
        set :pty, false

        env.variables.untrusted! do
          set :application, "my_app"
          set :repo_tree, "public"
          set :repo_url, ".git"
          set :copy_strategy, :scp
          set :custom_setting, "hello"
          set "string_setting", "hello"
          ask :secret
        end

        fetch :custom_setting
      end

      after { Capistrano::Configuration.reset! }

      it "prints using 4-space indentation" do
        expect { doc.call }.to output(/^ {4}/).to_stdout
      end

      it "prints variable names and values" do
        expect { doc.call }.to output(/:branch\s+"master"$/).to_stdout
        expect { doc.call }.to output(/:pty\s+false$/).to_stdout
        expect { doc.call }.to output(/:application\s+"my_app"$/).to_stdout
        expect { doc.call }.to output(/:repo_url\s+".git"$/).to_stdout
        expect { doc.call }.to output(/:repo_tree\s+"public"$/).to_stdout
        expect { doc.call }.to output(/:copy_strategy\s+:scp$/).to_stdout
        expect { doc.call }.to output(/:custom_setting\s+"hello"$/).to_stdout
        expect { doc.call }.to output(/"string_setting"\s+"hello"$/).to_stdout
      end

      it "prints unanswered question variable as <ask>" do
        expect { doc.call }.to output(/:secret\s+<ask>$/).to_stdout
      end

      it "prints warning for unrecognized variable" do
        expect { doc.call }.to \
          output(/:copy_strategy is not a recognized Capistrano setting/)\
          .to_stdout
      end

      it "does not print warning for unrecognized variable that is fetched" do
        expect { doc.call }.not_to \
          output(/:custom_setting is not a recognized Capistrano setting/)\
          .to_stdout
      end

      it "does not print warning for whitelisted variable" do
        expect { doc.call }.not_to \
          output(/:repo_tree is not a recognized Capistrano setting/)\
          .to_stdout
      end

      describe "Rake" do
        before do
          load File.expand_path("../../../../../lib/capistrano/doctor.rb",
                                __FILE__)
        end

        after do
          Rake::Task.clear
        end

        it "has an doctor:variables task that calls VariablesDoctor", capture_io: true do
          VariablesDoctor.any_instance.expects(:call)
          Rake::Task["doctor:variables"].invoke
        end

        it "has a doctor task that depends on doctor:variables" do
          expect(Rake::Task["doctor"].prerequisites).to \
            include("doctor:variables")
        end
require "spec_helper"
require "capistrano/doctor/environment_doctor"

module Capistrano
  module Doctor
    describe EnvironmentDoctor do
      let(:doc) { EnvironmentDoctor.new }

      it "prints using 4-space indentation" do
        expect { doc.call }.to output(/^ {4}/).to_stdout
      end

      it "prints the Ruby version" do
        expect { doc.call }.to\
          output(/#{Regexp.quote(RUBY_DESCRIPTION)}/).to_stdout
      end

      it "prints the Rubygems version" do
        expect { doc.call }.to output(/#{Regexp.quote(Gem::VERSION)}/).to_stdout
      end

      describe "Rake" do
        before do
          load File.expand_path("../../../../../lib/capistrano/doctor.rb",
                                __FILE__)
        end

        after do
          Rake::Task.clear
        end

        it "has an doctor:environment task that calls EnvironmentDoctor", capture_io: true do
          EnvironmentDoctor.any_instance.expects(:call)
          Rake::Task["doctor:environment"].invoke
        end

        it "has a doctor task that depends on doctor:environment" do
          expect(Rake::Task["doctor"].prerequisites).to \
            include("doctor:environment")
        end
require "spec_helper"
require "capistrano/doctor/servers_doctor"

module Capistrano
  module Doctor
    describe ServersDoctor do
      include Capistrano::DSL
      let(:doc) { ServersDoctor.new }

      before { Capistrano::Configuration.reset! }
      after { Capistrano::Configuration.reset! }

      it "prints using 4-space indentation" do
        expect { doc.call }.to output(/^ {4}/).to_stdout
      end

      it "prints the number of defined servers" do
        role :app, %w(example.com)
        server "www@example.com:22"

        expect { doc.call }.to output(/Servers \(2\)/).to_stdout
      end

      describe "prints the server's details" do
        it "including username" do
          server "www@example.com"
          expect { doc.call }.to output(/www@example.com/).to_stdout
        end

        it "including port" do
          server "www@example.com:22"
          expect { doc.call }.to output(/www@example.com:22/).to_stdout
        end

        it "including roles" do
          role :app, %w(example.com)
          expect { doc.call }.to output(/example.com\s+\[:app\]/).to_stdout
        end

        it "including empty roles" do
          server "example.com"
          expect { doc.call }.to output(/example.com\s+\[\]/).to_stdout
        end

        it "including properties" do
          server "example.com", roles: %w(app db), primary: true
          expect { doc.call }.to \
            output(/example.com\s+\[:app, :db\]\s+\{ :primary => true \}/).to_stdout
        end

        it "including misleading role name alert" do
          server "example.com", roles: ["web app db"]
          warning_msg = 'Whitespace detected in role(s) :"web app db". ' \
            'This might be a result of a mistyped "%w()" array literal'

          expect { doc.call }.to output(/#{Regexp.escape(warning_msg)}/).to_stdout
        end
      end

      it "doesn't fail for no servers" do
        expect { doc.call }.to output("\nServers (0)\n    \n").to_stdout
      end

      describe "Rake" do
        before do
          load File.expand_path("../../../../../lib/capistrano/doctor.rb",
                                __FILE__)
        end

        after do
          Rake::Task.clear
        end

        it "has an doctor:servers task that calls ServersDoctor", capture_io: true do
          ServersDoctor.any_instance.expects(:call)
          Rake::Task["doctor:servers"].invoke
        end

        it "has a doctor task that depends on doctor:servers" do
          expect(Rake::Task["doctor"].prerequisites).to \
            include("doctor:servers")
        end
      end
    end
  end
require "spec_helper"
require "capistrano/doctor/gems_doctor"
require "airbrussh/version"
require "sshkit/version"
require "net/ssh/version"

module Capistrano
  module Doctor
    describe GemsDoctor do
      let(:doc) { GemsDoctor.new }

      it "prints using 4-space indentation" do
        expect { doc.call }.to output(/^ {4}/).to_stdout
      end

      it "prints the Capistrano version" do
        expect { doc.call }.to\
          output(/capistrano\s+#{Regexp.quote(Capistrano::VERSION)}/).to_stdout
      end

      it "prints the Rake version" do
        expect { doc.call }.to\
          output(/rake\s+#{Regexp.quote(Rake::VERSION)}/).to_stdout
      end

      it "prints the SSHKit version" do
        expect { doc.call }.to\
          output(/sshkit\s+#{Regexp.quote(SSHKit::VERSION)}/).to_stdout
      end

      it "prints the Airbrussh version" do
        expect { doc.call }.to\
          output(/airbrussh\s+#{Regexp.quote(Airbrussh::VERSION)}/).to_stdout
      end

      it "prints the net-ssh version" do
        expect { doc.call }.to\
          output(/net-ssh\s+#{Regexp.quote(Net::SSH::Version::STRING)}/).to_stdout
      end

      it "warns that new version is available" do
        Gem.stubs(:latest_version_for).returns(Gem::Version.new("99.0.0"))
        expect { doc.call }.to output(/\(update available\)/).to_stdout
      end

      describe "Rake" do
        before do
          load File.expand_path("../../../../../lib/capistrano/doctor.rb",
                                __FILE__)
        end

        after do
          Rake::Task.clear
        end

        it "has an doctor:gems task that calls GemsDoctor", capture_io: true do
          GemsDoctor.any_instance.expects(:call)
          Rake::Task["doctor:gems"].invoke
        end

        it "has a doctor task that depends on doctor:gems" do
          expect(Rake::Task["doctor"].prerequisites).to include("doctor:gems")
        end
      end
    end
require "spec_helper"
require "rake"
require "capistrano/immutable_task"

module Capistrano
  describe ImmutableTask do
    after do
      # Ensure that any tasks we create in these tests don't pollute other tests
      Rake::Task.clear
    end

    it "prints warning and raises when task is enhanced" do
      extend(Rake::DSL)

      load_defaults = Rake::Task.define_task("load:defaults")
      load_defaults.extend(Capistrano::ImmutableTask)

      $stderr.expects(:puts).with do |message|
        message =~ /^ERROR: load:defaults has already been invoked/
      end

      expect do
        namespace :load do
          task :defaults do
            # Never reached since load_defaults is frozen and can't be enhanced
          end
        end
      end.to raise_error(/frozen/i)
    end
  end
require "spec_helper"

module Capistrano
  class DummyDSL
    include DSL
  end

  # see also - spec/integration/dsl_spec.rb
  describe DSL do
    let(:dsl) { DummyDSL.new }

    describe "#t" do
      before do
        I18n.expects(:t).with(:phrase, count: 2, scope: :capistrano)
      end

      it "delegates to I18n" do
        dsl.t(:phrase, count: 2)
      end
    end

    describe "#stage_set?" do
      subject { dsl.stage_set? }

      context "stage is set" do
        before do
          dsl.set(:stage, :sandbox)
        end
        it { expect(subject).to be_truthy }
      end

      context "stage is not set" do
        before do
          dsl.set(:stage, nil)
        end
        it { expect(subject).to be_falsey }
      end
    end

    describe "#sudo" do
      before do
        dsl.expects(:execute).with(:sudo, :my, :command)
      end

      it "prepends sudo, delegates to execute" do
        dsl.sudo(:my, :command)
      end
    end

    describe "#execute" do
      context "use outside of on scope" do
        after do
          task.clear
          Rake::Task.clear
        end

        let(:task) do
          Rake::Task.define_task("execute_outside_scope") do
            dsl.execute "whoami"
          end
        end

        it "prints helpful message to stderr", capture_io: true do
          expect do
            expect do
              task.invoke
            end.to output(/^.*Warning: `execute' should be wrapped in an `on' scope/).to_stderr
          end.to raise_error(NoMethodError)
        end
      end
    end

    describe "#invoke" do
      context "reinvoking" do
        it "will not reenable invoking task", capture_io: true do
          counter = 0

          Rake::Task.define_task("A") do
            counter += 1
          end

          expect do
            dsl.invoke("A")
            dsl.invoke("A")
          end.to change { counter }.by(1)
        end

        it "will print a message on stderr", capture_io: true do
          Rake::Task.define_task("B")

          expect do
            dsl.invoke("B")
            dsl.invoke("B")
          end.to output(/If you really meant to run this task again, use invoke!/).to_stderr
        end
      end
    end

    describe "#invoke!" do
      context "reinvoking" do
        it "will reenable invoking task", capture_io: true do
          counter = 0

          Rake::Task.define_task("C") do
            counter += 1
          end

          expect do
            dsl.invoke!("C")
            dsl.invoke!("C")
          end.to change { counter }.by(2)
        end

        it "will not print a message on stderr", capture_io: true do
          Rake::Task.define_task("D")

          expect do
            dsl.invoke!("D")
            dsl.invoke!("D")
          end.to_not output(/If you really meant to run this task again, use invoke!/).to_stderr
require "spec_helper"

require "capistrano/scm"

module RaiseNotImplementedMacro
  def raise_not_implemented_on(method)
    it "should raise NotImplemented on #{method}" do
      expect do
        subject.send(method)
      end.to raise_error(NotImplementedError)
    end
  end
end

RSpec.configure do
  include RaiseNotImplementedMacro
end

module DummyStrategy
  def test
    test!("you dummy!")
  end
end

module BlindStrategy; end

module Capistrano
  describe SCM do
    let(:context) { mock }

    describe "#initialize" do
      subject { Capistrano::SCM.new(context, DummyStrategy) }

      it "should load the provided strategy" do
        context.expects(:test).with("you dummy!")
        subject.test
      end
    end

    describe "Convenience methods" do
      subject { Capistrano::SCM.new(context, BlindStrategy) }

      describe "#test!" do
        it "should return call test on the context" do
          context.expects(:test).with(:x)
          subject.test!(:x)
        end
      end

      describe "#repo_url" do
        it "should return the repo url according to the context" do
          context.expects(:repo_url).returns(:url)
          expect(subject.repo_url).to eq(:url)
        end
      end

      describe "#repo_path" do
        it "should return the repo path according to the context" do
          context.expects(:repo_path).returns(:path)
          expect(subject.repo_path).to eq(:path)
        end
      end

      describe "#release_path" do
        it "should return the release path according to the context" do
          context.expects(:release_path).returns("/path/to/nowhere")
          expect(subject.release_path).to eq("/path/to/nowhere")
        end
      end

      describe "#fetch" do
        it "should call fetch on the context" do
          context.expects(:fetch)
          subject.fetch(:branch)
        end
      end
    end

    describe "With a 'blind' strategy" do
      subject { Capistrano::SCM.new(context, BlindStrategy) }

      describe "#test" do
        raise_not_implemented_on(:test)
      end

      describe "#check" do
        raise_not_implemented_on(:check)
      end

      describe "#clone" do
        raise_not_implemented_on(:clone)
      end

      describe "#update" do
        raise_not_implemented_on(:update)
      end

      describe "#release" do
        raise_not_implemented_on(:release)
      end
require "spec_helper"

require "capistrano/scm/svn"

module Capistrano
  describe SCM::Svn do
    subject { Capistrano::SCM::Svn.new }

    # This allows us to easily use `set`, `fetch`, etc. in the examples.
    let(:env) { Capistrano::Configuration.env }

    # Stub the SSHKit backend so we can set up expectations without the plugin
    # actually executing any commands.
    let(:backend) { stub }
    before { SSHKit::Backend.stubs(:current).returns(backend) }

    # Mimic the deploy flow tasks so that the plugin can register its hooks.
    before do
      Rake::Task.define_task("deploy:new_release_path")
      Rake::Task.define_task("deploy:check")
      Rake::Task.define_task("deploy:set_current_revision")
    end

    # Clean up any tasks or variables that the plugin defined.
    after do
      Rake::Task.clear
      Capistrano::Configuration.reset!
    end

    describe "#svn" do
      it "should call execute svn in the context, with arguments" do
        env.set(:svn_username, "someuser")
        env.set(:svn_password, "somepassword")
        backend.expects(:execute).with(:svn, :init, "--username someuser", "--password somepassword")
        subject.svn(:init)
      end
    end

    describe "#repo_mirror_exists?" do
      it "should call test for repo HEAD" do
        env.set(:repo_path, "/path/to/repo")
        backend.expects(:test).with " [ -d /path/to/repo/.svn ] "

        subject.repo_mirror_exists?
      end
    end

    describe "#check_repo_is_reachable" do
      it "should test the repo url" do
        env.set(:repo_url, :url)
        env.set(:svn_username, "someuser")
        env.set(:svn_password, "somepassword")
        backend.expects(:test).with(:svn, :info, :url, "--username someuser", "--password somepassword").returns(true)

        subject.check_repo_is_reachable
      end
    end

    describe "#clone_repo" do
      it "should run svn checkout" do
        env.set(:repo_url, :url)
        env.set(:repo_path, "path")
        env.set(:svn_username, "someuser")
        env.set(:svn_password, "somepassword")

        backend.expects(:execute).with(:svn, :checkout, :url, "path", "--username someuser", "--password somepassword")

        subject.clone_repo
      end
    end

    describe "#update_mirror" do
      it "should run svn update" do
        env.set(:repo_url, "url")
        env.set(:repo_path, "path")
        backend.expects(:capture).with(:svn, :info, "path").returns("URL: url\n")

        env.set(:svn_username, "someuser")
        env.set(:svn_password, "somepassword")
        backend.expects(:execute).with(:svn, :update, "--username someuser", "--password somepassword")

        subject.update_mirror
      end

      context "for specific revision" do
        it "should run svn update" do
          env.set(:repo_url, "url")
          env.set(:repo_path, "path")
          backend.expects(:capture).with(:svn, :info, "path").returns("URL: url\n")

          env.set(:svn_username, "someuser")
          env.set(:svn_password, "somepassword")
          env.set(:svn_revision, "12345")
          backend.expects(:execute).with(:svn, :update, "--username someuser", "--password somepassword", "--revision 12345")

          subject.update_mirror
        end
      end

      it "should run svn switch if repo_url is changed" do
        env.set(:repo_url, "url")
        env.set(:repo_path, "path")
        backend.expects(:capture).with(:svn, :info, "path").returns("URL: old_url\n")

        env.set(:svn_username, "someuser")
        env.set(:svn_password, "somepassword")
        backend.expects(:execute).with(:svn, :switch, "url", "--username someuser", "--password somepassword")
        backend.expects(:execute).with(:svn, :update, "--username someuser", "--password somepassword")

        subject.update_mirror
      end
    end

    describe "#archive_to_release_path" do
      it "should run svn export" do
        env.set(:release_path, "path")
        env.set(:svn_username, "someuser")
        env.set(:svn_password, "somepassword")

        backend.expects(:execute).with(:svn, :export, "--force", ".", "path", "--username someuser", "--password somepassword")

        subject.archive_to_release_path
      end
    end

    describe "#fetch_revision" do
      it "should capture svn version" do
        env.set(:repo_path, "path")

        backend.expects(:capture).with(:svnversion, "path").returns("12345")

        revision = subject.fetch_revision
        expect(revision).to eq("12345")
      end
    end
require "spec_helper"

require "capistrano/scm/git"

module Capistrano
  describe SCM::Git do
    subject { Capistrano::SCM::Git.new }

    # This allows us to easily use `set`, `fetch`, etc. in the examples.
    let(:env) { Capistrano::Configuration.env }

    # Stub the SSHKit backend so we can set up expectations without the plugin
    # actually executing any commands.
    let(:backend) { stub }
    before { SSHKit::Backend.stubs(:current).returns(backend) }

    # Mimic the deploy flow tasks so that the plugin can register its hooks.
    before do
      Rake::Task.define_task("deploy:new_release_path")
      Rake::Task.define_task("deploy:check")
      Rake::Task.define_task("deploy:set_current_revision")
    end

    # Clean up any tasks or variables that the plugin defined.
    after do
      Rake::Task.clear
      Capistrano::Configuration.reset!
    end

    describe "#set_defaults" do
      it "makes git_wrapper_path using a random hex value" do
        env.set(:tmp_dir, "/tmp")
        subject.set_defaults
        expect(env.fetch(:git_wrapper_path)).to match(%r{/tmp/git-ssh-\h{20}\.sh})
      end

      it "makes git_max_concurrent_connections" do
        subject.set_defaults
        expect(env.fetch(:git_max_concurrent_connections)).to eq(10)
        env.set(:git_max_concurrent_connections, 7)
        expect(env.fetch(:git_max_concurrent_connections)).to eq(7)
      end

      it "makes git_wait_interval" do
        subject.set_defaults
        expect(env.fetch(:git_wait_interval)).to eq(0)
        env.set(:git_wait_interval, 5)
        expect(env.fetch(:git_wait_interval)).to eq(5)
      end
    end

    describe "#git" do
      it "should call execute git in the context, with arguments" do
        backend.expects(:execute).with(:git, :init)
        subject.git(:init)
      end
    end

    describe "#repo_mirror_exists?" do
      it "should call test for repo HEAD" do
        env.set(:repo_path, "/path/to/repo")
        backend.expects(:test).with " [ -f /path/to/repo/HEAD ] "

        subject.repo_mirror_exists?
      end
    end

    describe "#check_repo_is_reachable" do
      it "should test the repo url" do
        env.set(:repo_url, "url")
        backend.expects(:execute).with(:git, :'ls-remote', "url", "HEAD").returns(true)

        subject.check_repo_is_reachable
      end
    end

    describe "#clone_repo" do
      it "should run git clone" do
        env.set(:repo_url, "url")
        env.set(:repo_path, "path")
        backend.expects(:execute).with(:git, :clone, "--mirror", "url", "path")

        subject.clone_repo
      end

      it "should run git clone in shallow mode" do
        env.set(:git_shallow_clone, "1")
        env.set(:repo_url, "url")
        env.set(:repo_path, "path")

        backend.expects(:execute).with(:git, :clone, "--mirror", "--depth", "1", "--no-single-branch", "url", "path")

        subject.clone_repo
      end

      context "with username and password specified" do
        before do
          env.set(:git_http_username, "hello")
          env.set(:git_http_password, "topsecret")
          env.set(:repo_url, "https://example.com/repo.git")
          env.set(:repo_path, "path")
        end

        it "should include the credentials in the url" do
          backend.expects(:execute).with(:git, :clone, "--mirror", "https://hello:topsecret@example.com/repo.git", "path")
          subject.clone_repo
        end
      end
    end

    describe "#update_mirror" do
      it "should run git update" do
        env.set(:repo_url, "url")

        backend.expects(:execute).with(:git, :remote, "set-url", "origin", "url")
        backend.expects(:execute).with(:git, :remote, :update, "--prune")

        subject.update_mirror
      end

      it "should run git update in shallow mode" do
        env.set(:git_shallow_clone, "1")
        env.set(:branch, "branch")
        env.set(:repo_url, "url")

        backend.expects(:execute).with(:git, :remote, "set-url", "origin", "url")
        backend.expects(:execute).with(:git, :fetch, "--depth", "1", "origin", "branch")

        subject.update_mirror
      end
    end

    describe "#archive_to_release_path" do
      it "should run git archive without a subtree" do
        env.set(:branch, "branch")
        env.set(:release_path, "path")

        backend.expects(:execute).with(:git, :archive, "branch", "| /usr/bin/env tar -x -f - -C", "path")

        subject.archive_to_release_path
      end

      it "should run git archive with a subtree" do
        env.set(:repo_tree, "tree")
        env.set(:branch, "branch")
        env.set(:release_path, "path")

        backend.expects(:execute).with(:git, :archive, "branch", "tree", "| /usr/bin/env tar -x --strip-components 1 -f - -C", "path")

        subject.archive_to_release_path
      end

      it "should run tar with an overridden name" do
        env.set(:branch, "branch")
        env.set(:release_path, "path")
        SSHKit.config.command_map.expects(:[]).with(:tar).returns("/usr/bin/env gtar")

        backend.expects(:execute).with(:git, :archive, "branch", "| /usr/bin/env gtar -x -f - -C", "path")

        subject.archive_to_release_path
      end
    end

    describe "#fetch_revision" do
      it "should capture git rev-list" do
        env.set(:branch, "branch")
        backend.expects(:capture).with(:git, "rev-list --max-count=1 branch").returns("81cec13b777ff46348693d327fc8e7832f79bf43")
        revision = subject.fetch_revision
        expect(revision).to eq("81cec13b777ff46348693d327fc8e7832f79bf43")
      end
require "spec_helper"

require "capistrano/scm/hg"

module Capistrano
  describe SCM::Hg do
    subject { Capistrano::SCM::Hg.new }

    # This allows us to easily use `set`, `fetch`, etc. in the examples.
    let(:env) { Capistrano::Configuration.env }

    # Stub the SSHKit backend so we can set up expectations without the plugin
    # actually executing any commands.
    let(:backend) { stub }
    before { SSHKit::Backend.stubs(:current).returns(backend) }

    # Mimic the deploy flow tasks so that the plugin can register its hooks.
    before do
      Rake::Task.define_task("deploy:new_release_path")
      Rake::Task.define_task("deploy:check")
      Rake::Task.define_task("deploy:set_current_revision")
    end

    # Clean up any tasks or variables that the plugin defined.
    after do
      Rake::Task.clear
      Capistrano::Configuration.reset!
    end

    describe "#hg" do
      it "should call execute hg in the context, with arguments" do
        backend.expects(:execute).with(:hg, :init)
        subject.hg(:init)
      end
    end

    describe "#repo_mirror_exists?" do
      it "should call test for repo HEAD" do
        env.set(:repo_path, "/path/to/repo")
        backend.expects(:test).with " [ -d /path/to/repo/.hg ] "

        subject.repo_mirror_exists?
      end
    end

    describe "#check_repo_is_reachable" do
      it "should test the repo url" do
        env.set(:repo_url, :url)
        backend.expects(:execute).with(:hg, "id", :url)

        subject.check_repo_is_reachable
      end
    end

    describe "#clone_repo" do
      it "should run hg clone" do
        env.set(:repo_url, :url)
        env.set(:repo_path, "path")

        backend.expects(:execute).with(:hg, "clone", "--noupdate", :url, "path")

        subject.clone_repo
      end
    end

    describe "#update_mirror" do
      it "should run hg update" do
        backend.expects(:execute).with(:hg, "pull")

        subject.update_mirror
      end
    end

    describe "#archive_to_release_path" do
      it "should run hg archive without a subtree" do
        env.set(:branch, :branch)
        env.set(:release_path, "path")

        backend.expects(:execute).with(:hg, "archive", "path", "--rev", :branch)

        subject.archive_to_release_path
      end

      it "should run hg archive with a subtree" do
        env.set(:repo_tree, "tree")
        env.set(:branch, :branch)
        env.set(:release_path, "path")
        env.set(:tmp_dir, "/tmp")

        SecureRandom.stubs(:hex).with(10).returns("random")
        backend.expects(:execute).with(:hg, "archive -p . -I", "tree", "--rev", :branch, "/tmp/random.tar")
        backend.expects(:execute).with(:mkdir, "-p", "path")
        backend.expects(:execute).with(:tar, "-x --strip-components 1 -f", "/tmp/random.tar", "-C", "path")
        backend.expects(:execute).with(:rm, "/tmp/random.tar")

        subject.archive_to_release_path
      end
    end

    describe "#fetch_revision" do
      it "should capture hg log" do
        env.set(:branch, :branch)
        backend.expects(:capture).with(:hg, "log --rev branch --template \"{node}\n\"").returns("01abcde")
        revision = subject.fetch_revision
        expect(revision).to eq("01abcde")
require "spec_helper"

module Capistrano
  describe Application do
    let(:app) { Application.new }
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), "..", "lib"))
$LOAD_PATH.unshift(File.dirname(__FILE__))
require "capistrano/all"
require "rspec"
require "mocha/api"
require "time"

# Requires supporting files with custom matchers and macros, etc,
# in ./support/ and its subdirectories.
Dir['#{File.dirname(__FILE__)}/support/**/*.rb'].each { |f| require f }

RSpec.configure do |config|
  config.raise_errors_for_deprecations!
  config.mock_framework = :mocha
  config.order = "random"

  config.around(:example, capture_io: true) do |example|
    begin
      Rake.application.options.trace_output = StringIO.new
      $stdout = StringIO.new
      $stderr = StringIO.new
      example.run
    ensure
      Rake.application.options.trace_output = STDERR
      $stdout = STDOUT
require "spec_helper"

describe Capistrano::DSL do
  let(:dsl) { Class.new.extend Capistrano::DSL }

  before do
    Capistrano::Configuration.reset!
  end

  describe "setting and fetching hosts" do
    describe "when defining a host using the `server` syntax" do
      before do
        dsl.server "example1.com", roles: %w{web}, active: true
        dsl.server "example2.com", roles: %w{web}
        dsl.server "example3.com", roles: %w{app web}, active: true
        dsl.server "example4.com", roles: %w{app}, primary: true
        dsl.server "example5.com", roles: %w{db}, no_release: true, active: true
      end

      describe "fetching all servers" do
        subject { dsl.roles(:all) }

        it "returns all servers" do
          expect(subject.map(&:hostname)).to eq %w{example1.com example2.com example3.com example4.com example5.com}
        end
      end

      describe "fetching all release servers" do
        context "with no additional options" do
          subject { dsl.release_roles(:all) }

          it "returns all release servers" do
            expect(subject.map(&:hostname)).to eq %w{example1.com example2.com example3.com example4.com}
          end
        end

        context "with property filter options" do
          subject { dsl.release_roles(:all, filter: :active) }

          it "returns all release servers that match the property filter" do
            expect(subject.map(&:hostname)).to eq %w{example1.com example3.com}
          end
        end
      end

      describe "fetching servers by multiple roles" do
        it "does not confuse the last role with options" do
          expect(dsl.roles(:app, :web).count).to eq 4
          expect(dsl.roles(:app, :web, filter: :active).count).to eq 2
        end
      end

      describe "fetching servers by role" do
        subject { dsl.roles(:app) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com example4.com}
        end
      end

      describe "fetching servers by an array of roles" do
        subject { dsl.roles([:app]) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com example4.com}
        end
      end

      describe "fetching filtered servers by role" do
        subject { dsl.roles(:app, filter: :active) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com}
        end
      end

      describe "fetching selected servers by role" do
        subject { dsl.roles(:app, select: :active) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com}
        end
      end

      describe "fetching the primary server by role" do
        context "when inferring primary status based on order" do
          subject { dsl.primary(:web) }
          it "returns the servers" do
            expect(subject.hostname).to eq "example1.com"
          end
        end

        context "when the attribute `primary` is explicitly set" do
          subject { dsl.primary(:app) }
          it "returns the servers" do
            expect(subject.hostname).to eq "example4.com"
          end
        end
      end

      describe "setting an internal host filter" do
        subject { dsl.roles(:app) }
        it "is ignored" do
          dsl.set :filter, host: "example3.com"
          expect(subject.map(&:hostname)).to eq(["example3.com", "example4.com"])
        end
      end

      describe "setting an internal role filter" do
        subject { dsl.roles(:app) }
        it "ignores it" do
          dsl.set :filter, role: :web
          expect(subject.map(&:hostname)).to eq(["example3.com", "example4.com"])
        end
      end

      describe "setting an internal host and role filter" do
        subject { dsl.roles(:app) }
        it "ignores it" do
          dsl.set :filter, role: :web, host: "example1.com"
          expect(subject.map(&:hostname)).to eq(["example3.com", "example4.com"])
        end
      end

      describe "setting an internal regexp host filter" do
        subject { dsl.roles(:all) }
        it "is ignored" do
          dsl.set :filter, host: /1/
          expect(subject.map(&:hostname)).to eq(%w{example1.com example2.com example3.com example4.com example5.com})
        end
      end

      describe "setting an internal hosts filter" do
        subject { dsl.roles(:app) }
        it "is ignored" do
          dsl.set :filter, hosts: "example3.com"
          expect(subject.map(&:hostname)).to eq(["example3.com", "example4.com"])
        end
      end

      describe "setting an internal roles filter" do
        subject { dsl.roles(:app) }
        it "ignores it" do
          dsl.set :filter, roles: :web
          expect(subject.map(&:hostname)).to eq(["example3.com", "example4.com"])
        end
      end

      describe "setting an internal hosts and roles filter" do
        subject { dsl.roles(:app) }
        it "ignores it" do
          dsl.set :filter, roles: :web, hosts: "example1.com"
          expect(subject.map(&:hostname)).to eq(["example3.com", "example4.com"])
        end
      end

      describe "setting an internal regexp hosts filter" do
        subject { dsl.roles(:all) }
        it "is ignored" do
          dsl.set :filter, hosts: /1/
          expect(subject.map(&:hostname)).to eq(%w{example1.com example2.com example3.com example4.com example5.com})
        end
      end
    end

    describe "when defining role with reserved name" do
      it "fails with ArgumentError" do
        expect do
          dsl.role :all, %w{example1.com}
        end.to raise_error(ArgumentError, "all reserved name for role. Please choose another name")
      end
    end

    describe "when defining hosts using the `role` syntax" do
      before do
        dsl.role :web, %w{example1.com example2.com example3.com}
        dsl.role :web, %w{example1.com}, active: true
        dsl.role :app, %w{example3.com example4.com}
        dsl.role :app, %w{example3.com}, active: true
        dsl.role :app, %w{example4.com}, primary: true
        dsl.role :db, %w{example5.com}, no_release: true
      end

      describe "fetching all servers" do
        subject { dsl.roles(:all) }

        it "returns all servers" do
          expect(subject.map(&:hostname)).to eq %w{example1.com example2.com example3.com example4.com example5.com}
        end
      end

      describe "fetching all release servers" do
        context "with no additional options" do
          subject { dsl.release_roles(:all) }

          it "returns all release servers" do
            expect(subject.map(&:hostname)).to eq %w{example1.com example2.com example3.com example4.com}
          end
        end

        context "with filter options" do
          subject { dsl.release_roles(:all, filter: :active) }

          it "returns all release servers that match the filter" do
            expect(subject.map(&:hostname)).to eq %w{example1.com example3.com}
          end
        end
      end

      describe "fetching servers by role" do
        subject { dsl.roles(:app) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com example4.com}
        end
      end

      describe "fetching servers by an array of roles" do
        subject { dsl.roles([:app]) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com example4.com}
        end
      end

      describe "fetching filtered servers by role" do
        subject { dsl.roles(:app, filter: :active) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com}
        end
      end

      describe "fetching selected servers by role" do
        subject { dsl.roles(:app, select: :active) }

        it "returns the servers" do
          expect(subject.map(&:hostname)).to eq %w{example3.com}
        end
      end

      describe "fetching the primary server by role" do
        context "when inferring primary status based on order" do
          subject { dsl.primary(:web) }
          it "returns the servers" do
            expect(subject.hostname).to eq "example1.com"
          end
        end

        context "when the attribute `primary` is explicity set" do
          subject { dsl.primary(:app) }
          it "returns the servers" do
            expect(subject.hostname).to eq "example4.com"
          end
        end
      end
    end

    describe "when defining a host using a combination of the `server` and `role` syntax" do
      before do
        dsl.server "db@example1.com:1234", roles: %w{db}, active: true
        dsl.server "root@example1.com:1234", roles: %w{web}, active: true
        dsl.server "example1.com:5678", roles: %w{web}, active: true
        dsl.role :app, %w{deployer@example1.com:1234}
        dsl.role :app, %w{example1.com:5678}
      end

      describe "fetching all servers" do
        it "creates one server per hostname, ignoring user combinations" do
          expect(dsl.roles(:all).size).to eq(2)
        end
      end

      describe "fetching servers for a role" do
        it "roles defined using the `server` syntax are included" do
          as = dsl.roles(:web).map { |server| "#{server.user}@#{server.hostname}:#{server.port}" }
          expect(as.size).to eq(2)
          expect(as[0]).to eq("deployer@example1.com:1234")
          expect(as[1]).to eq("@example1.com:5678")
        end

        it "roles defined using the `role` syntax are included" do
          as = dsl.roles(:app).map { |server| "#{server.user}@#{server.hostname}:#{server.port}" }
          expect(as.size).to eq(2)
          expect(as[0]).to eq("deployer@example1.com:1234")
          expect(as[1]).to eq("@example1.com:5678")
        end
      end
    end

    describe "when setting user and port" do
      subject { dsl.roles(:all).map { |server| "#{server.user}@#{server.hostname}:#{server.port}" }.first }

      describe "using the :user property" do
        it "takes precedence over in the host string" do
          dsl.server "db@example1.com:1234", roles: %w{db}, active: true, user: "brian"
          expect(subject).to eq("brian@example1.com:1234")
        end
      end

      describe "using the :port property" do
        it "takes precedence over in the host string" do
          dsl.server "db@example1.com:9090", roles: %w{db}, active: true, port: 1234
          expect(subject).to eq("db@example1.com:1234")
        end
      end
    end
  end

  describe "setting and fetching variables" do
    before do
      dsl.set :scm, :git
    end

    context "without a default" do
      context "when the variables is defined" do
        it "returns the variable" do
          expect(dsl.fetch(:scm)).to eq :git
        end
      end

      context "when the variables is undefined" do
        it "returns nil" do
          expect(dsl.fetch(:source_control)).to be_nil
        end
      end
    end

    context "with a default" do
      context "when the variables is defined" do
        it "returns the variable" do
          expect(dsl.fetch(:scm, :svn)).to eq :git
        end
      end

      context "when the variables is undefined" do
        it "returns the default" do
          expect(dsl.fetch(:source_control, :svn)).to eq :svn
        end
      end
    end

    context "with a block" do
      context "when the variables is defined" do
        it "returns the variable" do
          expect(dsl.fetch(:scm) { :svn }).to eq :git
        end
      end

      context "when the variables is undefined" do
        it "calls the block" do
          expect(dsl.fetch(:source_control) { :svn }).to eq :svn
        end
      end
    end
  end

  describe "asking for a variable" do
    let(:stdin) { stub(tty?: true) }

    before do
      dsl.ask(:scm, :svn, stdin: stdin)
      $stdout.stubs(:print)
    end

    context "variable is provided" do
      before do
        stdin.expects(:gets).returns("git")
      end

      it "sets the input as the variable" do
        expect(dsl.fetch(:scm)).to eq "git"
      end
    end

    context "variable is not provided" do
      before do
        stdin.expects(:gets).returns("")
      end

      it "sets the variable as the default" do
        expect(dsl.fetch(:scm)).to eq :svn
      end
    end
  end

  describe "checking for presence" do
    subject { dsl.any? :linked_files }

    before do
      dsl.set(:linked_files, linked_files)
    end

    context "variable is an non-empty array" do
      let(:linked_files) { %w{1} }

      it { expect(subject).to be_truthy }
    end

    context "variable is an empty array" do
      let(:linked_files) { [] }
      it { expect(subject).to be_falsey }
    end

    context "variable exists, is not an array" do
      let(:linked_files) { stub }
      it { expect(subject).to be_truthy }
    end

    context "variable is nil" do
      let(:linked_files) { nil }
      it { expect(subject).to be_falsey }
    end
  end

  describe "configuration SSHKit" do
    let(:config) { SSHKit.config }
    let(:backend) { SSHKit.config.backend.config }
    let(:default_env) { { rails_env: :production } }

    before do
      dsl.set(:format, :dot)
      dsl.set(:log_level, :debug)
      dsl.set(:default_env, default_env)
      dsl.set(:pty, true)
      dsl.set(:connection_timeout, 10)
      dsl.set(:ssh_options, keys: %w(/home/user/.ssh/id_rsa),
                            forward_agent: false,
                            auth_methods: %w(publickey password))
      dsl.configure_backend
    end

    it "sets the output" do
      expect(config.output).to be_a SSHKit::Formatter::Dot
    end

    it "sets the output verbosity" do
      expect(config.output_verbosity).to eq 0
    end

    it "sets the default env" do
      expect(config.default_env).to eq default_env
    end

    it "sets the backend pty" do
      expect(backend.pty).to be_truthy
    end

    it "sets the backend connection timeout" do
      expect(backend.connection_timeout).to eq 10
    end

    it "sets the backend ssh_options" do
      expect(backend.ssh_options[:keys]).to eq %w(/home/user/.ssh/id_rsa)
      expect(backend.ssh_options[:forward_agent]).to eq false
      expect(backend.ssh_options[:auth_methods]).to eq %w(publickey password)
    end
  end

  describe "on()" do
    describe "when passed server objects" do
      before do
        dsl.server "example1.com", roles: %w{web}, active: true
        dsl.server "example2.com", roles: %w{web}
        dsl.server "example3.com", roles: %w{app web}, active: true
        dsl.server "example4.com", roles: %w{app}, primary: true
        dsl.server "example5.com", roles: %w{db}, no_release: true
        @coordinator = mock("coordinator")
        @coordinator.expects(:each).returns(nil)
        ENV.delete "ROLES"
        ENV.delete "HOSTS"
      end

      it "filters by role from the :filter variable" do
        hosts = dsl.roles(:web)
        all = dsl.roles(:all)
        SSHKit::Coordinator.expects(:new).with(hosts).returns(@coordinator)
        dsl.set :filter, role: "web"
        dsl.on(all)
      end

      it "filters by host and role from the :filter variable" do
        all = dsl.roles(:all)
        SSHKit::Coordinator.expects(:new).with([]).returns(@coordinator)
        dsl.set :filter, role: "db", host: "example3.com"
        dsl.on(all)
      end

      it "filters by roles from the :filter variable" do
        hosts = dsl.roles(:web)
        all = dsl.roles(:all)
        SSHKit::Coordinator.expects(:new).with(hosts).returns(@coordinator)
        dsl.set :filter, roles: "web"
        dsl.on(all)
      end

      it "filters by hosts and roles from the :filter variable" do
        all = dsl.roles(:all)
        SSHKit::Coordinator.expects(:new).with([]).returns(@coordinator)
        dsl.set :filter, roles: "db", hosts: "example3.com"
        dsl.on(all)
      end

      it "filters from ENV[ROLES]" do
        hosts = dsl.roles(:db)
        all = dsl.roles(:all)
        SSHKit::Coordinator.expects(:new).with(hosts).returns(@coordinator)
        ENV["ROLES"] = "db"
        dsl.on(all)
      end

      it "filters from ENV[HOSTS]" do
        hosts = dsl.roles(:db)
        all = dsl.roles(:all)
        SSHKit::Coordinator.expects(:new).with(hosts).returns(@coordinator)
        ENV["HOSTS"] = "example5.com"
        dsl.on(all)
      end

      it "filters by ENV[HOSTS] && ENV[ROLES]" do
        all = dsl.roles(:all)
        SSHKit::Coordinator.expects(:new).with([]).returns(@coordinator)
        ENV["HOSTS"] = "example5.com"
        ENV["ROLES"] = "web"
        dsl.on(all)
      end
    end

    describe "when passed server literal names" do
      before do
        ENV.delete "ROLES"
        ENV.delete "HOSTS"
        @coordinator = mock("coordinator")
        @coordinator.expects(:each).returns(nil)
      end

      it "selects nothing when a role filter is present" do
        dsl.set :filter, role: "web"
        SSHKit::Coordinator.expects(:new).with([]).returns(@coordinator)
        dsl.on("my.server")
      end

      it "selects using the string when a host filter is present" do
        dsl.set :filter, host: "server.local"
        SSHKit::Coordinator.expects(:new).with(["server.local"]).returns(@coordinator)
        dsl.on("server.local")
      end

      it "doesn't select when a host filter is present that doesn't match" do
        dsl.set :filter, host: "ruby.local"
        SSHKit::Coordinator.expects(:new).with([]).returns(@coordinator)
        dsl.on("server.local")
      end

      it "selects nothing when a roles filter is present" do
        dsl.set :filter, roles: "web"
        SSHKit::Coordinator.expects(:new).with([]).returns(@coordinator)
        dsl.on("my.server")
      end

      it "selects using the string when a hosts filter is present" do
        dsl.set :filter, hosts: "server.local"
        SSHKit::Coordinator.expects(:new).with(["server.local"]).returns(@coordinator)
        dsl.on("server.local")
      end

      it "doesn't select when a hosts filter is present that doesn't match" do
        dsl.set :filter, hosts: "ruby.local"
        SSHKit::Coordinator.expects(:new).with([]).returns(@coordinator)
        dsl.on("server.local")
      end
    end
  end

  describe "role_properties()" do
    before do
      dsl.role :redis, %w[example1.com example2.com], redis: { port: 6379, type: :slave }
      dsl.server "example1.com", roles: %w{web}, active: true, web: { port: 80 }
      dsl.server "example2.com", roles: %w{web redis}, web: { port: 81 }, redis: { type: :master }
      dsl.server "example3.com", roles: %w{app}, primary: true
    end

    it "retrieves properties for a single role as a set" do
      rps = dsl.role_properties(:app)
      expect(rps).to eq(Set[{ hostname: "example3.com", role: :app }])
    end

    it "retrieves properties for multiple roles as a set" do
      rps = dsl.role_properties(:app, :web)
      expect(rps).to eq(Set[{ hostname: "example3.com", role: :app }, { hostname: "example1.com", role: :web, port: 80 }, { hostname: "example2.com", role: :web, port: 81 }])
    end

    it "yields the properties for a single role" do
      recipient = mock("recipient")
      recipient.expects(:doit).with("example1.com", :redis, port: 6379, type: :slave)
      recipient.expects(:doit).with("example2.com", :redis, port: 6379, type: :master)
      dsl.role_properties(:redis) do |host, role, props|
        recipient.doit(host, role, props)
      end
    end

    it "yields the properties for multiple roles" do
      recipient = mock("recipient")
      recipient.expects(:doit).with("example1.com", :redis, port: 6379, type: :slave)
      recipient.expects(:doit).with("example2.com", :redis, port: 6379, type: :master)
      recipient.expects(:doit).with("example3.com", :app, nil)
      dsl.role_properties(:redis, :app) do |host, role, props|
        recipient.doit(host, role, props)
      end
    end

    it "yields the merged properties for multiple roles" do
      recipient = mock("recipient")
      recipient.expects(:doit).with("example1.com", :redis, port: 6379, type: :slave)
      recipient.expects(:doit).with("example2.com", :redis, port: 6379, type: :master)
      recipient.expects(:doit).with("example1.com", :web, port: 80)
      recipient.expects(:doit).with("example2.com", :web, port: 81)
      dsl.role_properties(:redis, :web) do |host, role, props|
        recipient.doit(host, role, props)
      end
    end

    it "honours a property filter before yielding" do
      recipient = mock("recipient")
      recipient.expects(:doit).with("example1.com", :redis, port: 6379, type: :slave)
      recipient.expects(:doit).with("example1.com", :web, port: 80)
      dsl.role_properties(:redis, :web, select: :active) do |host, role, props|
        recipient.doit(host, role, props)
      end
    end
require "English"
require "fileutils"
require "pathname"

module TestApp
  extend self

  def install
    install_test_app_with(default_config)
  end

  def default_config
    <<-CONFIG
      set :deploy_to, '#{deploy_to}'
      set :repo_url, 'git://github.com/capistrano/capistrano.git'
      set :branch, 'master'
      set :ssh_options, { keys: "\#{ENV['HOME']}/.vagrant.d/insecure_private_key", auth_methods: ['publickey'] }
      server 'vagrant@localhost:2220', roles: %w{web app}
      set :linked_files, #{linked_files}
      set :linked_dirs, #{linked_dirs}
      set :format_options, log_file: nil
      set :local_user, #{current_user.inspect}
    CONFIG
  end

  def linked_files
    %w{config/database.yml}
  end

  def linked_file
    shared_path.join(linked_files.first)
  end

  def linked_dirs
    %w{bin log public/system}
  end

  def create_test_app
    FileUtils.rm_rf(test_app_path)
    FileUtils.mkdir(test_app_path)

    File.open(gemfile, "w+") do |file|
      file.write "gem 'capistrano', path: '#{path_to_cap}'"
    end

    Dir.chdir(test_app_path) do
      run "bundle"
    end
  end

  def install_test_app_with(config)
    create_test_app
    Dir.chdir(test_app_path) do
      run "cap install STAGES=#{stage}"
    end
    write_local_deploy_file(config)
  end

  def write_local_deploy_file(config)
    File.open(test_stage_path, "w") do |file|
      file.write config
    end
  end

  def write_local_stage_file(filename, config=nil)
    File.open(test_app_path.join("config/deploy/#{filename}"), "w") do |file|
      file.write(config) if config
    end
  end

  def append_to_deploy_file(config)
    File.open(test_stage_path, "a") do |file|
      file.write config + "\n"
    end
  end

  def prepend_to_capfile(config)
    current_capfile = File.read(capfile)
    File.open(capfile, "w") do |file|
      file.write config
      file.write current_capfile
    end
  end

  def create_shared_directory(path)
    FileUtils.mkdir_p(shared_path.join(path))
  end

  def create_shared_file(path)
    File.open(shared_path.join(path), "w")
  end

  def cap(task, subdirectory=nil)
    run "cap #{stage} #{task} --trace", subdirectory
  end

  def run(command, subdirectory=nil)
    output = nil
    command = "bundle exec #{command}" unless command =~ /^bundle\b/
    dir = subdirectory ? test_app_path.join(subdirectory) : test_app_path
    Dir.chdir(dir) do
      output = with_clean_bundler_env { `#{command}` }
    end
    [$CHILD_STATUS.success?, output]
  end

  def stage
    "test"
  end

  def test_stage_path
    test_app_path.join("config/deploy/test.rb")
  end

  def test_app_path
    Pathname.new("/tmp/test_app")
  end

  def deploy_to
    Pathname.new("/home/vagrant/var/www/deploy")
  end

  def shared_path
    deploy_to.join("shared")
  end

  def current_path
    deploy_to.join("current")
  end

  def releases_path
    deploy_to.join("releases")
  end

  def release_path(t=timestamp)
    releases_path.join(t)
  end

  def timestamp(offset=0)
    (Time.now.utc + offset).strftime("%Y%m%d%H%M%S")
  end

  def repo_path
    deploy_to.join("repo")
  end

  def path_to_cap
    File.expand_path(".")
  end

  def gemfile
    test_app_path.join("Gemfile")
  end

  def capfile
    test_app_path.join("Capfile")
  end

  def current_user
    "(GitHub Web Flow) via ShipIt"
  end

  def task_dir
    test_app_path.join("lib/capistrano/tasks")
  end

  def copy_task_to_test_app(source)
    FileUtils.cp(source, task_dir)
  end

  def config_path
    test_app_path.join("config")
  end

  def move_configuration_to_custom_location(location)
    prepend_to_capfile(
      <<-CONFIG
        set :stage_config_path, "app/config/deploy"
        set :deploy_config_path, "app/config/deploy.rb"
      CONFIG
    )

    location = test_app_path.join(location)
    FileUtils.mkdir_p(location)
    FileUtils.mv(config_path, location)
  end

  def git_wrapper_path_glob
    "/tmp/git-ssh-*.sh"
  end

  def with_clean_bundler_env(&block)
    return yield unless defined?(Bundler)

    if Bundler.respond_to?(:with_unbundled_env)
      Bundler.with_unbundled_env(&block)
    else
      Bundler.with_clean_env(&block)
    end
  end
require "shellwords"

Then(/^references in the remote repo are listed$/) do
  expect(@output).to include("refs/heads/master")
end

Then(/^git wrapper permissions are 0700$/) do
  permissions_test = %Q([ $(stat -c "%a" #{TestApp.git_wrapper_path_glob}) == "700" ])
  _stdout, _stderr, status = vagrant_cli_command("ssh -c #{permissions_test.shellescape}")

  expect(status).to be_success
end

Then(/^the shared path is created$/) do
  run_vagrant_command(test_dir_exists(TestApp.shared_path))
end

Then(/^the releases path is created$/) do
  run_vagrant_command(test_dir_exists(TestApp.releases_path))
end

Then(/^(\d+) valid releases are kept/) do |num|
  test = %Q([ $(ls -g #{TestApp.releases_path} | grep -E '[0-9]{14}' | wc -l) == "#{num}" ])
  _, _, status = vagrant_cli_command("ssh -c #{test.shellescape}")
  expect(status).to be_success
end

Then(/^the invalid (.+) release is ignored$/) do |filename|
  test = "ls -g #{TestApp.releases_path} | grep #{filename}"
  _, _, status = vagrant_cli_command("ssh -c #{test.shellescape}")
  expect(status).to be_success
end

Then(/^directories in :linked_dirs are created in shared$/) do
  TestApp.linked_dirs.each do |dir|
    run_vagrant_command(test_dir_exists(TestApp.shared_path.join(dir)))
  end
end

Then(/^directories referenced in :linked_files are created in shared$/) do
  dirs = TestApp.linked_files.map { |path| TestApp.shared_path.join(path).dirname }
  dirs.each do |dir|
    run_vagrant_command(test_dir_exists(dir))
  end
end

Then(/^the repo is cloned$/) do
  run_vagrant_command(test_dir_exists(TestApp.repo_path))
end

Then(/^the release is created$/) do
  run_vagrant_command("ls -g #{TestApp.releases_path}")
end

Then(/^file symlinks are created in the new release$/) do
  TestApp.linked_files.each do |file|
    run_vagrant_command(test_symlink_exists(TestApp.current_path.join(file)))
  end
end

Then(/^directory symlinks are created in the new release$/) do
  pending
  TestApp.linked_dirs.each do |dir|
    run_vagrant_command(test_symlink_exists(TestApp.release_path.join(dir)))
  end
end

Then(/^the current directory will be a symlink to the release$/) do
  run_vagrant_command(exists?("e", TestApp.current_path))
end

Then(/^the deploy\.rb file is created$/) do
  file = TestApp.test_app_path.join("config/deploy.rb")
  expect(File.exist?(file)).to be true
end

Then(/^the default stage files are created$/) do
  staging = TestApp.test_app_path.join("config/deploy/staging.rb")
  production = TestApp.test_app_path.join("config/deploy/production.rb")
  expect(File.exist?(staging)).to be true
  expect(File.exist?(production)).to be true
end

Then(/^the tasks folder is created$/) do
  path = TestApp.test_app_path.join("lib/capistrano/tasks")
  expect(Dir.exist?(path)).to be true
end

Then(/^the specified stage files are created$/) do
  qa = TestApp.test_app_path.join("config/deploy/qa.rb")
  production = TestApp.test_app_path.join("config/deploy/production.rb")
  expect(File.exist?(qa)).to be true
  expect(File.exist?(production)).to be true
end

Then(/^it creates the file with the remote_task prerequisite$/) do
  TestApp.linked_files.each do |file|
    run_vagrant_command(test_file_exists(TestApp.shared_path.join(file)))
  end
end

Then(/^it will not recreate the file$/) do
  #
end

Then(/^the task is successful$/) do
  expect(@success).to be true
end

Then(/^the task fails$/) do
  expect(@success).to be_falsey
end

Then(/^the failure task will run$/) do
  failed = TestApp.shared_path.join("failed")
  run_vagrant_command(test_file_exists(failed))
end

Then(/^the failure task will not run$/) do
  failed = TestApp.shared_path.join("failed")
  expect { run_vagrant_command(test_file_exists(failed)) }
    .to raise_error(VagrantHelpers::VagrantSSHCommandError)
end

When(/^an error is raised$/) do
  error = TestApp.shared_path.join("fail")
  run_vagrant_command(test_file_exists(error))
end

Then(/contains "([^"]*)" in the output/) do |expected|
  expect(@output).to include(expected)
end

Then(/the output matches "([^"]*)" followed by "([^"]*)"/) do |expected, followedby|
  expect(@output).to match(/#{expected}.*#{followedby}/m)
end

Then(/doesn't contain "([^"]*)" in the output/) do |expected|
  expect(@output).not_to include(expected)
end

Then(/the current symlink points to the previous release/) do
  previous_release_path = @release_paths[-2]

  run_vagrant_command(symlinked?(TestApp.current_path, previous_release_path))
end

Then(/^the current symlink points to that specific release$/) do
  specific_release_path = TestApp.releases_path.join(@rollback_release)

When(/^I run cap "(.*?)"$/) do |task|
  @success, @output = TestApp.cap(task)
end

When(/^I run cap "(.*?)" within the "(.*?)" directory$/) do |task, directory|
  @success, @output = TestApp.cap(task, directory)
end

When(/^I run cap "(.*?)" as part of a release$/) do |task|
  TestApp.cap("deploy:new_release_path #{task}")
end

When(/^I run "(.*?)"$/) do |command|
  @success, @output = TestApp.run(command)
end

When(/^I rollback to a specific release$/) do
  @rollback_release = @release_paths.first.split("/").last

  step %Q{I run cap "deploy:rollback ROLLBACK_RELEASE=#{@rollback_release}"}
Given(/^a test app with the default configuration$/) do
  TestApp.install
end

Given(/^a test app without any configuration$/) do
  TestApp.create_test_app
end

Given(/^servers with the roles app and web$/) do
  begin
    vagrant_cli_command("up")
  rescue
    nil
  end
end

Given(/^a linked file "(.*?)"$/) do |file|
  # ignoring other linked files
  TestApp.append_to_deploy_file("set :linked_files, ['#{file}']")
end

Given(/^file "(.*?)" exists in shared path$/) do |file|
  file_shared_path = TestApp.shared_path.join(file)
  run_vagrant_command("mkdir -p #{file_shared_path.dirname}")
  run_vagrant_command("touch #{file_shared_path}")
end

Given(/^all linked files exists in shared path$/) do
  TestApp.linked_files.each do |linked_file|
    step %Q{file "#{linked_file}" exists in shared path}
  end
end

Given(/^file "(.*?)" does not exist in shared path$/) do |file|
  file_shared_path = TestApp.shared_path.join(file)
  run_vagrant_command("mkdir -p #{TestApp.shared_path}")
  run_vagrant_command("touch #{file_shared_path} && rm #{file_shared_path}")
end

Given(/^a custom task to generate a file$/) do
  TestApp.copy_task_to_test_app("spec/support/tasks/database.rake")
end

Given(/^a task which executes as root$/) do
  TestApp.copy_task_to_test_app("spec/support/tasks/root.rake")
end

Given(/config stage file has line "(.*?)"/) do |line|
  TestApp.append_to_deploy_file(line)
end

Given(/^the configuration is in a custom location$/) do
  TestApp.move_configuration_to_custom_location("app")
end

Given(/^a custom task that will simulate a failure$/) do
  safely_remove_file(TestApp.shared_path.join("failed"))
  TestApp.copy_task_to_test_app("spec/support/tasks/fail.rake")
end

Given(/^a custom task to run in the event of a failure$/) do
  safely_remove_file(TestApp.shared_path.join("failed"))
  TestApp.copy_task_to_test_app("spec/support/tasks/failed.rake")
end

Given(/^a stage file named (.+)$/) do |filename|
  TestApp.write_local_stage_file(filename)
end

Given(/^I make (\d+) deployments$/) do |count|
  step "all linked files exists in shared path"

  @release_paths = (1..count.to_i).map do
    TestApp.cap("deploy")
    stdout, _stderr = run_vagrant_command("readlink #{TestApp.current_path}")

    stdout.strip
  end
end

Given(/^(\d+) valid existing releases$/) do |num|
  a_day = 86_400 # in seconds
  (1...num).each_slice(100) do |num_batch|
    dirs = num_batch.map do |i|
      offset = -(a_day * i)
      TestApp.release_path(TestApp.timestamp(offset))
    end
    run_vagrant_command("mkdir -p #{dirs.join(' ')}")
  end
end
PROJECT_ROOT = File.expand_path("../../../", __FILE__)
VAGRANT_ROOT = File.join(PROJECT_ROOT, "spec/support")
VAGRANT_BIN = ENV["VAGRANT_BIN"] || "vagrant"

at_exit do
  if ENV["KEEP_RUNNING"]
    VagrantHelpers.run_vagrant_command("rm -rf /home/vagrant/var")
  end
end

require "open3"

module VagrantHelpers
  extend self

  class VagrantSSHCommandError < RuntimeError; end

  at_exit do
    if ENV["KEEP_RUNNING"]
      puts "Vagrant vm will be left up because KEEP_RUNNING is set."
      puts "Rerun without KEEP_RUNNING set to cleanup the vm."
    else
      vagrant_cli_command("destroy -f")
    end
  end

  def vagrant_cli_command(command)
    puts "[vagrant] #{command}"
    stdout, stderr, status = Dir.chdir(VAGRANT_ROOT) do
      Open3.capture3("#{VAGRANT_BIN} #{command}")
    end

    (stdout + stderr).each_line { |line| puts "[vagrant] #{line}" }

    [stdout, stderr, status]
  end

  def run_vagrant_command(command)
    stdout, stderr, status = vagrant_cli_command("ssh -c #{command.inspect}")
    return [stdout, stderr] if status.success?
    raise VagrantSSHCommandError, status
  end

  def puts(message)
    # Attach log messages to the current cucumber feature (`log`),
    # or simply puts to the console (`super`) if we are outside of cucumber.
    respond_to?(:log) ? log(message) : super(message)
  end
end

module RemoteCommandHelpers
  def test_dir_exists(path)
    exists?("d", path)
  end

  def test_symlink_exists(path)
    exists?("L", path)
  end

  def test_file_exists(path)
    exists?("f", path)
  end

  def exists?(type, path)
    %Q{[ -#{type} "#{path}" ]}
  end

  def symlinked?(symlink_path, target_path)
    "[ #{symlink_path} -ef #{target_path} ]"
  end

  def safely_remove_file(_path)
    run_vagrant_command("rm #{test_file}")
  rescue
    VagrantHelpers::VagrantSSHCommandError
#!/usr/bin/ruby
#
# Applies the colors defined in .itermcolors file to the current session using
# proprietary escape codes of iTerm2
#
# Author: Junegunn Choi <https://github.com/junegunn> Reference:
# https://iterm2.com/documentation-escape-codes.html

require 'rexml/document'
require 'io/console'

files = ARGV.select { |f| File.exists? f }
if files.empty?
  puts "usage: #$0 <itermcolors files...>"
  exit 1
end

if ENV.has_key? 'TMUX'
  puts 'Does not work on tmux'
  exit 1
end

preview = files.length > 1
history = []
until files.empty?
  file = files.shift
  print "[#{File.basename file, '.*'}] " if preview
  begin
    colors = {}
    root = REXML::Document.new(File.read file).root
    root.elements['dict'].select { |e| e.is_a? REXML::Element }.each do |dict|
      if dict.previous_element && !dict.previous_element.text.strip.empty?
        type = dict.previous_element.text.downcase.gsub(/^ansi\s+|\s+color$/, '')
        colors[type] = {}
      end
      next unless type

      dict.elements.each_slice(2) do |elems|
        key = val = nil
        elems.each do |elem|
          case elem.name.downcase
          when 'key'  then key = elem.text
          when 'real' then val = elem.text
          end
        end
        colors[type][key.sub(/\s.+/, '').downcase.to_sym] =
          '%02x' % [255, val.to_f.*(256).to_i].min if key && val
      end
      colors[type] &&= colors[type].values_at(:red, :green, :blue).join
    end

    colors.each do |type, rgb|
      print "\e]P" << {
        'foreground'    => 'g',
        'background'    => 'h',
        'bold'          => 'i',
        'selection'     => 'j',
        'selected text' => 'k',
        'cursor'        => 'l',
        'cursor text'   => 'm',
      }.fetch(type, '%x' % type.to_i) << rgb << "\e\\"
    end
    case IO.console.getch.ord
    when 127   # backspace
      files.unshift *[history.pop, file].compact
    when 3, 27 # ctrl-c, esc
      break
    else
      history << file
    end
  rescue Exception
    print '(X) '
  end
end
puts if preview
# frozen_string_literal: true

require "concurrent/map"
require "openssl"

module ActiveSupport
  # KeyGenerator is a simple wrapper around OpenSSL's implementation of PBKDF2.
  # It can be used to derive a number of keys for various purposes from a given secret.
  # This lets Rails applications have a single secure secret, but avoid reusing that
  # key in multiple incompatible contexts.
  class KeyGenerator
    class << self
      def hash_digest_class=(klass)
        if klass.kind_of?(Class) && klass < OpenSSL::Digest
          @hash_digest_class = klass
        else
          raise ArgumentError, "#{klass} is expected to be an OpenSSL::Digest subclass"
        end
      end

      def hash_digest_class
        @hash_digest_class ||= OpenSSL::Digest::SHA1
      end
    end

    def initialize(secret, options = {})
      @secret = secret
      # The default iterations are higher than required for our key derivation uses
      # on the off chance someone uses this for password storage
      @iterations = options[:iterations] || 2**16
      # Also allow configuration here so people can use this to build a rotation
      # scheme when switching the digest class.
      @hash_digest_class = options[:hash_digest_class] || self.class.hash_digest_class
    end

    # Returns a derived key suitable for use.  The default key_size is chosen
    # to be compatible with the default settings of ActiveSupport::MessageVerifier.
    # i.e. OpenSSL::Digest::SHA1#block_length
    def generate_key(salt, key_size = 64)
      OpenSSL::PKCS5.pbkdf2_hmac(@secret, salt, @iterations, key_size, @hash_digest_class.new)
    end
  end

  # CachingKeyGenerator is a wrapper around KeyGenerator which allows users to avoid
  # re-executing the key generation process when it's called using the same salt and
  # key_size.
  class CachingKeyGenerator
    def initialize(key_generator)
      @key_generator = key_generator
      @cache_keys = Concurrent::Map.new
    end

    # Returns a derived key suitable for use.
    def generate_key(*args)
      @cache_keys[args.join("|")] ||= @key_generator.generate_key(*args)
# frozen_string_literal: true

require "pathname"
require "tmpdir"
require "active_support/message_encryptor"

module ActiveSupport
  class EncryptedFile
    class MissingContentError < RuntimeError
      def initialize(content_path)
        super "Missing encrypted content file in #{content_path}."
      end
    end

    class MissingKeyError < RuntimeError
      def initialize(key_path:, env_key:)
        super \
          "Missing encryption key to decrypt file with. " +
          "Ask your team for your master key and write it to #{key_path} or put it in the ENV['#{env_key}']."
      end
    end

    class InvalidKeyLengthError < RuntimeError
      def initialize
        super "Encryption key must be exactly #{EncryptedFile.expected_key_length} characters."
      end
    end

    CIPHER = "aes-128-gcm"

    def self.generate_key
      SecureRandom.hex(ActiveSupport::MessageEncryptor.key_len(CIPHER))
    end

    def self.expected_key_length # :nodoc:
      @expected_key_length ||= generate_key.length
    end


    attr_reader :content_path, :key_path, :env_key, :raise_if_missing_key

    def initialize(content_path:, key_path:, env_key:, raise_if_missing_key:)
      @content_path = Pathname.new(content_path).yield_self { |path| path.symlink? ? path.realpath : path }
      @key_path = Pathname.new(key_path)
      @env_key, @raise_if_missing_key = env_key, raise_if_missing_key
    end

    def key
      read_env_key || read_key_file || handle_missing_key
    end

    def read
      if !key.nil? && content_path.exist?
        decrypt content_path.binread
      else
        raise MissingContentError, content_path
      end
    end

    def write(contents)
      IO.binwrite "#{content_path}.tmp", encrypt(contents)
      FileUtils.mv "#{content_path}.tmp", content_path
    end

    def change(&block)
      writing read, &block
    end


    private
      def writing(contents)
        tmp_file = "#{Process.pid}.#{content_path.basename.to_s.chomp('.enc')}"
        tmp_path = Pathname.new File.join(Dir.tmpdir, tmp_file)
        tmp_path.binwrite contents

        yield tmp_path

        updated_contents = tmp_path.binread

        write(updated_contents) if updated_contents != contents
      ensure
        FileUtils.rm(tmp_path) if tmp_path&.exist?
      end


      def encrypt(contents)
        check_key_length
        encryptor.encrypt_and_sign contents
      end

      def decrypt(contents)
        encryptor.decrypt_and_verify contents
      end

      def encryptor
        @encryptor ||= ActiveSupport::MessageEncryptor.new([ key ].pack("H*"), cipher: CIPHER)
      end


      def read_env_key
        ENV[env_key]
      end

      def read_key_file
        return @key_file_contents if defined?(@key_file_contents)
        @key_file_contents = (key_path.binread.strip if key_path.exist?)
      end

      def handle_missing_key
        raise MissingKeyError.new(key_path: key_path, env_key: env_key) if raise_if_missing_key
      end

      def check_key_length
        raise InvalidKeyLengthError if key&.length != self.class.expected_key_length
      end
# frozen_string_literal: true

module ActiveSupport
  module Messages
    class RotationConfiguration # :nodoc:
      attr_reader :signed, :encrypted

      def initialize
        @signed, @encrypted = [], []
      end

      def rotate(kind, *args, **options)
        args << options unless options.empty?
        case kind
        when :signed
          @signed << args
        when :encrypted
          @encrypted << args
        end
      end
# frozen_string_literal: true

require "time"

module ActiveSupport
  module Messages #:nodoc:
    class Metadata #:nodoc:
      def initialize(message, expires_at = nil, purpose = nil)
        @message, @purpose = message, purpose
        @expires_at = expires_at.is_a?(String) ? parse_expires_at(expires_at) : expires_at
      end

      def as_json(options = {})
        { _rails: { message: @message, exp: @expires_at, pur: @purpose } }
      end

      class << self
        def wrap(message, expires_at: nil, expires_in: nil, purpose: nil)
          if expires_at || expires_in || purpose
            JSON.encode new(encode(message), pick_expiry(expires_at, expires_in), purpose)
          else
            message
          end
        end

        def verify(message, purpose)
          extract_metadata(message).verify(purpose)
        end

        private
          def pick_expiry(expires_at, expires_in)
            if expires_at
              expires_at.utc.iso8601(3)
            elsif expires_in
              Time.now.utc.advance(seconds: expires_in).iso8601(3)
            end
          end

          def extract_metadata(message)
            data = JSON.decode(message) rescue nil

            if data.is_a?(Hash) && data.key?("_rails")
              new(decode(data["_rails"]["message"]), data["_rails"]["exp"], data["_rails"]["pur"])
            else
              new(message)
            end
          end

          def encode(message)
            ::Base64.strict_encode64(message)
          end

          def decode(message)
            ::Base64.strict_decode64(message)
          end
      end

      def verify(purpose)
        @message if match?(purpose) && fresh?
      end

      private
        def match?(purpose)
          @purpose.to_s == purpose.to_s
        end

        def fresh?
          @expires_at.nil? || Time.now.utc < @expires_at
        end

        def parse_expires_at(expires_at)
          if ActiveSupport.use_standard_json_time_format
            Time.iso8601(expires_at)
          else
            Time.parse(expires_at)
# frozen_string_literal: true

module ActiveSupport
  module Messages
    module Rotator # :nodoc:
      def initialize(*secrets, on_rotation: nil, **options)
        super(*secrets, **options)

        @options   = options
        @rotations = []
        @on_rotation = on_rotation
      end

      def rotate(*secrets, **options)
        @rotations << build_rotation(*secrets, @options.merge(options))
      end

      module Encryptor
        include Rotator

        def decrypt_and_verify(*args, on_rotation: @on_rotation, **options)
          super
        rescue MessageEncryptor::InvalidMessage, MessageVerifier::InvalidSignature
          run_rotations(on_rotation) { |encryptor| encryptor.decrypt_and_verify(*args, **options) } || raise
        end

        private
          def build_rotation(secret = @secret, sign_secret = @sign_secret, options)
            self.class.new(secret, sign_secret, **options)
          end
      end

      module Verifier
        include Rotator

        def verified(*args, on_rotation: @on_rotation, **options)
          super || run_rotations(on_rotation) { |verifier| verifier.verified(*args, **options) }
        end

        private
          def build_rotation(secret = @secret, options)
            self.class.new(secret, **options)
          end
      end

      private
        def run_rotations(on_rotation)
          @rotations.find do |rotation|
            if message = yield(rotation) rescue next
              on_rotation&.call
              return message
            end
          end
        end
    end
# frozen_string_literal: true

require "active_support/core_ext/hash/deep_merge"
require "active_support/core_ext/hash/except"
require "active_support/core_ext/hash/slice"
begin
  require "i18n"
  require "i18n/backend/fallbacks"
rescue LoadError => e
  $stderr.puts "The i18n gem is not available. Please add it to your Gemfile and run bundle install"
  raise e
end
require "active_support/lazy_load_hooks"

ActiveSupport.run_load_hooks(:i18n)
# frozen_string_literal: true

require "thread"
require "monitor"

module ActiveSupport
  module Concurrency
    # A share/exclusive lock, otherwise known as a read/write lock.
    #
    # https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock
    class ShareLock
      include MonitorMixin

      # We track Thread objects, instead of just using counters, because
      # we need exclusive locks to be reentrant, and we need to be able
      # to upgrade share locks to exclusive.

      def raw_state # :nodoc:
        synchronize do
          threads = @sleeping.keys | @sharing.keys | @waiting.keys
          threads |= [@exclusive_thread] if @exclusive_thread

          data = {}

          threads.each do |thread|
            purpose, compatible = @waiting[thread]

            data[thread] = {
              thread: thread,
              sharing: @sharing[thread],
              exclusive: @exclusive_thread == thread,
              purpose: purpose,
              compatible: compatible,
              waiting: !!@waiting[thread],
              sleeper: @sleeping[thread],
            }
          end

          # NB: Yields while holding our *internal* synchronize lock,
          # which is supposed to be used only for a few instructions at
          # a time. This allows the caller to inspect additional state
          # without things changing out from underneath, but would have
          # disastrous effects upon normal operation. Fortunately, this
          # method is only intended to be called when things have
          # already gone wrong.
          yield data
        end
      end

      def initialize
        super()

        @cv = new_cond

        @sharing = Hash.new(0)
        @waiting = {}
        @sleeping = {}
        @exclusive_thread = nil
        @exclusive_depth = 0
      end

      # Returns false if +no_wait+ is set and the lock is not
      # immediately available. Otherwise, returns true after the lock
      # has been acquired.
      #
      # +purpose+ and +compatible+ work together; while this thread is
      # waiting for the exclusive lock, it will yield its share (if any)
      # to any other attempt whose +purpose+ appears in this attempt's
      # +compatible+ list. This allows a "loose" upgrade, which, being
      # less strict, prevents some classes of deadlocks.
      #
      # For many resources, loose upgrades are sufficient: if a thread
      # is awaiting a lock, it is not running any other code. With
      # +purpose+ matching, it is possible to yield only to other
      # threads whose activity will not interfere.
      def start_exclusive(purpose: nil, compatible: [], no_wait: false)
        synchronize do
          unless @exclusive_thread == Thread.current
            if busy_for_exclusive?(purpose)
              return false if no_wait

              yield_shares(purpose: purpose, compatible: compatible, block_share: true) do
                wait_for(:start_exclusive) { busy_for_exclusive?(purpose) }
              end
            end
            @exclusive_thread = Thread.current
          end
          @exclusive_depth += 1

          true
        end
      end

      # Relinquish the exclusive lock. Must only be called by the thread
      # that called start_exclusive (and currently holds the lock).
      def stop_exclusive(compatible: [])
        synchronize do
          raise "invalid unlock" if @exclusive_thread != Thread.current

          @exclusive_depth -= 1
          if @exclusive_depth == 0
            @exclusive_thread = nil

            if eligible_waiters?(compatible)
              yield_shares(compatible: compatible, block_share: true) do
                wait_for(:stop_exclusive) { @exclusive_thread || eligible_waiters?(compatible) }
              end
            end
            @cv.broadcast
          end
        end
      end

      def start_sharing
        synchronize do
          if @sharing[Thread.current] > 0 || @exclusive_thread == Thread.current
            # We already hold a lock; nothing to wait for
          elsif @waiting[Thread.current]
            # We're nested inside a +yield_shares+ call: we'll resume as
            # soon as there isn't an exclusive lock in our way
            wait_for(:start_sharing) { @exclusive_thread }
          else
            # This is an initial / outermost share call: any outstanding
            # requests for an exclusive lock get to go first
            wait_for(:start_sharing) { busy_for_sharing?(false) }
          end
          @sharing[Thread.current] += 1
        end
      end

      def stop_sharing
        synchronize do
          if @sharing[Thread.current] > 1
            @sharing[Thread.current] -= 1
          else
            @sharing.delete Thread.current
            @cv.broadcast
          end
        end
      end

      # Execute the supplied block while holding the Exclusive lock. If
      # +no_wait+ is set and the lock is not immediately available,
      # returns +nil+ without yielding. Otherwise, returns the result of
      # the block.
      #
      # See +start_exclusive+ for other options.
      def exclusive(purpose: nil, compatible: [], after_compatible: [], no_wait: false)
        if start_exclusive(purpose: purpose, compatible: compatible, no_wait: no_wait)
          begin
            yield
          ensure
            stop_exclusive(compatible: after_compatible)
          end
        end
      end

      # Execute the supplied block while holding the Share lock.
      def sharing
        start_sharing
        begin
          yield
        ensure
          stop_sharing
        end
      end

      # Temporarily give up all held Share locks while executing the
      # supplied block, allowing any +compatible+ exclusive lock request
      # to proceed.
      def yield_shares(purpose: nil, compatible: [], block_share: false)
        loose_shares = previous_wait = nil
        synchronize do
          if loose_shares = @sharing.delete(Thread.current)
            if previous_wait = @waiting[Thread.current]
              purpose = nil unless purpose == previous_wait[0]
              compatible &= previous_wait[1]
            end
            compatible |= [false] unless block_share
            @waiting[Thread.current] = [purpose, compatible]
          end

          @cv.broadcast
        end

        begin
          yield
        ensure
          synchronize do
            wait_for(:yield_shares) { @exclusive_thread && @exclusive_thread != Thread.current }

            if previous_wait
              @waiting[Thread.current] = previous_wait
            else
              @waiting.delete Thread.current
            end
            @sharing[Thread.current] = loose_shares if loose_shares
          end
        end
      end

      private
        # Must be called within synchronize
        def busy_for_exclusive?(purpose)
          busy_for_sharing?(purpose) ||
            @sharing.size > (@sharing[Thread.current] > 0 ? 1 : 0)
        end

        def busy_for_sharing?(purpose)
          (@exclusive_thread && @exclusive_thread != Thread.current) ||
            @waiting.any? { |t, (_, c)| t != Thread.current && !c.include?(purpose) }
        end

        def eligible_waiters?(compatible)
          @waiting.any? { |t, (p, _)| compatible.include?(p) && @waiting.all? { |t2, (_, c2)| t == t2 || c2.include?(p) } }
        end

        def wait_for(method)
          @sleeping[Thread.current] = method
          @cv.wait_while { yield }
        ensure
          @sleeping.delete Thread.current
        end
    end
  end
# frozen_string_literal: true

require "monitor"

module ActiveSupport
  module Concurrency
    # A monitor that will permit dependency loading while blocked waiting for
    # the lock.
    class LoadInterlockAwareMonitor < Monitor
      EXCEPTION_NEVER = { Exception => :never }.freeze
      EXCEPTION_IMMEDIATE = { Exception => :immediate }.freeze
      private_constant :EXCEPTION_NEVER, :EXCEPTION_IMMEDIATE

      # Enters an exclusive section, but allows dependency loading while blocked
      def mon_enter
        mon_try_enter ||
          ActiveSupport::Dependencies.interlock.permit_concurrent_loads { super }
      end

      def synchronize
        Thread.handle_interrupt(EXCEPTION_NEVER) do
          mon_enter

          begin
            Thread.handle_interrupt(EXCEPTION_IMMEDIATE) do
              yield
            end
          ensure
            mon_exit
          end
# frozen_string_literal: true

require "active_support/core_ext/object/blank"

module ActiveSupport
  # +OrderedOptions+ inherits from +Hash+ and provides dynamic accessor methods.
  #
  # With a +Hash+, key-value pairs are typically managed like this:
  #
  #   h = {}
  #   h[:boy] = 'John'
  #   h[:girl] = 'Mary'
  #   h[:boy]  # => 'John'
  #   h[:girl] # => 'Mary'
  #   h[:dog]  # => nil
  #
  # Using +OrderedOptions+, the above code can be written as:
  #
  #   h = ActiveSupport::OrderedOptions.new
  #   h.boy = 'John'
  #   h.girl = 'Mary'
  #   h.boy  # => 'John'
  #   h.girl # => 'Mary'
  #   h.dog  # => nil
  #
  # To raise an exception when the value is blank, append a
  # bang to the key name, like:
  #
  #   h.dog! # => raises KeyError: :dog is blank
  #
  class OrderedOptions < Hash
    alias_method :_get, :[] # preserve the original #[] method
    protected :_get # make it protected

    def []=(key, value)
      super(key.to_sym, value)
    end

    def [](key)
      super(key.to_sym)
    end

    def method_missing(name, *args)
      name_string = +name.to_s
      if name_string.chomp!("=")
        self[name_string] = args.first
      else
        bangs = name_string.chomp!("!")

        if bangs
          self[name_string].presence || raise(KeyError.new(":#{name_string} is blank"))
        else
          self[name_string]
        end
      end
    end

    def respond_to_missing?(name, include_private)
      true
    end

    def extractable_options?
      true
    end

    def inspect
      "#<#{self.class.name} #{super}>"
    end
  end

  # +InheritableOptions+ provides a constructor to build an +OrderedOptions+
  # hash inherited from another hash.
  #
  # Use this if you already have some hash and you want to create a new one based on it.
  #
  #   h = ActiveSupport::InheritableOptions.new({ girl: 'Mary', boy: 'John' })
  #   h.girl # => 'Mary'
  #   h.boy  # => 'John'
  class InheritableOptions < OrderedOptions
    def initialize(parent = nil)
      if parent.kind_of?(OrderedOptions)
        # use the faster _get when dealing with OrderedOptions
        super() { |h, k| parent._get(k) }
      elsif parent
        super() { |h, k| parent[k] }
      else
        super()
      end
    end

# frozen_string_literal: true

module ActiveSupport
  # Wrapping a string in this class gives you a prettier way to test
  # for equality. The value returned by <tt>Rails.env</tt> is wrapped
  # in a StringInquirer object, so instead of calling this:
  #
  #   Rails.env == 'production'
  #
  # you can call this:
  #
  #   Rails.env.production?
  #
  # == Instantiating a new StringInquirer
  #
  #   vehicle = ActiveSupport::StringInquirer.new('car')
  #   vehicle.car?   # => true
  #   vehicle.bike?  # => false
  class StringInquirer < String
    private
      def respond_to_missing?(method_name, include_private = false)
        method_name.end_with?("?") || super
      end

      def method_missing(method_name, *arguments)
        if method_name.end_with?("?")
          self == method_name[0..-2]
        else
          super
        end
# frozen_string_literal: true

# This is a private interface.
#
# Rails components cherry pick from Active Support as needed, but there are a
# few features that are used for sure in some way or another and it is not worth
# putting individual requires absolutely everywhere. Think blank? for example.
#
# This file is loaded by every Rails component except Active Support itself,
# but it does not belong to the Rails public interface. It is internal to
# Rails and can change anytime.

# Defines Object#blank? and Object#present?.
require "active_support/core_ext/object/blank"

# Support for ClassMethods and the included macro.
require "active_support/concern"

# Defines Class#class_attribute.
require "active_support/core_ext/class/attribute"

# Defines Module#delegate.
require "active_support/core_ext/module/delegation"

# Defines ActiveSupport::Deprecation.
# frozen_string_literal: true

module ActiveSupport
  # Wrapping an array in an +ArrayInquirer+ gives a friendlier way to check
  # its string-like contents:
  #
  #   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
  #
  #   variants.phone?    # => true
  #   variants.tablet?   # => true
  #   variants.desktop?  # => false
  class ArrayInquirer < Array
    # Passes each element of +candidates+ collection to ArrayInquirer collection.
    # The method returns true if any element from the ArrayInquirer collection
    # is equal to the stringified or symbolized form of any element in the +candidates+ collection.
    #
    # If +candidates+ collection is not given, method returns true.
    #
    #   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
    #
    #   variants.any?                      # => true
    #   variants.any?(:phone, :tablet)     # => true
    #   variants.any?('phone', 'desktop')  # => true
    #   variants.any?(:desktop, :watch)    # => false
    def any?(*candidates)
      if candidates.none?
        super
      else
        candidates.any? do |candidate|
          include?(candidate.to_sym) || include?(candidate.to_s)
        end
      end
    end

    private
      def respond_to_missing?(name, include_private = false)
        name.end_with?("?") || super
      end

      def method_missing(name, *args)
        if name.end_with?("?")
          any?(name[0..-2])
        else
          super
        end
# frozen_string_literal: true

gem "minitest" # make sure we get the gem, not stdlib
require "minitest"
require "active_support/testing/tagged_logging"
require "active_support/testing/setup_and_teardown"
require "active_support/testing/assertions"
require "active_support/testing/deprecation"
require "active_support/testing/declarative"
require "active_support/testing/isolation"
require "active_support/testing/constant_lookup"
require "active_support/testing/time_helpers"
require "active_support/testing/file_fixtures"
require "active_support/testing/parallelization"
require "concurrent/utility/processor_counter"

module ActiveSupport
  class TestCase < ::Minitest::Test
    Assertion = Minitest::Assertion

    class << self
      # Sets the order in which test cases are run.
      #
      #   ActiveSupport::TestCase.test_order = :random # => :random
      #
      # Valid values are:
      # * +:random+   (to run tests in random order)
      # * +:parallel+ (to run tests in parallel)
      # * +:sorted+   (to run tests alphabetically by method name)
      # * +:alpha+    (equivalent to +:sorted+)
      def test_order=(new_order)
        ActiveSupport.test_order = new_order
      end

      # Returns the order in which test cases are run.
      #
      #   ActiveSupport::TestCase.test_order # => :random
      #
      # Possible values are +:random+, +:parallel+, +:alpha+, +:sorted+.
      # Defaults to +:random+.
      def test_order
        ActiveSupport.test_order ||= :random
      end

      # Parallelizes the test suite.
      #
      # Takes a +workers+ argument that controls how many times the process
      # is forked. For each process a new database will be created suffixed
      # with the worker number.
      #
      #   test-database-0
      #   test-database-1
      #
      # If <tt>ENV["PARALLEL_WORKERS"]</tt> is set the workers argument will be ignored
      # and the environment variable will be used instead. This is useful for CI
      # environments, or other environments where you may need more workers than
      # you do for local testing.
      #
      # If the number of workers is set to +1+ or fewer, the tests will not be
      # parallelized.
      #
      # If +workers+ is set to +:number_of_processors+, the number of workers will be
      # set to the actual core count on the machine you are on.
      #
      # The default parallelization method is to fork processes. If you'd like to
      # use threads instead you can pass <tt>with: :threads</tt> to the +parallelize+
      # method. Note the threaded parallelization does not create multiple
      # database and will not work with system tests at this time.
      #
      #   parallelize(workers: :number_of_processors, with: :threads)
      #
      # The threaded parallelization uses minitest's parallel executor directly.
      # The processes parallelization uses a Ruby DRb server.
      def parallelize(workers: :number_of_processors, with: :processes)
        workers = Concurrent.physical_processor_count if workers == :number_of_processors
        workers = ENV["PARALLEL_WORKERS"].to_i if ENV["PARALLEL_WORKERS"]

        return if workers <= 1

        executor = case with
                   when :processes
                     Testing::Parallelization.new(workers)
                   when :threads
                     Minitest::Parallel::Executor.new(workers)
                   else
                     raise ArgumentError, "#{with} is not a supported parallelization executor."
        end

        self.lock_threads = false if defined?(self.lock_threads) && with == :threads

        Minitest.parallel_executor = executor

        parallelize_me!
      end

      # Set up hook for parallel testing. This can be used if you have multiple
      # databases or any behavior that needs to be run after the process is forked
      # but before the tests run.
      #
      # Note: this feature is not available with the threaded parallelization.
      #
      # In your +test_helper.rb+ add the following:
      #
      #   class ActiveSupport::TestCase
      #     parallelize_setup do
      #       # create databases
      #     end
      #   end
      def parallelize_setup(&block)
        ActiveSupport::Testing::Parallelization.after_fork_hook do |worker|
          yield worker
        end
      end

      # Clean up hook for parallel testing. This can be used to drop databases
      # if your app uses multiple write/read databases or other clean up before
      # the tests finish. This runs before the forked process is closed.
      #
      # Note: this feature is not available with the threaded parallelization.
      #
      # In your +test_helper.rb+ add the following:
      #
      #   class ActiveSupport::TestCase
      #     parallelize_teardown do
      #       # drop databases
      #     end
      #   end
      def parallelize_teardown(&block)
        ActiveSupport::Testing::Parallelization.run_cleanup_hook do |worker|
          yield worker
        end
      end
    end

    alias_method :method_name, :name

    include ActiveSupport::Testing::TaggedLogging
    prepend ActiveSupport::Testing::SetupAndTeardown
    include ActiveSupport::Testing::Assertions
    include ActiveSupport::Testing::Deprecation
    include ActiveSupport::Testing::TimeHelpers
    include ActiveSupport::Testing::FileFixtures
    extend ActiveSupport::Testing::Declarative

    # test/unit backwards compatibility methods
    alias :assert_raise :assert_raises
    alias :assert_not_empty :refute_empty
    alias :assert_not_equal :refute_equal
    alias :assert_not_in_delta :refute_in_delta
    alias :assert_not_in_epsilon :refute_in_epsilon
    alias :assert_not_includes :refute_includes
    alias :assert_not_instance_of :refute_instance_of
    alias :assert_not_kind_of :refute_kind_of
    alias :assert_no_match :refute_match
    alias :assert_not_nil :refute_nil
    alias :assert_not_operator :refute_operator
    alias :assert_not_predicate :refute_predicate
    alias :assert_not_respond_to :refute_respond_to
    alias :assert_not_same :refute_same

# frozen_string_literal: true

module ActiveSupport::CurrentAttributes::TestHelper # :nodoc:
  def before_setup
    ActiveSupport::CurrentAttributes.reset_all
    super
  end

  def after_teardown
    super
# frozen_string_literal: true

module ActiveSupport
  module NumberHelper
    class RoundingHelper # :nodoc:
      attr_reader :options

      def initialize(options)
        @options = options
      end

      def round(number)
        precision = absolute_precision(number)
        return number unless precision

        rounded_number = convert_to_decimal(number).round(precision, options.fetch(:round_mode, :default).to_sym)
        rounded_number.zero? ? rounded_number.abs : rounded_number # prevent showing negative zeros
      end

      def digit_count(number)
        return 1 if number.zero?
        (Math.log10(number.abs) + 1).floor
      end

      private
        def convert_to_decimal(number)
          case number
          when Float, String
            BigDecimal(number.to_s)
          when Rational
            BigDecimal(number, digit_count(number.to_i) + options[:precision])
          else
            number.to_d
          end
        end

        def absolute_precision(number)
          if options[:significant] && options[:precision] > 0
            options[:precision] - digit_count(convert_to_decimal(number))
          else
            options[:precision]
          end
        end
    end
  end
# frozen_string_literal: true

require "active_support/number_helper/number_converter"

module ActiveSupport
  module NumberHelper
    class NumberToPercentageConverter < NumberConverter # :nodoc:
      self.namespace = :percentage

      def convert
        rounded_number = NumberToRoundedConverter.convert(number, options)
        options[:format].gsub("%n", rounded_number)
      end
    end
  end
# frozen_string_literal: true

require "active_support/number_helper/number_converter"

module ActiveSupport
  module NumberHelper
    class NumberToHumanConverter < NumberConverter # :nodoc:
      DECIMAL_UNITS = { 0 => :unit, 1 => :ten, 2 => :hundred, 3 => :thousand, 6 => :million, 9 => :billion, 12 => :trillion, 15 => :quadrillion,
        -1 => :deci, -2 => :centi, -3 => :mili, -6 => :micro, -9 => :nano, -12 => :pico, -15 => :femto }
      INVERTED_DECIMAL_UNITS = DECIMAL_UNITS.invert

      self.namespace      = :human
      self.validate_float = true

      def convert # :nodoc:
        @number = RoundingHelper.new(options).round(number)
        @number = Float(number)

        # For backwards compatibility with those that didn't add strip_insignificant_zeros to their locale files.
        unless options.key?(:strip_insignificant_zeros)
          options[:strip_insignificant_zeros] = true
        end

        units = opts[:units]
        exponent = calculate_exponent(units)
        @number = number / (10**exponent)

        rounded_number = NumberToRoundedConverter.convert(number, options)
        unit = determine_unit(units, exponent)
        format.gsub("%n", rounded_number).gsub("%u", unit).strip
      end

      private
        def format
          options[:format] || translate_in_locale("human.decimal_units.format")
        end

        def determine_unit(units, exponent)
          exp = DECIMAL_UNITS[exponent]
          case units
          when Hash
            units[exp] || ""
          when String, Symbol
            I18n.translate("#{units}.#{exp}", locale: options[:locale], count: number.to_i)
          else
            translate_in_locale("human.decimal_units.units.#{exp}", count: number.to_i)
          end
        end

        def calculate_exponent(units)
          exponent = number != 0 ? Math.log10(number.abs).floor : 0
          unit_exponents(units).find { |e| exponent >= e } || 0
        end

        def unit_exponents(units)
          case units
          when Hash
            units
          when String, Symbol
            I18n.translate(units.to_s, locale: options[:locale], raise: true)
          when nil
            translate_in_locale("human.decimal_units.units", raise: true)
          else
            raise ArgumentError, ":units must be a Hash or String translation scope."
          end.keys.map { |e_name| INVERTED_DECIMAL_UNITS[e_name] }.sort_by(&:-@)
# frozen_string_literal: true

require "active_support/number_helper/number_converter"

module ActiveSupport
  module NumberHelper
    class NumberToCurrencyConverter < NumberConverter # :nodoc:
      self.namespace = :currency

      def convert
        number = self.number.to_s.strip
        format = options[:format]

        if number.sub!(/^-/, "") &&
           (options[:precision] != 0 || number.to_f > 0.5)
          format = options[:negative_format]
        end

        rounded_number = NumberToRoundedConverter.convert(number, options)
        format.gsub("%n", rounded_number).gsub("%u", options[:unit])
      end

      private
        def options
          @options ||= begin
            defaults = default_format_options.merge(i18n_opts)
            # Override negative format if format options are given
            defaults[:negative_format] = "-#{opts[:format]}" if opts[:format]
            defaults.merge!(opts)
          end
        end

        def i18n_opts
          # Set International negative format if it does not exist
          i18n = i18n_format_options
          i18n[:negative_format] ||= "-#{i18n[:format]}" if i18n[:format]
          i18n
        end
    end
  end
# frozen_string_literal: true

require "active_support/number_helper/number_converter"

module ActiveSupport
  module NumberHelper
    class NumberToRoundedConverter < NumberConverter # :nodoc:
      self.namespace      = :precision
      self.validate_float = true

      def convert
        helper = RoundingHelper.new(options)
        rounded_number = helper.round(number)

        if precision = options[:precision]
          if options[:significant] && precision > 0
            digits = helper.digit_count(rounded_number)
            precision -= digits
            precision = 0 if precision < 0 # don't let it be negative
          end

          formatted_string =
            if rounded_number.nan? || rounded_number.infinite? || rounded_number == rounded_number.to_i
              "%00.#{precision}f" % rounded_number
            else
              s = rounded_number.to_s("F")
              s << "0" * precision
              a, b = s.split(".", 2)
              a << "."
              a << b[0, precision]
            end
        else
          formatted_string = rounded_number
        end

        delimited_number = NumberToDelimitedConverter.convert(formatted_string, options)
        format_number(delimited_number)
      end

      private
        def strip_insignificant_zeros
          options[:strip_insignificant_zeros]
        end

        def format_number(number)
          if strip_insignificant_zeros
            escaped_separator = Regexp.escape(options[:separator])
            number.sub(/(#{escaped_separator})(\d*[1-9])?0+\z/, '\1\2').sub(/#{escaped_separator}\z/, "")
          else
            number
# frozen_string_literal: true

require "active_support/core_ext/big_decimal/conversions"
require "active_support/core_ext/object/blank"
require "active_support/core_ext/hash/keys"
require "active_support/i18n"
require "active_support/core_ext/class/attribute"

module ActiveSupport
  module NumberHelper
    class NumberConverter # :nodoc:
      # Default and i18n option namespace per class
      class_attribute :namespace

      # Does the object need a number that is a valid float?
      class_attribute :validate_float

      attr_reader :number, :opts

      DEFAULTS = {
        # Used in number_to_delimited
        # These are also the defaults for 'currency', 'percentage', 'precision', and 'human'
        format: {
          # Sets the separator between the units, for more precision (e.g. 1.0 / 2.0 == 0.5)
          separator: ".",
          # Delimits thousands (e.g. 1,000,000 is a million) (always in groups of three)
          delimiter: ",",
          # Number of decimals, behind the separator (the number 1 with a precision of 2 gives: 1.00)
          precision: 3,
          # If set to true, precision will mean the number of significant digits instead
          # of the number of decimal digits (1234 with precision 2 becomes 1200, 1.23543 becomes 1.2)
          significant: false,
          # If set, the zeros after the decimal separator will always be stripped (e.g.: 1.200 will be 1.2)
          strip_insignificant_zeros: false
        },

        # Used in number_to_currency
        currency: {
          format: {
            format: "%u%n",
            negative_format: "-%u%n",
            unit: "$",
            # These five are to override number.format and are optional
            separator: ".",
            delimiter: ",",
            precision: 2,
            significant: false,
            strip_insignificant_zeros: false
          }
        },

        # Used in number_to_percentage
        percentage: {
          format: {
            delimiter: "",
            format: "%n%"
          }
        },

        # Used in number_to_rounded
        precision: {
          format: {
            delimiter: ""
          }
        },

        # Used in number_to_human_size and number_to_human
        human: {
          format: {
            # These five are to override number.format and are optional
            delimiter: "",
            precision: 3,
            significant: true,
            strip_insignificant_zeros: true
          },
          # Used in number_to_human_size
          storage_units: {
            # Storage units output formatting.
            # %u is the storage unit, %n is the number (default: 2 MB)
            format: "%n %u",
            units: {
              byte: "Bytes",
              kb: "KB",
              mb: "MB",
              gb: "GB",
              tb: "TB"
            }
          },
          # Used in number_to_human
          decimal_units: {
            format: "%n %u",
            # Decimal units output formatting
            # By default we will only quantify some of the exponents
            # but the commented ones might be defined or overridden
            # by the user.
            units: {
              # femto: Quadrillionth
              # pico: Trillionth
              # nano: Billionth
              # micro: Millionth
              # mili: Thousandth
              # centi: Hundredth
              # deci: Tenth
              unit: "",
              # ten:
              #   one: Ten
              #   other: Tens
              # hundred: Hundred
              thousand: "Thousand",
              million: "Million",
              billion: "Billion",
              trillion: "Trillion",
              quadrillion: "Quadrillion"
            }
          }
        }
      }

      def self.convert(number, options)
        new(number, options).execute
      end

      def initialize(number, options)
        @number = number
        @opts   = options.symbolize_keys
      end

      def execute
        if !number
          nil
        elsif validate_float? && !valid_float?
          number
        else
          convert
        end
      end

      private
        def options
          @options ||= format_options.merge(opts)
        end

        def format_options
          default_format_options.merge!(i18n_format_options)
        end

        def default_format_options
          options = DEFAULTS[:format].dup
          options.merge!(DEFAULTS[namespace][:format]) if namespace
          options
        end

        def i18n_format_options
          locale = opts[:locale]
          options = I18n.translate(:'number.format', locale: locale, default: {}).dup

          if namespace
            options.merge!(I18n.translate(:"number.#{namespace}.format", locale: locale, default: {}))
          end

          options
        end

        def translate_number_value_with_default(key, **i18n_options)
          I18n.translate(key, **{ default: default_value(key), scope: :number }.merge!(i18n_options))
        end

        def translate_in_locale(key, **i18n_options)
          translate_number_value_with_default(key, **{ locale: options[:locale] }.merge(i18n_options))
        end

        def default_value(key)
          key.split(".").reduce(DEFAULTS) { |defaults, k| defaults[k.to_sym] }
        end

        def valid_float?
          Float(number)
        rescue ArgumentError, TypeError
          false
        end
# frozen_string_literal: true

require "active_support/number_helper/number_converter"

module ActiveSupport
  module NumberHelper
    class NumberToPhoneConverter < NumberConverter #:nodoc:
      def convert
        str = country_code(opts[:country_code]).dup
        str << convert_to_phone_number(number.to_s.strip)
        str << phone_ext(opts[:extension])
      end

      private
        def convert_to_phone_number(number)
          if opts[:area_code]
            convert_with_area_code(number)
          else
            convert_without_area_code(number)
          end
        end

        def convert_with_area_code(number)
          default_pattern = /(\d{1,3})(\d{3})(\d{4}$)/
          number.gsub!(regexp_pattern(default_pattern),
                       "(\\1) \\2#{delimiter}\\3")
          number
        end

        def convert_without_area_code(number)
          default_pattern = /(\d{0,3})(\d{3})(\d{4})$/
          number.gsub!(regexp_pattern(default_pattern),
                       "\\1#{delimiter}\\2#{delimiter}\\3")
          number.slice!(0, 1) if start_with_delimiter?(number)
          number
        end

        def start_with_delimiter?(number)
          delimiter.present? && number.start_with?(delimiter)
        end

        def delimiter
          opts[:delimiter] || "-"
        end

        def country_code(code)
          code.blank? ? "" : "+#{code}#{delimiter}"
        end

        def phone_ext(ext)
          ext.blank? ? "" : " x #{ext}"
        end

        def regexp_pattern(default_pattern)
          opts.fetch :pattern, default_pattern
# frozen_string_literal: true

require "active_support/number_helper/number_converter"

module ActiveSupport
  module NumberHelper
    class NumberToHumanSizeConverter < NumberConverter #:nodoc:
      STORAGE_UNITS = [:byte, :kb, :mb, :gb, :tb, :pb, :eb]

      self.namespace      = :human
      self.validate_float = true

      def convert
        @number = Float(number)

        # For backwards compatibility with those that didn't add strip_insignificant_zeros to their locale files.
        unless options.key?(:strip_insignificant_zeros)
          options[:strip_insignificant_zeros] = true
        end

        if smaller_than_base?
          number_to_format = number.to_i.to_s
        else
          human_size = number / (base**exponent)
          number_to_format = NumberToRoundedConverter.convert(human_size, options)
        end
        conversion_format.gsub("%n", number_to_format).gsub("%u", unit)
      end

      private
        def conversion_format
          translate_number_value_with_default("human.storage_units.format", locale: options[:locale], raise: true)
        end

        def unit
          translate_number_value_with_default(storage_unit_key, locale: options[:locale], count: number.to_i, raise: true)
        end

        def storage_unit_key
          key_end = smaller_than_base? ? "byte" : STORAGE_UNITS[exponent]
          "human.storage_units.units.#{key_end}"
        end

        def exponent
          max = STORAGE_UNITS.size - 1
          exp = (Math.log(number) / Math.log(base)).to_i
          exp = max if exp > max # avoid overflow for the highest unit
          exp
        end

        def smaller_than_base?
          number.to_i < base
        end

        def base
# frozen_string_literal: true

require "active_support/number_helper/number_converter"

module ActiveSupport
  module NumberHelper
    class NumberToDelimitedConverter < NumberConverter #:nodoc:
      self.validate_float = true

      DEFAULT_DELIMITER_REGEX = /(\d)(?=(\d\d\d)+(?!\d))/

      def convert
        parts.join(options[:separator])
      end

      private
        def parts
          left, right = number.to_s.split(".")
          left.gsub!(delimiter_pattern) do |digit_to_delimit|
            "#{digit_to_delimit}#{options[:delimiter]}"
          end
          [left, right].compact
        end

        def delimiter_pattern
# frozen_string_literal: true

require "active_support/core_ext/hash/conversions"
require "active_support/core_ext/hash/deep_merge"
require "active_support/core_ext/hash/deep_transform_values"
# frozen_string_literal: true

class Symbol
  alias :starts_with? :start_with?
  alias :ends_with? :end_with?
# frozen_string_literal: true

module Kernel
  # class_eval on an object acts like singleton_class.class_eval.
  def class_eval(*args, &block)
# frozen_string_literal: true

module Kernel
  module_function

  # Sets $VERBOSE to +nil+ for the duration of the block and back to its original
  # value afterwards.
  #
  #   silence_warnings do
  #     value = noisy_call # no warning voiced
  #   end
  #
  #   noisy_call # warning voiced
  def silence_warnings
    with_warnings(nil) { yield }
  end

  # Sets $VERBOSE to +true+ for the duration of the block and back to its
  # original value afterwards.
  def enable_warnings
    with_warnings(true) { yield }
  end

  # Sets $VERBOSE for the duration of the block and back to its original
  # value afterwards.
  def with_warnings(flag)
    old_verbose, $VERBOSE = $VERBOSE, flag
    yield
  ensure
    $VERBOSE = old_verbose
  end

  # Blocks and ignores any exception passed as argument if raised within the block.
  #
  #   suppress(ZeroDivisionError) do
  #     1/0
  #     puts 'This code is NOT reached'
  #   end
  #
  #   puts 'This code gets executed and nothing related to ZeroDivisionError was seen'
# frozen_string_literal: true

require "active_support/core_ext/module/concerning"

module Kernel
  module_function

  # A shortcut to define a toplevel concern, not within a module.
  #
  # See Module::Concerning for more.
# frozen_string_literal: true

class LoadError
  # Returns true if the given path name (except perhaps for the ".rb"
  # extension) is the missing file which caused the exception to be raised.
# frozen_string_literal: true

require "active_support/core_ext/array/wrap"
require "active_support/core_ext/array/access"
require "active_support/core_ext/array/conversions"
# frozen_string_literal: true

require "date"

class DateTime
  class << self
    # Returns <tt>Time.zone.now.to_datetime</tt> when <tt>Time.zone</tt> or
    # <tt>config.time_zone</tt> are set, otherwise returns
    # <tt>Time.now.to_datetime</tt>.
    def current
      ::Time.zone ? ::Time.zone.now.to_datetime : ::Time.now.to_datetime
    end
  end

  # Returns the number of seconds since 00:00:00.
  #
  #   DateTime.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0
  #   DateTime.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296
  #   DateTime.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399
  def seconds_since_midnight
    sec + (min * 60) + (hour * 3600)
  end

  # Returns the number of seconds until 23:59:59.
  #
  #   DateTime.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399
  #   DateTime.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103
  #   DateTime.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0
  def seconds_until_end_of_day
    end_of_day.to_i - to_i
  end

  # Returns the fraction of a second as a +Rational+
  #
  #   DateTime.new(2012, 8, 29, 0, 0, 0.5).subsec # => (1/2)
  def subsec
    sec_fraction
  end

  # Returns a new DateTime where one or more of the elements have been changed
  # according to the +options+ parameter. The time options (<tt>:hour</tt>,
  # <tt>:min</tt>, <tt>:sec</tt>) reset cascadingly, so if only the hour is
  # passed, then minute and sec is set to 0. If the hour and minute is passed,
  # then sec is set to 0. The +options+ parameter takes a hash with any of these
  # keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>,
  # <tt>:min</tt>, <tt>:sec</tt>, <tt>:offset</tt>, <tt>:start</tt>.
  #
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => DateTime.new(2012, 8, 1, 22, 35, 0)
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => DateTime.new(1981, 8, 1, 22, 35, 0)
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => DateTime.new(1981, 8, 29, 0, 0, 0)
  def change(options)
    if new_nsec = options[:nsec]
      raise ArgumentError, "Can't change both :nsec and :usec at the same time: #{options.inspect}" if options[:usec]
      new_fraction = Rational(new_nsec, 1000000000)
    else
      new_usec = options.fetch(:usec, (options[:hour] || options[:min] || options[:sec]) ? 0 : Rational(nsec, 1000))
      new_fraction = Rational(new_usec, 1000000)
    end

    raise ArgumentError, "argument out of range" if new_fraction >= 1

    ::DateTime.civil(
      options.fetch(:year, year),
      options.fetch(:month, month),
      options.fetch(:day, day),
      options.fetch(:hour, hour),
      options.fetch(:min, options[:hour] ? 0 : min),
      options.fetch(:sec, (options[:hour] || options[:min]) ? 0 : sec) + new_fraction,
      options.fetch(:offset, offset),
      options.fetch(:start, start)
    )
  end

  # Uses Date to provide precise Time calculations for years, months, and days.
  # The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>,
  # <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>,
  # <tt>:minutes</tt>, <tt>:seconds</tt>.
  def advance(options)
    unless options[:weeks].nil?
      options[:weeks], partial_weeks = options[:weeks].divmod(1)
      options[:days] = options.fetch(:days, 0) + 7 * partial_weeks
    end

    unless options[:days].nil?
      options[:days], partial_days = options[:days].divmod(1)
      options[:hours] = options.fetch(:hours, 0) + 24 * partial_days
    end

    d = to_date.advance(options)
    datetime_advanced_by_date = change(year: d.year, month: d.month, day: d.day)
    seconds_to_advance = \
      options.fetch(:seconds, 0) +
      options.fetch(:minutes, 0) * 60 +
      options.fetch(:hours, 0) * 3600

    if seconds_to_advance.zero?
      datetime_advanced_by_date
    else
      datetime_advanced_by_date.since(seconds_to_advance)
    end
  end

  # Returns a new DateTime representing the time a number of seconds ago.
  # Do not use this method in combination with x.months, use months_ago instead!
  def ago(seconds)
    since(-seconds)
  end

  # Returns a new DateTime representing the time a number of seconds since the
  # instance time. Do not use this method in combination with x.months, use
  # months_since instead!
  def since(seconds)
    self + Rational(seconds, 86400)
  end
  alias :in :since

  # Returns a new DateTime representing the start of the day (0:00).
  def beginning_of_day
    change(hour: 0)
  end
  alias :midnight :beginning_of_day
  alias :at_midnight :beginning_of_day
  alias :at_beginning_of_day :beginning_of_day

  # Returns a new DateTime representing the middle of the day (12:00)
  def middle_of_day
    change(hour: 12)
  end
  alias :midday :middle_of_day
  alias :noon :middle_of_day
  alias :at_midday :middle_of_day
  alias :at_noon :middle_of_day
  alias :at_middle_of_day :middle_of_day

  # Returns a new DateTime representing the end of the day (23:59:59).
  def end_of_day
    change(hour: 23, min: 59, sec: 59, usec: Rational(999999999, 1000))
  end
  alias :at_end_of_day :end_of_day

  # Returns a new DateTime representing the start of the hour (hh:00:00).
  def beginning_of_hour
    change(min: 0)
  end
  alias :at_beginning_of_hour :beginning_of_hour

  # Returns a new DateTime representing the end of the hour (hh:59:59).
  def end_of_hour
    change(min: 59, sec: 59, usec: Rational(999999999, 1000))
  end
  alias :at_end_of_hour :end_of_hour

  # Returns a new DateTime representing the start of the minute (hh:mm:00).
  def beginning_of_minute
    change(sec: 0)
  end
  alias :at_beginning_of_minute :beginning_of_minute

  # Returns a new DateTime representing the end of the minute (hh:mm:59).
  def end_of_minute
    change(sec: 59, usec: Rational(999999999, 1000))
  end
  alias :at_end_of_minute :end_of_minute

  # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
  def localtime(utc_offset = nil)
    utc = new_offset(0)

    Time.utc(
      utc.year, utc.month, utc.day,
      utc.hour, utc.min, utc.sec + utc.sec_fraction
    ).getlocal(utc_offset)
  end
  alias_method :getlocal, :localtime

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC
  def utc
    utc = new_offset(0)

    Time.utc(
      utc.year, utc.month, utc.day,
      utc.hour, utc.min, utc.sec + utc.sec_fraction
    )
  end
  alias_method :getgm, :utc
  alias_method :getutc, :utc
  alias_method :gmtime, :utc

  # Returns +true+ if <tt>offset == 0</tt>.
  def utc?
    offset == 0
  end

  # Returns the offset value in seconds.
  def utc_offset
    (offset * 86400).to_i
  end

  # Layers additional behavior on DateTime#<=> so that Time and
  # ActiveSupport::TimeWithZone instances can be compared with a DateTime.
  def <=>(other)
    if other.respond_to? :to_datetime
      super other.to_datetime rescue nil
    else
      super
    end
  end
# frozen_string_literal: true

require "date"
require "active_support/inflector/methods"
require "active_support/core_ext/time/conversions"
require "active_support/core_ext/date_time/calculations"
require "active_support/values/time_zone"

class DateTime
  # Convert to a formatted string. See Time::DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_s</tt>.
  #
  # === Examples
  #   datetime = DateTime.civil(2007, 12, 4, 0, 0, 0, 0)   # => Tue, 04 Dec 2007 00:00:00 +0000
  #
  #   datetime.to_formatted_s(:db)            # => "2007-12-04 00:00:00"
  #   datetime.to_s(:db)                      # => "2007-12-04 00:00:00"
  #   datetime.to_s(:number)                  # => "20071204000000"
  #   datetime.to_formatted_s(:short)         # => "04 Dec 00:00"
  #   datetime.to_formatted_s(:long)          # => "December 04, 2007 00:00"
  #   datetime.to_formatted_s(:long_ordinal)  # => "December 4th, 2007 00:00"
  #   datetime.to_formatted_s(:rfc822)        # => "Tue, 04 Dec 2007 00:00:00 +0000"
  #   datetime.to_formatted_s(:iso8601)       # => "2007-12-04T00:00:00+00:00"
  #
  # == Adding your own datetime formats to to_formatted_s
  # DateTime formats are shared with Time. You can add your own to the
  # Time::DATE_FORMATS hash. Use the format name as the hash key and
  # either a strftime string or Proc instance that takes a time or
  # datetime argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal] = lambda { |time| time.strftime("%B #{time.day.ordinalize}") }
  def to_formatted_s(format = :default)
    if formatter = ::Time::DATE_FORMATS[format]
      formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)
    else
      to_default_s
    end
  end
  alias_method :to_default_s, :to_s if instance_methods(false).include?(:to_s)
  alias_method :to_s, :to_formatted_s

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   datetime = DateTime.civil(2000, 1, 1, 0, 0, 0, Rational(-6, 24))
  #   datetime.formatted_offset         # => "-06:00"
  #   datetime.formatted_offset(false)  # => "-0600"
  def formatted_offset(colon = true, alternate_utc_string = nil)
    utc? && alternate_utc_string || ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, colon)
  end

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005 14:30:00 +0000".
  def readable_inspect
    to_s(:rfc822)
  end
  alias_method :default_inspect, :inspect
  alias_method :inspect, :readable_inspect

  # Returns DateTime with local offset for given year if format is local else
  # offset is zero.
  #
  #   DateTime.civil_from_format :local, 2012
  #   # => Sun, 01 Jan 2012 00:00:00 +0300
  #   DateTime.civil_from_format :local, 2012, 12, 17
  #   # => Mon, 17 Dec 2012 00:00:00 +0000
  def self.civil_from_format(utc_or_local, year, month = 1, day = 1, hour = 0, min = 0, sec = 0)
    if utc_or_local.to_sym == :local
      offset = ::Time.local(year, month, day).utc_offset.to_r / 86400
    else
      offset = 0
    end
    civil(year, month, day, hour, min, sec, offset)
  end

  # Converts +self+ to a floating-point number of seconds, including fractional microseconds, since the Unix epoch.
  def to_f
    seconds_since_unix_epoch.to_f + sec_fraction
  end

  # Converts +self+ to an integer number of seconds since the Unix epoch.
  def to_i
    seconds_since_unix_epoch.to_i
  end

  # Returns the fraction of a second as microseconds
  def usec
    (sec_fraction * 1_000_000).to_i
  end

  # Returns the fraction of a second as nanoseconds
  def nsec
    (sec_fraction * 1_000_000_000).to_i
  end

  private
    def offset_in_seconds
      (offset * 86400).to_i
    end

    def seconds_since_unix_epoch
      (jd - 2440588) * 86400 - offset_in_seconds + seconds_since_midnight
    end
# frozen_string_literal: true

require "date"
require "active_support/core_ext/object/acts_like"

class DateTime
  # Duck-types as a Date-like class. See Object#acts_like?.
  def acts_like_date?
    true
  end

  # Duck-types as a Time-like class. See Object#acts_like?.
  def acts_like_time?
    true
  end
# frozen_string_literal: true

require "date"

class DateTime #:nodoc:
  # No DateTime is ever blank:
  #
  #   DateTime.now.blank? # => false
  #
  # @return [false]
# frozen_string_literal: true

require "active_support/core_ext/date_and_time/compatibility"
require "active_support/core_ext/module/redefine_method"

class DateTime
  include DateAndTime::Compatibility

  silence_redefinition_of_method :to_time

  # Either return an instance of +Time+ with the same UTC offset
  # as +self+ or an instance of +Time+ representing the same time
  # in the local system timezone depending on the setting of
  # on the setting of +ActiveSupport.to_time_preserves_timezone+.
  def to_time
# frozen_string_literal: true

require "active_support/core_ext/string/inflections"

module ActiveSupport
  module MarshalWithAutoloading # :nodoc:
    def load(source, proc = nil)
      super(source, proc)
    rescue ArgumentError, NameError => exc
      if exc.message.match(%r|undefined class/module (.+?)(?:::)?\z|)
        # try loading the class/module
        loaded = $1.constantize

        raise unless $1 == loaded.name

        # if it is an IO we need to go back to read the object
        source.rewind if source.respond_to?(:rewind)
        retry
      else
        raise exc
      end
    end
  end
end

# frozen_string_literal: true

require "active_support/duration"
require "active_support/core_ext/time/conversions"
require "active_support/time_with_zone"
require "active_support/core_ext/time/zones"
require "active_support/core_ext/date_and_time/calculations"
require "active_support/core_ext/date/calculations"
require "active_support/core_ext/module/remove_method"

class Time
  include DateAndTime::Calculations

  COMMON_YEAR_DAYS_IN_MONTH = [nil, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

  class << self
    # Overriding case equality method so that it returns true for ActiveSupport::TimeWithZone instances
    def ===(other)
      super || (self == Time && other.is_a?(ActiveSupport::TimeWithZone))
    end

    # Returns the number of days in the given month.
    # If no year is specified, it will use the current year.
    def days_in_month(month, year = current.year)
      if month == 2 && ::Date.gregorian_leap?(year)
        29
      else
        COMMON_YEAR_DAYS_IN_MONTH[month]
      end
    end

    # Returns the number of days in the given year.
    # If no year is specified, it will use the current year.
    def days_in_year(year = current.year)
      days_in_month(2, year) + 337
    end

    # Returns <tt>Time.zone.now</tt> when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns <tt>Time.now</tt>.
    def current
      ::Time.zone ? ::Time.zone.now : ::Time.now
    end

    # Layers additional behavior on Time.at so that ActiveSupport::TimeWithZone and DateTime
    # instances can be used when called with a single argument
    def at_with_coercion(*args, **kwargs)
      return at_without_coercion(*args, **kwargs) if args.size != 1 || !kwargs.empty?

      # Time.at can be called with a time or numerical value
      time_or_number = args.first

      if time_or_number.is_a?(ActiveSupport::TimeWithZone)
        at_without_coercion(time_or_number.to_r).getlocal
      elsif time_or_number.is_a?(DateTime)
        at_without_coercion(time_or_number.to_f).getlocal
      else
        at_without_coercion(time_or_number)
      end
    end
    alias_method :at_without_coercion, :at
    alias_method :at, :at_with_coercion

    # Creates a +Time+ instance from an RFC 3339 string.
    #
    #   Time.rfc3339('1999-12-31T14:00:00-10:00') # => 2000-01-01 00:00:00 -1000
    #
    # If the time or offset components are missing then an +ArgumentError+ will be raised.
    #
    #   Time.rfc3339('1999-12-31') # => ArgumentError: invalid date
    def rfc3339(str)
      parts = Date._rfc3339(str)

      raise ArgumentError, "invalid date" if parts.empty?

      Time.new(
        parts.fetch(:year),
        parts.fetch(:mon),
        parts.fetch(:mday),
        parts.fetch(:hour),
        parts.fetch(:min),
        parts.fetch(:sec) + parts.fetch(:sec_fraction, 0),
        parts.fetch(:offset)
      )
    end
  end

  # Returns the number of seconds since 00:00:00.
  #
  #   Time.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0.0
  #   Time.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296.0
  #   Time.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399.0
  def seconds_since_midnight
    to_i - change(hour: 0).to_i + (usec / 1.0e+6)
  end

  # Returns the number of seconds until 23:59:59.
  #
  #   Time.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399
  #   Time.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103
  #   Time.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0
  def seconds_until_end_of_day
    end_of_day.to_i - to_i
  end

  # Returns the fraction of a second as a +Rational+
  #
  #   Time.new(2012, 8, 29, 0, 0, 0.5).sec_fraction # => (1/2)
  def sec_fraction
    subsec
  end

  unless Time.method_defined?(:floor)
    def floor(precision = 0)
      change(nsec: 0) + subsec.floor(precision)
    end
  end

  # Restricted Ruby version due to a bug in `Time#ceil`
  # See https://bugs.ruby-lang.org/issues/17025 for more details
  if RUBY_VERSION <= "2.8"
    remove_possible_method :ceil
    def ceil(precision = 0)
      change(nsec: 0) + subsec.ceil(precision)
    end
  end

  # Returns a new Time where one or more of the elements have been changed according
  # to the +options+ parameter. The time options (<tt>:hour</tt>, <tt>:min</tt>,
  # <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly, so if only
  # the hour is passed, then minute, sec, usec and nsec is set to 0. If the hour
  # and minute is passed, then sec, usec and nsec is set to 0. The +options+ parameter
  # takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>,
  # <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>,
  # <tt>:offset</tt>. Pass either <tt>:usec</tt> or <tt>:nsec</tt>, not both.
  #
  #   Time.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => Time.new(2012, 8, 1, 22, 35, 0)
  #   Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => Time.new(1981, 8, 1, 22, 35, 0)
  #   Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => Time.new(1981, 8, 29, 0, 0, 0)
  def change(options)
    new_year   = options.fetch(:year, year)
    new_month  = options.fetch(:month, month)
    new_day    = options.fetch(:day, day)
    new_hour   = options.fetch(:hour, hour)
    new_min    = options.fetch(:min, options[:hour] ? 0 : min)
    new_sec    = options.fetch(:sec, (options[:hour] || options[:min]) ? 0 : sec)
    new_offset = options.fetch(:offset, nil)

    if new_nsec = options[:nsec]
      raise ArgumentError, "Can't change both :nsec and :usec at the same time: #{options.inspect}" if options[:usec]
      new_usec = Rational(new_nsec, 1000)
    else
      new_usec = options.fetch(:usec, (options[:hour] || options[:min] || options[:sec]) ? 0 : Rational(nsec, 1000))
    end

    raise ArgumentError, "argument out of range" if new_usec >= 1000000

    new_sec += Rational(new_usec, 1000000)

    if new_offset
      ::Time.new(new_year, new_month, new_day, new_hour, new_min, new_sec, new_offset)
    elsif utc?
      ::Time.utc(new_year, new_month, new_day, new_hour, new_min, new_sec)
    elsif zone
      ::Time.local(new_year, new_month, new_day, new_hour, new_min, new_sec)
    else
      ::Time.new(new_year, new_month, new_day, new_hour, new_min, new_sec, utc_offset)
    end
  end

  # Uses Date to provide precise Time calculations for years, months, and days
  # according to the proleptic Gregorian calendar. The +options+ parameter
  # takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>,
  # <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>,
  # <tt>:seconds</tt>.
  #
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(seconds: 1) # => 2015-08-01 14:35:01 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(minutes: 1) # => 2015-08-01 14:36:00 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(hours: 1)   # => 2015-08-01 15:35:00 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(days: 1)    # => 2015-08-02 14:35:00 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(weeks: 1)   # => 2015-08-08 14:35:00 -0700
  def advance(options)
    unless options[:weeks].nil?
      options[:weeks], partial_weeks = options[:weeks].divmod(1)
      options[:days] = options.fetch(:days, 0) + 7 * partial_weeks
    end

    unless options[:days].nil?
      options[:days], partial_days = options[:days].divmod(1)
      options[:hours] = options.fetch(:hours, 0) + 24 * partial_days
    end

    d = to_date.gregorian.advance(options)
    time_advanced_by_date = change(year: d.year, month: d.month, day: d.day)
    seconds_to_advance = \
      options.fetch(:seconds, 0) +
      options.fetch(:minutes, 0) * 60 +
      options.fetch(:hours, 0) * 3600

    if seconds_to_advance.zero?
      time_advanced_by_date
    else
      time_advanced_by_date.since(seconds_to_advance)
    end
  end

  # Returns a new Time representing the time a number of seconds ago, this is basically a wrapper around the Numeric extension
  def ago(seconds)
    since(-seconds)
  end

  # Returns a new Time representing the time a number of seconds since the instance time
  def since(seconds)
    self + seconds
  rescue
    to_datetime.since(seconds)
  end
  alias :in :since

  # Returns a new Time representing the start of the day (0:00)
  def beginning_of_day
    change(hour: 0)
  end
  alias :midnight :beginning_of_day
  alias :at_midnight :beginning_of_day
  alias :at_beginning_of_day :beginning_of_day

  # Returns a new Time representing the middle of the day (12:00)
  def middle_of_day
    change(hour: 12)
  end
  alias :midday :middle_of_day
  alias :noon :middle_of_day
  alias :at_midday :middle_of_day
  alias :at_noon :middle_of_day
  alias :at_middle_of_day :middle_of_day

  # Returns a new Time representing the end of the day, 23:59:59.999999
  def end_of_day
    change(
      hour: 23,
      min: 59,
      sec: 59,
      usec: Rational(999999999, 1000)
    )
  end
  alias :at_end_of_day :end_of_day

  # Returns a new Time representing the start of the hour (x:00)
  def beginning_of_hour
    change(min: 0)
  end
  alias :at_beginning_of_hour :beginning_of_hour

  # Returns a new Time representing the end of the hour, x:59:59.999999
  def end_of_hour
    change(
      min: 59,
      sec: 59,
      usec: Rational(999999999, 1000)
    )
  end
  alias :at_end_of_hour :end_of_hour

  # Returns a new Time representing the start of the minute (x:xx:00)
  def beginning_of_minute
    change(sec: 0)
  end
  alias :at_beginning_of_minute :beginning_of_minute

  # Returns a new Time representing the end of the minute, x:xx:59.999999
  def end_of_minute
    change(
      sec: 59,
      usec: Rational(999999999, 1000)
    )
  end
  alias :at_end_of_minute :end_of_minute

  def plus_with_duration(other) #:nodoc:
    if ActiveSupport::Duration === other
      other.since(self)
    else
      plus_without_duration(other)
    end
  end
  alias_method :plus_without_duration, :+
  alias_method :+, :plus_with_duration

  def minus_with_duration(other) #:nodoc:
    if ActiveSupport::Duration === other
      other.until(self)
    else
      minus_without_duration(other)
    end
  end
  alias_method :minus_without_duration, :-
  alias_method :-, :minus_with_duration

  # Time#- can also be used to determine the number of seconds between two Time instances.
  # We're layering on additional behavior so that ActiveSupport::TimeWithZone instances
  # are coerced into values that Time#- will recognize
  def minus_with_coercion(other)
    other = other.comparable_time if other.respond_to?(:comparable_time)
    other.is_a?(DateTime) ? to_f - other.to_f : minus_without_coercion(other)
  end
  alias_method :minus_without_coercion, :-
  alias_method :-, :minus_with_coercion

  # Layers additional behavior on Time#<=> so that DateTime and ActiveSupport::TimeWithZone instances
  # can be chronologically compared with a Time
  def compare_with_coercion(other)
    # we're avoiding Time#to_datetime and Time#to_time because they're expensive
    if other.class == Time
      compare_without_coercion(other)
    elsif other.is_a?(Time)
      compare_without_coercion(other.to_time)
    else
      to_datetime <=> other
    end
  end
  alias_method :compare_without_coercion, :<=>
  alias_method :<=>, :compare_with_coercion

  # Layers additional behavior on Time#eql? so that ActiveSupport::TimeWithZone instances
  # can be eql? to an equivalent Time
  def eql_with_coercion(other)
    # if other is an ActiveSupport::TimeWithZone, coerce a Time instance from it so we can do eql? comparison
    other = other.comparable_time if other.respond_to?(:comparable_time)
    eql_without_coercion(other)
  end
  alias_method :eql_without_coercion, :eql?
  alias_method :eql?, :eql_with_coercion

  # Returns a new time the specified number of days ago.
  def prev_day(days = 1)
    advance(days: -days)
  end

  # Returns a new time the specified number of days in the future.
  def next_day(days = 1)
    advance(days: days)
  end

  # Returns a new time the specified number of months ago.
  def prev_month(months = 1)
    advance(months: -months)
  end

  # Returns a new time the specified number of months in the future.
  def next_month(months = 1)
    advance(months: months)
  end

  # Returns a new time the specified number of years ago.
  def prev_year(years = 1)
    advance(years: -years)
  end

  # Returns a new time the specified number of years in the future.
  def next_year(years = 1)
    advance(years: years)
# frozen_string_literal: true

require "active_support/time_with_zone"
require "active_support/core_ext/time/acts_like"
require "active_support/core_ext/date_and_time/zones"

class Time
  include DateAndTime::Zones
  class << self
    attr_accessor :zone_default

    # Returns the TimeZone for the current request, if this has been set (via Time.zone=).
    # If <tt>Time.zone</tt> has not been set for the current request, returns the TimeZone specified in <tt>config.time_zone</tt>.
    def zone
      Thread.current[:time_zone] || zone_default
    end

    # Sets <tt>Time.zone</tt> to a TimeZone object for the current request/thread.
    #
    # This method accepts any of the following:
    #
    # * A Rails TimeZone object.
    # * An identifier for a Rails TimeZone object (e.g., "Eastern Time (US & Canada)", <tt>-5.hours</tt>).
    # * A TZInfo::Timezone object.
    # * An identifier for a TZInfo::Timezone object (e.g., "America/New_York").
    #
    # Here's an example of how you might set <tt>Time.zone</tt> on a per request basis and reset it when the request is done.
    # <tt>current_user.time_zone</tt> just needs to return a string identifying the user's preferred time zone:
    #
    #   class ApplicationController < ActionController::Base
    #     around_action :set_time_zone
    #
    #     def set_time_zone
    #       if logged_in?
    #         Time.use_zone(current_user.time_zone) { yield }
    #       else
    #         yield
    #       end
    #     end
    #   end
    def zone=(time_zone)
      Thread.current[:time_zone] = find_zone!(time_zone)
    end

    # Allows override of <tt>Time.zone</tt> locally inside supplied block;
    # resets <tt>Time.zone</tt> to existing value when done.
    #
    #   class ApplicationController < ActionController::Base
    #     around_action :set_time_zone
    #
    #     private
    #
    #     def set_time_zone
    #       Time.use_zone(current_user.timezone) { yield }
    #     end
    #   end
    #
    # NOTE: This won't affect any <tt>ActiveSupport::TimeWithZone</tt>
    # objects that have already been created, e.g. any model timestamp
    # attributes that have been read before the block will remain in
    # the application's default timezone.
    def use_zone(time_zone)
      new_zone = find_zone!(time_zone)
      begin
        old_zone, ::Time.zone = ::Time.zone, new_zone
        yield
      ensure
        ::Time.zone = old_zone
      end
    end

    # Returns a TimeZone instance matching the time zone provided.
    # Accepts the time zone in any format supported by <tt>Time.zone=</tt>.
    # Raises an +ArgumentError+ for invalid time zones.
    #
    #   Time.find_zone! "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
    #   Time.find_zone! "EST"              # => #<ActiveSupport::TimeZone @name="EST" ...>
    #   Time.find_zone! -5.hours           # => #<ActiveSupport::TimeZone @name="Bogota" ...>
    #   Time.find_zone! nil                # => nil
    #   Time.find_zone! false              # => false
    #   Time.find_zone! "NOT-A-TIMEZONE"   # => ArgumentError: Invalid Timezone: NOT-A-TIMEZONE
    def find_zone!(time_zone)
      if !time_zone || time_zone.is_a?(ActiveSupport::TimeZone)
        time_zone
      else
        # Look up the timezone based on the identifier (unless we've been
        # passed a TZInfo::Timezone)
        unless time_zone.respond_to?(:period_for_local)
          time_zone = ActiveSupport::TimeZone[time_zone] || TZInfo::Timezone.get(time_zone)
        end

        # Return if a TimeZone instance, or wrap in a TimeZone instance if a TZInfo::Timezone
        if time_zone.is_a?(ActiveSupport::TimeZone)
          time_zone
        else
          ActiveSupport::TimeZone.create(time_zone.name, nil, time_zone)
        end
      end
    rescue TZInfo::InvalidTimezoneIdentifier
      raise ArgumentError, "Invalid Timezone: #{time_zone}"
    end

    # Returns a TimeZone instance matching the time zone provided.
    # Accepts the time zone in any format supported by <tt>Time.zone=</tt>.
    # Returns +nil+ for invalid time zones.
    #
    #   Time.find_zone "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
    #   Time.find_zone "NOT-A-TIMEZONE"   # => nil
    def find_zone(time_zone)
      find_zone!(time_zone) rescue nil
# frozen_string_literal: true

require "time"
require "active_support/inflector/methods"
require "active_support/values/time_zone"

class Time
  DATE_FORMATS = {
    db: "%Y-%m-%d %H:%M:%S",
    inspect: "%Y-%m-%d %H:%M:%S.%9N %z",
    number: "%Y%m%d%H%M%S",
    nsec: "%Y%m%d%H%M%S%9N",
    usec: "%Y%m%d%H%M%S%6N",
    time: "%H:%M",
    short: "%d %b %H:%M",
    long: "%B %d, %Y %H:%M",
    long_ordinal: lambda { |time|
      day_format = ActiveSupport::Inflector.ordinalize(time.day)
      time.strftime("%B #{day_format}, %Y %H:%M")
    },
    rfc822: lambda { |time|
      offset_format = time.formatted_offset(false)
      time.strftime("%a, %d %b %Y %H:%M:%S #{offset_format}")
    },
    iso8601: lambda { |time| time.iso8601 }
  }

  # Converts to a formatted string. See DATE_FORMATS for built-in formats.
  #
  # This method is aliased to <tt>to_s</tt>.
  #
  #   time = Time.now                    # => 2007-01-18 06:10:17 -06:00
  #
  #   time.to_formatted_s(:time)         # => "06:10"
  #   time.to_s(:time)                   # => "06:10"
  #
  #   time.to_formatted_s(:db)           # => "2007-01-18 06:10:17"
  #   time.to_formatted_s(:number)       # => "20070118061017"
  #   time.to_formatted_s(:short)        # => "18 Jan 06:10"
  #   time.to_formatted_s(:long)         # => "January 18, 2007 06:10"
  #   time.to_formatted_s(:long_ordinal) # => "January 18th, 2007 06:10"
  #   time.to_formatted_s(:rfc822)       # => "Thu, 18 Jan 2007 06:10:17 -0600"
  #   time.to_formatted_s(:iso8601)      # => "2007-01-18T06:10:17-06:00"
  #
  # == Adding your own time formats to +to_formatted_s+
  # You can add your own formats to the Time::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a time argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime("%B #{time.day.ordinalize}") }
  def to_formatted_s(format = :default)
    if formatter = DATE_FORMATS[format]
      formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)
    else
      to_default_s
    end
  end
  alias_method :to_default_s, :to_s
  alias_method :to_s, :to_formatted_s

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   Time.local(2000).formatted_offset        # => "-06:00"
  #   Time.local(2000).formatted_offset(false) # => "-0600"
  def formatted_offset(colon = true, alternate_utc_string = nil)
    utc? && alternate_utc_string || ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, colon)
  end
# frozen_string_literal: true

require "active_support/core_ext/object/acts_like"

class Time
# frozen_string_literal: true

require "active_support/core_ext/date_and_time/compatibility"
require "active_support/core_ext/module/redefine_method"

class Time
  include DateAndTime::Compatibility

  silence_redefinition_of_method :to_time

  # Either return +self+ or the time in the local system timezone depending
  # on the setting of +ActiveSupport.to_time_preserves_timezone+.
  def to_time
    preserve_timezone ? self : getlocal
  end
# frozen_string_literal: true

require "benchmark"

class << Benchmark
  # Benchmark realtime in milliseconds.
  #
  #   Benchmark.realtime { User.all }
  #   # => 8.0e-05
  #
  #   Benchmark.ms { User.all }
  #   # => 0.074
  def ms(&block)
    1000 * realtime(&block)
  end
# frozen_string_literal: true

class Regexp
  # Returns +true+ if the regexp has the multiline flag set.
  #
  #   (/./).multiline?  # => false
  #   (/./m).multiline? # => true
  #
  #   Regexp.new(".").multiline?                    # => false
  #   Regexp.new(".", Regexp::MULTILINE).multiline? # => true
# frozen_string_literal: true

require "bigdecimal"
require "bigdecimal/util"

module ActiveSupport
  module BigDecimalWithDefaultFormat #:nodoc:
    def to_s(format = "F")
      super(format)
    end
# frozen_string_literal: true

require "active_support/core_ext/module/aliasing"
require "active_support/core_ext/module/introspection"
require "active_support/core_ext/module/anonymous"
require "active_support/core_ext/module/attribute_accessors"
require "active_support/core_ext/module/attribute_accessors_per_thread"
require "active_support/core_ext/module/attr_internal"
require "active_support/core_ext/module/concerning"
require "active_support/core_ext/module/delegation"
# frozen_string_literal: true

class Numeric
  KILOBYTE = 1024
  MEGABYTE = KILOBYTE * 1024
  GIGABYTE = MEGABYTE * 1024
  TERABYTE = GIGABYTE * 1024
  PETABYTE = TERABYTE * 1024
  EXABYTE  = PETABYTE * 1024

  # Enables the use of byte calculations and declarations, like 45.bytes + 2.6.megabytes
  #
  #   2.bytes # => 2
  def bytes
    self
  end
  alias :byte :bytes

  # Returns the number of bytes equivalent to the kilobytes provided.
  #
  #   2.kilobytes # => 2048
  def kilobytes
    self * KILOBYTE
  end
  alias :kilobyte :kilobytes

  # Returns the number of bytes equivalent to the megabytes provided.
  #
  #   2.megabytes # => 2_097_152
  def megabytes
    self * MEGABYTE
  end
  alias :megabyte :megabytes

  # Returns the number of bytes equivalent to the gigabytes provided.
  #
  #   2.gigabytes # => 2_147_483_648
  def gigabytes
    self * GIGABYTE
  end
  alias :gigabyte :gigabytes

  # Returns the number of bytes equivalent to the terabytes provided.
  #
  #   2.terabytes # => 2_199_023_255_552
  def terabytes
    self * TERABYTE
  end
  alias :terabyte :terabytes

  # Returns the number of bytes equivalent to the petabytes provided.
  #
  #   2.petabytes # => 2_251_799_813_685_248
  def petabytes
    self * PETABYTE
  end
  alias :petabyte :petabytes

  # Returns the number of bytes equivalent to the exabytes provided.
  #
  #   2.exabytes # => 2_305_843_009_213_693_952
  def exabytes
    self * EXABYTE
  end
  alias :exabyte :exabytes
# frozen_string_literal: true

require "active_support/core_ext/big_decimal/conversions"
require "active_support/number_helper"

module ActiveSupport
  module NumericWithFormat
    # Provides options for converting numbers into formatted strings.
    # Options are provided for phone numbers, currency, percentage,
    # precision, positional notation, file size and pretty printing.
    #
    # ==== Options
    #
    # For details on which formats use which options, see ActiveSupport::NumberHelper
    #
    # ==== Examples
    #
    #  Phone Numbers:
    #  5551234.to_s(:phone)                                     # => "555-1234"
    #  1235551234.to_s(:phone)                                  # => "123-555-1234"
    #  1235551234.to_s(:phone, area_code: true)                 # => "(123) 555-1234"
    #  1235551234.to_s(:phone, delimiter: ' ')                  # => "123 555 1234"
    #  1235551234.to_s(:phone, area_code: true, extension: 555) # => "(123) 555-1234 x 555"
    #  1235551234.to_s(:phone, country_code: 1)                 # => "+1-123-555-1234"
    #  1235551234.to_s(:phone, country_code: 1, extension: 1343, delimiter: '.')
    #  # => "+1.123.555.1234 x 1343"
    #
    #  Currency:
    #  1234567890.50.to_s(:currency)                     # => "$1,234,567,890.50"
    #  1234567890.506.to_s(:currency)                    # => "$1,234,567,890.51"
    #  1234567890.506.to_s(:currency, precision: 3)      # => "$1,234,567,890.506"
    #  1234567890.506.to_s(:currency, round_mode: :down) # => "$1,234,567,890.50"
    #  1234567890.506.to_s(:currency, locale: :fr)       # => "1 234 567 890,51 "
    #  -1234567890.50.to_s(:currency, negative_format: '(%u%n)')
    #  # => "($1,234,567,890.50)"
    #  1234567890.50.to_s(:currency, unit: '&pound;', separator: ',', delimiter: '')
    #  # => "&pound;1234567890,50"
    #  1234567890.50.to_s(:currency, unit: '&pound;', separator: ',', delimiter: '', format: '%n %u')
    #  # => "1234567890,50 &pound;"
    #
    #  Percentage:
    #  100.to_s(:percentage)                                  # => "100.000%"
    #  100.to_s(:percentage, precision: 0)                    # => "100%"
    #  1000.to_s(:percentage, delimiter: '.', separator: ',') # => "1.000,000%"
    #  302.24398923423.to_s(:percentage, precision: 5)        # => "302.24399%"
    #  302.24398923423.to_s(:percentage, round_mode: :down)   # => "302.243%"
    #  1000.to_s(:percentage, locale: :fr)                    # => "1 000,000%"
    #  100.to_s(:percentage, format: '%n  %')                 # => "100.000  %"
    #
    #  Delimited:
    #  12345678.to_s(:delimited)                     # => "12,345,678"
    #  12345678.05.to_s(:delimited)                  # => "12,345,678.05"
    #  12345678.to_s(:delimited, delimiter: '.')     # => "12.345.678"
    #  12345678.to_s(:delimited, delimiter: ',')     # => "12,345,678"
    #  12345678.05.to_s(:delimited, separator: ' ')  # => "12,345,678 05"
    #  12345678.05.to_s(:delimited, locale: :fr)     # => "12 345 678,05"
    #  98765432.98.to_s(:delimited, delimiter: ' ', separator: ',')
    #  # => "98 765 432,98"
    #
    #  Rounded:
    #  111.2345.to_s(:rounded)                                      # => "111.235"
    #  111.2345.to_s(:rounded, precision: 2)                        # => "111.23"
    #  111.2345.to_s(:rounded, precision: 2, round_mode: :up)       # => "111.24"
    #  13.to_s(:rounded, precision: 5)                              # => "13.00000"
    #  389.32314.to_s(:rounded, precision: 0)                       # => "389"
    #  111.2345.to_s(:rounded, significant: true)                   # => "111"
    #  111.2345.to_s(:rounded, precision: 1, significant: true)     # => "100"
    #  13.to_s(:rounded, precision: 5, significant: true)           # => "13.000"
    #  111.234.to_s(:rounded, locale: :fr)                          # => "111,234"
    #  13.to_s(:rounded, precision: 5, significant: true, strip_insignificant_zeros: true)
    #  # => "13"
    #  389.32314.to_s(:rounded, precision: 4, significant: true)    # => "389.3"
    #  1111.2345.to_s(:rounded, precision: 2, separator: ',', delimiter: '.')
    #  # => "1.111,23"
    #
    #  Human-friendly size in Bytes:
    #  123.to_s(:human_size)                                    # => "123 Bytes"
    #  1234.to_s(:human_size)                                   # => "1.21 KB"
    #  12345.to_s(:human_size)                                  # => "12.1 KB"
    #  1234567.to_s(:human_size)                                # => "1.18 MB"
    #  1234567890.to_s(:human_size)                             # => "1.15 GB"
    #  1234567890123.to_s(:human_size)                          # => "1.12 TB"
    #  1234567890123456.to_s(:human_size)                       # => "1.1 PB"
    #  1234567890123456789.to_s(:human_size)                    # => "1.07 EB"
    #  1234567.to_s(:human_size, precision: 2)                  # => "1.2 MB"
    #  1234567.to_s(:human_size, precision: 2, round_mode: :up) # => "1.3 MB"
    #  483989.to_s(:human_size, precision: 2)                   # => "470 KB"
    #  1234567.to_s(:human_size, precision: 2, separator: ',')  # => "1,2 MB"
    #  1234567890123.to_s(:human_size, precision: 5)            # => "1.1228 TB"
    #  524288000.to_s(:human_size, precision: 5)                # => "500 MB"
    #
    #  Human-friendly format:
    #  123.to_s(:human)                                       # => "123"
    #  1234.to_s(:human)                                      # => "1.23 Thousand"
    #  12345.to_s(:human)                                     # => "12.3 Thousand"
    #  1234567.to_s(:human)                                   # => "1.23 Million"
    #  1234567890.to_s(:human)                                # => "1.23 Billion"
    #  1234567890123.to_s(:human)                             # => "1.23 Trillion"
    #  1234567890123456.to_s(:human)                          # => "1.23 Quadrillion"
    #  1234567890123456789.to_s(:human)                       # => "1230 Quadrillion"
    #  489939.to_s(:human, precision: 2)                      # => "490 Thousand"
    #  489939.to_s(:human, precision: 2, round_mode: :down)   # => "480 Thousand"
    #  489939.to_s(:human, precision: 4)                      # => "489.9 Thousand"
    #  1234567.to_s(:human, precision: 4,
    #                   significant: false)                   # => "1.2346 Million"
    #  1234567.to_s(:human, precision: 1,
    #                   separator: ',',
    #                   significant: false)                   # => "1,2 Million"
    def to_s(format = nil, options = nil)
      case format
      when nil
        super()
      when Integer, String
        super(format)
      when :phone
        ActiveSupport::NumberHelper.number_to_phone(self, options || {})
      when :currency
        ActiveSupport::NumberHelper.number_to_currency(self, options || {})
      when :percentage
        ActiveSupport::NumberHelper.number_to_percentage(self, options || {})
      when :delimited
        ActiveSupport::NumberHelper.number_to_delimited(self, options || {})
      when :rounded
        ActiveSupport::NumberHelper.number_to_rounded(self, options || {})
      when :human
        ActiveSupport::NumberHelper.number_to_human(self, options || {})
      when :human_size
        ActiveSupport::NumberHelper.number_to_human_size(self, options || {})
      when Symbol
        super()
      else
        super(format)
      end
    end
  end
# frozen_string_literal: true

require "active_support/duration"
require "active_support/core_ext/time/calculations"
require "active_support/core_ext/time/acts_like"
require "active_support/core_ext/date/calculations"
require "active_support/core_ext/date/acts_like"

class Numeric
  # Returns a Duration instance matching the number of seconds provided.
  #
  #   2.seconds # => 2 seconds
  def seconds
    ActiveSupport::Duration.seconds(self)
  end
  alias :second :seconds

  # Returns a Duration instance matching the number of minutes provided.
  #
  #   2.minutes # => 2 minutes
  def minutes
    ActiveSupport::Duration.minutes(self)
  end
  alias :minute :minutes

  # Returns a Duration instance matching the number of hours provided.
  #
  #   2.hours # => 2 hours
  def hours
    ActiveSupport::Duration.hours(self)
  end
  alias :hour :hours

  # Returns a Duration instance matching the number of days provided.
  #
  #   2.days # => 2 days
  def days
    ActiveSupport::Duration.days(self)
  end
  alias :day :days

  # Returns a Duration instance matching the number of weeks provided.
  #
  #   2.weeks # => 2 weeks
  def weeks
    ActiveSupport::Duration.weeks(self)
  end
  alias :week :weeks

  # Returns a Duration instance matching the number of fortnights provided.
  #
  #   2.fortnights # => 4 weeks
  def fortnights
    ActiveSupport::Duration.weeks(self * 2)
  end
  alias :fortnight :fortnights

  # Returns the number of milliseconds equivalent to the seconds provided.
  # Used with the standard time durations.
  #
  #   2.in_milliseconds # => 2000
  #   1.hour.in_milliseconds # => 3600000
  def in_milliseconds
    self * 1000
  end
# frozen_string_literal: true

require "fileutils"

class File
  # Write to a file atomically. Useful for situations where you don't
  # want other processes or threads to see half-written files.
  #
  #   File.atomic_write('important.file') do |file|
  #     file.write('hello')
  #   end
  #
  # This method needs to create a temporary file. By default it will create it
  # in the same directory as the destination file. If you don't like this
  # behavior you can provide a different directory but it must be on the
  # same physical filesystem as the file you're trying to write.
  #
  #   File.atomic_write('/data/something.important', '/data/tmp') do |file|
  #     file.write('hello')
  #   end
  def self.atomic_write(file_name, temp_dir = dirname(file_name))
    require "tempfile" unless defined?(Tempfile)

    Tempfile.open(".#{basename(file_name)}", temp_dir) do |temp_file|
      temp_file.binmode
      return_val = yield temp_file
      temp_file.close

      old_stat = if exist?(file_name)
        # Get original file permissions
        stat(file_name)
      else
        # If not possible, probe which are the default permissions in the
        # destination directory.
        probe_stat_in(dirname(file_name))
      end

      if old_stat
        # Set correct permissions on new file
        begin
          chown(old_stat.uid, old_stat.gid, temp_file.path)
          # This operation will affect filesystem ACL's
          chmod(old_stat.mode, temp_file.path)
        rescue Errno::EPERM, Errno::EACCES
          # Changing file ownership failed, moving on.
        end
      end

      # Overwrite original file with temp file
      rename(temp_file.path, file_name)
      return_val
    end
  end

  # Private utility method.
  def self.probe_stat_in(dir) #:nodoc:
    basename = [
      ".permissions_check",
      Thread.current.object_id,
      Process.pid,
      rand(1000000)
    ].join(".")

    file_name = join(dir, basename)
    FileUtils.touch(file_name)
# frozen_string_literal: true

require "active_support/core_ext/object/acts_like"
require "active_support/core_ext/object/blank"
require "active_support/core_ext/object/duplicable"
require "active_support/core_ext/object/deep_dup"
require "active_support/core_ext/object/try"
require "active_support/core_ext/object/inclusion"

require "active_support/core_ext/object/conversions"
require "active_support/core_ext/object/instance_variables"

require "active_support/core_ext/object/json"
require "active_support/core_ext/object/to_param"
require "active_support/core_ext/object/to_query"
# frozen_string_literal: true

module Enumerable
  INDEX_WITH_DEFAULT = Object.new
  private_constant :INDEX_WITH_DEFAULT

  # Enumerable#sum was added in Ruby 2.4, but it only works with Numeric elements
  # when we omit an identity.

  # :stopdoc:

  # We can't use Refinements here because Refinements with Module which will be prepended
  # doesn't work well https://bugs.ruby-lang.org/issues/13446
  alias :_original_sum_with_required_identity :sum
  private :_original_sum_with_required_identity

  # :startdoc:

  # Calculates the minimum from the extracted elements.
  #
  # payments = [Payment.new(5), Payment.new(15), Payment.new(10)]
  # payments.minimum(:price) # => 5
  def minimum(key)
    map(&key).min
  end

  # Calculates the maximum from the extracted elements.
  #
  # payments = [Payment.new(5), Payment.new(15), Payment.new(10)]
  # payments.maximum(:price) # => 15
  def maximum(key)
    map(&key).max
  end

  # Calculates a sum from the elements.
  #
  #  payments.sum { |p| p.price * p.tax_rate }
  #  payments.sum(&:price)
  #
  # The latter is a shortcut for:
  #
  #  payments.inject(0) { |sum, p| sum + p.price }
  #
  # It can also calculate the sum without the use of a block.
  #
  #  [5, 15, 10].sum # => 30
  #  ['foo', 'bar'].sum # => "foobar"
  #  [[1, 2], [3, 1, 5]].sum # => [1, 2, 3, 1, 5]
  #
  # The default sum of an empty list is zero. You can override this default:
  #
  #  [].sum(Payment.new(0)) { |i| i.amount } # => Payment.new(0)
  def sum(identity = nil, &block)
    if identity
      _original_sum_with_required_identity(identity, &block)
    elsif block_given?
      map(&block).sum(identity)
    else
      inject(:+) || 0
    end
  end

  # Convert an enumerable to a hash, using the block result as the key and the
  # element as the value.
  #
  #   people.index_by(&:login)
  #   # => { "nextangle" => <Person ...>, "chade-" => <Person ...>, ...}
  #
  #   people.index_by { |person| "#{person.first_name} #{person.last_name}" }
  #   # => { "Chade- Fowlersburg-e" => <Person ...>, "David Heinemeier Hansson" => <Person ...>, ...}
  def index_by
    if block_given?
      result = {}
      each { |elem| result[yield(elem)] = elem }
      result
    else
      to_enum(:index_by) { size if respond_to?(:size) }
    end
  end

  # Convert an enumerable to a hash, using the element as the key and the block
  # result as the value.
  #
  #   post = Post.new(title: "hey there", body: "what's up?")
  #
  #   %i( title body ).index_with { |attr_name| post.public_send(attr_name) }
  #   # => { title: "hey there", body: "what's up?" }
  #
  # If an argument is passed instead of a block, it will be used as the value
  # for all elements:
  #
  #   %i( created_at updated_at ).index_with(Time.now)
  #   # => { created_at: 2020-03-09 22:31:47, updated_at: 2020-03-09 22:31:47 }
  def index_with(default = INDEX_WITH_DEFAULT)
    if block_given?
      result = {}
      each { |elem| result[elem] = yield(elem) }
      result
    elsif default != INDEX_WITH_DEFAULT
      result = {}
      each { |elem| result[elem] = default }
      result
    else
      to_enum(:index_with) { size if respond_to?(:size) }
    end
  end

  # Returns +true+ if the enumerable has more than 1 element. Functionally
  # equivalent to <tt>enum.to_a.size > 1</tt>. Can be called with a block too,
  # much like any?, so <tt>people.many? { |p| p.age > 26 }</tt> returns +true+
  # if more than one person is over 26.
  def many?
    cnt = 0
    if block_given?
      any? do |element|
        cnt += 1 if yield element
        cnt > 1
      end
    else
      any? { (cnt += 1) > 1 }
    end
  end

  # Returns a new array that includes the passed elements.
  #
  #   [ 1, 2, 3 ].including(4, 5)
  #   # => [ 1, 2, 3, 4, 5 ]
  #
  #   ["David", "Rafael"].including %w[ Aaron Todd ]
  #   # => ["David", "Rafael", "Aaron", "Todd"]
  def including(*elements)
    to_a.including(*elements)
  end

  # The negative of the <tt>Enumerable#include?</tt>. Returns +true+ if the
  # collection does not include the object.
  def exclude?(object)
    !include?(object)
  end

  # Returns a copy of the enumerable excluding the specified elements.
  #
  #   ["David", "Rafael", "Aaron", "Todd"].excluding "Aaron", "Todd"
  #   # => ["David", "Rafael"]
  #
  #   ["David", "Rafael", "Aaron", "Todd"].excluding %w[ Aaron Todd ]
  #   # => ["David", "Rafael"]
  #
  #   {foo: 1, bar: 2, baz: 3}.excluding :bar
  #   # => {foo: 1, baz: 3}
  def excluding(*elements)
    elements.flatten!(1)
    reject { |element| elements.include?(element) }
  end
  alias :without :excluding

  # Extract the given key from each element in the enumerable.
  #
  #   [{ name: "David" }, { name: "Rafael" }, { name: "Aaron" }].pluck(:name)
  #   # => ["David", "Rafael", "Aaron"]
  #
  #   [{ id: 1, name: "David" }, { id: 2, name: "Rafael" }].pluck(:id, :name)
  #   # => [[1, "David"], [2, "Rafael"]]
  def pluck(*keys)
    if keys.many?
      map { |element| keys.map { |key| element[key] } }
    else
      key = keys.first
      map { |element| element[key] }
    end
  end

  # Extract the given key from the first element in the enumerable.
  #
  #   [{ name: "David" }, { name: "Rafael" }, { name: "Aaron" }].pick(:name)
  #   # => "David"
  #
  #   [{ id: 1, name: "David" }, { id: 2, name: "Rafael" }].pick(:id, :name)
  #   # => [1, "David"]
  def pick(*keys)
    return if none?

    if keys.many?
      keys.map { |key| first[key] }
    else
      first[keys.first]
    end
  end

  # Returns a new +Array+ without the blank items.
  # Uses Object#blank? for determining if an item is blank.
  #
  #    [1, "", nil, 2, " ", [], {}, false, true].compact_blank
  #    # =>  [1, 2, true]
  #
  #    Set.new([nil, "", 1, 2])
  #    # => [2, 1] (or [1, 2])
  #
  # When called on a +Hash+, returns a new +Hash+ without the blank values.
  #
  #    { a: "", b: 1, c: nil, d: [], e: false, f: true }.compact_blank
  #    #=> { b: 1, f: true }
  def compact_blank
    reject(&:blank?)
  end

  # Returns a new +Array+ where the order has been set to that provided in the +series+, based on the +key+ of the
  # objects in the original enumerable.
  #
  #   [ Person.find(5), Person.find(3), Person.find(1) ].in_order_of(:id, [ 1, 5, 3 ])
  #   => [ Person.find(1), Person.find(5), Person.find(3) ]
  #
  # If the +series+ include keys that have no corresponding element in the Enumerable, these are ignored.
  # If the Enumerable has additional elements that aren't named in the +series+, these are not included in the result.
  def in_order_of(key, series)
    index_by(&key).values_at(*series).compact
  end
end

class Hash
  # Hash#reject has its own definition, so this needs one too.
  def compact_blank #:nodoc:
    reject { |_k, v| v.blank? }
  end

  # Removes all blank values from the +Hash+ in place and returns self.
  # Uses Object#blank? for determining if a value is blank.
  #
  #    h = { a: "", b: 1, c: nil, d: [], e: false, f: true }
  #    h.compact_blank!
  #    # => { b: 1, f: true }
  def compact_blank!
    # use delete_if rather than reject! because it always returns self even if nothing changed
    delete_if { |_k, v| v.blank? }
  end
end

class Range #:nodoc:
  # Optimize range sum to use arithmetic progression if a block is not given and
  # we have a range of numeric values.
  def sum(identity = nil)
    if block_given? || !(first.is_a?(Integer) && last.is_a?(Integer))
      super
    else
      actual_last = exclude_end? ? (last - 1) : last
      if actual_last >= first
        sum = identity || 0
        sum + (actual_last - first + 1) * (actual_last + first) / 2
      else
        identity || 0
      end
    end
  end
end

# Using Refinements here in order not to expose our internal method
using Module.new {
  refine Array do
    alias :orig_sum :sum
  end
}

class Array #:nodoc:
  # Array#sum was added in Ruby 2.4 but it only works with Numeric elements.
  def sum(init = nil, &block)
    if init.is_a?(Numeric) || first.is_a?(Numeric)
      init ||= 0
      orig_sum(init, &block)
    else
      super
    end
  end

  # Removes all blank elements from the +Array+ in place and returns self.
  # Uses Object#blank? for determining if an item is blank.
  #
  #    a = [1, "", nil, 2, " ", [], {}, false, true]
  #    a.compact_blank!
  #    # =>  [1, 2, true]
  def compact_blank!
# frozen_string_literal: true

class Object
  # Returns true if this object is included in the argument. Argument must be
  # any object which responds to +#include?+. Usage:
  #
  #   characters = ["Konata", "Kagami", "Tsukasa"]
  #   "Konata".in?(characters) # => true
  #
  # This will throw an +ArgumentError+ if the argument doesn't respond
  # to +#include?+.
  def in?(another_object)
    another_object.include?(self)
  rescue NoMethodError
    raise ArgumentError.new("The parameter passed to #in? must respond to #include?")
  end

  # Returns the receiver if it's included in the argument otherwise returns +nil+.
  # Argument must be any object which responds to +#include?+. Usage:
  #
  #   params[:bucket_type].presence_in %w( project calendar )
  #
  # This will throw an +ArgumentError+ if the argument doesn't respond to +#include?+.
  #
  # @return [Object]
# frozen_string_literal: true

require "active_support/option_merger"

class Object
  # An elegant way to factor duplication out of options passed to a series of
  # method calls. Each method called in the block, with the block variable as
  # the receiver, will have its options merged with the default +options+ hash
  # provided. Each method called on the block variable must take an options
  # hash as its final argument.
  #
  # Without <tt>with_options</tt>, this code contains duplication:
  #
  #   class Account < ActiveRecord::Base
  #     has_many :customers, dependent: :destroy
  #     has_many :products,  dependent: :destroy
  #     has_many :invoices,  dependent: :destroy
  #     has_many :expenses,  dependent: :destroy
  #   end
  #
  # Using <tt>with_options</tt>, we can remove the duplication:
  #
  #   class Account < ActiveRecord::Base
  #     with_options dependent: :destroy do |assoc|
  #       assoc.has_many :customers
  #       assoc.has_many :products
  #       assoc.has_many :invoices
  #       assoc.has_many :expenses
  #     end
  #   end
  #
  # It can also be used with an explicit receiver:
  #
  #   I18n.with_options locale: user.locale, scope: 'newsletter' do |i18n|
  #     subject i18n.t :subject
  #     body    i18n.t :body, user_name: user.name
  #   end
  #
  # When you don't pass an explicit receiver, it executes the whole block
  # in merging options context:
  #
  #   class Account < ActiveRecord::Base
  #     with_options dependent: :destroy do
  #       has_many :customers
  #       has_many :products
  #       has_many :invoices
  #       has_many :expenses
  #     end
  #   end
  #
  # <tt>with_options</tt> can also be nested since the call is forwarded to its receiver.
  #
  # NOTE: Each nesting level will merge inherited defaults in addition to their own.
  #
  #   class Post < ActiveRecord::Base
  #     with_options if: :persisted?, length: { minimum: 50 } do
  #       validates :content, if: -> { content.present? }
  #     end
  #   end
  #
  # The code is equivalent to:
  #
  #   validates :content, length: { minimum: 50 }, if: -> { content.present? }
  #
  # Hence the inherited default for +if+ key is ignored.
  #
  # NOTE: You cannot call class methods implicitly inside of with_options.
  # You can access these methods using the class name instead:
  #
  #   class Phone < ActiveRecord::Base
  #     enum phone_number_type: { home: 0, office: 1, mobile: 2 }
  #
  #     with_options presence: true do
  #       validates :phone_number_type, inclusion: { in: Phone.phone_number_types.keys }
  #     end
  #   end
  #
  def with_options(options, &block)
    option_merger = ActiveSupport::OptionMerger.new(self, options)
    block.arity.zero? ? option_merger.instance_eval(&block) : block.call(option_merger)
# frozen_string_literal: true

#--
# Most objects are cloneable, but not all. For example you can't dup methods:
#
#   method(:puts).dup # => TypeError: allocator undefined for Method
#
# Classes may signal their instances are not duplicable removing +dup+/+clone+
# or raising exceptions from them. So, to dup an arbitrary object you normally
# use an optimistic approach and are ready to catch an exception, say:
#
#   arbitrary_object.dup rescue object
#
# Rails dups objects in a few critical spots where they are not that arbitrary.
# That rescue is very expensive (like 40 times slower than a predicate), and it
# is often triggered.
#
# That's why we hardcode the following cases and check duplicable? instead of
# using that rescue idiom.
#++
class Object
  # Can you safely dup this object?
  #
  # False for method objects;
  # true otherwise.
  def duplicable?
    true
  end
end

class Method
  # Methods are not duplicable:
  #
  #  method(:puts).duplicable? # => false
  #  method(:puts).dup         # => TypeError: allocator undefined for Method
  def duplicable?
    false
  end
end

class UnboundMethod
  # Unbound methods are not duplicable:
  #
  #  method(:puts).unbind.duplicable? # => false
  #  method(:puts).unbind.dup         # => TypeError: allocator undefined for UnboundMethod
  def duplicable?
    false
  end
end

require "singleton"

module Singleton
  # Singleton instances are not duplicable:
  #
# frozen_string_literal: true

# Hack to load json gem first so we can overwrite its to_json.
require "json"
require "bigdecimal"
require "ipaddr"
require "uri/generic"
require "pathname"
require "active_support/core_ext/big_decimal/conversions" # for #to_s
require "active_support/core_ext/hash/except"
require "active_support/core_ext/hash/slice"
require "active_support/core_ext/object/instance_variables"
require "time"
require "active_support/core_ext/time/conversions"
require "active_support/core_ext/date_time/conversions"
require "active_support/core_ext/date/conversions"

#--
# The JSON gem adds a few modules to Ruby core classes containing :to_json definition, overwriting
# their default behavior. That said, we need to define the basic to_json method in all of them,
# otherwise they will always use to_json gem implementation, which is backwards incompatible in
# several cases (for instance, the JSON implementation for Hash does not work) with inheritance
# and consequently classes as ActiveSupport::OrderedHash cannot be serialized to json.
#
# On the other hand, we should avoid conflict with ::JSON.{generate,dump}(obj). Unfortunately, the
# JSON gem's encoder relies on its own to_json implementation to encode objects. Since it always
# passes a ::JSON::State object as the only argument to to_json, we can detect that and forward the
# calls to the original to_json method.
#
# It should be noted that when using ::JSON.{generate,dump} directly, ActiveSupport's encoder is
# bypassed completely. This means that as_json won't be invoked and the JSON gem will simply
# ignore any options it does not natively understand. This also means that ::JSON.{generate,dump}
# should give exactly the same results with or without active support.

module ActiveSupport
  module ToJsonWithActiveSupportEncoder # :nodoc:
    def to_json(options = nil)
      if options.is_a?(::JSON::State)
        # Called from JSON.{generate,dump}, forward it to JSON gem's to_json
        super(options)
      else
        # to_json is being invoked directly, use ActiveSupport's encoder
        ActiveSupport::JSON.encode(self, options)
      end
    end
  end
end

[Enumerable, Object, Array, FalseClass, Float, Hash, Integer, NilClass, String, TrueClass].reverse_each do |klass|
  klass.prepend(ActiveSupport::ToJsonWithActiveSupportEncoder)
end

class Object
  def as_json(options = nil) #:nodoc:
    if respond_to?(:to_hash)
      to_hash.as_json(options)
    else
      instance_values.as_json(options)
    end
  end
end

class Struct #:nodoc:
  def as_json(options = nil)
    Hash[members.zip(values)].as_json(options)
  end
end

class TrueClass
  def as_json(options = nil) #:nodoc:
    self
  end
end

class FalseClass
  def as_json(options = nil) #:nodoc:
    self
  end
end

class NilClass
  def as_json(options = nil) #:nodoc:
    self
  end
end

class String
  def as_json(options = nil) #:nodoc:
    self
  end
end

class Symbol
  def as_json(options = nil) #:nodoc:
    to_s
  end
end

class Numeric
  def as_json(options = nil) #:nodoc:
    self
  end
end

class Float
  # Encoding Infinity or NaN to JSON should return "null". The default returns
  # "Infinity" or "NaN" which are not valid JSON.
  def as_json(options = nil) #:nodoc:
    finite? ? self : nil
  end
end

class BigDecimal
  # A BigDecimal would be naturally represented as a JSON number. Most libraries,
  # however, parse non-integer JSON numbers directly as floats. Clients using
  # those libraries would get in general a wrong number and no way to recover
  # other than manually inspecting the string with the JSON code itself.
  #
  # That's why a JSON string is returned. The JSON literal is not numeric, but
  # if the other end knows by contract that the data is supposed to be a
  # BigDecimal, it still has the chance to post-process the string and get the
  # real value.
  def as_json(options = nil) #:nodoc:
    finite? ? to_s : nil
  end
end

class Regexp
  def as_json(options = nil) #:nodoc:
    to_s
  end
end

module Enumerable
  def as_json(options = nil) #:nodoc:
    to_a.as_json(options)
  end
end

class IO
  def as_json(options = nil) #:nodoc:
    to_s
  end
end

class Range
  def as_json(options = nil) #:nodoc:
    to_s
  end
end

class Array
  def as_json(options = nil) #:nodoc:
    map { |v| options ? v.as_json(options.dup) : v.as_json }
  end
end

class Hash
  def as_json(options = nil) #:nodoc:
    # create a subset of the hash by applying :only or :except
    subset = if options
      if attrs = options[:only]
        slice(*Array(attrs))
      elsif attrs = options[:except]
        except(*Array(attrs))
      else
        self
      end
    else
      self
    end

    result = {}
    subset.each do |k, v|
      result[k.to_s] = options ? v.as_json(options.dup) : v.as_json
    end
    result
  end
end

class Time
  def as_json(options = nil) #:nodoc:
    if ActiveSupport::JSON::Encoding.use_standard_json_time_format
      xmlschema(ActiveSupport::JSON::Encoding.time_precision)
    else
      %(#{strftime("%Y/%m/%d %H:%M:%S")} #{formatted_offset(false)})
    end
  end
end

class Date
  def as_json(options = nil) #:nodoc:
    if ActiveSupport::JSON::Encoding.use_standard_json_time_format
      strftime("%Y-%m-%d")
    else
      strftime("%Y/%m/%d")
    end
  end
end

class DateTime
  def as_json(options = nil) #:nodoc:
    if ActiveSupport::JSON::Encoding.use_standard_json_time_format
      xmlschema(ActiveSupport::JSON::Encoding.time_precision)
    else
      strftime("%Y/%m/%d %H:%M:%S %z")
    end
  end
end

class URI::Generic #:nodoc:
  def as_json(options = nil)
    to_s
  end
end

class Pathname #:nodoc:
  def as_json(options = nil)
    to_s
  end
end

class IPAddr # :nodoc:
  def as_json(options = nil)
    to_s
  end
end

class Process::Status #:nodoc:
  def as_json(options = nil)
    { exitstatus: exitstatus, pid: pid }
  end
end

class Exception
# frozen_string_literal: true

require "cgi"

class Object
  # Alias of <tt>to_s</tt>.
  def to_param
    to_s
  end

  # Converts an object into a string suitable for use as a URL query string,
  # using the given <tt>key</tt> as the param name.
  def to_query(key)
    "#{CGI.escape(key.to_param)}=#{CGI.escape(to_param.to_s)}"
  end
end

class NilClass
  # Returns +self+.
  def to_param
    self
  end
end

class TrueClass
  # Returns +self+.
  def to_param
    self
  end
end

class FalseClass
  # Returns +self+.
  def to_param
    self
  end
end

class Array
  # Calls <tt>to_param</tt> on all its elements and joins the result with
  # slashes. This is used by <tt>url_for</tt> in Action Pack.
  def to_param
    collect(&:to_param).join "/"
  end

  # Converts an array into a string suitable for use as a URL query string,
  # using the given +key+ as the param name.
  #
  #   ['Rails', 'coding'].to_query('hobbies') # => "hobbies%5B%5D=Rails&hobbies%5B%5D=coding"
  def to_query(key)
    prefix = "#{key}[]"

    if empty?
      nil.to_query(prefix)
    else
      collect { |value| value.to_query(prefix) }.join "&"
    end
  end
end

class Hash
  # Returns a string representation of the receiver suitable for use as a URL
  # query string:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query
  #   # => "name=David&nationality=Danish"
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query('user')
  #   # => "user%5Bname%5D=David&user%5Bnationality%5D=Danish"
  #
  # The string pairs "key=value" that conform the query string
  # are sorted lexicographically in ascending order.
  #
  # This method is also aliased as +to_param+.
  def to_query(namespace = nil)
    query = collect do |key, value|
      unless (value.is_a?(Hash) || value.is_a?(Array)) && value.empty?
        value.to_query(namespace ? "#{namespace}[#{key}]" : key)
      end
    end.compact

    query.sort! unless namespace.to_s.include?("[]")
    query.join("&")
# frozen_string_literal: true

require "delegate"

module ActiveSupport
  module Tryable #:nodoc:
    def try(method_name = nil, *args, &b)
      if method_name.nil? && block_given?
        if b.arity == 0
          instance_eval(&b)
        else
          yield self
        end
      elsif respond_to?(method_name)
        public_send(method_name, *args, &b)
      end
    end
    ruby2_keywords(:try) if respond_to?(:ruby2_keywords, true)

    def try!(method_name = nil, *args, &b)
      if method_name.nil? && block_given?
        if b.arity == 0
          instance_eval(&b)
        else
          yield self
        end
      else
        public_send(method_name, *args, &b)
      end
    end
    ruby2_keywords(:try!) if respond_to?(:ruby2_keywords, true)
  end
end

class Object
  include ActiveSupport::Tryable

  ##
  # :method: try
  #
  # :call-seq:
  #   try(*a, &b)
  #
  # Invokes the public method whose name goes as first argument just like
  # +public_send+ does, except that if the receiver does not respond to it the
  # call returns +nil+ rather than raising an exception.
  #
  # This method is defined to be able to write
  #
  #   @person.try(:name)
  #
  # instead of
  #
  #   @person.name if @person
  #
  # +try+ calls can be chained:
  #
  #   @person.try(:spouse).try(:name)
  #
  # instead of
  #
  #   @person.spouse.name if @person && @person.spouse
  #
  # +try+ will also return +nil+ if the receiver does not respond to the method:
  #
  #   @person.try(:non_existing_method) # => nil
  #
  # instead of
  #
  #   @person.non_existing_method if @person.respond_to?(:non_existing_method) # => nil
  #
  # +try+ returns +nil+ when called on +nil+ regardless of whether it responds
  # to the method:
  #
  #   nil.try(:to_i) # => nil, rather than 0
  #
  # Arguments and blocks are forwarded to the method if invoked:
  #
  #   @posts.try(:each_slice, 2) do |a, b|
  #     ...
  #   end
  #
  # The number of arguments in the signature must match. If the object responds
  # to the method the call is attempted and +ArgumentError+ is still raised
  # in case of argument mismatch.
  #
  # If +try+ is called without arguments it yields the receiver to a given
  # block unless it is +nil+:
  #
  #   @person.try do |p|
  #     ...
  #   end
  #
  # You can also call try with a block without accepting an argument, and the block
  # will be instance_eval'ed instead:
  #
  #   @person.try { upcase.truncate(50) }
  #
  # Please also note that +try+ is defined on +Object+. Therefore, it won't work
  # with instances of classes that do not have +Object+ among their ancestors,
  # like direct subclasses of +BasicObject+.

  ##
  # :method: try!
  #
  # :call-seq:
  #   try!(*a, &b)
  #
  # Same as #try, but raises a +NoMethodError+ exception if the receiver is
  # not +nil+ and does not implement the tried method.
  #
  #   "a".try!(:upcase) # => "A"
  #   nil.try!(:upcase) # => nil
  #   123.try!(:upcase) # => NoMethodError: undefined method `upcase' for 123:Integer
end

class Delegator
  include ActiveSupport::Tryable

  ##
  # :method: try
  #
  # :call-seq:
  #   try(a*, &b)
  #
  # See Object#try

  ##
  # :method: try!
  #
  # :call-seq:
  #   try!(a*, &b)
  #
  # See Object#try!
end

class NilClass
  # Calling +try+ on +nil+ always returns +nil+.
  # It becomes especially helpful when navigating through associations that may return +nil+.
  #
  #   nil.try(:name) # => nil
  #
  # Without +try+
  #   @person && @person.children.any? && @person.children.first.name
  #
  # With +try+
  #   @person.try(:children).try(:first).try(:name)
  def try(_method_name = nil, *)
    nil
  end

  # Calling +try!+ on +nil+ always returns +nil+.
  #
  #   nil.try!(:name) # => nil
  def try!(_method_name = nil, *)
# frozen_string_literal: true

require "active_support/core_ext/object/to_param"
require "active_support/core_ext/object/to_query"
require "active_support/core_ext/array/conversions"
# frozen_string_literal: true

class Object
  # A duck-type assistant method. For example, Active Support extends Date
  # to define an <tt>acts_like_date?</tt> method, and extends Time to define
  # <tt>acts_like_time?</tt>. As a result, we can do <tt>x.acts_like?(:time)</tt> and
  # <tt>x.acts_like?(:date)</tt> to do duck-type-safe comparisons, since classes that
  # we want to act like Time simply need to define an <tt>acts_like_time?</tt> method.
  def acts_like?(duck)
    case duck
    when :time
      respond_to? :acts_like_time?
    when :date
      respond_to? :acts_like_date?
    when :string
      respond_to? :acts_like_string?
    else
      respond_to? :"acts_like_#{duck}?"
    end
  end
# frozen_string_literal: true

require "concurrent/map"

class Object
  # An object is blank if it's false, empty, or a whitespace string.
  # For example, +nil+, '', '   ', [], {}, and +false+ are all blank.
  #
  # This simplifies
  #
  #   !address || address.empty?
  #
  # to
  #
  #   address.blank?
  #
  # @return [true, false]
  def blank?
    respond_to?(:empty?) ? !!empty? : !self
  end

  # An object is present if it's not blank.
  #
  # @return [true, false]
  def present?
    !blank?
  end

  # Returns the receiver if it's present otherwise returns +nil+.
  # <tt>object.presence</tt> is equivalent to
  #
  #    object.present? ? object : nil
  #
  # For example, something like
  #
  #   state   = params[:state]   if params[:state].present?
  #   country = params[:country] if params[:country].present?
  #   region  = state || country || 'US'
  #
  # becomes
  #
  #   region = params[:state].presence || params[:country].presence || 'US'
  #
  # @return [Object]
  def presence
    self if present?
  end
end

class NilClass
  # +nil+ is blank:
  #
  #   nil.blank? # => true
  #
  # @return [true]
  def blank?
    true
  end
end

class FalseClass
  # +false+ is blank:
  #
  #   false.blank? # => true
  #
  # @return [true]
  def blank?
    true
  end
end

class TrueClass
  # +true+ is not blank:
  #
  #   true.blank? # => false
  #
  # @return [false]
  def blank?
    false
  end
end

class Array
  # An array is blank if it's empty:
  #
  #   [].blank?      # => true
  #   [1,2,3].blank? # => false
  #
  # @return [true, false]
  alias_method :blank?, :empty?
end

class Hash
  # A hash is blank if it's empty:
  #
  #   {}.blank?                # => true
  #   { key: 'value' }.blank?  # => false
  #
  # @return [true, false]
  alias_method :blank?, :empty?
end

class String
  BLANK_RE = /\A[[:space:]]*\z/
  ENCODED_BLANKS = Concurrent::Map.new do |h, enc|
    h[enc] = Regexp.new(BLANK_RE.source.encode(enc), BLANK_RE.options | Regexp::FIXEDENCODING)
  end

  # A string is blank if it's empty or contains whitespaces only:
  #
  #   ''.blank?       # => true
  #   '   '.blank?    # => true
  #   "\t\n\r".blank? # => true
  #   ' blah '.blank? # => false
  #
  # Unicode whitespace is supported:
  #
  #   "\u00a0".blank? # => true
  #
  # @return [true, false]
  def blank?
    # The regexp that matches blank strings is expensive. For the case of empty
    # strings we can speed up this method (~3.5x) with an empty? call. The
    # penalty for the rest of strings is marginal.
    empty? ||
      begin
        BLANK_RE.match?(self)
      rescue Encoding::CompatibilityError
        ENCODED_BLANKS[self.encoding].match?(self)
      end
  end
end

class Numeric #:nodoc:
  # No number is blank:
  #
  #   1.blank? # => false
  #   0.blank? # => false
  #
  # @return [false]
  def blank?
    false
  end
end

class Time #:nodoc:
  # No Time is blank:
  #
  #   Time.now.blank? # => false
  #
# frozen_string_literal: true

require "active_support/core_ext/object/duplicable"

class Object
  # Returns a deep copy of object if it's duplicable. If it's
  # not duplicable, returns +self+.
  #
  #   object = Object.new
  #   dup    = object.deep_dup
  #   dup.instance_variable_set(:@a, 1)
  #
  #   object.instance_variable_defined?(:@a) # => false
  #   dup.instance_variable_defined?(:@a)    # => true
  def deep_dup
    duplicable? ? dup : self
  end
end

class Array
  # Returns a deep copy of array.
  #
  #   array = [1, [2, 3]]
  #   dup   = array.deep_dup
  #   dup[1][2] = 4
  #
  #   array[1][2] # => nil
  #   dup[1][2]   # => 4
  def deep_dup
    map(&:deep_dup)
  end
end

class Hash
  # Returns a deep copy of hash.
  #
  #   hash = { a: { b: 'b' } }
  #   dup  = hash.deep_dup
  #   dup[:a][:c] = 'c'
  #
  #   hash[:a][:c] # => nil
  #   dup[:a][:c]  # => "c"
  def deep_dup
    hash = dup
    each_pair do |key, value|
      if ::String === key || ::Symbol === key
        hash[key] = value.deep_dup
      else
        hash.delete(key)
        hash[key.deep_dup] = value.deep_dup
# frozen_string_literal: true

class Object
  # Returns a hash with string keys that maps instance variable names without "@" to their
  # corresponding values.
  #
  #   class C
  #     def initialize(x, y)
  #       @x, @y = x, y
  #     end
  #   end
  #
  #   C.new(0, 1).instance_values # => {"x" => 0, "y" => 1}
  def instance_values
    Hash[instance_variables.map { |name| [name[1..-1], instance_variable_get(name)] }]
  end

  # Returns an array of instance variable names as strings including "@".
  #
  #   class C
  #     def initialize(x, y)
  #       @x, @y = x, y
  #     end
  #   end
  #
# frozen_string_literal: true

require "active_support/core_ext/range/conversions"
require "active_support/core_ext/range/compare_range"
require "active_support/core_ext/range/include_time_with_zone"
# frozen_string_literal: true

require "active_support/core_ext/object/try"
require "active_support/core_ext/date_time/conversions"

module DateAndTime
  module Calculations
    DAYS_INTO_WEEK = {
      sunday: 0,
      monday: 1,
      tuesday: 2,
      wednesday: 3,
      thursday: 4,
      friday: 5,
      saturday: 6
    }
    WEEKEND_DAYS = [ 6, 0 ]

    # Returns a new date/time representing yesterday.
    def yesterday
      advance(days: -1)
    end

    # Returns a new date/time representing tomorrow.
    def tomorrow
      advance(days: 1)
    end

    # Returns true if the date/time is today.
    def today?
      to_date == ::Date.current
    end

    # Returns true if the date/time is tomorrow.
    def tomorrow?
      to_date == ::Date.current.tomorrow
    end
    alias :next_day? :tomorrow?

    # Returns true if the date/time is yesterday.
    def yesterday?
      to_date == ::Date.current.yesterday
    end
    alias :prev_day? :yesterday?

    # Returns true if the date/time is in the past.
    def past?
      self < self.class.current
    end

    # Returns true if the date/time is in the future.
    def future?
      self > self.class.current
    end

    # Returns true if the date/time falls on a Saturday or Sunday.
    def on_weekend?
      WEEKEND_DAYS.include?(wday)
    end

    # Returns true if the date/time does not fall on a Saturday or Sunday.
    def on_weekday?
      !WEEKEND_DAYS.include?(wday)
    end

    # Returns true if the date/time falls before <tt>date_or_time</tt>.
    def before?(date_or_time)
      self < date_or_time
    end

    # Returns true if the date/time falls after <tt>date_or_time</tt>.
    def after?(date_or_time)
      self > date_or_time
    end

    # Returns a new date/time the specified number of days ago.
    def days_ago(days)
      advance(days: -days)
    end

    # Returns a new date/time the specified number of days in the future.
    def days_since(days)
      advance(days: days)
    end

    # Returns a new date/time the specified number of weeks ago.
    def weeks_ago(weeks)
      advance(weeks: -weeks)
    end

    # Returns a new date/time the specified number of weeks in the future.
    def weeks_since(weeks)
      advance(weeks: weeks)
    end

    # Returns a new date/time the specified number of months ago.
    def months_ago(months)
      advance(months: -months)
    end

    # Returns a new date/time the specified number of months in the future.
    def months_since(months)
      advance(months: months)
    end

    # Returns a new date/time the specified number of years ago.
    def years_ago(years)
      advance(years: -years)
    end

    # Returns a new date/time the specified number of years in the future.
    def years_since(years)
      advance(years: years)
    end

    # Returns a new date/time at the start of the month.
    #
    #   today = Date.today # => Thu, 18 Jun 2015
    #   today.beginning_of_month # => Mon, 01 Jun 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Thu, 18 Jun 2015 15:23:13 +0000
    #   now.beginning_of_month # => Mon, 01 Jun 2015 00:00:00 +0000
    def beginning_of_month
      first_hour(change(day: 1))
    end
    alias :at_beginning_of_month :beginning_of_month

    # Returns a new date/time at the start of the quarter.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.beginning_of_quarter # => Wed, 01 Jul 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.beginning_of_quarter # => Wed, 01 Jul 2015 00:00:00 +0000
    def beginning_of_quarter
      first_quarter_month = month - (2 + month) % 3
      beginning_of_month.change(month: first_quarter_month)
    end
    alias :at_beginning_of_quarter :beginning_of_quarter

    # Returns a new date/time at the end of the quarter.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.end_of_quarter # => Wed, 30 Sep 2015
    #
    # +DateTime+ objects will have a time set to 23:59:59.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.end_of_quarter # => Wed, 30 Sep 2015 23:59:59 +0000
    def end_of_quarter
      last_quarter_month = month + (12 - month) % 3
      beginning_of_month.change(month: last_quarter_month).end_of_month
    end
    alias :at_end_of_quarter :end_of_quarter

    # Returns a new date/time at the beginning of the year.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.beginning_of_year # => Thu, 01 Jan 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.beginning_of_year # => Thu, 01 Jan 2015 00:00:00 +0000
    def beginning_of_year
      change(month: 1).beginning_of_month
    end
    alias :at_beginning_of_year :beginning_of_year

    # Returns a new date/time representing the given day in the next week.
    #
    #   today = Date.today # => Thu, 07 May 2015
    #   today.next_week    # => Mon, 11 May 2015
    #
    # The +given_day_in_next_week+ defaults to the beginning of the week
    # which is determined by +Date.beginning_of_week+ or +config.beginning_of_week+
    # when set.
    #
    #   today = Date.today       # => Thu, 07 May 2015
    #   today.next_week(:friday) # => Fri, 15 May 2015
    #
    # +DateTime+ objects have their time set to 0:00 unless +same_time+ is true.
    #
    #   now = DateTime.current # => Thu, 07 May 2015 13:31:16 +0000
    #   now.next_week      # => Mon, 11 May 2015 00:00:00 +0000
    def next_week(given_day_in_next_week = Date.beginning_of_week, same_time: false)
      result = first_hour(weeks_since(1).beginning_of_week.days_since(days_span(given_day_in_next_week)))
      same_time ? copy_time_to(result) : result
    end

    # Returns a new date/time representing the next weekday.
    def next_weekday
      if next_day.on_weekend?
        next_week(:monday, same_time: true)
      else
        next_day
      end
    end

    # Short-hand for months_since(3)
    def next_quarter
      months_since(3)
    end

    # Returns a new date/time representing the given day in the previous week.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # DateTime objects have their time set to 0:00 unless +same_time+ is true.
    def prev_week(start_day = Date.beginning_of_week, same_time: false)
      result = first_hour(weeks_ago(1).beginning_of_week.days_since(days_span(start_day)))
      same_time ? copy_time_to(result) : result
    end
    alias_method :last_week, :prev_week

    # Returns a new date/time representing the previous weekday.
    def prev_weekday
      if prev_day.on_weekend?
        copy_time_to(beginning_of_week(:friday))
      else
        prev_day
      end
    end
    alias_method :last_weekday, :prev_weekday

    # Short-hand for months_ago(1).
    def last_month
      months_ago(1)
    end

    # Short-hand for months_ago(3).
    def prev_quarter
      months_ago(3)
    end
    alias_method :last_quarter, :prev_quarter

    # Short-hand for years_ago(1).
    def last_year
      years_ago(1)
    end

    # Returns the number of days to the start of the week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    def days_to_week_start(start_day = Date.beginning_of_week)
      start_day_number = DAYS_INTO_WEEK.fetch(start_day)
      (wday - start_day_number) % 7
    end

    # Returns a new date/time representing the start of this week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # +DateTime+ objects have their time set to 0:00.
    def beginning_of_week(start_day = Date.beginning_of_week)
      result = days_ago(days_to_week_start(start_day))
      acts_like?(:time) ? result.midnight : result
    end
    alias :at_beginning_of_week :beginning_of_week

    # Returns Monday of this week assuming that week starts on Monday.
    # +DateTime+ objects have their time set to 0:00.
    def monday
      beginning_of_week(:monday)
    end

    # Returns a new date/time representing the end of this week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # DateTime objects have their time set to 23:59:59.
    def end_of_week(start_day = Date.beginning_of_week)
      last_hour(days_since(6 - days_to_week_start(start_day)))
    end
    alias :at_end_of_week :end_of_week

    # Returns Sunday of this week assuming that week starts on Monday.
    # +DateTime+ objects have their time set to 23:59:59.
    def sunday
      end_of_week(:monday)
    end

    # Returns a new date/time representing the end of the month.
    # DateTime objects will have a time set to 23:59:59.
    def end_of_month
      last_day = ::Time.days_in_month(month, year)
      last_hour(days_since(last_day - day))
    end
    alias :at_end_of_month :end_of_month

    # Returns a new date/time representing the end of the year.
    # DateTime objects will have a time set to 23:59:59.
    def end_of_year
      change(month: 12).end_of_month
    end
    alias :at_end_of_year :end_of_year

    # Returns a Range representing the whole day of the current date/time.
    def all_day
      beginning_of_day..end_of_day
    end

    # Returns a Range representing the whole week of the current date/time.
    # Week starts on start_day, default is <tt>Date.beginning_of_week</tt> or <tt>config.beginning_of_week</tt> when set.
    def all_week(start_day = Date.beginning_of_week)
      beginning_of_week(start_day)..end_of_week(start_day)
    end

    # Returns a Range representing the whole month of the current date/time.
    def all_month
      beginning_of_month..end_of_month
    end

    # Returns a Range representing the whole quarter of the current date/time.
    def all_quarter
      beginning_of_quarter..end_of_quarter
    end

    # Returns a Range representing the whole year of the current date/time.
    def all_year
      beginning_of_year..end_of_year
    end

    # Returns a new date/time representing the next occurrence of the specified day of week.
    #
    #   today = Date.today               # => Thu, 14 Dec 2017
    #   today.next_occurring(:monday)    # => Mon, 18 Dec 2017
    #   today.next_occurring(:thursday)  # => Thu, 21 Dec 2017
    def next_occurring(day_of_week)
      from_now = DAYS_INTO_WEEK.fetch(day_of_week) - wday
      from_now += 7 unless from_now > 0
      advance(days: from_now)
    end

    # Returns a new date/time representing the previous occurrence of the specified day of week.
    #
    #   today = Date.today               # => Thu, 14 Dec 2017
    #   today.prev_occurring(:monday)    # => Mon, 11 Dec 2017
    #   today.prev_occurring(:thursday)  # => Thu, 07 Dec 2017
    def prev_occurring(day_of_week)
      ago = wday - DAYS_INTO_WEEK.fetch(day_of_week)
      ago += 7 unless ago > 0
      advance(days: -ago)
    end

    private
      def first_hour(date_or_time)
        date_or_time.acts_like?(:time) ? date_or_time.beginning_of_day : date_or_time
      end

      def last_hour(date_or_time)
        date_or_time.acts_like?(:time) ? date_or_time.end_of_day : date_or_time
      end

      def days_span(day)
        (DAYS_INTO_WEEK.fetch(day) - DAYS_INTO_WEEK.fetch(Date.beginning_of_week)) % 7
      end

      def copy_time_to(other)
# frozen_string_literal: true

module DateAndTime
  module Zones
    # Returns the simultaneous time in <tt>Time.zone</tt> if a zone is given or
    # if Time.zone_default is set. Otherwise, it returns the current time.
    #
    #   Time.zone = 'Hawaii'        # => 'Hawaii'
    #   Time.utc(2000).in_time_zone # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #   Date.new(2000).in_time_zone # => Sat, 01 Jan 2000 00:00:00 HST -10:00
    #
    # This method is similar to Time#localtime, except that it uses <tt>Time.zone</tt> as the local zone
    # instead of the operating system's time zone.
    #
    # You can also pass in a TimeZone instance or string that identifies a TimeZone as an argument,
    # and the conversion will be based on that zone instead of <tt>Time.zone</tt>.
    #
    #   Time.utc(2000).in_time_zone('Alaska') # => Fri, 31 Dec 1999 15:00:00 AKST -09:00
    #   Date.new(2000).in_time_zone('Alaska') # => Sat, 01 Jan 2000 00:00:00 AKST -09:00
    def in_time_zone(zone = ::Time.zone)
      time_zone = ::Time.find_zone! zone
      time = acts_like?(:time) ? self : nil

      if time_zone
        time_with_zone(time, time_zone)
      else
        time || to_time
      end
    end

    private
      def time_with_zone(time, zone)
        if time
          ActiveSupport::TimeWithZone.new(time.utc? ? time : time.getutc, zone)
        else
# frozen_string_literal: true

require "active_support/core_ext/module/attribute_accessors"

module DateAndTime
  module Compatibility
    # If true, +to_time+ preserves the timezone offset of receiver.
    #
    # NOTE: With Ruby 2.4+ the default for +to_time+ changed from
    # converting to the local system time, to preserving the offset
    # of the receiver. For backwards compatibility we're overriding
    # this behavior, but new apps will have an initializer that sets
    # this to true, because the new behavior is preferred.
    mattr_accessor :preserve_timezone, instance_writer: false, default: false

    # Change the output of <tt>ActiveSupport::TimeZone.utc_to_local</tt>.
    #
    # When `true`, it returns local times with an UTC offset, with `false` local
    # times are returned as UTC.
    #
    #   # Given this zone:
    #   zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    #
    #   # With `utc_to_local_returns_utc_offset_times = false`, local time is converted to UTC:
    #   zone.utc_to_local(Time.utc(2000, 1)) # => 1999-12-31 19:00:00 UTC
    #
    #   # With `utc_to_local_returns_utc_offset_times = true`, local time is returned with UTC offset:
    #   zone.utc_to_local(Time.utc(2000, 1)) # => 1999-12-31 19:00:00 -0500
    mattr_accessor :utc_to_local_returns_utc_offset_times, instance_writer: false, default: false
  end
# frozen_string_literal: true

require "active_support/core_ext/string/filters"
require "active_support/inflector"

class Module
  # Returns the name of the module containing this one.
  #
  #   M::N.module_parent_name # => "M"
  def module_parent_name
    if defined?(@parent_name)
      @parent_name
    else
      parent_name = name =~ /::[^:]+\z/ ? -$` : nil
      @parent_name = parent_name unless frozen?
      parent_name
    end
  end

  # Returns the module which contains this one according to its name.
  #
  #   module M
  #     module N
  #     end
  #   end
  #   X = M::N
  #
  #   M::N.module_parent # => M
  #   X.module_parent    # => M
  #
  # The parent of top-level and anonymous modules is Object.
  #
  #   M.module_parent          # => Object
  #   Module.new.module_parent # => Object
  def module_parent
    module_parent_name ? ActiveSupport::Inflector.constantize(module_parent_name) : Object
  end

  # Returns all the parents of this module according to its name, ordered from
  # nested outwards. The receiver is not contained within the result.
  #
  #   module M
  #     module N
  #     end
  #   end
  #   X = M::N
  #
  #   M.module_parents    # => [Object]
  #   M::N.module_parents # => [M, Object]
  #   X.module_parents    # => [M, Object]
  def module_parents
    parents = []
    if module_parent_name
      parts = module_parent_name.split("::")
      until parts.empty?
        parents << ActiveSupport::Inflector.constantize(parts * "::")
        parts.pop
      end
    end
    parents << Object unless parents.include? Object
# frozen_string_literal: true

class Module
  # A module may or may not have a name.
  #
  #   module M; end
  #   M.name # => "M"
  #
  #   m = Module.new
  #   m.name # => nil
  #
  # +anonymous?+ method returns true if module does not have a name, false otherwise:
  #
  #   Module.new.anonymous? # => true
  #
  #   module M; end
  #   M.anonymous?          # => false
  #
  # A module gets a name when it is first assigned to a constant. Either
  # via the +module+ or +class+ keyword or by an explicit assignment:
  #
  #   m = Module.new # creates an anonymous module
  #   m.anonymous?   # => true
  #   M = m          # m gets a name here as a side-effect
  #   m.name         # => "M"
# frozen_string_literal: true

require "active_support/core_ext/module/redefine_method"

class Module
  # Removes the named method, if it exists.
  def remove_possible_method(method)
    if method_defined?(method) || private_method_defined?(method)
      undef_method(method)
    end
  end

  # Removes the named singleton method, if it exists.
  def remove_possible_singleton_method(method)
    singleton_class.remove_possible_method(method)
# frozen_string_literal: true

class Module
  #   deprecate :foo
  #   deprecate bar: 'message'
  #   deprecate :foo, :bar, baz: 'warning!', qux: 'gone!'
  #
  # You can also use custom deprecator instance:
  #
  #   deprecate :foo, deprecator: MyLib::Deprecator.new
  #   deprecate :foo, bar: "warning!", deprecator: MyLib::Deprecator.new
  #
  # \Custom deprecators must respond to <tt>deprecation_warning(deprecated_method_name, message, caller_backtrace)</tt>
  # method where you can implement your custom warning behavior.
  #
  #   class MyLib::Deprecator
  #     def deprecation_warning(deprecated_method_name, message, caller_backtrace = nil)
  #       message = "#{deprecated_method_name} is deprecated and will be removed from MyLibrary | #{message}"
  #       Kernel.warn message
  #     end
# frozen_string_literal: true

require "set"

class Module
  # Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+
  # option is not used.
  class DelegationError < NoMethodError; end

  RUBY_RESERVED_KEYWORDS = %w(alias and BEGIN begin break case class def defined? do
  else elsif END end ensure false for if in module next nil not or redo rescue retry
  return self super then true undef unless until when while yield)
  DELEGATION_RESERVED_KEYWORDS = %w(_ arg args block)
  DELEGATION_RESERVED_METHOD_NAMES = Set.new(
    RUBY_RESERVED_KEYWORDS + DELEGATION_RESERVED_KEYWORDS
  ).freeze

  # Provides a +delegate+ class method to easily expose contained objects'
  # public methods as your own.
  #
  # ==== Options
  # * <tt>:to</tt> - Specifies the target object name as a symbol or string
  # * <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix
  # * <tt>:allow_nil</tt> - If set to true, prevents a +Module::DelegationError+
  #   from being raised
  # * <tt>:private</tt> - If set to true, changes method visibility to private
  #
  # The macro receives one or more method names (specified as symbols or
  # strings) and the name of the target object via the <tt>:to</tt> option
  # (also a symbol or string).
  #
  # Delegation is particularly useful with Active Record associations:
  #
  #   class Greeter < ActiveRecord::Base
  #     def hello
  #       'hello'
  #     end
  #
  #     def goodbye
  #       'goodbye'
  #     end
  #   end
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, to: :greeter
  #   end
  #
  #   Foo.new.hello   # => "hello"
  #   Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>
  #
  # Multiple delegates to the same target are allowed:
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, :goodbye, to: :greeter
  #   end
  #
  #   Foo.new.goodbye # => "goodbye"
  #
  # Methods can be delegated to instance variables, class variables, or constants
  # by providing them as a symbols:
  #
  #   class Foo
  #     CONSTANT_ARRAY = [0,1,2,3]
  #     @@class_array  = [4,5,6,7]
  #
  #     def initialize
  #       @instance_array = [8,9,10,11]
  #     end
  #     delegate :sum, to: :CONSTANT_ARRAY
  #     delegate :min, to: :@@class_array
  #     delegate :max, to: :@instance_array
  #   end
  #
  #   Foo.new.sum # => 6
  #   Foo.new.min # => 4
  #   Foo.new.max # => 11
  #
  # It's also possible to delegate a method to the class by using +:class+:
  #
  #   class Foo
  #     def self.hello
  #       "world"
  #     end
  #
  #     delegate :hello, to: :class
  #   end
  #
  #   Foo.new.hello # => "world"
  #
  # Delegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value
  # is <tt>true</tt>, the delegate methods are prefixed with the name of the object being
  # delegated to.
  #
  #   Person = Struct.new(:name, :address)
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: true
  #   end
  #
  #   john_doe = Person.new('John Doe', 'Vimmersvej 13')
  #   invoice = Invoice.new(john_doe)
  #   invoice.client_name    # => "John Doe"
  #   invoice.client_address # => "Vimmersvej 13"
  #
  # It is also possible to supply a custom prefix.
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: :customer
  #   end
  #
  #   invoice = Invoice.new(john_doe)
  #   invoice.customer_name    # => 'John Doe'
  #   invoice.customer_address # => 'Vimmersvej 13'
  #
  # The delegated methods are public by default.
  # Pass <tt>private: true</tt> to change that.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :first_name, to: :profile
  #     delegate :date_of_birth, to: :profile, private: true
  #
  #     def age
  #       Date.today.year - date_of_birth.year
  #     end
  #   end
  #
  #   User.new.first_name # => "Tomas"
  #   User.new.date_of_birth # => NoMethodError: private method `date_of_birth' called for #<User:0x00000008221340>
  #   User.new.age # => 2
  #
  # If the target is +nil+ and does not respond to the delegated method a
  # +Module::DelegationError+ is raised. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile
  #   end
  #
  #   User.new.age
  #   # => Module::DelegationError: User#age delegated to profile.age, but profile is nil
  #
  # But if not having a profile yet is fine and should not be an error
  # condition:
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile, allow_nil: true
  #   end
  #
  #   User.new.age # nil
  #
  # Note that if the target is not +nil+ then the call is attempted regardless of the
  # <tt>:allow_nil</tt> option, and thus an exception is still raised if said object
  # does not respond to the method:
  #
  #   class Foo
  #     def initialize(bar)
  #       @bar = bar
  #     end
  #
  #     delegate :name, to: :@bar, allow_nil: true
  #   end
  #
  #   Foo.new("Bar").name # raises NoMethodError: undefined method `name'
  #
  # The target method must be public, otherwise it will raise +NoMethodError+.
  def delegate(*methods, to: nil, prefix: nil, allow_nil: nil, private: nil)
    unless to
      raise ArgumentError, "Delegation needs a target. Supply a keyword argument 'to' (e.g. delegate :hello, to: :greeter)."
    end

    if prefix == true && /^[^a-z_]/.match?(to)
      raise ArgumentError, "Can only automatically set the delegation prefix when delegating to a method."
    end

    method_prefix = \
      if prefix
        "#{prefix == true ? to : prefix}_"
      else
        ""
      end

    location = caller_locations(1, 1).first
    file, line = location.path, location.lineno

    to = to.to_s
    to = "self.#{to}" if DELEGATION_RESERVED_METHOD_NAMES.include?(to)

    method_def = []
    method_names = []

    methods.map do |method|
      method_name = prefix ? "#{method_prefix}#{method}" : method
      method_names << method_name.to_sym

      # Attribute writer methods only accept one argument. Makes sure []=
      # methods still accept two arguments.
      definition = /[^\]]=\z/.match?(method) ? "arg" : "..."

      # The following generated method calls the target exactly once, storing
      # the returned value in a dummy variable.
      #
      # Reason is twofold: On one hand doing less calls is in general better.
      # On the other hand it could be that the target has side-effects,
      # whereas conceptually, from the user point of view, the delegator should
      # be doing one call.
      if allow_nil
        method = method.to_s

        method_def <<
          "def #{method_name}(#{definition})" <<
          "  _ = #{to}" <<
          "  if !_.nil? || nil.respond_to?(:#{method})" <<
          "    _.#{method}(#{definition})" <<
          "  end" <<
          "end"
      else
        method = method.to_s
        method_name = method_name.to_s

        method_def <<
          "def #{method_name}(#{definition})" <<
          "  _ = #{to}" <<
          "  _.#{method}(#{definition})" <<
          "rescue NoMethodError => e" <<
          "  if _.nil? && e.name == :#{method}" <<
          %(   raise DelegationError, "#{self}##{method_name} delegated to #{to}.#{method}, but #{to} is nil: \#{self.inspect}") <<
          "  else" <<
          "    raise" <<
          "  end" <<
          "end"
      end
    end
    module_eval(method_def.join(";"), file, line)
    private(*method_names) if private
    method_names
  end

  # When building decorators, a common pattern may emerge:
  #
  #   class Partition
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #
  #     private
  #       def respond_to_missing?(name, include_private = false)
  #         @event.respond_to?(name, include_private)
  #       end
  #
  #       def method_missing(method, *args, &block)
  #         @event.send(method, *args, &block)
  #       end
  #   end
  #
  # With <tt>Module#delegate_missing_to</tt>, the above is condensed to:
  #
  #   class Partition
  #     delegate_missing_to :@event
  #
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #   end
  #
  # The target can be anything callable within the object, e.g. instance
  # variables, methods, constants, etc.
  #
  # The delegated method must be public on the target, otherwise it will
  # raise +DelegationError+. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  # The <tt>marshal_dump</tt> and <tt>_dump</tt> methods are exempt from
  # delegation due to possible interference when calling
  # <tt>Marshal.dump(object)</tt>, should the delegation target method
  # of <tt>object</tt> add or remove instance variables.
  def delegate_missing_to(target, allow_nil: nil)
    target = target.to_s
    target = "self.#{target}" if DELEGATION_RESERVED_METHOD_NAMES.include?(target)

    module_eval <<-RUBY, __FILE__, __LINE__ + 1
      def respond_to_missing?(name, include_private = false)
        # It may look like an oversight, but we deliberately do not pass
        # +include_private+, because they do not get delegated.

        return false if name == :marshal_dump || name == :_dump
        #{target}.respond_to?(name) || super
      end

      def method_missing(method, *args, &block)
        if #{target}.respond_to?(method)
          #{target}.public_send(method, *args, &block)
        else
          begin
            super
          rescue NoMethodError
            if #{target}.nil?
              if #{allow_nil == true}
                nil
              else
                raise DelegationError, "\#{method} delegated to #{target}, but #{target} is nil"
              end
            else
              raise
            end
          end
        end
      end
# frozen_string_literal: true

class Module
  # Marks the named method as intended to be redefined, if it exists.
  # Suppresses the Ruby method redefinition warning. Prefer
  # #redefine_method where possible.
  def silence_redefinition_of_method(method)
    if method_defined?(method) || private_method_defined?(method)
      # This suppresses the "method redefined" warning; the self-alias
      # looks odd, but means we don't need to generate a unique name
      alias_method method, method
    end
  end

  # Replaces the existing method definition, if there is one, with the passed
  # block as its body.
  def redefine_method(method, &block)
    visibility = method_visibility(method)
    silence_redefinition_of_method(method)
    define_method(method, &block)
    send(visibility, method)
  end

  # Replaces the existing singleton method definition, if there is one, with
  # the passed block as its body.
  def redefine_singleton_method(method, &block)
    singleton_class.redefine_method(method, &block)
  end

  def method_visibility(method) # :nodoc:
    case
    when private_method_defined?(method)
      :private
    when protected_method_defined?(method)
      :protected
# frozen_string_literal: true

# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes.
class Module
  # Defines a class attribute and creates a class and instance reader methods.
  # The underlying class variable is set to +nil+, if it is not previously
  # defined. All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_reader :hair_colors
  #   end
  #
  #   HairColors.hair_colors # => nil
  #   HairColors.class_variable_set("@@hair_colors", [:brown, :black])
  #   HairColors.hair_colors # => [:brown, :black]
  #
  # The attribute name must be a valid method name in Ruby.
  #
  #   module Foo
  #     mattr_reader :"1_Badname"
  #   end
  #   # => NameError: invalid attribute name: 1_Badname
  #
  # To omit the instance reader method, pass
  # <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, default: [:brown, :black, :blonde, :red]
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  def mattr_reader(*syms, instance_reader: true, instance_accessor: true, default: nil, location: nil)
    raise TypeError, "module attributes should be defined directly on class, not singleton" if singleton_class?
    location ||= caller_locations(1, 1).first

    definition = []
    syms.each do |sym|
      raise NameError.new("invalid attribute name: #{sym}") unless /\A[_A-Za-z]\w*\z/.match?(sym)

      definition << "def self.#{sym}; @@#{sym}; end"

      if instance_reader && instance_accessor
        definition << "def #{sym}; @@#{sym}; end"
      end

      sym_default_value = (block_given? && default.nil?) ? yield : default
      class_variable_set("@@#{sym}", sym_default_value) unless sym_default_value.nil? && class_variable_defined?("@@#{sym}")
    end

    module_eval(definition.join(";"), location.path, location.lineno)
  end
  alias :cattr_reader :mattr_reader

  # Defines a class attribute and creates a class and instance writer methods to
  # allow assignment to the attribute. All class and instance methods created
  # will be public, even if this method is called with a private or protected
  # access modifier.
  #
  #   module HairColors
  #     mattr_writer :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black]
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black]
  #   Person.new.hair_colors = [:blonde, :red]
  #   HairColors.class_variable_get("@@hair_colors") # => [:blonde, :red]
  #
  # To omit the instance writer method, pass
  # <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, instance_writer: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:blonde, :red] # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, default: [:brown, :black, :blonde, :red]
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  def mattr_writer(*syms, instance_writer: true, instance_accessor: true, default: nil, location: nil)
    raise TypeError, "module attributes should be defined directly on class, not singleton" if singleton_class?
    location ||= caller_locations(1, 1).first

    definition = []
    syms.each do |sym|
      raise NameError.new("invalid attribute name: #{sym}") unless /\A[_A-Za-z]\w*\z/.match?(sym)
      definition << "def self.#{sym}=(val); @@#{sym} = val; end"

      if instance_writer && instance_accessor
        definition << "def #{sym}=(val); @@#{sym} = val; end"
      end

      sym_default_value = (block_given? && default.nil?) ? yield : default
      class_variable_set("@@#{sym}", sym_default_value) unless sym_default_value.nil? && class_variable_defined?("@@#{sym}")
    end

    module_eval(definition.join(";"), location.path, location.lineno)
  end
  alias :cattr_writer :mattr_writer

  # Defines both class and instance accessors for class attributes.
  # All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black, :blonde, :red]
  #   HairColors.hair_colors # => [:brown, :black, :blonde, :red]
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  #
  # If a subclass changes the value then that would also change the value for
  # parent class. Similarly if parent class changes the value then that would
  # change the value of subclasses too.
  #
  #   class Citizen < Person
  #   end
  #
  #   Citizen.new.hair_colors << :blue
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red, :blue]
  #
  # To omit the instance writer method, pass <tt>instance_writer: false</tt>.
  # To omit the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_writer: false, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_accessor: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, default: [:brown, :black, :blonde, :red]
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  def mattr_accessor(*syms, instance_reader: true, instance_writer: true, instance_accessor: true, default: nil, &blk)
    location = caller_locations(1, 1).first
    mattr_reader(*syms, instance_reader: instance_reader, instance_accessor: instance_accessor, default: default, location: location, &blk)
    mattr_writer(*syms, instance_writer: instance_writer, instance_accessor: instance_accessor, default: default, location: location)
  end
  alias :cattr_accessor :mattr_accessor
# frozen_string_literal: true

require "active_support/concern"

class Module
  # = Bite-sized separation of concerns
  #
  # We often find ourselves with a medium-sized chunk of behavior that we'd
  # like to extract, but only mix in to a single class.
  #
  # Extracting a plain old Ruby object to encapsulate it and collaborate or
  # delegate to the original object is often a good choice, but when there's
  # no additional state to encapsulate or we're making DSL-style declarations
  # about the parent class, introducing new collaborators can obfuscate rather
  # than simplify.
  #
  # The typical route is to just dump everything in a monolithic class, perhaps
  # with a comment, as a least-bad alternative. Using modules in separate files
  # means tedious sifting to get a big-picture view.
  #
  # = Dissatisfying ways to separate small concerns
  #
  # == Using comments:
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     ## Event tracking
  #     has_many :events
  #
  #     before_create :track_creation
  #
  #     private
  #       def track_creation
  #         # ...
  #       end
  #   end
  #
  # == With an inline module:
  #
  # Noisy syntax.
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     module EventTracking
  #       extend ActiveSupport::Concern
  #
  #       included do
  #         has_many :events
  #         before_create :track_creation
  #       end
  #
  #       private
  #         def track_creation
  #           # ...
  #         end
  #     end
  #     include EventTracking
  #   end
  #
  # == Mix-in noise exiled to its own file:
  #
  # Once our chunk of behavior starts pushing the scroll-to-understand-it
  # boundary, we give in and move it to a separate file. At this size, the
  # increased overhead can be a reasonable tradeoff even if it reduces our
  # at-a-glance perception of how things work.
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     include TodoEventTracking
  #   end
  #
  # = Introducing Module#concerning
  #
  # By quieting the mix-in noise, we arrive at a natural, low-ceremony way to
  # separate bite-sized concerns.
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     concerning :EventTracking do
  #       included do
  #         has_many :events
  #         before_create :track_creation
  #       end
  #
  #       private
  #         def track_creation
  #           # ...
  #         end
  #     end
  #   end
  #
  #   Todo.ancestors
  #   # => [Todo, Todo::EventTracking, ApplicationRecord, Object]
  #
  # This small step has some wonderful ripple effects. We can
  # * grok the behavior of our class in one glance,
  # * clean up monolithic junk-drawer classes by separating their concerns, and
  # * stop leaning on protected/private for crude "this is internal stuff" modularity.
  #
  # === Prepending concerning
  #
  # <tt>concerning</tt> supports a <tt>prepend: true</tt> argument which will <tt>prepend</tt> the
  # concern instead of using <tt>include</tt> for it.
  module Concerning
    # Define a new concern and mix it in.
    def concerning(topic, prepend: false, &block)
      method = prepend ? :prepend : :include
      __send__(method, concern(topic, &block))
    end

    # A low-cruft shortcut to define a concern.
    #
    #   concern :EventTracking do
    #     ...
    #   end
    #
    # is equivalent to
    #
    #   module EventTracking
    #     extend ActiveSupport::Concern
    #
    #     ...
    #   end
    def concern(topic, &module_definition)
      const_set topic, Module.new {
        extend ::ActiveSupport::Concern
        module_eval(&module_definition)
# frozen_string_literal: true

class Module
  # Allows you to make aliases for attributes, which includes
  # getter, setter, and a predicate.
  #
  #   class Content < ActiveRecord::Base
  #     # has a title attribute
  #   end
  #
  #   class Email < Content
  #     alias_attribute :subject, :title
  #   end
  #
  #   e = Email.find(1)
  #   e.title    # => "Superstars"
  #   e.subject  # => "Superstars"
  #   e.subject? # => true
  #   e.subject = "Megastars"
  #   e.title    # => "Megastars"
  def alias_attribute(new_name, old_name)
    # The following reader methods use an explicit `self` receiver in order to
    # support aliases that start with an uppercase letter. Otherwise, they would
    # be resolved as constants instead.
    module_eval <<-STR, __FILE__, __LINE__ + 1
      def #{new_name}; self.#{old_name}; end          # def subject; self.title; end
      def #{new_name}?; self.#{old_name}?; end        # def subject?; self.title?; end
      def #{new_name}=(v); self.#{old_name} = v; end  # def subject=(v); self.title = v; end
    STR
  end
# frozen_string_literal: true

class Module
  # Declares an attribute reader backed by an internally-named instance variable.
  def attr_internal_reader(*attrs)
    attrs.each { |attr_name| attr_internal_define(attr_name, :reader) }
  end

  # Declares an attribute writer backed by an internally-named instance variable.
  def attr_internal_writer(*attrs)
    attrs.each { |attr_name| attr_internal_define(attr_name, :writer) }
  end

  # Declares an attribute reader and writer backed by an internally-named instance
  # variable.
  def attr_internal_accessor(*attrs)
    attr_internal_reader(*attrs)
    attr_internal_writer(*attrs)
  end
  alias_method :attr_internal, :attr_internal_accessor

  class << self; attr_accessor :attr_internal_naming_format end
  self.attr_internal_naming_format = "@_%s"

  private
    def attr_internal_ivar_name(attr)
      Module.attr_internal_naming_format % attr
    end

    def attr_internal_define(attr_name, type)
      internal_name = attr_internal_ivar_name(attr_name).delete_prefix("@")
      # use native attr_* methods as they are faster on some Ruby implementations
      public_send("attr_#{type}", internal_name)
      attr_name, internal_name = "#{attr_name}=", "#{internal_name}=" if type == :writer
      alias_method attr_name, internal_name
# frozen_string_literal: true

# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes, but does so on a per-thread basis.
#
# So the values are scoped within the Thread.current space under the class name
# of the module.
class Module
  # Defines a per-thread class attribute and creates class and instance reader methods.
  # The underlying per-thread class variable is set to +nil+, if it is not previously defined.
  #
  #   module Current
  #     thread_mattr_reader :user
  #   end
  #
  #   Current.user # => nil
  #   Thread.current[:attr_Current_user] = "DHH"
  #   Current.user # => "DHH"
  #
  # The attribute name must be a valid method name in Ruby.
  #
  #   module Foo
  #     thread_mattr_reader :"1_Badname"
  #   end
  #   # => NameError: invalid attribute name: 1_Badname
  #
  # To omit the instance reader method, pass
  # <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   class Current
  #     thread_mattr_reader :user, instance_reader: false
  #   end
  #
  #   Current.new.user # => NoMethodError
  def thread_mattr_reader(*syms, instance_reader: true, instance_accessor: true, default: nil) # :nodoc:
    syms.each do |sym|
      raise NameError.new("invalid attribute name: #{sym}") unless /^[_A-Za-z]\w*$/.match?(sym)

      # The following generated method concatenates `name` because we want it
      # to work with inheritance via polymorphism.
      class_eval(<<-EOS, __FILE__, __LINE__ + 1)
        def self.#{sym}
          Thread.current["attr_" + name + "_#{sym}"]
        end
      EOS

      if instance_reader && instance_accessor
        class_eval(<<-EOS, __FILE__, __LINE__ + 1)
          def #{sym}
            self.class.#{sym}
          end
        EOS
      end

      Thread.current["attr_" + name + "_#{sym}"] = default unless default.nil?
    end
  end
  alias :thread_cattr_reader :thread_mattr_reader

  # Defines a per-thread class attribute and creates a class and instance writer methods to
  # allow assignment to the attribute.
  #
  #   module Current
  #     thread_mattr_writer :user
  #   end
  #
  #   Current.user = "DHH"
  #   Thread.current[:attr_Current_user] # => "DHH"
  #
  # To omit the instance writer method, pass
  # <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   class Current
  #     thread_mattr_writer :user, instance_writer: false
  #   end
  #
  #   Current.new.user = "DHH" # => NoMethodError
  def thread_mattr_writer(*syms, instance_writer: true, instance_accessor: true, default: nil) # :nodoc:
    syms.each do |sym|
      raise NameError.new("invalid attribute name: #{sym}") unless /^[_A-Za-z]\w*$/.match?(sym)

      # The following generated method concatenates `name` because we want it
      # to work with inheritance via polymorphism.
      class_eval(<<-EOS, __FILE__, __LINE__ + 1)
        def self.#{sym}=(obj)
          Thread.current["attr_" + name + "_#{sym}"] = obj
        end
      EOS

      if instance_writer && instance_accessor
        class_eval(<<-EOS, __FILE__, __LINE__ + 1)
          def #{sym}=(obj)
            self.class.#{sym} = obj
          end
        EOS
      end

      public_send("#{sym}=", default) unless default.nil?
    end
  end
  alias :thread_cattr_writer :thread_mattr_writer

  # Defines both class and instance accessors for class attributes.
  #
  #   class Account
  #     thread_mattr_accessor :user
  #   end
  #
  #   Account.user = "DHH"
  #   Account.user     # => "DHH"
  #   Account.new.user # => "DHH"
  #
  # If a subclass changes the value, the parent class' value is not changed.
  # Similarly, if the parent class changes the value, the value of subclasses
  # is not changed.
  #
  #   class Customer < Account
  #   end
  #
  #   Customer.user = "Rafael"
  #   Customer.user # => "Rafael"
  #   Account.user  # => "DHH"
  #
  # To omit the instance writer method, pass <tt>instance_writer: false</tt>.
  # To omit the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   class Current
  #     thread_mattr_accessor :user, instance_writer: false, instance_reader: false
  #   end
  #
  #   Current.new.user = "DHH"  # => NoMethodError
  #   Current.new.user          # => NoMethodError
  #
  # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.
  #
  #   class Current
  #     thread_mattr_accessor :user, instance_accessor: false
  #   end
  #
  #   Current.new.user = "DHH"  # => NoMethodError
  #   Current.new.user          # => NoMethodError
  def thread_mattr_accessor(*syms, instance_reader: true, instance_writer: true, instance_accessor: true, default: nil)
    thread_mattr_reader(*syms, instance_reader: instance_reader, instance_accessor: instance_accessor, default: default)
    thread_mattr_writer(*syms, instance_writer: instance_writer, instance_accessor: instance_accessor)
# frozen_string_literal: true

require "securerandom"

module SecureRandom
  BASE58_ALPHABET = ("0".."9").to_a + ("A".."Z").to_a + ("a".."z").to_a - ["0", "O", "I", "l"]
  BASE36_ALPHABET = ("0".."9").to_a + ("a".."z").to_a

  # SecureRandom.base58 generates a random base58 string.
  #
  # The argument _n_ specifies the length of the random string to be generated.
  #
  # If _n_ is not specified or is +nil+, 16 is assumed. It may be larger in the future.
  #
  # The result may contain alphanumeric characters except 0, O, I and l.
  #
  #   p SecureRandom.base58 # => "4kUgL2pdQMSCQtjE"
  #   p SecureRandom.base58(24) # => "77TMHrHJFvFDwodq8w7Ev2m7"
  def self.base58(n = 16)
    SecureRandom.random_bytes(n).unpack("C*").map do |byte|
      idx = byte % 64
      idx = SecureRandom.random_number(58) if idx >= 58
      BASE58_ALPHABET[idx]
    end.join
  end

  # SecureRandom.base36 generates a random base36 string in lowercase.
  #
  # The argument _n_ specifies the length of the random string to be generated.
  #
  # If _n_ is not specified or is +nil+, 16 is assumed. It may be larger in the future.
  # This method can be used over +base58+ if a deterministic case key is necessary.
  #
  # The result will contain alphanumeric characters in lowercase.
  #
  #   p SecureRandom.base36 # => "4kugl2pdqmscqtje"
  #   p SecureRandom.base36(24) # => "77tmhrhjfvfdwodq8w7ev2m7"
  def self.base36(n = 16)
    SecureRandom.random_bytes(n).unpack("C*").map do |byte|
      idx = byte % 64
# frozen_string_literal: true

require "uri"

module URI
  class << self
    def parser
      ActiveSupport::Deprecation.warn(<<-MSG.squish)
        URI.parser is deprecated and will be removed in Rails 7.0.
        Use `URI::DEFAULT_PARSER` instead.
# frozen_string_literal: true

# cattr_* became mattr_* aliases in 7dfbd91b0780fbd6a1dd9bfbc176e10894871d2d,
# but we keep this around for libraries that directly require it knowing they
# want cattr_*. No need to deprecate.
# frozen_string_literal: true

class Class
  # Returns an array with all classes that are < than its receiver.
  #
  #   class C; end
  #   C.descendants # => []
  #
  #   class B < C; end
  #   C.descendants # => [B]
  #
  #   class A < B; end
  #   C.descendants # => [B, A]
  #
  #   class D < C; end
  #   C.descendants # => [B, A, D]
  def descendants
    ObjectSpace.each_object(singleton_class).reject do |k|
      k.singleton_class? || k == self
    end
  end

  # Returns an array with the direct children of +self+.
  #
  #   class Foo; end
  #   class Bar < Foo; end
  #   class Baz < Bar; end
  #
  #   Foo.subclasses # => [Bar]
  def subclasses
# frozen_string_literal: true

require "active_support/core_ext/module/redefine_method"

class Class
  # Declare a class-level attribute whose value is inheritable by subclasses.
  # Subclasses can change their own value and it will not impact parent class.
  #
  # ==== Options
  #
  # * <tt>:instance_reader</tt> - Sets the instance reader method (defaults to true).
  # * <tt>:instance_writer</tt> - Sets the instance writer method (defaults to true).
  # * <tt>:instance_accessor</tt> - Sets both instance methods (defaults to true).
  # * <tt>:instance_predicate</tt> - Sets a predicate method (defaults to true).
  # * <tt>:default</tt> - Sets a default value for the attribute (defaults to nil).
  #
  # ==== Examples
  #
  #   class Base
  #     class_attribute :setting
  #   end
  #
  #   class Subclass < Base
  #   end
  #
  #   Base.setting = true
  #   Subclass.setting            # => true
  #   Subclass.setting = false
  #   Subclass.setting            # => false
  #   Base.setting                # => true
  #
  # In the above case as long as Subclass does not assign a value to setting
  # by performing <tt>Subclass.setting = _something_</tt>, <tt>Subclass.setting</tt>
  # would read value assigned to parent class. Once Subclass assigns a value then
  # the value assigned by Subclass would be returned.
  #
  # This matches normal Ruby method inheritance: think of writing an attribute
  # on a subclass as overriding the reader method. However, you need to be aware
  # when using +class_attribute+ with mutable structures as +Array+ or +Hash+.
  # In such cases, you don't want to do changes in place. Instead use setters:
  #
  #   Base.setting = []
  #   Base.setting                # => []
  #   Subclass.setting            # => []
  #
  #   # Appending in child changes both parent and child because it is the same object:
  #   Subclass.setting << :foo
  #   Base.setting               # => [:foo]
  #   Subclass.setting           # => [:foo]
  #
  #   # Use setters to not propagate changes:
  #   Base.setting = []
  #   Subclass.setting += [:foo]
  #   Base.setting               # => []
  #   Subclass.setting           # => [:foo]
  #
  # For convenience, an instance predicate method is defined as well.
  # To skip it, pass <tt>instance_predicate: false</tt>.
  #
  #   Subclass.setting?       # => false
  #
  # Instances may overwrite the class value in the same way:
  #
  #   Base.setting = true
  #   object = Base.new
  #   object.setting          # => true
  #   object.setting = false
  #   object.setting          # => false
  #   Base.setting            # => true
  #
  # To opt out of the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   object.setting          # => NoMethodError
  #   object.setting?         # => NoMethodError
  #
  # To opt out of the instance writer method, pass <tt>instance_writer: false</tt>.
  #
  #   object.setting = false  # => NoMethodError
  #
  # To opt out of both instance methods, pass <tt>instance_accessor: false</tt>.
  #
  # To set a default value for the attribute, pass <tt>default:</tt>, like so:
  #
  #   class_attribute :settings, default: {}
  def class_attribute(*attrs, instance_accessor: true,
    instance_reader: instance_accessor, instance_writer: instance_accessor, instance_predicate: true, default: nil)

    class_methods, methods = [], []
    attrs.each do |name|
      unless name.is_a?(Symbol) || name.is_a?(String)
        raise TypeError, "#{name.inspect} is not a symbol nor a string"
      end

      class_methods << <<~RUBY # In case the method exists and is not public
        silence_redefinition_of_method def #{name}
        end
      RUBY

      methods << <<~RUBY if instance_reader
        silence_redefinition_of_method def #{name}
          defined?(@#{name}) ? @#{name} : self.class.#{name}
        end
      RUBY

      class_methods << <<~RUBY
        silence_redefinition_of_method def #{name}=(value)
          redefine_method(:#{name}) { value } if singleton_class?
          redefine_singleton_method(:#{name}) { value }
          value
        end
      RUBY

      methods << <<~RUBY if instance_writer
        silence_redefinition_of_method(:#{name}=)
        attr_writer :#{name}
      RUBY

      if instance_predicate
        class_methods << "silence_redefinition_of_method def #{name}?; !!self.#{name}; end"
        if instance_reader
          methods << "silence_redefinition_of_method def #{name}?; !!self.#{name}; end"
        end
      end
    end

    location = caller_locations(1, 1).first
    class_eval(["class << self", *class_methods, "end", *methods].join(";").tr("\n", ";"), location.path, location.lineno)

    attrs.each { |name| public_send("#{name}=", default) }
  end
# frozen_string_literal: true

require "active_support/time_with_zone"

module ActiveSupport
  module EachTimeWithZone #:nodoc:
    def each(&block)
      ensure_iteration_allowed
      super
    end

    def step(n = 1, &block)
      ensure_iteration_allowed
      super
    end

    private
      def ensure_iteration_allowed
        raise TypeError, "can't iterate from #{first.class}" if first.is_a?(TimeWithZone)
      end
# frozen_string_literal: true

require "active_support/time_with_zone"
require "active_support/deprecation"

module ActiveSupport
  module IncludeTimeWithZone #:nodoc:
    # Extends the default Range#include? to support ActiveSupport::TimeWithZone.
    #
    #   (1.hour.ago..1.hour.from_now).include?(Time.current) # => true
    #
    def include?(value)
      if self.begin.is_a?(TimeWithZone) || self.end.is_a?(TimeWithZone)
        ActiveSupport::Deprecation.warn(<<-MSG.squish)
          Using `Range#include?` to check the inclusion of a value in
          a date time range is deprecated.
          It is recommended to use `Range#cover?` instead of `Range#include?` to
          check the inclusion of a value in a date time range.
        MSG
        cover?(value)
      else
        super
      end
    end
  end
# frozen_string_literal: true

module ActiveSupport
  module RangeWithFormat
    RANGE_FORMATS = {
      db: -> (start, stop) do
        case start
        when String then "BETWEEN '#{start}' AND '#{stop}'"
        else
          "BETWEEN '#{start.to_s(:db)}' AND '#{stop.to_s(:db)}'"
        end
      end
    }

    # Convert range to a formatted string. See RANGE_FORMATS for predefined formats.
    #
    #   range = (1..100)           # => 1..100
    #
    #   range.to_s                 # => "1..100"
    #   range.to_s(:db)            # => "BETWEEN '1' AND '100'"
    #
    # == Adding your own range formats to to_s
    # You can add your own formats to the Range::RANGE_FORMATS hash.
    # Use the format name as the hash key and a Proc instance.
    #
    #   # config/initializers/range_formats.rb
    #   Range::RANGE_FORMATS[:short] = ->(start, stop) { "Between #{start.to_s(:db)} and #{stop.to_s(:db)}" }
    def to_s(format = :default)
      if formatter = RANGE_FORMATS[format]
        formatter.call(first, last)
      else
        super()
      end
    end

    alias_method :to_default_s, :to_s
    alias_method :to_formatted_s, :to_s
  end
end

# frozen_string_literal: true

class Range
  # Compare two ranges and see if they overlap each other
  #  (1..5).overlaps?(4..6) # => true
# frozen_string_literal: true

module ActiveSupport
  module CompareWithRange
    # Extends the default Range#=== to support range comparisons.
    #  (1..5) === (1..5)  # => true
    #  (1..5) === (2..3)  # => true
    #  (1..5) === (1...6) # => true
    #  (1..5) === (2..6)  # => false
    #
    # The native Range#=== behavior is untouched.
    #  ('a'..'f') === ('c') # => true
    #  (5..9) === (11) # => false
    #
    # The given range must be fully bounded, with both start and end.
    def ===(value)
      if value.is_a?(::Range)
        is_backwards_op = value.exclude_end? ? :>= : :>
        return false if value.begin && value.end && value.begin.public_send(is_backwards_op, value.end)
        # 1...10 includes 1..9 but it does not include 1..10.
        # 1..10 includes 1...11 but it does not include 1...12.
        operator = exclude_end? && !value.exclude_end? ? :< : :<=
        value_max = !exclude_end? && value.exclude_end? ? value.max : value.last
        super(value.first) && (self.end.nil? || value_max.public_send(operator, last))
      else
        super
      end
    end

    # Extends the default Range#include? to support range comparisons.
    #  (1..5).include?(1..5)  # => true
    #  (1..5).include?(2..3)  # => true
    #  (1..5).include?(1...6) # => true
    #  (1..5).include?(2..6)  # => false
    #
    # The native Range#include? behavior is untouched.
    #  ('a'..'f').include?('c') # => true
    #  (5..9).include?(11) # => false
    #
    # The given range must be fully bounded, with both start and end.
    def include?(value)
      if value.is_a?(::Range)
        is_backwards_op = value.exclude_end? ? :>= : :>
        return false if value.begin && value.end && value.begin.public_send(is_backwards_op, value.end)
        # 1...10 includes 1..9 but it does not include 1..10.
        # 1..10 includes 1...11 but it does not include 1...12.
        operator = exclude_end? && !value.exclude_end? ? :< : :<=
        value_max = !exclude_end? && value.exclude_end? ? value.max : value.last
        super(value.first) && (self.end.nil? || value_max.public_send(operator, last))
      else
        super
      end
    end
  end
end
# frozen_string_literal: true

require "active_support/core_ext/date_time/acts_like"
require "active_support/core_ext/date_time/blank"
require "active_support/core_ext/date_time/calculations"
# frozen_string_literal: true

class Hash
  # Merges the caller into +other_hash+. For example,
  #
  #   options = options.reverse_merge(size: 25, velocity: 10)
  #
  # is equivalent to
  #
  #   options = { size: 25, velocity: 10 }.merge(options)
  #
  # This is particularly useful for initializing an options hash
  # with default values.
  def reverse_merge(other_hash)
    other_hash.merge(self)
  end
  alias_method :with_defaults, :reverse_merge

  # Destructive +reverse_merge+.
  def reverse_merge!(other_hash)
# frozen_string_literal: true

class Hash
  # Returns a new hash with all values converted by the block operation.
  # This includes the values from the root hash and from all
  # nested hashes and arrays.
  #
  #  hash = { person: { name: 'Rob', age: '28' } }
  #
  #  hash.deep_transform_values{ |value| value.to_s.upcase }
  #  # => {person: {name: "ROB", age: "28"}}
  def deep_transform_values(&block)
    _deep_transform_values_in_object(self, &block)
  end

  # Destructively converts all values by using the block operation.
  # This includes the values from the root hash and from all
  # nested hashes and arrays.
  def deep_transform_values!(&block)
    _deep_transform_values_in_object!(self, &block)
  end

  private
    # Support methods for deep transforming nested hashes and arrays.
    def _deep_transform_values_in_object(object, &block)
      case object
      when Hash
        object.transform_values { |value| _deep_transform_values_in_object(value, &block) }
      when Array
        object.map { |e| _deep_transform_values_in_object(e, &block) }
      else
        yield(object)
      end
    end

    def _deep_transform_values_in_object!(object, &block)
      case object
      when Hash
        object.transform_values! { |value| _deep_transform_values_in_object!(value, &block) }
      when Array
        object.map! { |e| _deep_transform_values_in_object!(e, &block) }
      else
        yield(object)
      end
    end
# frozen_string_literal: true

require "active_support/xml_mini"
require "active_support/core_ext/object/blank"
require "active_support/core_ext/object/to_param"
require "active_support/core_ext/object/to_query"
require "active_support/core_ext/object/try"
require "active_support/core_ext/array/wrap"
require "active_support/core_ext/hash/reverse_merge"
require "active_support/core_ext/string/inflections"

class Hash
  # Returns a string containing an XML representation of its receiver:
  #
  #   { foo: 1, bar: 2 }.to_xml
  #   # =>
  #   # <?xml version="1.0" encoding="UTF-8"?>
  #   # <hash>
  #   #   <foo type="integer">1</foo>
  #   #   <bar type="integer">2</bar>
  #   # </hash>
  #
  # To do so, the method loops over the pairs and builds nodes that depend on
  # the _values_. Given a pair +key+, +value+:
  #
  # * If +value+ is a hash there's a recursive call with +key+ as <tt>:root</tt>.
  #
  # * If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>,
  #   and +key+ singularized as <tt>:children</tt>.
  #
  # * If +value+ is a callable object it must expect one or two arguments. Depending
  #   on the arity, the callable is invoked with the +options+ hash as first argument
  #   with +key+ as <tt>:root</tt>, and +key+ singularized as second argument. The
  #   callable can add nodes by using <tt>options[:builder]</tt>.
  #
  #     {foo: lambda { |options, key| options[:builder].b(key) }}.to_xml
  #     # => "<b>foo</b>"
  #
  # * If +value+ responds to +to_xml+ the method is invoked with +key+ as <tt>:root</tt>.
  #
  #     class Foo
  #       def to_xml(options)
  #         options[:builder].bar 'fooing!'
  #       end
  #     end
  #
  #     { foo: Foo.new }.to_xml(skip_instruct: true)
  #     # =>
  #     # <hash>
  #     #   <bar>fooing!</bar>
  #     # </hash>
  #
  # * Otherwise, a node with +key+ as tag is created with a string representation of
  #   +value+ as text node. If +value+ is +nil+ an attribute "nil" set to "true" is added.
  #   Unless the option <tt>:skip_types</tt> exists and is true, an attribute "type" is
  #   added as well according to the following mapping:
  #
  #     XML_TYPE_NAMES = {
  #       "Symbol"     => "symbol",
  #       "Integer"    => "integer",
  #       "BigDecimal" => "decimal",
  #       "Float"      => "float",
  #       "TrueClass"  => "boolean",
  #       "FalseClass" => "boolean",
  #       "Date"       => "date",
  #       "DateTime"   => "dateTime",
  #       "Time"       => "dateTime"
  #     }
  #
  # By default the root node is "hash", but that's configurable via the <tt>:root</tt> option.
  #
  # The default XML builder is a fresh instance of <tt>Builder::XmlMarkup</tt>. You can
  # configure your own builder with the <tt>:builder</tt> option. The method also accepts
  # options like <tt>:dasherize</tt> and friends, they are forwarded to the builder.
  def to_xml(options = {})
    require "active_support/builder" unless defined?(Builder::XmlMarkup)

    options = options.dup
    options[:indent]  ||= 2
    options[:root]    ||= "hash"
    options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])

    builder = options[:builder]
    builder.instruct! unless options.delete(:skip_instruct)

    root = ActiveSupport::XmlMini.rename_key(options[:root].to_s, options)

    builder.tag!(root) do
      each { |key, value| ActiveSupport::XmlMini.to_tag(key, value, options) }
      yield builder if block_given?
    end
  end

  class << self
    # Returns a Hash containing a collection of pairs when the key is the node name and the value is
    # its content
    #
    #   xml = <<-XML
    #     <?xml version="1.0" encoding="UTF-8"?>
    #       <hash>
    #         <foo type="integer">1</foo>
    #         <bar type="integer">2</bar>
    #       </hash>
    #   XML
    #
    #   hash = Hash.from_xml(xml)
    #   # => {"hash"=>{"foo"=>1, "bar"=>2}}
    #
    # +DisallowedType+ is raised if the XML contains attributes with <tt>type="yaml"</tt> or
    # <tt>type="symbol"</tt>. Use <tt>Hash.from_trusted_xml</tt> to
    # parse this XML.
    #
    # Custom +disallowed_types+ can also be passed in the form of an
    # array.
    #
    #   xml = <<-XML
    #     <?xml version="1.0" encoding="UTF-8"?>
    #       <hash>
    #         <foo type="integer">1</foo>
    #         <bar type="string">"David"</bar>
    #       </hash>
    #   XML
    #
    #   hash = Hash.from_xml(xml, ['integer'])
    #   # => ActiveSupport::XMLConverter::DisallowedType: Disallowed type attribute: "integer"
    #
    # Note that passing custom disallowed types will override the default types,
    # which are Symbol and YAML.
    def from_xml(xml, disallowed_types = nil)
      ActiveSupport::XMLConverter.new(xml, disallowed_types).to_h
    end

    # Builds a Hash from XML just like <tt>Hash.from_xml</tt>, but also allows Symbol and YAML.
    def from_trusted_xml(xml)
      from_xml xml, []
    end
  end
end

module ActiveSupport
  class XMLConverter # :nodoc:
    # Raised if the XML contains attributes with type="yaml" or
    # type="symbol". Read Hash#from_xml for more details.
    class DisallowedType < StandardError
      def initialize(type)
        super "Disallowed type attribute: #{type.inspect}"
      end
    end

    DISALLOWED_TYPES = %w(symbol yaml)

    def initialize(xml, disallowed_types = nil)
      @xml = normalize_keys(XmlMini.parse(xml))
      @disallowed_types = disallowed_types || DISALLOWED_TYPES
    end

    def to_h
      deep_to_h(@xml)
    end

    private
      def normalize_keys(params)
        case params
        when Hash
          Hash[params.map { |k, v| [k.to_s.tr("-", "_"), normalize_keys(v)] } ]
        when Array
          params.map { |v| normalize_keys(v) }
        else
          params
        end
      end

      def deep_to_h(value)
        case value
        when Hash
          process_hash(value)
        when Array
          process_array(value)
        when String
          value
        else
          raise "can't typecast #{value.class.name} - #{value.inspect}"
        end
      end

      def process_hash(value)
        if value.include?("type") && !value["type"].is_a?(Hash) && @disallowed_types.include?(value["type"])
          raise DisallowedType, value["type"]
        end

        if become_array?(value)
          _, entries = Array.wrap(value.detect { |k, v| not v.is_a?(String) })
          if entries.nil? || value["__content__"].try(:empty?)
            []
          else
            case entries
            when Array
              entries.collect { |v| deep_to_h(v) }
            when Hash
              [deep_to_h(entries)]
            else
              raise "can't typecast #{entries.inspect}"
            end
          end
        elsif become_content?(value)
          process_content(value)

        elsif become_empty_string?(value)
          ""
        elsif become_hash?(value)
          xml_value = value.transform_values { |v| deep_to_h(v) }

          # Turn { files: { file: #<StringIO> } } into { files: #<StringIO> } so it is compatible with
          # how multipart uploaded files from HTML appear
          xml_value["file"].is_a?(StringIO) ? xml_value["file"] : xml_value
        end
      end

      def become_content?(value)
        value["type"] == "file" || (value["__content__"] && (value.keys.size == 1 || value["__content__"].present?))
      end

      def become_array?(value)
        value["type"] == "array"
      end

      def become_empty_string?(value)
        # { "string" => true }
        # No tests fail when the second term is removed.
        value["type"] == "string" && value["nil"] != "true"
      end

      def become_hash?(value)
        !nothing?(value) && !garbage?(value)
      end

      def nothing?(value)
        # blank or nil parsed values are represented by nil
        value.blank? || value["nil"] == "true"
      end

      def garbage?(value)
        # If the type is the only element which makes it then
        # this still makes the value nil, except if type is
        # an XML node(where type['value'] is a Hash)
        value["type"] && !value["type"].is_a?(::Hash) && value.size == 1
      end

      def process_content(value)
        content = value["__content__"]
        if parser = ActiveSupport::XmlMini::PARSING[value["type"]]
          parser.arity == 1 ? parser.call(content) : parser.call(content, value)
        else
          content
        end
      end

      def process_array(value)
        value.map! { |i| deep_to_h(i) }
        value.length > 1 ? value : value.first
# frozen_string_literal: true

require "active_support/hash_with_indifferent_access"

class Hash
  # Returns an <tt>ActiveSupport::HashWithIndifferentAccess</tt> out of its receiver:
  #
  #   { a: 1 }.with_indifferent_access['a'] # => 1
  def with_indifferent_access
    ActiveSupport::HashWithIndifferentAccess.new(self)
  end

  # Called when object is nested under an object that receives
  # #with_indifferent_access. This method will be called on the current object
  # by the enclosing object and is aliased to #with_indifferent_access by
  # default. Subclasses of Hash may overwrite this method to return +self+ if
  # converting to an <tt>ActiveSupport::HashWithIndifferentAccess</tt> would not be
  # desirable.
  #
  #   b = { b: 1 }
# frozen_string_literal: true

class Hash
  # Replaces the hash with only the given keys.
  # Returns a hash containing the removed key/value pairs.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.slice!(:a, :b)  # => {:c=>3, :d=>4}
  #   hash                 # => {:a=>1, :b=>2}
  def slice!(*keys)
    omit = slice(*self.keys - keys)
    hash = slice(*keys)
    hash.default      = default
    hash.default_proc = default_proc if default_proc
    replace(hash)
    omit
  end

  # Removes and returns the key/value pairs matching the given keys.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.extract!(:a, :b) # => {:a=>1, :b=>2}
  #   hash                  # => {:c=>3, :d=>4}
  def extract!(*keys)
    keys.each_with_object(self.class.new) { |key, result| result[key] = delete(key) if has_key?(key) }
# frozen_string_literal: true

class Hash
  # Returns a hash that includes everything except given keys.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except(:c)     # => { a: true, b: false }
  #   hash.except(:a, :b) # => { c: nil }
  #   hash                # => { a: true, b: false, c: nil }
  #
  # This is useful for limiting a set of parameters to everything but a few known toggles:
  #   @person.update(params[:person].except(:admin))
  def except(*keys)
    slice(*self.keys - keys)
  end unless method_defined?(:except)

  # Removes the given keys from hash and returns it.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except!(:c) # => { a: true, b: false }
  #   hash             # => { a: true, b: false }
  def except!(*keys)
# frozen_string_literal: true

class Hash
  # Returns a new hash with +self+ and +other_hash+ merged recursively.
  #
  #   h1 = { a: true, b: { c: [1, 2, 3] } }
  #   h2 = { a: false, b: { x: [3, 4, 5] } }
  #
  #   h1.deep_merge(h2) # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
  #
  # Like with Hash#merge in the standard library, a block can be provided
  # to merge values:
  #
  #   h1 = { a: 100, b: 200, c: { c1: 100 } }
  #   h2 = { b: 250, c: { c1: 200 } }
  #   h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val }
  #   # => { a: 100, b: 450, c: { c1: 300 } }
  def deep_merge(other_hash, &block)
    dup.deep_merge!(other_hash, &block)
  end

  # Same as +deep_merge+, but modifies +self+.
  def deep_merge!(other_hash, &block)
    merge!(other_hash) do |key, this_val, other_val|
      if this_val.is_a?(Hash) && other_val.is_a?(Hash)
        this_val.deep_merge(other_val, &block)
      elsif block_given?
        block.call(key, this_val, other_val)
      else
        other_val
# frozen_string_literal: true

class Hash
  # Returns a new hash with all keys converted to strings.
  #
  #   hash = { name: 'Rob', age: '28' }
  #
  #   hash.stringify_keys
  #   # => {"name"=>"Rob", "age"=>"28"}
  def stringify_keys
    transform_keys(&:to_s)
  end

  # Destructively converts all keys to strings. Same as
  # +stringify_keys+, but modifies +self+.
  def stringify_keys!
    transform_keys!(&:to_s)
  end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+.
  #
  #   hash = { 'name' => 'Rob', 'age' => '28' }
  #
  #   hash.symbolize_keys
  #   # => {:name=>"Rob", :age=>"28"}
  def symbolize_keys
    transform_keys { |key| key.to_sym rescue key }
  end
  alias_method :to_options,  :symbolize_keys

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. Same as +symbolize_keys+, but modifies +self+.
  def symbolize_keys!
    transform_keys! { |key| key.to_sym rescue key }
  end
  alias_method :to_options!, :symbolize_keys!

  # Validates all keys in a hash match <tt>*valid_keys</tt>, raising
  # +ArgumentError+ on a mismatch.
  #
  # Note that keys are treated differently than HashWithIndifferentAccess,
  # meaning that string and symbol keys will not match.
  #
  #   { name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises "ArgumentError: Unknown key: :years. Valid keys are: :name, :age"
  #   { name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises "ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'"
  #   { name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing
  def assert_valid_keys(*valid_keys)
    valid_keys.flatten!
    each_key do |k|
      unless valid_keys.include?(k)
        raise ArgumentError.new("Unknown key: #{k.inspect}. Valid keys are: #{valid_keys.map(&:inspect).join(', ')}")
      end
    end
  end

  # Returns a new hash with all keys converted by the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #  hash = { person: { name: 'Rob', age: '28' } }
  #
  #  hash.deep_transform_keys{ |key| key.to_s.upcase }
  #  # => {"PERSON"=>{"NAME"=>"Rob", "AGE"=>"28"}}
  def deep_transform_keys(&block)
    _deep_transform_keys_in_object(self, &block)
  end

  # Destructively converts all keys by using the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  def deep_transform_keys!(&block)
    _deep_transform_keys_in_object!(self, &block)
  end

  # Returns a new hash with all keys converted to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #   hash = { person: { name: 'Rob', age: '28' } }
  #
  #   hash.deep_stringify_keys
  #   # => {"person"=>{"name"=>"Rob", "age"=>"28"}}
  def deep_stringify_keys
    deep_transform_keys(&:to_s)
  end

  # Destructively converts all keys to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  def deep_stringify_keys!
    deep_transform_keys!(&:to_s)
  end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+. This includes the keys from the root hash
  # and from all nested hashes and arrays.
  #
  #   hash = { 'person' => { 'name' => 'Rob', 'age' => '28' } }
  #
  #   hash.deep_symbolize_keys
  #   # => {:person=>{:name=>"Rob", :age=>"28"}}
  def deep_symbolize_keys
    deep_transform_keys { |key| key.to_sym rescue key }
  end

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. This includes the keys from the root hash and from all
  # nested hashes and arrays.
  def deep_symbolize_keys!
    deep_transform_keys! { |key| key.to_sym rescue key }
  end

  private
    # Support methods for deep transforming nested hashes and arrays.
    def _deep_transform_keys_in_object(object, &block)
      case object
      when Hash
        object.each_with_object(self.class.new) do |(key, value), result|
          result[yield(key)] = _deep_transform_keys_in_object(value, &block)
        end
      when Array
        object.map { |e| _deep_transform_keys_in_object(e, &block) }
      else
        object
      end
    end

    def _deep_transform_keys_in_object!(object, &block)
      case object
      when Hash
        object.keys.each do |key|
          value = object.delete(key)
          object[yield(key)] = _deep_transform_keys_in_object!(value, &block)
        end
        object
      when Array
        object.map! { |e| _deep_transform_keys_in_object!(e, &block) }
      else
        object
# frozen_string_literal: true

require "securerandom"

module Digest
  module UUID
    DNS_NAMESPACE  = "k\xA7\xB8\x10\x9D\xAD\x11\xD1\x80\xB4\x00\xC0O\xD40\xC8" #:nodoc:
    URL_NAMESPACE  = "k\xA7\xB8\x11\x9D\xAD\x11\xD1\x80\xB4\x00\xC0O\xD40\xC8" #:nodoc:
    OID_NAMESPACE  = "k\xA7\xB8\x12\x9D\xAD\x11\xD1\x80\xB4\x00\xC0O\xD40\xC8" #:nodoc:
    X500_NAMESPACE = "k\xA7\xB8\x14\x9D\xAD\x11\xD1\x80\xB4\x00\xC0O\xD40\xC8" #:nodoc:

    # Generates a v5 non-random UUID (Universally Unique IDentifier).
    #
    # Using Digest::MD5 generates version 3 UUIDs; Digest::SHA1 generates version 5 UUIDs.
    # uuid_from_hash always generates the same UUID for a given name and namespace combination.
    #
    # See RFC 4122 for details of UUID at: https://www.ietf.org/rfc/rfc4122.txt
    def self.uuid_from_hash(hash_class, uuid_namespace, name)
      if hash_class == Digest::MD5
        version = 3
      elsif hash_class == Digest::SHA1
        version = 5
      else
        raise ArgumentError, "Expected Digest::SHA1 or Digest::MD5, got #{hash_class.name}."
      end

      hash = hash_class.new
      hash.update(uuid_namespace)
      hash.update(name)

      ary = hash.digest.unpack("NnnnnN")
      ary[2] = (ary[2] & 0x0FFF) | (version << 12)
      ary[3] = (ary[3] & 0x3FFF) | 0x8000

      "%08x-%04x-%04x-%04x-%04x%08x" % ary
    end

    # Convenience method for uuid_from_hash using Digest::MD5.
    def self.uuid_v3(uuid_namespace, name)
      uuid_from_hash(Digest::MD5, uuid_namespace, name)
    end

    # Convenience method for uuid_from_hash using Digest::SHA1.
    def self.uuid_v5(uuid_namespace, name)
      uuid_from_hash(Digest::SHA1, uuid_namespace, name)
    end

    # Convenience method for SecureRandom.uuid.
    def self.uuid_v4
      SecureRandom.uuid
# frozen_string_literal: true

class Integer
  # Check whether the integer is evenly divisible by the argument.
  #
  #   0.multiple_of?(0)  # => true
  #   6.multiple_of?(5)  # => false
  #   10.multiple_of?(2) # => true
  def multiple_of?(number)
    number == 0 ? self == 0 : self % number == 0
# frozen_string_literal: true

require "active_support/inflector"

class Integer
  # Ordinalize turns a number into an ordinal string used to denote the
  # position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
  #
  #  1.ordinalize     # => "1st"
  #  2.ordinalize     # => "2nd"
  #  1002.ordinalize  # => "1002nd"
  #  1003.ordinalize  # => "1003rd"
  #  -11.ordinalize   # => "-11th"
  #  -1001.ordinalize # => "-1001st"
  def ordinalize
    ActiveSupport::Inflector.ordinalize(self)
  end

  # Ordinal returns the suffix used to denote the position
  # in an ordered sequence such as 1st, 2nd, 3rd, 4th.
  #
  #  1.ordinal     # => "st"
  #  2.ordinal     # => "nd"
  #  1002.ordinal  # => "nd"
  #  1003.ordinal  # => "rd"
  #  -11.ordinal   # => "th"
  #  -1001.ordinal # => "st"
  def ordinal
    ActiveSupport::Inflector.ordinal(self)
  end
# frozen_string_literal: true

require "active_support/duration"
require "active_support/core_ext/numeric/time"

class Integer
  # Returns a Duration instance matching the number of months provided.
  #
  #   2.months # => 2 months
  def months
    ActiveSupport::Duration.months(self)
  end
  alias :month :months

  # Returns a Duration instance matching the number of years provided.
  #
  #   2.years # => 2 years
  def years
    ActiveSupport::Duration.years(self)
  end
# frozen_string_literal: true

require "active_support/core_ext/date/acts_like"
require "active_support/core_ext/date/blank"
require "active_support/core_ext/date/calculations"
# frozen_string_literal: true

require "date"
require "active_support/duration"
require "active_support/core_ext/object/acts_like"
require "active_support/core_ext/date/zones"
require "active_support/core_ext/time/zones"
require "active_support/core_ext/date_and_time/calculations"

class Date
  include DateAndTime::Calculations

  class << self
    attr_accessor :beginning_of_week_default

    # Returns the week start (e.g. :monday) for the current request, if this has been set (via Date.beginning_of_week=).
    # If <tt>Date.beginning_of_week</tt> has not been set for the current request, returns the week start specified in <tt>config.beginning_of_week</tt>.
    # If no config.beginning_of_week was specified, returns :monday.
    def beginning_of_week
      Thread.current[:beginning_of_week] || beginning_of_week_default || :monday
    end

    # Sets <tt>Date.beginning_of_week</tt> to a week start (e.g. :monday) for current request/thread.
    #
    # This method accepts any of the following day symbols:
    # :monday, :tuesday, :wednesday, :thursday, :friday, :saturday, :sunday
    def beginning_of_week=(week_start)
      Thread.current[:beginning_of_week] = find_beginning_of_week!(week_start)
    end

    # Returns week start day symbol (e.g. :monday), or raises an +ArgumentError+ for invalid day symbol.
    def find_beginning_of_week!(week_start)
      raise ArgumentError, "Invalid beginning of week: #{week_start}" unless ::Date::DAYS_INTO_WEEK.key?(week_start)
      week_start
    end

    # Returns a new Date representing the date 1 day ago (i.e. yesterday's date).
    def yesterday
      ::Date.current.yesterday
    end

    # Returns a new Date representing the date 1 day after today (i.e. tomorrow's date).
    def tomorrow
      ::Date.current.tomorrow
    end

    # Returns Time.zone.today when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns Date.today.
    def current
      ::Time.zone ? ::Time.zone.today : ::Date.today
    end
  end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  # and then subtracts the specified number of seconds.
  def ago(seconds)
    in_time_zone.since(-seconds)
  end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  # and then adds the specified number of seconds
  def since(seconds)
    in_time_zone.since(seconds)
  end
  alias :in :since

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  def beginning_of_day
    in_time_zone
  end
  alias :midnight :beginning_of_day
  alias :at_midnight :beginning_of_day
  alias :at_beginning_of_day :beginning_of_day

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  def middle_of_day
    in_time_zone.middle_of_day
  end
  alias :midday :middle_of_day
  alias :noon :middle_of_day
  alias :at_midday :middle_of_day
  alias :at_noon :middle_of_day
  alias :at_middle_of_day :middle_of_day

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the end of the day (23:59:59)
  def end_of_day
    in_time_zone.end_of_day
  end
  alias :at_end_of_day :end_of_day

  def plus_with_duration(other) #:nodoc:
    if ActiveSupport::Duration === other
      other.since(self)
    else
      plus_without_duration(other)
    end
  end
  alias_method :plus_without_duration, :+
  alias_method :+, :plus_with_duration

  def minus_with_duration(other) #:nodoc:
    if ActiveSupport::Duration === other
      plus_with_duration(-other)
    else
      minus_without_duration(other)
    end
  end
  alias_method :minus_without_duration, :-
  alias_method :-, :minus_with_duration

  # Provides precise Date calculations for years, months, and days. The +options+ parameter takes a hash with
  # any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>.
  def advance(options)
    d = self

    d = d >> options[:years] * 12 if options[:years]
    d = d >> options[:months] if options[:months]
    d = d + options[:weeks] * 7 if options[:weeks]
    d = d + options[:days] if options[:days]

    d
  end

  # Returns a new Date where one or more of the elements have been changed according to the +options+ parameter.
  # The +options+ parameter is a hash with a combination of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>.
  #
  #   Date.new(2007, 5, 12).change(day: 1)               # => Date.new(2007, 5, 1)
  #   Date.new(2007, 5, 12).change(year: 2005, month: 1) # => Date.new(2005, 1, 12)
  def change(options)
    ::Date.new(
      options.fetch(:year, year),
      options.fetch(:month, month),
      options.fetch(:day, day)
    )
  end

  # Allow Date to be compared with Time by converting to DateTime and relying on the <=> from there.
  def compare_with_coercion(other)
    if other.is_a?(Time)
      to_datetime <=> other
    else
      compare_without_coercion(other)
    end
  end
  alias_method :compare_without_coercion, :<=>
  alias_method :<=>, :compare_with_coercion
# frozen_string_literal: true

require "date"
require "active_support/core_ext/date_and_time/zones"

# frozen_string_literal: true

require "date"
require "active_support/inflector/methods"
require "active_support/core_ext/date/zones"
require "active_support/core_ext/module/redefine_method"

class Date
  DATE_FORMATS = {
    short: "%d %b",
    long: "%B %d, %Y",
    db: "%Y-%m-%d",
    inspect: "%Y-%m-%d",
    number: "%Y%m%d",
    long_ordinal: lambda { |date|
      day_format = ActiveSupport::Inflector.ordinalize(date.day)
      date.strftime("%B #{day_format}, %Y") # => "April 25th, 2007"
    },
    rfc822: "%d %b %Y",
    iso8601: lambda { |date| date.iso8601 }
  }

  # Convert to a formatted string. See DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_s</tt>.
  #
  #   date = Date.new(2007, 11, 10)       # => Sat, 10 Nov 2007
  #
  #   date.to_formatted_s(:db)            # => "2007-11-10"
  #   date.to_s(:db)                      # => "2007-11-10"
  #
  #   date.to_formatted_s(:short)         # => "10 Nov"
  #   date.to_formatted_s(:number)        # => "20071110"
  #   date.to_formatted_s(:long)          # => "November 10, 2007"
  #   date.to_formatted_s(:long_ordinal)  # => "November 10th, 2007"
  #   date.to_formatted_s(:rfc822)        # => "10 Nov 2007"
  #   date.to_formatted_s(:iso8601)       # => "2007-11-10"
  #
  # == Adding your own date formats to to_formatted_s
  # You can add your own formats to the Date::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a date argument as the value.
  #
  #   # config/initializers/date_formats.rb
  #   Date::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Date::DATE_FORMATS[:short_ordinal] = ->(date) { date.strftime("%B #{date.day.ordinalize}") }
  def to_formatted_s(format = :default)
    if formatter = DATE_FORMATS[format]
      if formatter.respond_to?(:call)
        formatter.call(self).to_s
      else
        strftime(formatter)
      end
    else
      to_default_s
    end
  end
  alias_method :to_default_s, :to_s
  alias_method :to_s, :to_formatted_s

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005"
  def readable_inspect
    strftime("%a, %d %b %Y")
  end
  alias_method :default_inspect, :inspect
  alias_method :inspect, :readable_inspect

  silence_redefinition_of_method :to_time

  # Converts a Date instance to a Time, where the time is set to the beginning of the day.
  # The timezone can be either :local or :utc (default :local).
  #
  #   date = Date.new(2007, 11, 10)  # => Sat, 10 Nov 2007
  #
  #   date.to_time                   # => 2007-11-10 00:00:00 0800
  #   date.to_time(:local)           # => 2007-11-10 00:00:00 0800
  #
  #   date.to_time(:utc)             # => 2007-11-10 00:00:00 UTC
  #
  # NOTE: The :local timezone is Ruby's *process* timezone, i.e. ENV['TZ'].
  #       If the *application's* timezone is needed, then use +in_time_zone+ instead.
  def to_time(form = :local)
    raise ArgumentError, "Expected :local or :utc, got #{form.inspect}." unless [:local, :utc].include?(form)
    ::Time.public_send(form, year, month, day)
  end

  silence_redefinition_of_method :xmlschema

  # Returns a string which represents the time in used time zone as DateTime
  # defined by XML Schema:
  #
  #   date = Date.new(2015, 05, 23)  # => Sat, 23 May 2015
  #   date.xmlschema                 # => "2015-05-23T00:00:00+04:00"
  def xmlschema
    in_time_zone.xmlschema
# frozen_string_literal: true

require "active_support/core_ext/object/acts_like"

class Date
# frozen_string_literal: true

require "date"

class Date #:nodoc:
  # No Date is blank:
  #
  #   Date.today.blank? # => false
  #
  # @return [false]
# frozen_string_literal: true

require "active_support/core_ext/string/conversions"
require "active_support/core_ext/time/zones"

class String
  # Converts String to a TimeWithZone in the current zone if Time.zone or Time.zone_default
  # is set, otherwise converts String to a Time via String#to_time
  def in_time_zone(zone = ::Time.zone)
    if zone
      ::Time.find_zone!(zone).parse(self)
    else
      to_time
    end
  end
# frozen_string_literal: true

class String
  # Enables more predictable duck-typing on String-like classes. See <tt>Object#acts_like?</tt>.
  def acts_like_string?
# frozen_string_literal: true

class String
  # Strips indentation in heredocs.
  #
  # For example in
  #
  #   if options[:usage]
  #     puts <<-USAGE.strip_heredoc
  #       This command does such and such.
  #
  #       Supported options are:
  #         -h         This message
  #         ...
  #     USAGE
  #   end
  #
  # the user would see the usage message aligned against the left margin.
  #
  # Technically, it looks for the least indented non-empty line
  # in the whole string, and removes that amount of leading whitespace.
  def strip_heredoc
    gsub(/^#{scan(/^[ \t]*(?=\S)/).min}/, "").tap do |stripped|
      stripped.freeze if frozen?
    end
# frozen_string_literal: true

require "date"
require "active_support/core_ext/time/calculations"

class String
  # Converts a string to a Time value.
  # The +form+ can be either :utc or :local (default :local).
  #
  # The time is parsed using Time.parse method.
  # If +form+ is :local, then the time is in the system timezone.
  # If the date part is missing then the current date is used and if
  # the time part is missing then it is assumed to be 00:00:00.
  #
  #   "13-12-2012".to_time               # => 2012-12-13 00:00:00 +0100
  #   "06:12".to_time                    # => 2012-12-13 06:12:00 +0100
  #   "2012-12-13 06:12".to_time         # => 2012-12-13 06:12:00 +0100
  #   "2012-12-13T06:12".to_time         # => 2012-12-13 06:12:00 +0100
  #   "2012-12-13T06:12".to_time(:utc)   # => 2012-12-13 06:12:00 UTC
  #   "12/13/2012".to_time               # => ArgumentError: argument out of range
  #   "1604326192".to_time               # => ArgumentError: argument out of range
  def to_time(form = :local)
    parts = Date._parse(self, false)
    used_keys = %i(year mon mday hour min sec sec_fraction offset)
    return if (parts.keys & used_keys).empty?

    now = Time.now
    time = Time.new(
      parts.fetch(:year, now.year),
      parts.fetch(:mon, now.month),
      parts.fetch(:mday, now.day),
      parts.fetch(:hour, 0),
      parts.fetch(:min, 0),
      parts.fetch(:sec, 0) + parts.fetch(:sec_fraction, 0),
      parts.fetch(:offset, form == :utc ? 0 : nil)
    )

    form == :utc ? time.utc : time.to_time
  end

  # Converts a string to a Date value.
  #
  #   "1-1-2012".to_date   # => Sun, 01 Jan 2012
  #   "01/01/2012".to_date # => Sun, 01 Jan 2012
  #   "2012-12-13".to_date # => Thu, 13 Dec 2012
  #   "12/13/2012".to_date # => ArgumentError: invalid date
  def to_date
    ::Date.parse(self, false) unless blank?
  end

  # Converts a string to a DateTime value.
  #
  #   "1-1-2012".to_datetime            # => Sun, 01 Jan 2012 00:00:00 +0000
  #   "01/01/2012 23:59:59".to_datetime # => Sun, 01 Jan 2012 23:59:59 +0000
  #   "2012-12-13 12:50".to_datetime    # => Thu, 13 Dec 2012 12:50:00 +0000
# frozen_string_literal: true

class String
  # If you pass a single integer, returns a substring of one character at that
  # position. The first character of the string is at position 0, the next at
  # position 1, and so on. If a range is supplied, a substring containing
  # characters at offsets given by the range is returned. In both cases, if an
  # offset is negative, it is counted from the end of the string. Returns +nil+
  # if the initial offset falls outside the string. Returns an empty string if
  # the beginning of the range is greater than the end of the string.
  #
  #   str = "hello"
  #   str.at(0)      # => "h"
  #   str.at(1..3)   # => "ell"
  #   str.at(-2)     # => "l"
  #   str.at(-2..-1) # => "lo"
  #   str.at(5)      # => nil
  #   str.at(5..-1)  # => ""
  #
  # If a Regexp is given, the matching portion of the string is returned.
  # If a String is given, that given string is returned if it occurs in
  # the string. In both cases, +nil+ is returned if there is no match.
  #
  #   str = "hello"
  #   str.at(/lo/) # => "lo"
  #   str.at(/ol/) # => nil
  #   str.at("lo") # => "lo"
  #   str.at("ol") # => nil
  def at(position)
    self[position]
  end

  # Returns a substring from the given position to the end of the string.
  # If the position is negative, it is counted from the end of the string.
  #
  #   str = "hello"
  #   str.from(0)  # => "hello"
  #   str.from(3)  # => "lo"
  #   str.from(-2) # => "lo"
  #
  # You can mix it with +to+ method and do fun things like:
  #
  #   str = "hello"
  #   str.from(0).to(-1) # => "hello"
  #   str.from(1).to(-2) # => "ell"
  def from(position)
    self[position, length]
  end

  # Returns a substring from the beginning of the string to the given position.
  # If the position is negative, it is counted from the end of the string.
  #
  #   str = "hello"
  #   str.to(0)  # => "h"
  #   str.to(3)  # => "hell"
  #   str.to(-2) # => "hell"
  #
  # You can mix it with +from+ method and do fun things like:
  #
  #   str = "hello"
  #   str.from(0).to(-1) # => "hello"
  #   str.from(1).to(-2) # => "ell"
  def to(position)
    position += size if position < 0
    self[0, position + 1] || +""
  end

  # Returns the first character. If a limit is supplied, returns a substring
  # from the beginning of the string until it reaches the limit value. If the
  # given limit is greater than or equal to the string length, returns a copy of self.
  #
  #   str = "hello"
  #   str.first    # => "h"
  #   str.first(1) # => "h"
  #   str.first(2) # => "he"
  #   str.first(0) # => ""
  #   str.first(6) # => "hello"
  def first(limit = 1)
    self[0, limit] || raise(ArgumentError, "negative limit")
  end

  # Returns the last character of the string. If a limit is supplied, returns a substring
  # from the end of the string until it reaches the limit value (counting backwards). If
  # the given limit is greater than or equal to the string length, returns a copy of self.
  #
  #   str = "hello"
  #   str.last    # => "o"
  #   str.last(1) # => "o"
  #   str.last(2) # => "lo"
  #   str.last(0) # => ""
# frozen_string_literal: true

require "active_support/string_inquirer"
require "active_support/environment_inquirer"

class String
  # Wraps the current string in the <tt>ActiveSupport::StringInquirer</tt> class,
  # which gives you a prettier way to test for equality.
  #
  #   env = 'production'.inquiry
  #   env.production?  # => true
  #   env.development? # => false
  def inquiry
    ActiveSupport::StringInquirer.new(self)
  end
# frozen_string_literal: true

class String
  # The inverse of <tt>String#include?</tt>. Returns true if the string
  # does not include the other string.
  #
  #   "hello".exclude? "lo" # => false
  #   "hello".exclude? "ol" # => true
  #   "hello".exclude? ?h   # => false
  def exclude?(string)
# frozen_string_literal: true

require "active_support/multibyte"

class String
  # == Multibyte proxy
  #
  # +mb_chars+ is a multibyte safe proxy for string methods.
  #
  # It creates and returns an instance of the ActiveSupport::Multibyte::Chars class which
  # encapsulates the original string. A Unicode safe version of all the String methods are defined on this proxy
  # class. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.
  #
  #   >> "".mb_chars.upcase.to_s
  #   => ""
  #
  # NOTE: Ruby 2.4 and later support native Unicode case mappings:
  #
  #   >> "".upcase
  #   => ""
  #
  # == Method chaining
  #
  # All the methods on the Chars proxy which normally return a string will return a Chars object. This allows
  # method chaining on the result of any of these methods.
  #
  #   name.mb_chars.reverse.length # => 12
  #
  # == Interoperability and configuration
  #
  # The Chars object tries to be as interchangeable with String objects as possible: sorting and comparing between
  # String and Char work like expected. The bang! methods change the internal string representation in the Chars
  # object. Interoperability problems can be resolved easily with a +to_s+ call.
  #
  # For more information about the methods defined on the Chars proxy see ActiveSupport::Multibyte::Chars. For
  # information about how to change the default Multibyte behavior see ActiveSupport::Multibyte.
  def mb_chars
    ActiveSupport::Multibyte.proxy_class.new(self)
  end

  # Returns +true+ if string has utf_8 encoding.
  #
  #   utf_8_str = "some string".encode "UTF-8"
  #   iso_str = "some string".encode "ISO-8859-1"
  #
  #   utf_8_str.is_utf8? # => true
  #   iso_str.is_utf8?   # => false
  def is_utf8?
    case encoding
    when Encoding::UTF_8, Encoding::US_ASCII
      valid_encoding?
    when Encoding::ASCII_8BIT
      dup.force_encoding(Encoding::UTF_8).valid_encoding?
    else
      false
# frozen_string_literal: true

class String
  alias :starts_with? :start_with?
  alias :ends_with? :end_with?
# frozen_string_literal: true

class String
  # Returns the string, first removing all whitespace on both ends of
  # the string, and then changing remaining consecutive whitespace
  # groups into one space each.
  #
  # Note that it handles both ASCII and Unicode whitespace.
  #
  #   %{ Multi-line
  #      string }.squish                   # => "Multi-line string"
  #   " foo   bar    \n   \t   boo".squish # => "foo bar boo"
  def squish
    dup.squish!
  end

  # Performs a destructive squish. See String#squish.
  #   str = " foo   bar    \n   \t   boo"
  #   str.squish!                         # => "foo bar boo"
  #   str                                 # => "foo bar boo"
  def squish!
    gsub!(/[[:space:]]+/, " ")
    strip!
    self
  end

  # Returns a new string with all occurrences of the patterns removed.
  #   str = "foo bar test"
  #   str.remove(" test")                 # => "foo bar"
  #   str.remove(" test", /bar/)          # => "foo "
  #   str                                 # => "foo bar test"
  def remove(*patterns)
    dup.remove!(*patterns)
  end

  # Alters the string by removing all occurrences of the patterns.
  #   str = "foo bar test"
  #   str.remove!(" test", /bar/)         # => "foo "
  #   str                                 # => "foo "
  def remove!(*patterns)
    patterns.each do |pattern|
      gsub! pattern, ""
    end

    self
  end

  # Truncates a given +text+ after a given <tt>length</tt> if +text+ is longer than <tt>length</tt>:
  #
  #   'Once upon a time in a world far far away'.truncate(27)
  #   # => "Once upon a time in a wo..."
  #
  # Pass a string or regexp <tt>:separator</tt> to truncate +text+ at a natural break:
  #
  #   'Once upon a time in a world far far away'.truncate(27, separator: ' ')
  #   # => "Once upon a time in a..."
  #
  #   'Once upon a time in a world far far away'.truncate(27, separator: /\s/)
  #   # => "Once upon a time in a..."
  #
  # The last characters will be replaced with the <tt>:omission</tt> string (defaults to "...")
  # for a total length not exceeding <tt>length</tt>:
  #
  #   'And they found that many people were sleeping better.'.truncate(25, omission: '... (continued)')
  #   # => "And they f... (continued)"
  def truncate(truncate_at, options = {})
    return dup unless length > truncate_at

    omission = options[:omission] || "..."
    length_with_room_for_omission = truncate_at - omission.length
    stop = \
      if options[:separator]
        rindex(options[:separator], length_with_room_for_omission) || length_with_room_for_omission
      else
        length_with_room_for_omission
      end

    +"#{self[0, stop]}#{omission}"
  end

  # Truncates +text+ to at most <tt>bytesize</tt> bytes in length without
  # breaking string encoding by splitting multibyte characters or breaking
  # grapheme clusters ("perceptual characters") by truncating at combining
  # characters.
  #
  #   >> "".size
  #   => 20
  #   >> "".bytesize
  #   => 80
  #   >> "".truncate_bytes(20)
  #   => ""
  #
  # The truncated text ends with the <tt>:omission</tt> string, defaulting
  # to "", for a total length not exceeding <tt>bytesize</tt>.
  def truncate_bytes(truncate_at, omission: "")
    omission ||= ""

    case
    when bytesize <= truncate_at
      dup
    when omission.bytesize > truncate_at
      raise ArgumentError, "Omission #{omission.inspect} is #{omission.bytesize}, larger than the truncation length of #{truncate_at} bytes"
    when omission.bytesize == truncate_at
      omission.dup
    else
      self.class.new.tap do |cut|
        cut_at = truncate_at - omission.bytesize

        each_grapheme_cluster do |grapheme|
          if cut.bytesize + grapheme.bytesize <= cut_at
            cut << grapheme
          else
            break
          end
        end

        cut << omission
      end
    end
  end

  # Truncates a given +text+ after a given number of words (<tt>words_count</tt>):
  #
  #   'Once upon a time in a world far far away'.truncate_words(4)
  #   # => "Once upon a time..."
  #
  # Pass a string or regexp <tt>:separator</tt> to specify a different separator of words:
  #
  #   'Once<br>upon<br>a<br>time<br>in<br>a<br>world'.truncate_words(5, separator: '<br>')
  #   # => "Once<br>upon<br>a<br>time<br>in..."
  #
  # The last characters will be replaced with the <tt>:omission</tt> string (defaults to "..."):
  #
  #   'And they found that many people were sleeping better.'.truncate_words(5, omission: '... (continued)')
  #   # => "And they found that many... (continued)"
  def truncate_words(words_count, options = {})
    sep = options[:separator] || /\s+/
    sep = Regexp.escape(sep.to_s) unless Regexp === sep
    if self =~ /\A((?>.+?#{sep}){#{words_count - 1}}.+?)#{sep}.*/m
      $1 + (options[:omission] || "...")
# frozen_string_literal: true

require "erb"
require "active_support/core_ext/module/redefine_method"
require "active_support/multibyte/unicode"

class ERB
  module Util
    HTML_ESCAPE = { "&" => "&amp;",  ">" => "&gt;",   "<" => "&lt;", '"' => "&quot;", "'" => "&#39;" }
    JSON_ESCAPE = { "&" => '\u0026', ">" => '\u003e', "<" => '\u003c', "\u2028" => '\u2028', "\u2029" => '\u2029' }
    HTML_ESCAPE_ONCE_REGEXP = /["><']|&(?!([a-zA-Z]+|(#\d+)|(#[xX][\dA-Fa-f]+));)/
    JSON_ESCAPE_REGEXP = /[\u2028\u2029&><]/u

    # A utility method for escaping HTML tag characters.
    # This method is also aliased as <tt>h</tt>.
    #
    #   puts html_escape('is a > 0 & a < 10?')
    #   # => is a &gt; 0 &amp; a &lt; 10?
    def html_escape(s)
      unwrapped_html_escape(s).html_safe
    end

    silence_redefinition_of_method :h
    alias h html_escape

    module_function :h

    singleton_class.silence_redefinition_of_method :html_escape
    module_function :html_escape

    # HTML escapes strings but doesn't wrap them with an ActiveSupport::SafeBuffer.
    # This method is not for public consumption! Seriously!
    def unwrapped_html_escape(s) # :nodoc:
      s = s.to_s
      if s.html_safe?
        s
      else
        CGI.escapeHTML(ActiveSupport::Multibyte::Unicode.tidy_bytes(s))
      end
    end
    module_function :unwrapped_html_escape

    # A utility method for escaping HTML without affecting existing escaped entities.
    #
    #   html_escape_once('1 < 2 &amp; 3')
    #   # => "1 &lt; 2 &amp; 3"
    #
    #   html_escape_once('&lt;&lt; Accept & Checkout')
    #   # => "&lt;&lt; Accept &amp; Checkout"
    def html_escape_once(s)
      result = ActiveSupport::Multibyte::Unicode.tidy_bytes(s.to_s).gsub(HTML_ESCAPE_ONCE_REGEXP, HTML_ESCAPE)
      s.html_safe? ? result.html_safe : result
    end

    module_function :html_escape_once

    # A utility method for escaping HTML entities in JSON strings. Specifically, the
    # &, > and < characters are replaced with their equivalent unicode escaped form -
    # \u0026, \u003e, and \u003c. The Unicode sequences \u2028 and \u2029 are also
    # escaped as they are treated as newline characters in some JavaScript engines.
    # These sequences have identical meaning as the original characters inside the
    # context of a JSON string, so assuming the input is a valid and well-formed
    # JSON value, the output will have equivalent meaning when parsed:
    #
    #   json = JSON.generate({ name: "</script><script>alert('PWNED!!!')</script>"})
    #   # => "{\"name\":\"</script><script>alert('PWNED!!!')</script>\"}"
    #
    #   json_escape(json)
    #   # => "{\"name\":\"\\u003C/script\\u003E\\u003Cscript\\u003Ealert('PWNED!!!')\\u003C/script\\u003E\"}"
    #
    #   JSON.parse(json) == JSON.parse(json_escape(json))
    #   # => true
    #
    # The intended use case for this method is to escape JSON strings before including
    # them inside a script tag to avoid XSS vulnerability:
    #
    #   <script>
    #     var currentUser = <%= raw json_escape(current_user.to_json) %>;
    #   </script>
    #
    # It is necessary to +raw+ the result of +json_escape+, so that quotation marks
    # don't get converted to <tt>&quot;</tt> entities. +json_escape+ doesn't
    # automatically flag the result as HTML safe, since the raw value is unsafe to
    # use inside HTML attributes.
    #
    # If your JSON is being used downstream for insertion into the DOM, be aware of
    # whether or not it is being inserted via <tt>html()</tt>. Most jQuery plugins do this.
    # If that is the case, be sure to +html_escape+ or +sanitize+ any user-generated
    # content returned by your JSON.
    #
    # If you need to output JSON elsewhere in your HTML, you can just do something
    # like this, as any unsafe characters (including quotation marks) will be
    # automatically escaped for you:
    #
    #   <div data-user-info="<%= current_user.to_json %>">...</div>
    #
    # WARNING: this helper only works with valid JSON. Using this on non-JSON values
    # will open up serious XSS vulnerabilities. For example, if you replace the
    # +current_user.to_json+ in the example above with user input instead, the browser
    # will happily eval() that string as JavaScript.
    #
    # The escaping performed in this method is identical to those performed in the
    # Active Support JSON encoder when +ActiveSupport.escape_html_entities_in_json+ is
    # set to true. Because this transformation is idempotent, this helper can be
    # applied even if +ActiveSupport.escape_html_entities_in_json+ is already true.
    #
    # Therefore, when you are unsure if +ActiveSupport.escape_html_entities_in_json+
    # is enabled, or if you are unsure where your JSON string originated from, it
    # is recommended that you always apply this helper (other libraries, such as the
    # JSON gem, do not provide this kind of protection by default; also some gems
    # might override +to_json+ to bypass Active Support's encoder).
    def json_escape(s)
      result = s.to_s.gsub(JSON_ESCAPE_REGEXP, JSON_ESCAPE)
      s.html_safe? ? result.html_safe : result
    end

    module_function :json_escape
  end
end

class Object
  def html_safe?
    false
  end
end

class Numeric
  def html_safe?
    true
  end
end

module ActiveSupport #:nodoc:
  class SafeBuffer < String
    UNSAFE_STRING_METHODS = %w(
      capitalize chomp chop delete delete_prefix delete_suffix
      downcase lstrip next reverse rstrip scrub slice squeeze strip
      succ swapcase tr tr_s unicode_normalize upcase
    )

    UNSAFE_STRING_METHODS_WITH_BACKREF = %w(gsub sub)

    alias_method :original_concat, :concat
    private :original_concat

    # Raised when <tt>ActiveSupport::SafeBuffer#safe_concat</tt> is called on unsafe buffers.
    class SafeConcatError < StandardError
      def initialize
        super "Could not concatenate to the buffer because it is not html safe."
      end
    end

    def [](*args)
      if html_safe?
        new_string = super

        return unless new_string

        new_safe_buffer = new_string.is_a?(SafeBuffer) ? new_string : SafeBuffer.new(new_string)
        new_safe_buffer.instance_variable_set :@html_safe, true
        new_safe_buffer
      else
        to_str[*args]
      end
    end

    def safe_concat(value)
      raise SafeConcatError unless html_safe?
      original_concat(value)
    end

    def initialize(str = "")
      @html_safe = true
      super
    end

    def initialize_copy(other)
      super
      @html_safe = other.html_safe?
    end

    def clone_empty
      self[0, 0]
    end

    def concat(value)
      super(html_escape_interpolated_argument(value))
    end
    alias << concat

    def insert(index, value)
      super(index, html_escape_interpolated_argument(value))
    end

    def prepend(value)
      super(html_escape_interpolated_argument(value))
    end

    def replace(value)
      super(html_escape_interpolated_argument(value))
    end

    def []=(*args)
      if args.length == 3
        super(args[0], args[1], html_escape_interpolated_argument(args[2]))
      else
        super(args[0], html_escape_interpolated_argument(args[1]))
      end
    end

    def +(other)
      dup.concat(other)
    end

    def *(*)
      new_string = super
      new_safe_buffer = new_string.is_a?(SafeBuffer) ? new_string : SafeBuffer.new(new_string)
      new_safe_buffer.instance_variable_set(:@html_safe, @html_safe)
      new_safe_buffer
    end

    def %(args)
      case args
      when Hash
        escaped_args = args.transform_values { |arg| html_escape_interpolated_argument(arg) }
      else
        escaped_args = Array(args).map { |arg| html_escape_interpolated_argument(arg) }
      end

      self.class.new(super(escaped_args))
    end

    def html_safe?
      defined?(@html_safe) && @html_safe
    end

    def to_s
      self
    end

    def to_param
      to_str
    end

    def encode_with(coder)
      coder.represent_object nil, to_str
    end

    UNSAFE_STRING_METHODS.each do |unsafe_method|
      if unsafe_method.respond_to?(unsafe_method)
        class_eval <<-EOT, __FILE__, __LINE__ + 1
          def #{unsafe_method}(*args, &block)       # def capitalize(*args, &block)
            to_str.#{unsafe_method}(*args, &block)  #   to_str.capitalize(*args, &block)
          end                                       # end

          def #{unsafe_method}!(*args)              # def capitalize!(*args)
            @html_safe = false                      #   @html_safe = false
            super                                   #   super
          end                                       # end
        EOT
      end
    end

    UNSAFE_STRING_METHODS_WITH_BACKREF.each do |unsafe_method|
      class_eval <<-EOT, __FILE__, __LINE__ + 1
        def #{unsafe_method}(*args, &block)             # def gsub(*args, &block)
          if block                                      #   if block
            to_str.#{unsafe_method}(*args) { |*params|  #     to_str.gsub(*args) { |*params|
              set_block_back_references(block, $~)      #       set_block_back_references(block, $~)
              block.call(*params)                       #       block.call(*params)
            }                                           #     }
          else                                          #   else
            to_str.#{unsafe_method}(*args)              #     to_str.gsub(*args)
          end                                           #   end
        end                                             # end

        def #{unsafe_method}!(*args, &block)            # def gsub!(*args, &block)
          @html_safe = false                            #   @html_safe = false
          if block                                      #   if block
            super(*args) { |*params|                    #     super(*args) { |*params|
              set_block_back_references(block, $~)      #       set_block_back_references(block, $~)
              block.call(*params)                       #       block.call(*params)
            }                                           #     }
          else                                          #   else
            super                                       #     super
          end                                           #   end
        end                                             # end
      EOT
    end

    private
      def html_escape_interpolated_argument(arg)
        (!html_safe? || arg.html_safe?) ? arg : CGI.escapeHTML(arg.to_s)
      end

      def set_block_back_references(block, match_data)
        block.binding.eval("proc { |m| $~ = m }").call(match_data)
      rescue ArgumentError
        # Can't create binding from C level Proc
      end
  end
end

class String
  # Marks a string as trusted safe. It will be inserted into HTML with no
  # additional escaping performed. It is your responsibility to ensure that the
  # string contains no malicious content. This method is equivalent to the
  # +raw+ helper in views. It is recommended that you use +sanitize+ instead of
  # this method. It should never be called on user input.
  def html_safe
# frozen_string_literal: true

require "active_support/inflector/methods"
require "active_support/inflector/transliterate"

# String inflections define new methods on the String class to transform names for different purposes.
# For instance, you can figure out the name of a table from the name of a class.
#
#   'ScaleScore'.tableize # => "scale_scores"
#
class String
  # Returns the plural form of the word in the string.
  #
  # If the optional parameter +count+ is specified,
  # the singular form will be returned if <tt>count == 1</tt>.
  # For any other value of +count+ the plural will be returned.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be pluralized as a word of that language.
  # By default, this parameter is set to <tt>:en</tt>.
  # You must define your own inflection rules for languages other than English.
  #
  #   'post'.pluralize             # => "posts"
  #   'octopus'.pluralize          # => "octopi"
  #   'sheep'.pluralize            # => "sheep"
  #   'words'.pluralize            # => "words"
  #   'the blue mailman'.pluralize # => "the blue mailmen"
  #   'CamelOctopus'.pluralize     # => "CamelOctopi"
  #   'apple'.pluralize(1)         # => "apple"
  #   'apple'.pluralize(2)         # => "apples"
  #   'ley'.pluralize(:es)         # => "leyes"
  #   'ley'.pluralize(1, :es)      # => "ley"
  #
  # See ActiveSupport::Inflector.pluralize.
  def pluralize(count = nil, locale = :en)
    locale = count if count.is_a?(Symbol)
    if count == 1
      dup
    else
      ActiveSupport::Inflector.pluralize(self, locale)
    end
  end

  # The reverse of +pluralize+, returns the singular form of a word in a string.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be singularized as a word of that language.
  # By default, this parameter is set to <tt>:en</tt>.
  # You must define your own inflection rules for languages other than English.
  #
  #   'posts'.singularize            # => "post"
  #   'octopi'.singularize           # => "octopus"
  #   'sheep'.singularize            # => "sheep"
  #   'word'.singularize             # => "word"
  #   'the blue mailmen'.singularize # => "the blue mailman"
  #   'CamelOctopi'.singularize      # => "CamelOctopus"
  #   'leyes'.singularize(:es)       # => "ley"
  #
  # See ActiveSupport::Inflector.singularize.
  def singularize(locale = :en)
    ActiveSupport::Inflector.singularize(self, locale)
  end

  # +constantize+ tries to find a declared constant with the name specified
  # in the string. It raises a NameError when the name is not in CamelCase
  # or is not initialized.
  #
  #   'Module'.constantize  # => Module
  #   'Class'.constantize   # => Class
  #   'blargle'.constantize # => NameError: wrong constant name blargle
  #
  # See ActiveSupport::Inflector.constantize.
  def constantize
    ActiveSupport::Inflector.constantize(self)
  end

  # +safe_constantize+ tries to find a declared constant with the name specified
  # in the string. It returns +nil+ when the name is not in CamelCase
  # or is not initialized.
  #
  #   'Module'.safe_constantize  # => Module
  #   'Class'.safe_constantize   # => Class
  #   'blargle'.safe_constantize # => nil
  #
  # See ActiveSupport::Inflector.safe_constantize.
  def safe_constantize
    ActiveSupport::Inflector.safe_constantize(self)
  end

  # By default, +camelize+ converts strings to UpperCamelCase. If the argument to camelize
  # is set to <tt>:lower</tt> then camelize produces lowerCamelCase.
  #
  # +camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.
  #
  #   'active_record'.camelize                # => "ActiveRecord"
  #   'active_record'.camelize(:lower)        # => "activeRecord"
  #   'active_record/errors'.camelize         # => "ActiveRecord::Errors"
  #   'active_record/errors'.camelize(:lower) # => "activeRecord::Errors"
  #
  # +camelize+ is also aliased as +camelcase+.
  #
  # See ActiveSupport::Inflector.camelize.
  def camelize(first_letter = :upper)
    case first_letter
    when :upper
      ActiveSupport::Inflector.camelize(self, true)
    when :lower
      ActiveSupport::Inflector.camelize(self, false)
    else
      raise ArgumentError, "Invalid option, use either :upper or :lower."
    end
  end
  alias_method :camelcase, :camelize

  # Capitalizes all the words and replaces some characters in the string to create
  # a nicer looking title. +titleize+ is meant for creating pretty output. It is not
  # used in the Rails internals.
  #
  # The trailing '_id','Id'.. can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  #   'man from the boondocks'.titleize                       # => "Man From The Boondocks"
  #   'x-men: the last stand'.titleize                        # => "X Men: The Last Stand"
  #   'string_ending_with_id'.titleize(keep_id_suffix: true)  # => "String Ending With Id"
  #
  # +titleize+ is also aliased as +titlecase+.
  #
  # See ActiveSupport::Inflector.titleize.
  def titleize(keep_id_suffix: false)
    ActiveSupport::Inflector.titleize(self, keep_id_suffix: keep_id_suffix)
  end
  alias_method :titlecase, :titleize

  # The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.
  #
  # +underscore+ will also change '::' to '/' to convert namespaces to paths.
  #
  #   'ActiveModel'.underscore         # => "active_model"
  #   'ActiveModel::Errors'.underscore # => "active_model/errors"
  #
  # See ActiveSupport::Inflector.underscore.
  def underscore
    ActiveSupport::Inflector.underscore(self)
  end

  # Replaces underscores with dashes in the string.
  #
  #   'puni_puni'.dasherize # => "puni-puni"
  #
  # See ActiveSupport::Inflector.dasherize.
  def dasherize
    ActiveSupport::Inflector.dasherize(self)
  end

  # Removes the module part from the constant expression in the string.
  #
  #   'ActiveSupport::Inflector::Inflections'.demodulize # => "Inflections"
  #   'Inflections'.demodulize                           # => "Inflections"
  #   '::Inflections'.demodulize                         # => "Inflections"
  #   ''.demodulize                                      # => ''
  #
  # See ActiveSupport::Inflector.demodulize.
  #
  # See also +deconstantize+.
  def demodulize
    ActiveSupport::Inflector.demodulize(self)
  end

  # Removes the rightmost segment from the constant expression in the string.
  #
  #   'Net::HTTP'.deconstantize   # => "Net"
  #   '::Net::HTTP'.deconstantize # => "::Net"
  #   'String'.deconstantize      # => ""
  #   '::String'.deconstantize    # => ""
  #   ''.deconstantize            # => ""
  #
  # See ActiveSupport::Inflector.deconstantize.
  #
  # See also +demodulize+.
  def deconstantize
    ActiveSupport::Inflector.deconstantize(self)
  end

  # Replaces special characters in a string so that it may be used as part of a 'pretty' URL.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be parameterized as a word of that language.
  # By default, this parameter is set to <tt>nil</tt> and it will use
  # the configured <tt>I18n.locale</tt>.
  #
  #   class Person
  #     def to_param
  #       "#{id}-#{name.parameterize}"
  #     end
  #   end
  #
  #   @person = Person.find(1)
  #   # => #<Person id: 1, name: "Donald E. Knuth">
  #
  #   <%= link_to(@person.name, person_path) %>
  #   # => <a href="/person/1-donald-e-knuth">Donald E. Knuth</a>
  #
  # To preserve the case of the characters in a string, use the +preserve_case+ argument.
  #
  #   class Person
  #     def to_param
  #       "#{id}-#{name.parameterize(preserve_case: true)}"
  #     end
  #   end
  #
  #   @person = Person.find(1)
  #   # => #<Person id: 1, name: "Donald E. Knuth">
  #
  #   <%= link_to(@person.name, person_path) %>
  #   # => <a href="/person/1-Donald-E-Knuth">Donald E. Knuth</a>
  #
  # See ActiveSupport::Inflector.parameterize.
  def parameterize(separator: "-", preserve_case: false, locale: nil)
    ActiveSupport::Inflector.parameterize(self, separator: separator, preserve_case: preserve_case, locale: locale)
  end

  # Creates the name of a table like Rails does for models to table names. This method
  # uses the +pluralize+ method on the last word in the string.
  #
  #   'RawScaledScorer'.tableize # => "raw_scaled_scorers"
  #   'ham_and_egg'.tableize     # => "ham_and_eggs"
  #   'fancyCategory'.tableize   # => "fancy_categories"
  #
  # See ActiveSupport::Inflector.tableize.
  def tableize
    ActiveSupport::Inflector.tableize(self)
  end

  # Creates a class name from a plural table name like Rails does for table names to models.
  # Note that this returns a string and not a class. (To convert to an actual class
  # follow +classify+ with +constantize+.)
  #
  #   'ham_and_eggs'.classify # => "HamAndEgg"
  #   'posts'.classify        # => "Post"
  #
  # See ActiveSupport::Inflector.classify.
  def classify
    ActiveSupport::Inflector.classify(self)
  end

  # Capitalizes the first word, turns underscores into spaces, and (by default)strips a
  # trailing '_id' if present.
  # Like +titleize+, this is meant for creating pretty output.
  #
  # The capitalization of the first word can be turned off by setting the
  # optional parameter +capitalize+ to false.
  # By default, this parameter is true.
  #
  # The trailing '_id' can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  #   'employee_salary'.humanize                    # => "Employee salary"
  #   'author_id'.humanize                          # => "Author"
  #   'author_id'.humanize(capitalize: false)       # => "author"
  #   '_id'.humanize                                # => "Id"
  #   'author_id'.humanize(keep_id_suffix: true)    # => "Author Id"
  #
  # See ActiveSupport::Inflector.humanize.
  def humanize(capitalize: true, keep_id_suffix: false)
    ActiveSupport::Inflector.humanize(self, capitalize: capitalize, keep_id_suffix: keep_id_suffix)
  end

  # Converts just the first character to uppercase.
  #
  #   'what a Lovely Day'.upcase_first # => "What a Lovely Day"
  #   'w'.upcase_first                 # => "W"
  #   ''.upcase_first                  # => ""
  #
  # See ActiveSupport::Inflector.upcase_first.
  def upcase_first
    ActiveSupport::Inflector.upcase_first(self)
  end

  # Creates a foreign key name from a class name.
  # +separate_class_name_and_id_with_underscore+ sets whether
  # the method should put '_' between the name and 'id'.
  #
  #   'Message'.foreign_key        # => "message_id"
  #   'Message'.foreign_key(false) # => "messageid"
  #   'Admin::Post'.foreign_key    # => "post_id"
  #
  # See ActiveSupport::Inflector.foreign_key.
  def foreign_key(separate_class_name_and_id_with_underscore = true)
# frozen_string_literal: true

class String
  # Same as +indent+, except it indents the receiver in-place.
  #
  # Returns the indented string, or +nil+ if there was nothing to indent.
  def indent!(amount, indent_string = nil, indent_empty_lines = false)
    indent_string = indent_string || self[/^[ \t]/] || " "
    re = indent_empty_lines ? /^/ : /^(?!$)/
    gsub!(re, indent_string * amount)
  end

  # Indents the lines in the receiver:
  #
  #   <<EOS.indent(2)
  #   def some_method
  #     some_code
  #   end
  #   EOS
  #   # =>
  #     def some_method
  #       some_code
  #     end
  #
  # The second argument, +indent_string+, specifies which indent string to
  # use. The default is +nil+, which tells the method to make a guess by
  # peeking at the first indented line, and fallback to a space if there is
  # none.
  #
  #   "  foo".indent(2)        # => "    foo"
  #   "foo\n\t\tbar".indent(2) # => "\t\tfoo\n\t\t\t\tbar"
  #   "foo".indent(2, "\t")    # => "\t\tfoo"
  #
  # While +indent_string+ is typically one space or tab, it may be any string.
  #
  # The third argument, +indent_empty_lines+, is a flag that says whether
  # empty lines should be indented. Default is false.
  #
  #   "foo\n\nbar".indent(2)            # => "  foo\n\n  bar"
  #   "foo\n\nbar".indent(2, nil, true) # => "  foo\n  \n  bar"
# frozen_string_literal: true

require "active_support/core_ext/time/acts_like"
require "active_support/core_ext/time/calculations"
require "active_support/core_ext/time/compatibility"
# frozen_string_literal: true

require "active_support/core_ext/string/conversions"
require "active_support/core_ext/string/filters"
require "active_support/core_ext/string/multibyte"
require "active_support/core_ext/string/starts_ends_with"
require "active_support/core_ext/string/inflections"
require "active_support/core_ext/string/access"
require "active_support/core_ext/string/behavior"
require "active_support/core_ext/string/output_safety"
# frozen_string_literal: true

class NameError
  # Extract the name of the missing constant from the exception message.
  #
  #   begin
  #     HelloWorld
  #   rescue NameError => e
  #     e.missing_name
  #   end
  #   # => "HelloWorld"
  def missing_name
    # Since ruby v2.3.0 `did_you_mean` gem is loaded by default.
    # It extends NameError#message with spell corrections which are SLOW.
    # We should use original_message message instead.
    message = respond_to?(:original_message) ? original_message : self.message
    return unless message.start_with?("uninitialized constant ")

    receiver = begin
      self.receiver
    rescue ArgumentError
      nil
    end

    if receiver == Object
      name.to_s
    elsif receiver
      "#{real_mod_name(receiver)}::#{self.name}"
    else
      if match = message.match(/((::)?([A-Z]\w*)(::[A-Z]\w*)*)$/)
        match[1]
      end
    end
  end

  # Was this exception raised because the given name was missing?
  #
  #   begin
  #     HelloWorld
  #   rescue NameError => e
  #     e.missing_name?("HelloWorld")
  #   end
  #   # => true
  def missing_name?(name)
    if name.is_a? Symbol
      self.name == name
    else
      missing_name == name.to_s
    end
  end

  private
    UNBOUND_METHOD_MODULE_NAME = Module.instance_method(:name)
    private_constant :UNBOUND_METHOD_MODULE_NAME

# frozen_string_literal: true

class Array
  # Wraps its argument in an array unless it is already an array (or array-like).
  #
  # Specifically:
  #
  # * If the argument is +nil+ an empty array is returned.
  # * Otherwise, if the argument responds to +to_ary+ it is invoked, and its result returned.
  # * Otherwise, returns an array with the argument as its single element.
  #
  #     Array.wrap(nil)       # => []
  #     Array.wrap([1, 2, 3]) # => [1, 2, 3]
  #     Array.wrap(0)         # => [0]
  #
  # This method is similar in purpose to <tt>Kernel#Array</tt>, but there are some differences:
  #
  # * If the argument responds to +to_ary+ the method is invoked. <tt>Kernel#Array</tt>
  #   moves on to try +to_a+ if the returned value is +nil+, but <tt>Array.wrap</tt> returns
  #   an array with the argument as its single element right away.
  # * If the returned value from +to_ary+ is neither +nil+ nor an +Array+ object, <tt>Kernel#Array</tt>
  #   raises an exception, while <tt>Array.wrap</tt> does not, it just returns the value.
  # * It does not call +to_a+ on the argument, if the argument does not respond to +to_ary+
  #   it returns an array with the argument as its single element.
  #
  # The last point is easily explained with some enumerables:
  #
  #   Array(foo: :bar)      # => [[:foo, :bar]]
  #   Array.wrap(foo: :bar) # => [{:foo=>:bar}]
  #
  # There's also a related idiom that uses the splat operator:
  #
  #   [*object]
  #
  # which returns <tt>[]</tt> for +nil+, but calls to <tt>Array(object)</tt> otherwise.
  #
  # The differences with <tt>Kernel#Array</tt> explained above
  # apply to the rest of <tt>object</tt>s.
  def self.wrap(object)
    if object.nil?
      []
    elsif object.respond_to?(:to_ary)
      object.to_ary || [object]
    else
      [object]
# frozen_string_literal: true

class Hash
  # By default, only instances of Hash itself are extractable.
  # Subclasses of Hash may implement this method and return
  # true to declare themselves as extractable. If a Hash
  # is extractable, Array#extract_options! pops it from
  # the Array when it is the last element of the Array.
  def extractable_options?
    instance_of?(Hash)
  end
end

class Array
  # Extracts options from a set of arguments. Removes and returns the last
  # element in the array if it's a hash, otherwise returns a blank hash.
  #
  #   def options(*args)
  #     args.extract_options!
  #   end
  #
  #   options(1, 2)        # => {}
  #   options(1, 2, a: :b) # => {:a=>:b}
  def extract_options!
    if last.is_a?(Hash) && last.extractable_options?
      pop
    else
      {}
    end
  end
# frozen_string_literal: true

require "active_support/xml_mini"
require "active_support/core_ext/hash/keys"
require "active_support/core_ext/string/inflections"
require "active_support/core_ext/object/to_param"
require "active_support/core_ext/object/to_query"

class Array
  # Converts the array to a comma-separated sentence where the last element is
  # joined by the connector word.
  #
  # You can pass the following options to change the default behavior. If you
  # pass an option key that doesn't exist in the list below, it will raise an
  # <tt>ArgumentError</tt>.
  #
  # ==== Options
  #
  # * <tt>:words_connector</tt> - The sign or word used to join the elements
  #   in arrays with two or more elements (default: ", ").
  # * <tt>:two_words_connector</tt> - The sign or word used to join the elements
  #   in arrays with two elements (default: " and ").
  # * <tt>:last_word_connector</tt> - The sign or word used to join the last element
  #   in arrays with three or more elements (default: ", and ").
  # * <tt>:locale</tt> - If +i18n+ is available, you can set a locale and use
  #   the connector options defined on the 'support.array' namespace in the
  #   corresponding dictionary file.
  #
  # ==== Examples
  #
  #   [].to_sentence                      # => ""
  #   ['one'].to_sentence                 # => "one"
  #   ['one', 'two'].to_sentence          # => "one and two"
  #   ['one', 'two', 'three'].to_sentence # => "one, two, and three"
  #
  #   ['one', 'two'].to_sentence(passing: 'invalid option')
  #   # => ArgumentError: Unknown key: :passing. Valid keys are: :words_connector, :two_words_connector, :last_word_connector, :locale
  #
  #   ['one', 'two'].to_sentence(two_words_connector: '-')
  #   # => "one-two"
  #
  #   ['one', 'two', 'three'].to_sentence(words_connector: ' or ', last_word_connector: ' or at least ')
  #   # => "one or two or at least three"
  #
  # Using <tt>:locale</tt> option:
  #
  #   # Given this locale dictionary:
  #   #
  #   #   es:
  #   #     support:
  #   #       array:
  #   #         words_connector: " o "
  #   #         two_words_connector: " y "
  #   #         last_word_connector: " o al menos "
  #
  #   ['uno', 'dos'].to_sentence(locale: :es)
  #   # => "uno y dos"
  #
  #   ['uno', 'dos', 'tres'].to_sentence(locale: :es)
  #   # => "uno o dos o al menos tres"
  def to_sentence(options = {})
    options.assert_valid_keys(:words_connector, :two_words_connector, :last_word_connector, :locale)

    default_connectors = {
      words_connector: ", ",
      two_words_connector: " and ",
      last_word_connector: ", and "
    }
    if defined?(I18n)
      i18n_connectors = I18n.translate(:'support.array', locale: options[:locale], default: {})
      default_connectors.merge!(i18n_connectors)
    end
    options = default_connectors.merge!(options)

    case length
    when 0
      +""
    when 1
      +"#{self[0]}"
    when 2
      +"#{self[0]}#{options[:two_words_connector]}#{self[1]}"
    else
      +"#{self[0...-1].join(options[:words_connector])}#{options[:last_word_connector]}#{self[-1]}"
    end
  end

  # Extends <tt>Array#to_s</tt> to convert a collection of elements into a
  # comma separated id list if <tt>:db</tt> argument is given as the format.
  #
  #   Blog.all.to_formatted_s(:db)  # => "1,2,3"
  #   Blog.none.to_formatted_s(:db) # => "null"
  #   [1,2].to_formatted_s          # => "[1, 2]"
  def to_formatted_s(format = :default)
    case format
    when :db
      if empty?
        "null"
      else
        collect(&:id).join(",")
      end
    else
      to_default_s
    end
  end
  alias_method :to_default_s, :to_s
  alias_method :to_s, :to_formatted_s

  # Returns a string that represents the array in XML by invoking +to_xml+
  # on each element. Active Record collections delegate their representation
  # in XML to this method.
  #
  # All elements are expected to respond to +to_xml+, if any of them does
  # not then an exception is raised.
  #
  # The root node reflects the class name of the first element in plural
  # if all elements belong to the same type and that's not Hash:
  #
  #   customer.projects.to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <projects type="array">
  #     <project>
  #       <amount type="decimal">20000.0</amount>
  #       <customer-id type="integer">1567</customer-id>
  #       <deal-date type="date">2008-04-09</deal-date>
  #       ...
  #     </project>
  #     <project>
  #       <amount type="decimal">57230.0</amount>
  #       <customer-id type="integer">1567</customer-id>
  #       <deal-date type="date">2008-04-15</deal-date>
  #       ...
  #     </project>
  #   </projects>
  #
  # Otherwise the root element is "objects":
  #
  #   [{ foo: 1, bar: 2}, { baz: 3}].to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <objects type="array">
  #     <object>
  #       <bar type="integer">2</bar>
  #       <foo type="integer">1</foo>
  #     </object>
  #     <object>
  #       <baz type="integer">3</baz>
  #     </object>
  #   </objects>
  #
  # If the collection is empty the root element is "nil-classes" by default:
  #
  #   [].to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <nil-classes type="array"/>
  #
  # To ensure a meaningful root element use the <tt>:root</tt> option:
  #
  #   customer_with_no_projects.projects.to_xml(root: 'projects')
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <projects type="array"/>
  #
  # By default name of the node for the children of root is <tt>root.singularize</tt>.
  # You can change it with the <tt>:children</tt> option.
  #
  # The +options+ hash is passed downwards:
  #
  #   Message.all.to_xml(skip_types: true)
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <messages>
  #     <message>
  #       <created-at>2008-03-07T09:58:18+01:00</created-at>
  #       <id>1</id>
  #       <name>1</name>
  #       <updated-at>2008-03-07T09:58:18+01:00</updated-at>
  #       <user-id>1</user-id>
  #     </message>
  #   </messages>
  #
  def to_xml(options = {})
    require "active_support/builder" unless defined?(Builder::XmlMarkup)

    options = options.dup
    options[:indent]  ||= 2
    options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])
    options[:root]    ||= \
      if first.class != Hash && all?(first.class)
        underscored = ActiveSupport::Inflector.underscore(first.class.name)
        ActiveSupport::Inflector.pluralize(underscored).tr("/", "_")
      else
        "objects"
      end

    builder = options[:builder]
    builder.instruct! unless options.delete(:skip_instruct)

    root = ActiveSupport::XmlMini.rename_key(options[:root].to_s, options)
    children = options.delete(:children) || root.singularize
    attributes = options[:skip_types] ? {} : { type: "array" }

    if empty?
      builder.tag!(root, attributes)
    else
      builder.tag!(root, attributes) do
        each { |value| ActiveSupport::XmlMini.to_tag(children, value, options) }
        yield builder if block_given?
      end
# frozen_string_literal: true

class Array
  # Returns the tail of the array from +position+.
  #
  #   %w( a b c d ).from(0)  # => ["a", "b", "c", "d"]
  #   %w( a b c d ).from(2)  # => ["c", "d"]
  #   %w( a b c d ).from(10) # => []
  #   %w().from(0)           # => []
  #   %w( a b c d ).from(-2) # => ["c", "d"]
  #   %w( a b c ).from(-10)  # => []
  def from(position)
    self[position, length] || []
  end

  # Returns the beginning of the array up to +position+.
  #
  #   %w( a b c d ).to(0)  # => ["a"]
  #   %w( a b c d ).to(2)  # => ["a", "b", "c"]
  #   %w( a b c d ).to(10) # => ["a", "b", "c", "d"]
  #   %w().to(0)           # => []
  #   %w( a b c d ).to(-2) # => ["a", "b", "c"]
  #   %w( a b c ).to(-10)  # => []
  def to(position)
    if position >= 0
      take position + 1
    else
      self[0..position]
    end
  end

  # Returns a new array that includes the passed elements.
  #
  #   [ 1, 2, 3 ].including(4, 5) # => [ 1, 2, 3, 4, 5 ]
  #   [ [ 0, 1 ] ].including([ [ 1, 0 ] ]) # => [ [ 0, 1 ], [ 1, 0 ] ]
  def including(*elements)
    self + elements.flatten(1)
  end

  # Returns a copy of the Array excluding the specified elements.
  #
  #   ["David", "Rafael", "Aaron", "Todd"].excluding("Aaron", "Todd") # => ["David", "Rafael"]
  #   [ [ 0, 1 ], [ 1, 0 ] ].excluding([ [ 1, 0 ] ]) # => [ [ 0, 1 ] ]
  #
  # Note: This is an optimization of <tt>Enumerable#excluding</tt> that uses <tt>Array#-</tt>
  # instead of <tt>Array#reject</tt> for performance reasons.
  def excluding(*elements)
    self - elements.flatten(1)
  end
  alias :without :excluding

  # Equal to <tt>self[1]</tt>.
  #
  #   %w( a b c d e ).second # => "b"
  def second
    self[1]
  end

  # Equal to <tt>self[2]</tt>.
  #
  #   %w( a b c d e ).third # => "c"
  def third
    self[2]
  end

  # Equal to <tt>self[3]</tt>.
  #
  #   %w( a b c d e ).fourth # => "d"
  def fourth
    self[3]
  end

  # Equal to <tt>self[4]</tt>.
  #
  #   %w( a b c d e ).fifth # => "e"
  def fifth
    self[4]
  end

  # Equal to <tt>self[41]</tt>. Also known as accessing "the reddit".
  #
  #   (1..42).to_a.forty_two # => 42
  def forty_two
    self[41]
  end

  # Equal to <tt>self[-3]</tt>.
  #
  #   %w( a b c d e ).third_to_last # => "c"
  def third_to_last
    self[-3]
  end

  # Equal to <tt>self[-2]</tt>.
  #
# frozen_string_literal: true

class Array
  # Removes and returns the elements for which the block returns a true value.
  # If no block is given, an Enumerator is returned instead.
  #
  #   numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #   odd_numbers = numbers.extract! { |number| number.odd? } # => [1, 3, 5, 7, 9]
  #   numbers # => [0, 2, 4, 6, 8]
  def extract!
    return to_enum(:extract!) { size } unless block_given?

    extracted_elements = []

    reject! do |element|
      extracted_elements << element if yield(element)
    end

    extracted_elements
  end
# frozen_string_literal: true

require "active_support/array_inquirer"

class Array
  # Wraps the array in an +ArrayInquirer+ object, which gives a friendlier way
  # to check its string-like contents.
  #
  #   pets = [:cat, :dog].inquiry
  #
  #   pets.cat?     # => true
  #   pets.ferret?  # => false
  #
  #   pets.any?(:cat, :ferret)  # => true
  #   pets.any?(:ferret, :alligator)  # => false
# frozen_string_literal: true

class Array
  # Splits or iterates over the array in groups of size +number+,
  # padding any remaining slots with +fill_with+ unless it is +false+.
  #
  #   %w(1 2 3 4 5 6 7 8 9 10).in_groups_of(3) {|group| p group}
  #   ["1", "2", "3"]
  #   ["4", "5", "6"]
  #   ["7", "8", "9"]
  #   ["10", nil, nil]
  #
  #   %w(1 2 3 4 5).in_groups_of(2, '&nbsp;') {|group| p group}
  #   ["1", "2"]
  #   ["3", "4"]
  #   ["5", "&nbsp;"]
  #
  #   %w(1 2 3 4 5).in_groups_of(2, false) {|group| p group}
  #   ["1", "2"]
  #   ["3", "4"]
  #   ["5"]
  def in_groups_of(number, fill_with = nil)
    if number.to_i <= 0
      raise ArgumentError,
        "Group size must be a positive integer, was #{number.inspect}"
    end

    if fill_with == false
      collection = self
    else
      # size % number gives how many extra we have;
      # subtracting from number gives how many to add;
      # modulo number ensures we don't add group of just fill.
      padding = (number - size % number) % number
      collection = dup.concat(Array.new(padding, fill_with))
    end

    if block_given?
      collection.each_slice(number) { |slice| yield(slice) }
    else
      collection.each_slice(number).to_a
    end
  end

  # Splits or iterates over the array in +number+ of groups, padding any
  # remaining slots with +fill_with+ unless it is +false+.
  #
  #   %w(1 2 3 4 5 6 7 8 9 10).in_groups(3) {|group| p group}
  #   ["1", "2", "3", "4"]
  #   ["5", "6", "7", nil]
  #   ["8", "9", "10", nil]
  #
  #   %w(1 2 3 4 5 6 7 8 9 10).in_groups(3, '&nbsp;') {|group| p group}
  #   ["1", "2", "3", "4"]
  #   ["5", "6", "7", "&nbsp;"]
  #   ["8", "9", "10", "&nbsp;"]
  #
  #   %w(1 2 3 4 5 6 7).in_groups(3, false) {|group| p group}
  #   ["1", "2", "3"]
  #   ["4", "5"]
  #   ["6", "7"]
  def in_groups(number, fill_with = nil)
    # size.div number gives minor group size;
    # size % number gives how many objects need extra accommodation;
    # each group hold either division or division + 1 items.
    division = size.div number
    modulo = size % number

    # create a new array avoiding dup
    groups = []
    start = 0

    number.times do |index|
      length = division + (modulo > 0 && modulo > index ? 1 : 0)
      groups << last_group = slice(start, length)
      last_group << fill_with if fill_with != false &&
        modulo > 0 && length == division
      start += length
    end

    if block_given?
      groups.each { |g| yield(g) }
    else
      groups
    end
  end

  # Divides the array into one or more subarrays based on a delimiting +value+
  # or the result of an optional block.
  #
  #   [1, 2, 3, 4, 5].split(3)              # => [[1, 2], [4, 5]]
  #   (1..10).to_a.split { |i| i % 3 == 0 } # => [[1, 2], [4, 5], [7, 8], [10]]
  def split(value = nil)
    arr = dup
    result = []
    if block_given?
      while (idx = arr.index { |i| yield i })
        result << arr.shift(idx)
        arr.shift
      end
    else
      while (idx = arr.index(value))
        result << arr.shift(idx)
        arr.shift
      end
# frozen_string_literal: true

module ActiveSupport
  # Reads a YAML configuration file, evaluating any ERB, then
  # parsing the resulting YAML.
  #
  # Warns in case of YAML confusing characters, like invisible
  # non-breaking spaces.
  class ConfigurationFile # :nodoc:
    class FormatError < StandardError; end

    def initialize(content_path)
      @content_path = content_path.to_s
      @content = read content_path
    end

    def self.parse(content_path, **options)
      new(content_path).parse(**options)
    end

    def parse(context: nil, **options)
      YAML.load(render(context), **options) || {}
    rescue Psych::SyntaxError => error
      raise "YAML syntax error occurred while parsing #{@content_path}. " \
            "Please note that YAML must be consistently indented using spaces. Tabs are not allowed. " \
            "Error: #{error.message}"
    end

    private
      def read(content_path)
        require "yaml"
        require "erb"

        File.read(content_path).tap do |content|
          if content.include?("\u00A0")
            warn "#{content_path} contains invisible non-breaking spaces, you may want to remove those"
          end
        end
      end

      def render(context)
        erb = ERB.new(@content).tap { |e| e.filename = @content_path }
        context ? erb.result(context) : erb.result
      end
  end
# frozen_string_literal: true

require "active_support/execution_wrapper"
require "active_support/executor"

module ActiveSupport
  #--
  # This class defines several callbacks:
  #
  #   to_prepare -- Run once at application startup, and also from
  #   +to_run+.
  #
  #   to_run -- Run before a work run that is reloading. If
  #   +reload_classes_only_on_change+ is true (the default), the class
  #   unload will have already occurred.
  #
  #   to_complete -- Run after a work run that has reloaded. If
  #   +reload_classes_only_on_change+ is false, the class unload will
  #   have occurred after the work run, but before this callback.
  #
  #   before_class_unload -- Run immediately before the classes are
  #   unloaded.
  #
  #   after_class_unload -- Run immediately after the classes are
  #   unloaded.
  #
  class Reloader < ExecutionWrapper
    define_callbacks :prepare

    define_callbacks :class_unload

    # Registers a callback that will run once at application startup and every time the code is reloaded.
    def self.to_prepare(*args, &block)
      set_callback(:prepare, *args, &block)
    end

    # Registers a callback that will run immediately before the classes are unloaded.
    def self.before_class_unload(*args, &block)
      set_callback(:class_unload, *args, &block)
    end

    # Registers a callback that will run immediately after the classes are unloaded.
    def self.after_class_unload(*args, &block)
      set_callback(:class_unload, :after, *args, &block)
    end

    to_run(:after) { self.class.prepare! }

    # Initiate a manual reload
    def self.reload!
      executor.wrap do
        new.tap do |instance|
          instance.run!
        ensure
          instance.complete!
        end
      end
      prepare!
    end

    def self.run! # :nodoc:
      if check!
        super
      else
        Null
      end
    end

    # Run the supplied block as a work unit, reloading code as needed
    def self.wrap
      executor.wrap do
        super
      end
    end

    class_attribute :executor, default: Executor
    class_attribute :check, default: lambda { false }

    def self.check! # :nodoc:
      @should_reload ||= check.call
    end

    def self.reloaded! # :nodoc:
      @should_reload = false
    end

    def self.prepare! # :nodoc:
      new.run_callbacks(:prepare)
    end

    def initialize
      super
      @locked = false
    end

    # Acquire the ActiveSupport::Dependencies::Interlock unload lock,
    # ensuring it will be released automatically
    def require_unload_lock!
      unless @locked
        ActiveSupport::Dependencies.interlock.start_unloading
        @locked = true
      end
    end

    # Release the unload lock if it has been previously obtained
    def release_unload_lock!
      if @locked
        @locked = false
        ActiveSupport::Dependencies.interlock.done_unloading
      end
    end

    def run! # :nodoc:
      super
      release_unload_lock!
    end

    def class_unload!(&block) # :nodoc:
      require_unload_lock!
      run_callbacks(:class_unload, &block)
    end

    def complete! # :nodoc:
      super
      self.class.reloaded!
# frozen_string_literal: true

require "active_support/concern"
require "active_support/core_ext/class/attribute"
require "active_support/core_ext/string/inflections"

module ActiveSupport
  # Rescuable module adds support for easier exception handling.
  module Rescuable
    extend Concern

    included do
      class_attribute :rescue_handlers, default: []
    end

    module ClassMethods
      # Registers exception classes with a handler to be called by <tt>rescue_with_handler</tt>.
      #
      # <tt>rescue_from</tt> receives a series of exception classes or class
      # names, and an exception handler specified by a trailing <tt>:with</tt>
      # option containing the name of a method or a Proc object. Alternatively, a block
      # can be given as the handler.
      #
      # Handlers that take one argument will be called with the exception, so
      # that the exception can be inspected when dealing with it.
      #
      # Handlers are inherited. They are searched from right to left, from
      # bottom to top, and up the hierarchy. The handler of the first class for
      # which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if
      # any.
      #
      #   class ApplicationController < ActionController::Base
      #     rescue_from User::NotAuthorized, with: :deny_access # self defined exception
      #     rescue_from ActiveRecord::RecordInvalid, with: :show_errors
      #
      #     rescue_from 'MyAppError::Base' do |exception|
      #       render xml: exception, status: 500
      #     end
      #
      #     private
      #       def deny_access
      #         ...
      #       end
      #
      #       def show_errors(exception)
      #         exception.record.new_record? ? ...
      #       end
      #   end
      #
      # Exceptions raised inside exception handlers are not propagated up.
      def rescue_from(*klasses, with: nil, &block)
        unless with
          if block_given?
            with = block
          else
            raise ArgumentError, "Need a handler. Pass the with: keyword argument or provide a block."
          end
        end

        klasses.each do |klass|
          key = if klass.is_a?(Module) && klass.respond_to?(:===)
            klass.name
          elsif klass.is_a?(String)
            klass
          else
            raise ArgumentError, "#{klass.inspect} must be an Exception class or a String referencing an Exception class"
          end

          # Put the new handler at the end because the list is read in reverse.
          self.rescue_handlers += [[key, with]]
        end
      end

      # Matches an exception to a handler based on the exception class.
      #
      # If no handler matches the exception, check for a handler matching the
      # (optional) exception.cause. If no handler matches the exception or its
      # cause, this returns +nil+, so you can deal with unhandled exceptions.
      # Be sure to re-raise unhandled exceptions if this is what you expect.
      #
      #     begin
      #       
      #     rescue => exception
      #       rescue_with_handler(exception) || raise
      #     end
      #
      # Returns the exception if it was handled and +nil+ if it was not.
      def rescue_with_handler(exception, object: self, visited_exceptions: [])
        visited_exceptions << exception

        if handler = handler_for_rescue(exception, object: object)
          handler.call exception
          exception
        elsif exception
          if visited_exceptions.include?(exception.cause)
            nil
          else
            rescue_with_handler(exception.cause, object: object, visited_exceptions: visited_exceptions)
          end
        end
      end

      def handler_for_rescue(exception, object: self) #:nodoc:
        case rescuer = find_rescue_handler(exception)
        when Symbol
          method = object.method(rescuer)
          if method.arity == 0
            -> e { method.call }
          else
            method
          end
        when Proc
          if rescuer.arity == 0
            -> e { object.instance_exec(&rescuer) }
          else
            -> e { object.instance_exec(e, &rescuer) }
          end
        end
      end

      private
        def find_rescue_handler(exception)
          if exception
            # Handlers are in order of declaration but the most recently declared
            # is the highest priority match, so we search for matching handlers
            # in reverse.
            _, handler = rescue_handlers.reverse_each.detect do |class_or_name, _|
              if klass = constantize_rescue_handler_class(class_or_name)
                klass === exception
              end
            end

            handler
          end
        end

        def constantize_rescue_handler_class(class_or_name)
          case class_or_name
          when String, Symbol
            begin
              # Try a lexical lookup first since we support
              #
              #     class Super
              #       rescue_from 'Error', with: 
              #     end
              #
              #     class Sub
              #       class Error < StandardError; end
              #     end
              #
              # so an Error raised in Sub will hit the 'Error' handler.
              const_get class_or_name
            rescue NameError
              class_or_name.safe_constantize
            end
          else
            class_or_name
          end
        end
    end

    # Delegates to the class method, but uses the instance as the subject for
    # rescue_from handlers (method calls, instance_exec blocks).
    def rescue_with_handler(exception)
      self.class.rescue_with_handler exception, object: self
    end

    # Internal handler lookup. Delegates to class method. Some libraries call
    # this directly, so keeping it around for compatibility.
    def handler_for_rescue(exception) #:nodoc:
# frozen_string_literal: true

module ActiveSupport
  # lazy_load_hooks allows Rails to lazily load a lot of components and thus
  # making the app boot faster. Because of this feature now there is no need to
  # require <tt>ActiveRecord::Base</tt> at boot time purely to apply
  # configuration. Instead a hook is registered that applies configuration once
  # <tt>ActiveRecord::Base</tt> is loaded. Here <tt>ActiveRecord::Base</tt> is
  # used as example but this feature can be applied elsewhere too.
  #
  # Here is an example where +on_load+ method is called to register a hook.
  #
  #   initializer 'active_record.initialize_timezone' do
  #     ActiveSupport.on_load(:active_record) do
  #       self.time_zone_aware_attributes = true
  #       self.default_timezone = :utc
  #     end
  #   end
  #
  # When the entirety of +ActiveRecord::Base+ has been
  # evaluated then +run_load_hooks+ is invoked. The very last line of
  # +ActiveRecord::Base+ is:
  #
  #   ActiveSupport.run_load_hooks(:active_record, ActiveRecord::Base)
  module LazyLoadHooks
    def self.extended(base) # :nodoc:
      base.class_eval do
        @load_hooks = Hash.new { |h, k| h[k] = [] }
        @loaded     = Hash.new { |h, k| h[k] = [] }
        @run_once   = Hash.new { |h, k| h[k] = [] }
      end
    end

    # Declares a block that will be executed when a Rails component is fully
    # loaded.
    #
    # Options:
    #
    # * <tt>:yield</tt> - Yields the object that run_load_hooks to +block+.
    # * <tt>:run_once</tt> - Given +block+ will run only once.
    def on_load(name, options = {}, &block)
      @loaded[name].each do |base|
        execute_hook(name, base, options, block)
      end

      @load_hooks[name] << [block, options]
    end

    def run_load_hooks(name, base = Object)
      @loaded[name] << base
      @load_hooks[name].each do |hook, options|
        execute_hook(name, base, options, hook)
      end
    end

    private
      def with_execution_control(name, block, once)
        unless @run_once[name].include?(block)
          @run_once[name] << block if once

          yield
        end
      end

      def execute_hook(name, base, options, block)
        with_execution_control(name, block, options[:run_once]) do
          if options[:yield]
            block.call(base)
          else
            if base.is_a?(Module)
              base.class_eval(&block)
            else
              base.instance_eval(&block)
            end
          end
        end
      end
  end

  extend LazyLoadHooks
# frozen_string_literal: true

require "zlib"
require "active_support/core_ext/array/extract_options"
require "active_support/core_ext/array/wrap"
require "active_support/core_ext/enumerable"
require "active_support/core_ext/module/attribute_accessors"
require "active_support/core_ext/numeric/bytes"
require "active_support/core_ext/numeric/time"
require "active_support/core_ext/object/to_param"
require "active_support/core_ext/object/try"
require "active_support/core_ext/string/inflections"

module ActiveSupport
  # See ActiveSupport::Cache::Store for documentation.
  module Cache
    autoload :FileStore,        "active_support/cache/file_store"
    autoload :MemoryStore,      "active_support/cache/memory_store"
    autoload :MemCacheStore,    "active_support/cache/mem_cache_store"
    autoload :NullStore,        "active_support/cache/null_store"
    autoload :RedisCacheStore,  "active_support/cache/redis_cache_store"

    # These options mean something to all cache implementations. Individual cache
    # implementations may support additional options.
    UNIVERSAL_OPTIONS = [:namespace, :compress, :compress_threshold, :expires_in, :expire_in, :expired_in, :race_condition_ttl, :coder, :skip_nil]

    # Mapping of canonical option names to aliases that a store will recognize.
    OPTION_ALIASES = {
      expires_in: [:expire_in, :expired_in]
    }.freeze

    module Strategy
      autoload :LocalCache, "active_support/cache/strategy/local_cache"
    end

    class << self
      # Creates a new Store object according to the given options.
      #
      # If no arguments are passed to this method, then a new
      # ActiveSupport::Cache::MemoryStore object will be returned.
      #
      # If you pass a Symbol as the first argument, then a corresponding cache
      # store class under the ActiveSupport::Cache namespace will be created.
      # For example:
      #
      #   ActiveSupport::Cache.lookup_store(:memory_store)
      #   # => returns a new ActiveSupport::Cache::MemoryStore object
      #
      #   ActiveSupport::Cache.lookup_store(:mem_cache_store)
      #   # => returns a new ActiveSupport::Cache::MemCacheStore object
      #
      # Any additional arguments will be passed to the corresponding cache store
      # class's constructor:
      #
      #   ActiveSupport::Cache.lookup_store(:file_store, '/tmp/cache')
      #   # => same as: ActiveSupport::Cache::FileStore.new('/tmp/cache')
      #
      # If the first argument is not a Symbol, then it will simply be returned:
      #
      #   ActiveSupport::Cache.lookup_store(MyOwnCacheStore.new)
      #   # => returns MyOwnCacheStore.new
      def lookup_store(store = nil, *parameters)
        case store
        when Symbol
          options = parameters.extract_options!
          # clean this up once Ruby 2.7 support is dropped
          # see https://github.com/rails/rails/pull/41522#discussion_r581186602
          if options.empty?
            retrieve_store_class(store).new(*parameters)
          else
            retrieve_store_class(store).new(*parameters, **options)
          end
        when Array
          lookup_store(*store)
        when nil
          ActiveSupport::Cache::MemoryStore.new
        else
          store
        end
      end

      # Expands out the +key+ argument into a key that can be used for the
      # cache store. Optionally accepts a namespace, and all keys will be
      # scoped within that namespace.
      #
      # If the +key+ argument provided is an array, or responds to +to_a+, then
      # each of elements in the array will be turned into parameters/keys and
      # concatenated into a single key. For example:
      #
      #   ActiveSupport::Cache.expand_cache_key([:foo, :bar])               # => "foo/bar"
      #   ActiveSupport::Cache.expand_cache_key([:foo, :bar], "namespace")  # => "namespace/foo/bar"
      #
      # The +key+ argument can also respond to +cache_key+ or +to_param+.
      def expand_cache_key(key, namespace = nil)
        expanded_cache_key = namespace ? +"#{namespace}/" : +""

        if prefix = ENV["RAILS_CACHE_ID"] || ENV["RAILS_APP_VERSION"]
          expanded_cache_key << "#{prefix}/"
        end

        expanded_cache_key << retrieve_cache_key(key)
        expanded_cache_key
      end

      private
        def retrieve_cache_key(key)
          case
          when key.respond_to?(:cache_key_with_version) then key.cache_key_with_version
          when key.respond_to?(:cache_key)              then key.cache_key
          when key.is_a?(Array)                         then key.map { |element| retrieve_cache_key(element) }.to_param
          when key.respond_to?(:to_a)                   then retrieve_cache_key(key.to_a)
          else                                               key.to_param
          end.to_s
        end

        # Obtains the specified cache store class, given the name of the +store+.
        # Raises an error when the store class cannot be found.
        def retrieve_store_class(store)
          # require_relative cannot be used here because the class might be
          # provided by another gem, like redis-activesupport for example.
          require "active_support/cache/#{store}"
        rescue LoadError => e
          raise "Could not find cache store adapter for #{store} (#{e})"
        else
          ActiveSupport::Cache.const_get(store.to_s.camelize)
        end
    end

    # An abstract cache store class. There are multiple cache store
    # implementations, each having its own additional features. See the classes
    # under the ActiveSupport::Cache module, e.g.
    # ActiveSupport::Cache::MemCacheStore. MemCacheStore is currently the most
    # popular cache store for large production websites.
    #
    # Some implementations may not support all methods beyond the basic cache
    # methods of +fetch+, +write+, +read+, +exist?+, and +delete+.
    #
    # ActiveSupport::Cache::Store can store any serializable Ruby object.
    #
    #   cache = ActiveSupport::Cache::MemoryStore.new
    #
    #   cache.read('city')   # => nil
    #   cache.write('city', "Duckburgh")
    #   cache.read('city')   # => "Duckburgh"
    #
    # Keys are always translated into Strings and are case sensitive. When an
    # object is specified as a key and has a +cache_key+ method defined, this
    # method will be called to define the key.  Otherwise, the +to_param+
    # method will be called. Hashes and Arrays can also be used as keys. The
    # elements will be delimited by slashes, and the elements within a Hash
    # will be sorted by key so they are consistent.
    #
    #   cache.read('city') == cache.read(:city)   # => true
    #
    # Nil values can be cached.
    #
    # If your cache is on a shared infrastructure, you can define a namespace
    # for your cache entries. If a namespace is defined, it will be prefixed on
    # to every key. The namespace can be either a static value or a Proc. If it
    # is a Proc, it will be invoked when each key is evaluated so that you can
    # use application logic to invalidate keys.
    #
    #   cache.namespace = -> { @last_mod_time }  # Set the namespace to a variable
    #   @last_mod_time = Time.now  # Invalidate the entire cache by changing namespace
    #
    # Cached data larger than 1kB are compressed by default. To turn off
    # compression, pass <tt>compress: false</tt> to the initializer or to
    # individual +fetch+ or +write+ method calls. The 1kB compression
    # threshold is configurable with the <tt>:compress_threshold</tt> option,
    # specified in bytes.
    class Store
      DEFAULT_CODER = Marshal

      cattr_accessor :logger, instance_writer: true

      attr_reader :silence, :options
      alias :silence? :silence

      class << self
        private
          def retrieve_pool_options(options)
            {}.tap do |pool_options|
              pool_options[:size] = options.delete(:pool_size) if options[:pool_size]
              pool_options[:timeout] = options.delete(:pool_timeout) if options[:pool_timeout]
            end
          end

          def ensure_connection_pool_added!
            require "connection_pool"
          rescue LoadError => e
            $stderr.puts "You don't have connection_pool installed in your application. Please add it to your Gemfile and run bundle install"
            raise e
          end
      end

      # Creates a new cache. The options will be passed to any write method calls
      # except for <tt>:namespace</tt> which can be used to set the global
      # namespace for the cache.
      def initialize(options = nil)
        @options = options ? normalize_options(options) : {}
        @coder = @options.delete(:coder) { self.class::DEFAULT_CODER } || NullCoder
      end

      # Silences the logger.
      def silence!
        @silence = true
        self
      end

      # Silences the logger within a block.
      def mute
        previous_silence, @silence = defined?(@silence) && @silence, true
        yield
      ensure
        @silence = previous_silence
      end

      # Fetches data from the cache, using the given key. If there is data in
      # the cache with the given key, then that data is returned.
      #
      # If there is no such data in the cache (a cache miss), then +nil+ will be
      # returned. However, if a block has been passed, that block will be passed
      # the key and executed in the event of a cache miss. The return value of the
      # block will be written to the cache under the given cache key, and that
      # return value will be returned.
      #
      #   cache.write('today', 'Monday')
      #   cache.fetch('today')  # => "Monday"
      #
      #   cache.fetch('city')   # => nil
      #   cache.fetch('city') do
      #     'Duckburgh'
      #   end
      #   cache.fetch('city')   # => "Duckburgh"
      #
      # You may also specify additional options via the +options+ argument.
      # Setting <tt>force: true</tt> forces a cache "miss," meaning we treat
      # the cache value as missing even if it's present. Passing a block is
      # required when +force+ is true so this always results in a cache write.
      #
      #   cache.write('today', 'Monday')
      #   cache.fetch('today', force: true) { 'Tuesday' } # => 'Tuesday'
      #   cache.fetch('today', force: true) # => ArgumentError
      #
      # The +:force+ option is useful when you're calling some other method to
      # ask whether you should force a cache write. Otherwise, it's clearer to
      # just call <tt>Cache#write</tt>.
      #
      # Setting <tt>skip_nil: true</tt> will not cache nil result:
      #
      #   cache.fetch('foo') { nil }
      #   cache.fetch('bar', skip_nil: true) { nil }
      #   cache.exist?('foo') # => true
      #   cache.exist?('bar') # => false
      #
      #
      # Setting <tt>compress: false</tt> disables compression of the cache entry.
      #
      # Setting <tt>:expires_in</tt> will set an expiration time on the cache.
      # All caches support auto-expiring content after a specified number of
      # seconds. This value can be specified as an option to the constructor
      # (in which case all entries will be affected), or it can be supplied to
      # the +fetch+ or +write+ method to affect just one entry.
      # <tt>:expire_in</tt> and <tt>:expired_in</tt> are aliases for
      # <tt>:expires_in</tt>.
      #
      #   cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 5.minutes)
      #   cache.write(key, value, expires_in: 1.minute) # Set a lower value for one entry
      #
      # Setting <tt>:version</tt> verifies the cache stored under <tt>name</tt>
      # is of the same version. nil is returned on mismatches despite contents.
      # This feature is used to support recyclable cache keys.
      #
      # Setting <tt>:race_condition_ttl</tt> is very useful in situations where
      # a cache entry is used very frequently and is under heavy load. If a
      # cache expires and due to heavy load several different processes will try
      # to read data natively and then they all will try to write to cache. To
      # avoid that case the first process to find an expired cache entry will
      # bump the cache expiration time by the value set in <tt>:race_condition_ttl</tt>.
      # Yes, this process is extending the time for a stale value by another few
      # seconds. Because of extended life of the previous cache, other processes
      # will continue to use slightly stale data for a just a bit longer. In the
      # meantime that first process will go ahead and will write into cache the
      # new value. After that all the processes will start getting the new value.
      # The key is to keep <tt>:race_condition_ttl</tt> small.
      #
      # If the process regenerating the entry errors out, the entry will be
      # regenerated after the specified number of seconds. Also note that the
      # life of stale cache is extended only if it expired recently. Otherwise
      # a new value is generated and <tt>:race_condition_ttl</tt> does not play
      # any role.
      #
      #   # Set all values to expire after one minute.
      #   cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 1.minute)
      #
      #   cache.write('foo', 'original value')
      #   val_1 = nil
      #   val_2 = nil
      #   sleep 60
      #
      #   Thread.new do
      #     val_1 = cache.fetch('foo', race_condition_ttl: 10.seconds) do
      #       sleep 1
      #       'new value 1'
      #     end
      #   end
      #
      #   Thread.new do
      #     val_2 = cache.fetch('foo', race_condition_ttl: 10.seconds) do
      #       'new value 2'
      #     end
      #   end
      #
      #   cache.fetch('foo') # => "original value"
      #   sleep 10 # First thread extended the life of cache by another 10 seconds
      #   cache.fetch('foo') # => "new value 1"
      #   val_1 # => "new value 1"
      #   val_2 # => "original value"
      #
      # Other options will be handled by the specific cache store implementation.
      # Internally, #fetch calls #read_entry, and calls #write_entry on a cache
      # miss. +options+ will be passed to the #read and #write calls.
      #
      # For example, MemCacheStore's #write method supports the +:raw+
      # option, which tells the memcached server to store all values as strings.
      # We can use this option with #fetch too:
      #
      #   cache = ActiveSupport::Cache::MemCacheStore.new
      #   cache.fetch("foo", force: true, raw: true) do
      #     :bar
      #   end
      #   cache.fetch('foo') # => "bar"
      def fetch(name, options = nil, &block)
        if block_given?
          options = merged_options(options)
          key = normalize_key(name, options)

          entry = nil
          instrument(:read, name, options) do |payload|
            cached_entry = read_entry(key, **options, event: payload) unless options[:force]
            entry = handle_expired_entry(cached_entry, key, options)
            entry = nil if entry && entry.mismatched?(normalize_version(name, options))
            payload[:super_operation] = :fetch if payload
            payload[:hit] = !!entry if payload
          end

          if entry
            get_entry_value(entry, name, options)
          else
            save_block_result_to_cache(name, options, &block)
          end
        elsif options && options[:force]
          raise ArgumentError, "Missing block: Calling `Cache#fetch` with `force: true` requires a block."
        else
          read(name, options)
        end
      end

      # Reads data from the cache, using the given key. If there is data in
      # the cache with the given key, then that data is returned. Otherwise,
      # +nil+ is returned.
      #
      # Note, if data was written with the <tt>:expires_in</tt> or
      # <tt>:version</tt> options, both of these conditions are applied before
      # the data is returned.
      #
      # Options are passed to the underlying cache implementation.
      def read(name, options = nil)
        options = merged_options(options)
        key     = normalize_key(name, options)
        version = normalize_version(name, options)

        instrument(:read, name, options) do |payload|
          entry = read_entry(key, **options, event: payload)

          if entry
            if entry.expired?
              delete_entry(key, **options)
              payload[:hit] = false if payload
              nil
            elsif entry.mismatched?(version)
              payload[:hit] = false if payload
              nil
            else
              payload[:hit] = true if payload
              entry.value
            end
          else
            payload[:hit] = false if payload
            nil
          end
        end
      end

      # Reads multiple values at once from the cache. Options can be passed
      # in the last argument.
      #
      # Some cache implementation may optimize this method.
      #
      # Returns a hash mapping the names provided to the values found.
      def read_multi(*names)
        options = names.extract_options!
        options = merged_options(options)

        instrument :read_multi, names, options do |payload|
          read_multi_entries(names, **options, event: payload).tap do |results|
            payload[:hits] = results.keys
          end
        end
      end

      # Cache Storage API to write multiple values at once.
      def write_multi(hash, options = nil)
        options = merged_options(options)

        instrument :write_multi, hash, options do |payload|
          entries = hash.each_with_object({}) do |(name, value), memo|
            memo[normalize_key(name, options)] = Entry.new(value, **options.merge(version: normalize_version(name, options)))
          end

          write_multi_entries entries, **options
        end
      end

      # Fetches data from the cache, using the given keys. If there is data in
      # the cache with the given keys, then that data is returned. Otherwise,
      # the supplied block is called for each key for which there was no data,
      # and the result will be written to the cache and returned.
      # Therefore, you need to pass a block that returns the data to be written
      # to the cache. If you do not want to write the cache when the cache is
      # not found, use #read_multi.
      #
      # Returns a hash with the data for each of the names. For example:
      #
      #   cache.write("bim", "bam")
      #   cache.fetch_multi("bim", "unknown_key") do |key|
      #     "Fallback value for key: #{key}"
      #   end
      #   # => { "bim" => "bam",
      #   #      "unknown_key" => "Fallback value for key: unknown_key" }
      #
      # Options are passed to the underlying cache implementation. For example:
      #
      #   cache.fetch_multi("fizz", expires_in: 5.seconds) do |key|
      #     "buzz"
      #   end
      #   # => {"fizz"=>"buzz"}
      #   cache.read("fizz")
      #   # => "buzz"
      #   sleep(6)
      #   cache.read("fizz")
      #   # => nil
      def fetch_multi(*names)
        raise ArgumentError, "Missing block: `Cache#fetch_multi` requires a block." unless block_given?

        options = names.extract_options!
        options = merged_options(options)

        instrument :read_multi, names, options do |payload|
          reads   = read_multi_entries(names, **options)
          writes  = {}
          ordered = names.index_with do |name|
            reads.fetch(name) { writes[name] = yield(name) }
          end

          payload[:hits] = reads.keys
          payload[:super_operation] = :fetch_multi

          write_multi(writes, options)

          ordered
        end
      end

      # Writes the value to the cache, with the key.
      #
      # Options are passed to the underlying cache implementation.
      def write(name, value, options = nil)
        options = merged_options(options)

        instrument(:write, name, options) do
          entry = Entry.new(value, **options.merge(version: normalize_version(name, options)))
          write_entry(normalize_key(name, options), entry, **options)
        end
      end

      # Deletes an entry in the cache. Returns +true+ if an entry is deleted.
      #
      # Options are passed to the underlying cache implementation.
      def delete(name, options = nil)
        options = merged_options(options)

        instrument(:delete, name) do
          delete_entry(normalize_key(name, options), **options)
        end
      end

      # Deletes multiple entries in the cache.
      #
      # Options are passed to the underlying cache implementation.
      def delete_multi(names, options = nil)
        options = merged_options(options)
        names.map! { |key| normalize_key(key, options) }

        instrument :delete_multi, names do
          delete_multi_entries(names, **options)
        end
      end

      # Returns +true+ if the cache contains an entry for the given key.
      #
      # Options are passed to the underlying cache implementation.
      def exist?(name, options = nil)
        options = merged_options(options)

        instrument(:exist?, name) do |payload|
          entry = read_entry(normalize_key(name, options), **options, event: payload)
          (entry && !entry.expired? && !entry.mismatched?(normalize_version(name, options))) || false
        end
      end

      # Deletes all entries with keys matching the pattern.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def delete_matched(matcher, options = nil)
        raise NotImplementedError.new("#{self.class.name} does not support delete_matched")
      end

      # Increments an integer value in the cache.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def increment(name, amount = 1, options = nil)
        raise NotImplementedError.new("#{self.class.name} does not support increment")
      end

      # Decrements an integer value in the cache.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def decrement(name, amount = 1, options = nil)
        raise NotImplementedError.new("#{self.class.name} does not support decrement")
      end

      # Cleanups the cache by removing expired entries.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def cleanup(options = nil)
        raise NotImplementedError.new("#{self.class.name} does not support cleanup")
      end

      # Clears the entire cache. Be careful with this method since it could
      # affect other processes if shared cache is being used.
      #
      # The options hash is passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def clear(options = nil)
        raise NotImplementedError.new("#{self.class.name} does not support clear")
      end

      private
        # Adds the namespace defined in the options to a pattern designed to
        # match keys. Implementations that support delete_matched should call
        # this method to translate a pattern that matches names into one that
        # matches namespaced keys.
        def key_matcher(pattern, options) # :doc:
          prefix = options[:namespace].is_a?(Proc) ? options[:namespace].call : options[:namespace]
          if prefix
            source = pattern.source
            if source.start_with?("^")
              source = source[1, source.length]
            else
              source = ".*#{source[0, source.length]}"
            end
            Regexp.new("^#{Regexp.escape(prefix)}:#{source}", pattern.options)
          else
            pattern
          end
        end

        # Reads an entry from the cache implementation. Subclasses must implement
        # this method.
        def read_entry(key, **options)
          raise NotImplementedError.new
        end

        # Writes an entry to the cache implementation. Subclasses must implement
        # this method.
        def write_entry(key, entry, **options)
          raise NotImplementedError.new
        end

        def serialize_entry(entry)
          @coder.dump(entry)
        end

        def deserialize_entry(payload)
          payload.nil? ? nil : @coder.load(payload)
        end

        # Reads multiple entries from the cache implementation. Subclasses MAY
        # implement this method.
        def read_multi_entries(names, **options)
          names.each_with_object({}) do |name, results|
            key   = normalize_key(name, options)
            entry = read_entry(key, **options)

            next unless entry

            version = normalize_version(name, options)

            if entry.expired?
              delete_entry(key, **options)
            elsif !entry.mismatched?(version)
              results[name] = entry.value
            end
          end
        end

        # Writes multiple entries to the cache implementation. Subclasses MAY
        # implement this method.
        def write_multi_entries(hash, **options)
          hash.each do |key, entry|
            write_entry key, entry, **options
          end
        end

        # Deletes an entry from the cache implementation. Subclasses must
        # implement this method.
        def delete_entry(key, **options)
          raise NotImplementedError.new
        end

        # Deletes multiples entries in the cache implementation. Subclasses MAY
        # implement this method.
        def delete_multi_entries(entries, **options)
          entries.count { |key| delete_entry(key, **options) }
        end

        # Merges the default options with ones specific to a method call.
        def merged_options(call_options)
          if call_options
            call_options = normalize_options(call_options)
            if options.empty?
              call_options
            else
              options.merge(call_options)
            end
          else
            options
          end
        end

        # Normalize aliased options to their canonical form
        def normalize_options(options)
          options = options.dup
          OPTION_ALIASES.each do |canonical_name, aliases|
            alias_key = aliases.detect { |key| options.key?(key) }
            options[canonical_name] ||= options[alias_key] if alias_key
            options.except!(*aliases)
          end
          options
        end

        # Expands and namespaces the cache key. May be overridden by
        # cache stores to do additional normalization.
        def normalize_key(key, options = nil)
          namespace_key expanded_key(key), options
        end

        # Prefix the key with a namespace string:
        #
        #   namespace_key 'foo', namespace: 'cache'
        #   # => 'cache:foo'
        #
        # With a namespace block:
        #
        #   namespace_key 'foo', namespace: -> { 'cache' }
        #   # => 'cache:foo'
        def namespace_key(key, options = nil)
          options = merged_options(options)
          namespace = options[:namespace]

          if namespace.respond_to?(:call)
            namespace = namespace.call
          end

          if key && key.encoding != Encoding::UTF_8
            key = key.dup.force_encoding(Encoding::UTF_8)
          end

          if namespace
            "#{namespace}:#{key}"
          else
            key
          end
        end

        # Expands key to be a consistent string value. Invokes +cache_key+ if
        # object responds to +cache_key+. Otherwise, +to_param+ method will be
        # called. If the key is a Hash, then keys will be sorted alphabetically.
        def expanded_key(key)
          return key.cache_key.to_s if key.respond_to?(:cache_key)

          case key
          when Array
            if key.size > 1
              key.collect { |element| expanded_key(element) }
            else
              expanded_key(key.first)
            end
          when Hash
            key.collect { |k, v| "#{k}=#{v}" }.sort!
          else
            key
          end.to_param
        end

        def normalize_version(key, options = nil)
          (options && options[:version].try(:to_param)) || expanded_version(key)
        end

        def expanded_version(key)
          case
          when key.respond_to?(:cache_version) then key.cache_version.to_param
          when key.is_a?(Array)                then key.map { |element| expanded_version(element) }.tap(&:compact!).to_param
          when key.respond_to?(:to_a)          then expanded_version(key.to_a)
          end
        end

        def instrument(operation, key, options = nil)
          if logger && logger.debug? && !silence?
            logger.debug "Cache #{operation}: #{normalize_key(key, options)}#{options.blank? ? "" : " (#{options.inspect})"}"
          end

          payload = { key: key, store: self.class.name }
          payload.merge!(options) if options.is_a?(Hash)
          ActiveSupport::Notifications.instrument("cache_#{operation}.active_support", payload) { yield(payload) }
        end

        def handle_expired_entry(entry, key, options)
          if entry && entry.expired?
            race_ttl = options[:race_condition_ttl].to_i
            if (race_ttl > 0) && (Time.now.to_f - entry.expires_at <= race_ttl)
              # When an entry has a positive :race_condition_ttl defined, put the stale entry back into the cache
              # for a brief period while the entry is being recalculated.
              entry.expires_at = Time.now + race_ttl
              write_entry(key, entry, expires_in: race_ttl * 2)
            else
              delete_entry(key, **options)
            end
            entry = nil
          end
          entry
        end

        def get_entry_value(entry, name, options)
          instrument(:fetch_hit, name, options) { }
          entry.value
        end

        def save_block_result_to_cache(name, options)
          result = instrument(:generate, name, options) do
            yield(name)
          end

          write(name, result, options) unless result.nil? && options[:skip_nil]
          result
        end
    end

    module NullCoder # :nodoc:
      class << self
        def load(payload)
          payload
        end

        def dump(entry)
          entry
        end
      end
    end

    # This class is used to represent cache entries. Cache entries have a value, an optional
    # expiration time, and an optional version. The expiration time is used to support the :race_condition_ttl option
    # on the cache. The version is used to support the :version option on the cache for rejecting
    # mismatches.
    #
    # Since cache entries in most instances will be serialized, the internals of this class are highly optimized
    # using short instance variable names that are lazily defined.
    class Entry # :nodoc:
      attr_reader :version

      DEFAULT_COMPRESS_LIMIT = 1.kilobyte

      # Creates a new cache entry for the specified value. Options supported are
      # +:compress+, +:compress_threshold+, +:version+ and +:expires_in+.
      def initialize(value, compress: true, compress_threshold: DEFAULT_COMPRESS_LIMIT, version: nil, expires_in: nil, **)
        @value      = value
        @version    = version
        @created_at = Time.now.to_f
        @expires_in = expires_in && expires_in.to_f

        compress!(compress_threshold) if compress
      end

      def value
        compressed? ? uncompress(@value) : @value
      end

      def mismatched?(version)
        @version && version && @version != version
      end

      # Checks if the entry is expired. The +expires_in+ parameter can override
      # the value set when the entry was created.
      def expired?
        @expires_in && @created_at + @expires_in <= Time.now.to_f
      end

      def expires_at
        @expires_in ? @created_at + @expires_in : nil
      end

      def expires_at=(value)
        if value
          @expires_in = value.to_f - @created_at
        else
          @expires_in = nil
        end
      end

      # Returns the size of the cached value. This could be less than
      # <tt>value.bytesize</tt> if the data is compressed.
      def bytesize
        case value
        when NilClass
          0
        when String
          @value.bytesize
        else
          @s ||= Marshal.dump(@value).bytesize
        end
      end

      # Duplicates the value in a class. This is used by cache implementations that don't natively
      # serialize entries to protect against accidental cache modifications.
      def dup_value!
        if @value && !compressed? && !(@value.is_a?(Numeric) || @value == true || @value == false)
          if @value.is_a?(String)
            @value = @value.dup
          else
            @value = Marshal.load(Marshal.dump(@value))
          end
        end
      end

      private
        def compress!(compress_threshold)
          case @value
          when nil, true, false, Numeric
            uncompressed_size = 0
          when String
            uncompressed_size = @value.bytesize
          else
            serialized = Marshal.dump(@value)
            uncompressed_size = serialized.bytesize
          end

          if uncompressed_size >= compress_threshold
            serialized ||= Marshal.dump(@value)
            compressed = Zlib::Deflate.deflate(serialized)

            if compressed.bytesize < uncompressed_size
              @value = compressed
              @compressed = true
            end
          end
        end

        def compressed?
          defined?(@compressed)
        end

        def uncompress(value)
          Marshal.load(Zlib::Inflate.inflate(value))
        end
    end
# frozen_string_literal: true

require "active_support/concern"
require "active_support/descendants_tracker"
require "active_support/core_ext/array/extract_options"
require "active_support/core_ext/class/attribute"
require "active_support/core_ext/string/filters"
require "thread"

module ActiveSupport
  # Callbacks are code hooks that are run at key points in an object's life cycle.
  # The typical use case is to have a base class define a set of callbacks
  # relevant to the other functionality it supplies, so that subclasses can
  # install callbacks that enhance or modify the base functionality without
  # needing to override or redefine methods of the base class.
  #
  # Mixing in this module allows you to define the events in the object's
  # life cycle that will support callbacks (via +ClassMethods.define_callbacks+),
  # set the instance methods, procs, or callback objects to be called (via
  # +ClassMethods.set_callback+), and run the installed callbacks at the
  # appropriate times (via +run_callbacks+).
  #
  # By default callbacks are halted by throwing +:abort+.
  # See +ClassMethods.define_callbacks+ for details.
  #
  # Three kinds of callbacks are supported: before callbacks, run before a
  # certain event; after callbacks, run after the event; and around callbacks,
  # blocks that surround the event, triggering it when they yield. Callback code
  # can be contained in instance methods, procs or lambdas, or callback objects
  # that respond to certain predetermined methods. See +ClassMethods.set_callback+
  # for details.
  #
  #   class Record
  #     include ActiveSupport::Callbacks
  #     define_callbacks :save
  #
  #     def save
  #       run_callbacks :save do
  #         puts "- save"
  #       end
  #     end
  #   end
  #
  #   class PersonRecord < Record
  #     set_callback :save, :before, :saving_message
  #     def saving_message
  #       puts "saving..."
  #     end
  #
  #     set_callback :save, :after do |object|
  #       puts "saved"
  #     end
  #   end
  #
  #   person = PersonRecord.new
  #   person.save
  #
  # Output:
  #   saving...
  #   - save
  #   saved
  module Callbacks
    extend Concern

    included do
      extend ActiveSupport::DescendantsTracker
      class_attribute :__callbacks, instance_writer: false, default: {}
    end

    CALLBACK_FILTER_TYPES = [:before, :after, :around]

    # Runs the callbacks for the given event.
    #
    # Calls the before and around callbacks in the order they were set, yields
    # the block (if given one), and then runs the after callbacks in reverse
    # order.
    #
    # If the callback chain was halted, returns +false+. Otherwise returns the
    # result of the block, +nil+ if no callbacks have been set, or +true+
    # if callbacks have been set but no block is given.
    #
    #   run_callbacks :save do
    #     save
    #   end
    #
    #--
    #
    # As this method is used in many places, and often wraps large portions of
    # user code, it has an additional design goal of minimizing its impact on
    # the visible call stack. An exception from inside a :before or :after
    # callback can be as noisy as it likes -- but when control has passed
    # smoothly through and into the supplied block, we want as little evidence
    # as possible that we were here.
    def run_callbacks(kind)
      callbacks = __callbacks[kind.to_sym]

      if callbacks.empty?
        yield if block_given?
      else
        env = Filters::Environment.new(self, false, nil)
        next_sequence = callbacks.compile

        # Common case: no 'around' callbacks defined
        if next_sequence.final?
          next_sequence.invoke_before(env)
          env.value = !env.halted && (!block_given? || yield)
          next_sequence.invoke_after(env)
          env.value
        else
          invoke_sequence = Proc.new do
            skipped = nil

            while true
              current = next_sequence
              current.invoke_before(env)
              if current.final?
                env.value = !env.halted && (!block_given? || yield)
              elsif current.skip?(env)
                (skipped ||= []) << current
                next_sequence = next_sequence.nested
                next
              else
                next_sequence = next_sequence.nested
                begin
                  target, block, method, *arguments = current.expand_call_template(env, invoke_sequence)
                  target.send(method, *arguments, &block)
                ensure
                  next_sequence = current
                end
              end
              current.invoke_after(env)
              skipped.pop.invoke_after(env) while skipped&.first
              break env.value
            end
          end

          invoke_sequence.call
        end
      end
    end

    private
      # A hook invoked every time a before callback is halted.
      # This can be overridden in ActiveSupport::Callbacks implementors in order
      # to provide better debugging/logging.
      def halted_callback_hook(filter, name)
      end

      module Conditionals # :nodoc:
        class Value
          def initialize(&block)
            @block = block
          end
          def call(target, value); @block.call(value); end
        end
      end

      module Filters
        Environment = Struct.new(:target, :halted, :value)

        class Before
          def self.build(callback_sequence, user_callback, user_conditions, chain_config, filter, name)
            halted_lambda = chain_config[:terminator]

            if user_conditions.any?
              halting_and_conditional(callback_sequence, user_callback, user_conditions, halted_lambda, filter, name)
            else
              halting(callback_sequence, user_callback, halted_lambda, filter, name)
            end
          end

          def self.halting_and_conditional(callback_sequence, user_callback, user_conditions, halted_lambda, filter, name)
            callback_sequence.before do |env|
              target = env.target
              value  = env.value
              halted = env.halted

              if !halted && user_conditions.all? { |c| c.call(target, value) }
                result_lambda = -> { user_callback.call target, value }
                env.halted = halted_lambda.call(target, result_lambda)
                if env.halted
                  target.send :halted_callback_hook, filter, name
                end
              end

              env
            end
          end
          private_class_method :halting_and_conditional

          def self.halting(callback_sequence, user_callback, halted_lambda, filter, name)
            callback_sequence.before do |env|
              target = env.target
              value  = env.value
              halted = env.halted

              unless halted
                result_lambda = -> { user_callback.call target, value }
                env.halted = halted_lambda.call(target, result_lambda)
                if env.halted
                  target.send :halted_callback_hook, filter, name
                end
              end

              env
            end
          end
          private_class_method :halting
        end

        class After
          def self.build(callback_sequence, user_callback, user_conditions, chain_config)
            if chain_config[:skip_after_callbacks_if_terminated]
              if user_conditions.any?
                halting_and_conditional(callback_sequence, user_callback, user_conditions)
              else
                halting(callback_sequence, user_callback)
              end
            else
              if user_conditions.any?
                conditional callback_sequence, user_callback, user_conditions
              else
                simple callback_sequence, user_callback
              end
            end
          end

          def self.halting_and_conditional(callback_sequence, user_callback, user_conditions)
            callback_sequence.after do |env|
              target = env.target
              value  = env.value
              halted = env.halted

              if !halted && user_conditions.all? { |c| c.call(target, value) }
                user_callback.call target, value
              end

              env
            end
          end
          private_class_method :halting_and_conditional

          def self.halting(callback_sequence, user_callback)
            callback_sequence.after do |env|
              unless env.halted
                user_callback.call env.target, env.value
              end

              env
            end
          end
          private_class_method :halting

          def self.conditional(callback_sequence, user_callback, user_conditions)
            callback_sequence.after do |env|
              target = env.target
              value  = env.value

              if user_conditions.all? { |c| c.call(target, value) }
                user_callback.call target, value
              end

              env
            end
          end
          private_class_method :conditional

          def self.simple(callback_sequence, user_callback)
            callback_sequence.after do |env|
              user_callback.call env.target, env.value

              env
            end
          end
          private_class_method :simple
        end
      end

      class Callback #:nodoc:#
        def self.build(chain, filter, kind, options)
          if filter.is_a?(String)
            raise ArgumentError, <<-MSG.squish
              Passing string to define a callback is not supported. See the `.set_callback`
              documentation to see supported values.
            MSG
          end

          new chain.name, filter, kind, options, chain.config
        end

        attr_accessor :kind, :name
        attr_reader :chain_config

        def initialize(name, filter, kind, options, chain_config)
          @chain_config = chain_config
          @name    = name
          @kind    = kind
          @filter  = filter
          @key     = compute_identifier filter
          @if      = check_conditionals(options[:if])
          @unless  = check_conditionals(options[:unless])
        end

        def filter; @key; end
        def raw_filter; @filter; end

        def merge_conditional_options(chain, if_option:, unless_option:)
          options = {
            if: @if.dup,
            unless: @unless.dup
          }

          options[:if].concat     Array(unless_option)
          options[:unless].concat Array(if_option)

          self.class.build chain, @filter, @kind, options
        end

        def matches?(_kind, _filter)
          @kind == _kind && filter == _filter
        end

        def duplicates?(other)
          case @filter
          when Symbol
            matches?(other.kind, other.filter)
          else
            false
          end
        end

        # Wraps code with filter
        def apply(callback_sequence)
          user_conditions = conditions_lambdas
          user_callback = CallTemplate.build(@filter, self)

          case kind
          when :before
            Filters::Before.build(callback_sequence, user_callback.make_lambda, user_conditions, chain_config, @filter, name)
          when :after
            Filters::After.build(callback_sequence, user_callback.make_lambda, user_conditions, chain_config)
          when :around
            callback_sequence.around(user_callback, user_conditions)
          end
        end

        def current_scopes
          Array(chain_config[:scope]).map { |s| public_send(s) }
        end

        private
          EMPTY_ARRAY = [].freeze
          private_constant :EMPTY_ARRAY

          def check_conditionals(conditionals)
            return EMPTY_ARRAY if conditionals.blank?

            conditionals = Array(conditionals)
            if conditionals.any?(String)
              raise ArgumentError, <<-MSG.squish
                Passing string to be evaluated in :if and :unless conditional
                options is not supported. Pass a symbol for an instance method,
                or a lambda, proc or block, instead.
              MSG
            end

            conditionals.freeze
          end

          def compute_identifier(filter)
            case filter
            when ::Proc
              filter.object_id
            else
              filter
            end
          end

          def conditions_lambdas
            @if.map { |c| CallTemplate.build(c, self).make_lambda } +
              @unless.map { |c| CallTemplate.build(c, self).inverted_lambda }
          end
      end

      # A future invocation of user-supplied code (either as a callback,
      # or a condition filter).
      class CallTemplate # :nodoc:
        def initialize(target, method, arguments, block)
          @override_target = target
          @method_name = method
          @arguments = arguments
          @override_block = block
        end

        # Return the parts needed to make this call, with the given
        # input values.
        #
        # Returns an array of the form:
        #
        #   [target, block, method, *arguments]
        #
        # This array can be used as such:
        #
        #   target.send(method, *arguments, &block)
        #
        # The actual invocation is left up to the caller to minimize
        # call stack pollution.
        def expand(target, value, block)
          expanded = [@override_target || target, @override_block || block, @method_name]

          @arguments.each do |arg|
            case arg
            when :value then expanded << value
            when :target then expanded << target
            when :block then expanded << (block || raise(ArgumentError))
            end
          end

          expanded
        end

        # Return a lambda that will make this call when given the input
        # values.
        def make_lambda
          lambda do |target, value, &block|
            target, block, method, *arguments = expand(target, value, block)
            target.send(method, *arguments, &block)
          end
        end

        # Return a lambda that will make this call when given the input
        # values, but then return the boolean inverse of that result.
        def inverted_lambda
          lambda do |target, value, &block|
            target, block, method, *arguments = expand(target, value, block)
            ! target.send(method, *arguments, &block)
          end
        end

        # Filters support:
        #
        #   Symbols:: A method to call.
        #   Procs::   A proc to call with the object.
        #   Objects:: An object with a <tt>before_foo</tt> method on it to call.
        #
        # All of these objects are converted into a CallTemplate and handled
        # the same after this point.
        def self.build(filter, callback)
          case filter
          when Symbol
            new(nil, filter, [], nil)
          when Conditionals::Value
            new(filter, :call, [:target, :value], nil)
          when ::Proc
            if filter.arity > 1
              new(nil, :instance_exec, [:target, :block], filter)
            elsif filter.arity > 0
              new(nil, :instance_exec, [:target], filter)
            else
              new(nil, :instance_exec, [], filter)
            end
          else
            method_to_call = callback.current_scopes.join("_")

            new(filter, method_to_call, [:target], nil)
          end
        end
      end

      # Execute before and after filters in a sequence instead of
      # chaining them with nested lambda calls, see:
      # https://github.com/rails/rails/issues/18011
      class CallbackSequence # :nodoc:
        def initialize(nested = nil, call_template = nil, user_conditions = nil)
          @nested = nested
          @call_template = call_template
          @user_conditions = user_conditions

          @before = []
          @after = []
        end

        def before(&before)
          @before.unshift(before)
          self
        end

        def after(&after)
          @after.push(after)
          self
        end

        def around(call_template, user_conditions)
          CallbackSequence.new(self, call_template, user_conditions)
        end

        def skip?(arg)
          arg.halted || !@user_conditions.all? { |c| c.call(arg.target, arg.value) }
        end

        attr_reader :nested

        def final?
          !@call_template
        end

        def expand_call_template(arg, block)
          @call_template.expand(arg.target, arg.value, block)
        end

        def invoke_before(arg)
          @before.each { |b| b.call(arg) }
        end

        def invoke_after(arg)
          @after.each { |a| a.call(arg) }
        end
      end

      class CallbackChain #:nodoc:#
        include Enumerable

        attr_reader :name, :config

        def initialize(name, config)
          @name = name
          @config = {
            scope: [:kind],
            terminator: default_terminator
          }.merge!(config)
          @chain = []
          @callbacks = nil
          @mutex = Mutex.new
        end

        def each(&block); @chain.each(&block); end
        def index(o);     @chain.index(o); end
        def empty?;       @chain.empty?; end

        def insert(index, o)
          @callbacks = nil
          @chain.insert(index, o)
        end

        def delete(o)
          @callbacks = nil
          @chain.delete(o)
        end

        def clear
          @callbacks = nil
          @chain.clear
          self
        end

        def initialize_copy(other)
          @callbacks = nil
          @chain     = other.chain.dup
          @mutex     = Mutex.new
        end

        def compile
          @callbacks || @mutex.synchronize do
            final_sequence = CallbackSequence.new
            @callbacks ||= @chain.reverse.inject(final_sequence) do |callback_sequence, callback|
              callback.apply callback_sequence
            end
          end
        end

        def append(*callbacks)
          callbacks.each { |c| append_one(c) }
        end

        def prepend(*callbacks)
          callbacks.each { |c| prepend_one(c) }
        end

        protected
          attr_reader :chain

        private
          def append_one(callback)
            @callbacks = nil
            remove_duplicates(callback)
            @chain.push(callback)
          end

          def prepend_one(callback)
            @callbacks = nil
            remove_duplicates(callback)
            @chain.unshift(callback)
          end

          def remove_duplicates(callback)
            @callbacks = nil
            @chain.delete_if { |c| callback.duplicates?(c) }
          end

          def default_terminator
            Proc.new do |target, result_lambda|
              terminate = true
              catch(:abort) do
                result_lambda.call
                terminate = false
              end
              terminate
            end
          end
      end

      module ClassMethods
        def normalize_callback_params(filters, block) # :nodoc:
          type = CALLBACK_FILTER_TYPES.include?(filters.first) ? filters.shift : :before
          options = filters.extract_options!
          filters.unshift(block) if block
          [type, filters, options.dup]
        end

        # This is used internally to append, prepend and skip callbacks to the
        # CallbackChain.
        def __update_callbacks(name) #:nodoc:
          ([self] + ActiveSupport::DescendantsTracker.descendants(self)).reverse_each do |target|
            chain = target.get_callbacks name
            yield target, chain.dup
          end
        end

        # Install a callback for the given event.
        #
        #   set_callback :save, :before, :before_method
        #   set_callback :save, :after,  :after_method, if: :condition
        #   set_callback :save, :around, ->(r, block) { stuff; result = block.call; stuff }
        #
        # The second argument indicates whether the callback is to be run +:before+,
        # +:after+, or +:around+ the event. If omitted, +:before+ is assumed. This
        # means the first example above can also be written as:
        #
        #   set_callback :save, :before_method
        #
        # The callback can be specified as a symbol naming an instance method; as a
        # proc, lambda, or block; or as an object that responds to a certain method
        # determined by the <tt>:scope</tt> argument to +define_callbacks+.
        #
        # If a proc, lambda, or block is given, its body is evaluated in the context
        # of the current object. It can also optionally accept the current object as
        # an argument.
        #
        # Before and around callbacks are called in the order that they are set;
        # after callbacks are called in the reverse order.
        #
        # Around callbacks can access the return value from the event, if it
        # wasn't halted, from the +yield+ call.
        #
        # ===== Options
        #
        # * <tt>:if</tt> - A symbol or an array of symbols, each naming an instance
        #   method or a proc; the callback will be called only when they all return
        #   a true value.
        #
        #   If a proc is given, its body is evaluated in the context of the
        #   current object. It can also optionally accept the current object as
        #   an argument.
        # * <tt>:unless</tt> - A symbol or an array of symbols, each naming an
        #   instance method or a proc; the callback will be called only when they
        #   all return a false value.
        #
        #   If a proc is given, its body is evaluated in the context of the
        #   current object. It can also optionally accept the current object as
        #   an argument.
        # * <tt>:prepend</tt> - If +true+, the callback will be prepended to the
        #   existing chain rather than appended.
        def set_callback(name, *filter_list, &block)
          type, filters, options = normalize_callback_params(filter_list, block)

          self_chain = get_callbacks name
          mapped = filters.map do |filter|
            Callback.build(self_chain, filter, type, options)
          end

          __update_callbacks(name) do |target, chain|
            options[:prepend] ? chain.prepend(*mapped) : chain.append(*mapped)
            target.set_callbacks name, chain
          end
        end

        # Skip a previously set callback. Like +set_callback+, <tt>:if</tt> or
        # <tt>:unless</tt> options may be passed in order to control when the
        # callback is skipped.
        #
        #   class Writer < Person
        #      skip_callback :validate, :before, :check_membership, if: -> { age > 18 }
        #   end
        #
        # An <tt>ArgumentError</tt> will be raised if the callback has not
        # already been set (unless the <tt>:raise</tt> option is set to <tt>false</tt>).
        def skip_callback(name, *filter_list, &block)
          type, filters, options = normalize_callback_params(filter_list, block)

          options[:raise] = true unless options.key?(:raise)

          __update_callbacks(name) do |target, chain|
            filters.each do |filter|
              callback = chain.find { |c| c.matches?(type, filter) }

              if !callback && options[:raise]
                raise ArgumentError, "#{type.to_s.capitalize} #{name} callback #{filter.inspect} has not been defined"
              end

              if callback && (options.key?(:if) || options.key?(:unless))
                new_callback = callback.merge_conditional_options(chain, if_option: options[:if], unless_option: options[:unless])
                chain.insert(chain.index(callback), new_callback)
              end

              chain.delete(callback)
            end
            target.set_callbacks name, chain
          end
        end

        # Remove all set callbacks for the given event.
        def reset_callbacks(name)
          callbacks = get_callbacks name

          ActiveSupport::DescendantsTracker.descendants(self).each do |target|
            chain = target.get_callbacks(name).dup
            callbacks.each { |c| chain.delete(c) }
            target.set_callbacks name, chain
          end

          set_callbacks(name, callbacks.dup.clear)
        end

        # Define sets of events in the object life cycle that support callbacks.
        #
        #   define_callbacks :validate
        #   define_callbacks :initialize, :save, :destroy
        #
        # ===== Options
        #
        # * <tt>:terminator</tt> - Determines when a before filter will halt the
        #   callback chain, preventing following before and around callbacks from
        #   being called and the event from being triggered.
        #   This should be a lambda to be executed.
        #   The current object and the result lambda of the callback will be provided
        #   to the terminator lambda.
        #
        #     define_callbacks :validate, terminator: ->(target, result_lambda) { result_lambda.call == false }
        #
        #   In this example, if any before validate callbacks returns +false+,
        #   any successive before and around callback is not executed.
        #
        #   The default terminator halts the chain when a callback throws +:abort+.
        #
        # * <tt>:skip_after_callbacks_if_terminated</tt> - Determines if after
        #   callbacks should be terminated by the <tt>:terminator</tt> option. By
        #   default after callbacks are executed no matter if callback chain was
        #   terminated or not. This option has no effect if <tt>:terminator</tt>
        #   option is set to +nil+.
        #
        # * <tt>:scope</tt> - Indicates which methods should be executed when an
        #   object is used as a callback.
        #
        #     class Audit
        #       def before(caller)
        #         puts 'Audit: before is called'
        #       end
        #
        #       def before_save(caller)
        #         puts 'Audit: before_save is called'
        #       end
        #     end
        #
        #     class Account
        #       include ActiveSupport::Callbacks
        #
        #       define_callbacks :save
        #       set_callback :save, :before, Audit.new
        #
        #       def save
        #         run_callbacks :save do
        #           puts 'save in main'
        #         end
        #       end
        #     end
        #
        #   In the above case whenever you save an account the method
        #   <tt>Audit#before</tt> will be called. On the other hand
        #
        #     define_callbacks :save, scope: [:kind, :name]
        #
        #   would trigger <tt>Audit#before_save</tt> instead. That's constructed
        #   by calling <tt>#{kind}_#{name}</tt> on the given instance. In this
        #   case "kind" is "before" and "name" is "save". In this context +:kind+
        #   and +:name+ have special meanings: +:kind+ refers to the kind of
        #   callback (before/after/around) and +:name+ refers to the method on
        #   which callbacks are being defined.
        #
        #   A declaration like
        #
        #     define_callbacks :save, scope: [:name]
        #
        #   would call <tt>Audit#save</tt>.
        #
        # ===== Notes
        #
        # +names+ passed to +define_callbacks+ must not end with
        # <tt>!</tt>, <tt>?</tt> or <tt>=</tt>.
        #
        # Calling +define_callbacks+ multiple times with the same +names+ will
        # overwrite previous callbacks registered with +set_callback+.
        def define_callbacks(*names)
          options = names.extract_options!

          names.each do |name|
            name = name.to_sym

            ([self] + ActiveSupport::DescendantsTracker.descendants(self)).each do |target|
              target.set_callbacks name, CallbackChain.new(name, options)
            end

            module_eval <<-RUBY, __FILE__, __LINE__ + 1
              def _run_#{name}_callbacks(&block)
                run_callbacks #{name.inspect}, &block
              end

              def self._#{name}_callbacks
                get_callbacks(#{name.inspect})
              end

              def self._#{name}_callbacks=(value)
                set_callbacks(#{name.inspect}, value)
              end

              def _#{name}_callbacks
                __callbacks[#{name.inspect}]
              end
            RUBY
          end
        end

        protected
          def get_callbacks(name) # :nodoc:
            __callbacks[name.to_sym]
          end

          def set_callbacks(name, callbacks) # :nodoc:
            unless singleton_class.method_defined?(:__callbacks, false)
              self.__callbacks = __callbacks.dup
            end
            self.__callbacks[name.to_sym] = callbacks
            self.__callbacks
          end
      end
  end
# frozen_string_literal: true

require "active_support/concern"
require "active_support/ordered_options"

module ActiveSupport
  # Configurable provides a <tt>config</tt> method to store and retrieve
  # configuration options as an <tt>OrderedOptions</tt>.
  module Configurable
    extend ActiveSupport::Concern

    class Configuration < ActiveSupport::InheritableOptions
      def compile_methods!
        self.class.compile_methods!(keys)
      end

      # Compiles reader methods so we don't have to go through method_missing.
      def self.compile_methods!(keys)
        keys.reject { |m| method_defined?(m) }.each do |key|
          class_eval <<-RUBY, __FILE__, __LINE__ + 1
            def #{key}; _get(#{key.inspect}); end
          RUBY
        end
      end
    end

    module ClassMethods
      def config
        @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
          superclass.config.inheritable_copy
        else
          # create a new "anonymous" class that will host the compiled reader methods
          Class.new(Configuration).new
        end
      end

      def configure
        yield config
      end

      # Allows you to add shortcut so that you don't have to refer to attribute
      # through config. Also look at the example for config to contrast.
      #
      # Defines both class and instance config accessors.
      #
      #   class User
      #     include ActiveSupport::Configurable
      #     config_accessor :allowed_access
      #   end
      #
      #   User.allowed_access # => nil
      #   User.allowed_access = false
      #   User.allowed_access # => false
      #
      #   user = User.new
      #   user.allowed_access # => false
      #   user.allowed_access = true
      #   user.allowed_access # => true
      #
      #   User.allowed_access # => false
      #
      # The attribute name must be a valid method name in Ruby.
      #
      #   class User
      #     include ActiveSupport::Configurable
      #     config_accessor :"1_Badname"
      #   end
      #   # => NameError: invalid config attribute name
      #
      # To omit the instance writer method, pass <tt>instance_writer: false</tt>.
      # To omit the instance reader method, pass <tt>instance_reader: false</tt>.
      #
      #   class User
      #     include ActiveSupport::Configurable
      #     config_accessor :allowed_access, instance_reader: false, instance_writer: false
      #   end
      #
      #   User.allowed_access = false
      #   User.allowed_access # => false
      #
      #   User.new.allowed_access = true # => NoMethodError
      #   User.new.allowed_access        # => NoMethodError
      #
      # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.
      #
      #   class User
      #     include ActiveSupport::Configurable
      #     config_accessor :allowed_access, instance_accessor: false
      #   end
      #
      #   User.allowed_access = false
      #   User.allowed_access # => false
      #
      #   User.new.allowed_access = true # => NoMethodError
      #   User.new.allowed_access        # => NoMethodError
      #
      # Also you can pass a block to set up the attribute with a default value.
      #
      #   class User
      #     include ActiveSupport::Configurable
      #     config_accessor :hair_colors do
      #       [:brown, :black, :blonde, :red]
      #     end
      #   end
      #
      #   User.hair_colors # => [:brown, :black, :blonde, :red]
      def config_accessor(*names, instance_reader: true, instance_writer: true, instance_accessor: true) # :doc:
        names.each do |name|
          raise NameError.new("invalid config attribute name") unless /\A[_A-Za-z]\w*\z/.match?(name)

          reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
          writer, writer_line = "def #{name}=(value); config.#{name} = value; end", __LINE__

          singleton_class.class_eval reader, __FILE__, reader_line
          singleton_class.class_eval writer, __FILE__, writer_line

          if instance_accessor
            class_eval reader, __FILE__, reader_line if instance_reader
            class_eval writer, __FILE__, writer_line if instance_writer
          end
          send("#{name}=", yield) if block_given?
        end
      end
      private :config_accessor
    end

    # Reads and writes attributes from a configuration <tt>OrderedOptions</tt>.
    #
    #   require "active_support/configurable"
    #
    #   class User
    #     include ActiveSupport::Configurable
    #   end
    #
    #   user = User.new
    #
    #   user.config.allowed_access = true
    #   user.config.level = 1
    #
    #   user.config.allowed_access # => true
    #   user.config.level          # => 1
    def config
      @_config ||= self.class.config.inheritable_copy
    end
  end
# frozen_string_literal: true

require "active_support/core_ext/hash/keys"
require "active_support/core_ext/hash/reverse_merge"
require "active_support/core_ext/hash/except"

module ActiveSupport
  # Implements a hash where keys <tt>:foo</tt> and <tt>"foo"</tt> are considered
  # to be the same.
  #
  #   rgb = ActiveSupport::HashWithIndifferentAccess.new
  #
  #   rgb[:black] = '#000000'
  #   rgb[:black]  # => '#000000'
  #   rgb['black'] # => '#000000'
  #
  #   rgb['white'] = '#FFFFFF'
  #   rgb[:white]  # => '#FFFFFF'
  #   rgb['white'] # => '#FFFFFF'
  #
  # Internally symbols are mapped to strings when used as keys in the entire
  # writing interface (calling <tt>[]=</tt>, <tt>merge</tt>, etc). This
  # mapping belongs to the public interface. For example, given:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)
  #
  # You are guaranteed that the key is returned as a string:
  #
  #   hash.keys # => ["a"]
  #
  # Technically other types of keys are accepted:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)
  #   hash[0] = 0
  #   hash # => {"a"=>1, 0=>0}
  #
  # but this class is intended for use cases where strings or symbols are the
  # expected keys and it is convenient to understand both as the same. For
  # example the +params+ hash in Ruby on Rails.
  #
  # Note that core extensions define <tt>Hash#with_indifferent_access</tt>:
  #
  #   rgb = { black: '#000000', white: '#FFFFFF' }.with_indifferent_access
  #
  # which may be handy.
  #
  # To access this class outside of Rails, require the core extension with:
  #
  #   require "active_support/core_ext/hash/indifferent_access"
  #
  # which will, in turn, require this file.
  class HashWithIndifferentAccess < Hash
    # Returns +true+ so that <tt>Array#extract_options!</tt> finds members of
    # this class.
    def extractable_options?
      true
    end

    def with_indifferent_access
      dup
    end

    def nested_under_indifferent_access
      self
    end

    def initialize(constructor = nil)
      if constructor.respond_to?(:to_hash)
        super()
        update(constructor)

        hash = constructor.is_a?(Hash) ? constructor : constructor.to_hash
        self.default = hash.default if hash.default
        self.default_proc = hash.default_proc if hash.default_proc
      elsif constructor.nil?
        super()
      else
        super(constructor)
      end
    end

    def self.[](*args)
      new.merge!(Hash[*args])
    end

    alias_method :regular_writer, :[]= unless method_defined?(:regular_writer)
    alias_method :regular_update, :update unless method_defined?(:regular_update)

    # Assigns a new value to the hash:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash[:key] = 'value'
    #
    # This value can be later fetched using either +:key+ or <tt>'key'</tt>.
    def []=(key, value)
      regular_writer(convert_key(key), convert_value(value, conversion: :assignment))
    end

    alias_method :store, :[]=

    # Updates the receiver in-place, merging in the hashes passed as arguments:
    #
    #   hash_1 = ActiveSupport::HashWithIndifferentAccess.new
    #   hash_1[:key] = 'value'
    #
    #   hash_2 = ActiveSupport::HashWithIndifferentAccess.new
    #   hash_2[:key] = 'New Value!'
    #
    #   hash_1.update(hash_2) # => {"key"=>"New Value!"}
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash.update({ "a" => 1 }, { "b" => 2 }) # => { "a" => 1, "b" => 2 }
    #
    # The arguments can be either an
    # <tt>ActiveSupport::HashWithIndifferentAccess</tt> or a regular +Hash+.
    # In either case the merge respects the semantics of indifferent access.
    #
    # If the argument is a regular hash with keys +:key+ and <tt>"key"</tt> only one
    # of the values end up in the receiver, but which one is unspecified.
    #
    # When given a block, the value for duplicated keys will be determined
    # by the result of invoking the block with the duplicated key, the value
    # in the receiver, and the value in +other_hash+. The rules for duplicated
    # keys follow the semantics of indifferent access:
    #
    #   hash_1[:key] = 10
    #   hash_2['key'] = 12
    #   hash_1.update(hash_2) { |key, old, new| old + new } # => {"key"=>22}
    def update(*other_hashes, &block)
      if other_hashes.size == 1
        update_with_single_argument(other_hashes.first, block)
      else
        other_hashes.each do |other_hash|
          update_with_single_argument(other_hash, block)
        end
      end
      self
    end

    alias_method :merge!, :update

    # Checks the hash for a key matching the argument passed in:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash['key'] = 'value'
    #   hash.key?(:key)  # => true
    #   hash.key?('key') # => true
    def key?(key)
      super(convert_key(key))
    end

    alias_method :include?, :key?
    alias_method :has_key?, :key?
    alias_method :member?, :key?

    # Same as <tt>Hash#[]</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = 1
    #
    #   counters['foo'] # => 1
    #   counters[:foo]  # => 1
    #   counters[:zoo]  # => nil
    def [](key)
      super(convert_key(key))
    end

    # Same as <tt>Hash#assoc</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = 1
    #
    #   counters.assoc('foo') # => ["foo", 1]
    #   counters.assoc(:foo)  # => ["foo", 1]
    #   counters.assoc(:zoo)  # => nil
    def assoc(key)
      super(convert_key(key))
    end

    # Same as <tt>Hash#fetch</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = 1
    #
    #   counters.fetch('foo')          # => 1
    #   counters.fetch(:bar, 0)        # => 0
    #   counters.fetch(:bar) { |key| 0 } # => 0
    #   counters.fetch(:zoo)           # => KeyError: key not found: "zoo"
    def fetch(key, *extras)
      super(convert_key(key), *extras)
    end

    # Same as <tt>Hash#dig</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = { bar: 1 }
    #
    #   counters.dig('foo', 'bar')     # => 1
    #   counters.dig(:foo, :bar)       # => 1
    #   counters.dig(:zoo)             # => nil
    def dig(*args)
      args[0] = convert_key(args[0]) if args.size > 0
      super(*args)
    end

    # Same as <tt>Hash#default</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new(1)
    #   hash.default                   # => 1
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new { |hash, key| key }
    #   hash.default                   # => nil
    #   hash.default('foo')            # => 'foo'
    #   hash.default(:foo)             # => 'foo'
    def default(*args)
      super(*args.map { |arg| convert_key(arg) })
    end

    # Returns an array of the values at the specified indices:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash[:a] = 'x'
    #   hash[:b] = 'y'
    #   hash.values_at('a', 'b') # => ["x", "y"]
    def values_at(*keys)
      super(*keys.map { |key| convert_key(key) })
    end

    # Returns an array of the values at the specified indices, but also
    # raises an exception when one of the keys can't be found.
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash[:a] = 'x'
    #   hash[:b] = 'y'
    #   hash.fetch_values('a', 'b') # => ["x", "y"]
    #   hash.fetch_values('a', 'c') { |key| 'z' } # => ["x", "z"]
    #   hash.fetch_values('a', 'c') # => KeyError: key not found: "c"
    def fetch_values(*indices, &block)
      super(*indices.map { |key| convert_key(key) }, &block)
    end

    # Returns a shallow copy of the hash.
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } })
    #   dup  = hash.dup
    #   dup[:a][:c] = 'c'
    #
    #   hash[:a][:c] # => "c"
    #   dup[:a][:c]  # => "c"
    def dup
      self.class.new(self).tap do |new_hash|
        set_defaults(new_hash)
      end
    end

    # This method has the same semantics of +update+, except it does not
    # modify the receiver but rather returns a new hash with indifferent
    # access with the result of the merge.
    def merge(*hashes, &block)
      dup.update(*hashes, &block)
    end

    # Like +merge+ but the other way around: Merges the receiver into the
    # argument and returns a new hash with indifferent access as result:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash['a'] = nil
    #   hash.reverse_merge(a: 0, b: 1) # => {"a"=>nil, "b"=>1}
    def reverse_merge(other_hash)
      super(self.class.new(other_hash))
    end
    alias_method :with_defaults, :reverse_merge

    # Same semantics as +reverse_merge+ but modifies the receiver in-place.
    def reverse_merge!(other_hash)
      super(self.class.new(other_hash))
    end
    alias_method :with_defaults!, :reverse_merge!

    # Replaces the contents of this hash with other_hash.
    #
    #   h = { "a" => 100, "b" => 200 }
    #   h.replace({ "c" => 300, "d" => 400 }) # => {"c"=>300, "d"=>400}
    def replace(other_hash)
      super(self.class.new(other_hash))
    end

    # Removes the specified key from the hash.
    def delete(key)
      super(convert_key(key))
    end

    def except(*keys)
      slice(*self.keys - keys.map { |key| convert_key(key) })
    end
    alias_method :without, :except

    def stringify_keys!; self end
    def deep_stringify_keys!; self end
    def stringify_keys; dup end
    def deep_stringify_keys; dup end
    undef :symbolize_keys!
    undef :deep_symbolize_keys!
    def symbolize_keys; to_hash.symbolize_keys! end
    alias_method :to_options, :symbolize_keys
    def deep_symbolize_keys; to_hash.deep_symbolize_keys! end
    def to_options!; self end

    def select(*args, &block)
      return to_enum(:select) unless block_given?
      dup.tap { |hash| hash.select!(*args, &block) }
    end

    def reject(*args, &block)
      return to_enum(:reject) unless block_given?
      dup.tap { |hash| hash.reject!(*args, &block) }
    end

    def transform_values(*args, &block)
      return to_enum(:transform_values) unless block_given?
      dup.tap { |hash| hash.transform_values!(*args, &block) }
    end

    def transform_keys(*args, &block)
      return to_enum(:transform_keys) unless block_given?
      dup.tap { |hash| hash.transform_keys!(*args, &block) }
    end

    def transform_keys!
      return enum_for(:transform_keys!) { size } unless block_given?
      keys.each do |key|
        self[yield(key)] = delete(key)
      end
      self
    end

    def slice(*keys)
      keys.map! { |key| convert_key(key) }
      self.class.new(super)
    end

    def slice!(*keys)
      keys.map! { |key| convert_key(key) }
      super
    end

    def compact
      dup.tap(&:compact!)
    end

    # Convert to a regular hash with string keys.
    def to_hash
      _new_hash = Hash.new
      set_defaults(_new_hash)

      each do |key, value|
        _new_hash[key] = convert_value(value, conversion: :to_hash)
      end
      _new_hash
    end

    private
      if Symbol.method_defined?(:name)
        def convert_key(key)
          key.kind_of?(Symbol) ? key.name : key
        end
      else
        def convert_key(key)
          key.kind_of?(Symbol) ? key.to_s : key
        end
      end

      def convert_value(value, conversion: nil)
        if value.is_a? Hash
          if conversion == :to_hash
            value.to_hash
          else
            value.nested_under_indifferent_access
          end
        elsif value.is_a?(Array)
          if conversion != :assignment || value.frozen?
            value = value.dup
          end
          value.map! { |e| convert_value(e, conversion: conversion) }
        else
          value
        end
      end

      def set_defaults(target)
        if default_proc
          target.default_proc = default_proc.dup
        else
          target.default = default
        end
      end

      def update_with_single_argument(other_hash, block)
        if other_hash.is_a? HashWithIndifferentAccess
          regular_update(other_hash, &block)
        else
          other_hash.to_hash.each_pair do |key, value|
            if block && key?(key)
              value = block.call(convert_key(key), self[key], value)
            end
            regular_writer(convert_key(key), convert_value(value))
          end
        end
      end
  end
# frozen_string_literal: true

module ActiveSupport
  module SecurityUtils
    # Constant time string comparison, for fixed length strings.
    #
    # The values compared should be of fixed length, such as strings
    # that have already been processed by HMAC. Raises in case of length mismatch.

    if defined?(OpenSSL.fixed_length_secure_compare)
      def fixed_length_secure_compare(a, b)
        OpenSSL.fixed_length_secure_compare(a, b)
      end
    else
      def fixed_length_secure_compare(a, b)
        raise ArgumentError, "string length mismatch." unless a.bytesize == b.bytesize

        l = a.unpack "C#{a.bytesize}"

        res = 0
        b.each_byte { |byte| res |= byte ^ l.shift }
        res == 0
      end
    end
    module_function :fixed_length_secure_compare

    # Secure string comparison for strings of variable length.
    #
    # While a timing attack would not be able to discern the content of
    # a secret compared via secure_compare, it is possible to determine
    # the secret length. This should be considered when using secure_compare
    # to compare weak, short secrets to user input.
    def secure_compare(a, b)
      a.length == b.length && fixed_length_secure_compare(a, b)
    end
# frozen_string_literal: true

require "singleton"

module ActiveSupport
  # \Deprecation specifies the API used by Rails to deprecate methods, instance
  # variables, objects and constants.
  class Deprecation
    # active_support.rb sets an autoload for ActiveSupport::Deprecation.
    #
    # If these requires were at the top of the file the constant would not be
    # defined by the time their files were loaded. Since some of them reopen
    # ActiveSupport::Deprecation its autoload would be triggered, resulting in
    # a circular require warning for active_support/deprecation.rb.
    #
    # So, we define the constant first, and load dependencies later.
    require "active_support/deprecation/instance_delegator"
    require "active_support/deprecation/behaviors"
    require "active_support/deprecation/reporting"
    require "active_support/deprecation/disallowed"
    require "active_support/deprecation/constant_accessor"
    require "active_support/deprecation/method_wrappers"
    require "active_support/deprecation/proxy_wrappers"
    require "active_support/core_ext/module/deprecation"
    require "concurrent/atomic/thread_local_var"

    include Singleton
    include InstanceDelegator
    include Behavior
    include Reporting
    include Disallowed
    include MethodWrapper

    # The version number in which the deprecated behavior will be removed, by default.
    attr_accessor :deprecation_horizon

    # It accepts two parameters on initialization. The first is a version of library
    # and the second is a library name.
    #
    #   ActiveSupport::Deprecation.new('2.0', 'MyLibrary')
    def initialize(deprecation_horizon = "7.1", gem_name = "Rails")
      self.gem_name = gem_name
      self.deprecation_horizon = deprecation_horizon
      # By default, warnings are not silenced and debugging is off.
      self.silenced = false
      self.debug = false
      @silenced_thread = Concurrent::ThreadLocalVar.new(false)
      @explicitly_allowed_warnings = Concurrent::ThreadLocalVar.new(nil)
    end
  end
# frozen_string_literal: true

require "active_support/core_ext/module/attribute_accessors"
require "active_support/core_ext/module/delegation"
require "json"

module ActiveSupport
  # Look for and parse json strings that look like ISO 8601 times.
  mattr_accessor :parse_json_times

  module JSON
    # matches YAML-formatted dates
    DATE_REGEX = /\A\d{4}-\d{2}-\d{2}\z/
    DATETIME_REGEX = /\A(?:\d{4}-\d{2}-\d{2}|\d{4}-\d{1,2}-\d{1,2}[T \t]+\d{1,2}:\d{2}:\d{2}(\.[0-9]*)?(([ \t]*)Z|[-+]\d{2}?(:\d{2})?)?)\z/

    class << self
      # Parses a JSON string (JavaScript Object Notation) into a hash.
      # See http://www.json.org for more info.
      #
      #   ActiveSupport::JSON.decode("{\"team\":\"rails\",\"players\":\"36\"}")
      #   => {"team" => "rails", "players" => "36"}
      def decode(json)
        data = ::JSON.parse(json, quirks_mode: true)

        if ActiveSupport.parse_json_times
          convert_dates_from(data)
        else
          data
        end
      end

      # Returns the class of the error that will be raised when there is an
      # error in decoding JSON. Using this method means you won't directly
      # depend on the ActiveSupport's JSON implementation, in case it changes
      # in the future.
      #
      #   begin
      #     obj = ActiveSupport::JSON.decode(some_string)
      #   rescue ActiveSupport::JSON.parse_error
      #     Rails.logger.warn("Attempted to decode invalid JSON: #{some_string}")
      #   end
      def parse_error
        ::JSON::ParserError
      end

      private
        def convert_dates_from(data)
          case data
          when nil
            nil
          when DATE_REGEX
            begin
              Date.parse(data)
            rescue ArgumentError
              data
            end
          when DATETIME_REGEX
            begin
              Time.zone.parse(data)
            rescue ArgumentError
              data
            end
          when Array
            data.map! { |d| convert_dates_from(d) }
          when Hash
            data.transform_values! do |value|
              convert_dates_from(value)
            end
          else
            data
# frozen_string_literal: true

require "active_support/core_ext/object/json"
require "active_support/core_ext/module/delegation"

module ActiveSupport
  class << self
    delegate :use_standard_json_time_format, :use_standard_json_time_format=,
      :time_precision, :time_precision=,
      :escape_html_entities_in_json, :escape_html_entities_in_json=,
      :json_encoder, :json_encoder=,
      to: :'ActiveSupport::JSON::Encoding'
  end

  module JSON
    # Dumps objects in JSON (JavaScript Object Notation).
    # See http://www.json.org for more info.
    #
    #   ActiveSupport::JSON.encode({ team: 'rails', players: '36' })
    #   # => "{\"team\":\"rails\",\"players\":\"36\"}"
    def self.encode(value, options = nil)
      Encoding.json_encoder.new(options).encode(value)
    end

    module Encoding #:nodoc:
      class JSONGemEncoder #:nodoc:
        attr_reader :options

        def initialize(options = nil)
          @options = options || {}
        end

        # Encode the given object into a JSON string
        def encode(value)
          stringify jsonify value.as_json(options.dup)
        end

        private
          # Rails does more escaping than the JSON gem natively does (we
          # escape \u2028 and \u2029 and optionally >, <, & to work around
          # certain browser problems).
          ESCAPED_CHARS = {
            "\u2028" => '\u2028',
            "\u2029" => '\u2029',
            ">"      => '\u003e',
            "<"      => '\u003c',
            "&"      => '\u0026',
            }

          ESCAPE_REGEX_WITH_HTML_ENTITIES = /[\u2028\u2029><&]/u
          ESCAPE_REGEX_WITHOUT_HTML_ENTITIES = /[\u2028\u2029]/u

          # This class wraps all the strings we see and does the extra escaping
          class EscapedString < String #:nodoc:
            def to_json(*)
              if Encoding.escape_html_entities_in_json
                s = super
                s.gsub! ESCAPE_REGEX_WITH_HTML_ENTITIES, ESCAPED_CHARS
                s
              else
                s = super
                s.gsub! ESCAPE_REGEX_WITHOUT_HTML_ENTITIES, ESCAPED_CHARS
                s
              end
            end

            def to_s
              self
            end
          end

          # Mark these as private so we don't leak encoding-specific constructs
          private_constant :ESCAPED_CHARS, :ESCAPE_REGEX_WITH_HTML_ENTITIES,
            :ESCAPE_REGEX_WITHOUT_HTML_ENTITIES, :EscapedString

          # Convert an object into a "JSON-ready" representation composed of
          # primitives like Hash, Array, String, Numeric,
          # and +true+/+false+/+nil+.
          # Recursively calls #as_json to the object to recursively build a
          # fully JSON-ready object.
          #
          # This allows developers to implement #as_json without having to
          # worry about what base types of objects they are allowed to return
          # or having to remember to call #as_json recursively.
          #
          # Note: the +options+ hash passed to +object.to_json+ is only passed
          # to +object.as_json+, not any of this method's recursive +#as_json+
          # calls.
          def jsonify(value)
            case value
            when String
              EscapedString.new(value)
            when Numeric, NilClass, TrueClass, FalseClass
              value.as_json
            when Hash
              result = {}
              value.each do |k, v|
                result[jsonify(k)] = jsonify(v)
              end
              result
            when Array
              value.map { |v| jsonify(v) }
            else
              jsonify value.as_json
            end
          end

          # Encode a "jsonified" Ruby data structure using the JSON gem
          def stringify(jsonified)
            ::JSON.generate(jsonified, quirks_mode: true, max_nesting: false)
          end
      end

      class << self
        # If true, use ISO 8601 format for dates and times. Otherwise, fall back
        # to the Active Support legacy format.
        attr_accessor :use_standard_json_time_format

        # If true, encode >, <, & as escaped unicode sequences (e.g. > as \u003e)
        # as a safety measure.
        attr_accessor :escape_html_entities_in_json

        # Sets the precision of encoded time values.
        # Defaults to 3 (equivalent to millisecond precision)
        attr_accessor :time_precision

        # Sets the encoder used by Rails to encode Ruby objects into JSON strings
        # in +Object#to_json+ and +ActiveSupport::JSON.encode+.
        attr_accessor :json_encoder
      end

      self.use_standard_json_time_format = true
      self.escape_html_entities_in_json  = true
      self.json_encoder = JSONGemEncoder
      self.time_precision = 3
# frozen_string_literal: true

require "active_support/per_thread_registry"
require "active_support/notifications"

module ActiveSupport
  # ActiveSupport::Subscriber is an object set to consume
  # ActiveSupport::Notifications. The subscriber dispatches notifications to
  # a registered object based on its given namespace.
  #
  # An example would be an Active Record subscriber responsible for collecting
  # statistics about queries:
  #
  #   module ActiveRecord
  #     class StatsSubscriber < ActiveSupport::Subscriber
  #       attach_to :active_record
  #
  #       def sql(event)
  #         Statsd.timing("sql.#{event.payload[:name]}", event.duration)
  #       end
  #     end
  #   end
  #
  # After configured, whenever a "sql.active_record" notification is published,
  # it will properly dispatch the event (ActiveSupport::Notifications::Event) to
  # the +sql+ method.
  #
  # We can detach a subscriber as well:
  #
  #   ActiveRecord::StatsSubscriber.detach_from(:active_record)
  class Subscriber
    class << self
      # Attach the subscriber to a namespace.
      def attach_to(namespace, subscriber = new, notifier = ActiveSupport::Notifications, inherit_all: false)
        @namespace  = namespace
        @subscriber = subscriber
        @notifier   = notifier
        @inherit_all = inherit_all

        subscribers << subscriber

        # Add event subscribers for all existing methods on the class.
        fetch_public_methods(subscriber, inherit_all).each do |event|
          add_event_subscriber(event)
        end
      end

      # Detach the subscriber from a namespace.
      def detach_from(namespace, notifier = ActiveSupport::Notifications)
        @namespace  = namespace
        @subscriber = find_attached_subscriber
        @notifier   = notifier

        return unless subscriber

        subscribers.delete(subscriber)

        # Remove event subscribers of all existing methods on the class.
        fetch_public_methods(subscriber, true).each do |event|
          remove_event_subscriber(event)
        end

        # Reset notifier so that event subscribers will not add for new methods added to the class.
        @notifier = nil
      end

      # Adds event subscribers for all new methods added to the class.
      def method_added(event)
        # Only public methods are added as subscribers, and only if a notifier
        # has been set up. This means that subscribers will only be set up for
        # classes that call #attach_to.
        if public_method_defined?(event) && notifier
          add_event_subscriber(event)
        end
      end

      def subscribers
        @@subscribers ||= []
      end

      private
        attr_reader :subscriber, :notifier, :namespace

        def add_event_subscriber(event) # :doc:
          return if invalid_event?(event)

          pattern = prepare_pattern(event)

          # Don't add multiple subscribers (e.g. if methods are redefined).
          return if pattern_subscribed?(pattern)

          subscriber.patterns[pattern] = notifier.subscribe(pattern, subscriber)
        end

        def remove_event_subscriber(event) # :doc:
          return if invalid_event?(event)

          pattern = prepare_pattern(event)

          return unless pattern_subscribed?(pattern)

          notifier.unsubscribe(subscriber.patterns[pattern])
          subscriber.patterns.delete(pattern)
        end

        def find_attached_subscriber
          subscribers.find { |attached_subscriber| attached_subscriber.instance_of?(self) }
        end

        def invalid_event?(event)
          %i{ start finish }.include?(event.to_sym)
        end

        def prepare_pattern(event)
          "#{event}.#{namespace}"
        end

        def pattern_subscribed?(pattern)
          subscriber.patterns.key?(pattern)
        end

        def fetch_public_methods(subscriber, inherit_all)
          subscriber.public_methods(inherit_all) - Subscriber.public_instance_methods(true)
        end
    end

    attr_reader :patterns # :nodoc:

    def initialize
      @queue_key = [self.class.name, object_id].join "-"
      @patterns  = {}
      super
    end

    def start(name, id, payload)
      event = ActiveSupport::Notifications::Event.new(name, nil, nil, id, payload)
      event.start!
      parent = event_stack.last
      parent << event if parent

      event_stack.push event
    end

    def finish(name, id, payload)
      event = event_stack.pop
      event.finish!
      event.payload.merge!(payload)

      method = name.split(".").first
      send(method, event)
    end

    private
      def event_stack
        SubscriberQueueRegistry.instance.get_queue(@queue_key)
      end
  end

  # This is a registry for all the event stacks kept for subscribers.
  #
  # See the documentation of <tt>ActiveSupport::PerThreadRegistry</tt>
  # for further details.
  class SubscriberQueueRegistry # :nodoc:
    extend PerThreadRegistry

    def initialize
      @registry = {}
    end

    def get_queue(queue_key)
# frozen_string_literal: true

begin
  require "builder"
rescue LoadError => e
# frozen_string_literal: true

require "active_support/core_ext/benchmark"
require "active_support/core_ext/hash/keys"

module ActiveSupport
  module Benchmarkable
    # Allows you to measure the execution time of a block in a template and
    # records the result to the log. Wrap this block around expensive operations
    # or possible bottlenecks to get a time reading for the operation. For
    # example, let's say you thought your file processing method was taking too
    # long; you could wrap it in a benchmark block.
    #
    #  <% benchmark 'Process data files' do %>
    #    <%= expensive_files_operation %>
    #  <% end %>
    #
    # That would add something like "Process data files (345.2ms)" to the log,
    # which you can then use to compare timings when optimizing your code.
    #
    # You may give an optional logger level (<tt>:debug</tt>, <tt>:info</tt>,
    # <tt>:warn</tt>, <tt>:error</tt>) as the <tt>:level</tt> option. The
    # default logger level value is <tt>:info</tt>.
    #
    #  <% benchmark 'Low-level files', level: :debug do %>
    #    <%= lowlevel_files_operation %>
    #  <% end %>
    #
    # Finally, you can pass true as the third argument to silence all log
    # activity (other than the timing information) from inside the block. This
    # is great for boiling down a noisy block to just a single statement that
    # produces one log line:
    #
    #  <% benchmark 'Process data files', level: :info, silence: true do %>
    #    <%= expensive_and_chatty_files_operation %>
    #  <% end %>
    def benchmark(message = "Benchmarking", options = {})
      if logger
        options.assert_valid_keys(:level, :silence)
        options[:level] ||= :info

        result = nil
        ms = Benchmark.ms { result = options[:silence] ? logger.silence { yield } : yield }
        logger.public_send(options[:level], "%s (%.1fms)" % [ message, ms ])
        result
      else
        yield
      end
    end
  end
# frozen_string_literal: true

require "active_support/core_ext/module/delegation"

module ActiveSupport
  # NOTE: This approach has been deprecated for end-user code in favor of {thread_mattr_accessor}[rdoc-ref:Module#thread_mattr_accessor] and friends.
  # Please use that approach instead.
  #
  # This module is used to encapsulate access to thread local variables.
  #
  # Instead of polluting the thread locals namespace:
  #
  #   Thread.current[:connection_handler]
  #
  # you define a class that extends this module:
  #
  #   module ActiveRecord
  #     class RuntimeRegistry
  #       extend ActiveSupport::PerThreadRegistry
  #
  #       attr_accessor :connection_handler
  #     end
  #   end
  #
  # and invoke the declared instance accessors as class methods. So
  #
  #   ActiveRecord::RuntimeRegistry.connection_handler = connection_handler
  #
  # sets a connection handler local to the current thread, and
  #
  #   ActiveRecord::RuntimeRegistry.connection_handler
  #
  # returns a connection handler local to the current thread.
  #
  # This feature is accomplished by instantiating the class and storing the
  # instance as a thread local keyed by the class name. In the example above
  # a key "ActiveRecord::RuntimeRegistry" is stored in <tt>Thread.current</tt>.
  # The class methods proxy to said thread local instance.
  #
  # If the class has an initializer, it must accept no arguments.
  module PerThreadRegistry
    def self.extended(object)
      object.instance_variable_set :@per_thread_registry_key, object.name.freeze
    end

    def instance
      Thread.current[@per_thread_registry_key] ||= new
    end

    private
      def method_missing(name, *args, &block)
        # Caches the method definition as a singleton method of the receiver.
        #
        # By letting #delegate handle it, we avoid an enclosure that'll capture args.
        singleton_class.delegate name, to: :instance
# frozen_string_literal: true

require "active_support"
require "active_support/i18n_railtie"

module ActiveSupport
  class Railtie < Rails::Railtie # :nodoc:
    config.active_support = ActiveSupport::OrderedOptions.new

    config.eager_load_namespaces << ActiveSupport

    initializer "active_support.set_authenticated_message_encryption" do |app|
      config.after_initialize do
        unless app.config.active_support.use_authenticated_message_encryption.nil?
          ActiveSupport::MessageEncryptor.use_authenticated_message_encryption =
            app.config.active_support.use_authenticated_message_encryption
        end
      end
    end

    initializer "active_support.reset_all_current_attributes_instances" do |app|
      app.reloader.before_class_unload { ActiveSupport::CurrentAttributes.clear_all }
      app.executor.to_run              { ActiveSupport::CurrentAttributes.reset_all }
      app.executor.to_complete         { ActiveSupport::CurrentAttributes.reset_all }

      ActiveSupport.on_load(:active_support_test_case) do
        require "active_support/current_attributes/test_helper"
        include ActiveSupport::CurrentAttributes::TestHelper
      end
    end

    initializer "active_support.deprecation_behavior" do |app|
      if deprecation = app.config.active_support.deprecation
        ActiveSupport::Deprecation.behavior = deprecation
      end

      if disallowed_deprecation = app.config.active_support.disallowed_deprecation
        ActiveSupport::Deprecation.disallowed_behavior = disallowed_deprecation
      end

      if disallowed_warnings = app.config.active_support.disallowed_deprecation_warnings
        ActiveSupport::Deprecation.disallowed_warnings = disallowed_warnings
      end
    end

    # Sets the default value for Time.zone
    # If assigned value cannot be matched to a TimeZone, an exception will be raised.
    initializer "active_support.initialize_time_zone" do |app|
      begin
        TZInfo::DataSource.get
      rescue TZInfo::DataSourceNotFound => e
        raise e.exception "tzinfo-data is not present. Please add gem 'tzinfo-data' to your Gemfile and run bundle install"
      end
      require "active_support/core_ext/time/zones"
      Time.zone_default = Time.find_zone!(app.config.time_zone)
    end

    # Sets the default week start
    # If assigned value is not a valid day symbol (e.g. :sunday, :monday, ...), an exception will be raised.
    initializer "active_support.initialize_beginning_of_week" do |app|
      require "active_support/core_ext/date/calculations"
      beginning_of_week_default = Date.find_beginning_of_week!(app.config.beginning_of_week)

      Date.beginning_of_week_default = beginning_of_week_default
    end

    initializer "active_support.require_master_key" do |app|
      if app.config.respond_to?(:require_master_key) && app.config.require_master_key
        begin
          app.credentials.key
        rescue ActiveSupport::EncryptedFile::MissingKeyError => error
          $stderr.puts error.message
          exit 1
        end
      end
    end

    initializer "active_support.set_configs" do |app|
      app.config.active_support.each do |k, v|
        k = "#{k}="
        ActiveSupport.public_send(k, v) if ActiveSupport.respond_to? k
      end
    end

    initializer "active_support.set_hash_digest_class" do |app|
      config.after_initialize do
        if app.config.active_support.use_sha1_digests
          ActiveSupport::Deprecation.warn(<<-MSG.squish)
            config.active_support.use_sha1_digests is deprecated and will
            be removed from Rails 7.0. Use
            config.active_support.hash_digest_class = OpenSSL::Digest::SHA1 instead.
          MSG
          ActiveSupport::Digest.hash_digest_class = OpenSSL::Digest::SHA1
        end

        if klass = app.config.active_support.hash_digest_class
          ActiveSupport::Digest.hash_digest_class = klass
        end
      end
    end

    initializer "active_support.set_key_generator_hash_digest_class" do |app|
      config.after_initialize do
        if klass = app.config.active_support.key_generator_hash_digest_class
          ActiveSupport::KeyGenerator.hash_digest_class = klass
# frozen_string_literal: true

require "active_support/core_ext/module/attribute_accessors"
require "active_support/core_ext/class/attribute"
require "active_support/subscriber"

module ActiveSupport
  # <tt>ActiveSupport::LogSubscriber</tt> is an object set to consume
  # <tt>ActiveSupport::Notifications</tt> with the sole purpose of logging them.
  # The log subscriber dispatches notifications to a registered object based
  # on its given namespace.
  #
  # An example would be Active Record log subscriber responsible for logging
  # queries:
  #
  #   module ActiveRecord
  #     class LogSubscriber < ActiveSupport::LogSubscriber
  #       def sql(event)
  #         info "#{event.payload[:name]} (#{event.duration}) #{event.payload[:sql]}"
  #       end
  #     end
  #   end
  #
  # And it's finally registered as:
  #
  #   ActiveRecord::LogSubscriber.attach_to :active_record
  #
  # Since we need to know all instance methods before attaching the log
  # subscriber, the line above should be called after your
  # <tt>ActiveRecord::LogSubscriber</tt> definition.
  #
  # A logger also needs to be set with <tt>ActiveRecord::LogSubscriber.logger=</tt>.
  # This is assigned automatically in a Rails environment.
  #
  # After configured, whenever a <tt>"sql.active_record"</tt> notification is published,
  # it will properly dispatch the event
  # (<tt>ActiveSupport::Notifications::Event</tt>) to the sql method.
  #
  # Being an <tt>ActiveSupport::Notifications</tt> consumer,
  # <tt>ActiveSupport::LogSubscriber</tt> exposes a simple interface to check if
  # instrumented code raises an exception. It is common to log a different
  # message in case of an error, and this can be achieved by extending
  # the previous example:
  #
  #   module ActiveRecord
  #     class LogSubscriber < ActiveSupport::LogSubscriber
  #       def sql(event)
  #         exception = event.payload[:exception]
  #
  #         if exception
  #           exception_object = event.payload[:exception_object]
  #
  #           error "[ERROR] #{event.payload[:name]}: #{exception.join(', ')} " \
  #                 "(#{exception_object.backtrace.first})"
  #         else
  #           # standard logger code
  #         end
  #       end
  #     end
  #   end
  #
  # Log subscriber also has some helpers to deal with logging and automatically
  # flushes all logs when the request finishes
  # (via <tt>action_dispatch.callback</tt> notification) in a Rails environment.
  class LogSubscriber < Subscriber
    # Embed in a String to clear all previous ANSI sequences.
    CLEAR   = "\e[0m"
    BOLD    = "\e[1m"

    # Colors
    BLACK   = "\e[30m"
    RED     = "\e[31m"
    GREEN   = "\e[32m"
    YELLOW  = "\e[33m"
    BLUE    = "\e[34m"
    MAGENTA = "\e[35m"
    CYAN    = "\e[36m"
    WHITE   = "\e[37m"

    mattr_accessor :colorize_logging, default: true

    class << self
      def logger
        @logger ||= if defined?(Rails) && Rails.respond_to?(:logger)
          Rails.logger
        end
      end

      attr_writer :logger

      def log_subscribers
        subscribers
      end

      # Flush all log_subscribers' logger.
      def flush_all!
        logger.flush if logger.respond_to?(:flush)
      end

      private
        def fetch_public_methods(subscriber, inherit_all)
          subscriber.public_methods(inherit_all) - LogSubscriber.public_instance_methods(true)
        end
    end

    def logger
      LogSubscriber.logger
    end

    def start(name, id, payload)
      super if logger
    end

    def finish(name, id, payload)
      super if logger
    rescue => e
      if logger
        logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
      end
    end

  private
    %w(info debug warn error fatal unknown).each do |level|
      class_eval <<-METHOD, __FILE__, __LINE__ + 1
        def #{level}(progname = nil, &block)
          logger.#{level}(progname, &block) if logger
        end
      METHOD
    end

    # Set color by using a symbol or one of the defined constants. If a third
    # option is set to +true+, it also adds bold to the string. This is based
    # on the Highline implementation and will automatically append CLEAR to the
    # end of the returned String.
    def color(text, color, bold = false) # :doc:
      return text unless colorize_logging
      color = self.class.const_get(color.upcase) if color.is_a?(Symbol)
      bold  = bold ? BOLD : ""
      "#{bold}#{color}#{text}#{CLEAR}"
    end
# frozen_string_literal: true

require "active_support/string_inquirer"

module ActiveSupport
  class EnvironmentInquirer < StringInquirer #:nodoc:
    DEFAULT_ENVIRONMENTS = ["development", "test", "production"]
    def initialize(env)
      super(env)

      DEFAULT_ENVIRONMENTS.each do |default|
        instance_variable_set :"@#{default}", env == default
      end
    end

# frozen_string_literal: true

require "openssl"

module ActiveSupport
  class Digest #:nodoc:
    class <<self
      def hash_digest_class
        @hash_digest_class ||= OpenSSL::Digest::MD5
      end

      def hash_digest_class=(klass)
        raise ArgumentError, "#{klass} is expected to implement hexdigest class method" unless klass.respond_to?(:hexdigest)
        @hash_digest_class = klass
      end

      def hexdigest(arg)
        hash_digest_class.hexdigest(arg)[0...32]
      end
    end
# frozen_string_literal: true

require "active_support"
require "active_support/core_ext/array/wrap"

# :enddoc:

module I18n
  class Railtie < Rails::Railtie
    config.i18n = ActiveSupport::OrderedOptions.new
    config.i18n.railties_load_path = []
    config.i18n.load_path = []
    config.i18n.fallbacks = ActiveSupport::OrderedOptions.new

    config.eager_load_namespaces << I18n

    # Set the i18n configuration after initialization since a lot of
    # configuration is still usually done in application initializers.
    config.after_initialize do |app|
      I18n::Railtie.initialize_i18n(app)
    end

    # Trigger i18n config before any eager loading has happened
    # so it's ready if any classes require it when eager loaded.
    config.before_eager_load do |app|
      I18n::Railtie.initialize_i18n(app)
    end

    @i18n_inited = false

    # Setup i18n configuration.
    def self.initialize_i18n(app)
      return if @i18n_inited

      fallbacks = app.config.i18n.delete(:fallbacks)

      # Avoid issues with setting the default_locale by disabling available locales
      # check while configuring.
      enforce_available_locales = app.config.i18n.delete(:enforce_available_locales)
      enforce_available_locales = I18n.enforce_available_locales if enforce_available_locales.nil?
      I18n.enforce_available_locales = false

      reloadable_paths = []
      app.config.i18n.each do |setting, value|
        case setting
        when :railties_load_path
          reloadable_paths = value
          app.config.i18n.load_path.unshift(*value.flat_map(&:existent))
        when :load_path
          I18n.load_path += value
        when :raise_on_missing_translations
          forward_raise_on_missing_translations_config(app)
        else
          I18n.public_send("#{setting}=", value)
        end
      end

      init_fallbacks(fallbacks) if fallbacks && validate_fallbacks(fallbacks)

      # Restore available locales check so it will take place from now on.
      I18n.enforce_available_locales = enforce_available_locales

      directories = watched_dirs_with_extensions(reloadable_paths)
      reloader = app.config.file_watcher.new(I18n.load_path.dup, directories) do
        I18n.load_path.keep_if { |p| File.exist?(p) }
        I18n.load_path |= reloadable_paths.flat_map(&:existent)
      end

      app.reloaders << reloader
      app.reloader.to_run do
        reloader.execute_if_updated { require_unload_lock! }
      end
      reloader.execute

      @i18n_inited = true
    end

    def self.forward_raise_on_missing_translations_config(app)
      ActiveSupport.on_load(:action_view) do
        self.raise_on_missing_translations = app.config.i18n.raise_on_missing_translations
      end

      ActiveSupport.on_load(:action_controller) do
        AbstractController::Translation.raise_on_missing_translations = app.config.i18n.raise_on_missing_translations
      end
    end

    def self.include_fallbacks_module
      I18n.backend.class.include(I18n::Backend::Fallbacks)
    end

    def self.init_fallbacks(fallbacks)
      include_fallbacks_module

      args = \
        case fallbacks
        when ActiveSupport::OrderedOptions
          [*(fallbacks[:defaults] || []) << fallbacks[:map]].compact
        when Hash, Array
          Array.wrap(fallbacks)
        else # TrueClass
          [I18n.default_locale]
        end

      I18n.fallbacks = I18n::Locale::Fallbacks.new(*args)
    end

    def self.validate_fallbacks(fallbacks)
      case fallbacks
      when ActiveSupport::OrderedOptions
        !fallbacks.empty?
      when TrueClass, Array, Hash
        true
      else
        raise "Unexpected fallback type #{fallbacks.inspect}"
      end
    end

    def self.watched_dirs_with_extensions(paths)
      paths.each_with_object({}) do |path, result|
# frozen_string_literal: true

require "active_support/concern"
require "active_support/core_ext/module/attribute_accessors"
require "concurrent"
require "fiber"

module ActiveSupport
  module LoggerThreadSafeLevel # :nodoc:
    extend ActiveSupport::Concern

    included do
      cattr_accessor :local_levels, default: Concurrent::Map.new(initial_capacity: 2), instance_accessor: false
    end

    Logger::Severity.constants.each do |severity|
      class_eval(<<-EOT, __FILE__, __LINE__ + 1)
        def #{severity.downcase}?                # def debug?
          Logger::#{severity} >= level           #   DEBUG >= level
        end                                      # end
      EOT
    end

    def local_log_id
      Fiber.current.__id__
    end

    def local_level
      self.class.local_levels[local_log_id]
    end

    def local_level=(level)
      case level
      when Integer
        self.class.local_levels[local_log_id] = level
      when Symbol
        self.class.local_levels[local_log_id] = Logger::Severity.const_get(level.to_s.upcase)
      when nil
        self.class.local_levels.delete(local_log_id)
      else
        raise ArgumentError, "Invalid log level: #{level.inspect}"
      end
    end

    def level
      local_level || super
    end

    # Change the thread-local level for the duration of the given block.
    def log_at(level)
      old_local_level, self.local_level = local_level, level
      yield
    ensure
      self.local_level = old_local_level
    end

    # Redefined to check severity against #level, and thus the thread-local level, rather than +@level+.
    # FIXME: Remove when the minimum Ruby version supports overriding Logger#level.
    def add(severity, message = nil, progname = nil, &block) #:nodoc:
      severity ||= UNKNOWN
      progname ||= @progname

      return true if @logdev.nil? || severity < level

      if message.nil?
        if block_given?
          message  = yield
        else
          message  = progname
          progname = @progname
        end
      end

      @logdev.write \
        format_message(format_severity(severity), Time.now, progname, message)
# frozen_string_literal: true

require "active_support/log_subscriber"
require "active_support/logger"
require "active_support/notifications"

module ActiveSupport
  class LogSubscriber
    # Provides some helpers to deal with testing log subscribers by setting up
    # notifications. Take for instance Active Record subscriber tests:
    #
    #   class SyncLogSubscriberTest < ActiveSupport::TestCase
    #     include ActiveSupport::LogSubscriber::TestHelper
    #
    #     setup do
    #       ActiveRecord::LogSubscriber.attach_to(:active_record)
    #     end
    #
    #     def test_basic_query_logging
    #       Developer.all.to_a
    #       wait
    #       assert_equal 1, @logger.logged(:debug).size
    #       assert_match(/Developer Load/, @logger.logged(:debug).last)
    #       assert_match(/SELECT \* FROM "developers"/, @logger.logged(:debug).last)
    #     end
    #   end
    #
    # All you need to do is to ensure that your log subscriber is added to
    # Rails::Subscriber, as in the second line of the code above. The test
    # helpers are responsible for setting up the queue, subscriptions and
    # turning colors in logs off.
    #
    # The messages are available in the @logger instance, which is a logger with
    # limited powers (it actually does not send anything to your output), and
    # you can collect them doing @logger.logged(level), where level is the level
    # used in logging, like info, debug, warn and so on.
    module TestHelper
      def setup # :nodoc:
        @logger   = MockLogger.new
        @notifier = ActiveSupport::Notifications::Fanout.new

        ActiveSupport::LogSubscriber.colorize_logging = false

        @old_notifier = ActiveSupport::Notifications.notifier
        set_logger(@logger)
        ActiveSupport::Notifications.notifier = @notifier
      end

      def teardown # :nodoc:
        set_logger(nil)
        ActiveSupport::Notifications.notifier = @old_notifier
      end

      class MockLogger
        include ActiveSupport::Logger::Severity

        attr_reader :flush_count
        attr_accessor :level

        def initialize(level = DEBUG)
          @flush_count = 0
          @level = level
          @logged = Hash.new { |h, k| h[k] = [] }
        end

        def method_missing(level, message = nil)
          if block_given?
            @logged[level] << yield
          else
            @logged[level] << message
          end
        end

        def logged(level)
          @logged[level].compact.map { |l| l.to_s.strip }
        end

        def flush
          @flush_count += 1
        end

        ActiveSupport::Logger::Severity.constants.each do |severity|
          class_eval <<-EOT, __FILE__, __LINE__ + 1
            def #{severity.downcase}?
              #{severity} >= @level
            end
          EOT
        end
      end

      # Wait notifications to be published.
      def wait
        @notifier.wait
      end

      # Overwrite if you use another logger in your log subscriber.
      #
      #   def logger
      #     ActiveRecord::Base.logger = @logger
      #   end
      def set_logger(logger)
        ActiveSupport::LogSubscriber.logger = logger
      end
    end
  end
# frozen_string_literal: true

require "active_support/core_ext/enumerable"

module ActiveSupport
  module Testing
    module Assertions
      UNTRACKED = Object.new # :nodoc:

      # Asserts that an expression is not truthy. Passes if <tt>object</tt> is
      # +nil+ or +false+. "Truthy" means "considered true in a conditional"
      # like <tt>if foo</tt>.
      #
      #   assert_not nil    # => true
      #   assert_not false  # => true
      #   assert_not 'foo'  # => Expected "foo" to be nil or false
      #
      # An error message can be specified.
      #
      #   assert_not foo, 'foo should be false'
      def assert_not(object, message = nil)
        message ||= "Expected #{mu_pp(object)} to be nil or false"
        assert !object, message
      end

      # Assertion that the block should not raise an exception.
      #
      # Passes if evaluated code in the yielded block raises no exception.
      #
      #   assert_nothing_raised do
      #     perform_service(param: 'no_exception')
      #   end
      def assert_nothing_raised
        yield
      rescue => error
        raise Minitest::UnexpectedError.new(error)
      end

      # Test numeric difference between the return value of an expression as a
      # result of what is evaluated in the yielded block.
      #
      #   assert_difference 'Article.count' do
      #     post :create, params: { article: {...} }
      #   end
      #
      # An arbitrary expression is passed in and evaluated.
      #
      #   assert_difference 'Article.last.comments(:reload).size' do
      #     post :create, params: { comment: {...} }
      #   end
      #
      # An arbitrary positive or negative difference can be specified.
      # The default is <tt>1</tt>.
      #
      #   assert_difference 'Article.count', -1 do
      #     post :delete, params: { id: ... }
      #   end
      #
      # An array of expressions can also be passed in and evaluated.
      #
      #   assert_difference [ 'Article.count', 'Post.count' ], 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      # A hash of expressions/numeric differences can also be passed in and evaluated.
      #
      #   assert_difference ->{ Article.count } => 1, ->{ Notification.count } => 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      # A lambda or a list of lambdas can be passed in and evaluated:
      #
      #   assert_difference ->{ Article.count }, 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      #   assert_difference [->{ Article.count }, ->{ Post.count }], 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      # An error message can be specified.
      #
      #   assert_difference 'Article.count', -1, 'An Article should be destroyed' do
      #     post :delete, params: { id: ... }
      #   end
      def assert_difference(expression, *args, &block)
        expressions =
          if expression.is_a?(Hash)
            message = args[0]
            expression
          else
            difference = args[0] || 1
            message = args[1]
            Array(expression).index_with(difference)
          end

        exps = expressions.keys.map { |e|
          e.respond_to?(:call) ? e : lambda { eval(e, block.binding) }
        }
        before = exps.map(&:call)

        retval = assert_nothing_raised(&block)

        expressions.zip(exps, before) do |(code, diff), exp, before_value|
          error  = "#{code.inspect} didn't change by #{diff}"
          error  = "#{message}.\n#{error}" if message
          assert_equal(before_value + diff, exp.call, error)
        end

        retval
      end

      # Assertion that the numeric result of evaluating an expression is not
      # changed before and after invoking the passed in block.
      #
      #   assert_no_difference 'Article.count' do
      #     post :create, params: { article: invalid_attributes }
      #   end
      #
      # A lambda can be passed in and evaluated.
      #
      #   assert_no_difference -> { Article.count } do
      #     post :create, params: { article: invalid_attributes }
      #   end
      #
      # An error message can be specified.
      #
      #   assert_no_difference 'Article.count', 'An Article should not be created' do
      #     post :create, params: { article: invalid_attributes }
      #   end
      #
      # An array of expressions can also be passed in and evaluated.
      #
      #   assert_no_difference [ 'Article.count', -> { Post.count } ] do
      #     post :create, params: { article: invalid_attributes }
      #   end
      def assert_no_difference(expression, message = nil, &block)
        assert_difference expression, 0, message, &block
      end

      # Assertion that the result of evaluating an expression is changed before
      # and after invoking the passed in block.
      #
      #   assert_changes 'Status.all_good?' do
      #     post :create, params: { status: { ok: false } }
      #   end
      #
      # You can pass the block as a string to be evaluated in the context of
      # the block. A lambda can be passed for the block as well.
      #
      #   assert_changes -> { Status.all_good? } do
      #     post :create, params: { status: { ok: false } }
      #   end
      #
      # The assertion is useful to test side effects. The passed block can be
      # anything that can be converted to string with #to_s.
      #
      #   assert_changes :@object do
      #     @object = 42
      #   end
      #
      # The keyword arguments :from and :to can be given to specify the
      # expected initial value and the expected value after the block was
      # executed.
      #
      #   assert_changes :@object, from: nil, to: :foo do
      #     @object = :foo
      #   end
      #
      # An error message can be specified.
      #
      #   assert_changes -> { Status.all_good? }, 'Expected the status to be bad' do
      #     post :create, params: { status: { incident: true } }
      #   end
      def assert_changes(expression, message = nil, from: UNTRACKED, to: UNTRACKED, &block)
        exp = expression.respond_to?(:call) ? expression : -> { eval(expression.to_s, block.binding) }

        before = exp.call
        retval = assert_nothing_raised(&block)

        unless from == UNTRACKED
          error = "Expected change from #{from.inspect}"
          error = "#{message}.\n#{error}" if message
          assert from === before, error
        end

        after = exp.call

        error = "#{expression.inspect} didn't change"
        error = "#{error}. It was already #{to}" if before == to
        error = "#{message}.\n#{error}" if message
        assert_not_equal before, after, error

        unless to == UNTRACKED
          error = "Expected change to #{to}\n"
          error = "#{message}.\n#{error}" if message
          assert to === after, error
        end

        retval
      end

      # Assertion that the result of evaluating an expression is not changed before
      # and after invoking the passed in block.
      #
      #   assert_no_changes 'Status.all_good?' do
      #     post :create, params: { status: { ok: true } }
      #   end
      #
      # An error message can be specified.
      #
      #   assert_no_changes -> { Status.all_good? }, 'Expected the status to be good' do
      #     post :create, params: { status: { ok: false } }
      #   end
      def assert_no_changes(expression, message = nil, &block)
        exp = expression.respond_to?(:call) ? expression : -> { eval(expression.to_s, block.binding) }

        before = exp.call
        retval = assert_nothing_raised(&block)
        after = exp.call

        error = "#{expression.inspect} changed"
        error = "#{message}.\n#{error}" if message

        if before.nil?
          assert_nil after, error
        else
          assert_equal before, after, error
        end

# frozen_string_literal: true

require "active_support/deprecation"

module ActiveSupport
  module Testing
    module Deprecation #:nodoc:
      def assert_deprecated(match = nil, deprecator = nil, &block)
        result, warnings = collect_deprecations(deprecator, &block)
        assert !warnings.empty?, "Expected a deprecation warning within the block but received none"
        if match
          match = Regexp.new(Regexp.escape(match)) unless match.is_a?(Regexp)
          assert warnings.any? { |w| match.match?(w) }, "No deprecation warning matched #{match}: #{warnings.join(', ')}"
        end
        result
      end

      def assert_not_deprecated(deprecator = nil, &block)
        result, deprecations = collect_deprecations(deprecator, &block)
        assert deprecations.empty?, "Expected no deprecation warning within the block but received #{deprecations.size}: \n  #{deprecations * "\n  "}"
        result
      end

      def collect_deprecations(deprecator = nil)
        deprecator ||= ActiveSupport::Deprecation
        old_behavior = deprecator.behavior
        deprecations = []
        deprecator.behavior = Proc.new do |message, callstack|
          deprecations << message
        end
        result = yield
        [result, deprecations]
      ensure
        deprecator.behavior = old_behavior
      end
# frozen_string_literal: true

require "drb"
require "drb/unix" unless Gem.win_platform?

module ActiveSupport
  module Testing
    class Parallelization # :nodoc:
      class Server
        include DRb::DRbUndumped

        def initialize
          @queue = Queue.new
          @active_workers = Concurrent::Map.new
          @in_flight = Concurrent::Map.new
        end

        def record(reporter, result)
          raise DRb::DRbConnError if result.is_a?(DRb::DRbUnknown)

          @in_flight.delete([result.klass, result.name])

          reporter.synchronize do
            reporter.record(result)
          end
        end

        def <<(o)
          o[2] = DRbObject.new(o[2]) if o
          @queue << o
        end

        def pop
          if test = @queue.pop
            @in_flight[[test[0].to_s, test[1]]] = test
            test
          end
        end

        def start_worker(worker_id)
          @active_workers[worker_id] = true
        end

        def stop_worker(worker_id)
          @active_workers.delete(worker_id)
        end

        def active_workers?
          @active_workers.size > 0
        end

        def shutdown
          # Wait for initial queue to drain
          while @queue.length != 0
            sleep 0.1
          end

          @queue.close

          # Wait until all workers have finished
          while active_workers?
            sleep 0.1
          end

          @in_flight.values.each do |(klass, name, reporter)|
            result = Minitest::Result.from(klass.new(name))
            error = RuntimeError.new("result not reported")
            error.set_backtrace([""])
            result.failures << Minitest::UnexpectedError.new(error)
            reporter.synchronize do
              reporter.record(result)
            end
          end
        end
      end
# frozen_string_literal: true

module ActiveSupport
  module Testing
    class Parallelization # :nodoc:
      class Worker
        def initialize(number, url)
          @id = SecureRandom.uuid
          @number = number
          @url = url
          @setup_exception = nil
        end

        def start
          fork do
            set_process_title("(starting)")

            DRb.stop_service

            @queue = DRbObject.new_with_uri(@url)
            @queue.start_worker(@id)

            begin
              after_fork
            rescue => @setup_exception; end

            work_from_queue
          ensure
            set_process_title("(stopping)")

            run_cleanup
            @queue.stop_worker(@id)
          end
        end

        def work_from_queue
          while job = @queue.pop
            perform_job(job)
          end
        end

        def perform_job(job)
          klass    = job[0]
          method   = job[1]
          reporter = job[2]

          set_process_title("#{klass}##{method}")

          result = klass.with_info_handler reporter do
            Minitest.run_one_method(klass, method)
          end

          safe_record(reporter, result)
        end

        def safe_record(reporter, result)
          add_setup_exception(result) if @setup_exception

          begin
            @queue.record(reporter, result)
          rescue DRb::DRbConnError
            result.failures.map! do |failure|
              if failure.respond_to?(:error)
                # minitest >5.14.0
                error = DRb::DRbRemoteError.new(failure.error)
              else
                error = DRb::DRbRemoteError.new(failure.exception)
              end
              Minitest::UnexpectedError.new(error)
            end
            @queue.record(reporter, result)
          end

          set_process_title("(idle)")
        end

        def after_fork
          Parallelization.after_fork_hooks.each do |cb|
            cb.call(@number)
          end
        end

        def run_cleanup
          Parallelization.run_cleanup_hooks.each do |cb|
            cb.call(@number)
          end
        end

        private
          def add_setup_exception(result)
            result.failures.prepend Minitest::UnexpectedError.new(@setup_exception)
          end

          def set_process_title(status)
            Process.setproctitle("Rails test worker #{@number} - #{status}")
# frozen_string_literal: true

gem "minitest"

require "minitest"
# frozen_string_literal: true

require "active_support/concern"

module ActiveSupport
  module Testing
    # Adds simple access to sample files called file fixtures.
    # File fixtures are normal files stored in
    # <tt>ActiveSupport::TestCase.file_fixture_path</tt>.
    #
    # File fixtures are represented as +Pathname+ objects.
    # This makes it easy to extract specific information:
    #
    #   file_fixture("example.txt").read # get the file's content
    #   file_fixture("example.mp3").size # get the file size
    module FileFixtures
      extend ActiveSupport::Concern

      included do
        class_attribute :file_fixture_path, instance_writer: false
      end

      # Returns a +Pathname+ to the fixture file named +fixture_name+.
      #
      # Raises +ArgumentError+ if +fixture_name+ can't be found.
      def file_fixture(fixture_name)
        path = Pathname.new(File.join(file_fixture_path, fixture_name))

        if path.exist?
          path
        else
          msg = "the directory '%s' does not contain a file named '%s'"
          raise ArgumentError, msg % [file_fixture_path, fixture_name]
        end
      end
# frozen_string_literal: true

require "minitest/mock"

module ActiveSupport
  module Testing
    module MethodCallAssertions # :nodoc:
      private
        def assert_called(object, method_name, message = nil, times: 1, returns: nil)
          times_called = 0

          object.stub(method_name, proc { times_called += 1; returns }) { yield }

          error = "Expected #{method_name} to be called #{times} times, " \
            "but was called #{times_called} times"
          error = "#{message}.\n#{error}" if message
          assert_equal times, times_called, error
        end

        def assert_called_with(object, method_name, args, returns: nil)
          mock = Minitest::Mock.new

          if args.all?(Array)
            args.each { |arg| mock.expect(:call, returns, arg) }
          else
            mock.expect(:call, returns, args)
          end

          object.stub(method_name, mock) { yield }

          mock.verify
        end

        def assert_not_called(object, method_name, message = nil, &block)
          assert_called(object, method_name, message, times: 0, &block)
        end

        def assert_called_on_instance_of(klass, method_name, message = nil, times: 1, returns: nil)
          times_called = 0
          klass.define_method("stubbed_#{method_name}") do |*|
            times_called += 1

            returns
          end

          klass.alias_method "original_#{method_name}", method_name
          klass.alias_method method_name, "stubbed_#{method_name}"

          yield

          error = "Expected #{method_name} to be called #{times} times, but was called #{times_called} times"
          error = "#{message}.\n#{error}" if message

          assert_equal times, times_called, error
        ensure
          klass.alias_method method_name, "original_#{method_name}"
          klass.undef_method "original_#{method_name}"
          klass.undef_method "stubbed_#{method_name}"
        end

        def assert_not_called_on_instance_of(klass, method_name, message = nil, &block)
          assert_called_on_instance_of(klass, method_name, message, times: 0, &block)
        end

        def stub_any_instance(klass, instance: klass.new)
# frozen_string_literal: true

require "drb"
require "drb/unix" unless Gem.win_platform?
require "active_support/core_ext/module/attribute_accessors"
require "active_support/testing/parallelization/server"
require "active_support/testing/parallelization/worker"

module ActiveSupport
  module Testing
    class Parallelization # :nodoc:
      @@after_fork_hooks = []

      def self.after_fork_hook(&blk)
        @@after_fork_hooks << blk
      end

      cattr_reader :after_fork_hooks

      @@run_cleanup_hooks = []

      def self.run_cleanup_hook(&blk)
        @@run_cleanup_hooks << blk
      end

      cattr_reader :run_cleanup_hooks

      def initialize(worker_count)
        @worker_count = worker_count
        @queue_server = Server.new
        @worker_pool = []
        @url = DRb.start_service("drbunix:", @queue_server).uri
      end

      def start
        @worker_pool = @worker_count.times.map do |worker|
          Worker.new(worker, @url).start
        end
      end

      def <<(work)
        @queue_server << work
      end

      def shutdown
        @queue_server.shutdown
        @worker_pool.each { |pid| Process.waitpid pid }
      end
    end
  end
# frozen_string_literal: true

module ActiveSupport
  module Testing
    module Isolation
      require "thread"

      def self.included(klass) #:nodoc:
        klass.class_eval do
          parallelize_me!
        end
      end

      def self.forking_env?
        !ENV["NO_FORK"] && Process.respond_to?(:fork)
      end

      def run
        serialized = run_in_isolation do
          super
        end

        Marshal.load(serialized)
      end

      module Forking
        def run_in_isolation(&blk)
          read, write = IO.pipe
          read.binmode
          write.binmode

          pid = fork do
            read.close
            yield
            begin
              if error?
                failures.map! { |e|
                  begin
                    Marshal.dump e
                    e
                  rescue TypeError
                    ex = Exception.new e.message
                    ex.set_backtrace e.backtrace
                    Minitest::UnexpectedError.new ex
                  end
                }
              end
              test_result = defined?(Minitest::Result) ? Minitest::Result.from(self) : dup
              result = Marshal.dump(test_result)
            end

            write.puts [result].pack("m")
            exit!
          end

          write.close
          result = read.read
          Process.wait2(pid)
          result.unpack1("m")
        end
      end

      module Subprocess
        ORIG_ARGV = ARGV.dup unless defined?(ORIG_ARGV)

        # Crazy H4X to get this working in windows / jruby with
        # no forking.
        def run_in_isolation(&blk)
          require "tempfile"

          if ENV["ISOLATION_TEST"]
            yield
            test_result = defined?(Minitest::Result) ? Minitest::Result.from(self) : dup
            File.open(ENV["ISOLATION_OUTPUT"], "w") do |file|
              file.puts [Marshal.dump(test_result)].pack("m")
            end
            exit!
          else
            Tempfile.open("isolation") do |tmpfile|
              env = {
                "ISOLATION_TEST" => self.class.name,
                "ISOLATION_OUTPUT" => tmpfile.path
              }

              test_opts = "-n#{self.class.name}##{name}"

              load_path_args = []
              $-I.each do |p|
                load_path_args << "-I"
                load_path_args << File.expand_path(p)
              end

              child = IO.popen([env, Gem.ruby, *load_path_args, $0, *ORIG_ARGV, test_opts])

              begin
                Process.wait(child.pid)
              rescue Errno::ECHILD # The child process may exit before we wait
                nil
              end

              return tmpfile.read.unpack1("m")
            end
          end
        end
      end
# frozen_string_literal: true

module ActiveSupport
  module Testing
    module Declarative
      unless defined?(Spec)
        # Helper to define a test method using a String. Under the hood, it replaces
        # spaces with underscores and defines the test method.
        #
        #   test "verify something" do
        #     ...
        #   end
        def test(name, &block)
          test_name = "test_#{name.gsub(/\s+/, '_')}".to_sym
          defined = method_defined? test_name
          raise "#{test_name} is already defined in #{self}" if defined
          if block_given?
            define_method(test_name, &block)
          else
            define_method(test_name) do
              flunk "No implementation provided for #{name}"
            end
          end
        end
      end
# frozen_string_literal: true

module ActiveSupport
  module Testing
    # Logs a "PostsControllerTest: test name" heading before each test to
    # make test.log easier to search and follow along with.
    module TaggedLogging #:nodoc:
      attr_writer :tagged_logger

      def before_setup
        if tagged_logger && tagged_logger.info?
          heading = "#{self.class}: #{name}"
          divider = "-" * heading.size
          tagged_logger.info divider
          tagged_logger.info heading
          tagged_logger.info divider
        end
        super
      end

      private
        def tagged_logger
          @tagged_logger ||= (defined?(Rails.logger) && Rails.logger)
        end
    end
# frozen_string_literal: true

require "active_support/concern"
require "active_support/inflector"

module ActiveSupport
  module Testing
    # Resolves a constant from a minitest spec name.
    #
    # Given the following spec-style test:
    #
    #   describe WidgetsController, :index do
    #     describe "authenticated user" do
    #       describe "returns widgets" do
    #         it "has a controller that exists" do
    #           assert_kind_of WidgetsController, @controller
    #         end
    #       end
    #     end
    #   end
    #
    # The test will have the following name:
    #
    #   "WidgetsController::index::authenticated user::returns widgets"
    #
    # The constant WidgetsController can be resolved from the name.
    # The following code will resolve the constant:
    #
    #   controller = determine_constant_from_test_name(name) do |constant|
    #     Class === constant && constant < ::ActionController::Metal
    #   end
    module ConstantLookup
      extend ::ActiveSupport::Concern

      module ClassMethods  # :nodoc:
        def determine_constant_from_test_name(test_name)
          names = test_name.split "::"
          while names.size > 0 do
            names.last.sub!(/Test$/, "")
            begin
              constant = names.join("::").safe_constantize
              break(constant) if yield(constant)
            ensure
              names.pop
            end
          end
        end
      end
    end
  end
# frozen_string_literal: true

module ActiveSupport
  module Testing
    module Stream #:nodoc:
      private
        def silence_stream(stream)
          old_stream = stream.dup
          stream.reopen(IO::NULL)
          stream.sync = true
          yield
        ensure
          stream.reopen(old_stream)
          old_stream.close
        end

        def quietly
          silence_stream(STDOUT) do
            silence_stream(STDERR) do
              yield
            end
          end
        end

        def capture(stream)
          stream = stream.to_s
          captured_stream = Tempfile.new(stream)
          stream_io = eval("$#{stream}")
          origin_stream = stream_io.dup
          stream_io.reopen(captured_stream)

          yield

          stream_io.rewind
          captured_stream.read
        ensure
          captured_stream.close
          captured_stream.unlink
          stream_io.reopen(origin_stream)
        end
# frozen_string_literal: true

require "active_support/callbacks"

module ActiveSupport
  module Testing
    # Adds support for +setup+ and +teardown+ callbacks.
    # These callbacks serve as a replacement to overwriting the
    # <tt>#setup</tt> and <tt>#teardown</tt> methods of your TestCase.
    #
    #   class ExampleTest < ActiveSupport::TestCase
    #     setup do
    #       # ...
    #     end
    #
    #     teardown do
    #       # ...
    #     end
    #   end
    module SetupAndTeardown
      def self.prepended(klass)
        klass.include ActiveSupport::Callbacks
        klass.define_callbacks :setup, :teardown
        klass.extend ClassMethods
      end

      module ClassMethods
        # Add a callback, which runs before <tt>TestCase#setup</tt>.
        def setup(*args, &block)
          set_callback(:setup, :before, *args, &block)
        end

        # Add a callback, which runs after <tt>TestCase#teardown</tt>.
        def teardown(*args, &block)
          set_callback(:teardown, :after, *args, &block)
        end
      end

      def before_setup # :nodoc:
        super
        run_callbacks :setup
      end

      def after_teardown # :nodoc:
        begin
          run_callbacks :teardown
        rescue => e
          self.failures << Minitest::UnexpectedError.new(e)
        end

# frozen_string_literal: true

require "active_support/core_ext/module/redefine_method"
require "active_support/core_ext/time/calculations"
require "concurrent/map"

module ActiveSupport
  module Testing
    # Manages stubs for TimeHelpers
    class SimpleStubs # :nodoc:
      Stub = Struct.new(:object, :method_name, :original_method)

      def initialize
        @stubs = Concurrent::Map.new { |h, k| h[k] = {} }
      end

      # Stubs object.method_name with the given block
      # If the method is already stubbed, remove that stub
      # so that removing this stub will restore the original implementation.
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   target = Time.zone.local(2004, 11, 24, 1, 4, 44)
      #   simple_stubs.stub_object(Time, :now) { at(target.to_i) }
      #   Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      def stub_object(object, method_name, &block)
        if stub = stubbing(object, method_name)
          unstub_object(stub)
        end

        new_name = "__simple_stub__#{method_name}"

        @stubs[object.object_id][method_name] = Stub.new(object, method_name, new_name)

        object.singleton_class.alias_method new_name, method_name
        object.define_singleton_method(method_name, &block)
      end

      # Remove all object-method stubs held by this instance
      def unstub_all!
        @stubs.each_value do |object_stubs|
          object_stubs.each_value do |stub|
            unstub_object(stub)
          end
        end
        @stubs.clear
      end

      # Returns the Stub for object#method_name
      # (nil if it is not stubbed)
      def stubbing(object, method_name)
        @stubs[object.object_id][method_name]
      end

      # Returns true if any stubs are set, false if there are none
      def stubbed?
        !@stubs.empty?
      end

      private
        # Restores the original object.method described by the Stub
        def unstub_object(stub)
          singleton_class = stub.object.singleton_class
          singleton_class.silence_redefinition_of_method stub.method_name
          singleton_class.alias_method stub.method_name, stub.original_method
          singleton_class.undef_method stub.original_method
        end
    end

    # Contains helpers that help you test passage of time.
    module TimeHelpers
      def after_teardown
        travel_back
        super
      end

      # Changes current time to the time in the future or in the past by a given time difference by
      # stubbing +Time.now+, +Date.today+, and +DateTime.now+. The stubs are automatically removed
      # at the end of the test.
      #
      #   Time.current     # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel 1.day
      #   Time.current     # => Sun, 10 Nov 2013 15:34:49 EST -05:00
      #   Date.current     # => Sun, 10 Nov 2013
      #   DateTime.current # => Sun, 10 Nov 2013 15:34:49 -0500
      #
      # This method also accepts a block, which will return the current time back to its original
      # state at the end of the block:
      #
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel 1.day do
      #     User.create.created_at # => Sun, 10 Nov 2013 15:34:49 EST -05:00
      #   end
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      def travel(duration, &block)
        travel_to Time.now + duration, &block
      end

      # Changes current time to the given time by stubbing +Time.now+,
      # +Date.today+, and +DateTime.now+ to return the time or date passed into this method.
      # The stubs are automatically removed at the end of the test.
      #
      #   Time.current     # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel_to Time.zone.local(2004, 11, 24, 1, 4, 44)
      #   Time.current     # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      #   Date.current     # => Wed, 24 Nov 2004
      #   DateTime.current # => Wed, 24 Nov 2004 01:04:44 -0500
      #
      # Dates are taken as their timestamp at the beginning of the day in the
      # application time zone. <tt>Time.current</tt> returns said timestamp,
      # and <tt>Time.now</tt> its equivalent in the system time zone. Similarly,
      # <tt>Date.current</tt> returns a date equal to the argument, and
      # <tt>Date.today</tt> the date according to <tt>Time.now</tt>, which may
      # be different. (Note that you rarely want to deal with <tt>Time.now</tt>,
      # or <tt>Date.today</tt>, in order to honor the application time zone
      # please always use <tt>Time.current</tt> and <tt>Date.current</tt>.)
      #
      # Note that the usec for the time passed will be set to 0 to prevent rounding
      # errors with external services, like MySQL (which will round instead of floor,
      # leading to off-by-one-second errors).
      #
      # This method also accepts a block, which will return the current time back to its original
      # state at the end of the block:
      #
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel_to Time.zone.local(2004, 11, 24, 1, 4, 44) do
      #     Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      #   end
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      def travel_to(date_or_time)
        if block_given? && simple_stubs.stubbing(Time, :now)
          travel_to_nested_block_call = <<~MSG

      Calling `travel_to` with a block, when we have previously already made a call to `travel_to`, can lead to confusing time stubbing.

      Instead of:

         travel_to 2.days.from_now do
           # 2 days from today
           travel_to 3.days.from_now do
             # 5 days from today
           end
         end

      preferred way to achieve above is:

         travel 2.days do
           # 2 days from today
         end

         travel 5.days do
           # 5 days from today
         end

          MSG
          raise travel_to_nested_block_call
        end

        if date_or_time.is_a?(Date) && !date_or_time.is_a?(DateTime)
          now = date_or_time.midnight.to_time
        elsif date_or_time.is_a?(String)
          now = Time.zone.parse(date_or_time)
        else
          now = date_or_time.to_time.change(usec: 0)
        end

        simple_stubs.stub_object(Time, :now) { at(now.to_i) }
        simple_stubs.stub_object(Date, :today) { jd(now.to_date.jd) }
        simple_stubs.stub_object(DateTime, :now) { jd(now.to_date.jd, now.hour, now.min, now.sec, Rational(now.utc_offset, 86400)) }

        if block_given?
          begin
            yield
          ensure
            travel_back
          end
        end
      end

      # Returns the current time back to its original state, by removing the stubs added by
      # +travel+, +travel_to+, and +freeze_time+.
      #
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #
      #   travel_to Time.zone.local(2004, 11, 24, 1, 4, 44)
      #   Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      #
      #   travel_back
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #
      # This method also accepts a block, which brings the stubs back at the end of the block:
      #
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #
      #   travel_to Time.zone.local(2004, 11, 24, 1, 4, 44)
      #   Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      #
      #   travel_back do
      #     Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   end
      #
      #   Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      def travel_back
        stubbed_time = Time.current if block_given? && simple_stubs.stubbed?

        simple_stubs.unstub_all!
        yield if block_given?
      ensure
        travel_to stubbed_time if stubbed_time
      end
      alias_method :unfreeze_time, :travel_back

      # Calls +travel_to+ with +Time.now+.
      #
      #   Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #   freeze_time
      #   sleep(1)
      #   Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #
      # This method also accepts a block, which will return the current time back to its original
      # state at the end of the block:
      #
      #   Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #   freeze_time do
      #     sleep(1)
      #     User.create.created_at # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #   end
      #   Time.current # => Sun, 09 Jul 2017 15:34:50 EST -05:00
      def freeze_time(&block)
        travel_to Time.now, &block
      end

      private
        def simple_stubs
          @simple_stubs ||= SimpleStubs.new
        end
    end
# frozen_string_literal: true

require_relative "gem_version"

module ActiveSupport
# frozen_string_literal: true

# in case active_support/inflector is required without the rest of active_support
require "active_support/inflector/inflections"
require "active_support/inflector/transliterate"
# frozen_string_literal: true

require "strscan"

module ActiveSupport
  class Duration
    # Parses a string formatted according to ISO 8601 Duration into the hash.
    #
    # See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information.
    #
    # This parser allows negative parts to be present in pattern.
    class ISO8601Parser # :nodoc:
      class ParsingError < ::ArgumentError; end

      PERIOD_OR_COMMA = /\.|,/
      PERIOD = "."
      COMMA = ","

      SIGN_MARKER = /\A-|\+|/
      DATE_MARKER = /P/
      TIME_MARKER = /T/
      DATE_COMPONENT = /(-?\d+(?:[.,]\d+)?)(Y|M|D|W)/
      TIME_COMPONENT = /(-?\d+(?:[.,]\d+)?)(H|M|S)/

      DATE_TO_PART = { "Y" => :years, "M" => :months, "W" => :weeks, "D" => :days }
      TIME_TO_PART = { "H" => :hours, "M" => :minutes, "S" => :seconds }

      DATE_COMPONENTS = [:years, :months, :days]
      TIME_COMPONENTS = [:hours, :minutes, :seconds]

      attr_reader :parts, :scanner
      attr_accessor :mode, :sign

      def initialize(string)
        @scanner = StringScanner.new(string)
        @parts = {}
        @mode = :start
        @sign = 1
      end

      def parse!
        while !finished?
          case mode
          when :start
            if scan(SIGN_MARKER)
              self.sign = (scanner.matched == "-") ? -1 : 1
              self.mode = :sign
            else
              raise_parsing_error
            end

          when :sign
            if scan(DATE_MARKER)
              self.mode = :date
            else
              raise_parsing_error
            end

          when :date
            if scan(TIME_MARKER)
              self.mode = :time
            elsif scan(DATE_COMPONENT)
              parts[DATE_TO_PART[scanner[2]]] = number * sign
            else
              raise_parsing_error
            end

          when :time
            if scan(TIME_COMPONENT)
              parts[TIME_TO_PART[scanner[2]]] = number * sign
            else
              raise_parsing_error
            end

          end
        end

        validate!
        parts
      end

      private
        def finished?
          scanner.eos?
        end

        # Parses number which can be a float with either comma or period.
        def number
          PERIOD_OR_COMMA.match?(scanner[1]) ? scanner[1].tr(COMMA, PERIOD).to_f : scanner[1].to_i
        end

        def scan(pattern)
          scanner.scan(pattern)
        end

        def raise_parsing_error(reason = nil)
          raise ParsingError, "Invalid ISO 8601 duration: #{scanner.string.inspect} #{reason}".strip
        end

        # Checks for various semantic errors as stated in ISO 8601 standard.
        def validate!
          raise_parsing_error("is empty duration") if parts.empty?

          # Mixing any of Y, M, D with W is invalid.
          if parts.key?(:weeks) && (parts.keys & DATE_COMPONENTS).any?
            raise_parsing_error("mixing weeks with other date parts not allowed")
          end

          # Specifying an empty T part is invalid.
          if mode == :time && (parts.keys & TIME_COMPONENTS).empty?
            raise_parsing_error("time part marker is present but time part is empty")
          end

          fractions = parts.values.reject(&:zero?).select { |a| (a % 1) != 0 }
          unless fractions.empty? || (fractions.size == 1 && fractions.last == @parts.values.reject(&:zero?).last)
            raise_parsing_error "(only last part can be fractional)"
          end

          true
        end
# frozen_string_literal: true

require "active_support/core_ext/object/blank"

module ActiveSupport
  class Duration
    # Serializes duration to string according to ISO 8601 Duration format.
    class ISO8601Serializer # :nodoc:
      DATE_COMPONENTS = %i(years months days)

      def initialize(duration, precision: nil)
        @duration = duration
        @precision = precision
      end

      # Builds and returns output string.
      def serialize
        parts = normalize
        return "PT0S" if parts.empty?

        output = +"P"
        output << "#{parts[:years]}Y"   if parts.key?(:years)
        output << "#{parts[:months]}M"  if parts.key?(:months)
        output << "#{parts[:days]}D"    if parts.key?(:days)
        output << "#{parts[:weeks]}W"   if parts.key?(:weeks)
        time = +""
        time << "#{parts[:hours]}H"     if parts.key?(:hours)
        time << "#{parts[:minutes]}M"   if parts.key?(:minutes)
        if parts.key?(:seconds)
          time << "#{sprintf(@precision ? "%0.0#{@precision}f" : '%g', parts[:seconds])}S"
        end
        output << "T#{time}" unless time.empty?
        output
      end

      private
        # Return pair of duration's parts and whole duration sign.
        # Parts are summarized (as they can become repetitive due to addition, etc).
        # Zero parts are removed as not significant.
        # If all parts are negative it will negate all of them and return minus as a sign.
        def normalize
          parts = @duration.parts.each_with_object(Hash.new(0)) do |(k, v), p|
            p[k] += v  unless v.zero?
          end

          # Convert weeks to days and remove weeks if mixed with date parts
          if week_mixed_with_date?(parts)
            parts[:days] += parts.delete(:weeks) * SECONDS_PER_WEEK / SECONDS_PER_DAY
          end

          parts
        end

        def week_mixed_with_date?(parts)
          parts.key?(:weeks) && (parts.keys & DATE_COMPONENTS).any?
# frozen_string_literal: true

require "active_support/concern"
require "active_support/core_ext/module/attribute_accessors"
require "active_support/logger_thread_safe_level"

module ActiveSupport
  module LoggerSilence
    extend ActiveSupport::Concern

    included do
      cattr_accessor :silencer, default: true
      include ActiveSupport::LoggerThreadSafeLevel
    end

    # Silences the logger for the duration of the block.
    def silence(severity = Logger::ERROR)
      silencer ? log_at(severity) { yield self } : yield(self)
    end
  end
# frozen_string_literal: true

require "zlib"
require "stringio"

module ActiveSupport
  # A convenient wrapper for the zlib standard library that allows
  # compression/decompression of strings with gzip.
  #
  #   gzip = ActiveSupport::Gzip.compress('compress me!')
  #   # => "\x1F\x8B\b\x00o\x8D\xCDO\x00\x03K\xCE\xCF-(J-.V\xC8MU\x04\x00R>n\x83\f\x00\x00\x00"
  #
  #   ActiveSupport::Gzip.decompress(gzip)
  #   # => "compress me!"
  module Gzip
    class Stream < StringIO
      def initialize(*)
        super
        set_encoding "BINARY"
      end
      def close; rewind; end
    end

    # Decompresses a gzipped string.
    def self.decompress(source)
      Zlib::GzipReader.wrap(StringIO.new(source), &:read)
    end

    # Compresses a string using gzip.
    def self.compress(source, level = Zlib::DEFAULT_COMPRESSION, strategy = Zlib::DEFAULT_STRATEGY)
      output = Stream.new
      gz = Zlib::GzipWriter.new(output, level, strategy)
      gz.write(source)
      gz.close
      output.string
# frozen_string_literal: true

require "weakref"

module ActiveSupport
  # This module provides an internal implementation to track descendants
  # which is faster than iterating through ObjectSpace.
  module DescendantsTracker
    @@direct_descendants = {}

    class << self
      def direct_descendants(klass)
        descendants = @@direct_descendants[klass]
        descendants ? descendants.to_a : []
      end
      alias_method :subclasses, :direct_descendants

      def descendants(klass)
        arr = []
        accumulate_descendants(klass, arr)
        arr
      end

      def clear
        if defined? ActiveSupport::Dependencies
          @@direct_descendants.each do |klass, descendants|
            if Dependencies.autoloaded?(klass)
              @@direct_descendants.delete(klass)
            else
              descendants.reject! { |v| Dependencies.autoloaded?(v) }
            end
          end
        else
          @@direct_descendants.clear
        end
      end

      # This is the only method that is not thread safe, but is only ever called
      # during the eager loading phase.
      def store_inherited(klass, descendant)
        (@@direct_descendants[klass] ||= DescendantsArray.new) << descendant
      end

      private
        def accumulate_descendants(klass, acc)
          if direct_descendants = @@direct_descendants[klass]
            direct_descendants.each do |direct_descendant|
              acc << direct_descendant
              accumulate_descendants(direct_descendant, acc)
            end
          end
        end
    end

    def inherited(base)
      DescendantsTracker.store_inherited(self, base)
      super
    end

    def direct_descendants
      DescendantsTracker.direct_descendants(self)
    end
    alias_method :subclasses, :direct_descendants

    def descendants
      DescendantsTracker.descendants(self)
    end

    # DescendantsArray is an array that contains weak references to classes.
    class DescendantsArray # :nodoc:
      include Enumerable

      def initialize
        @refs = []
      end

      def initialize_copy(orig)
        @refs = @refs.dup
      end

      def <<(klass)
        @refs << WeakRef.new(klass)
      end

      def each
        @refs.reject! do |ref|
          yield ref.__getobj__
          false
        rescue WeakRef::RefError
          true
        end
        self
      end

      def refs_size
        @refs.size
      end

      def cleanup!
        @refs.delete_if { |ref| !ref.weakref_alive? }
      end

      def reject!
        @refs.reject! do |ref|
          yield ref.__getobj__
        rescue WeakRef::RefError
          true
        end
      end
    end
# frozen_string_literal: true

require "time"
require "base64"
require "bigdecimal"
require "bigdecimal/util"
require "active_support/core_ext/module/delegation"
require "active_support/core_ext/string/inflections"
require "active_support/core_ext/date_time/calculations"

module ActiveSupport
  # = XmlMini
  #
  # To use the much faster libxml parser:
  #   gem 'libxml-ruby', '=0.9.7'
  #   XmlMini.backend = 'LibXML'
  module XmlMini
    extend self

    # This module decorates files deserialized using Hash.from_xml with
    # the <tt>original_filename</tt> and <tt>content_type</tt> methods.
    module FileLike #:nodoc:
      attr_writer :original_filename, :content_type

      def original_filename
        @original_filename || "untitled"
      end

      def content_type
        @content_type || "application/octet-stream"
      end
    end

    DEFAULT_ENCODINGS = {
      "binary" => "base64"
    } unless defined?(DEFAULT_ENCODINGS)

    unless defined?(TYPE_NAMES)
      TYPE_NAMES = {
        "Symbol"     => "symbol",
        "Integer"    => "integer",
        "BigDecimal" => "decimal",
        "Float"      => "float",
        "TrueClass"  => "boolean",
        "FalseClass" => "boolean",
        "Date"       => "date",
        "DateTime"   => "dateTime",
        "Time"       => "dateTime",
        "Array"      => "array",
        "Hash"       => "hash"
      }
    end

    FORMATTING = {
      "symbol"   => Proc.new { |symbol| symbol.to_s },
      "date"     => Proc.new { |date| date.to_s(:db) },
      "dateTime" => Proc.new { |time| time.xmlschema },
      "binary"   => Proc.new { |binary| ::Base64.encode64(binary) },
      "yaml"     => Proc.new { |yaml| yaml.to_yaml }
    } unless defined?(FORMATTING)

    # TODO use regexp instead of Date.parse
    unless defined?(PARSING)
      PARSING = {
        "symbol"       => Proc.new { |symbol|  symbol.to_s.to_sym },
        "date"         => Proc.new { |date|    ::Date.parse(date) },
        "datetime"     => Proc.new { |time|    Time.xmlschema(time).utc rescue ::DateTime.parse(time).utc },
        "integer"      => Proc.new { |integer| integer.to_i },
        "float"        => Proc.new { |float|   float.to_f },
        "decimal"      => Proc.new do |number|
          if String === number
            number.to_d
          else
            BigDecimal(number)
          end
        end,
        "boolean"      => Proc.new { |boolean| %w(1 true).include?(boolean.to_s.strip) },
        "string"       => Proc.new { |string|  string.to_s },
        "yaml"         => Proc.new { |yaml|    YAML.load(yaml) rescue yaml },
        "base64Binary" => Proc.new { |bin|     ::Base64.decode64(bin) },
        "binary"       => Proc.new { |bin, entity| _parse_binary(bin, entity) },
        "file"         => Proc.new { |file, entity| _parse_file(file, entity) }
      }

      PARSING.update(
        "double"   => PARSING["float"],
        "dateTime" => PARSING["datetime"]
      )
    end

    attr_accessor :depth
    self.depth = 100

    delegate :parse, to: :backend

    def backend
      current_thread_backend || @backend
    end

    def backend=(name)
      backend = name && cast_backend_name_to_module(name)
      self.current_thread_backend = backend if current_thread_backend
      @backend = backend
    end

    def with_backend(name)
      old_backend = current_thread_backend
      self.current_thread_backend = name && cast_backend_name_to_module(name)
      yield
    ensure
      self.current_thread_backend = old_backend
    end

    def to_tag(key, value, options)
      type_name = options.delete(:type)
      merged_options = options.merge(root: key, skip_instruct: true)

      if value.is_a?(::Method) || value.is_a?(::Proc)
        if value.arity == 1
          value.call(merged_options)
        else
          value.call(merged_options, key.to_s.singularize)
        end
      elsif value.respond_to?(:to_xml)
        value.to_xml(merged_options)
      else
        type_name ||= TYPE_NAMES[value.class.name]
        type_name ||= value.class.name if value && !value.respond_to?(:to_str)
        type_name   = type_name.to_s   if type_name
        type_name   = "dateTime" if type_name == "datetime"

        key = rename_key(key.to_s, options)

        attributes = options[:skip_types] || type_name.nil? ? {} : { type: type_name }
        attributes[:nil] = true if value.nil?

        encoding = options[:encoding] || DEFAULT_ENCODINGS[type_name]
        attributes[:encoding] = encoding if encoding

        formatted_value = FORMATTING[type_name] && !value.nil? ?
          FORMATTING[type_name].call(value) : value

        options[:builder].tag!(key, formatted_value, attributes)
      end
    end

    def rename_key(key, options = {})
      camelize  = options[:camelize]
      dasherize = !options.has_key?(:dasherize) || options[:dasherize]
      if camelize
        key = true == camelize ? key.camelize : key.camelize(camelize)
      end
      key = _dasherize(key) if dasherize
      key
    end

    private
      def _dasherize(key)
        # $2 must be a non-greedy regex for this to work
        left, middle, right = /\A(_*)(.*?)(_*)\Z/.match(key.strip)[1, 3]
        "#{left}#{middle.tr('_ ', '--')}#{right}"
      end

      # TODO: Add support for other encodings
      def _parse_binary(bin, entity)
        case entity["encoding"]
        when "base64"
          ::Base64.decode64(bin)
        else
          bin
        end
      end

      def _parse_file(file, entity)
        f = StringIO.new(::Base64.decode64(file))
        f.extend(FileLike)
        f.original_filename = entity["name"]
        f.content_type = entity["content_type"]
        f
      end

      def current_thread_backend
        Thread.current[:xml_mini_backend]
      end

      def current_thread_backend=(name)
        Thread.current[:xml_mini_backend] = name && cast_backend_name_to_module(name)
      end

      def cast_backend_name_to_module(name)
        if name.is_a?(Module)
          name
        else
          require "active_support/xml_mini/#{name.downcase}"
          ActiveSupport.const_get("XmlMini_#{name}")
        end
      end
  end

  XmlMini.backend = "REXML"
# frozen_string_literal: true

require "openssl"
require "base64"
require "active_support/core_ext/module/attribute_accessors"
require "active_support/message_verifier"
require "active_support/messages/metadata"

module ActiveSupport
  # MessageEncryptor is a simple way to encrypt values which get stored
  # somewhere you don't trust.
  #
  # The cipher text and initialization vector are base64 encoded and returned
  # to you.
  #
  # This can be used in situations similar to the <tt>MessageVerifier</tt>, but
  # where you don't want users to be able to determine the value of the payload.
  #
  #   len   = ActiveSupport::MessageEncryptor.key_len
  #   salt  = SecureRandom.random_bytes(len)
  #   key   = ActiveSupport::KeyGenerator.new('password').generate_key(salt, len) # => "\x89\xE0\x156\xAC..."
  #   crypt = ActiveSupport::MessageEncryptor.new(key)                            # => #<ActiveSupport::MessageEncryptor ...>
  #   encrypted_data = crypt.encrypt_and_sign('my secret data')                   # => "NlFBTTMwOUV5UlA1QlNEN2xkY2d6eThYWWh..."
  #   crypt.decrypt_and_verify(encrypted_data)                                    # => "my secret data"
  #
  # === Confining messages to a specific purpose
  #
  # By default any message can be used throughout your app. But they can also be
  # confined to a specific +:purpose+.
  #
  #   token = crypt.encrypt_and_sign("this is the chair", purpose: :login)
  #
  # Then that same purpose must be passed when verifying to get the data back out:
  #
  #   crypt.decrypt_and_verify(token, purpose: :login)    # => "this is the chair"
  #   crypt.decrypt_and_verify(token, purpose: :shipping) # => nil
  #   crypt.decrypt_and_verify(token)                     # => nil
  #
  # Likewise, if a message has no purpose it won't be returned when verifying with
  # a specific purpose.
  #
  #   token = crypt.encrypt_and_sign("the conversation is lively")
  #   crypt.decrypt_and_verify(token, purpose: :scare_tactics) # => nil
  #   crypt.decrypt_and_verify(token)                          # => "the conversation is lively"
  #
  # === Making messages expire
  #
  # By default messages last forever and verifying one year from now will still
  # return the original value. But messages can be set to expire at a given
  # time with +:expires_in+ or +:expires_at+.
  #
  #   crypt.encrypt_and_sign(parcel, expires_in: 1.month)
  #   crypt.encrypt_and_sign(doowad, expires_at: Time.now.end_of_year)
  #
  # Then the messages can be verified and returned up to the expire time.
  # Thereafter, verifying returns +nil+.
  #
  # === Rotating keys
  #
  # MessageEncryptor also supports rotating out old configurations by falling
  # back to a stack of encryptors. Call +rotate+ to build and add an encryptor
  # so +decrypt_and_verify+ will also try the fallback.
  #
  # By default any rotated encryptors use the values of the primary
  # encryptor unless specified otherwise.
  #
  # You'd give your encryptor the new defaults:
  #
  #   crypt = ActiveSupport::MessageEncryptor.new(@secret, cipher: "aes-256-gcm")
  #
  # Then gradually rotate the old values out by adding them as fallbacks. Any message
  # generated with the old values will then work until the rotation is removed.
  #
  #   crypt.rotate old_secret            # Fallback to an old secret instead of @secret.
  #   crypt.rotate cipher: "aes-256-cbc" # Fallback to an old cipher instead of aes-256-gcm.
  #
  # Though if both the secret and the cipher was changed at the same time,
  # the above should be combined into:
  #
  #   crypt.rotate old_secret, cipher: "aes-256-cbc"
  class MessageEncryptor
    prepend Messages::Rotator::Encryptor

    cattr_accessor :use_authenticated_message_encryption, instance_accessor: false, default: false

    class << self
      def default_cipher #:nodoc:
        if use_authenticated_message_encryption
          "aes-256-gcm"
        else
          "aes-256-cbc"
        end
      end
    end

    module NullSerializer #:nodoc:
      def self.load(value)
        value
      end

      def self.dump(value)
        value
      end
    end

    module NullVerifier #:nodoc:
      def self.verify(value)
        value
      end

      def self.generate(value)
        value
      end
    end

    class InvalidMessage < StandardError; end
    OpenSSLCipherError = OpenSSL::Cipher::CipherError

    # Initialize a new MessageEncryptor. +secret+ must be at least as long as
    # the cipher key size. For the default 'aes-256-gcm' cipher, this is 256
    # bits. If you are using a user-entered secret, you can generate a suitable
    # key by using <tt>ActiveSupport::KeyGenerator</tt> or a similar key
    # derivation function.
    #
    # First additional parameter is used as the signature key for +MessageVerifier+.
    # This allows you to specify keys to encrypt and sign data.
    #
    #    ActiveSupport::MessageEncryptor.new('secret', 'signature_secret')
    #
    # Options:
    # * <tt>:cipher</tt>     - Cipher to use. Can be any cipher returned by
    #   <tt>OpenSSL::Cipher.ciphers</tt>. Default is 'aes-256-gcm'.
    # * <tt>:digest</tt> - String of digest to use for signing. Default is
    #   +SHA1+. Ignored when using an AEAD cipher like 'aes-256-gcm'.
    # * <tt>:serializer</tt> - Object serializer to use. Default is +Marshal+.
    def initialize(secret, sign_secret = nil, cipher: nil, digest: nil, serializer: nil)
      @secret = secret
      @sign_secret = sign_secret
      @cipher = cipher || self.class.default_cipher
      @digest = digest || "SHA1" unless aead_mode?
      @verifier = resolve_verifier
      @serializer = serializer || Marshal
    end

    # Encrypt and sign a message. We need to sign the message in order to avoid
    # padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.
    def encrypt_and_sign(value, expires_at: nil, expires_in: nil, purpose: nil)
      verifier.generate(_encrypt(value, expires_at: expires_at, expires_in: expires_in, purpose: purpose))
    end

    # Decrypt and verify a message. We need to verify the message in order to
    # avoid padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.
    def decrypt_and_verify(data, purpose: nil, **)
      _decrypt(verifier.verify(data), purpose)
    end

    # Given a cipher, returns the key length of the cipher to help generate the key of desired size
    def self.key_len(cipher = default_cipher)
      OpenSSL::Cipher.new(cipher).key_len
    end

    private
      def _encrypt(value, **metadata_options)
        cipher = new_cipher
        cipher.encrypt
        cipher.key = @secret

        # Rely on OpenSSL for the initialization vector
        iv = cipher.random_iv
        cipher.auth_data = "" if aead_mode?

        encrypted_data = cipher.update(Messages::Metadata.wrap(@serializer.dump(value), **metadata_options))
        encrypted_data << cipher.final

        blob = "#{::Base64.strict_encode64 encrypted_data}--#{::Base64.strict_encode64 iv}"
        blob = "#{blob}--#{::Base64.strict_encode64 cipher.auth_tag}" if aead_mode?
        blob
      end

      def _decrypt(encrypted_message, purpose)
        cipher = new_cipher
        encrypted_data, iv, auth_tag = encrypted_message.split("--").map { |v| ::Base64.strict_decode64(v) }

        # Currently the OpenSSL bindings do not raise an error if auth_tag is
        # truncated, which would allow an attacker to easily forge it. See
        # https://github.com/ruby/openssl/issues/63
        raise InvalidMessage if aead_mode? && (auth_tag.nil? || auth_tag.bytes.length != 16)

        cipher.decrypt
        cipher.key = @secret
        cipher.iv  = iv
        if aead_mode?
          cipher.auth_tag = auth_tag
          cipher.auth_data = ""
        end

        decrypted_data = cipher.update(encrypted_data)
        decrypted_data << cipher.final

        message = Messages::Metadata.verify(decrypted_data, purpose)
        @serializer.load(message) if message
      rescue OpenSSLCipherError, TypeError, ArgumentError
        raise InvalidMessage
      end

      def new_cipher
        OpenSSL::Cipher.new(@cipher)
      end

      attr_reader :verifier

      def aead_mode?
        @aead_mode ||= new_cipher.authenticated?
      end

      def resolve_verifier
        if aead_mode?
          NullVerifier
        else
          MessageVerifier.new(@sign_secret || @secret, digest: @digest, serializer: NullSerializer)
# frozen_string_literal: true

module ActiveSupport
  # A class with no predefined methods that behaves similarly to Builder's
  # BlankSlate. Used for proxy classes.
  class ProxyObject < ::BasicObject
    undef_method :==
    undef_method :equal?

    # Let ActiveSupport::ProxyObject at least raise exceptions.
# frozen_string_literal: true

require "active_support/logger_silence"
require "active_support/logger_thread_safe_level"
require "logger"

module ActiveSupport
  class Logger < ::Logger
    include LoggerSilence

    # Returns true if the logger destination matches one of the sources
    #
    #   logger = Logger.new(STDOUT)
    #   ActiveSupport::Logger.logger_outputs_to?(logger, STDOUT)
    #   # => true
    def self.logger_outputs_to?(logger, *sources)
      logdev = logger.instance_variable_get(:@logdev)
      logger_source = logdev.dev if logdev.respond_to?(:dev)
      sources.any? { |source| source == logger_source }
    end

    # Broadcasts logs to multiple loggers.
    def self.broadcast(logger) # :nodoc:
      Module.new do
        define_method(:add) do |*args, &block|
          logger.add(*args, &block)
          super(*args, &block)
        end

        define_method(:<<) do |x|
          logger << x
          super(x)
        end

        define_method(:close) do
          logger.close
          super()
        end

        define_method(:progname=) do |name|
          logger.progname = name
          super(name)
        end

        define_method(:formatter=) do |formatter|
          logger.formatter = formatter
          super(formatter)
        end

        define_method(:level=) do |level|
          logger.level = level
          super(level)
        end

        define_method(:local_level=) do |level|
          logger.local_level = level if logger.respond_to?(:local_level=)
          super(level) if respond_to?(:local_level=)
        end

        define_method(:silence) do |level = Logger::ERROR, &block|
          if logger.respond_to?(:silence)
            logger.silence(level) do
              if defined?(super)
                super(level, &block)
              else
                block.call(self)
              end
            end
          else
            if defined?(super)
              super(level, &block)
            else
              block.call(self)
            end
          end
        end
      end
    end

    def initialize(*args, **kwargs)
      super
      @formatter = SimpleFormatter.new
    end

    # Simple formatter which only displays the message.
    class SimpleFormatter < ::Logger::Formatter
      # This method is invoked when a log event occurs
      def call(severity, timestamp, progname, msg)
        "#{String === msg ? msg : msg.inspect}\n"
      end
# frozen_string_literal: true

require "rack/body_proxy"
require "rack/utils"

module ActiveSupport
  module Cache
    module Strategy
      module LocalCache
        #--
        # This class wraps up local storage for middlewares. Only the middleware method should
        # construct them.
        class Middleware # :nodoc:
          attr_reader :name, :local_cache_key

          def initialize(name, local_cache_key)
            @name = name
            @local_cache_key = local_cache_key
            @app = nil
          end

          def new(app)
            @app = app
            self
          end

          def call(env)
            LocalCacheRegistry.set_cache_for(local_cache_key, LocalStore.new)
            response = @app.call(env)
            response[2] = ::Rack::BodyProxy.new(response[2]) do
              LocalCacheRegistry.set_cache_for(local_cache_key, nil)
            end
            cleanup_on_body_close = true
            response
          rescue Rack::Utils::InvalidParameterError
            [400, {}, []]
          ensure
            LocalCacheRegistry.set_cache_for(local_cache_key, nil) unless
              cleanup_on_body_close
          end
# frozen_string_literal: true

require "active_support/core_ext/string/inflections"
require "active_support/per_thread_registry"

module ActiveSupport
  module Cache
    module Strategy
      # Caches that implement LocalCache will be backed by an in-memory cache for the
      # duration of a block. Repeated calls to the cache for the same key will hit the
      # in-memory cache for faster access.
      module LocalCache
        autoload :Middleware, "active_support/cache/strategy/local_cache_middleware"

        # Class for storing and registering the local caches.
        class LocalCacheRegistry # :nodoc:
          extend ActiveSupport::PerThreadRegistry

          def initialize
            @registry = {}
          end

          def cache_for(local_cache_key)
            @registry[local_cache_key]
          end

          def set_cache_for(local_cache_key, value)
            @registry[local_cache_key] = value
          end

          def self.set_cache_for(l, v); instance.set_cache_for l, v; end
          def self.cache_for(l); instance.cache_for l; end
        end

        # Simple memory backed cache. This cache is not thread safe and is intended only
        # for serving as a temporary memory cache for a single thread.
        class LocalStore < Store
          def initialize
            super
            @data = {}
          end

          # Don't allow synchronizing since it isn't thread safe.
          def synchronize # :nodoc:
            yield
          end

          def clear(options = nil)
            @data.clear
          end

          def read_entry(key, **options)
            @data[key]
          end

          def read_multi_entries(keys, **options)
            values = {}

            keys.each do |name|
              entry = read_entry(name, **options)
              values[name] = entry.value if entry
            end

            values
          end

          def write_entry(key, entry, **options)
            entry.dup_value!
            @data[key] = entry
            true
          end

          def delete_entry(key, **options)
            !!@data.delete(key)
          end

          def fetch_entry(key, options = nil) # :nodoc:
            entry = @data.fetch(key) { @data[key] = yield }
            dup_entry = entry.dup
            dup_entry&.dup_value!
            dup_entry
          end
        end

        # Use a local cache for the duration of block.
        def with_local_cache
          use_temporary_local_cache(LocalStore.new) { yield }
        end

        # Middleware class can be inserted as a Rack handler to be local cache for the
        # duration of request.
        def middleware
          @middleware ||= Middleware.new(
            "ActiveSupport::Cache::Strategy::LocalCache",
            local_cache_key)
        end

        def clear(**options) # :nodoc:
          return super unless cache = local_cache
          cache.clear(options)
          super
        end

        def cleanup(**options) # :nodoc:
          return super unless cache = local_cache
          cache.clear
          super
        end

        def delete_matched(matcher, options = nil) # :nodoc:
          return super unless cache = local_cache
          cache.clear
          super
        end

        def increment(name, amount = 1, **options) # :nodoc:
          return super unless local_cache
          value = bypass_local_cache { super }
          write_cache_value(name, value, **options)
          value
        end

        def decrement(name, amount = 1, **options) # :nodoc:
          return super unless local_cache
          value = bypass_local_cache { super }
          write_cache_value(name, value, **options)
          value
        end

        private
          def read_entry(key, **options)
            if cache = local_cache
              hit = true
              value = cache.fetch_entry(key) do
                hit = false
                super
              end
              options[:event][:store] = cache.class.name if hit && options[:event]
              value
            else
              super
            end
          end

          def read_multi_entries(keys, **options)
            return super unless local_cache

            local_entries = local_cache.read_multi_entries(keys, **options)
            missed_keys = keys - local_entries.keys

            if missed_keys.any?
              local_entries.merge!(super(missed_keys, **options))
            else
              local_entries
            end
          end

          def write_entry(key, entry, **options)
            if options[:unless_exist]
              local_cache.delete_entry(key, **options) if local_cache
            else
              local_cache.write_entry(key, entry, **options) if local_cache
            end

            super
          end

          def delete_entry(key, **options)
            local_cache.delete_entry(key, **options) if local_cache
            super
          end

          def write_cache_value(name, value, **options)
            name = normalize_key(name, options)
            cache = local_cache
            cache.mute do
              if value
                cache.write(name, value, options)
              else
                cache.delete(name, **options)
              end
            end
          end

          def local_cache_key
            @local_cache_key ||= "#{self.class.name.underscore}_local_cache_#{object_id}".gsub(/[\/-]/, "_").to_sym
          end

          def local_cache
            LocalCacheRegistry.cache_for(local_cache_key)
          end

          def bypass_local_cache
            use_temporary_local_cache(nil) { yield }
          end

          def use_temporary_local_cache(temporary_cache)
            save_cache = LocalCacheRegistry.cache_for(local_cache_key)
            begin
              LocalCacheRegistry.set_cache_for(local_cache_key, temporary_cache)
              yield
            ensure
              LocalCacheRegistry.set_cache_for(local_cache_key, save_cache)
            end
          end
# frozen_string_literal: true

require "active_support/core_ext/marshal"
require "active_support/core_ext/file/atomic"
require "active_support/core_ext/string/conversions"
require "uri/common"

module ActiveSupport
  module Cache
    # A cache store implementation which stores everything on the filesystem.
    #
    # FileStore implements the Strategy::LocalCache strategy which implements
    # an in-memory cache inside of a block.
    class FileStore < Store
      prepend Strategy::LocalCache
      attr_reader :cache_path

      DIR_FORMATTER = "%03X"
      FILENAME_MAX_SIZE = 226 # max filename size on file system is 255, minus room for timestamp, pid, and random characters appended by Tempfile (used by atomic write)
      FILEPATH_MAX_SIZE = 900 # max is 1024, plus some room
      GITKEEP_FILES = [".gitkeep", ".keep"].freeze

      def initialize(cache_path, **options)
        super(options)
        @cache_path = cache_path.to_s
      end

      # Advertise cache versioning support.
      def self.supports_cache_versioning?
        true
      end

      # Deletes all items from the cache. In this case it deletes all the entries in the specified
      # file store directory except for .keep or .gitkeep. Be careful which directory is specified in your
      # config file when using +FileStore+ because everything in that directory will be deleted.
      def clear(options = nil)
        root_dirs = (Dir.children(cache_path) - GITKEEP_FILES)
        FileUtils.rm_r(root_dirs.collect { |f| File.join(cache_path, f) })
      rescue Errno::ENOENT, Errno::ENOTEMPTY
      end

      # Preemptively iterates through all stored keys and removes the ones which have expired.
      def cleanup(options = nil)
        options = merged_options(options)
        search_dir(cache_path) do |fname|
          entry = read_entry(fname, **options)
          delete_entry(fname, **options) if entry && entry.expired?
        end
      end

      # Increments an already existing integer value that is stored in the cache.
      # If the key is not found nothing is done.
      def increment(name, amount = 1, options = nil)
        modify_value(name, amount, options)
      end

      # Decrements an already existing integer value that is stored in the cache.
      # If the key is not found nothing is done.
      def decrement(name, amount = 1, options = nil)
        modify_value(name, -amount, options)
      end

      def delete_matched(matcher, options = nil)
        options = merged_options(options)
        instrument(:delete_matched, matcher.inspect) do
          matcher = key_matcher(matcher, options)
          search_dir(cache_path) do |path|
            key = file_path_key(path)
            delete_entry(path, **options) if key.match(matcher)
          end
        end
      end

      private
        def read_entry(key, **options)
          if File.exist?(key)
            entry = File.open(key) { |f| deserialize_entry(f.read) }
            entry if entry.is_a?(Cache::Entry)
          end
        rescue => e
          logger.error("FileStoreError (#{e}): #{e.message}") if logger
          nil
        end

        def write_entry(key, entry, **options)
          return false if options[:unless_exist] && File.exist?(key)
          ensure_cache_path(File.dirname(key))
          File.atomic_write(key, cache_path) { |f| f.write(serialize_entry(entry)) }
          true
        end

        def delete_entry(key, **options)
          if File.exist?(key)
            begin
              File.delete(key)
              delete_empty_directories(File.dirname(key))
              true
            rescue => e
              # Just in case the error was caused by another process deleting the file first.
              raise e if File.exist?(key)
              false
            end
          end
        end

        # Lock a file for a block so only one process can modify it at a time.
        def lock_file(file_name, &block)
          if File.exist?(file_name)
            File.open(file_name, "r+") do |f|
              f.flock File::LOCK_EX
              yield
            ensure
              f.flock File::LOCK_UN
            end
          else
            yield
          end
        end

        # Translate a key into a file path.
        def normalize_key(key, options)
          key = super
          fname = URI.encode_www_form_component(key)

          if fname.size > FILEPATH_MAX_SIZE
            fname = ActiveSupport::Digest.hexdigest(key)
          end

          hash = Zlib.adler32(fname)
          hash, dir_1 = hash.divmod(0x1000)
          dir_2 = hash.modulo(0x1000)

          # Make sure file name doesn't exceed file system limits.
          if fname.length < FILENAME_MAX_SIZE
            fname_paths = fname
          else
            fname_paths = []
            begin
              fname_paths << fname[0, FILENAME_MAX_SIZE]
              fname = fname[FILENAME_MAX_SIZE..-1]
            end until fname.blank?
          end

          File.join(cache_path, DIR_FORMATTER % dir_1, DIR_FORMATTER % dir_2, fname_paths)
        end

        # Translate a file path into a key.
        def file_path_key(path)
          fname = path[cache_path.to_s.size..-1].split(File::SEPARATOR, 4).last
          URI.decode_www_form_component(fname, Encoding::UTF_8)
        end

        # Delete empty directories in the cache.
        def delete_empty_directories(dir)
          return if File.realpath(dir) == File.realpath(cache_path)
          if Dir.children(dir).empty?
            Dir.delete(dir) rescue nil
            delete_empty_directories(File.dirname(dir))
          end
        end

        # Make sure a file path's directories exist.
        def ensure_cache_path(path)
          FileUtils.makedirs(path) unless File.exist?(path)
        end

        def search_dir(dir, &callback)
          return if !File.exist?(dir)
          Dir.each_child(dir) do |d|
            name = File.join(dir, d)
            if File.directory?(name)
              search_dir(name, &callback)
            else
              callback.call name
            end
          end
        end

        # Modifies the amount of an already existing integer value that is stored in the cache.
        # If the key is not found nothing is done.
        def modify_value(name, amount, options)
          file_name = normalize_key(name, options)

          lock_file(file_name) do
            options = merged_options(options)

            if num = read(name, options)
              num = num.to_i + amount
              write(name, num, options)
              num
            end
          end
        end
    end
  end
# frozen_string_literal: true

module ActiveSupport
  module Cache
    # A cache store implementation which doesn't actually store anything. Useful in
    # development and test environments where you don't want caching turned on but
    # need to go through the caching interface.
    #
    # This cache does implement the local cache strategy, so values will actually
    # be cached inside blocks that utilize this strategy. See
    # ActiveSupport::Cache::Strategy::LocalCache for more details.
    class NullStore < Store
      prepend Strategy::LocalCache

      # Advertise cache versioning support.
      def self.supports_cache_versioning?
        true
      end

      def clear(options = nil)
      end

      def cleanup(options = nil)
      end

      def increment(name, amount = 1, options = nil)
      end

      def decrement(name, amount = 1, options = nil)
      end

      def delete_matched(matcher, options = nil)
      end

      private
        def read_entry(key, **options)
        end

        def write_entry(key, entry, **options)
          true
        end

        def delete_entry(key, **options)
          false
        end
# frozen_string_literal: true

require "monitor"

module ActiveSupport
  module Cache
    # A cache store implementation which stores everything into memory in the
    # same process. If you're running multiple Ruby on Rails server processes
    # (which is the case if you're using Phusion Passenger or puma clustered mode),
    # then this means that Rails server process instances won't be able
    # to share cache data with each other and this may not be the most
    # appropriate cache in that scenario.
    #
    # This cache has a bounded size specified by the :size options to the
    # initializer (default is 32Mb). When the cache exceeds the allotted size,
    # a cleanup will occur which tries to prune the cache down to three quarters
    # of the maximum size by removing the least recently used entries.
    #
    # Unlike other Cache store implementations, MemoryStore does not compress
    # values by default. MemoryStore does not benefit from compression as much
    # as other Store implementations, as it does not send data over a network.
    # However, when compression is enabled, it still pays the full cost of
    # compression in terms of cpu use.
    #
    # MemoryStore is thread-safe.
    class MemoryStore < Store
      module DupCoder # :nodoc:
        class << self
          def load(entry)
            entry = entry.dup
            entry.dup_value!
            entry
          end

          def dump(entry)
            entry.dup_value!
            entry
          end
        end
      end

      DEFAULT_CODER = DupCoder

      def initialize(options = nil)
        options ||= {}
        # Disable compression by default.
        options[:compress] ||= false
        super(options)
        @data = {}
        @max_size = options[:size] || 32.megabytes
        @max_prune_time = options[:max_prune_time] || 2
        @cache_size = 0
        @monitor = Monitor.new
        @pruning = false
      end

      # Advertise cache versioning support.
      def self.supports_cache_versioning?
        true
      end

      # Delete all data stored in a given cache store.
      def clear(options = nil)
        synchronize do
          @data.clear
          @cache_size = 0
        end
      end

      # Preemptively iterates through all stored keys and removes the ones which have expired.
      def cleanup(options = nil)
        options = merged_options(options)
        instrument(:cleanup, size: @data.size) do
          keys = synchronize { @data.keys }
          keys.each do |key|
            entry = @data[key]
            delete_entry(key, **options) if entry && entry.expired?
          end
        end
      end

      # To ensure entries fit within the specified memory prune the cache by removing the least
      # recently accessed entries.
      def prune(target_size, max_time = nil)
        return if pruning?
        @pruning = true
        begin
          start_time = Concurrent.monotonic_time
          cleanup
          instrument(:prune, target_size, from: @cache_size) do
            keys = synchronize { @data.keys }
            keys.each do |key|
              delete_entry(key, **options)
              return if @cache_size <= target_size || (max_time && Concurrent.monotonic_time - start_time > max_time)
            end
          end
        ensure
          @pruning = false
        end
      end

      # Returns true if the cache is currently being pruned.
      def pruning?
        @pruning
      end

      # Increment an integer value in the cache.
      def increment(name, amount = 1, options = nil)
        modify_value(name, amount, options)
      end

      # Decrement an integer value in the cache.
      def decrement(name, amount = 1, options = nil)
        modify_value(name, -amount, options)
      end

      # Deletes cache entries if the cache key matches a given pattern.
      def delete_matched(matcher, options = nil)
        options = merged_options(options)
        instrument(:delete_matched, matcher.inspect) do
          matcher = key_matcher(matcher, options)
          keys = synchronize { @data.keys }
          keys.each do |key|
            delete_entry(key, **options) if key.match(matcher)
          end
        end
      end

      def inspect # :nodoc:
        "#<#{self.class.name} entries=#{@data.size}, size=#{@cache_size}, options=#{@options.inspect}>"
      end

      # Synchronize calls to the cache. This should be called wherever the underlying cache implementation
      # is not thread safe.
      def synchronize(&block) # :nodoc:
        @monitor.synchronize(&block)
      end

      private
        PER_ENTRY_OVERHEAD = 240

        def cached_size(key, payload)
          key.to_s.bytesize + payload.bytesize + PER_ENTRY_OVERHEAD
        end

        def read_entry(key, **options)
          entry = nil
          synchronize do
            payload = @data.delete(key)
            if payload
              @data[key] = payload
              entry = deserialize_entry(payload)
            end
          end
          entry
        end

        def write_entry(key, entry, **options)
          payload = serialize_entry(entry)
          synchronize do
            return false if options[:unless_exist] && @data.key?(key)

            old_payload = @data[key]
            if old_payload
              @cache_size -= (old_payload.bytesize - payload.bytesize)
            else
              @cache_size += cached_size(key, payload)
            end
            @data[key] = payload
            prune(@max_size * 0.75, @max_prune_time) if @cache_size > @max_size
            true
          end
        end

        def delete_entry(key, **options)
          synchronize do
            payload = @data.delete(key)
            @cache_size -= cached_size(key, payload) if payload
            !!payload
          end
        end

        def modify_value(name, amount, options)
          options = merged_options(options)
          synchronize do
            if num = read(name, options)
              num = num.to_i + amount
              write(name, num, options)
              num
            end
# frozen_string_literal: true

begin
  require "dalli"
rescue LoadError => e
  $stderr.puts "You don't have dalli installed in your application. Please add it to your Gemfile and run bundle install"
  raise e
end

require "active_support/core_ext/enumerable"
require "active_support/core_ext/marshal"
require "active_support/core_ext/array/extract_options"

module ActiveSupport
  module Cache
    # A cache store implementation which stores data in Memcached:
    # https://memcached.org
    #
    # This is currently the most popular cache store for production websites.
    #
    # Special features:
    # - Clustering and load balancing. One can specify multiple memcached servers,
    #   and MemCacheStore will load balance between all available servers. If a
    #   server goes down, then MemCacheStore will ignore it until it comes back up.
    #
    # MemCacheStore implements the Strategy::LocalCache strategy which implements
    # an in-memory cache inside of a block.
    class MemCacheStore < Store
      DEFAULT_CODER = NullCoder # Dalli automatically Marshal values

      # Provide support for raw values in the local cache strategy.
      module LocalCacheWithRaw # :nodoc:
        private
          def write_entry(key, entry, **options)
            if options[:raw] && local_cache
              raw_entry = Entry.new(entry.value.to_s)
              raw_entry.expires_at = entry.expires_at
              super(key, raw_entry, **options)
            else
              super
            end
          end
      end

      # Advertise cache versioning support.
      def self.supports_cache_versioning?
        true
      end

      prepend Strategy::LocalCache
      prepend LocalCacheWithRaw

      ESCAPE_KEY_CHARS = /[\x00-\x20%\x7F-\xFF]/n

      # Creates a new Dalli::Client instance with specified addresses and options.
      # If no addresses are provided, we give nil to Dalli::Client, so it uses its fallbacks:
      # - ENV["MEMCACHE_SERVERS"] (if defined)
      # - "127.0.0.1:11211"        (otherwise)
      #
      #   ActiveSupport::Cache::MemCacheStore.build_mem_cache
      #     # => #<Dalli::Client:0x007f98a47d2028 @servers=["127.0.0.1:11211"], @options={}, @ring=nil>
      #   ActiveSupport::Cache::MemCacheStore.build_mem_cache('localhost:10290')
      #     # => #<Dalli::Client:0x007f98a47b3a60 @servers=["localhost:10290"], @options={}, @ring=nil>
      def self.build_mem_cache(*addresses) # :nodoc:
        addresses = addresses.flatten
        options = addresses.extract_options!
        addresses = nil if addresses.compact.empty?
        pool_options = retrieve_pool_options(options)

        if pool_options.empty?
          Dalli::Client.new(addresses, options)
        else
          ensure_connection_pool_added!
          ConnectionPool.new(pool_options) { Dalli::Client.new(addresses, options.merge(threadsafe: false)) }
        end
      end

      # Creates a new MemCacheStore object, with the given memcached server
      # addresses. Each address is either a host name, or a host-with-port string
      # in the form of "host_name:port". For example:
      #
      #   ActiveSupport::Cache::MemCacheStore.new("localhost", "server-downstairs.localnetwork:8229")
      #
      # If no addresses are provided, but ENV['MEMCACHE_SERVERS'] is defined, it will be used instead. Otherwise,
      # MemCacheStore will connect to localhost:11211 (the default memcached port).
      def initialize(*addresses)
        addresses = addresses.flatten
        options = addresses.extract_options!
        if options.key?(:cache_nils)
          options[:skip_nil] = !options.delete(:cache_nils)
        end
        super(options)

        unless [String, Dalli::Client, NilClass].include?(addresses.first.class)
          raise ArgumentError, "First argument must be an empty array, an array of hosts or a Dalli::Client instance."
        end
        if addresses.first.is_a?(Dalli::Client)
          @data = addresses.first
        else
          mem_cache_options = options.dup
          UNIVERSAL_OPTIONS.each { |name| mem_cache_options.delete(name) }
          @data = self.class.build_mem_cache(*(addresses + [mem_cache_options]))
        end
      end

      # Increment a cached value. This method uses the memcached incr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      def increment(name, amount = 1, options = nil)
        options = merged_options(options)
        instrument(:increment, name, amount: amount) do
          rescue_error_with nil do
            @data.with { |c| c.incr(normalize_key(name, options), amount, options[:expires_in]) }
          end
        end
      end

      # Decrement a cached value. This method uses the memcached decr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      def decrement(name, amount = 1, options = nil)
        options = merged_options(options)
        instrument(:decrement, name, amount: amount) do
          rescue_error_with nil do
            @data.with { |c| c.decr(normalize_key(name, options), amount, options[:expires_in]) }
          end
        end
      end

      # Clear the entire cache on all memcached servers. This method should
      # be used with care when shared cache is being used.
      def clear(options = nil)
        rescue_error_with(nil) { @data.with { |c| c.flush_all } }
      end

      # Get the statistics from the memcached servers.
      def stats
        @data.with { |c| c.stats }
      end

      private
        # Read an entry from the cache.
        def read_entry(key, **options)
          rescue_error_with(nil) { deserialize_entry(@data.with { |c| c.get(key, options) }) }
        end

        # Write an entry to the cache.
        def write_entry(key, entry, **options)
          method = options[:unless_exist] ? :add : :set
          value = options[:raw] ? entry.value.to_s : serialize_entry(entry)
          expires_in = options[:expires_in].to_i
          if options[:race_condition_ttl] && expires_in > 0 && !options[:raw]
            # Set the memcache expire a few minutes in the future to support race condition ttls on read
            expires_in += 5.minutes
          end
          rescue_error_with false do
            # The value "compress: false" prevents duplicate compression within Dalli.
            @data.with { |c| c.send(method, key, value, expires_in, **options, compress: false) }
          end
        end

        # Reads multiple entries from the cache implementation.
        def read_multi_entries(names, **options)
          keys_to_names = names.index_by { |name| normalize_key(name, options) }

          raw_values = @data.with { |c| c.get_multi(keys_to_names.keys) }
          values = {}

          raw_values.each do |key, value|
            entry = deserialize_entry(value)

            unless entry.expired? || entry.mismatched?(normalize_version(keys_to_names[key], options))
              values[keys_to_names[key]] = entry.value
            end
          end

          values
        end

        # Delete an entry from the cache.
        def delete_entry(key, **options)
          rescue_error_with(false) { @data.with { |c| c.delete(key) } }
        end

        # Memcache keys are binaries. So we need to force their encoding to binary
        # before applying the regular expression to ensure we are escaping all
        # characters properly.
        def normalize_key(key, options)
          key = super
          if key
            key = key.dup.force_encoding(Encoding::ASCII_8BIT)
            key = key.gsub(ESCAPE_KEY_CHARS) { |match| "%#{match.getbyte(0).to_s(16).upcase}" }
            key = "#{key[0, 212]}:hash:#{ActiveSupport::Digest.hexdigest(key)}" if key.size > 250
          end
          key
        end

        def deserialize_entry(payload)
          entry = super
          entry = Entry.new(entry, compress: false) if entry && !entry.is_a?(Entry)
          entry
        end

        def rescue_error_with(fallback)
          yield
        rescue Dalli::DalliError => e
          logger.error("DalliError (#{e}): #{e.message}") if logger
          fallback
# frozen_string_literal: true

begin
  gem "redis", ">= 4.0.1"
  require "redis"
  require "redis/distributed"
rescue LoadError
  warn "The Redis cache store requires the redis gem, version 4.0.1 or later. Please add it to your Gemfile: `gem \"redis\", \"~> 4.0\"`"
  raise
end

# Prefer the hiredis driver but don't require it.
begin
  require "redis/connection/hiredis"
rescue LoadError
end

require "active_support/digest"
require "active_support/core_ext/marshal"

module ActiveSupport
  module Cache
    module ConnectionPoolLike
      def with
        yield self
      end
    end

    ::Redis.include(ConnectionPoolLike)
    ::Redis::Distributed.include(ConnectionPoolLike)

    # Redis cache store.
    #
    # Deployment note: Take care to use a *dedicated Redis cache* rather
    # than pointing this at your existing Redis server. It won't cope well
    # with mixed usage patterns and it won't expire cache entries by default.
    #
    # Redis cache server setup guide: https://redis.io/topics/lru-cache
    #
    # * Supports vanilla Redis, hiredis, and Redis::Distributed.
    # * Supports Memcached-like sharding across Redises with Redis::Distributed.
    # * Fault tolerant. If the Redis server is unavailable, no exceptions are
    #   raised. Cache fetches are all misses and writes are dropped.
    # * Local cache. Hot in-memory primary cache within block/middleware scope.
    # * +read_multi+ and +write_multi+ support for Redis mget/mset. Use Redis::Distributed
    #   4.0.1+ for distributed mget support.
    # * +delete_matched+ support for Redis KEYS globs.
    class RedisCacheStore < Store
      # Keys are truncated with the ActiveSupport digest if they exceed 1kB
      MAX_KEY_BYTESIZE = 1024

      DEFAULT_REDIS_OPTIONS = {
        connect_timeout:    20,
        read_timeout:       1,
        write_timeout:      1,
        reconnect_attempts: 0,
      }

      DEFAULT_ERROR_HANDLER = -> (method:, returning:, exception:) do
        if logger
          logger.error { "RedisCacheStore: #{method} failed, returned #{returning.inspect}: #{exception.class}: #{exception.message}" }
        end
      end

      # The maximum number of entries to receive per SCAN call.
      SCAN_BATCH_SIZE = 1000
      private_constant :SCAN_BATCH_SIZE

      # Advertise cache versioning support.
      def self.supports_cache_versioning?
        true
      end

      # Support raw values in the local cache strategy.
      module LocalCacheWithRaw # :nodoc:
        private
          def write_entry(key, entry, **options)
            if options[:raw] && local_cache
              raw_entry = Entry.new(serialize_entry(entry, raw: true))
              raw_entry.expires_at = entry.expires_at
              super(key, raw_entry, **options)
            else
              super
            end
          end

          def write_multi_entries(entries, **options)
            if options[:raw] && local_cache
              raw_entries = entries.map do |key, entry|
                raw_entry = Entry.new(serialize_entry(entry, raw: true))
                raw_entry.expires_at = entry.expires_at
              end.to_h

              super(raw_entries, **options)
            else
              super
            end
          end
      end

      prepend Strategy::LocalCache
      prepend LocalCacheWithRaw

      class << self
        # Factory method to create a new Redis instance.
        #
        # Handles four options: :redis block, :redis instance, single :url
        # string, and multiple :url strings.
        #
        #   Option  Class       Result
        #   :redis  Proc    ->  options[:redis].call
        #   :redis  Object  ->  options[:redis]
        #   :url    String  ->  Redis.new(url: )
        #   :url    Array   ->  Redis::Distributed.new([{ url:  }, { url:  }, ])
        #
        def build_redis(redis: nil, url: nil, **redis_options) #:nodoc:
          urls = Array(url)

          if redis.is_a?(Proc)
            redis.call
          elsif redis
            redis
          elsif urls.size > 1
            build_redis_distributed_client urls: urls, **redis_options
          else
            build_redis_client url: urls.first, **redis_options
          end
        end

        private
          def build_redis_distributed_client(urls:, **redis_options)
            ::Redis::Distributed.new([], DEFAULT_REDIS_OPTIONS.merge(redis_options)).tap do |dist|
              urls.each { |u| dist.add_node url: u }
            end
          end

          def build_redis_client(url:, **redis_options)
            ::Redis.new DEFAULT_REDIS_OPTIONS.merge(redis_options.merge(url: url))
          end
      end

      attr_reader :redis_options
      attr_reader :max_key_bytesize

      # Creates a new Redis cache store.
      #
      # Handles four options: :redis block, :redis instance, single :url
      # string, and multiple :url strings.
      #
      #   Option  Class       Result
      #   :redis  Proc    ->  options[:redis].call
      #   :redis  Object  ->  options[:redis]
      #   :url    String  ->  Redis.new(url: )
      #   :url    Array   ->  Redis::Distributed.new([{ url:  }, { url:  }, ])
      #
      # No namespace is set by default. Provide one if the Redis cache
      # server is shared with other apps: <tt>namespace: 'myapp-cache'</tt>.
      #
      # Compression is enabled by default with a 1kB threshold, so cached
      # values larger than 1kB are automatically compressed. Disable by
      # passing <tt>compress: false</tt> or change the threshold by passing
      # <tt>compress_threshold: 4.kilobytes</tt>.
      #
      # No expiry is set on cache entries by default. Redis is expected to
      # be configured with an eviction policy that automatically deletes
      # least-recently or -frequently used keys when it reaches max memory.
      # See https://redis.io/topics/lru-cache for cache server setup.
      #
      # Race condition TTL is not set by default. This can be used to avoid
      # "thundering herd" cache writes when hot cache entries are expired.
      # See <tt>ActiveSupport::Cache::Store#fetch</tt> for more.
      def initialize(namespace: nil, compress: true, compress_threshold: 1.kilobyte, coder: DEFAULT_CODER, expires_in: nil, race_condition_ttl: nil, error_handler: DEFAULT_ERROR_HANDLER, **redis_options)
        @redis_options = redis_options

        @max_key_bytesize = MAX_KEY_BYTESIZE
        @error_handler = error_handler

        super namespace: namespace,
          compress: compress, compress_threshold: compress_threshold,
          expires_in: expires_in, race_condition_ttl: race_condition_ttl,
          coder: coder
      end

      def redis
        @redis ||= begin
          pool_options = self.class.send(:retrieve_pool_options, redis_options)

          if pool_options.any?
            self.class.send(:ensure_connection_pool_added!)
            ::ConnectionPool.new(pool_options) { self.class.build_redis(**redis_options) }
          else
            self.class.build_redis(**redis_options)
          end
        end
      end

      def inspect
        instance = @redis || @redis_options
        "#<#{self.class} options=#{options.inspect} redis=#{instance.inspect}>"
      end

      # Cache Store API implementation.
      #
      # Read multiple values at once. Returns a hash of requested keys ->
      # fetched values.
      def read_multi(*names)
        if mget_capable?
          instrument(:read_multi, names, options) do |payload|
            read_multi_mget(*names).tap do |results|
              payload[:hits] = results.keys
            end
          end
        else
          super
        end
      end

      # Cache Store API implementation.
      #
      # Supports Redis KEYS glob patterns:
      #
      #   h?llo matches hello, hallo and hxllo
      #   h*llo matches hllo and heeeello
      #   h[ae]llo matches hello and hallo, but not hillo
      #   h[^e]llo matches hallo, hbllo, ... but not hello
      #   h[a-b]llo matches hallo and hbllo
      #
      # Use \ to escape special characters if you want to match them verbatim.
      #
      # See https://redis.io/commands/KEYS for more.
      #
      # Failsafe: Raises errors.
      def delete_matched(matcher, options = nil)
        instrument :delete_matched, matcher do
          unless String === matcher
            raise ArgumentError, "Only Redis glob strings are supported: #{matcher.inspect}"
          end
          redis.with do |c|
            pattern = namespace_key(matcher, options)
            cursor = "0"
            # Fetch keys in batches using SCAN to avoid blocking the Redis server.
            nodes = c.respond_to?(:nodes) ? c.nodes : [c]

            nodes.each do |node|
              begin
                cursor, keys = node.scan(cursor, match: pattern, count: SCAN_BATCH_SIZE)
                node.del(*keys) unless keys.empty?
              end until cursor == "0"
            end
          end
        end
      end

      # Cache Store API implementation.
      #
      # Increment a cached value. This method uses the Redis incr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      #
      # Failsafe: Raises errors.
      def increment(name, amount = 1, options = nil)
        instrument :increment, name, amount: amount do
          failsafe :increment do
            options = merged_options(options)
            key = normalize_key(name, options)

            redis.with do |c|
              c.incrby(key, amount).tap do
                write_key_expiry(c, key, options)
              end
            end
          end
        end
      end

      # Cache Store API implementation.
      #
      # Decrement a cached value. This method uses the Redis decr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      #
      # Failsafe: Raises errors.
      def decrement(name, amount = 1, options = nil)
        instrument :decrement, name, amount: amount do
          failsafe :decrement do
            options = merged_options(options)
            key = normalize_key(name, options)

            redis.with do |c|
              c.decrby(key, amount).tap do
                write_key_expiry(c, key, options)
              end
            end
          end
        end
      end

      # Cache Store API implementation.
      #
      # Removes expired entries. Handled natively by Redis least-recently-/
      # least-frequently-used expiry, so manual cleanup is not supported.
      def cleanup(options = nil)
        super
      end

      # Clear the entire cache on all Redis servers. Safe to use on
      # shared servers if the cache is namespaced.
      #
      # Failsafe: Raises errors.
      def clear(options = nil)
        failsafe :clear do
          if namespace = merged_options(options)[:namespace]
            delete_matched "*", namespace: namespace
          else
            redis.with { |c| c.flushdb }
          end
        end
      end

      # Get info from redis servers.
      def stats
        redis.with { |c| c.info }
      end

      def mget_capable? #:nodoc:
        set_redis_capabilities unless defined? @mget_capable
        @mget_capable
      end

      def mset_capable? #:nodoc:
        set_redis_capabilities unless defined? @mset_capable
        @mset_capable
      end

      private
        def set_redis_capabilities
          case redis
          when Redis::Distributed
            @mget_capable = true
            @mset_capable = false
          else
            @mget_capable = true
            @mset_capable = true
          end
        end

        # Store provider interface:
        # Read an entry from the cache.
        def read_entry(key, **options)
          failsafe :read_entry do
            raw = options&.fetch(:raw, false)
            deserialize_entry(redis.with { |c| c.get(key) }, raw: raw)
          end
        end

        def read_multi_entries(names, **options)
          if mget_capable?
            read_multi_mget(*names, **options)
          else
            super
          end
        end

        def read_multi_mget(*names)
          options = names.extract_options!
          options = merged_options(options)
          return {} if names == []
          raw = options&.fetch(:raw, false)

          keys = names.map { |name| normalize_key(name, options) }

          values = failsafe(:read_multi_mget, returning: {}) do
            redis.with { |c| c.mget(*keys) }
          end

          names.zip(values).each_with_object({}) do |(name, value), results|
            if value
              entry = deserialize_entry(value, raw: raw)
              unless entry.nil? || entry.expired? || entry.mismatched?(normalize_version(name, options))
                results[name] = entry.value
              end
            end
          end
        end

        # Write an entry to the cache.
        #
        # Requires Redis 2.6.12+ for extended SET options.
        def write_entry(key, entry, unless_exist: false, raw: false, expires_in: nil, race_condition_ttl: nil, **options)
          serialized_entry = serialize_entry(entry, raw: raw)

          # If race condition TTL is in use, ensure that cache entries
          # stick around a bit longer after they would have expired
          # so we can purposefully serve stale entries.
          if race_condition_ttl && expires_in && expires_in > 0 && !raw
            expires_in += 5.minutes
          end

          failsafe :write_entry, returning: false do
            if unless_exist || expires_in
              modifiers = {}
              modifiers[:nx] = unless_exist
              modifiers[:px] = (1000 * expires_in.to_f).ceil if expires_in

              redis.with { |c| c.set key, serialized_entry, **modifiers }
            else
              redis.with { |c| c.set key, serialized_entry }
            end
          end
        end

        def write_key_expiry(client, key, options)
          if options[:expires_in] && client.ttl(key).negative?
            client.expire key, options[:expires_in].to_i
          end
        end

        # Delete an entry from the cache.
        def delete_entry(key, options)
          failsafe :delete_entry, returning: false do
            redis.with { |c| c.del key }
          end
        end

        # Deletes multiple entries in the cache. Returns the number of entries deleted.
        def delete_multi_entries(entries, **_options)
          redis.with { |c| c.del(entries) }
        end

        # Nonstandard store provider API to write multiple values at once.
        def write_multi_entries(entries, expires_in: nil, **options)
          if entries.any?
            if mset_capable? && expires_in.nil?
              failsafe :write_multi_entries do
                redis.with { |c| c.mapped_mset(serialize_entries(entries, raw: options[:raw])) }
              end
            else
              super
            end
          end
        end

        # Truncate keys that exceed 1kB.
        def normalize_key(key, options)
          truncate_key super&.b
        end

        def truncate_key(key)
          if key && key.bytesize > max_key_bytesize
            suffix = ":hash:#{ActiveSupport::Digest.hexdigest(key)}"
            truncate_at = max_key_bytesize - suffix.bytesize
            "#{key.byteslice(0, truncate_at)}#{suffix}"
          else
            key
          end
        end

        def deserialize_entry(payload, raw:)
          if payload && raw
            Entry.new(payload, compress: false)
          else
            super(payload)
          end
        end

        def serialize_entry(entry, raw: false)
          if raw
            entry.value.to_s
          else
            super(entry)
          end
        end

        def serialize_entries(entries, raw: false)
          entries.transform_values do |entry|
            serialize_entry entry, raw: raw
          end
        end

        def failsafe(method, returning: nil)
          yield
        rescue ::Redis::BaseError => e
          handle_exception exception: e, method: method, returning: returning
          returning
        end

        def handle_exception(exception:, method:, returning:)
          if @error_handler
            @error_handler.(method: method, exception: exception, returning: returning)
          end
        rescue => failsafe
          warn "RedisCacheStore ignored exception in handle_exception: #{failsafe.class}: #{failsafe.message}\n  #{failsafe.backtrace.join("\n  ")}"
        end
# frozen_string_literal: true

require "base64"
require "active_support/core_ext/object/blank"
require "active_support/security_utils"
require "active_support/messages/metadata"
require "active_support/messages/rotator"

module ActiveSupport
  # +MessageVerifier+ makes it easy to generate and verify messages which are
  # signed to prevent tampering.
  #
  # This is useful for cases like remember-me tokens and auto-unsubscribe links
  # where the session store isn't suitable or available.
  #
  # Remember Me:
  #   cookies[:remember_me] = @verifier.generate([@user.id, 2.weeks.from_now])
  #
  # In the authentication filter:
  #
  #   id, time = @verifier.verify(cookies[:remember_me])
  #   if Time.now < time
  #     self.current_user = User.find(id)
  #   end
  #
  # By default it uses Marshal to serialize the message. If you want to use
  # another serialization method, you can set the serializer in the options
  # hash upon initialization:
  #
  #   @verifier = ActiveSupport::MessageVerifier.new('s3Krit', serializer: YAML)
  #
  # +MessageVerifier+ creates HMAC signatures using SHA1 hash algorithm by default.
  # If you want to use a different hash algorithm, you can change it by providing
  # +:digest+ key as an option while initializing the verifier:
  #
  #   @verifier = ActiveSupport::MessageVerifier.new('s3Krit', digest: 'SHA256')
  #
  # === Confining messages to a specific purpose
  #
  # By default any message can be used throughout your app. But they can also be
  # confined to a specific +:purpose+.
  #
  #   token = @verifier.generate("this is the chair", purpose: :login)
  #
  # Then that same purpose must be passed when verifying to get the data back out:
  #
  #   @verifier.verified(token, purpose: :login)    # => "this is the chair"
  #   @verifier.verified(token, purpose: :shipping) # => nil
  #   @verifier.verified(token)                     # => nil
  #
  #   @verifier.verify(token, purpose: :login)      # => "this is the chair"
  #   @verifier.verify(token, purpose: :shipping)   # => ActiveSupport::MessageVerifier::InvalidSignature
  #   @verifier.verify(token)                       # => ActiveSupport::MessageVerifier::InvalidSignature
  #
  # Likewise, if a message has no purpose it won't be returned when verifying with
  # a specific purpose.
  #
  #   token = @verifier.generate("the conversation is lively")
  #   @verifier.verified(token, purpose: :scare_tactics) # => nil
  #   @verifier.verified(token)                          # => "the conversation is lively"
  #
  #   @verifier.verify(token, purpose: :scare_tactics)   # => ActiveSupport::MessageVerifier::InvalidSignature
  #   @verifier.verify(token)                            # => "the conversation is lively"
  #
  # === Making messages expire
  #
  # By default messages last forever and verifying one year from now will still
  # return the original value. But messages can be set to expire at a given
  # time with +:expires_in+ or +:expires_at+.
  #
  #   @verifier.generate("parcel", expires_in: 1.month)
  #   @verifier.generate("doowad", expires_at: Time.now.end_of_year)
  #
  # Then the messages can be verified and returned up to the expire time.
  # Thereafter, the +verified+ method returns +nil+ while +verify+ raises
  # <tt>ActiveSupport::MessageVerifier::InvalidSignature</tt>.
  #
  # === Rotating keys
  #
  # MessageVerifier also supports rotating out old configurations by falling
  # back to a stack of verifiers. Call +rotate+ to build and add a verifier to
  # so either +verified+ or +verify+ will also try verifying with the fallback.
  #
  # By default any rotated verifiers use the values of the primary
  # verifier unless specified otherwise.
  #
  # You'd give your verifier the new defaults:
  #
  #   verifier = ActiveSupport::MessageVerifier.new(@secret, digest: "SHA512", serializer: JSON)
  #
  # Then gradually rotate the old values out by adding them as fallbacks. Any message
  # generated with the old values will then work until the rotation is removed.
  #
  #   verifier.rotate old_secret          # Fallback to an old secret instead of @secret.
  #   verifier.rotate digest: "SHA256"    # Fallback to an old digest instead of SHA512.
  #   verifier.rotate serializer: Marshal # Fallback to an old serializer instead of JSON.
  #
  # Though the above would most likely be combined into one rotation:
  #
  #   verifier.rotate old_secret, digest: "SHA256", serializer: Marshal
  class MessageVerifier
    prepend Messages::Rotator::Verifier

    class InvalidSignature < StandardError; end

    def initialize(secret, digest: nil, serializer: nil)
      raise ArgumentError, "Secret should not be nil." unless secret
      @secret = secret
      @digest = digest || "SHA1"
      @serializer = serializer || Marshal
    end

    # Checks if a signed message could have been generated by signing an object
    # with the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #   verifier.valid_message?(signed_message) # => true
    #
    #   tampered_message = signed_message.chop # editing the message invalidates the signature
    #   verifier.valid_message?(tampered_message) # => false
    def valid_message?(signed_message)
      return if signed_message.nil? || !signed_message.valid_encoding? || signed_message.blank?

      data, digest = signed_message.split("--")
      data.present? && digest.present? && ActiveSupport::SecurityUtils.secure_compare(digest, generate_digest(data))
    end

    # Decodes the signed message using the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #
    #   signed_message = verifier.generate 'a private message'
    #   verifier.verified(signed_message) # => 'a private message'
    #
    # Returns +nil+ if the message was not signed with the same secret.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verified(signed_message) # => nil
    #
    # Returns +nil+ if the message is not Base64-encoded.
    #
    #   invalid_message = "f--46a0120593880c733a53b6dad75b42ddc1c8996d"
    #   verifier.verified(invalid_message) # => nil
    #
    # Raises any error raised while decoding the signed message.
    #
    #   incompatible_message = "test--dad7b06c94abba8d46a15fafaef56c327665d5ff"
    #   verifier.verified(incompatible_message) # => TypeError: incompatible marshal file format
    def verified(signed_message, purpose: nil, **)
      if valid_message?(signed_message)
        begin
          data = signed_message.split("--")[0]
          message = Messages::Metadata.verify(decode(data), purpose)
          @serializer.load(message) if message
        rescue ArgumentError => argument_error
          return if argument_error.message.include?("invalid base64")
          raise
        end
      end
    end

    # Decodes the signed message using the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #
    #   verifier.verify(signed_message) # => 'a private message'
    #
    # Raises +InvalidSignature+ if the message was not signed with the same
    # secret or was not Base64-encoded.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verify(signed_message) # => ActiveSupport::MessageVerifier::InvalidSignature
    def verify(*args, **options)
      verified(*args, **options) || raise(InvalidSignature)
    end

    # Generates a signed message for the provided value.
    #
    # The message is signed with the +MessageVerifier+'s secret.
    # Returns Base64-encoded message joined with the generated signature.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   verifier.generate 'a private message' # => "BAhJIhRwcml2YXRlLW1lc3NhZ2UGOgZFVA==--e2d724331ebdee96a10fb99b089508d1c72bd772"
    def generate(value, expires_at: nil, expires_in: nil, purpose: nil)
      data = encode(Messages::Metadata.wrap(@serializer.dump(value), expires_at: expires_at, expires_in: expires_in, purpose: purpose))
      "#{data}--#{generate_digest(data)}"
    end

    private
      def encode(data)
        ::Base64.strict_encode64(data)
      end

      def decode(data)
        ::Base64.strict_decode64(data)
      end

      def generate_digest(data)
# frozen_string_literal: true

raise "JRuby is required to use the JDOM backend for XmlMini" unless RUBY_PLATFORM.include?("java")

require "jruby"
include Java

require "active_support/core_ext/object/blank"

java_import javax.xml.parsers.DocumentBuilder unless defined? DocumentBuilder
java_import javax.xml.parsers.DocumentBuilderFactory unless defined? DocumentBuilderFactory
java_import java.io.StringReader unless defined? StringReader
java_import org.xml.sax.InputSource unless defined? InputSource
java_import org.xml.sax.Attributes unless defined? Attributes
java_import org.w3c.dom.Node unless defined? Node

module ActiveSupport
  module XmlMini_JDOM #:nodoc:
    extend self

    CONTENT_KEY = "__content__"

    NODE_TYPE_NAMES = %w{ATTRIBUTE_NODE CDATA_SECTION_NODE COMMENT_NODE DOCUMENT_FRAGMENT_NODE
    DOCUMENT_NODE DOCUMENT_TYPE_NODE ELEMENT_NODE ENTITY_NODE ENTITY_REFERENCE_NODE NOTATION_NODE
    PROCESSING_INSTRUCTION_NODE TEXT_NODE}

    node_type_map = {}
    NODE_TYPE_NAMES.each { |type| node_type_map[Node.send(type)] = type }

    # Parse an XML Document string or IO into a simple hash using Java's jdom.
    # data::
    #   XML Document string or IO to parse
    def parse(data)
      if data.respond_to?(:read)
        data = data.read
      end

      if data.blank?
        {}
      else
        @dbf = DocumentBuilderFactory.new_instance
        # secure processing of java xml
        # https://archive.is/9xcQQ
        @dbf.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
        @dbf.setFeature("http://xml.org/sax/features/external-general-entities", false)
        @dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false)
        @dbf.setFeature(javax.xml.XMLConstants::FEATURE_SECURE_PROCESSING, true)
        xml_string_reader = StringReader.new(data)
        xml_input_source = InputSource.new(xml_string_reader)
        doc = @dbf.new_document_builder.parse(xml_input_source)
        merge_element!({ CONTENT_KEY => "" }, doc.document_element, XmlMini.depth)
      end
    end

    private
      # Convert an XML element and merge into the hash
      #
      # hash::
      #   Hash to merge the converted element into.
      # element::
      #   XML element to merge into hash
      def merge_element!(hash, element, depth)
        raise "Document too deep!" if depth == 0
        delete_empty(hash)
        merge!(hash, element.tag_name, collapse(element, depth))
      end

      def delete_empty(hash)
        hash.delete(CONTENT_KEY) if hash[CONTENT_KEY] == ""
      end

      # Actually converts an XML document element into a data structure.
      #
      # element::
      #   The document element to be collapsed.
      def collapse(element, depth)
        hash = get_attributes(element)

        child_nodes = element.child_nodes
        if child_nodes.length > 0
          (0...child_nodes.length).each do |i|
            child = child_nodes.item(i)
            merge_element!(hash, child, depth - 1) unless child.node_type == Node.TEXT_NODE
          end
          merge_texts!(hash, element) unless empty_content?(element)
          hash
        else
          merge_texts!(hash, element)
        end
      end

      # Merge all the texts of an element into the hash
      #
      # hash::
      #   Hash to add the converted element to.
      # element::
      #   XML element whose texts are to me merged into the hash
      def merge_texts!(hash, element)
        delete_empty(hash)
        text_children = texts(element)
        if text_children.join.empty?
          hash
        else
          # must use value to prevent double-escaping
          merge!(hash, CONTENT_KEY, text_children.join)
        end
      end

      # Adds a new key/value pair to an existing Hash. If the key to be added
      # already exists and the existing value associated with key is not
      # an Array, it will be wrapped in an Array. Then the new value is
      # appended to that Array.
      #
      # hash::
      #   Hash to add key/value pair to.
      # key::
      #   Key to be added.
      # value::
      #   Value to be associated with key.
      def merge!(hash, key, value)
        if hash.has_key?(key)
          if hash[key].instance_of?(Array)
            hash[key] << value
          else
            hash[key] = [hash[key], value]
          end
        elsif value.instance_of?(Array)
          hash[key] = [value]
        else
          hash[key] = value
        end
        hash
      end

      # Converts the attributes array of an XML element into a hash.
      # Returns an empty Hash if node has no attributes.
      #
      # element::
      #   XML element to extract attributes from.
      def get_attributes(element)
        attribute_hash = {}
        attributes = element.attributes
        (0...attributes.length).each do |i|
          attribute_hash[CONTENT_KEY] ||= ""
          attribute_hash[attributes.item(i).name] = attributes.item(i).value
        end
        attribute_hash
      end

      # Determines if a document element has text content
      #
      # element::
      #   XML element to be checked.
      def texts(element)
        texts = []
        child_nodes = element.child_nodes
        (0...child_nodes.length).each do |i|
          item = child_nodes.item(i)
          if item.node_type == Node.TEXT_NODE
            texts << item.get_data
          end
        end
        texts
      end

      # Determines if a document element has text content
      #
      # element::
      #   XML element to be checked.
      def empty_content?(element)
        text = +""
        child_nodes = element.child_nodes
        (0...child_nodes.length).each do |i|
          item = child_nodes.item(i)
          if item.node_type == Node.TEXT_NODE
            text << item.get_data.strip
          end
        end
        text.strip.length == 0
      end
# frozen_string_literal: true

begin
  require "nokogiri"
rescue LoadError => e
  $stderr.puts "You don't have nokogiri installed in your application. Please add it to your Gemfile and run bundle install"
  raise e
end
require "active_support/core_ext/object/blank"
require "stringio"

module ActiveSupport
  module XmlMini_Nokogiri #:nodoc:
    extend self

    # Parse an XML Document string or IO into a simple hash using libxml / nokogiri.
    # data::
    #   XML Document string or IO to parse
    def parse(data)
      if !data.respond_to?(:read)
        data = StringIO.new(data || "")
      end

      if data.eof?
        {}
      else
        doc = Nokogiri::XML(data)
        raise doc.errors.first if doc.errors.length > 0
        doc.to_hash
      end
    end

    module Conversions #:nodoc:
      module Document #:nodoc:
        def to_hash
          root.to_hash
        end
      end

      module Node #:nodoc:
        CONTENT_ROOT = "__content__"

        # Convert XML document to hash.
        #
        # hash::
        #   Hash to merge the converted element into.
        def to_hash(hash = {})
          node_hash = {}

          # Insert node hash into parent hash correctly.
          case hash[name]
          when Array then hash[name] << node_hash
          when Hash  then hash[name] = [hash[name], node_hash]
          when nil   then hash[name] = node_hash
          end

          # Handle child elements
          children.each do |c|
            if c.element?
              c.to_hash(node_hash)
            elsif c.text? || c.cdata?
              node_hash[CONTENT_ROOT] ||= +""
              node_hash[CONTENT_ROOT] << c.content
            end
          end

          # Remove content node if it is blank and there are child tags
          if node_hash.length > 1 && node_hash[CONTENT_ROOT].blank?
            node_hash.delete(CONTENT_ROOT)
          end

          # Handle attributes
          attribute_nodes.each { |a| node_hash[a.node_name] = a.value }

          hash
        end
      end
    end

    Nokogiri::XML::Document.include(Conversions::Document)
# frozen_string_literal: true

require "active_support/core_ext/kernel/reporting"
require "active_support/core_ext/object/blank"
require "stringio"

module ActiveSupport
  module XmlMini_REXML #:nodoc:
    extend self

    CONTENT_KEY = "__content__"

    # Parse an XML Document string or IO into a simple hash.
    #
    # Same as XmlSimple::xml_in but doesn't shoot itself in the foot,
    # and uses the defaults from Active Support.
    #
    # data::
    #   XML Document string or IO to parse
    def parse(data)
      if !data.respond_to?(:read)
        data = StringIO.new(data || "")
      end

      if data.eof?
        {}
      else
        require_rexml unless defined?(REXML::Document)
        doc = REXML::Document.new(data)

        if doc.root
          merge_element!({}, doc.root, XmlMini.depth)
        else
          raise REXML::ParseException,
            "The document #{doc.to_s.inspect} does not have a valid root"
        end
      end
    end

    private
      def require_rexml
        silence_warnings { require "rexml/document" }
      rescue LoadError => e
        $stderr.puts "You don't have rexml installed in your application. Please add it to your Gemfile and run bundle install"
        raise e
      end

      # Convert an XML element and merge into the hash
      #
      # hash::
      #   Hash to merge the converted element into.
      # element::
      #   XML element to merge into hash
      def merge_element!(hash, element, depth)
        raise REXML::ParseException, "The document is too deep" if depth == 0
        merge!(hash, element.name, collapse(element, depth))
      end

      # Actually converts an XML document element into a data structure.
      #
      # element::
      #   The document element to be collapsed.
      def collapse(element, depth)
        hash = get_attributes(element)

        if element.has_elements?
          element.each_element { |child| merge_element!(hash, child, depth - 1) }
          merge_texts!(hash, element) unless empty_content?(element)
          hash
        else
          merge_texts!(hash, element)
        end
      end

      # Merge all the texts of an element into the hash
      #
      # hash::
      #   Hash to add the converted element to.
      # element::
      #   XML element whose texts are to me merged into the hash
      def merge_texts!(hash, element)
        unless element.has_text?
          hash
        else
          # must use value to prevent double-escaping
          texts = +""
          element.texts.each { |t| texts << t.value }
          merge!(hash, CONTENT_KEY, texts)
        end
      end

      # Adds a new key/value pair to an existing Hash. If the key to be added
      # already exists and the existing value associated with key is not
      # an Array, it will be wrapped in an Array. Then the new value is
      # appended to that Array.
      #
      # hash::
      #   Hash to add key/value pair to.
      # key::
      #   Key to be added.
      # value::
      #   Value to be associated with key.
      def merge!(hash, key, value)
        if hash.has_key?(key)
          if hash[key].instance_of?(Array)
            hash[key] << value
          else
            hash[key] = [hash[key], value]
          end
        elsif value.instance_of?(Array)
          hash[key] = [value]
        else
          hash[key] = value
        end
        hash
      end

      # Converts the attributes array of an XML element into a hash.
      # Returns an empty Hash if node has no attributes.
      #
      # element::
      #   XML element to extract attributes from.
      def get_attributes(element)
        attributes = {}
        element.attributes.each { |n, v| attributes[n] = v }
        attributes
      end

      # Determines if a document element has text content
      #
      # element::
      #   XML element to be checked.
      def empty_content?(element)
        element.texts.join.blank?
      end
# frozen_string_literal: true

require "libxml"
require "active_support/core_ext/object/blank"
require "stringio"

module ActiveSupport
  module XmlMini_LibXMLSAX #:nodoc:
    extend self

    # Class that will build the hash while the XML document
    # is being parsed using SAX events.
    class HashBuilder
      include LibXML::XML::SaxParser::Callbacks

      CONTENT_KEY   = "__content__"
      HASH_SIZE_KEY = "__hash_size__"

      attr_reader :hash

      def current_hash
        @hash_stack.last
      end

      def on_start_document
        @hash = { CONTENT_KEY => +"" }
        @hash_stack = [@hash]
      end

      def on_end_document
        @hash = @hash_stack.pop
        @hash.delete(CONTENT_KEY)
      end

      def on_start_element(name, attrs = {})
        new_hash = { CONTENT_KEY => +"" }.merge!(attrs)
        new_hash[HASH_SIZE_KEY] = new_hash.size + 1

        case current_hash[name]
        when Array then current_hash[name] << new_hash
        when Hash  then current_hash[name] = [current_hash[name], new_hash]
        when nil   then current_hash[name] = new_hash
        end

        @hash_stack.push(new_hash)
      end

      def on_end_element(name)
        if current_hash.length > current_hash.delete(HASH_SIZE_KEY) && current_hash[CONTENT_KEY].blank? || current_hash[CONTENT_KEY] == ""
          current_hash.delete(CONTENT_KEY)
        end
        @hash_stack.pop
      end

      def on_characters(string)
        current_hash[CONTENT_KEY] << string
      end

      alias_method :on_cdata_block, :on_characters
    end

    attr_accessor :document_class
    self.document_class = HashBuilder

    def parse(data)
      if !data.respond_to?(:read)
        data = StringIO.new(data || "")
      end

      if data.eof?
        {}
      else
        LibXML::XML::Error.set_handler(&LibXML::XML::Error::QUIET_HANDLER)
        parser = LibXML::XML::SaxParser.io(data)
        document = document_class.new

        parser.callbacks = document
        parser.parse
        document.hash
      end
# frozen_string_literal: true

begin
  require "nokogiri"
rescue LoadError => e
  $stderr.puts "You don't have nokogiri installed in your application. Please add it to your Gemfile and run bundle install"
  raise e
end
require "active_support/core_ext/object/blank"
require "stringio"

module ActiveSupport
  module XmlMini_NokogiriSAX #:nodoc:
    extend self

    # Class that will build the hash while the XML document
    # is being parsed using SAX events.
    class HashBuilder < Nokogiri::XML::SAX::Document
      CONTENT_KEY   = "__content__"
      HASH_SIZE_KEY = "__hash_size__"

      attr_reader :hash

      def current_hash
        @hash_stack.last
      end

      def start_document
        @hash = {}
        @hash_stack = [@hash]
      end

      def end_document
        raise "Parse stack not empty!" if @hash_stack.size > 1
      end

      def error(error_message)
        raise error_message
      end

      def start_element(name, attrs = [])
        new_hash = { CONTENT_KEY => +"" }.merge!(Hash[attrs])
        new_hash[HASH_SIZE_KEY] = new_hash.size + 1

        case current_hash[name]
        when Array then current_hash[name] << new_hash
        when Hash  then current_hash[name] = [current_hash[name], new_hash]
        when nil   then current_hash[name] = new_hash
        end

        @hash_stack.push(new_hash)
      end

      def end_element(name)
        if current_hash.length > current_hash.delete(HASH_SIZE_KEY) && current_hash[CONTENT_KEY].blank? || current_hash[CONTENT_KEY] == ""
          current_hash.delete(CONTENT_KEY)
        end
        @hash_stack.pop
      end

      def characters(string)
        current_hash[CONTENT_KEY] << string
      end

      alias_method :cdata_block, :characters
    end

    attr_accessor :document_class
    self.document_class = HashBuilder

    def parse(data)
      if !data.respond_to?(:read)
        data = StringIO.new(data || "")
      end

      if data.eof?
        {}
      else
        document = document_class.new
        parser = Nokogiri::XML::SAX::Parser.new(document)
        parser.parse(data)
        document.hash
      end
    end
  end
# frozen_string_literal: true

require "libxml"
require "active_support/core_ext/object/blank"
require "stringio"

module ActiveSupport
  module XmlMini_LibXML #:nodoc:
    extend self

    # Parse an XML Document string or IO into a simple hash using libxml.
    # data::
    #   XML Document string or IO to parse
    def parse(data)
      if !data.respond_to?(:read)
        data = StringIO.new(data || "")
      end

      if data.eof?
        {}
      else
        LibXML::XML::Parser.io(data).parse.to_hash
      end
    end
  end
end

module LibXML #:nodoc:
  module Conversions #:nodoc:
    module Document #:nodoc:
      def to_hash
        root.to_hash
      end
    end

    module Node #:nodoc:
      CONTENT_ROOT = "__content__"

      # Convert XML document to hash.
      #
      # hash::
      #   Hash to merge the converted element into.
      def to_hash(hash = {})
        node_hash = {}

        # Insert node hash into parent hash correctly.
        case hash[name]
        when Array then hash[name] << node_hash
        when Hash  then hash[name] = [hash[name], node_hash]
        when nil   then hash[name] = node_hash
        end

        # Handle child elements
        each_child do |c|
          if c.element?
            c.to_hash(node_hash)
          elsif c.text? || c.cdata?
            node_hash[CONTENT_ROOT] ||= +""
            node_hash[CONTENT_ROOT] << c.content
          end
        end

        # Remove content node if it is blank
        if node_hash.length > 1 && node_hash[CONTENT_ROOT].blank?
          node_hash.delete(CONTENT_ROOT)
        end

        # Handle attributes
        each_attr { |a| node_hash[a.name] = a.value }

        hash
      end
    end
  end
end
# frozen_string_literal: true

require "set"
require "pathname"
require "concurrent/atomic/atomic_boolean"
require "listen"
require "active_support/fork_tracker"

module ActiveSupport
  # Allows you to "listen" to changes in a file system.
  # The evented file updater does not hit disk when checking for updates
  # instead it uses platform specific file system events to trigger a change
  # in state.
  #
  # The file checker takes an array of files to watch or a hash specifying directories
  # and file extensions to watch. It also takes a block that is called when
  # EventedFileUpdateChecker#execute is run or when EventedFileUpdateChecker#execute_if_updated
  # is run and there have been changes to the file system.
  #
  # Note: Forking will cause the first call to `updated?` to return `true`.
  #
  # Example:
  #
  #     checker = ActiveSupport::EventedFileUpdateChecker.new(["/tmp/foo"]) { puts "changed" }
  #     checker.updated?
  #     # => false
  #     checker.execute_if_updated
  #     # => nil
  #
  #     FileUtils.touch("/tmp/foo")
  #
  #     checker.updated?
  #     # => true
  #     checker.execute_if_updated
  #     # => "changed"
  #
  class EventedFileUpdateChecker #:nodoc: all
    def initialize(files, dirs = {}, &block)
      unless block
        raise ArgumentError, "A block is required to initialize an EventedFileUpdateChecker"
      end

      @block = block
      @core = Core.new(files, dirs)
      ObjectSpace.define_finalizer(self, @core.finalizer)
    end

    def updated?
      if @core.restart?
        @core.thread_safely(&:restart)
        @core.updated.make_true
      end

      @core.updated.true?
    end

    def execute
      @core.updated.make_false
      @block.call
    end

    def execute_if_updated
      if updated?
        yield if block_given?
        execute
        true
      end
    end

    class Core
      attr_reader :updated

      def initialize(files, dirs)
        @files = files.map { |file| Pathname(file).expand_path }.to_set

        @dirs = dirs.each_with_object({}) do |(dir, exts), hash|
          hash[Pathname(dir).expand_path] = Array(exts).map { |ext| ext.to_s.sub(/\A\.?/, ".") }.to_set
        end

        @common_path = common_path(@dirs.keys)

        @dtw = directories_to_watch
        @missing = []

        @updated = Concurrent::AtomicBoolean.new(false)
        @mutex = Mutex.new

        start
        @after_fork = ActiveSupport::ForkTracker.after_fork { start }
      end

      def finalizer
        proc do
          stop
          ActiveSupport::ForkTracker.unregister(@after_fork)
        end
      end

      def thread_safely
        @mutex.synchronize do
          yield self
        end
      end

      def start
        normalize_dirs!
        @dtw, @missing = [*@dtw, *@missing].partition(&:exist?)
        @listener = @dtw.any? ? Listen.to(*@dtw, &method(:changed)) : nil
        @listener&.start
      end

      def stop
        @listener&.stop
      end

      def restart
        stop
        start
      end

      def restart?
        @missing.any?(&:exist?)
      end

      def normalize_dirs!
        @dirs.transform_keys! do |dir|
          dir.exist? ? dir.realpath : dir
        end
      end

      def changed(modified, added, removed)
        unless @updated.true?
          @updated.make_true if (modified + added + removed).any? { |f| watching?(f) }
        end
      end

      def watching?(file)
        file = Pathname(file)

        if @files.member?(file)
          true
        elsif file.directory?
          false
        else
          ext = file.extname

          file.dirname.ascend do |dir|
            matching = @dirs[dir]

            if matching && (matching.empty? || matching.include?(ext))
              break true
            elsif dir == @common_path || dir.root?
              break false
            end
          end
        end
      end

      def directories_to_watch
        dtw = @dirs.keys | @files.map(&:dirname)
        accounted_for = dtw.to_set + Gem.path.map { |path| Pathname(path) }
        dtw.reject { |dir| dir.ascend.drop(1).any? { |parent| accounted_for.include?(parent) } }
      end

      def common_path(paths)
# frozen_string_literal: true

module ActiveSupport
  # A typical module looks like this:
  #
  #   module M
  #     def self.included(base)
  #       base.extend ClassMethods
  #       base.class_eval do
  #         scope :disabled, -> { where(disabled: true) }
  #       end
  #     end
  #
  #     module ClassMethods
  #       ...
  #     end
  #   end
  #
  # By using <tt>ActiveSupport::Concern</tt> the above module could instead be
  # written as:
  #
  #   require "active_support/concern"
  #
  #   module M
  #     extend ActiveSupport::Concern
  #
  #     included do
  #       scope :disabled, -> { where(disabled: true) }
  #     end
  #
  #     class_methods do
  #       ...
  #     end
  #   end
  #
  # Moreover, it gracefully handles module dependencies. Given a +Foo+ module
  # and a +Bar+ module which depends on the former, we would typically write the
  # following:
  #
  #   module Foo
  #     def self.included(base)
  #       base.class_eval do
  #         def self.method_injected_by_foo
  #           ...
  #         end
  #       end
  #     end
  #   end
  #
  #   module Bar
  #     def self.included(base)
  #       base.method_injected_by_foo
  #     end
  #   end
  #
  #   class Host
  #     include Foo # We need to include this dependency for Bar
  #     include Bar # Bar is the module that Host really needs
  #   end
  #
  # But why should +Host+ care about +Bar+'s dependencies, namely +Foo+? We
  # could try to hide these from +Host+ directly including +Foo+ in +Bar+:
  #
  #   module Bar
  #     include Foo
  #     def self.included(base)
  #       base.method_injected_by_foo
  #     end
  #   end
  #
  #   class Host
  #     include Bar
  #   end
  #
  # Unfortunately this won't work, since when +Foo+ is included, its <tt>base</tt>
  # is the +Bar+ module, not the +Host+ class. With <tt>ActiveSupport::Concern</tt>,
  # module dependencies are properly resolved:
  #
  #   require "active_support/concern"
  #
  #   module Foo
  #     extend ActiveSupport::Concern
  #     included do
  #       def self.method_injected_by_foo
  #         ...
  #       end
  #     end
  #   end
  #
  #   module Bar
  #     extend ActiveSupport::Concern
  #     include Foo
  #
  #     included do
  #       self.method_injected_by_foo
  #     end
  #   end
  #
  #   class Host
  #     include Bar # It works, now Bar takes care of its dependencies
  #   end
  #
  # === Prepending concerns
  #
  # Just like <tt>include</tt>, concerns also support <tt>prepend</tt> with a corresponding
  # <tt>prepended do</tt> callback. <tt>module ClassMethods</tt> or <tt>class_methods do</tt> are
  # prepended as well.
  #
  # <tt>prepend</tt> is also used for any dependencies.
  module Concern
    class MultipleIncludedBlocks < StandardError #:nodoc:
      def initialize
        super "Cannot define multiple 'included' blocks for a Concern"
      end
    end

    class MultiplePrependBlocks < StandardError #:nodoc:
      def initialize
        super "Cannot define multiple 'prepended' blocks for a Concern"
      end
    end

    def self.extended(base) #:nodoc:
      base.instance_variable_set(:@_dependencies, [])
    end

    def append_features(base) #:nodoc:
      if base.instance_variable_defined?(:@_dependencies)
        base.instance_variable_get(:@_dependencies) << self
        false
      else
        return false if base < self
        @_dependencies.each { |dep| base.include(dep) }
        super
        base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
        base.class_eval(&@_included_block) if instance_variable_defined?(:@_included_block)
      end
    end

    def prepend_features(base) #:nodoc:
      if base.instance_variable_defined?(:@_dependencies)
        base.instance_variable_get(:@_dependencies).unshift self
        false
      else
        return false if base < self
        @_dependencies.each { |dep| base.prepend(dep) }
        super
        base.singleton_class.prepend const_get(:ClassMethods) if const_defined?(:ClassMethods)
        base.class_eval(&@_prepended_block) if instance_variable_defined?(:@_prepended_block)
      end
    end

    # Evaluate given block in context of base class,
    # so that you can write class macros here.
    # When you define more than one +included+ block, it raises an exception.
    def included(base = nil, &block)
      if base.nil?
        if instance_variable_defined?(:@_included_block)
          if @_included_block.source_location != block.source_location
            raise MultipleIncludedBlocks
          end
        else
          @_included_block = block
        end
      else
        super
      end
    end

    # Evaluate given block in context of base class,
    # so that you can write class macros here.
    # When you define more than one +prepended+ block, it raises an exception.
    def prepended(base = nil, &block)
      if base.nil?
        if instance_variable_defined?(:@_prepended_block)
          if @_prepended_block.source_location != block.source_location
            raise MultiplePrependBlocks
          end
        else
          @_prepended_block = block
        end
      else
        super
      end
    end

    # Define class methods from given block.
    # You can define private class methods as well.
    #
    #   module Example
    #     extend ActiveSupport::Concern
    #
    #     class_methods do
    #       def foo; puts 'foo'; end
    #
    #       private
    #         def bar; puts 'bar'; end
    #     end
    #   end
    #
    #   class Buzz
    #     include Example
    #   end
    #
    #   Buzz.foo # => "foo"
    #   Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)
    def class_methods(&class_methods_module_definition)
      mod = const_defined?(:ClassMethods, false) ?
        const_get(:ClassMethods) :
        const_set(:ClassMethods, Module.new)
# frozen_string_literal: true

require "set"
require "thread"
require "concurrent/map"
require "pathname"
require "active_support/core_ext/module/aliasing"
require "active_support/core_ext/module/attribute_accessors"
require "active_support/core_ext/module/introspection"
require "active_support/core_ext/module/anonymous"
require "active_support/core_ext/object/blank"
require "active_support/core_ext/kernel/reporting"
require "active_support/core_ext/load_error"
require "active_support/core_ext/name_error"
require "active_support/dependencies/interlock"
require "active_support/inflector"

module ActiveSupport #:nodoc:
  module Dependencies #:nodoc:
    extend self

    UNBOUND_METHOD_MODULE_NAME = Module.instance_method(:name)
    private_constant :UNBOUND_METHOD_MODULE_NAME

    mattr_accessor :interlock, default: Interlock.new

    # :doc:

    # Execute the supplied block without interference from any
    # concurrent loads.
    def self.run_interlock
      Dependencies.interlock.running { yield }
    end

    # Execute the supplied block while holding an exclusive lock,
    # preventing any other thread from being inside a #run_interlock
    # block at the same time.
    def self.load_interlock
      Dependencies.interlock.loading { yield }
    end

    # Execute the supplied block while holding an exclusive lock,
    # preventing any other thread from being inside a #run_interlock
    # block at the same time.
    def self.unload_interlock
      Dependencies.interlock.unloading { yield }
    end

    # :nodoc:

    # Should we turn on Ruby warnings on the first load of dependent files?
    mattr_accessor :warnings_on_first_load, default: false

    # All files ever loaded.
    mattr_accessor :history, default: Set.new

    # All files currently loaded.
    mattr_accessor :loaded, default: Set.new

    # Stack of files being loaded.
    mattr_accessor :loading, default: []

    # Should we load files or require them?
    mattr_accessor :mechanism, default: ENV["NO_RELOAD"] ? :require : :load

    # The set of directories from which we may automatically load files. Files
    # under these directories will be reloaded on each request in development mode,
    # unless the directory also appears in autoload_once_paths.
    mattr_accessor :autoload_paths, default: []

    # The set of directories from which automatically loaded constants are loaded
    # only once. All directories in this set must also be present in +autoload_paths+.
    mattr_accessor :autoload_once_paths, default: []

    # This is a private set that collects all eager load paths during bootstrap.
    # Useful for Zeitwerk integration. Its public interface is the config.* path
    # accessors of each engine.
    mattr_accessor :_eager_load_paths, default: Set.new

    # An array of qualified constant names that have been loaded. Adding a name
    # to this array will cause it to be unloaded the next time Dependencies are
    # cleared.
    mattr_accessor :autoloaded_constants, default: []

    # An array of constant names that need to be unloaded on every request. Used
    # to allow arbitrary constants to be marked for unloading.
    mattr_accessor :explicitly_unloadable_constants, default: []

    # The logger used when tracing autoloads.
    mattr_accessor :logger

    # If true, trace autoloads with +logger.debug+.
    mattr_accessor :verbose, default: false

    # The WatchStack keeps a stack of the modules being watched as files are
    # loaded. If a file in the process of being loaded (parent.rb) triggers the
    # load of another file (child.rb) the stack will ensure that child.rb
    # handles the new constants.
    #
    # If child.rb is being autoloaded, its constants will be added to
    # autoloaded_constants. If it was being required, they will be discarded.
    #
    # This is handled by walking back up the watch stack and adding the constants
    # found by child.rb to the list of original constants in parent.rb.
    class WatchStack
      include Enumerable

      # @watching is a stack of lists of constants being watched. For instance,
      # if parent.rb is autoloaded, the stack will look like [[Object]]. If
      # parent.rb then requires namespace/child.rb, the stack will look like
      # [[Object], [Namespace]].

      attr_reader :watching

      def initialize
        @watching = []
        @stack = Hash.new { |h, k| h[k] = [] }
      end

      def each(&block)
        @stack.each(&block)
      end

      def watching?
        !@watching.empty?
      end

      # Returns a list of new constants found since the last call to
      # <tt>watch_namespaces</tt>.
      def new_constants
        constants = []

        # Grab the list of namespaces that we're looking for new constants under
        @watching.last.each do |namespace|
          # Retrieve the constants that were present under the namespace when watch_namespaces
          # was originally called
          original_constants = @stack[namespace].last

          mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
          next unless mod.is_a?(Module)

          # Get a list of the constants that were added
          new_constants = mod.constants(false) - original_constants

          # @stack[namespace] returns an Array of the constants that are being evaluated
          # for that namespace. For instance, if parent.rb requires child.rb, the first
          # element of @stack[Object] will be an Array of the constants that were present
          # before parent.rb was required. The second element will be an Array of the
          # constants that were present before child.rb was required.
          @stack[namespace].each do |namespace_constants|
            namespace_constants.concat(new_constants)
          end

          # Normalize the list of new constants, and add them to the list we will return
          new_constants.each do |suffix|
            constants << ([namespace, suffix] - ["Object"]).join("::")
          end
        end
        constants
      ensure
        # A call to new_constants is always called after a call to watch_namespaces
        pop_modules(@watching.pop)
      end

      # Add a set of modules to the watch stack, remembering the initial
      # constants.
      def watch_namespaces(namespaces)
        @watching << namespaces.map do |namespace|
          module_name = Dependencies.to_constant_name(namespace)
          original_constants = Dependencies.qualified_const_defined?(module_name) ?
            Inflector.constantize(module_name).constants(false) : []

          @stack[module_name] << original_constants
          module_name
        end
      end

      private
        def pop_modules(modules)
          modules.each { |mod| @stack[mod].pop }
        end
    end

    # An internal stack used to record which constants are loaded by any block.
    mattr_accessor :constant_watch_stack, default: WatchStack.new

    # Module includes this module.
    module ModuleConstMissing #:nodoc:
      def self.append_features(base)
        base.class_eval do
          # Emulate #exclude via an ivar
          return if defined?(@_const_missing) && @_const_missing
          @_const_missing = instance_method(:const_missing)
          remove_method(:const_missing)
        end
        super
      end

      def self.exclude_from(base)
        base.class_eval do
          define_method :const_missing, @_const_missing
          @_const_missing = nil
        end
      end

      def self.include_into(base)
        base.include(self)
        append_features(base)
      end

      def const_missing(const_name)
        from_mod = anonymous? ? guess_for_anonymous(const_name) : self
        Dependencies.load_missing_constant(from_mod, const_name)
      end

      # We assume that the name of the module reflects the nesting
      # (unless it can be proven that is not the case) and the path to the file
      # that defines the constant. Anonymous modules cannot follow these
      # conventions and therefore we assume that the user wants to refer to a
      # top-level constant.
      def guess_for_anonymous(const_name)
        if Object.const_defined?(const_name)
          raise NameError.new "#{const_name} cannot be autoloaded from an anonymous class or module", const_name
        else
          Object
        end
      end

      def unloadable(const_desc = self)
        super(const_desc)
      end
    end

    # Object includes this module.
    module Loadable #:nodoc:
      def self.exclude_from(base)
        base.class_eval do
          define_method(:load, Kernel.instance_method(:load))
          private :load

          define_method(:require, Kernel.instance_method(:require))
          private :require
        end
      end

      def self.include_into(base)
        base.include(self)

        if base.instance_method(:load).owner == base
          base.remove_method(:load)
        end

        if base.instance_method(:require).owner == base
          base.remove_method(:require)
        end
      end

      def require_or_load(file_name)
        Dependencies.require_or_load(file_name)
      end

      # :doc:

      # <b>Warning:</b> This method is obsolete in +:zeitwerk+ mode. In
      # +:zeitwerk+ mode semantics match Ruby's and you do not need to be
      # defensive with load order. Just refer to classes and modules normally.
      # If the constant name is dynamic, camelize if needed, and constantize.
      #
      # In +:classic+ mode, interprets a file using +mechanism+ and marks its
      # defined constants as autoloaded. +file_name+ can be either a string or
      # respond to <tt>to_path</tt>.
      #
      # In +:classic+ mode, use this method in code that absolutely needs a
      # certain constant to be defined at that point. A typical use case is to
      # make constant name resolution deterministic for constants with the same
      # relative name in different namespaces whose evaluation would depend on
      # load order otherwise.
      #
      # Engines that do not control the mode in which their parent application
      # runs should call +require_dependency+ where needed in case the runtime
      # mode is +:classic+.
      def require_dependency(file_name, message = "No such file to load -- %s.rb")
        file_name = file_name.to_path if file_name.respond_to?(:to_path)
        unless file_name.is_a?(String)
          raise ArgumentError, "the file name must either be a String or implement #to_path -- you passed #{file_name.inspect}"
        end

        Dependencies.depend_on(file_name, message)
      end

      # :nodoc:

      def load_dependency(file)
        if Dependencies.load? && Dependencies.constant_watch_stack.watching?
          descs = Dependencies.constant_watch_stack.watching.flatten.uniq

          Dependencies.new_constants_in(*descs) { yield }
        else
          yield
        end
      rescue Exception => exception  # errors from loading file
        exception.blame_file! file if exception.respond_to? :blame_file!
        raise
      end

      # Mark the given constant as unloadable. Unloadable constants are removed
      # each time dependencies are cleared.
      #
      # Note that marking a constant for unloading need only be done once. Setup
      # or init scripts may list each unloadable constant that may need unloading;
      # each constant will be removed for every subsequent clear, as opposed to
      # for the first clear.
      #
      # The provided constant descriptor may be a (non-anonymous) module or class,
      # or a qualified constant name as a string or symbol.
      #
      # Returns +true+ if the constant was not previously marked for unloading,
      # +false+ otherwise.
      def unloadable(const_desc)
        Dependencies.mark_for_unload const_desc
      end

      private
        def load(file, wrap = false)
          result = false
          load_dependency(file) { result = super }
          result
        end

        def require(file)
          result = false
          load_dependency(file) { result = super }
          result
        end
    end

    # Exception file-blaming.
    module Blamable #:nodoc:
      def blame_file!(file)
        (@blamed_files ||= []).unshift file
      end

      def blamed_files
        @blamed_files ||= []
      end

      def describe_blame
        return nil if blamed_files.empty?
        "This error occurred while loading the following files:\n   #{blamed_files.join "\n   "}"
      end

      def copy_blame!(exc)
        @blamed_files = exc.blamed_files.clone
        self
      end
    end

    def hook!
      Loadable.include_into(Object)
      ModuleConstMissing.include_into(Module)
      Exception.include(Blamable)
    end

    def unhook!
      ModuleConstMissing.exclude_from(Module)
      Loadable.exclude_from(Object)
    end

    def load?
      mechanism == :load
    end

    def depend_on(file_name, message = "No such file to load -- %s.rb")
      path = search_for_file(file_name)
      require_or_load(path || file_name)
    rescue LoadError => load_error
      if file_name = load_error.message[/ -- (.*?)(\.rb)?$/, 1]
        load_error_message = if load_error.respond_to?(:original_message)
          load_error.original_message
        else
          load_error.message
        end
        load_error_message.replace(message % file_name)
        load_error.copy_blame!(load_error)
      end
      raise
    end

    def clear
      Dependencies.unload_interlock do
        loaded.clear
        loading.clear
        remove_unloadable_constants!
      end
    end

    def require_or_load(file_name, const_path = nil)
      file_name = file_name.chomp(".rb")
      expanded = File.expand_path(file_name)
      return if loaded.include?(expanded)

      Dependencies.load_interlock do
        # Maybe it got loaded while we were waiting for our lock:
        return if loaded.include?(expanded)

        # Record that we've seen this file *before* loading it to avoid an
        # infinite loop with mutual dependencies.
        loaded << expanded
        loading << expanded

        begin
          if load?
            # Enable warnings if this file has not been loaded before and
            # warnings_on_first_load is set.
            load_args = ["#{file_name}.rb"]
            load_args << const_path unless const_path.nil?

            if !warnings_on_first_load || history.include?(expanded)
              result = load_file(*load_args)
            else
              enable_warnings { result = load_file(*load_args) }
            end
          else
            result = require file_name
          end
        rescue Exception
          loaded.delete expanded
          raise
        ensure
          loading.pop
        end

        # Record history *after* loading so first load gets warnings.
        history << expanded
        result
      end
    end

    # Is the provided constant path defined?
    def qualified_const_defined?(path)
      Object.const_defined?(path, false)
    end

    # Given +path+, a filesystem path to a ruby file, return an array of
    # constant paths which would cause Dependencies to attempt to load this
    # file.
    def loadable_constants_for_path(path, bases = autoload_paths)
      path = path.chomp(".rb")
      expanded_path = File.expand_path(path)
      paths = []

      bases.each do |root|
        expanded_root = File.expand_path(root)
        next unless expanded_path.start_with?(expanded_root)

        root_size = expanded_root.size
        next if expanded_path[root_size] != ?/

        nesting = expanded_path[(root_size + 1)..-1]
        paths << nesting.camelize unless nesting.blank?
      end

      paths.uniq!
      paths
    end

    # Search for a file in autoload_paths matching the provided suffix.
    def search_for_file(path_suffix)
      path_suffix += ".rb" unless path_suffix.end_with?(".rb")

      autoload_paths.each do |root|
        path = File.join(root, path_suffix)
        return path if File.file? path
      end
      nil # Gee, I sure wish we had first_match ;-)
    end

    # Does the provided path_suffix correspond to an autoloadable module?
    # Instead of returning a boolean, the autoload base for this module is
    # returned.
    def autoloadable_module?(path_suffix)
      autoload_paths.each do |load_path|
        return load_path if File.directory? File.join(load_path, path_suffix)
      end
      nil
    end

    def load_once_path?(path)
      # to_s works around a ruby issue where String#start_with?(Pathname)
      # will raise a TypeError: no implicit conversion of Pathname into String
      autoload_once_paths.any? { |base| path.start_with?(base.to_s) }
    end

    # Attempt to autoload the provided module name by searching for a directory
    # matching the expected path suffix. If found, the module is created and
    # assigned to +into+'s constants with the name +const_name+. Provided that
    # the directory was loaded from a reloadable base path, it is added to the
    # set of constants that are to be unloaded.
    def autoload_module!(into, const_name, qualified_name, path_suffix)
      return nil unless base_path = autoloadable_module?(path_suffix)
      mod = Module.new
      into.const_set const_name, mod
      log("constant #{qualified_name} autoloaded (module autovivified from #{File.join(base_path, path_suffix)})")
      autoloaded_constants << qualified_name unless autoload_once_paths.include?(base_path)
      autoloaded_constants.uniq!
      mod
    end

    # Load the file at the provided path. +const_paths+ is a set of qualified
    # constant names. When loading the file, Dependencies will watch for the
    # addition of these constants. Each that is defined will be marked as
    # autoloaded, and will be removed when Dependencies.clear is next called.
    #
    # If the second parameter is left off, then Dependencies will construct a
    # set of names that the file at +path+ may define. See
    # +loadable_constants_for_path+ for more details.
    def load_file(path, const_paths = loadable_constants_for_path(path))
      const_paths = [const_paths].compact unless const_paths.is_a? Array
      parent_paths = const_paths.collect { |const_path| const_path[/.*(?=::)/] || ::Object }

      result = nil
      newly_defined_paths = new_constants_in(*parent_paths) do
        result = Kernel.load path
      end

      autoloaded_constants.concat newly_defined_paths unless load_once_path?(path)
      autoloaded_constants.uniq!
      result
    end

    # Returns the constant path for the provided parent and constant name.
    def qualified_name_for(mod, name)
      mod_name = to_constant_name mod
      mod_name == "Object" ? name.to_s : "#{mod_name}::#{name}"
    end

    # Load the constant named +const_name+ which is missing from +from_mod+. If
    # it is not possible to load the constant into from_mod, try its parent
    # module using +const_missing+.
    def load_missing_constant(from_mod, const_name)
      from_mod_name = real_mod_name(from_mod)
      unless qualified_const_defined?(from_mod_name) && Inflector.constantize(from_mod_name).equal?(from_mod)
        raise ArgumentError, "A copy of #{from_mod} has been removed from the module tree but is still active!"
      end

      qualified_name = qualified_name_for(from_mod, const_name)
      path_suffix = qualified_name.underscore

      file_path = search_for_file(path_suffix)

      if file_path
        expanded = File.expand_path(file_path)
        expanded.delete_suffix!(".rb")

        if loading.include?(expanded)
          raise "Circular dependency detected while autoloading constant #{qualified_name}"
        else
          require_or_load(expanded, qualified_name)

          if from_mod.const_defined?(const_name, false)
            log("constant #{qualified_name} autoloaded from #{expanded}.rb")
            return from_mod.const_get(const_name)
          else
            raise LoadError, "Unable to autoload constant #{qualified_name}, expected #{file_path} to define it"
          end
        end
      elsif mod = autoload_module!(from_mod, const_name, qualified_name, path_suffix)
        return mod
      elsif (parent = from_mod.module_parent) && parent != from_mod &&
            ! from_mod.module_parents.any? { |p| p.const_defined?(const_name, false) }
        # If our parents do not have a constant named +const_name+ then we are free
        # to attempt to load upwards. If they do have such a constant, then this
        # const_missing must be due to from_mod::const_name, which should not
        # return constants from from_mod's parents.
        begin
          # Since Ruby does not pass the nesting at the point the unknown
          # constant triggered the callback we cannot fully emulate constant
          # name lookup and need to make a trade-off: we are going to assume
          # that the nesting in the body of Foo::Bar is [Foo::Bar, Foo] even
          # though it might not be. Counterexamples are
          #
          #   class Foo::Bar
          #     Module.nesting # => [Foo::Bar]
          #   end
          #
          # or
          #
          #   module M::N
          #     module S::T
          #       Module.nesting # => [S::T, M::N]
          #     end
          #   end
          #
          # for example.
          return parent.const_missing(const_name)
        rescue NameError => e
          raise unless e.missing_name? qualified_name_for(parent, const_name)
        end
      end

      name_error = uninitialized_constant(qualified_name, const_name, receiver: from_mod)
      name_error.set_backtrace(caller.reject { |l| l.start_with? __FILE__ })
      raise name_error
    end

    # Remove the constants that have been autoloaded, and those that have been
    # marked for unloading. Before each constant is removed a callback is sent
    # to its class/module if it implements +before_remove_const+.
    #
    # The callback implementation should be restricted to cleaning up caches, etc.
    # as the environment will be in an inconsistent state, e.g. other constants
    # may have already been unloaded and not accessible.
    def remove_unloadable_constants!
      log("removing unloadable constants")
      autoloaded_constants.each { |const| remove_constant const }
      autoloaded_constants.clear
      Reference.clear!
      explicitly_unloadable_constants.each { |const| remove_constant const }
    end

    class ClassCache
      def initialize
        @store = Concurrent::Map.new
      end

      def empty?
        @store.empty?
      end

      def key?(key)
        @store.key?(key)
      end

      def get(key)
        key = key.name if key.respond_to?(:name)
        @store[key] ||= Inflector.constantize(key)
      end
      alias :[] :get

      def safe_get(key)
        key = key.name if key.respond_to?(:name)
        @store[key] ||= Inflector.safe_constantize(key)
      end

      def store(klass)
        return self unless klass.respond_to?(:name)
        raise(ArgumentError, "anonymous classes cannot be cached") if klass.name.empty?
        @store[klass.name] = klass
        self
      end

      def clear!
        @store.clear
      end
    end

    Reference = ClassCache.new

    # Store a reference to a class +klass+.
    def reference(klass)
      Reference.store klass
    end

    # Get the reference for class named +name+.
    # Raises an exception if referenced class does not exist.
    def constantize(name)
      Reference.get(name)
    end

    # Get the reference for class named +name+ if one exists.
    # Otherwise returns +nil+.
    def safe_constantize(name)
      Reference.safe_get(name)
    end

    # Determine if the given constant has been automatically loaded.
    def autoloaded?(desc)
      return false if desc.is_a?(Module) && real_mod_name(desc).nil?
      name = to_constant_name desc
      return false unless qualified_const_defined?(name)
      autoloaded_constants.include?(name)
    end

    # Will the provided constant descriptor be unloaded?
    def will_unload?(const_desc)
      autoloaded?(const_desc) ||
        explicitly_unloadable_constants.include?(to_constant_name(const_desc))
    end

    # Mark the provided constant name for unloading. This constant will be
    # unloaded on each request, not just the next one.
    def mark_for_unload(const_desc)
      name = to_constant_name const_desc
      if explicitly_unloadable_constants.include? name
        false
      else
        explicitly_unloadable_constants << name
        true
      end
    end

    # Run the provided block and detect the new constants that were loaded during
    # its execution. Constants may only be regarded as 'new' once -- so if the
    # block calls +new_constants_in+ again, then the constants defined within the
    # inner call will not be reported in this one.
    #
    # If the provided block does not run to completion, and instead raises an
    # exception, any new constants are regarded as being only partially defined
    # and will be removed immediately.
    def new_constants_in(*descs)
      constant_watch_stack.watch_namespaces(descs)
      success = false

      begin
        yield # Now yield to the code that is to define new constants.
        success = true
      ensure
        new_constants = constant_watch_stack.new_constants

        return new_constants if success

        # Remove partially loaded constants.
        new_constants.each { |c| remove_constant(c) }
      end
    end

    # Convert the provided const desc to a qualified constant name (as a string).
    # A module, class, symbol, or string may be provided.
    def to_constant_name(desc) #:nodoc:
      case desc
      when String then desc.delete_prefix("::")
      when Symbol then desc.to_s
      when Module
        real_mod_name(desc) ||
          raise(ArgumentError, "Anonymous modules have no name to be referenced by")
      else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
      end
    end

    def remove_constant(const) #:nodoc:
      # Normalize ::Foo, ::Object::Foo, Object::Foo, Object::Object::Foo, etc. as Foo.
      normalized = const.to_s.delete_prefix("::")
      normalized.sub!(/\A(Object::)+/, "")

      constants = normalized.split("::")
      to_remove = constants.pop

      # Remove the file path from the loaded list.
      file_path = search_for_file(const.underscore)
      if file_path
        expanded = File.expand_path(file_path)
        expanded.delete_suffix!(".rb")
        loaded.delete(expanded)
      end

      if constants.empty?
        parent = Object
      else
        # This method is robust to non-reachable constants.
        #
        # Non-reachable constants may be passed if some of the parents were
        # autoloaded and already removed. It is easier to do a sanity check
        # here than require the caller to be clever. We check the parent
        # rather than the very const argument because we do not want to
        # trigger Kernel#autoloads, see the comment below.
        parent_name = constants.join("::")
        return unless qualified_const_defined?(parent_name)
        parent = constantize(parent_name)
      end

      # In an autoloaded user.rb like this
      #
      #   autoload :Foo, 'foo'
      #
      #   class User < ActiveRecord::Base
      #   end
      #
      # we correctly register "Foo" as being autoloaded. But if the app does
      # not use the "Foo" constant we need to be careful not to trigger
      # loading "foo.rb" ourselves. While #const_defined? and #const_get? do
      # require the file, #autoload? and #remove_const don't.
      #
      # We are going to remove the constant nonetheless ---which exists as
      # far as Ruby is concerned--- because if the user removes the macro
      # call from a class or module that were not autoloaded, as in the
      # example above with Object, accessing to that constant must err.
      unless parent.autoload?(to_remove)
        begin
          constantized = parent.const_get(to_remove, false)
        rescue NameError
          # The constant is no longer reachable, just skip it.
          return
        else
          constantized.before_remove_const if constantized.respond_to?(:before_remove_const)
        end
      end

      begin
        parent.instance_eval { remove_const to_remove }
      rescue NameError
        # The constant is no longer reachable, just skip it.
      end
    end

    def log(message)
      logger.debug("autoloading: #{message}") if logger && verbose
    end

    private
      def uninitialized_constant(qualified_name, const_name, receiver:)
        NameError.new("uninitialized constant #{qualified_name}", const_name, receiver: receiver)
      end

      # Returns the original name of a class or module even if `name` has been
      # overridden.
      def real_mod_name(mod)
        UNBOUND_METHOD_MODULE_NAME.bind_call(mod)
      end
  end
end
# frozen_string_literal: true

require "active_support/core_ext/object/duplicable"

module ActiveSupport
  # +ParameterFilter+ allows you to specify keys for sensitive data from
  # hash-like object and replace corresponding value. Filtering only certain
  # sub-keys from a hash is possible by using the dot notation:
  # 'credit_card.number'. If a proc is given, each key and value of a hash and
  # all sub-hashes are passed to it, where the value or the key can be replaced
  # using String#replace or similar methods.
  #
  #   ActiveSupport::ParameterFilter.new([:password])
  #   => replaces the value to all keys matching /password/i with "[FILTERED]"
  #
  #   ActiveSupport::ParameterFilter.new([:foo, "bar"])
  #   => replaces the value to all keys matching /foo|bar/i with "[FILTERED]"
  #
  #   ActiveSupport::ParameterFilter.new([/\Apin\z/i, /\Apin_/i])
  #   => replaces the value for the exact (case-insensitive) key 'pin' and all
  #   (case-insensitive) keys beginning with 'pin_', with "[FILTERED]".
  #   Does not match keys with 'pin' as a substring, such as 'shipping_id'.
  #
  #   ActiveSupport::ParameterFilter.new(["credit_card.code"])
  #   => replaces { credit_card: {code: "xxxx"} } with "[FILTERED]", does not
  #   change { file: { code: "xxxx"} }
  #
  #   ActiveSupport::ParameterFilter.new([-> (k, v) do
  #     v.reverse! if /secret/i.match?(k)
  #   end])
  #   => reverses the value to all keys matching /secret/i
  class ParameterFilter
    FILTERED = "[FILTERED]" # :nodoc:

    # Create instance with given filters. Supported type of filters are +String+, +Regexp+, and +Proc+.
    # Other types of filters are treated as +String+ using +to_s+.
    # For +Proc+ filters, key, value, and optional original hash is passed to block arguments.
    #
    # ==== Options
    #
    # * <tt>:mask</tt> - A replaced object when filtered. Defaults to <tt>"[FILTERED]"</tt>.
    def initialize(filters = [], mask: FILTERED)
      @filters = filters
      @mask = mask
    end

    # Mask value of +params+ if key matches one of filters.
    def filter(params)
      compiled_filter.call(params)
    end

    # Returns filtered value for given key. For +Proc+ filters, third block argument is not populated.
    def filter_param(key, value)
      @filters.empty? ? value : compiled_filter.value_for_key(key, value)
    end

  private
    def compiled_filter
      @compiled_filter ||= CompiledFilter.compile(@filters, mask: @mask)
    end

    class CompiledFilter # :nodoc:
      def self.compile(filters, mask:)
        return lambda { |params| params.dup } if filters.empty?

        strings, regexps, blocks, deep_regexps, deep_strings = [], [], [], nil, nil

        filters.each do |item|
          case item
          when Proc
            blocks << item
          when Regexp
            if item.to_s.include?("\\.")
              (deep_regexps ||= []) << item
            else
              regexps << item
            end
          else
            s = Regexp.escape(item.to_s)
            if s.include?("\\.")
              (deep_strings ||= []) << s
            else
              strings << s
            end
          end
        end

        regexps << Regexp.new(strings.join("|"), true) unless strings.empty?
        (deep_regexps ||= []) << Regexp.new(deep_strings.join("|"), true) if deep_strings&.any?

        new regexps, deep_regexps, blocks, mask: mask
      end

      attr_reader :regexps, :deep_regexps, :blocks

      def initialize(regexps, deep_regexps, blocks, mask:)
        @regexps = regexps
        @deep_regexps = deep_regexps&.any? ? deep_regexps : nil
        @blocks = blocks
        @mask = mask
      end

      def call(params, parents = [], original_params = params)
        filtered_params = params.class.new

        params.each do |key, value|
          filtered_params[key] = value_for_key(key, value, parents, original_params)
        end

        filtered_params
      end

      def value_for_key(key, value, parents = [], original_params = nil)
        parents.push(key) if deep_regexps
        if regexps.any? { |r| r.match?(key.to_s) }
          value = @mask
        elsif deep_regexps && (joined = parents.join(".")) && deep_regexps.any? { |r| r.match?(joined) }
          value = @mask
        elsif value.is_a?(Hash)
          value = call(value, parents, original_params)
        elsif value.is_a?(Array)
          # If we don't pop the current parent it will be duplicated as we
          # process each array value.
          parents.pop if deep_regexps
          value = value.map { |v| value_for_key(key, v, parents, original_params) }
          # Restore the parent stack after processing the array.
          parents.push(key) if deep_regexps
        elsif blocks.any?
          key = key.dup if key.duplicable?
          value = value.dup if value.duplicable?
          blocks.each { |b| b.arity == 2 ? b.call(key, value) : b.call(key, value, original_params) }
        end
        parents.pop if deep_regexps
        value
      end
# frozen_string_literal: true

module ActiveSupport
  # Actionable errors let's you define actions to resolve an error.
  #
  # To make an error actionable, include the <tt>ActiveSupport::ActionableError</tt>
  # module and invoke the +action+ class macro to define the action. An action
  # needs a name and a block to execute.
  module ActionableError
    extend Concern

    class NonActionable < StandardError; end

    included do
      class_attribute :_actions, default: {}
    end

    def self.actions(error) # :nodoc:
      case error
      when ActionableError, -> it { Class === it && it < ActionableError }
        error._actions
      else
        {}
      end
    end

    def self.dispatch(error, name) # :nodoc:
      actions(error).fetch(name).call
    rescue KeyError
      raise NonActionable, "Cannot find action \"#{name}\""
    end

    module ClassMethods
      # Defines an action that can resolve the error.
      #
      #   class PendingMigrationError < MigrationError
      #     include ActiveSupport::ActionableError
      #
      #     action "Run pending migrations" do
      #       ActiveRecord::Tasks::DatabaseTasks.migrate
      #     end
      #   end
      def action(name, &block)
        _actions[name] = block
      end
# frozen_string_literal: true

require "active_support/notifications/instrumenter"
require "active_support/notifications/fanout"
require "active_support/per_thread_registry"

module ActiveSupport
  # = Notifications
  #
  # <tt>ActiveSupport::Notifications</tt> provides an instrumentation API for
  # Ruby.
  #
  # == Instrumenters
  #
  # To instrument an event you just need to do:
  #
  #   ActiveSupport::Notifications.instrument('render', extra: :information) do
  #     render plain: 'Foo'
  #   end
  #
  # That first executes the block and then notifies all subscribers once done.
  #
  # In the example above +render+ is the name of the event, and the rest is called
  # the _payload_. The payload is a mechanism that allows instrumenters to pass
  # extra information to subscribers. Payloads consist of a hash whose contents
  # are arbitrary and generally depend on the event.
  #
  # == Subscribers
  #
  # You can consume those events and the information they provide by registering
  # a subscriber.
  #
  #   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
  #     name    # => String, name of the event (such as 'render' from above)
  #     start   # => Time, when the instrumented block started execution
  #     finish  # => Time, when the instrumented block ended execution
  #     id      # => String, unique ID for the instrumenter that fired the event
  #     payload # => Hash, the payload
  #   end
  #
  # Here, the +start+ and +finish+ values represent wall-clock time. If you are
  # concerned about accuracy, you can register a monotonic subscriber.
  #
  #   ActiveSupport::Notifications.monotonic_subscribe('render') do |name, start, finish, id, payload|
  #     name    # => String, name of the event (such as 'render' from above)
  #     start   # => Monotonic time, when the instrumented block started execution
  #     finish  # => Monotonic time, when the instrumented block ended execution
  #     id      # => String, unique ID for the instrumenter that fired the event
  #     payload # => Hash, the payload
  #   end
  #
  # The +start+ and +finish+ values above represent monotonic time.
  #
  # For instance, let's store all "render" events in an array:
  #
  #   events = []
  #
  #   ActiveSupport::Notifications.subscribe('render') do |*args|
  #     events << ActiveSupport::Notifications::Event.new(*args)
  #   end
  #
  # That code returns right away, you are just subscribing to "render" events.
  # The block is saved and will be called whenever someone instruments "render":
  #
  #   ActiveSupport::Notifications.instrument('render', extra: :information) do
  #     render plain: 'Foo'
  #   end
  #
  #   event = events.first
  #   event.name      # => "render"
  #   event.duration  # => 10 (in milliseconds)
  #   event.payload   # => { extra: :information }
  #
  # The block in the <tt>subscribe</tt> call gets the name of the event, start
  # timestamp, end timestamp, a string with a unique identifier for that event's instrumenter
  # (something like "535801666f04d0298cd6"), and a hash with the payload, in
  # that order.
  #
  # If an exception happens during that particular instrumentation the payload will
  # have a key <tt>:exception</tt> with an array of two elements as value: a string with
  # the name of the exception class, and the exception message.
  # The <tt>:exception_object</tt> key of the payload will have the exception
  # itself as the value:
  #
  #   event.payload[:exception]         # => ["ArgumentError", "Invalid value"]
  #   event.payload[:exception_object]  # => #<ArgumentError: Invalid value>
  #
  # As the earlier example depicts, the class <tt>ActiveSupport::Notifications::Event</tt>
  # is able to take the arguments as they come and provide an object-oriented
  # interface to that data.
  #
  # It is also possible to pass an object which responds to <tt>call</tt> method
  # as the second parameter to the <tt>subscribe</tt> method instead of a block:
  #
  #   module ActionController
  #     class PageRequest
  #       def call(name, started, finished, unique_id, payload)
  #         Rails.logger.debug ['notification:', name, started, finished, unique_id, payload].join(' ')
  #       end
  #     end
  #   end
  #
  #   ActiveSupport::Notifications.subscribe('process_action.action_controller', ActionController::PageRequest.new)
  #
  # resulting in the following output within the logs including a hash with the payload:
  #
  #   notification: process_action.action_controller 2012-04-13 01:08:35 +0300 2012-04-13 01:08:35 +0300 af358ed7fab884532ec7 {
  #      controller: "Devise::SessionsController",
  #      action: "new",
  #      params: {"action"=>"new", "controller"=>"devise/sessions"},
  #      format: :html,
  #      method: "GET",
  #      path: "/login/sign_in",
  #      status: 200,
  #      view_runtime: 279.3080806732178,
  #      db_runtime: 40.053
  #    }
  #
  # You can also subscribe to all events whose name matches a certain regexp:
  #
  #   ActiveSupport::Notifications.subscribe(/render/) do |*args|
  #     ...
  #   end
  #
  # and even pass no argument to <tt>subscribe</tt>, in which case you are subscribing
  # to all events.
  #
  # == Temporary Subscriptions
  #
  # Sometimes you do not want to subscribe to an event for the entire life of
  # the application. There are two ways to unsubscribe.
  #
  # WARNING: The instrumentation framework is designed for long-running subscribers,
  # use this feature sparingly because it wipes some internal caches and that has
  # a negative impact on performance.
  #
  # === Subscribe While a Block Runs
  #
  # You can subscribe to some event temporarily while some block runs. For
  # example, in
  #
  #   callback = lambda {|*args| ... }
  #   ActiveSupport::Notifications.subscribed(callback, "sql.active_record") do
  #     ...
  #   end
  #
  # the callback will be called for all "sql.active_record" events instrumented
  # during the execution of the block. The callback is unsubscribed automatically
  # after that.
  #
  # To record +started+ and +finished+ values with monotonic time,
  # specify the optional <tt>:monotonic</tt> option to the
  # <tt>subscribed</tt> method. The <tt>:monotonic</tt> option is set
  # to +false+ by default.
  #
  #   callback = lambda {|name, started, finished, unique_id, payload| ... }
  #   ActiveSupport::Notifications.subscribed(callback, "sql.active_record", monotonic: true) do
  #     ...
  #   end
  #
  # === Manual Unsubscription
  #
  # The +subscribe+ method returns a subscriber object:
  #
  #   subscriber = ActiveSupport::Notifications.subscribe("render") do |*args|
  #     ...
  #   end
  #
  # To prevent that block from being called anymore, just unsubscribe passing
  # that reference:
  #
  #   ActiveSupport::Notifications.unsubscribe(subscriber)
  #
  # You can also unsubscribe by passing the name of the subscriber object. Note
  # that this will unsubscribe all subscriptions with the given name:
  #
  #   ActiveSupport::Notifications.unsubscribe("render")
  #
  # Subscribers using a regexp or other pattern-matching object will remain subscribed
  # to all events that match their original pattern, unless those events match a string
  # passed to +unsubscribe+:
  #
  #   subscriber = ActiveSupport::Notifications.subscribe(/render/) { }
  #   ActiveSupport::Notifications.unsubscribe('render_template.action_view')
  #   subscriber.matches?('render_template.action_view') # => false
  #   subscriber.matches?('render_partial.action_view') # => true
  #
  # == Default Queue
  #
  # Notifications ships with a queue implementation that consumes and publishes events
  # to all log subscribers. You can use any queue implementation you want.
  #
  module Notifications
    class << self
      attr_accessor :notifier

      def publish(name, *args)
        notifier.publish(name, *args)
      end

      def instrument(name, payload = {})
        if notifier.listening?(name)
          instrumenter.instrument(name, payload) { yield payload if block_given? }
        else
          yield payload if block_given?
        end
      end

      # Subscribe to a given event name with the passed +block+.
      #
      # You can subscribe to events by passing a String to match exact event
      # names, or by passing a Regexp to match all events that match a pattern.
      #
      #   ActiveSupport::Notifications.subscribe(/render/) do |*args|
      #     @event = ActiveSupport::Notifications::Event.new(*args)
      #   end
      #
      # The +block+ will receive five parameters with information about the event:
      #
      #   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
      #     name    # => String, name of the event (such as 'render' from above)
      #     start   # => Time, when the instrumented block started execution
      #     finish  # => Time, when the instrumented block ended execution
      #     id      # => String, unique ID for the instrumenter that fired the event
      #     payload # => Hash, the payload
      #   end
      #
      # If the block passed to the method only takes one parameter,
      # it will yield an event object to the block:
      #
      #   ActiveSupport::Notifications.subscribe(/render/) do |event|
      #     @event = event
      #   end
      #
      # Raises an error if invalid event name type is passed:
      #
      #  ActiveSupport::Notifications.subscribe(:render) {|*args| ...}
      #  #=> ArgumentError (pattern must be specified as a String, Regexp or empty)
      #
      def subscribe(pattern = nil, callback = nil, &block)
        notifier.subscribe(pattern, callback, monotonic: false, &block)
      end

      def monotonic_subscribe(pattern = nil, callback = nil, &block)
        notifier.subscribe(pattern, callback, monotonic: true, &block)
      end

      def subscribed(callback, pattern = nil, monotonic: false, &block)
        subscriber = notifier.subscribe(pattern, callback, monotonic: monotonic)
        yield
      ensure
        unsubscribe(subscriber)
      end

      def unsubscribe(subscriber_or_name)
        notifier.unsubscribe(subscriber_or_name)
      end

      def instrumenter
        InstrumentationRegistry.instance.instrumenter_for(notifier)
      end
    end

    # This class is a registry which holds all of the +Instrumenter+ objects
    # in a particular thread local. To access the +Instrumenter+ object for a
    # particular +notifier+, you can call the following method:
    #
    #   InstrumentationRegistry.instrumenter_for(notifier)
    #
    # The instrumenters for multiple notifiers are held in a single instance of
    # this class.
    class InstrumentationRegistry # :nodoc:
      extend ActiveSupport::PerThreadRegistry

      def initialize
        @registry = {}
      end

      def instrumenter_for(notifier)
        @registry[notifier] ||= Instrumenter.new(notifier)
      end
    end

    self.notifier = Fanout.new
  end
# frozen_string_literal: true

require "active_support/core_ext/time/calculations"

module ActiveSupport
  # FileUpdateChecker specifies the API used by Rails to watch files
  # and control reloading. The API depends on four methods:
  #
  # * +initialize+ which expects two parameters and one block as
  #   described below.
  #
  # * +updated?+ which returns a boolean if there were updates in
  #   the filesystem or not.
  #
  # * +execute+ which executes the given block on initialization
  #   and updates the latest watched files and timestamp.
  #
  # * +execute_if_updated+ which just executes the block if it was updated.
  #
  # After initialization, a call to +execute_if_updated+ must execute
  # the block only if there was really a change in the filesystem.
  #
  # This class is used by Rails to reload the I18n framework whenever
  # they are changed upon a new request.
  #
  #   i18n_reloader = ActiveSupport::FileUpdateChecker.new(paths) do
  #     I18n.reload!
  #   end
  #
  #   ActiveSupport::Reloader.to_prepare do
  #     i18n_reloader.execute_if_updated
  #   end
  class FileUpdateChecker
    # It accepts two parameters on initialization. The first is an array
    # of files and the second is an optional hash of directories. The hash must
    # have directories as keys and the value is an array of extensions to be
    # watched under that directory.
    #
    # This method must also receive a block that will be called once a path
    # changes. The array of files and list of directories cannot be changed
    # after FileUpdateChecker has been initialized.
    def initialize(files, dirs = {}, &block)
      unless block
        raise ArgumentError, "A block is required to initialize a FileUpdateChecker"
      end

      @files = files.freeze
      @glob  = compile_glob(dirs)
      @block = block

      @watched    = nil
      @updated_at = nil

      @last_watched   = watched
      @last_update_at = updated_at(@last_watched)
    end

    # Check if any of the entries were updated. If so, the watched and/or
    # updated_at values are cached until the block is executed via +execute+
    # or +execute_if_updated+.
    def updated?
      current_watched = watched
      if @last_watched.size != current_watched.size
        @watched = current_watched
        true
      else
        current_updated_at = updated_at(current_watched)
        if @last_update_at < current_updated_at
          @watched    = current_watched
          @updated_at = current_updated_at
          true
        else
          false
        end
      end
    end

    # Executes the given block and updates the latest watched files and
    # timestamp.
    def execute
      @last_watched   = watched
      @last_update_at = updated_at(@last_watched)
      @block.call
    ensure
      @watched = nil
      @updated_at = nil
    end

    # Execute the block given if updated.
    def execute_if_updated
      if updated?
        yield if block_given?
        execute
        true
      else
        false
      end
    end

    private
      def watched
        @watched || begin
          all = @files.select { |f| File.exist?(f) }
          all.concat(Dir[@glob]) if @glob
          all
        end
      end

      def updated_at(paths)
        @updated_at || max_mtime(paths) || Time.at(0)
      end

      # This method returns the maximum mtime of the files in +paths+, or +nil+
      # if the array is empty.
      #
      # Files with a mtime in the future are ignored. Such abnormal situation
      # can happen for example if the user changes the clock by hand. It is
      # healthy to consider this edge case because with mtimes in the future
      # reloading is not triggered.
      def max_mtime(paths)
        time_now = Time.now
        max_mtime = nil

        # Time comparisons are performed with #compare_without_coercion because
        # AS redefines these operators in a way that is much slower and does not
        # bring any benefit in this particular code.
        #
        # Read t1.compare_without_coercion(t2) < 0 as t1 < t2.
        paths.each do |path|
          mtime = File.mtime(path)

          next if time_now.compare_without_coercion(mtime) < 0

          if max_mtime.nil? || max_mtime.compare_without_coercion(mtime) < 0
            max_mtime = mtime
          end
        end

        max_mtime
      end

      def compile_glob(hash)
        hash.freeze # Freeze so changes aren't accidentally pushed
        return if hash.empty?

        globs = hash.map do |key, value|
          "#{escape(key)}/**/*#{compile_ext(value)}"
        end
        "{#{globs.join(",")}}"
      end

      def escape(key)
        key.gsub(",", '\,')
      end

      def compile_ext(array)
        array = Array(array)
        return if array.empty?
        ".{#{array.join(",")}}"
      end
# frozen_string_literal: true

module ActiveSupport
  module NumberHelper
    extend ActiveSupport::Autoload

    eager_autoload do
      autoload :NumberConverter
      autoload :RoundingHelper
      autoload :NumberToRoundedConverter
      autoload :NumberToDelimitedConverter
      autoload :NumberToHumanConverter
      autoload :NumberToHumanSizeConverter
      autoload :NumberToPhoneConverter
      autoload :NumberToCurrencyConverter
      autoload :NumberToPercentageConverter
    end

    extend self

    # Formats a +number+ into a phone number (US by default e.g., (555)
    # 123-9876). You can customize the format in the +options+ hash.
    #
    # ==== Options
    #
    # * <tt>:area_code</tt> - Adds parentheses around the area code.
    # * <tt>:delimiter</tt> - Specifies the delimiter to use
    #   (defaults to "-").
    # * <tt>:extension</tt> - Specifies an extension to add to the
    #   end of the generated number.
    # * <tt>:country_code</tt> - Sets the country code for the phone
    #   number.
    # * <tt>:pattern</tt> - Specifies how the number is divided into three
    #   groups with the custom regexp to override the default format.
    # ==== Examples
    #
    #   number_to_phone(5551234)                                     # => "555-1234"
    #   number_to_phone('5551234')                                   # => "555-1234"
    #   number_to_phone(1235551234)                                  # => "123-555-1234"
    #   number_to_phone(1235551234, area_code: true)                 # => "(123) 555-1234"
    #   number_to_phone(1235551234, delimiter: ' ')                  # => "123 555 1234"
    #   number_to_phone(1235551234, area_code: true, extension: 555) # => "(123) 555-1234 x 555"
    #   number_to_phone(1235551234, country_code: 1)                 # => "+1-123-555-1234"
    #   number_to_phone('123a456')                                   # => "123a456"
    #
    #   number_to_phone(1235551234, country_code: 1, extension: 1343, delimiter: '.')
    #   # => "+1.123.555.1234 x 1343"
    #
    #   number_to_phone(75561234567, pattern: /(\d{1,4})(\d{4})(\d{4})$/, area_code: true)
    #   # => "(755) 6123-4567"
    #   number_to_phone(13312345678, pattern: /(\d{3})(\d{4})(\d{4})$/)
    #   # => "133-1234-5678"
    def number_to_phone(number, options = {})
      NumberToPhoneConverter.convert(number, options)
    end

    # Formats a +number+ into a currency string (e.g., $13.65). You
    # can customize the format in the +options+ hash.
    #
    # The currency unit and number formatting of the current locale will be used
    # unless otherwise specified in the provided options. No currency conversion
    # is performed. If the user is given a way to change their locale, they will
    # also be able to change the relative value of the currency displayed with
    # this helper. If your application will ever support multiple locales, you
    # may want to specify a constant <tt>:locale</tt> option or consider
    # using a library capable of currency conversion.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the level of precision (defaults
    #   to 2).
    # * <tt>:round_mode</tt> - Determine how rounding is performed
    #   (defaults to :default. See BigDecimal::mode)
    # * <tt>:unit</tt> - Sets the denomination of the currency
    #   (defaults to "$").
    # * <tt>:separator</tt> - Sets the separator between the units
    #   (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to ",").
    # * <tt>:format</tt> - Sets the format for non-negative numbers
    #   (defaults to "%u%n").  Fields are <tt>%u</tt> for the
    #   currency, and <tt>%n</tt> for the number.
    # * <tt>:negative_format</tt> - Sets the format for negative
    #   numbers (defaults to prepending a hyphen to the formatted
    #   number given by <tt>:format</tt>).  Accepts the same fields
    #   than <tt>:format</tt>, except <tt>%n</tt> is here the
    #   absolute value of the number.
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +false+).
    #
    # ==== Examples
    #
    #   number_to_currency(1234567890.50)                # => "$1,234,567,890.50"
    #   number_to_currency(1234567890.506)               # => "$1,234,567,890.51"
    #   number_to_currency(1234567890.506, precision: 3) # => "$1,234,567,890.506"
    #   number_to_currency(1234567890.506, locale: :fr)  # => "1 234 567 890,51 "
    #   number_to_currency('123a456')                    # => "$123a456"
    #
    #   number_to_currency("123a456", raise: true)       # => InvalidNumberError
    #
    #   number_to_currency(-0.456789, precision: 0)
    #   # => "$0"
    #   number_to_currency(-1234567890.50, negative_format: '(%u%n)')
    #   # => "($1,234,567,890.50)"
    #   number_to_currency(1234567890.50, unit: '&pound;', separator: ',', delimiter: '')
    #   # => "&pound;1234567890,50"
    #   number_to_currency(1234567890.50, unit: '&pound;', separator: ',', delimiter: '', format: '%n %u')
    #   # => "1234567890,50 &pound;"
    #   number_to_currency(1234567890.50, strip_insignificant_zeros: true)
    #   # => "$1,234,567,890.5"
    #   number_to_currency(1234567890.50, precision: 0, round_mode: :up)
    #   # => "$1,234,567,891"
    def number_to_currency(number, options = {})
      NumberToCurrencyConverter.convert(number, options)
    end

    # Formats a +number+ as a percentage string (e.g., 65%). You can
    # customize the format in the +options+ hash.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3). Keeps the number's precision if +nil+.
    # * <tt>:round_mode</tt> - Determine how rounding is performed
    #   (defaults to :default. See BigDecimal::mode)
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +false+).
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +false+).
    # * <tt>:format</tt> - Specifies the format of the percentage
    #   string The number field is <tt>%n</tt> (defaults to "%n%").
    #
    # ==== Examples
    #
    #   number_to_percentage(100)                                              # => "100.000%"
    #   number_to_percentage('98')                                             # => "98.000%"
    #   number_to_percentage(100, precision: 0)                                # => "100%"
    #   number_to_percentage(1000, delimiter: '.', separator: ',')             # => "1.000,000%"
    #   number_to_percentage(302.24398923423, precision: 5)                    # => "302.24399%"
    #   number_to_percentage(1000, locale: :fr)                                # => "1000,000%"
    #   number_to_percentage(1000, precision: nil)                             # => "1000%"
    #   number_to_percentage('98a')                                            # => "98a%"
    #   number_to_percentage(100, format: '%n  %')                             # => "100.000  %"
    #   number_to_percentage(302.24398923423, precision: 5, round_mode: :down) # => "302.24398%"
    def number_to_percentage(number, options = {})
      NumberToPercentageConverter.convert(number, options)
    end

    # Formats a +number+ with grouped thousands using +delimiter+
    # (e.g., 12,324). You can customize the format in the +options+
    # hash.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to ",").
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter_pattern</tt> - Sets a custom regular expression used for
    #   deriving the placement of delimiter. Helpful when using currency formats
    #   like INR.
    #
    # ==== Examples
    #
    #   number_to_delimited(12345678)                    # => "12,345,678"
    #   number_to_delimited('123456')                    # => "123,456"
    #   number_to_delimited(12345678.05)                 # => "12,345,678.05"
    #   number_to_delimited(12345678, delimiter: '.')    # => "12.345.678"
    #   number_to_delimited(12345678, delimiter: ',')    # => "12,345,678"
    #   number_to_delimited(12345678.05, separator: ' ') # => "12,345,678 05"
    #   number_to_delimited(12345678.05, locale: :fr)    # => "12 345 678,05"
    #   number_to_delimited('112a')                      # => "112a"
    #   number_to_delimited(98765432.98, delimiter: ' ', separator: ',')
    #                                                    # => "98 765 432,98"
    #   number_to_delimited("123456.78",
    #     delimiter_pattern: /(\d+?)(?=(\d\d)+(\d)(?!\d))/)
    #                                                    # => "1,23,456.78"
    def number_to_delimited(number, options = {})
      NumberToDelimitedConverter.convert(number, options)
    end

    # Formats a +number+ with the specified level of
    # <tt>:precision</tt> (e.g., 112.32 has a precision of 2 if
    # +:significant+ is +false+, and 5 if +:significant+ is +true+).
    # You can customize the format in the +options+ hash.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3). Keeps the number's precision if +nil+.
    # * <tt>:round_mode</tt> - Determine how rounding is performed
    #   (defaults to :default. See BigDecimal::mode)
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +false+).
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +false+).
    #
    # ==== Examples
    #
    #   number_to_rounded(111.2345)                                  # => "111.235"
    #   number_to_rounded(111.2345, precision: 2)                    # => "111.23"
    #   number_to_rounded(13, precision: 5)                          # => "13.00000"
    #   number_to_rounded(389.32314, precision: 0)                   # => "389"
    #   number_to_rounded(111.2345, significant: true)               # => "111"
    #   number_to_rounded(111.2345, precision: 1, significant: true) # => "100"
    #   number_to_rounded(13, precision: 5, significant: true)       # => "13.000"
    #   number_to_rounded(13, precision: nil)                        # => "13"
    #   number_to_rounded(389.32314, precision: 0, round_mode: :up)  # => "390"
    #   number_to_rounded(111.234, locale: :fr)                      # => "111,234"
    #
    #   number_to_rounded(13, precision: 5, significant: true, strip_insignificant_zeros: true)
    #   # => "13"
    #
    #   number_to_rounded(389.32314, precision: 4, significant: true) # => "389.3"
    #   number_to_rounded(1111.2345, precision: 2, separator: ',', delimiter: '.')
    #   # => "1.111,23"
    def number_to_rounded(number, options = {})
      NumberToRoundedConverter.convert(number, options)
    end

    # Formats the bytes in +number+ into a more understandable
    # representation (e.g., giving it 1500 yields 1.46 KB). This
    # method is useful for reporting file sizes to users. You can
    # customize the format in the +options+ hash.
    #
    # See <tt>number_to_human</tt> if you want to pretty-print a
    # generic number.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3).
    # * <tt>:round_mode</tt> - Determine how rounding is performed
    #   (defaults to :default. See BigDecimal::mode)
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +true+)
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +true+)
    #
    # ==== Examples
    #
    #   number_to_human_size(123)                                    # => "123 Bytes"
    #   number_to_human_size(1234)                                   # => "1.21 KB"
    #   number_to_human_size(12345)                                  # => "12.1 KB"
    #   number_to_human_size(1234567)                                # => "1.18 MB"
    #   number_to_human_size(1234567890)                             # => "1.15 GB"
    #   number_to_human_size(1234567890123)                          # => "1.12 TB"
    #   number_to_human_size(1234567890123456)                       # => "1.1 PB"
    #   number_to_human_size(1234567890123456789)                    # => "1.07 EB"
    #   number_to_human_size(1234567, precision: 2)                  # => "1.2 MB"
    #   number_to_human_size(483989, precision: 2)                   # => "470 KB"
    #   number_to_human_size(483989, precision: 2, round_mode: :up)  # => "480 KB"
    #   number_to_human_size(1234567, precision: 2, separator: ',')  # => "1,2 MB"
    #   number_to_human_size(1234567890123, precision: 5)            # => "1.1228 TB"
    #   number_to_human_size(524288000, precision: 5)                # => "500 MB"
    def number_to_human_size(number, options = {})
      NumberToHumanSizeConverter.convert(number, options)
    end

    # Pretty prints (formats and approximates) a number in a way it
    # is more readable by humans (e.g.: 1200000000 becomes "1.2
    # Billion"). This is useful for numbers that can get very large
    # (and too hard to read).
    #
    # See <tt>number_to_human_size</tt> if you want to print a file
    # size.
    #
    # You can also define your own unit-quantifier names if you want
    # to use other decimal units (e.g.: 1500 becomes "1.5
    # kilometers", 0.150 becomes "150 milliliters", etc). You may
    # define a wide range of unit quantifiers, even fractional ones
    # (centi, deci, mili, etc).
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3).
    # * <tt>:round_mode</tt> - Determine how rounding is performed
    #   (defaults to :default. See BigDecimal::mode)
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +true+)
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +true+)
    # * <tt>:units</tt> - A Hash of unit quantifier names. Or a
    #   string containing an i18n scope where to find this hash. It
    #   might have the following keys:
    #   * *integers*: <tt>:unit</tt>, <tt>:ten</tt>,
    #     <tt>:hundred</tt>, <tt>:thousand</tt>, <tt>:million</tt>,
    #     <tt>:billion</tt>, <tt>:trillion</tt>,
    #     <tt>:quadrillion</tt>
    #   * *fractionals*: <tt>:deci</tt>, <tt>:centi</tt>,
    #     <tt>:mili</tt>, <tt>:micro</tt>, <tt>:nano</tt>,
    #     <tt>:pico</tt>, <tt>:femto</tt>
    # * <tt>:format</tt> - Sets the format of the output string
    #   (defaults to "%n %u"). The field types are:
    #   * %u - The quantifier (ex.: 'thousand')
    #   * %n - The number
    #
    # ==== Examples
    #
    #   number_to_human(123)                         # => "123"
    #   number_to_human(1234)                        # => "1.23 Thousand"
    #   number_to_human(12345)                       # => "12.3 Thousand"
    #   number_to_human(1234567)                     # => "1.23 Million"
    #   number_to_human(1234567890)                  # => "1.23 Billion"
    #   number_to_human(1234567890123)               # => "1.23 Trillion"
    #   number_to_human(1234567890123456)            # => "1.23 Quadrillion"
    #   number_to_human(1234567890123456789)         # => "1230 Quadrillion"
    #   number_to_human(489939, precision: 2)        # => "490 Thousand"
    #   number_to_human(489939, precision: 4)        # => "489.9 Thousand"
    #   number_to_human(489939, precision: 2
    #                         , round_mode: :down)   # => "480 Thousand"
    #   number_to_human(1234567, precision: 4,
    #                            significant: false) # => "1.2346 Million"
    #   number_to_human(1234567, precision: 1,
    #                            separator: ',',
    #                            significant: false) # => "1,2 Million"
    #
    #   number_to_human(500000000, precision: 5)           # => "500 Million"
    #   number_to_human(12345012345, significant: false)   # => "12.345 Billion"
    #
    # Non-significant zeros after the decimal separator are stripped
    # out by default (set <tt>:strip_insignificant_zeros</tt> to
    # +false+ to change that):
    #
    # number_to_human(12.00001)                                       # => "12"
    # number_to_human(12.00001, strip_insignificant_zeros: false)     # => "12.0"
    #
    # ==== Custom Unit Quantifiers
    #
    # You can also use your own custom unit quantifiers:
    #  number_to_human(500000, units: { unit: 'ml', thousand: 'lt' })  # => "500 lt"
    #
    # If in your I18n locale you have:
    #
    #   distance:
    #     centi:
    #       one: "centimeter"
    #       other: "centimeters"
    #     unit:
    #       one: "meter"
    #       other: "meters"
    #     thousand:
    #       one: "kilometer"
    #       other: "kilometers"
    #     billion: "gazillion-distance"
    #
    # Then you could do:
    #
    #   number_to_human(543934, units: :distance)            # => "544 kilometers"
    #   number_to_human(54393498, units: :distance)          # => "54400 kilometers"
    #   number_to_human(54393498000, units: :distance)       # => "54.4 gazillion-distance"
    #   number_to_human(343, units: :distance, precision: 1) # => "300 meters"
    #   number_to_human(1, units: :distance)                 # => "1 meter"
    #   number_to_human(0.34, units: :distance)              # => "34 centimeters"
    def number_to_human(number, options = {})
      NumberToHumanConverter.convert(number, options)
    end
# frozen_string_literal: true

require "set"
require "active_support/core_ext/string/inflections"

module ActiveSupport
  module Dependencies
    module ZeitwerkIntegration # :nodoc: all
      module Decorations
        def clear
          Dependencies.unload_interlock do
            Rails.autoloaders.main.reload
          rescue Zeitwerk::ReloadingDisabledError
            raise "reloading is disabled because config.cache_classes is true"
          end
        end

        def constantize(cpath)
          ActiveSupport::Inflector.constantize(cpath)
        end

        def safe_constantize(cpath)
          ActiveSupport::Inflector.safe_constantize(cpath)
        end

        def autoloaded_constants
          Rails.autoloaders.main.unloadable_cpaths
        end

        def autoloaded?(object)
          cpath = object.is_a?(Module) ? real_mod_name(object) : object.to_s
          Rails.autoloaders.main.unloadable_cpath?(cpath)
        end

        def verbose=(verbose)
          l = verbose ? logger || Rails.logger : nil
          Rails.autoloaders.each { |autoloader| autoloader.logger = l }
        end

        def unhook!
          :no_op
        end
      end

      module RequireDependency
        def require_dependency(filename)
          filename = filename.to_path if filename.respond_to?(:to_path)
          if abspath = ActiveSupport::Dependencies.search_for_file(filename)
            require abspath
          else
            require filename
          end
        end
      end

      module Inflector
        # Concurrent::Map is not needed. This is a private class, and overrides
        # must be defined while the application boots.
        @overrides = {}

        def self.camelize(basename, _abspath)
          @overrides[basename] || basename.camelize
        end

        def self.inflect(overrides)
          @overrides.merge!(overrides)
        end
      end

      class << self
        def take_over(enable_reloading:)
          setup_autoloaders(enable_reloading)
          freeze_paths
          decorate_dependencies
        end

        private
          def setup_autoloaders(enable_reloading)
            Dependencies.autoload_paths.each do |autoload_path|
              # Zeitwerk only accepts existing directories in `push_dir` to
              # prevent misconfigurations.
              next unless File.directory?(autoload_path)

              autoloader = \
                autoload_once?(autoload_path) ? Rails.autoloaders.once : Rails.autoloaders.main

              autoloader.push_dir(autoload_path)
              autoloader.do_not_eager_load(autoload_path) unless eager_load?(autoload_path)
            end

            Rails.autoloaders.main.enable_reloading if enable_reloading
            Rails.autoloaders.each(&:setup)
          end

          def autoload_once?(autoload_path)
            Dependencies.autoload_once_paths.include?(autoload_path)
          end

          def eager_load?(autoload_path)
            Dependencies._eager_load_paths.member?(autoload_path)
          end

          def freeze_paths
            Dependencies.autoload_paths.freeze
            Dependencies.autoload_once_paths.freeze
            Dependencies._eager_load_paths.freeze
          end

          def decorate_dependencies
            Dependencies.unhook!
            Dependencies.singleton_class.prepend(Decorations)
            Object.prepend(RequireDependency)
          end
      end
    end
# frozen_string_literal: true

require "active_support/inflector/methods"

module ActiveSupport
  # Autoload and eager load conveniences for your library.
  #
  # This module allows you to define autoloads based on
  # Rails conventions (i.e. no need to define the path
  # it is automatically guessed based on the filename)
  # and also define a set of constants that needs to be
  # eager loaded:
  #
  #   module MyLib
  #     extend ActiveSupport::Autoload
  #
  #     autoload :Model
  #
  #     eager_autoload do
  #       autoload :Cache
  #     end
  #   end
  #
  # Then your library can be eager loaded by simply calling:
  #
  #   MyLib.eager_load!
  module Autoload
    def self.extended(base) # :nodoc:
      base.class_eval do
        @_autoloads = {}
        @_under_path = nil
        @_at_path = nil
        @_eager_autoload = false
      end
    end

    def autoload(const_name, path = @_at_path)
      unless path
        full = [name, @_under_path, const_name.to_s].compact.join("::")
        path = Inflector.underscore(full)
      end

      if @_eager_autoload
        @_autoloads[const_name] = path
      end

      super const_name, path
    end

    def autoload_under(path)
      @_under_path, old_path = path, @_under_path
      yield
    ensure
      @_under_path = old_path
    end

    def autoload_at(path)
      @_at_path, old_path = path, @_at_path
      yield
    ensure
      @_at_path = old_path
    end

    def eager_autoload
      old_eager, @_eager_autoload = @_eager_autoload, true
      yield
    ensure
      @_eager_autoload = old_eager
    end

    def eager_load!
      @_autoloads.each_value { |file| require file }
    end

    def autoloads
# frozen_string_literal: true

require "active_support/concurrency/share_lock"

module ActiveSupport #:nodoc:
  module Dependencies #:nodoc:
    class Interlock
      def initialize # :nodoc:
        @lock = ActiveSupport::Concurrency::ShareLock.new
      end

      def loading
        @lock.exclusive(purpose: :load, compatible: [:load], after_compatible: [:load]) do
          yield
        end
      end

      def unloading
        @lock.exclusive(purpose: :unload, compatible: [:load, :unload], after_compatible: [:load, :unload]) do
          yield
        end
      end

      def start_unloading
        @lock.start_exclusive(purpose: :unload, compatible: [:load, :unload])
      end

      def done_unloading
        @lock.stop_exclusive(compatible: [:load, :unload])
      end

      def start_running
        @lock.start_sharing
      end

      def done_running
        @lock.stop_sharing
      end

      def running
        @lock.sharing do
          yield
        end
      end

      def permit_concurrent_loads
        @lock.yield_shares(compatible: [:load]) do
          yield
        end
      end

      def raw_state(&block) # :nodoc:
        @lock.raw_state(&block)
      end
    end
# frozen_string_literal: true

require "yaml"
require "active_support/encrypted_file"
require "active_support/ordered_options"
require "active_support/core_ext/object/inclusion"
require "active_support/core_ext/module/delegation"

module ActiveSupport
  class EncryptedConfiguration < EncryptedFile
    delegate :[], :fetch, to: :config
    delegate_missing_to :options

    def initialize(config_path:, key_path:, env_key:, raise_if_missing_key:)
      super content_path: config_path, key_path: key_path,
        env_key: env_key, raise_if_missing_key: raise_if_missing_key
    end

    # Allow a config to be started without a file present
    def read
      super
    rescue ActiveSupport::EncryptedFile::MissingContentError
      ""
    end

    def write(contents)
      deserialize(contents)

      super
    end

    def config
      @config ||= deserialize(read).deep_symbolize_keys
    end

    private
      def options
        @options ||= ActiveSupport::InheritableOptions.new(config)
      end

# frozen_string_literal: true

require "active_support/core_ext/array/extract_options"
require "active_support/core_ext/module/redefine_method"

module ActiveSupport
  class Deprecation
    module MethodWrapper
      # Declare that a method has been deprecated.
      #
      #   class Fred
      #     def aaa; end
      #     def bbb; end
      #     def ccc; end
      #     def ddd; end
      #     def eee; end
      #   end
      #
      # Using the default deprecator:
      #   ActiveSupport::Deprecation.deprecate_methods(Fred, :aaa, bbb: :zzz, ccc: 'use Bar#ccc instead')
      #   # => Fred
      #
      #   Fred.new.aaa
      #   # DEPRECATION WARNING: aaa is deprecated and will be removed from Rails 5.1. (called from irb_binding at (irb):10)
      #   # => nil
      #
      #   Fred.new.bbb
      #   # DEPRECATION WARNING: bbb is deprecated and will be removed from Rails 5.1 (use zzz instead). (called from irb_binding at (irb):11)
      #   # => nil
      #
      #   Fred.new.ccc
      #   # DEPRECATION WARNING: ccc is deprecated and will be removed from Rails 5.1 (use Bar#ccc instead). (called from irb_binding at (irb):12)
      #   # => nil
      #
      # Passing in a custom deprecator:
      #   custom_deprecator = ActiveSupport::Deprecation.new('next-release', 'MyGem')
      #   ActiveSupport::Deprecation.deprecate_methods(Fred, ddd: :zzz, deprecator: custom_deprecator)
      #   # => [:ddd]
      #
      #   Fred.new.ddd
      #   DEPRECATION WARNING: ddd is deprecated and will be removed from MyGem next-release (use zzz instead). (called from irb_binding at (irb):15)
      #   # => nil
      #
      # Using a custom deprecator directly:
      #   custom_deprecator = ActiveSupport::Deprecation.new('next-release', 'MyGem')
      #   custom_deprecator.deprecate_methods(Fred, eee: :zzz)
      #   # => [:eee]
      #
      #   Fred.new.eee
      #   DEPRECATION WARNING: eee is deprecated and will be removed from MyGem next-release (use zzz instead). (called from irb_binding at (irb):18)
      #   # => nil
      def deprecate_methods(target_module, *method_names)
        options = method_names.extract_options!
        deprecator = options.delete(:deprecator) || self
        method_names += options.keys
        mod = nil

        method_names.each do |method_name|
          message = options[method_name]
          if target_module.method_defined?(method_name) || target_module.private_method_defined?(method_name)
            method = target_module.instance_method(method_name)
            target_module.module_eval do
              redefine_method(method_name) do |*args, &block|
                deprecator.deprecation_warning(method_name, message)
                method.bind_call(self, *args, &block)
              end
              ruby2_keywords(method_name) if respond_to?(:ruby2_keywords, true)
            end
          else
            mod ||= Module.new
            mod.module_eval do
              define_method(method_name) do |*args, &block|
                deprecator.deprecation_warning(method_name, message)
                super(*args, &block)
              end
              ruby2_keywords(method_name) if respond_to?(:ruby2_keywords, true)
            end
          end
        end

# frozen_string_literal: true

require "active_support/notifications"

module ActiveSupport
  # Raised when <tt>ActiveSupport::Deprecation::Behavior#behavior</tt> is set with <tt>:raise</tt>.
  # You would set <tt>:raise</tt>, as a behavior to raise errors and proactively report exceptions from deprecations.
  class DeprecationException < StandardError
  end

  class Deprecation
    # Default warning behaviors per Rails.env.
    DEFAULT_BEHAVIORS = {
      raise: ->(message, callstack, deprecation_horizon, gem_name) {
        e = DeprecationException.new(message)
        e.set_backtrace(callstack.map(&:to_s))
        raise e
      },

      stderr: ->(message, callstack, deprecation_horizon, gem_name) {
        $stderr.puts(message)
        $stderr.puts callstack.join("\n  ") if debug
      },

      log: ->(message, callstack, deprecation_horizon, gem_name) {
        logger =
            if defined?(Rails.logger) && Rails.logger
              Rails.logger
            else
              require "active_support/logger"
              ActiveSupport::Logger.new($stderr)
            end
        logger.warn message
        logger.debug callstack.join("\n  ") if debug
      },

      notify: ->(message, callstack, deprecation_horizon, gem_name) {
        notification_name = "deprecation.#{gem_name.underscore.tr('/', '_')}"
        ActiveSupport::Notifications.instrument(notification_name,
                                                message: message,
                                                callstack: callstack,
                                                gem_name: gem_name,
                                                deprecation_horizon: deprecation_horizon)
      },

      silence: ->(message, callstack, deprecation_horizon, gem_name) { },
    }

    # Behavior module allows to determine how to display deprecation messages.
    # You can create a custom behavior or set any from the +DEFAULT_BEHAVIORS+
    # constant. Available behaviors are:
    #
    # [+raise+]   Raise <tt>ActiveSupport::DeprecationException</tt>.
    # [+stderr+]  Log all deprecation warnings to <tt>$stderr</tt>.
    # [+log+]     Log all deprecation warnings to +Rails.logger+.
    # [+notify+]  Use +ActiveSupport::Notifications+ to notify +deprecation.rails+.
    # [+silence+] Do nothing.
    #
    # Setting behaviors only affects deprecations that happen after boot time.
    # For more information you can read the documentation of the +behavior=+ method.
    module Behavior
      # Whether to print a backtrace along with the warning.
      attr_accessor :debug

      # Returns the current behavior or if one isn't set, defaults to +:stderr+.
      def behavior
        @behavior ||= [DEFAULT_BEHAVIORS[:stderr]]
      end

      # Returns the current behavior for disallowed deprecations or if one isn't set, defaults to +:raise+.
      def disallowed_behavior
        @disallowed_behavior ||= [DEFAULT_BEHAVIORS[:raise]]
      end

      # Sets the behavior to the specified value. Can be a single value, array,
      # or an object that responds to +call+.
      #
      # Available behaviors:
      #
      # [+raise+]   Raise <tt>ActiveSupport::DeprecationException</tt>.
      # [+stderr+]  Log all deprecation warnings to <tt>$stderr</tt>.
      # [+log+]     Log all deprecation warnings to +Rails.logger+.
      # [+notify+]  Use +ActiveSupport::Notifications+ to notify +deprecation.rails+.
      # [+silence+] Do nothing.
      #
      # Setting behaviors only affects deprecations that happen after boot time.
      # Deprecation warnings raised by gems are not affected by this setting
      # because they happen before Rails boots up.
      #
      #   ActiveSupport::Deprecation.behavior = :stderr
      #   ActiveSupport::Deprecation.behavior = [:stderr, :log]
      #   ActiveSupport::Deprecation.behavior = MyCustomHandler
      #   ActiveSupport::Deprecation.behavior = ->(message, callstack, deprecation_horizon, gem_name) {
      #     # custom stuff
      #   }
      def behavior=(behavior)
        @behavior = Array(behavior).map { |b| DEFAULT_BEHAVIORS[b] || arity_coerce(b) }
      end

      # Sets the behavior for disallowed deprecations (those configured by
      # ActiveSupport::Deprecation.disallowed_warnings=) to the specified
      # value. As with +behavior=+, this can be a single value, array, or an
      # object that responds to +call+.
      def disallowed_behavior=(behavior)
        @disallowed_behavior = Array(behavior).map { |b| DEFAULT_BEHAVIORS[b] || arity_coerce(b) }
      end

      private
        def arity_coerce(behavior)
          unless behavior.respond_to?(:call)
            raise ArgumentError, "#{behavior.inspect} is not a valid deprecation behavior."
          end

          if behavior.arity == 4 || behavior.arity == -1
            behavior
          else
            -> message, callstack, _, _ { behavior.call(message, callstack) }
          end
        end
    end
# frozen_string_literal: true

module ActiveSupport
  class Deprecation
    # DeprecatedConstantAccessor transforms a constant into a deprecated one by
    # hooking +const_missing+.
    #
    # It takes the names of an old (deprecated) constant and of a new constant
    # (both in string form) and optionally a deprecator. The deprecator defaults
    # to +ActiveSupport::Deprecator+ if none is specified.
    #
    # The deprecated constant now returns the same object as the new one rather
    # than a proxy object, so it can be used transparently in +rescue+ blocks
    # etc.
    #
    #   PLANETS = %w(mercury venus earth mars jupiter saturn uranus neptune pluto)
    #
    #   # (In a later update, the original implementation of `PLANETS` has been removed.)
    #
    #   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
    #   include ActiveSupport::Deprecation::DeprecatedConstantAccessor
    #   deprecate_constant 'PLANETS', 'PLANETS_POST_2006'
    #
    #   PLANETS.map { |planet| planet.capitalize }
    #   # => DEPRECATION WARNING: PLANETS is deprecated! Use PLANETS_POST_2006 instead.
    #        (Backtrace information)
    #        ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    module DeprecatedConstantAccessor
      def self.included(base)
        require "active_support/inflector/methods"

        extension = Module.new do
          def const_missing(missing_const_name)
            if class_variable_defined?(:@@_deprecated_constants)
              if (replacement = class_variable_get(:@@_deprecated_constants)[missing_const_name.to_s])
                replacement[:deprecator].warn(replacement[:message] || "#{name}::#{missing_const_name} is deprecated! Use #{replacement[:new]} instead.", caller_locations)
                return ActiveSupport::Inflector.constantize(replacement[:new].to_s)
              end
            end
            super
          end

          def deprecate_constant(const_name, new_constant, message: nil, deprecator: ActiveSupport::Deprecation.instance)
            class_variable_set(:@@_deprecated_constants, {}) unless class_variable_defined?(:@@_deprecated_constants)
            class_variable_get(:@@_deprecated_constants)[const_name.to_s] = { new: new_constant, message: message, deprecator: deprecator }
          end
        end
        base.singleton_class.prepend extension
      end
    end
# frozen_string_literal: true

require "rbconfig"

module ActiveSupport
  class Deprecation
    module Reporting
      # Whether to print a message (silent mode)
      attr_writer :silenced
      # Name of gem where method is deprecated
      attr_accessor :gem_name

      # Outputs a deprecation warning to the output configured by
      # <tt>ActiveSupport::Deprecation.behavior</tt>.
      #
      #   ActiveSupport::Deprecation.warn('something broke!')
      #   # => "DEPRECATION WARNING: something broke! (called from your_code.rb:1)"
      def warn(message = nil, callstack = nil)
        return if silenced

        callstack ||= caller_locations(2)
        deprecation_message(callstack, message).tap do |m|
          if deprecation_disallowed?(message)
            disallowed_behavior.each { |b| b.call(m, callstack, deprecation_horizon, gem_name) }
          else
            behavior.each { |b| b.call(m, callstack, deprecation_horizon, gem_name) }
          end
        end
      end

      # Silence deprecation warnings within the block.
      #
      #   ActiveSupport::Deprecation.warn('something broke!')
      #   # => "DEPRECATION WARNING: something broke! (called from your_code.rb:1)"
      #
      #   ActiveSupport::Deprecation.silence do
      #     ActiveSupport::Deprecation.warn('something broke!')
      #   end
      #   # => nil
      def silence(&block)
        @silenced_thread.bind(true, &block)
      end

      # Allow previously disallowed deprecation warnings within the block.
      # <tt>allowed_warnings</tt> can be an array containing strings, symbols, or regular
      # expressions. (Symbols are treated as strings). These are compared against
      # the text of deprecation warning messages generated within the block.
      # Matching warnings will be exempt from the rules set by
      # +ActiveSupport::Deprecation.disallowed_warnings+
      #
      # The optional <tt>if:</tt> argument accepts a truthy/falsy value or an object that
      # responds to <tt>.call</tt>. If truthy, then matching warnings will be allowed.
      # If falsey then the method yields to the block without allowing the warning.
      #
      #   ActiveSupport::Deprecation.disallowed_behavior = :raise
      #   ActiveSupport::Deprecation.disallowed_warnings = [
      #     "something broke"
      #   ]
      #
      #   ActiveSupport::Deprecation.warn('something broke!')
      #   # => ActiveSupport::DeprecationException
      #
      #   ActiveSupport::Deprecation.allow ['something broke'] do
      #     ActiveSupport::Deprecation.warn('something broke!')
      #   end
      #   # => nil
      #
      #   ActiveSupport::Deprecation.allow ['something broke'], if: Rails.env.production? do
      #     ActiveSupport::Deprecation.warn('something broke!')
      #   end
      #   # => ActiveSupport::DeprecationException for dev/test, nil for production
      def allow(allowed_warnings = :all, if: true, &block)
        conditional = binding.local_variable_get(:if)
        conditional = conditional.call if conditional.respond_to?(:call)
        if conditional
          @explicitly_allowed_warnings.bind(allowed_warnings, &block)
        else
          yield
        end
      end

      def silenced
        @silenced || @silenced_thread.value
      end

      def deprecation_warning(deprecated_method_name, message = nil, caller_backtrace = nil)
        caller_backtrace ||= caller_locations(2)
        deprecated_method_warning(deprecated_method_name, message).tap do |msg|
          warn(msg, caller_backtrace)
        end
      end

      private
        # Outputs a deprecation warning message
        #
        #   deprecated_method_warning(:method_name)
        #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon}"
        #   deprecated_method_warning(:method_name, :another_method)
        #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon} (use another_method instead)"
        #   deprecated_method_warning(:method_name, "Optional message")
        #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon} (Optional message)"
        def deprecated_method_warning(method_name, message = nil)
          warning = "#{method_name} is deprecated and will be removed from #{gem_name} #{deprecation_horizon}"
          case message
          when Symbol then "#{warning} (use #{message} instead)"
          when String then "#{warning} (#{message})"
          else warning
          end
        end

        def deprecation_message(callstack, message = nil)
          message ||= "You are using deprecated behavior which will be removed from the next major or minor release."
          "DEPRECATION WARNING: #{message} #{deprecation_caller_message(callstack)}"
        end

        def deprecation_caller_message(callstack)
          file, line, method = extract_callstack(callstack)
          if file
            if line && method
              "(called from #{method} at #{file}:#{line})"
            else
              "(called from #{file}:#{line})"
            end
          end
        end

        def extract_callstack(callstack)
          return _extract_callstack(callstack) if callstack.first.is_a? String

          offending_line = callstack.find { |frame|
            frame.absolute_path && !ignored_callstack(frame.absolute_path)
          } || callstack.first

          [offending_line.path, offending_line.lineno, offending_line.label]
        end

        def _extract_callstack(callstack)
          warn "Please pass `caller_locations` to the deprecation API" if $VERBOSE
          offending_line = callstack.find { |line| !ignored_callstack(line) } || callstack.first

          if offending_line
            if md = offending_line.match(/^(.+?):(\d+)(?::in `(.*?)')?/)
              md.captures
            else
              offending_line
            end
          end
        end

        RAILS_GEM_ROOT = File.expand_path("../../../..", __dir__) + "/"

        def ignored_callstack(path)
          path.start_with?(RAILS_GEM_ROOT) || path.start_with?(RbConfig::CONFIG["rubylibdir"])
        end
    end
# frozen_string_literal: true

module ActiveSupport
  class Deprecation
    module Disallowed
      # Sets the criteria used to identify deprecation messages which should be
      # disallowed. Can be an array containing strings, symbols, or regular
      # expressions. (Symbols are treated as strings). These are compared against
      # the text of the generated deprecation warning.
      #
      # Additionally the scalar symbol +:all+ may be used to treat all
      # deprecations as disallowed.
      #
      # Deprecations matching a substring or regular expression will be handled
      # using the configured +ActiveSupport::Deprecation.disallowed_behavior+
      # rather than +ActiveSupport::Deprecation.behavior+
      attr_writer :disallowed_warnings

      # Returns the configured criteria used to identify deprecation messages
      # which should be treated as disallowed.
      def disallowed_warnings
        @disallowed_warnings ||= []
      end

      private
        def deprecation_disallowed?(message)
          disallowed = ActiveSupport::Deprecation.disallowed_warnings
          return false if explicitly_allowed?(message)
          return true if disallowed == :all
          disallowed.any? do |rule|
            case rule
            when String, Symbol
              message.include?(rule.to_s)
            when Regexp
              rule.match?(message)
            end
          end
        end

        def explicitly_allowed?(message)
          allowances = @explicitly_allowed_warnings.value
          return false unless allowances
          return true if allowances == :all
          allowances = [allowances] unless allowances.kind_of?(Array)
          allowances.any? do |rule|
            case rule
            when String, Symbol
              message.include?(rule.to_s)
            when Regexp
              rule.match?(message)
            end
          end
        end
    end
  end
# frozen_string_literal: true

module ActiveSupport
  class Deprecation
    class DeprecationProxy #:nodoc:
      def self.new(*args, &block)
        object = args.first

        return object unless object
        super
      end

      instance_methods.each { |m| undef_method m unless /^__|^object_id$/.match?(m) }

      # Don't give a deprecation warning on inspect since test/unit and error
      # logs rely on it for diagnostics.
      def inspect
        target.inspect
      end

      private
        def method_missing(called, *args, &block)
          warn caller_locations, called, args
          target.__send__(called, *args, &block)
        end
    end

    # DeprecatedObjectProxy transforms an object into a deprecated one. It
    # takes an object, a deprecation message and optionally a deprecator. The
    # deprecator defaults to +ActiveSupport::Deprecator+ if none is specified.
    #
    #   deprecated_object = ActiveSupport::Deprecation::DeprecatedObjectProxy.new(Object.new, "This object is now deprecated")
    #   # => #<Object:0x007fb9b34c34b0>
    #
    #   deprecated_object.to_s
    #   DEPRECATION WARNING: This object is now deprecated.
    #   (Backtrace)
    #   # => "#<Object:0x007fb9b34c34b0>"
    class DeprecatedObjectProxy < DeprecationProxy
      def initialize(object, message, deprecator = ActiveSupport::Deprecation.instance)
        @object = object
        @message = message
        @deprecator = deprecator
      end

      private
        def target
          @object
        end

        def warn(callstack, called, args)
          @deprecator.warn(@message, callstack)
        end
    end

    # DeprecatedInstanceVariableProxy transforms an instance variable into a
    # deprecated one. It takes an instance of a class, a method on that class
    # and an instance variable. It optionally takes a deprecator as the last
    # argument. The deprecator defaults to +ActiveSupport::Deprecator+ if none
    # is specified.
    #
    #   class Example
    #     def initialize
    #       @request = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(self, :request, :@request)
    #       @_request = :special_request
    #     end
    #
    #     def request
    #       @_request
    #     end
    #
    #     def old_request
    #       @request
    #     end
    #   end
    #
    #   example = Example.new
    #   # => #<Example:0x007fb9b31090b8 @_request=:special_request, @request=:special_request>
    #
    #   example.old_request.to_s
    #   # => DEPRECATION WARNING: @request is deprecated! Call request.to_s instead of
    #      @request.to_s
    #      (Backtrace information)
    #      "special_request"
    #
    #   example.request.to_s
    #   # => "special_request"
    class DeprecatedInstanceVariableProxy < DeprecationProxy
      def initialize(instance, method, var = "@#{method}", deprecator = ActiveSupport::Deprecation.instance)
        @instance = instance
        @method = method
        @var = var
        @deprecator = deprecator
      end

      private
        def target
          @instance.__send__(@method)
        end

        def warn(callstack, called, args)
          @deprecator.warn("#{@var} is deprecated! Call #{@method}.#{called} instead of #{@var}.#{called}. Args: #{args.inspect}", callstack)
        end
    end

    # DeprecatedConstantProxy transforms a constant into a deprecated one. It
    # takes the names of an old (deprecated) constant and of a new constant
    # (both in string form) and optionally a deprecator. The deprecator defaults
    # to +ActiveSupport::Deprecator+ if none is specified. The deprecated constant
    # now returns the value of the new one.
    #
    #   PLANETS = %w(mercury venus earth mars jupiter saturn uranus neptune pluto)
    #
    #   # (In a later update, the original implementation of `PLANETS` has been removed.)
    #
    #   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
    #   PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('PLANETS', 'PLANETS_POST_2006')
    #
    #   PLANETS.map { |planet| planet.capitalize }
    #   # => DEPRECATION WARNING: PLANETS is deprecated! Use PLANETS_POST_2006 instead.
    #        (Backtrace information)
    #        ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    class DeprecatedConstantProxy < Module
      def self.new(*args, **options, &block)
        object = args.first

        return object unless object
        super
      end

      def initialize(old_const, new_const, deprecator = ActiveSupport::Deprecation.instance, message: "#{old_const} is deprecated! Use #{new_const} instead.")
        Kernel.require "active_support/inflector/methods"

        @old_const = old_const
        @new_const = new_const
        @deprecator = deprecator
        @message = message
      end

      instance_methods.each { |m| undef_method m unless /^__|^object_id$/.match?(m) }

      # Don't give a deprecation warning on inspect since test/unit and error
      # logs rely on it for diagnostics.
      def inspect
        target.inspect
      end

      # Don't give a deprecation warning on methods that IRB may invoke
      # during tab-completion.
      delegate :hash, :instance_methods, :name, :respond_to?, to: :target

      # Returns the class of the new constant.
      #
      #   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
      #   PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('PLANETS', 'PLANETS_POST_2006')
      #   PLANETS.class # => Array
      def class
        target.class
      end

      private
        def target
          ActiveSupport::Inflector.constantize(@new_const.to_s)
        end

        def const_missing(name)
          @deprecator.warn(@message, caller_locations)
          target.const_get(name)
        end

        def method_missing(called, *args, &block)
          @deprecator.warn(@message, caller_locations)
          target.__send__(called, *args, &block)
        end
    end
# frozen_string_literal: true

require "active_support/core_ext/module/delegation"

module ActiveSupport
  class Deprecation
    module InstanceDelegator # :nodoc:
      def self.included(base)
        base.extend(ClassMethods)
        base.singleton_class.prepend(OverrideDelegators)
        base.public_class_method :new
      end

      module ClassMethods # :nodoc:
        def include(included_module)
          included_module.instance_methods.each { |m| method_added(m) }
          super
        end

        def method_added(method_name)
          singleton_class.delegate(method_name, to: :instance)
        end
      end

      module OverrideDelegators # :nodoc:
        def warn(message = nil, callstack = nil)
          callstack ||= caller_locations(2)
          super
        end

        def deprecation_warning(deprecated_method_name, message = nil, caller_backtrace = nil)
          caller_backtrace ||= caller_locations(2)
          super
        end
      end
# frozen_string_literal: true

require "active_support/callbacks"
require "active_support/core_ext/enumerable"

module ActiveSupport
  # Abstract super class that provides a thread-isolated attributes singleton, which resets automatically
  # before and after each request. This allows you to keep all the per-request attributes easily
  # available to the whole system.
  #
  # The following full app-like example demonstrates how to use a Current class to
  # facilitate easy access to the global, per-request attributes without passing them deeply
  # around everywhere:
  #
  #   # app/models/current.rb
  #   class Current < ActiveSupport::CurrentAttributes
  #     attribute :account, :user
  #     attribute :request_id, :user_agent, :ip_address
  #
  #     resets { Time.zone = nil }
  #
  #     def user=(user)
  #       super
  #       self.account = user.account
  #       Time.zone    = user.time_zone
  #     end
  #   end
  #
  #   # app/controllers/concerns/authentication.rb
  #   module Authentication
  #     extend ActiveSupport::Concern
  #
  #     included do
  #       before_action :authenticate
  #     end
  #
  #     private
  #       def authenticate
  #         if authenticated_user = User.find_by(id: cookies.encrypted[:user_id])
  #           Current.user = authenticated_user
  #         else
  #           redirect_to new_session_url
  #         end
  #       end
  #   end
  #
  #   # app/controllers/concerns/set_current_request_details.rb
  #   module SetCurrentRequestDetails
  #     extend ActiveSupport::Concern
  #
  #     included do
  #       before_action do
  #         Current.request_id = request.uuid
  #         Current.user_agent = request.user_agent
  #         Current.ip_address = request.ip
  #       end
  #     end
  #   end
  #
  #   class ApplicationController < ActionController::Base
  #     include Authentication
  #     include SetCurrentRequestDetails
  #   end
  #
  #   class MessagesController < ApplicationController
  #     def create
  #       Current.account.messages.create(message_params)
  #     end
  #   end
  #
  #   class Message < ApplicationRecord
  #     belongs_to :creator, default: -> { Current.user }
  #     after_create { |message| Event.create(record: message) }
  #   end
  #
  #   class Event < ApplicationRecord
  #     before_create do
  #       self.request_id = Current.request_id
  #       self.user_agent = Current.user_agent
  #       self.ip_address = Current.ip_address
  #     end
  #   end
  #
  # A word of caution: It's easy to overdo a global singleton like Current and tangle your model as a result.
  # Current should only be used for a few, top-level globals, like account, user, and request details.
  # The attributes stuck in Current should be used by more or less all actions on all requests. If you start
  # sticking controller-specific attributes in there, you're going to create a mess.
  class CurrentAttributes
    include ActiveSupport::Callbacks
    define_callbacks :reset

    class << self
      # Returns singleton instance for this class in this thread. If none exists, one is created.
      def instance
        current_instances[current_instances_key] ||= new
      end

      # Declares one or more attributes that will be given both class and instance accessor methods.
      def attribute(*names)
        generated_attribute_methods.module_eval do
          names.each do |name|
            define_method(name) do
              attributes[name.to_sym]
            end

            define_method("#{name}=") do |attribute|
              attributes[name.to_sym] = attribute
            end
          end
        end

        names.each do |name|
          define_singleton_method(name) do
            instance.public_send(name)
          end

          define_singleton_method("#{name}=") do |attribute|
            instance.public_send("#{name}=", attribute)
          end
        end
      end

      # Calls this block before #reset is called on the instance. Used for resetting external collaborators that depend on current values.
      def before_reset(&block)
        set_callback :reset, :before, &block
      end

      # Calls this block after #reset is called on the instance. Used for resetting external collaborators, like Time.zone.
      def resets(&block)
        set_callback :reset, :after, &block
      end
      alias_method :after_reset, :resets

      delegate :set, :reset, to: :instance

      def reset_all # :nodoc:
        current_instances.each_value(&:reset)
      end

      def clear_all # :nodoc:
        reset_all
        current_instances.clear
      end

      private
        def generated_attribute_methods
          @generated_attribute_methods ||= Module.new.tap { |mod| include mod }
        end

        def current_instances
          Thread.current[:current_attributes_instances] ||= {}
        end

        def current_instances_key
          @current_instances_key ||= name.to_sym
        end

        def method_missing(name, *args, **kwargs, &block)
          # Caches the method definition as a singleton method of the receiver.
          #
          # By letting #delegate handle it, we avoid an enclosure that'll capture args.
          singleton_class.delegate name, to: :instance

          send(name, *args, **kwargs, &block)
        end

        def respond_to_missing?(name, _)
          super || instance.respond_to?(name)
        end
    end

    attr_accessor :attributes

    def initialize
      @attributes = {}
    end

    # Expose one or more attributes within a block. Old values are returned after the block concludes.
    # Example demonstrating the common use of needing to set Current attributes outside the request-cycle:
    #
    #   class Chat::PublicationJob < ApplicationJob
    #     def perform(attributes, room_number, creator)
    #       Current.set(person: creator) do
    #         Chat::Publisher.publish(attributes: attributes, room_number: room_number)
    #       end
    #     end
    #   end
    def set(set_attributes)
      old_attributes = compute_attributes(set_attributes.keys)
      assign_attributes(set_attributes)
      yield
    ensure
      assign_attributes(old_attributes)
    end

    # Reset all attributes. Should be called before and after actions, when used as a per-request singleton.
    def reset
      run_callbacks :reset do
        self.attributes = {}
      end
    end

    private
      def assign_attributes(new_attributes)
        new_attributes.each { |key, value| public_send("#{key}=", value) }
      end

      def compute_attributes(keys)
        keys.index_with { |key| public_send(key) }
      end
# frozen_string_literal: true

require "tzinfo"
require "concurrent/map"

module ActiveSupport
  # The TimeZone class serves as a wrapper around TZInfo::Timezone instances.
  # It allows us to do the following:
  #
  # * Limit the set of zones provided by TZInfo to a meaningful subset of 134
  #   zones.
  # * Retrieve and display zones with a friendlier name
  #   (e.g., "Eastern Time (US & Canada)" instead of "America/New_York").
  # * Lazily load TZInfo::Timezone instances only when they're needed.
  # * Create ActiveSupport::TimeWithZone instances via TimeZone's +local+,
  #   +parse+, +at+ and +now+ methods.
  #
  # If you set <tt>config.time_zone</tt> in the Rails Application, you can
  # access this TimeZone object via <tt>Time.zone</tt>:
  #
  #   # application.rb:
  #   class Application < Rails::Application
  #     config.time_zone = 'Eastern Time (US & Canada)'
  #   end
  #
  #   Time.zone      # => #<ActiveSupport::TimeZone:0x514834...>
  #   Time.zone.name # => "Eastern Time (US & Canada)"
  #   Time.zone.now  # => Sun, 18 May 2008 14:30:44 EDT -04:00
  class TimeZone
    # Keys are Rails TimeZone names, values are TZInfo identifiers.
    MAPPING = {
      "International Date Line West" => "Etc/GMT+12",
      "Midway Island"                => "Pacific/Midway",
      "American Samoa"               => "Pacific/Pago_Pago",
      "Hawaii"                       => "Pacific/Honolulu",
      "Alaska"                       => "America/Juneau",
      "Pacific Time (US & Canada)"   => "America/Los_Angeles",
      "Tijuana"                      => "America/Tijuana",
      "Mountain Time (US & Canada)"  => "America/Denver",
      "Arizona"                      => "America/Phoenix",
      "Chihuahua"                    => "America/Chihuahua",
      "Mazatlan"                     => "America/Mazatlan",
      "Central Time (US & Canada)"   => "America/Chicago",
      "Saskatchewan"                 => "America/Regina",
      "Guadalajara"                  => "America/Mexico_City",
      "Mexico City"                  => "America/Mexico_City",
      "Monterrey"                    => "America/Monterrey",
      "Central America"              => "America/Guatemala",
      "Eastern Time (US & Canada)"   => "America/New_York",
      "Indiana (East)"               => "America/Indiana/Indianapolis",
      "Bogota"                       => "America/Bogota",
      "Lima"                         => "America/Lima",
      "Quito"                        => "America/Lima",
      "Atlantic Time (Canada)"       => "America/Halifax",
      "Caracas"                      => "America/Caracas",
      "La Paz"                       => "America/La_Paz",
      "Santiago"                     => "America/Santiago",
      "Newfoundland"                 => "America/St_Johns",
      "Brasilia"                     => "America/Sao_Paulo",
      "Buenos Aires"                 => "America/Argentina/Buenos_Aires",
      "Montevideo"                   => "America/Montevideo",
      "Georgetown"                   => "America/Guyana",
      "Puerto Rico"                  => "America/Puerto_Rico",
      "Greenland"                    => "America/Godthab",
      "Mid-Atlantic"                 => "Atlantic/South_Georgia",
      "Azores"                       => "Atlantic/Azores",
      "Cape Verde Is."               => "Atlantic/Cape_Verde",
      "Dublin"                       => "Europe/Dublin",
      "Edinburgh"                    => "Europe/London",
      "Lisbon"                       => "Europe/Lisbon",
      "London"                       => "Europe/London",
      "Casablanca"                   => "Africa/Casablanca",
      "Monrovia"                     => "Africa/Monrovia",
      "UTC"                          => "Etc/UTC",
      "Belgrade"                     => "Europe/Belgrade",
      "Bratislava"                   => "Europe/Bratislava",
      "Budapest"                     => "Europe/Budapest",
      "Ljubljana"                    => "Europe/Ljubljana",
      "Prague"                       => "Europe/Prague",
      "Sarajevo"                     => "Europe/Sarajevo",
      "Skopje"                       => "Europe/Skopje",
      "Warsaw"                       => "Europe/Warsaw",
      "Zagreb"                       => "Europe/Zagreb",
      "Brussels"                     => "Europe/Brussels",
      "Copenhagen"                   => "Europe/Copenhagen",
      "Madrid"                       => "Europe/Madrid",
      "Paris"                        => "Europe/Paris",
      "Amsterdam"                    => "Europe/Amsterdam",
      "Berlin"                       => "Europe/Berlin",
      "Bern"                         => "Europe/Zurich",
      "Zurich"                       => "Europe/Zurich",
      "Rome"                         => "Europe/Rome",
      "Stockholm"                    => "Europe/Stockholm",
      "Vienna"                       => "Europe/Vienna",
      "West Central Africa"          => "Africa/Algiers",
      "Bucharest"                    => "Europe/Bucharest",
      "Cairo"                        => "Africa/Cairo",
      "Helsinki"                     => "Europe/Helsinki",
      "Kyiv"                         => "Europe/Kiev",
      "Riga"                         => "Europe/Riga",
      "Sofia"                        => "Europe/Sofia",
      "Tallinn"                      => "Europe/Tallinn",
      "Vilnius"                      => "Europe/Vilnius",
      "Athens"                       => "Europe/Athens",
      "Istanbul"                     => "Europe/Istanbul",
      "Minsk"                        => "Europe/Minsk",
      "Jerusalem"                    => "Asia/Jerusalem",
      "Harare"                       => "Africa/Harare",
      "Pretoria"                     => "Africa/Johannesburg",
      "Kaliningrad"                  => "Europe/Kaliningrad",
      "Moscow"                       => "Europe/Moscow",
      "St. Petersburg"               => "Europe/Moscow",
      "Volgograd"                    => "Europe/Volgograd",
      "Samara"                       => "Europe/Samara",
      "Kuwait"                       => "Asia/Kuwait",
      "Riyadh"                       => "Asia/Riyadh",
      "Nairobi"                      => "Africa/Nairobi",
      "Baghdad"                      => "Asia/Baghdad",
      "Tehran"                       => "Asia/Tehran",
      "Abu Dhabi"                    => "Asia/Muscat",
      "Muscat"                       => "Asia/Muscat",
      "Baku"                         => "Asia/Baku",
      "Tbilisi"                      => "Asia/Tbilisi",
      "Yerevan"                      => "Asia/Yerevan",
      "Kabul"                        => "Asia/Kabul",
      "Ekaterinburg"                 => "Asia/Yekaterinburg",
      "Islamabad"                    => "Asia/Karachi",
      "Karachi"                      => "Asia/Karachi",
      "Tashkent"                     => "Asia/Tashkent",
      "Chennai"                      => "Asia/Kolkata",
      "Kolkata"                      => "Asia/Kolkata",
      "Mumbai"                       => "Asia/Kolkata",
      "New Delhi"                    => "Asia/Kolkata",
      "Kathmandu"                    => "Asia/Kathmandu",
      "Astana"                       => "Asia/Dhaka",
      "Dhaka"                        => "Asia/Dhaka",
      "Sri Jayawardenepura"          => "Asia/Colombo",
      "Almaty"                       => "Asia/Almaty",
      "Novosibirsk"                  => "Asia/Novosibirsk",
      "Rangoon"                      => "Asia/Rangoon",
      "Bangkok"                      => "Asia/Bangkok",
      "Hanoi"                        => "Asia/Bangkok",
      "Jakarta"                      => "Asia/Jakarta",
      "Krasnoyarsk"                  => "Asia/Krasnoyarsk",
      "Beijing"                      => "Asia/Shanghai",
      "Chongqing"                    => "Asia/Chongqing",
      "Hong Kong"                    => "Asia/Hong_Kong",
      "Urumqi"                       => "Asia/Urumqi",
      "Kuala Lumpur"                 => "Asia/Kuala_Lumpur",
      "Singapore"                    => "Asia/Singapore",
      "Taipei"                       => "Asia/Taipei",
      "Perth"                        => "Australia/Perth",
      "Irkutsk"                      => "Asia/Irkutsk",
      "Ulaanbaatar"                  => "Asia/Ulaanbaatar",
      "Seoul"                        => "Asia/Seoul",
      "Osaka"                        => "Asia/Tokyo",
      "Sapporo"                      => "Asia/Tokyo",
      "Tokyo"                        => "Asia/Tokyo",
      "Yakutsk"                      => "Asia/Yakutsk",
      "Darwin"                       => "Australia/Darwin",
      "Adelaide"                     => "Australia/Adelaide",
      "Canberra"                     => "Australia/Melbourne",
      "Melbourne"                    => "Australia/Melbourne",
      "Sydney"                       => "Australia/Sydney",
      "Brisbane"                     => "Australia/Brisbane",
      "Hobart"                       => "Australia/Hobart",
      "Vladivostok"                  => "Asia/Vladivostok",
      "Guam"                         => "Pacific/Guam",
      "Port Moresby"                 => "Pacific/Port_Moresby",
      "Magadan"                      => "Asia/Magadan",
      "Srednekolymsk"                => "Asia/Srednekolymsk",
      "Solomon Is."                  => "Pacific/Guadalcanal",
      "New Caledonia"                => "Pacific/Noumea",
      "Fiji"                         => "Pacific/Fiji",
      "Kamchatka"                    => "Asia/Kamchatka",
      "Marshall Is."                 => "Pacific/Majuro",
      "Auckland"                     => "Pacific/Auckland",
      "Wellington"                   => "Pacific/Auckland",
      "Nuku'alofa"                   => "Pacific/Tongatapu",
      "Tokelau Is."                  => "Pacific/Fakaofo",
      "Chatham Is."                  => "Pacific/Chatham",
      "Samoa"                        => "Pacific/Apia"
    }

    UTC_OFFSET_WITH_COLON = "%s%02d:%02d" # :nodoc:
    UTC_OFFSET_WITHOUT_COLON = UTC_OFFSET_WITH_COLON.tr(":", "") # :nodoc:
    private_constant :UTC_OFFSET_WITH_COLON, :UTC_OFFSET_WITHOUT_COLON

    @lazy_zones_map = Concurrent::Map.new
    @country_zones  = Concurrent::Map.new

    class << self
      # Assumes self represents an offset from UTC in seconds (as returned from
      # Time#utc_offset) and turns this into an +HH:MM formatted string.
      #
      #   ActiveSupport::TimeZone.seconds_to_utc_offset(-21_600) # => "-06:00"
      def seconds_to_utc_offset(seconds, colon = true)
        format = colon ? UTC_OFFSET_WITH_COLON : UTC_OFFSET_WITHOUT_COLON
        sign = (seconds < 0 ? "-" : "+")
        hours = seconds.abs / 3600
        minutes = (seconds.abs % 3600) / 60
        format % [sign, hours, minutes]
      end

      def find_tzinfo(name)
        TZInfo::Timezone.get(MAPPING[name] || name)
      end

      alias_method :create, :new

      # Returns a TimeZone instance with the given name, or +nil+ if no
      # such TimeZone instance exists. (This exists to support the use of
      # this class with the +composed_of+ macro.)
      def new(name)
        self[name]
      end

      # Returns an array of all TimeZone objects. There are multiple
      # TimeZone objects per time zone, in many cases, to make it easier
      # for users to find their own time zone.
      def all
        @zones ||= zones_map.values.sort
      end

      # Locate a specific time zone object. If the argument is a string, it
      # is interpreted to mean the name of the timezone to locate. If it is a
      # numeric value it is either the hour offset, or the second offset, of the
      # timezone to find. (The first one with that offset will be returned.)
      # Returns +nil+ if no such time zone is known to the system.
      def [](arg)
        case arg
        when String
          begin
            @lazy_zones_map[arg] ||= create(arg)
          rescue TZInfo::InvalidTimezoneIdentifier
            nil
          end
        when Numeric, ActiveSupport::Duration
          arg *= 3600 if arg.abs <= 13
          all.find { |z| z.utc_offset == arg.to_i }
        else
          raise ArgumentError, "invalid argument to TimeZone[]: #{arg.inspect}"
        end
      end

      # A convenience method for returning a collection of TimeZone objects
      # for time zones in the USA.
      def us_zones
        country_zones(:us)
      end

      # A convenience method for returning a collection of TimeZone objects
      # for time zones in the country specified by its ISO 3166-1 Alpha2 code.
      def country_zones(country_code)
        code = country_code.to_s.upcase
        @country_zones[code] ||= load_country_zones(code)
      end

      def clear #:nodoc:
        @lazy_zones_map = Concurrent::Map.new
        @country_zones  = Concurrent::Map.new
        @zones = nil
        @zones_map = nil
      end

      private
        def load_country_zones(code)
          country = TZInfo::Country.get(code)
          country.zone_identifiers.flat_map do |tz_id|
            if MAPPING.value?(tz_id)
              MAPPING.inject([]) do |memo, (key, value)|
                memo << self[key] if value == tz_id
                memo
              end
            else
              create(tz_id, nil, TZInfo::Timezone.get(tz_id))
            end
          end.sort!
        end

        def zones_map
          @zones_map ||= MAPPING.each_with_object({}) do |(name, _), zones|
            timezone = self[name]
            zones[name] = timezone if timezone
          end
        end
    end

    include Comparable
    attr_reader :name
    attr_reader :tzinfo

    # Create a new TimeZone object with the given name and offset. The
    # offset is the number of seconds that this time zone is offset from UTC
    # (GMT). Seconds were chosen as the offset unit because that is the unit
    # that Ruby uses to represent time zone offsets (see Time#utc_offset).
    def initialize(name, utc_offset = nil, tzinfo = nil)
      @name = name
      @utc_offset = utc_offset
      @tzinfo = tzinfo || TimeZone.find_tzinfo(name)
    end

    # Returns the offset of this time zone from UTC in seconds.
    def utc_offset
      @utc_offset || tzinfo&.current_period&.base_utc_offset
    end

    # Returns a formatted string of the offset from UTC, or an alternative
    # string if the time zone is already UTC.
    #
    #   zone = ActiveSupport::TimeZone['Central Time (US & Canada)']
    #   zone.formatted_offset        # => "-06:00"
    #   zone.formatted_offset(false) # => "-0600"
    def formatted_offset(colon = true, alternate_utc_string = nil)
      utc_offset == 0 && alternate_utc_string || self.class.seconds_to_utc_offset(utc_offset, colon)
    end

    # Compare this time zone to the parameter. The two are compared first on
    # their offsets, and then by name.
    def <=>(zone)
      return unless zone.respond_to? :utc_offset
      result = (utc_offset <=> zone.utc_offset)
      result = (name <=> zone.name) if result == 0
      result
    end

    # Compare #name and TZInfo identifier to a supplied regexp, returning +true+
    # if a match is found.
    def =~(re)
      re === name || re === MAPPING[name]
    end

    # Compare #name and TZInfo identifier to a supplied regexp, returning +true+
    # if a match is found.
    def match?(re)
      (re == name) || (re == MAPPING[name]) ||
        ((Regexp === re) && (re.match?(name) || re.match?(MAPPING[name])))
    end

    # Returns a textual representation of this time zone.
    def to_s
      "(GMT#{formatted_offset}) #{name}"
    end

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from given values.
    #
    #   Time.zone = 'Hawaii'                    # => "Hawaii"
    #   Time.zone.local(2007, 2, 1, 15, 30, 45) # => Thu, 01 Feb 2007 15:30:45 HST -10:00
    def local(*args)
      time = Time.utc(*args)
      ActiveSupport::TimeWithZone.new(nil, self, time)
    end

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from number of seconds since the Unix epoch.
    #
    #   Time.zone = 'Hawaii'        # => "Hawaii"
    #   Time.utc(2000).to_f         # => 946684800.0
    #   Time.zone.at(946684800.0)   # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # A second argument can be supplied to specify sub-second precision.
    #
    #   Time.zone = 'Hawaii'                # => "Hawaii"
    #   Time.at(946684800, 123456.789).nsec # => 123456789
    def at(*args)
      Time.at(*args).utc.in_time_zone(self)
    end

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from an ISO 8601 string.
    #
    #   Time.zone = 'Hawaii'                     # => "Hawaii"
    #   Time.zone.iso8601('1999-12-31T14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If the time components are missing then they will be set to zero.
    #
    #   Time.zone = 'Hawaii'            # => "Hawaii"
    #   Time.zone.iso8601('1999-12-31') # => Fri, 31 Dec 1999 00:00:00 HST -10:00
    #
    # If the string is invalid then an +ArgumentError+ will be raised unlike +parse+
    # which usually returns +nil+ when given an invalid date string.
    def iso8601(str)
      parts = Date._iso8601(str)

      raise ArgumentError, "invalid date" if parts.empty?

      time = Time.new(
        parts.fetch(:year),
        parts.fetch(:mon),
        parts.fetch(:mday),
        parts.fetch(:hour, 0),
        parts.fetch(:min, 0),
        parts.fetch(:sec, 0) + parts.fetch(:sec_fraction, 0),
        parts.fetch(:offset, 0)
      )

      if parts[:offset]
        TimeWithZone.new(time.utc, self)
      else
        TimeWithZone.new(nil, self, time)
      end
    end

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from parsed string.
    #
    #   Time.zone = 'Hawaii'                   # => "Hawaii"
    #   Time.zone.parse('1999-12-31 14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If upper components are missing from the string, they are supplied from
    # TimeZone#now:
    #
    #   Time.zone.now               # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #   Time.zone.parse('22:30:00') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
    #
    # However, if the date component is not provided, but any other upper
    # components are supplied, then the day of the month defaults to 1:
    #
    #   Time.zone.parse('Mar 2000') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
    #
    # If the string is invalid then an +ArgumentError+ could be raised.
    def parse(str, now = now())
      parts_to_time(Date._parse(str, false), now)
    end

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from an RFC 3339 string.
    #
    #   Time.zone = 'Hawaii'                     # => "Hawaii"
    #   Time.zone.rfc3339('2000-01-01T00:00:00Z') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If the time or zone components are missing then an +ArgumentError+ will
    # be raised. This is much stricter than either +parse+ or +iso8601+ which
    # allow for missing components.
    #
    #   Time.zone = 'Hawaii'            # => "Hawaii"
    #   Time.zone.rfc3339('1999-12-31') # => ArgumentError: invalid date
    def rfc3339(str)
      parts = Date._rfc3339(str)

      raise ArgumentError, "invalid date" if parts.empty?

      time = Time.new(
        parts.fetch(:year),
        parts.fetch(:mon),
        parts.fetch(:mday),
        parts.fetch(:hour),
        parts.fetch(:min),
        parts.fetch(:sec) + parts.fetch(:sec_fraction, 0),
        parts.fetch(:offset)
      )

      TimeWithZone.new(time.utc, self)
    end

    # Parses +str+ according to +format+ and returns an ActiveSupport::TimeWithZone.
    #
    # Assumes that +str+ is a time in the time zone +self+,
    # unless +format+ includes an explicit time zone.
    # (This is the same behavior as +parse+.)
    # In either case, the returned TimeWithZone has the timezone of +self+.
    #
    #   Time.zone = 'Hawaii'                   # => "Hawaii"
    #   Time.zone.strptime('1999-12-31 14:00:00', '%Y-%m-%d %H:%M:%S') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If upper components are missing from the string, they are supplied from
    # TimeZone#now:
    #
    #   Time.zone.now                              # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #   Time.zone.strptime('22:30:00', '%H:%M:%S') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
    #
    # However, if the date component is not provided, but any other upper
    # components are supplied, then the day of the month defaults to 1:
    #
    #   Time.zone.strptime('Mar 2000', '%b %Y') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
    def strptime(str, format, now = now())
      parts_to_time(DateTime._strptime(str, format), now)
    end

    # Returns an ActiveSupport::TimeWithZone instance representing the current
    # time in the time zone represented by +self+.
    #
    #   Time.zone = 'Hawaii'  # => "Hawaii"
    #   Time.zone.now         # => Wed, 23 Jan 2008 20:24:27 HST -10:00
    def now
      time_now.utc.in_time_zone(self)
    end

    # Returns the current date in this time zone.
    def today
      tzinfo.now.to_date
    end

    # Returns the next date in this time zone.
    def tomorrow
      today + 1
    end

    # Returns the previous date in this time zone.
    def yesterday
      today - 1
    end

    # Adjust the given time to the simultaneous time in the time zone
    # represented by +self+. Returns a local time with the appropriate offset
    # -- if you want an ActiveSupport::TimeWithZone instance, use
    # Time#in_time_zone() instead.
    #
    # As of tzinfo 2, utc_to_local returns a Time with a non-zero utc_offset.
    # See the +utc_to_local_returns_utc_offset_times+ config for more info.
    def utc_to_local(time)
      tzinfo.utc_to_local(time).yield_self do |t|
        ActiveSupport.utc_to_local_returns_utc_offset_times ?
          t : Time.utc(t.year, t.month, t.day, t.hour, t.min, t.sec, t.sec_fraction)
      end
    end

    # Adjust the given time to the simultaneous time in UTC. Returns a
    # Time.utc() instance.
    def local_to_utc(time, dst = true)
      tzinfo.local_to_utc(time, dst)
    end

    # Available so that TimeZone instances respond like TZInfo::Timezone
    # instances.
    def period_for_utc(time)
      tzinfo.period_for_utc(time)
    end

    # Available so that TimeZone instances respond like TZInfo::Timezone
    # instances.
    def period_for_local(time, dst = true)
      tzinfo.period_for_local(time, dst) { |periods| periods.last }
    end

    def periods_for_local(time) #:nodoc:
      tzinfo.periods_for_local(time)
    end

    def init_with(coder) #:nodoc:
      initialize(coder["name"])
    end

    def encode_with(coder) #:nodoc:
      coder.tag = "!ruby/object:#{self.class}"
      coder.map = { "name" => tzinfo.name }
    end

    private
      def parts_to_time(parts, now)
        raise ArgumentError, "invalid date" if parts.nil?
        return if parts.empty?

        if parts[:seconds]
          time = Time.at(parts[:seconds])
        else
          time = Time.new(
            parts.fetch(:year, now.year),
            parts.fetch(:mon, now.month),
            parts.fetch(:mday, parts[:year] || parts[:mon] ? 1 : now.day),
            parts.fetch(:hour, 0),
            parts.fetch(:min, 0),
            parts.fetch(:sec, 0) + parts.fetch(:sec_fraction, 0),
            parts.fetch(:offset, 0)
          )
        end

        if parts[:offset] || parts[:seconds]
          TimeWithZone.new(time.utc, self)
        else
          TimeWithZone.new(nil, self, time)
        end
      end

# frozen_string_literal: true

module ActiveSupport
  module ForkTracker # :nodoc:
    module CoreExt
      def fork(*)
        if block_given?
          super do
            ForkTracker.check!
            yield
          end
        else
          unless pid = super
            ForkTracker.check!
          end
          pid
        end
      end
    end

    module CoreExtPrivate
      include CoreExt

      private
        def fork(*)
          super
        end
    end

    @pid = Process.pid
    @callbacks = []

    class << self
      def check!
        if @pid != Process.pid
          @callbacks.each(&:call)
          @pid = Process.pid
        end
      end

      def hook!
        if Process.respond_to?(:fork)
          ::Object.prepend(CoreExtPrivate)
          ::Kernel.prepend(CoreExtPrivate)
          ::Kernel.singleton_class.prepend(CoreExt)
          ::Process.singleton_class.prepend(CoreExt)
        end
      end

      def after_fork(&block)
        @callbacks << block
        block
      end

      def unregister(callback)
        @callbacks.delete(callback)
      end
    end
  end
end
# frozen_string_literal: true

module ActiveSupport #:nodoc:
  module Multibyte
    autoload :Chars, "active_support/multibyte/chars"
    autoload :Unicode, "active_support/multibyte/unicode"

    # The proxy class returned when calling mb_chars. You can use this accessor
    # to configure your own proxy class so you can support other encodings. See
    # the ActiveSupport::Multibyte::Chars implementation for an example how to
    # do this.
    #
    #   ActiveSupport::Multibyte.proxy_class = CharsForUTF32
    def self.proxy_class=(klass)
      @proxy_class = klass
    end

    # Returns the current proxy class.
    def self.proxy_class
      @proxy_class ||= ActiveSupport::Multibyte::Chars
# frozen_string_literal: true

module ActiveSupport
  # Backtraces often include many lines that are not relevant for the context
  # under review. This makes it hard to find the signal amongst the backtrace
  # noise, and adds debugging time. With a BacktraceCleaner, filters and
  # silencers are used to remove the noisy lines, so that only the most relevant
  # lines remain.
  #
  # Filters are used to modify lines of data, while silencers are used to remove
  # lines entirely. The typical filter use case is to remove lengthy path
  # information from the start of each line, and view file paths relevant to the
  # app directory instead of the file system root. The typical silencer use case
  # is to exclude the output of a noisy library from the backtrace, so that you
  # can focus on the rest.
  #
  #   bc = ActiveSupport::BacktraceCleaner.new
  #   bc.add_filter   { |line| line.gsub(Rails.root.to_s, '') } # strip the Rails.root prefix
  #   bc.add_silencer { |line| /puma|rubygems/.match?(line) } # skip any lines from puma or rubygems
  #   bc.clean(exception.backtrace) # perform the cleanup
  #
  # To reconfigure an existing BacktraceCleaner (like the default one in Rails)
  # and show as much data as possible, you can always call
  # <tt>BacktraceCleaner#remove_silencers!</tt>, which will restore the
  # backtrace to a pristine state. If you need to reconfigure an existing
  # BacktraceCleaner so that it does not filter or modify the paths of any lines
  # of the backtrace, you can call <tt>BacktraceCleaner#remove_filters!</tt>
  # These two methods will give you a completely untouched backtrace.
  #
  # Inspired by the Quiet Backtrace gem by thoughtbot.
  class BacktraceCleaner
    def initialize
      @filters, @silencers = [], []
      add_gem_filter
      add_gem_silencer
      add_stdlib_silencer
    end

    # Returns the backtrace after all filters and silencers have been run
    # against it. Filters run first, then silencers.
    def clean(backtrace, kind = :silent)
      filtered = filter_backtrace(backtrace)

      case kind
      when :silent
        silence(filtered)
      when :noise
        noise(filtered)
      else
        filtered
      end
    end
    alias :filter :clean

    # Adds a filter from the block provided. Each line in the backtrace will be
    # mapped against this filter.
    #
    #   # Will turn "/my/rails/root/app/models/person.rb" into "/app/models/person.rb"
    #   backtrace_cleaner.add_filter { |line| line.gsub(Rails.root, '') }
    def add_filter(&block)
      @filters << block
    end

    # Adds a silencer from the block provided. If the silencer returns +true+
    # for a given line, it will be excluded from the clean backtrace.
    #
    #   # Will reject all lines that include the word "puma", like "/gems/puma/server.rb" or "/app/my_puma_server/rb"
    #   backtrace_cleaner.add_silencer { |line| /puma/.match?(line) }
    def add_silencer(&block)
      @silencers << block
    end

    # Removes all silencers, but leaves in the filters. Useful if your
    # context of debugging suddenly expands as you suspect a bug in one of
    # the libraries you use.
    def remove_silencers!
      @silencers = []
    end

    # Removes all filters, but leaves in the silencers. Useful if you suddenly
    # need to see entire filepaths in the backtrace that you had already
    # filtered out.
    def remove_filters!
      @filters = []
    end

    private
      FORMATTED_GEMS_PATTERN = /\A[^\/]+ \([\w.]+\) /

      def add_gem_filter
        gems_paths = (Gem.path | [Gem.default_dir]).map { |p| Regexp.escape(p) }
        return if gems_paths.empty?

        gems_regexp = %r{\A(#{gems_paths.join('|')})/(bundler/)?gems/([^/]+)-([\w.]+)/(.*)}
        gems_result = '\3 (\4) \5'
        add_filter { |line| line.sub(gems_regexp, gems_result) }
      end

      def add_gem_silencer
        add_silencer { |line| FORMATTED_GEMS_PATTERN.match?(line) }
      end

      def add_stdlib_silencer
        add_silencer { |line| line.start_with?(RbConfig::CONFIG["rubylibdir"]) }
      end

      def filter_backtrace(backtrace)
        @filters.each do |f|
          backtrace = backtrace.map { |line| f.call(line) }
        end

        backtrace
      end

      def silence(backtrace)
        @silencers.each do |s|
          backtrace = backtrace.reject { |line| s.call(line) }
        end

        backtrace
      end

      def noise(backtrace)
        backtrace.select do |line|
          @silencers.any? do |s|
            s.call(line)
          end
        end
      end
  end
# frozen_string_literal: true

require "yaml"

YAML.add_builtin_type("omap") do |type, val|
  ActiveSupport::OrderedHash[val.map { |v| v.to_a.first }]
end

module ActiveSupport
  # DEPRECATED: <tt>ActiveSupport::OrderedHash</tt> implements a hash that preserves
  # insertion order.
  #
  #   oh = ActiveSupport::OrderedHash.new
  #   oh[:a] = 1
  #   oh[:b] = 2
  #   oh.keys # => [:a, :b], this order is guaranteed
  #
  # Also, maps the +omap+ feature for YAML files
  # (See https://yaml.org/type/omap.html) to support ordered items
  # when loading from yaml.
  #
  # <tt>ActiveSupport::OrderedHash</tt> is namespaced to prevent conflicts
  # with other implementations.
  class OrderedHash < ::Hash
    def to_yaml_type
      "!tag:yaml.org,2002:omap"
    end

    def encode_with(coder)
      coder.represent_seq "!omap", map { |k, v| { k => v } }
    end

    def select(*args, &block)
      dup.tap { |hash| hash.select!(*args, &block) }
    end

    def reject(*args, &block)
      dup.tap { |hash| hash.reject!(*args, &block) }
    end

    def nested_under_indifferent_access
      self
    end

    # Returns true to make sure that this hash is extractable via <tt>Array#extract_options!</tt>
# frozen_string_literal: true

require "active_support/inflections"
require "active_support/core_ext/object/blank"

module ActiveSupport
  # The Inflector transforms words from singular to plural, class names to table
  # names, modularized class names to ones without, and class names to foreign
  # keys. The default inflections for pluralization, singularization, and
  # uncountable words are kept in inflections.rb.
  #
  # The Rails core team has stated patches for the inflections library will not
  # be accepted in order to avoid breaking legacy applications which may be
  # relying on errant inflections. If you discover an incorrect inflection and
  # require it for your application or wish to define rules for languages other
  # than English, please correct or add them yourself (explained below).
  module Inflector
    extend self

    # Returns the plural form of the word in the string.
    #
    # If passed an optional +locale+ parameter, the word will be
    # pluralized using rules defined for that language. By default,
    # this parameter is set to <tt>:en</tt>.
    #
    #   pluralize('post')             # => "posts"
    #   pluralize('octopus')          # => "octopi"
    #   pluralize('sheep')            # => "sheep"
    #   pluralize('words')            # => "words"
    #   pluralize('CamelOctopus')     # => "CamelOctopi"
    #   pluralize('ley', :es)         # => "leyes"
    def pluralize(word, locale = :en)
      apply_inflections(word, inflections(locale).plurals, locale)
    end

    # The reverse of #pluralize, returns the singular form of a word in a
    # string.
    #
    # If passed an optional +locale+ parameter, the word will be
    # singularized using rules defined for that language. By default,
    # this parameter is set to <tt>:en</tt>.
    #
    #   singularize('posts')            # => "post"
    #   singularize('octopi')           # => "octopus"
    #   singularize('sheep')            # => "sheep"
    #   singularize('word')             # => "word"
    #   singularize('CamelOctopi')      # => "CamelOctopus"
    #   singularize('leyes', :es)       # => "ley"
    def singularize(word, locale = :en)
      apply_inflections(word, inflections(locale).singulars, locale)
    end

    # Converts strings to UpperCamelCase.
    # If the +uppercase_first_letter+ parameter is set to false, then produces
    # lowerCamelCase.
    #
    # Also converts '/' to '::' which is useful for converting
    # paths to namespaces.
    #
    #   camelize('active_model')                # => "ActiveModel"
    #   camelize('active_model', false)         # => "activeModel"
    #   camelize('active_model/errors')         # => "ActiveModel::Errors"
    #   camelize('active_model/errors', false)  # => "activeModel::Errors"
    #
    # As a rule of thumb you can think of +camelize+ as the inverse of
    # #underscore, though there are cases where that does not hold:
    #
    #   camelize(underscore('SSLError'))        # => "SslError"
    def camelize(term, uppercase_first_letter = true)
      string = term.to_s
      # String#camelize takes a symbol (:upper or :lower), so here we also support :lower to keep the methods consistent.
      if !uppercase_first_letter || uppercase_first_letter == :lower
        string = string.sub(inflections.acronyms_camelize_regex) { |match| match.downcase! || match }
      else
        string = string.sub(/^[a-z\d]*/) { |match| inflections.acronyms[match] || match.capitalize! || match }
      end
      string.gsub!(/(?:_|(\/))([a-z\d]*)/i) do
        word = $2
        substituted = inflections.acronyms[word] || word.capitalize! || word
        $1 ? "::#{substituted}" : substituted
      end
      string
    end

    # Makes an underscored, lowercase form from the expression in the string.
    #
    # Changes '::' to '/' to convert namespaces to paths.
    #
    #   underscore('ActiveModel')         # => "active_model"
    #   underscore('ActiveModel::Errors') # => "active_model/errors"
    #
    # As a rule of thumb you can think of +underscore+ as the inverse of
    # #camelize, though there are cases where that does not hold:
    #
    #   camelize(underscore('SSLError'))  # => "SslError"
    def underscore(camel_cased_word)
      return camel_cased_word unless /[A-Z-]|::/.match?(camel_cased_word)
      word = camel_cased_word.to_s.gsub("::", "/")
      word.gsub!(inflections.acronyms_underscore_regex) { "#{$1 && '_' }#{$2.downcase}" }
      word.gsub!(/([A-Z\d]+)(?=[A-Z][a-z])|([a-z\d])(?=[A-Z])/) { ($1 || $2) << "_" }
      word.tr!("-", "_")
      word.downcase!
      word
    end

    # Tweaks an attribute name for display to end users.
    #
    # Specifically, performs these transformations:
    #
    # * Applies human inflection rules to the argument.
    # * Deletes leading underscores, if any.
    # * Removes a "_id" suffix if present.
    # * Replaces underscores with spaces, if any.
    # * Downcases all words except acronyms.
    # * Capitalizes the first word.
    # The capitalization of the first word can be turned off by setting the
    # +:capitalize+ option to false (default is true).
    #
    # The trailing '_id' can be kept and capitalized by setting the
    # optional parameter +keep_id_suffix+ to true (default is false).
    #
    #   humanize('employee_salary')                  # => "Employee salary"
    #   humanize('author_id')                        # => "Author"
    #   humanize('author_id', capitalize: false)     # => "author"
    #   humanize('_id')                              # => "Id"
    #   humanize('author_id', keep_id_suffix: true)  # => "Author Id"
    #
    # If "SSL" was defined to be an acronym:
    #
    #   humanize('ssl_error') # => "SSL error"
    #
    def humanize(lower_case_and_underscored_word, capitalize: true, keep_id_suffix: false)
      result = lower_case_and_underscored_word.to_s.dup

      inflections.humans.each { |(rule, replacement)| break if result.sub!(rule, replacement) }

      result.tr!("_", " ")
      result.lstrip!
      unless keep_id_suffix
        result.delete_suffix!(" id")
      end

      result.gsub!(/([a-z\d]+)/i) do |match|
        match.downcase!
        inflections.acronyms[match] || match
      end

      if capitalize
        result.sub!(/\A\w/) do |match|
          match.upcase!
          match
        end
      end

      result
    end

    # Converts just the first character to uppercase.
    #
    #   upcase_first('what a Lovely Day') # => "What a Lovely Day"
    #   upcase_first('w')                 # => "W"
    #   upcase_first('')                  # => ""
    def upcase_first(string)
      string.length > 0 ? string[0].upcase.concat(string[1..-1]) : ""
    end

    # Capitalizes all the words and replaces some characters in the string to
    # create a nicer looking title. +titleize+ is meant for creating pretty
    # output. It is not used in the Rails internals.
    #
    # The trailing '_id','Id'.. can be kept and capitalized by setting the
    # optional parameter +keep_id_suffix+ to true.
    # By default, this parameter is false.
    #
    # +titleize+ is also aliased as +titlecase+.
    #
    #   titleize('man from the boondocks')                       # => "Man From The Boondocks"
    #   titleize('x-men: the last stand')                        # => "X Men: The Last Stand"
    #   titleize('TheManWithoutAPast')                           # => "The Man Without A Past"
    #   titleize('raiders_of_the_lost_ark')                      # => "Raiders Of The Lost Ark"
    #   titleize('string_ending_with_id', keep_id_suffix: true)  # => "String Ending With Id"
    def titleize(word, keep_id_suffix: false)
      humanize(underscore(word), keep_id_suffix: keep_id_suffix).gsub(/\b(?<!\w['`()])[a-z]/) do |match|
        match.capitalize
      end
    end

    # Creates the name of a table like Rails does for models to table names.
    # This method uses the #pluralize method on the last word in the string.
    #
    #   tableize('RawScaledScorer') # => "raw_scaled_scorers"
    #   tableize('ham_and_egg')     # => "ham_and_eggs"
    #   tableize('fancyCategory')   # => "fancy_categories"
    def tableize(class_name)
      pluralize(underscore(class_name))
    end

    # Creates a class name from a plural table name like Rails does for table
    # names to models. Note that this returns a string and not a Class (To
    # convert to an actual class follow +classify+ with #constantize).
    #
    #   classify('ham_and_eggs') # => "HamAndEgg"
    #   classify('posts')        # => "Post"
    #
    # Singular names are not handled correctly:
    #
    #   classify('calculus')     # => "Calculu"
    def classify(table_name)
      # strip out any leading schema name
      camelize(singularize(table_name.to_s.sub(/.*\./, "")))
    end

    # Replaces underscores with dashes in the string.
    #
    #   dasherize('puni_puni') # => "puni-puni"
    def dasherize(underscored_word)
      underscored_word.tr("_", "-")
    end

    # Removes the module part from the expression in the string.
    #
    #   demodulize('ActiveSupport::Inflector::Inflections') # => "Inflections"
    #   demodulize('Inflections')                           # => "Inflections"
    #   demodulize('::Inflections')                         # => "Inflections"
    #   demodulize('')                                      # => ""
    #
    # See also #deconstantize.
    def demodulize(path)
      path = path.to_s
      if i = path.rindex("::")
        path[(i + 2)..-1]
      else
        path
      end
    end

    # Removes the rightmost segment from the constant expression in the string.
    #
    #   deconstantize('Net::HTTP')   # => "Net"
    #   deconstantize('::Net::HTTP') # => "::Net"
    #   deconstantize('String')      # => ""
    #   deconstantize('::String')    # => ""
    #   deconstantize('')            # => ""
    #
    # See also #demodulize.
    def deconstantize(path)
      path.to_s[0, path.rindex("::") || 0] # implementation based on the one in facets' Module#spacename
    end

    # Creates a foreign key name from a class name.
    # +separate_class_name_and_id_with_underscore+ sets whether
    # the method should put '_' between the name and 'id'.
    #
    #   foreign_key('Message')        # => "message_id"
    #   foreign_key('Message', false) # => "messageid"
    #   foreign_key('Admin::Post')    # => "post_id"
    def foreign_key(class_name, separate_class_name_and_id_with_underscore = true)
      underscore(demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? "_id" : "id")
    end

    # Tries to find a constant with the name specified in the argument string.
    #
    #   constantize('Module')   # => Module
    #   constantize('Foo::Bar') # => Foo::Bar
    #
    # The name is assumed to be the one of a top-level constant, no matter
    # whether it starts with "::" or not. No lexical context is taken into
    # account:
    #
    #   C = 'outside'
    #   module M
    #     C = 'inside'
    #     C                # => 'inside'
    #     constantize('C') # => 'outside', same as ::C
    #   end
    #
    # NameError is raised when the name is not in CamelCase or the constant is
    # unknown.
    def constantize(camel_cased_word)
      if camel_cased_word.blank? || !camel_cased_word.include?("::")
        Object.const_get(camel_cased_word)
      else
        names = camel_cased_word.split("::")

        # Trigger a built-in NameError exception including the ill-formed constant in the message.
        Object.const_get(camel_cased_word) if names.empty?

        # Remove the first blank element in case of '::ClassName' notation.
        names.shift if names.size > 1 && names.first.empty?

        names.inject(Object) do |constant, name|
          if constant == Object
            constant.const_get(name)
          else
            candidate = constant.const_get(name)
            next candidate if constant.const_defined?(name, false)
            next candidate unless Object.const_defined?(name)

            # Go down the ancestors to check if it is owned directly. The check
            # stops when we reach Object or the end of ancestors tree.
            constant = constant.ancestors.inject(constant) do |const, ancestor|
              break const    if ancestor == Object
              break ancestor if ancestor.const_defined?(name, false)
              const
            end

            # owner is in Object, so raise
            constant.const_get(name, false)
          end
        end
      end
    end

    # Tries to find a constant with the name specified in the argument string.
    #
    #   safe_constantize('Module')   # => Module
    #   safe_constantize('Foo::Bar') # => Foo::Bar
    #
    # The name is assumed to be the one of a top-level constant, no matter
    # whether it starts with "::" or not. No lexical context is taken into
    # account:
    #
    #   C = 'outside'
    #   module M
    #     C = 'inside'
    #     C                     # => 'inside'
    #     safe_constantize('C') # => 'outside', same as ::C
    #   end
    #
    # +nil+ is returned when the name is not in CamelCase or the constant (or
    # part of it) is unknown.
    #
    #   safe_constantize('blargle')                  # => nil
    #   safe_constantize('UnknownModule')            # => nil
    #   safe_constantize('UnknownModule::Foo::Bar')  # => nil
    def safe_constantize(camel_cased_word)
      constantize(camel_cased_word)
    rescue NameError => e
      raise if e.name && !(camel_cased_word.to_s.split("::").include?(e.name.to_s) ||
        e.name.to_s == camel_cased_word.to_s)
    rescue LoadError => e
      message = e.respond_to?(:original_message) ? e.original_message : e.message
      raise unless /Unable to autoload constant #{const_regexp(camel_cased_word)}/.match?(message)
    end

    # Returns the suffix that should be added to a number to denote the position
    # in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    #
    #   ordinal(1)     # => "st"
    #   ordinal(2)     # => "nd"
    #   ordinal(1002)  # => "nd"
    #   ordinal(1003)  # => "rd"
    #   ordinal(-11)   # => "th"
    #   ordinal(-1021) # => "st"
    def ordinal(number)
      I18n.translate("number.nth.ordinals", number: number)
    end

    # Turns a number into an ordinal string used to denote the position in an
    # ordered sequence such as 1st, 2nd, 3rd, 4th.
    #
    #   ordinalize(1)     # => "1st"
    #   ordinalize(2)     # => "2nd"
    #   ordinalize(1002)  # => "1002nd"
    #   ordinalize(1003)  # => "1003rd"
    #   ordinalize(-11)   # => "-11th"
    #   ordinalize(-1021) # => "-1021st"
    def ordinalize(number)
      I18n.translate("number.nth.ordinalized", number: number)
    end

    private
      # Mounts a regular expression, returned as a string to ease interpolation,
      # that will match part by part the given constant.
      #
      #   const_regexp("Foo::Bar::Baz") # => "Foo(::Bar(::Baz)?)?"
      #   const_regexp("::")            # => "::"
      def const_regexp(camel_cased_word)
        parts = camel_cased_word.split("::")

        return Regexp.escape(camel_cased_word) if parts.blank?

        last = parts.pop

        parts.reverse!.inject(last) do |acc, part|
          part.empty? ? acc : "#{part}(::#{acc})?"
        end
      end

      # Applies inflection rules for +singularize+ and +pluralize+.
      #
      # If passed an optional +locale+ parameter, the uncountables will be
      # found for that locale.
      #
      #  apply_inflections('post', inflections.plurals, :en)    # => "posts"
      #  apply_inflections('posts', inflections.singulars, :en) # => "post"
      def apply_inflections(word, rules, locale = :en)
        result = word.to_s.dup

        if word.empty? || inflections(locale).uncountables.uncountable?(result)
          result
        else
          rules.each { |(rule, replacement)| break if result.sub!(rule, replacement) }
          result
        end
# frozen_string_literal: true

require "active_support/core_ext/string/multibyte"
require "active_support/i18n"

module ActiveSupport
  module Inflector
    ALLOWED_ENCODINGS_FOR_TRANSLITERATE = [Encoding::UTF_8, Encoding::US_ASCII, Encoding::GB18030].freeze

    # Replaces non-ASCII characters with an ASCII approximation, or if none
    # exists, a replacement character which defaults to "?".
    #
    #    transliterate('rskbing')
    #    # => "AEroskobing"
    #
    # Default approximations are provided for Western/Latin characters,
    # e.g, "", "", "", "", etc.
    #
    # This method is I18n aware, so you can set up custom approximations for a
    # locale. This can be useful, for example, to transliterate German's ""
    # and "" to "ue" and "oe", or to add support for transliterating Russian
    # to ASCII.
    #
    # In order to make your custom transliterations available, you must set
    # them as the <tt>i18n.transliterate.rule</tt> i18n key:
    #
    #   # Store the transliterations in locales/de.yml
    #   i18n:
    #     transliterate:
    #       rule:
    #         : "ue"
    #         : "oe"
    #
    #   # Or set them using Ruby
    #   I18n.backend.store_translations(:de, i18n: {
    #     transliterate: {
    #       rule: {
    #         '' => 'ue',
    #         '' => 'oe'
    #       }
    #     }
    #   })
    #
    # The value for <tt>i18n.transliterate.rule</tt> can be a simple Hash that
    # maps characters to ASCII approximations as shown above, or, for more
    # complex requirements, a Proc:
    #
    #   I18n.backend.store_translations(:de, i18n: {
    #     transliterate: {
    #       rule: ->(string) { MyTransliterator.transliterate(string) }
    #     }
    #   })
    #
    # Now you can have different transliterations for each locale:
    #
    #   transliterate('Jrgen', locale: :en)
    #   # => "Jurgen"
    #
    #   transliterate('Jrgen', locale: :de)
    #   # => "Juergen"
    #
    # Transliteration is restricted to UTF-8, US-ASCII and GB18030 strings
    # Other encodings will raise an ArgumentError.
    def transliterate(string, replacement = "?", locale: nil)
      string = string.dup if string.frozen?
      raise ArgumentError, "Can only transliterate strings. Received #{string.class.name}" unless string.is_a?(String)
      raise ArgumentError, "Cannot transliterate strings with #{string.encoding} encoding" unless ALLOWED_ENCODINGS_FOR_TRANSLITERATE.include?(string.encoding)

      input_encoding = string.encoding

      # US-ASCII is a subset of UTF-8 so we'll force encoding as UTF-8 if
      # US-ASCII is given. This way we can let tidy_bytes handle the string
      # in the same way as we do for UTF-8
      string.force_encoding(Encoding::UTF_8) if string.encoding == Encoding::US_ASCII

      # GB18030 is Unicode compatible but is not a direct mapping so needs to be
      # transcoded. Using invalid/undef :replace will result in loss of data in
      # the event of invalid characters, but since tidy_bytes will replace
      # invalid/undef with a "?" we're safe to do the same beforehand
      string.encode!(Encoding::UTF_8, invalid: :replace, undef: :replace) if string.encoding == Encoding::GB18030

      transliterated = I18n.transliterate(
        ActiveSupport::Multibyte::Unicode.tidy_bytes(string).unicode_normalize(:nfc),
        replacement: replacement,
        locale: locale
      )

      # Restore the string encoding of the input if it was not UTF-8.
      # Apply invalid/undef :replace as tidy_bytes does
      transliterated.encode!(input_encoding, invalid: :replace, undef: :replace) if input_encoding != transliterated.encoding

      transliterated
    end

    # Replaces special characters in a string so that it may be used as part of
    # a 'pretty' URL.
    #
    #   parameterize("Donald E. Knuth") # => "donald-e-knuth"
    #   parameterize("^trs|Jolie-- ")  # => "tres-jolie"
    #
    # To use a custom separator, override the +separator+ argument.
    #
    #   parameterize("Donald E. Knuth", separator: '_') # => "donald_e_knuth"
    #   parameterize("^trs|Jolie__ ", separator: '_')  # => "tres_jolie"
    #
    # To preserve the case of the characters in a string, use the +preserve_case+ argument.
    #
    #   parameterize("Donald E. Knuth", preserve_case: true) # => "Donald-E-Knuth"
    #   parameterize("^trs|Jolie-- ", preserve_case: true) # => "tres-Jolie"
    #
    # It preserves dashes and underscores unless they are used as separators:
    #
    #   parameterize("^trs|Jolie__ ")                 # => "tres-jolie__"
    #   parameterize("^trs|Jolie-- ", separator: "_") # => "tres_jolie--"
    #   parameterize("^trs_Jolie-- ", separator: ".") # => "tres_jolie--"
    #
    # If the optional parameter +locale+ is specified,
    # the word will be parameterized as a word of that language.
    # By default, this parameter is set to <tt>nil</tt> and it will use
    # the configured <tt>I18n.locale</tt>.
    def parameterize(string, separator: "-", preserve_case: false, locale: nil)
      # Replace accented chars with their ASCII equivalents.
      parameterized_string = transliterate(string, locale: locale)

      # Turn unwanted chars into the separator.
      parameterized_string.gsub!(/[^a-z0-9\-_]+/i, separator)

      unless separator.nil? || separator.empty?
        if separator == "-"
          re_duplicate_separator        = /-{2,}/
          re_leading_trailing_separator = /^-|-$/i
        else
          re_sep = Regexp.escape(separator)
          re_duplicate_separator        = /#{re_sep}{2,}/
          re_leading_trailing_separator = /^#{re_sep}|#{re_sep}$/i
        end
        # No more than one of the separator in a row.
        parameterized_string.gsub!(re_duplicate_separator, separator)
        # Remove leading/trailing separator.
        parameterized_string.gsub!(re_leading_trailing_separator, "")
      end

      parameterized_string.downcase! unless preserve_case
      parameterized_string
    end
# frozen_string_literal: true

require "concurrent/map"
require "active_support/i18n"

module ActiveSupport
  module Inflector
    extend self

    # A singleton instance of this class is yielded by Inflector.inflections,
    # which can then be used to specify additional inflection rules. If passed
    # an optional locale, rules for other languages can be specified. The
    # default locale is <tt>:en</tt>. Only rules for English are provided.
    #
    #   ActiveSupport::Inflector.inflections(:en) do |inflect|
    #     inflect.plural /^(ox)$/i, '\1\2en'
    #     inflect.singular /^(ox)en/i, '\1'
    #
    #     inflect.irregular 'octopus', 'octopi'
    #
    #     inflect.uncountable 'equipment'
    #   end
    #
    # New rules are added at the top. So in the example above, the irregular
    # rule for octopus will now be the first of the pluralization and
    # singularization rules that is runs. This guarantees that your rules run
    # before any of the rules that may already have been loaded.
    class Inflections
      @__instance__ = Concurrent::Map.new

      class Uncountables < Array
        def initialize
          @regex_array = []
          super
        end

        def delete(entry)
          super entry
          @regex_array.delete(to_regex(entry))
        end

        def <<(*word)
          add(word)
        end

        def add(words)
          words = words.flatten.map(&:downcase)
          concat(words)
          @regex_array += words.map { |word| to_regex(word) }
          self
        end

        def uncountable?(str)
          @regex_array.any? { |regex| regex.match? str }
        end

        private
          def to_regex(string)
            /\b#{::Regexp.escape(string)}\Z/i
          end
      end

      def self.instance(locale = :en)
        @__instance__[locale] ||= new
      end

      def self.instance_or_fallback(locale)
        I18n.fallbacks[locale].each do |k|
          return @__instance__[k] if @__instance__.key?(k)
        end
        instance(locale)
      end

      attr_reader :plurals, :singulars, :uncountables, :humans, :acronyms

      attr_reader :acronyms_camelize_regex, :acronyms_underscore_regex # :nodoc:

      def initialize
        @plurals, @singulars, @uncountables, @humans, @acronyms = [], [], Uncountables.new, [], {}
        define_acronym_regex_patterns
      end

      # Private, for the test suite.
      def initialize_dup(orig) # :nodoc:
        %w(plurals singulars uncountables humans acronyms).each do |scope|
          instance_variable_set("@#{scope}", orig.public_send(scope).dup)
        end
        define_acronym_regex_patterns
      end

      # Specifies a new acronym. An acronym must be specified as it will appear
      # in a camelized string. An underscore string that contains the acronym
      # will retain the acronym when passed to +camelize+, +humanize+, or
      # +titleize+. A camelized string that contains the acronym will maintain
      # the acronym when titleized or humanized, and will convert the acronym
      # into a non-delimited single lowercase word when passed to +underscore+.
      #
      #   acronym 'HTML'
      #   titleize 'html'     # => 'HTML'
      #   camelize 'html'     # => 'HTML'
      #   underscore 'MyHTML' # => 'my_html'
      #
      # The acronym, however, must occur as a delimited unit and not be part of
      # another word for conversions to recognize it:
      #
      #   acronym 'HTTP'
      #   camelize 'my_http_delimited' # => 'MyHTTPDelimited'
      #   camelize 'https'             # => 'Https', not 'HTTPs'
      #   underscore 'HTTPS'           # => 'http_s', not 'https'
      #
      #   acronym 'HTTPS'
      #   camelize 'https'   # => 'HTTPS'
      #   underscore 'HTTPS' # => 'https'
      #
      # Note: Acronyms that are passed to +pluralize+ will no longer be
      # recognized, since the acronym will not occur as a delimited unit in the
      # pluralized result. To work around this, you must specify the pluralized
      # form as an acronym as well:
      #
      #    acronym 'API'
      #    camelize(pluralize('api')) # => 'Apis'
      #
      #    acronym 'APIs'
      #    camelize(pluralize('api')) # => 'APIs'
      #
      # +acronym+ may be used to specify any word that contains an acronym or
      # otherwise needs to maintain a non-standard capitalization. The only
      # restriction is that the word must begin with a capital letter.
      #
      #   acronym 'RESTful'
      #   underscore 'RESTful'           # => 'restful'
      #   underscore 'RESTfulController' # => 'restful_controller'
      #   titleize 'RESTfulController'   # => 'RESTful Controller'
      #   camelize 'restful'             # => 'RESTful'
      #   camelize 'restful_controller'  # => 'RESTfulController'
      #
      #   acronym 'McDonald'
      #   underscore 'McDonald' # => 'mcdonald'
      #   camelize 'mcdonald'   # => 'McDonald'
      def acronym(word)
        @acronyms[word.downcase] = word
        define_acronym_regex_patterns
      end

      # Specifies a new pluralization rule and its replacement. The rule can
      # either be a string or a regular expression. The replacement should
      # always be a string that may include references to the matched data from
      # the rule.
      def plural(rule, replacement)
        @uncountables.delete(rule) if rule.is_a?(String)
        @uncountables.delete(replacement)
        @plurals.prepend([rule, replacement])
      end

      # Specifies a new singularization rule and its replacement. The rule can
      # either be a string or a regular expression. The replacement should
      # always be a string that may include references to the matched data from
      # the rule.
      def singular(rule, replacement)
        @uncountables.delete(rule) if rule.is_a?(String)
        @uncountables.delete(replacement)
        @singulars.prepend([rule, replacement])
      end

      # Specifies a new irregular that applies to both pluralization and
      # singularization at the same time. This can only be used for strings, not
      # regular expressions. You simply pass the irregular in singular and
      # plural form.
      #
      #   irregular 'octopus', 'octopi'
      #   irregular 'person', 'people'
      def irregular(singular, plural)
        @uncountables.delete(singular)
        @uncountables.delete(plural)

        s0 = singular[0]
        srest = singular[1..-1]

        p0 = plural[0]
        prest = plural[1..-1]

        if s0.upcase == p0.upcase
          plural(/(#{s0})#{srest}$/i, '\1' + prest)
          plural(/(#{p0})#{prest}$/i, '\1' + prest)

          singular(/(#{s0})#{srest}$/i, '\1' + srest)
          singular(/(#{p0})#{prest}$/i, '\1' + srest)
        else
          plural(/#{s0.upcase}(?i)#{srest}$/,   p0.upcase   + prest)
          plural(/#{s0.downcase}(?i)#{srest}$/, p0.downcase + prest)
          plural(/#{p0.upcase}(?i)#{prest}$/,   p0.upcase   + prest)
          plural(/#{p0.downcase}(?i)#{prest}$/, p0.downcase + prest)

          singular(/#{s0.upcase}(?i)#{srest}$/,   s0.upcase   + srest)
          singular(/#{s0.downcase}(?i)#{srest}$/, s0.downcase + srest)
          singular(/#{p0.upcase}(?i)#{prest}$/,   s0.upcase   + srest)
          singular(/#{p0.downcase}(?i)#{prest}$/, s0.downcase + srest)
        end
      end

      # Specifies words that are uncountable and should not be inflected.
      #
      #   uncountable 'money'
      #   uncountable 'money', 'information'
      #   uncountable %w( money information rice )
      def uncountable(*words)
        @uncountables.add(words)
      end

      # Specifies a humanized form of a string by a regular expression rule or
      # by a string mapping. When using a regular expression based replacement,
      # the normal humanize formatting is called after the replacement. When a
      # string is used, the human form should be specified as desired (example:
      # 'The name', not 'the_name').
      #
      #   human /_cnt$/i, '\1_count'
      #   human 'legacy_col_person_name', 'Name'
      def human(rule, replacement)
        @humans.prepend([rule, replacement])
      end

      # Clears the loaded inflections within a given scope (default is
      # <tt>:all</tt>). Give the scope as a symbol of the inflection type, the
      # options are: <tt>:plurals</tt>, <tt>:singulars</tt>, <tt>:uncountables</tt>,
      # <tt>:humans</tt>.
      #
      #   clear :all
      #   clear :plurals
      def clear(scope = :all)
        case scope
        when :all
          @plurals, @singulars, @uncountables, @humans = [], [], Uncountables.new, []
        else
          instance_variable_set "@#{scope}", []
        end
      end

      private
        def define_acronym_regex_patterns
          @acronym_regex             = @acronyms.empty? ? /(?=a)b/ : /#{@acronyms.values.join("|")}/
          @acronyms_camelize_regex   = /^(?:#{@acronym_regex}(?=\b|[A-Z_])|\w)/
          @acronyms_underscore_regex = /(?:(?<=([A-Za-z\d]))|\b)(#{@acronym_regex})(?=\b|[^a-z])/
        end
    end

    # Yields a singleton instance of Inflector::Inflections so you can specify
    # additional inflector rules. If passed an optional locale, rules for other
    # languages can be specified. If not specified, defaults to <tt>:en</tt>.
    # Only rules for English are provided.
    #
    #   ActiveSupport::Inflector.inflections(:en) do |inflect|
    #     inflect.uncountable 'rails'
    #   end
    def inflections(locale = :en)
      if block_given?
        yield Inflections.instance(locale)
      else
        Inflections.instance_or_fallback(locale)
      end
    end
# frozen_string_literal: true

require "active_support/security_utils"
require "active_support/messages/rotator"

module ActiveSupport
  # The ActiveSupport::SecureCompareRotator is a wrapper around +ActiveSupport::SecurityUtils.secure_compare+
  # and allows you to rotate a previously defined value to a new one.
  #
  # It can be used as follow:
  #
  #   rotator = ActiveSupport::SecureCompareRotator.new('new_production_value')
  #   rotator.rotate('previous_production_value')
  #   rotator.secure_compare!('previous_production_value')
  #
  # One real use case example would be to rotate a basic auth credentials:
  #
  #   class MyController < ApplicationController
  #     def authenticate_request
  #       rotator = ActiveSupport::SecureComparerotator.new('new_password')
  #       rotator.rotate('old_password')
  #
  #       authenticate_or_request_with_http_basic do |username, password|
  #         rotator.secure_compare!(password)
  #       rescue ActiveSupport::SecureCompareRotator::InvalidMatch
  #         false
  #       end
  #     end
  #   end
  class SecureCompareRotator
    include SecurityUtils
    prepend Messages::Rotator

    InvalidMatch = Class.new(StandardError)

    def initialize(value, **_options)
      @value = value
    end

    def secure_compare!(other_value, on_rotation: @on_rotation)
      secure_compare(@value, other_value) ||
        run_rotations(on_rotation) { |wrapper| wrapper.secure_compare!(other_value) } ||
        raise(InvalidMatch)
    end

    private
      def build_rotation(previous_value, _options)
        self.class.new(previous_value)
      end
  end
# frozen_string_literal: true

require "active_support/execution_wrapper"

module ActiveSupport
# frozen_string_literal: true

module ActiveSupport
  # Returns the version of the currently loaded Active Support as a <tt>Gem::Version</tt>.
  def self.gem_version
    Gem::Version.new VERSION::STRING
  end

  module VERSION
    MAJOR = 7
    MINOR = 0
    TINY  = 0
    PRE   = "alpha"

    STRING = [MAJOR, MINOR, TINY, PRE].compact.join(".")
# frozen_string_literal: true

require "active_support/duration"
require "active_support/values/time_zone"
require "active_support/core_ext/object/acts_like"
require "active_support/core_ext/date_and_time/compatibility"

module ActiveSupport
  # A Time-like class that can represent a time in any time zone. Necessary
  # because standard Ruby Time instances are limited to UTC and the
  # system's <tt>ENV['TZ']</tt> zone.
  #
  # You shouldn't ever need to create a TimeWithZone instance directly via +new+.
  # Instead use methods +local+, +parse+, +at+ and +now+ on TimeZone instances,
  # and +in_time_zone+ on Time and DateTime instances.
  #
  #   Time.zone = 'Eastern Time (US & Canada)'        # => 'Eastern Time (US & Canada)'
  #   Time.zone.local(2007, 2, 10, 15, 30, 45)        # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
  #   Time.zone.parse('2007-02-10 15:30:45')          # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
  #   Time.zone.at(1171139445)                        # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
  #   Time.zone.now                                   # => Sun, 18 May 2008 13:07:55.754107581 EDT -04:00
  #   Time.utc(2007, 2, 10, 20, 30, 45).in_time_zone  # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
  #
  # See Time and TimeZone for further documentation of these methods.
  #
  # TimeWithZone instances implement the same API as Ruby Time instances, so
  # that Time and TimeWithZone instances are interchangeable.
  #
  #   t = Time.zone.now                     # => Sun, 18 May 2008 13:27:25.031505668 EDT -04:00
  #   t.hour                                # => 13
  #   t.dst?                                # => true
  #   t.utc_offset                          # => -14400
  #   t.zone                                # => "EDT"
  #   t.to_s(:rfc822)                       # => "Sun, 18 May 2008 13:27:25 -0400"
  #   t + 1.day                             # => Mon, 19 May 2008 13:27:25.031505668 EDT -04:00
  #   t.beginning_of_year                   # => Tue, 01 Jan 2008 00:00:00.000000000 EST -05:00
  #   t > Time.utc(1999)                    # => true
  #   t.is_a?(Time)                         # => true
  #   t.is_a?(ActiveSupport::TimeWithZone)  # => true
  class TimeWithZone
    # Report class name as 'Time' to thwart type checking.
    def self.name
      "Time"
    end

    PRECISIONS = Hash.new { |h, n| h[n] = "%FT%T.%#{n}N" }
    PRECISIONS[0] = "%FT%T"

    include Comparable, DateAndTime::Compatibility
    attr_reader :time_zone

    def initialize(utc_time, time_zone, local_time = nil, period = nil)
      @utc = utc_time ? transfer_time_values_to_utc_constructor(utc_time) : nil
      @time_zone, @time = time_zone, local_time
      @period = @utc ? period : get_period_and_ensure_valid_local_time(period)
    end

    # Returns a <tt>Time</tt> instance that represents the time in +time_zone+.
    def time
      @time ||= incorporate_utc_offset(@utc, utc_offset)
    end

    # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
    def utc
      @utc ||= incorporate_utc_offset(@time, -utc_offset)
    end
    alias_method :comparable_time, :utc
    alias_method :getgm, :utc
    alias_method :getutc, :utc
    alias_method :gmtime, :utc

    # Returns the underlying TZInfo::TimezonePeriod.
    def period
      @period ||= time_zone.period_for_utc(@utc)
    end

    # Returns the simultaneous time in <tt>Time.zone</tt>, or the specified zone.
    def in_time_zone(new_zone = ::Time.zone)
      return self if time_zone == new_zone
      utc.in_time_zone(new_zone)
    end

    # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
    def localtime(utc_offset = nil)
      utc.getlocal(utc_offset)
    end
    alias_method :getlocal, :localtime

    # Returns true if the current time is within Daylight Savings Time for the
    # specified time zone.
    #
    #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
    #   Time.zone.parse("2012-5-30").dst?           # => true
    #   Time.zone.parse("2012-11-30").dst?          # => false
    def dst?
      period.dst?
    end
    alias_method :isdst, :dst?

    # Returns true if the current time zone is set to UTC.
    #
    #   Time.zone = 'UTC'                           # => 'UTC'
    #   Time.zone.now.utc?                          # => true
    #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
    #   Time.zone.now.utc?                          # => false
    def utc?
      zone == "UTC" || zone == "UCT"
    end
    alias_method :gmt?, :utc?

    # Returns the offset from current time to UTC time in seconds.
    def utc_offset
      period.observed_utc_offset
    end
    alias_method :gmt_offset, :utc_offset
    alias_method :gmtoff, :utc_offset

    # Returns a formatted string of the offset from UTC, or an alternative
    # string if the time zone is already UTC.
    #
    #   Time.zone = 'Eastern Time (US & Canada)'   # => "Eastern Time (US & Canada)"
    #   Time.zone.now.formatted_offset(true)       # => "-05:00"
    #   Time.zone.now.formatted_offset(false)      # => "-0500"
    #   Time.zone = 'UTC'                          # => "UTC"
    #   Time.zone.now.formatted_offset(true, "0")  # => "0"
    def formatted_offset(colon = true, alternate_utc_string = nil)
      utc? && alternate_utc_string || TimeZone.seconds_to_utc_offset(utc_offset, colon)
    end

    # Returns the time zone abbreviation.
    #
    #   Time.zone = 'Eastern Time (US & Canada)'   # => "Eastern Time (US & Canada)"
    #   Time.zone.now.zone # => "EST"
    def zone
      period.abbreviation
    end

    # Returns a string of the object's date, time, zone, and offset from UTC.
    #
    #   Time.zone.now.inspect # => "Thu, 04 Dec 2014 11:00:25.624541392 EST -05:00"
    def inspect
      "#{time.strftime('%a, %d %b %Y %H:%M:%S.%9N')} #{zone} #{formatted_offset}"
    end

    # Returns a string of the object's date and time in the ISO 8601 standard
    # format.
    #
    #   Time.zone.now.xmlschema  # => "2014-12-04T11:02:37-05:00"
    def xmlschema(fraction_digits = 0)
      "#{time.strftime(PRECISIONS[fraction_digits.to_i])}#{formatted_offset(true, 'Z')}"
    end
    alias_method :iso8601, :xmlschema
    alias_method :rfc3339, :xmlschema

    # Coerces time to a string for JSON encoding. The default format is ISO 8601.
    # You can get %Y/%m/%d %H:%M:%S +offset style by setting
    # <tt>ActiveSupport::JSON::Encoding.use_standard_json_time_format</tt>
    # to +false+.
    #
    #   # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = true
    #   Time.utc(2005,2,1,15,15,10).in_time_zone("Hawaii").to_json
    #   # => "2005-02-01T05:15:10.000-10:00"
    #
    #   # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = false
    #   Time.utc(2005,2,1,15,15,10).in_time_zone("Hawaii").to_json
    #   # => "2005/02/01 05:15:10 -1000"
    def as_json(options = nil)
      if ActiveSupport::JSON::Encoding.use_standard_json_time_format
        xmlschema(ActiveSupport::JSON::Encoding.time_precision)
      else
        %(#{time.strftime("%Y/%m/%d %H:%M:%S")} #{formatted_offset(false)})
      end
    end

    def init_with(coder) #:nodoc:
      initialize(coder["utc"], coder["zone"], coder["time"])
    end

    def encode_with(coder) #:nodoc:
      coder.tag = "!ruby/object:ActiveSupport::TimeWithZone"
      coder.map = { "utc" => utc, "zone" => time_zone, "time" => time }
    end

    # Returns a string of the object's date and time in the format used by
    # HTTP requests.
    #
    #   Time.zone.now.httpdate  # => "Tue, 01 Jan 2013 04:39:43 GMT"
    def httpdate
      utc.httpdate
    end

    # Returns a string of the object's date and time in the RFC 2822 standard
    # format.
    #
    #   Time.zone.now.rfc2822  # => "Tue, 01 Jan 2013 04:51:39 +0000"
    def rfc2822
      to_s(:rfc822)
    end
    alias_method :rfc822, :rfc2822

    # Returns a string of the object's date and time.
    # Accepts an optional <tt>format</tt>:
    # * <tt>:default</tt> - default value, mimics Ruby Time#to_s format.
    # * <tt>:db</tt> - format outputs time in UTC :db time. See Time#to_formatted_s(:db).
    # * Any key in <tt>Time::DATE_FORMATS</tt> can be used. See active_support/core_ext/time/conversions.rb.
    def to_s(format = :default)
      if format == :db
        utc.to_s(format)
      elsif formatter = ::Time::DATE_FORMATS[format]
        formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)
      else
        "#{time.strftime("%Y-%m-%d %H:%M:%S")} #{formatted_offset(false, 'UTC')}" # mimicking Ruby Time#to_s format
      end
    end
    alias_method :to_formatted_s, :to_s

    # Replaces <tt>%Z</tt> directive with +zone before passing to Time#strftime,
    # so that zone information is correct.
    def strftime(format)
      format = format.gsub(/((?:\A|[^%])(?:%%)*)%Z/, "\\1#{zone}")
      getlocal(utc_offset).strftime(format)
    end

    # Use the time in UTC for comparisons.
    def <=>(other)
      utc <=> other
    end
    alias_method :before?, :<
    alias_method :after?, :>

    # Returns true if the current object's time is within the specified
    # +min+ and +max+ time.
    def between?(min, max)
      utc.between?(min, max)
    end

    # Returns true if the current object's time is in the past.
    def past?
      utc.past?
    end

    # Returns true if the current object's time falls within
    # the current day.
    def today?
      time.today?
    end

    # Returns true if the current object's time falls within
    # the next day (tomorrow).
    def tomorrow?
      time.tomorrow?
    end
    alias :next_day? :tomorrow?

    # Returns true if the current object's time falls within
    # the previous day (yesterday).
    def yesterday?
      time.yesterday?
    end
    alias :prev_day? :yesterday?

    # Returns true if the current object's time is in the future.
    def future?
      utc.future?
    end

    # Returns +true+ if +other+ is equal to current object.
    def eql?(other)
      other.eql?(utc)
    end

    def hash
      utc.hash
    end

    # Adds an interval of time to the current object's time and returns that
    # value as a new TimeWithZone object.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
    #   now + 1000          # => Sun, 02 Nov 2014 01:43:08.725182881 EDT -04:00
    #
    # If we're adding a Duration of variable length (i.e., years, months, days),
    # move forward from #time, otherwise move forward from #utc, for accuracy
    # when moving across DST boundaries.
    #
    # For instance, a time + 24.hours will advance exactly 24 hours, while a
    # time + 1.day will advance 23-25 hours, depending on the day.
    #
    #   now + 24.hours      # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
    #   now + 1.day         # => Mon, 03 Nov 2014 01:26:28.725182881 EST -05:00
    def +(other)
      if duration_of_variable_length?(other)
        method_missing(:+, other)
      else
        result = utc.acts_like?(:date) ? utc.since(other) : utc + other rescue utc.since(other)
        result.in_time_zone(time_zone)
      end
    end
    alias_method :since, :+
    alias_method :in, :+

    # Subtracts an interval of time and returns a new TimeWithZone object unless
    # the other value +acts_like?+ time. Then it will return a Float of the difference
    # between the two times that represents the difference between the current
    # object's time and the +other+ time.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
    #   now - 1000          # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00
    #
    # If subtracting a Duration of variable length (i.e., years, months, days),
    # move backward from #time, otherwise move backward from #utc, for accuracy
    # when moving across DST boundaries.
    #
    # For instance, a time - 24.hours will go subtract exactly 24 hours, while a
    # time - 1.day will subtract 23-25 hours, depending on the day.
    #
    #   now - 24.hours      # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
    #   now - 1.day         # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00
    #
    # If both the TimeWithZone object and the other value act like Time, a Float
    # will be returned.
    #
    #   Time.zone.now - 1.day.ago # => 86399.999967
    #
    def -(other)
      if other.acts_like?(:time)
        to_time - other.to_time
      elsif duration_of_variable_length?(other)
        method_missing(:-, other)
      else
        result = utc.acts_like?(:date) ? utc.ago(other) : utc - other rescue utc.ago(other)
        result.in_time_zone(time_zone)
      end
    end

    # Subtracts an interval of time from the current object's time and returns
    # the result as a new TimeWithZone object.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
    #   now.ago(1000)       # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00
    #
    # If we're subtracting a Duration of variable length (i.e., years, months,
    # days), move backward from #time, otherwise move backward from #utc, for
    # accuracy when moving across DST boundaries.
    #
    # For instance, <tt>time.ago(24.hours)</tt> will move back exactly 24 hours,
    # while <tt>time.ago(1.day)</tt> will move back 23-25 hours, depending on
    # the day.
    #
    #   now.ago(24.hours)   # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
    #   now.ago(1.day)      # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00
    def ago(other)
      since(-other)
    end

    # Returns a new +ActiveSupport::TimeWithZone+ where one or more of the elements have
    # been changed according to the +options+ parameter. The time options (<tt>:hour</tt>,
    # <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly,
    # so if only the hour is passed, then minute, sec, usec and nsec is set to 0. If the
    # hour and minute is passed, then sec, usec and nsec is set to 0. The +options+
    # parameter takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>,
    # <tt>:day</tt>, <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>,
    # <tt>:nsec</tt>, <tt>:offset</tt>, <tt>:zone</tt>. Pass either <tt>:usec</tt>
    # or <tt>:nsec</tt>, not both. Similarly, pass either <tt>:zone</tt> or
    # <tt>:offset</tt>, not both.
    #
    #   t = Time.zone.now          # => Fri, 14 Apr 2017 11:45:15.116992711 EST -05:00
    #   t.change(year: 2020)       # => Tue, 14 Apr 2020 11:45:15.116992711 EST -05:00
    #   t.change(hour: 12)         # => Fri, 14 Apr 2017 12:00:00.116992711 EST -05:00
    #   t.change(min: 30)          # => Fri, 14 Apr 2017 11:30:00.116992711 EST -05:00
    #   t.change(offset: "-10:00") # => Fri, 14 Apr 2017 11:45:15.116992711 HST -10:00
    #   t.change(zone: "Hawaii")   # => Fri, 14 Apr 2017 11:45:15.116992711 HST -10:00
    def change(options)
      if options[:zone] && options[:offset]
        raise ArgumentError, "Can't change both :offset and :zone at the same time: #{options.inspect}"
      end

      new_time = time.change(options)

      if options[:zone]
        new_zone = ::Time.find_zone(options[:zone])
      elsif options[:offset]
        new_zone = ::Time.find_zone(new_time.utc_offset)
      end

      new_zone ||= time_zone
      periods = new_zone.periods_for_local(new_time)

      self.class.new(nil, new_zone, new_time, periods.include?(period) ? period : nil)
    end

    # Uses Date to provide precise Time calculations for years, months, and days
    # according to the proleptic Gregorian calendar. The result is returned as a
    # new TimeWithZone object.
    #
    # The +options+ parameter takes a hash with any of these keys:
    # <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>,
    # <tt>:hours</tt>, <tt>:minutes</tt>, <tt>:seconds</tt>.
    #
    # If advancing by a value of variable length (i.e., years, weeks, months,
    # days), move forward from #time, otherwise move forward from #utc, for
    # accuracy when moving across DST boundaries.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.558049687 EDT -04:00
    #   now.advance(seconds: 1) # => Sun, 02 Nov 2014 01:26:29.558049687 EDT -04:00
    #   now.advance(minutes: 1) # => Sun, 02 Nov 2014 01:27:28.558049687 EDT -04:00
    #   now.advance(hours: 1)   # => Sun, 02 Nov 2014 01:26:28.558049687 EST -05:00
    #   now.advance(days: 1)    # => Mon, 03 Nov 2014 01:26:28.558049687 EST -05:00
    #   now.advance(weeks: 1)   # => Sun, 09 Nov 2014 01:26:28.558049687 EST -05:00
    #   now.advance(months: 1)  # => Tue, 02 Dec 2014 01:26:28.558049687 EST -05:00
    #   now.advance(years: 1)   # => Mon, 02 Nov 2015 01:26:28.558049687 EST -05:00
    def advance(options)
      # If we're advancing a value of variable length (i.e., years, weeks, months, days), advance from #time,
      # otherwise advance from #utc, for accuracy when moving across DST boundaries
      if options.values_at(:years, :weeks, :months, :days).any?
        method_missing(:advance, options)
      else
        utc.advance(options).in_time_zone(time_zone)
      end
    end

    %w(year mon month day mday wday yday hour min sec usec nsec to_date).each do |method_name|
      class_eval <<-EOV, __FILE__, __LINE__ + 1
        def #{method_name}    # def month
          time.#{method_name} #   time.month
        end                   # end
      EOV
    end

    # Returns Array of parts of Time in sequence of
    # [seconds, minutes, hours, day, month, year, weekday, yearday, dst?, zone].
    #
    #   now = Time.zone.now     # => Tue, 18 Aug 2015 02:29:27.485278555 UTC +00:00
    #   now.to_a                # => [27, 29, 2, 18, 8, 2015, 2, 230, false, "UTC"]
    def to_a
      [time.sec, time.min, time.hour, time.day, time.mon, time.year, time.wday, time.yday, dst?, zone]
    end

    # Returns the object's date and time as a floating point number of seconds
    # since the Epoch (January 1, 1970 00:00 UTC).
    #
    #   Time.zone.now.to_f # => 1417709320.285418
    def to_f
      utc.to_f
    end

    # Returns the object's date and time as an integer number of seconds
    # since the Epoch (January 1, 1970 00:00 UTC).
    #
    #   Time.zone.now.to_i # => 1417709320
    def to_i
      utc.to_i
    end
    alias_method :tv_sec, :to_i

    # Returns the object's date and time as a rational number of seconds
    # since the Epoch (January 1, 1970 00:00 UTC).
    #
    #   Time.zone.now.to_r # => (708854548642709/500000)
    def to_r
      utc.to_r
    end

    # Returns an instance of DateTime with the timezone's UTC offset
    #
    #   Time.zone.now.to_datetime                         # => Tue, 18 Aug 2015 02:32:20 +0000
    #   Time.current.in_time_zone('Hawaii').to_datetime   # => Mon, 17 Aug 2015 16:32:20 -1000
    def to_datetime
      @to_datetime ||= utc.to_datetime.new_offset(Rational(utc_offset, 86_400))
    end

    # Returns an instance of +Time+, either with the same UTC offset
    # as +self+ or in the local system timezone depending on the setting
    # of +ActiveSupport.to_time_preserves_timezone+.
    def to_time
      if preserve_timezone
        @to_time_with_instance_offset ||= getlocal(utc_offset)
      else
        @to_time_with_system_offset ||= getlocal
      end
    end

    # So that +self+ <tt>acts_like?(:time)</tt>.
    def acts_like_time?
      true
    end

    # Say we're a Time to thwart type checking.
    def is_a?(klass)
      klass == ::Time || super
    end
    alias_method :kind_of?, :is_a?

    # An instance of ActiveSupport::TimeWithZone is never blank
    def blank?
      false
    end

    def freeze
      # preload instance variables before freezing
      period; utc; time; to_datetime; to_time
      super
    end

    def marshal_dump
      [utc, time_zone.name, time]
    end

    def marshal_load(variables)
      initialize(variables[0].utc, ::Time.find_zone(variables[1]), variables[2].utc)
    end

    # respond_to_missing? is not called in some cases, such as when type conversion is
    # performed with Kernel#String
    def respond_to?(sym, include_priv = false)
      # ensure that we're not going to throw and rescue from NoMethodError in method_missing which is slow
      return false if sym.to_sym == :to_str
      super
    end

    # Ensure proxy class responds to all methods that underlying time instance
    # responds to.
    def respond_to_missing?(sym, include_priv)
      return false if sym.to_sym == :acts_like_date?
      time.respond_to?(sym, include_priv)
    end

    # Send the missing method to +time+ instance, and wrap result in a new
    # TimeWithZone with the existing +time_zone+.
    def method_missing(sym, *args, &block)
      wrap_with_time_zone time.__send__(sym, *args, &block)
    rescue NoMethodError => e
      raise e, e.message.sub(time.inspect, inspect), e.backtrace
    end

    private
      SECONDS_PER_DAY = 86400

      def incorporate_utc_offset(time, offset)
        if time.kind_of?(Date)
          time + Rational(offset, SECONDS_PER_DAY)
        else
          time + offset
        end
      end

      def get_period_and_ensure_valid_local_time(period)
        # we don't want a Time.local instance enforcing its own DST rules as well,
        # so transfer time values to a utc constructor if necessary
        @time = transfer_time_values_to_utc_constructor(@time) unless @time.utc?
        begin
          period || @time_zone.period_for_local(@time)
        rescue ::TZInfo::PeriodNotFound
          # time is in the "spring forward" hour gap, so we're moving the time forward one hour and trying again
          @time += 1.hour
          retry
        end
      end

      def transfer_time_values_to_utc_constructor(time)
        # avoid creating another Time object if possible
        return time if time.instance_of?(::Time) && time.utc?
        ::Time.utc(time.year, time.month, time.day, time.hour, time.min, time.sec + time.subsec)
      end

      def duration_of_variable_length?(obj)
        ActiveSupport::Duration === obj && obj.parts.any? { |p| [:years, :months, :weeks, :days].include?(p[0]) }
      end

      def wrap_with_time_zone(time)
        if time.acts_like?(:time)
          periods = time_zone.periods_for_local(time)
          self.class.new(nil, time_zone, time, periods.include?(period) ? period : nil)
        elsif time.is_a?(Range)
          wrap_with_time_zone(time.begin)..wrap_with_time_zone(time.end)
        else
# frozen_string_literal: true

require "mutex_m"
require "concurrent/map"
require "set"
require "active_support/core_ext/object/try"

module ActiveSupport
  module Notifications
    # This is a default queue implementation that ships with Notifications.
    # It just pushes events to all registered log subscribers.
    #
    # This class is thread safe. All methods are reentrant.
    class Fanout
      include Mutex_m

      def initialize
        @string_subscribers = Hash.new { |h, k| h[k] = [] }
        @other_subscribers = []
        @listeners_for = Concurrent::Map.new
        super
      end

      def subscribe(pattern = nil, callable = nil, monotonic: false, &block)
        subscriber = Subscribers.new(pattern, callable || block, monotonic)
        synchronize do
          case pattern
          when String
            @string_subscribers[pattern] << subscriber
            @listeners_for.delete(pattern)
          when NilClass, Regexp
            @other_subscribers << subscriber
            @listeners_for.clear
          else
            raise ArgumentError,  "pattern must be specified as a String, Regexp or empty"
          end
        end
        subscriber
      end

      def unsubscribe(subscriber_or_name)
        synchronize do
          case subscriber_or_name
          when String
            @string_subscribers[subscriber_or_name].clear
            @listeners_for.delete(subscriber_or_name)
            @other_subscribers.each { |sub| sub.unsubscribe!(subscriber_or_name) }
          else
            pattern = subscriber_or_name.try(:pattern)
            if String === pattern
              @string_subscribers[pattern].delete(subscriber_or_name)
              @listeners_for.delete(pattern)
            else
              @other_subscribers.delete(subscriber_or_name)
              @listeners_for.clear
            end
          end
        end
      end

      def start(name, id, payload)
        listeners_for(name).each { |s| s.start(name, id, payload) }
      end

      def finish(name, id, payload, listeners = listeners_for(name))
        listeners.each { |s| s.finish(name, id, payload) }
      end

      def publish(name, *args)
        listeners_for(name).each { |s| s.publish(name, *args) }
      end

      def listeners_for(name)
        # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
        @listeners_for[name] || synchronize do
          # use synchronisation when accessing @subscribers
          @listeners_for[name] ||=
            @string_subscribers[name] + @other_subscribers.select { |s| s.subscribed_to?(name) }
        end
      end

      def listening?(name)
        listeners_for(name).any?
      end

      # This is a sync queue, so there is no waiting.
      def wait
      end

      module Subscribers # :nodoc:
        def self.new(pattern, listener, monotonic)
          subscriber_class = monotonic ? MonotonicTimed : Timed

          if listener.respond_to?(:start) && listener.respond_to?(:finish)
            subscriber_class = Evented
          else
            # Doing this to detect a single argument block or callable
            # like `proc { |x| }` vs `proc { |*x| }`, `proc { |**x| }`,
            # or `proc { |x, **y| }`
            procish = listener.respond_to?(:parameters) ? listener : listener.method(:call)

            if procish.arity == 1 && procish.parameters.length == 1
              subscriber_class = EventObject
            end
          end

          wrap_all pattern, subscriber_class.new(pattern, listener)
        end

        def self.wrap_all(pattern, subscriber)
          unless pattern
            AllMessages.new(subscriber)
          else
            subscriber
          end
        end

        class Matcher #:nodoc:
          attr_reader :pattern, :exclusions

          def self.wrap(pattern)
            return pattern if String === pattern
            new(pattern)
          end

          def initialize(pattern)
            @pattern = pattern
            @exclusions = Set.new
          end

          def unsubscribe!(name)
            exclusions << -name if pattern === name
          end

          def ===(name)
            pattern === name && !exclusions.include?(name)
          end
        end

        class Evented #:nodoc:
          attr_reader :pattern

          def initialize(pattern, delegate)
            @pattern = Matcher.wrap(pattern)
            @delegate = delegate
            @can_publish = delegate.respond_to?(:publish)
          end

          def publish(name, *args)
            if @can_publish
              @delegate.publish name, *args
            end
          end

          def start(name, id, payload)
            @delegate.start name, id, payload
          end

          def finish(name, id, payload)
            @delegate.finish name, id, payload
          end

          def subscribed_to?(name)
            pattern === name
          end

          def matches?(name)
            pattern && pattern === name
          end

          def unsubscribe!(name)
            pattern.unsubscribe!(name)
          end
        end

        class Timed < Evented # :nodoc:
          def publish(name, *args)
            @delegate.call name, *args
          end

          def start(name, id, payload)
            timestack = Thread.current[:_timestack] ||= []
            timestack.push Time.now
          end

          def finish(name, id, payload)
            timestack = Thread.current[:_timestack]
            started = timestack.pop
            @delegate.call(name, started, Time.now, id, payload)
          end
        end

        class MonotonicTimed < Evented # :nodoc:
          def publish(name, *args)
            @delegate.call name, *args
          end

          def start(name, id, payload)
            timestack = Thread.current[:_timestack_monotonic] ||= []
            timestack.push Concurrent.monotonic_time
          end

          def finish(name, id, payload)
            timestack = Thread.current[:_timestack_monotonic]
            started = timestack.pop
            @delegate.call(name, started, Concurrent.monotonic_time, id, payload)
          end
        end

        class EventObject < Evented
          def start(name, id, payload)
            stack = Thread.current[:_event_stack] ||= []
            event = build_event name, id, payload
            event.start!
            stack.push event
          end

          def finish(name, id, payload)
            stack = Thread.current[:_event_stack]
            event = stack.pop
            event.payload = payload
            event.finish!
            @delegate.call event
          end

          private
            def build_event(name, id, payload)
              ActiveSupport::Notifications::Event.new name, nil, nil, id, payload
            end
        end

        class AllMessages # :nodoc:
          def initialize(delegate)
            @delegate = delegate
          end

          def start(name, id, payload)
            @delegate.start name, id, payload
          end

          def finish(name, id, payload)
            @delegate.finish name, id, payload
          end

          def publish(name, *args)
            @delegate.publish name, *args
          end

          def subscribed_to?(name)
            true
          end

          def unsubscribe!(*)
            false
          end

          alias :matches? :===
        end
      end
    end
# frozen_string_literal: true

require "securerandom"

module ActiveSupport
  module Notifications
    # Instrumenters are stored in a thread local.
    class Instrumenter
      attr_reader :id

      def initialize(notifier)
        @id       = unique_id
        @notifier = notifier
      end

      # Given a block, instrument it by measuring the time taken to execute
      # and publish it. Without a block, simply send a message via the
      # notifier. Notice that events get sent even if an error occurs in the
      # passed-in block.
      def instrument(name, payload = {})
        # some of the listeners might have state
        listeners_state = start name, payload
        begin
          yield payload if block_given?
        rescue Exception => e
          payload[:exception] = [e.class.name, e.message]
          payload[:exception_object] = e
          raise e
        ensure
          finish_with_state listeners_state, name, payload
        end
      end

      # Send a start notification with +name+ and +payload+.
      def start(name, payload)
        @notifier.start name, @id, payload
      end

      # Send a finish notification with +name+ and +payload+.
      def finish(name, payload)
        @notifier.finish name, @id, payload
      end

      def finish_with_state(listeners_state, name, payload)
        @notifier.finish name, @id, payload, listeners_state
      end

      private
        def unique_id
          SecureRandom.hex(10)
        end
    end

    class Event
      attr_reader :name, :time, :end, :transaction_id, :children
      attr_accessor :payload

      def initialize(name, start, ending, transaction_id, payload)
        @name           = name
        @payload        = payload.dup
        @time           = start
        @transaction_id = transaction_id
        @end            = ending
        @children       = []
        @cpu_time_start = 0
        @cpu_time_finish = 0
        @allocation_count_start = 0
        @allocation_count_finish = 0
      end

      # Record information at the time this event starts
      def start!
        @time = now
        @cpu_time_start = now_cpu
        @allocation_count_start = now_allocations
      end

      # Record information at the time this event finishes
      def finish!
        @cpu_time_finish = now_cpu
        @end = now
        @allocation_count_finish = now_allocations
      end

      # Returns the CPU time (in milliseconds) passed since the call to
      # +start!+ and the call to +finish!+
      def cpu_time
        (@cpu_time_finish - @cpu_time_start) * 1000
      end

      # Returns the idle time time (in milliseconds) passed since the call to
      # +start!+ and the call to +finish!+
      def idle_time
        duration - cpu_time
      end

      # Returns the number of allocations made since the call to +start!+ and
      # the call to +finish!+
      def allocations
        @allocation_count_finish - @allocation_count_start
      end

      # Returns the difference in milliseconds between when the execution of the
      # event started and when it ended.
      #
      #   ActiveSupport::Notifications.subscribe('wait') do |*args|
      #     @event = ActiveSupport::Notifications::Event.new(*args)
      #   end
      #
      #   ActiveSupport::Notifications.instrument('wait') do
      #     sleep 1
      #   end
      #
      #   @event.duration # => 1000.138
      def duration
        1000.0 * (self.end - time)
      end

      def <<(event)
        @children << event
      end

      def parent_of?(event)
        @children.include? event
      end

      private
        def now
          Concurrent.monotonic_time
        end

        begin
          Process.clock_gettime(Process::CLOCK_THREAD_CPUTIME_ID)

          def now_cpu
            Process.clock_gettime(Process::CLOCK_THREAD_CPUTIME_ID)
          end
        rescue
          def now_cpu
            0
          end
        end

        if defined?(JRUBY_VERSION)
          def now_allocations
            0
          end
        else
          def now_allocations
            GC.stat :total_allocated_objects
# frozen_string_literal: true

{
  en: {
    number: {
      nth: {
        ordinals: lambda do |_key, options|
          number = options[:number]
          case number
          when 1; "st"
          when 2; "nd"
          when 3; "rd"
          when 4, 5, 6, 7, 8, 9, 10, 11, 12, 13; "th"
          else
            num_modulo = number.to_i.abs % 100
            num_modulo %= 10 if num_modulo > 13
            case num_modulo
            when 1; "st"
            when 2; "nd"
            when 3; "rd"
            else    "th"
            end
          end
        end,

        ordinalized: lambda do |_key, options|
          number = options[:number]
          "#{number}#{ActiveSupport::Inflector.ordinal(number)}"
        end
      }
# frozen_string_literal: true

require "active_support/core_ext/hash/deep_merge"

module ActiveSupport
  class OptionMerger #:nodoc:
    instance_methods.each do |method|
      undef_method(method) unless method.start_with?("__", "instance_eval", "class", "object_id")
    end

    def initialize(context, options)
      @context, @options = context, options
    end

    private
      def method_missing(method, *arguments, &block)
        options = nil
        if arguments.first.is_a?(Proc)
          proc = arguments.pop
          arguments << lambda { |*args| @options.deep_merge(proc.call(*args)) }
        elsif arguments.last.respond_to?(:to_hash)
          options = @options.deep_merge(arguments.pop)
        else
          options = @options
        end

        if options
          @context.__send__(method, *arguments, **options, &block)
        else
          @context.__send__(method, *arguments, &block)
# frozen_string_literal: true

require "active_support/inflector/inflections"

#--
# Defines the standard inflection rules. These are the starting point for
# new projects and are not considered complete. The current set of inflection
# rules is frozen. This means, we do not change them to become more complete.
# This is a safety measure to keep existing applications from breaking.
#++
module ActiveSupport
  Inflector.inflections(:en) do |inflect|
    inflect.plural(/$/, "s")
    inflect.plural(/s$/i, "s")
    inflect.plural(/^(ax|test)is$/i, '\1es')
    inflect.plural(/(octop|vir)us$/i, '\1i')
    inflect.plural(/(octop|vir)i$/i, '\1i')
    inflect.plural(/(alias|status)$/i, '\1es')
    inflect.plural(/(bu)s$/i, '\1ses')
    inflect.plural(/(buffal|tomat)o$/i, '\1oes')
    inflect.plural(/([ti])um$/i, '\1a')
    inflect.plural(/([ti])a$/i, '\1a')
    inflect.plural(/sis$/i, "ses")
    inflect.plural(/(?:([^f])fe|([lr])f)$/i, '\1\2ves')
    inflect.plural(/(hive)$/i, '\1s')
    inflect.plural(/([^aeiouy]|qu)y$/i, '\1ies')
    inflect.plural(/(x|ch|ss|sh)$/i, '\1es')
    inflect.plural(/(matr|vert|ind)(?:ix|ex)$/i, '\1ices')
    inflect.plural(/^(m|l)ouse$/i, '\1ice')
    inflect.plural(/^(m|l)ice$/i, '\1ice')
    inflect.plural(/^(ox)$/i, '\1en')
    inflect.plural(/^(oxen)$/i, '\1')
    inflect.plural(/(quiz)$/i, '\1zes')

    inflect.singular(/s$/i, "")
    inflect.singular(/(ss)$/i, '\1')
    inflect.singular(/(n)ews$/i, '\1ews')
    inflect.singular(/([ti])a$/i, '\1um')
    inflect.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i, '\1sis')
    inflect.singular(/(^analy)(sis|ses)$/i, '\1sis')
    inflect.singular(/([^f])ves$/i, '\1fe')
    inflect.singular(/(hive)s$/i, '\1')
    inflect.singular(/(tive)s$/i, '\1')
    inflect.singular(/([lr])ves$/i, '\1f')
    inflect.singular(/([^aeiouy]|qu)ies$/i, '\1y')
    inflect.singular(/(s)eries$/i, '\1eries')
    inflect.singular(/(m)ovies$/i, '\1ovie')
    inflect.singular(/(x|ch|ss|sh)es$/i, '\1')
    inflect.singular(/^(m|l)ice$/i, '\1ouse')
    inflect.singular(/(bus)(es)?$/i, '\1')
    inflect.singular(/(o)es$/i, '\1')
    inflect.singular(/(shoe)s$/i, '\1')
    inflect.singular(/(cris|test)(is|es)$/i, '\1is')
    inflect.singular(/^(a)x[ie]s$/i, '\1xis')
    inflect.singular(/(octop|vir)(us|i)$/i, '\1us')
    inflect.singular(/(alias|status)(es)?$/i, '\1')
    inflect.singular(/^(ox)en/i, '\1')
    inflect.singular(/(vert|ind)ices$/i, '\1ex')
    inflect.singular(/(matr)ices$/i, '\1ix')
    inflect.singular(/(quiz)zes$/i, '\1')
    inflect.singular(/(database)s$/i, '\1')

    inflect.irregular("person", "people")
    inflect.irregular("man", "men")
    inflect.irregular("child", "children")
    inflect.irregular("sex", "sexes")
    inflect.irregular("move", "moves")
    inflect.irregular("zombie", "zombies")

    inflect.uncountable(%w(equipment information rice money species series fish sheep jeans police))
# frozen_string_literal: true

require "active_support/core_ext/module/delegation"
require "active_support/core_ext/object/blank"
require "logger"
require "active_support/logger"

module ActiveSupport
  # Wraps any standard Logger object to provide tagging capabilities.
  #
  # May be called with a block:
  #
  #   logger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
  #   logger.tagged('BCX') { logger.info 'Stuff' }                            # Logs "[BCX] Stuff"
  #   logger.tagged('BCX', "Jason") { logger.info 'Stuff' }                   # Logs "[BCX] [Jason] Stuff"
  #   logger.tagged('BCX') { logger.tagged('Jason') { logger.info 'Stuff' } } # Logs "[BCX] [Jason] Stuff"
  #
  # If called without a block, a new logger will be returned with applied tags:
  #
  #   logger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
  #   logger.tagged("BCX").info "Stuff"                 # Logs "[BCX] Stuff"
  #   logger.tagged("BCX", "Jason").info "Stuff"        # Logs "[BCX] [Jason] Stuff"
  #   logger.tagged("BCX").tagged("Jason").info "Stuff" # Logs "[BCX] [Jason] Stuff"
  #
  # This is used by the default Rails.logger as configured by Railties to make
  # it easy to stamp log lines with subdomains, request ids, and anything else
  # to aid debugging of multi-user production applications.
  module TaggedLogging
    module Formatter # :nodoc:
      # This method is invoked when a log event occurs.
      def call(severity, timestamp, progname, msg)
        super(severity, timestamp, progname, "#{tags_text}#{msg}")
      end

      def tagged(*tags)
        new_tags = push_tags(*tags)
        yield self
      ensure
        pop_tags(new_tags.size)
      end

      def push_tags(*tags)
        tags.flatten!
        tags.reject!(&:blank?)
        current_tags.concat tags
        tags
      end

      def pop_tags(size = 1)
        current_tags.pop size
      end

      def clear_tags!
        current_tags.clear
      end

      def current_tags
        # We use our object ID here to avoid conflicting with other instances
        thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}"
        Thread.current[thread_key] ||= []
      end

      def tags_text
        tags = current_tags
        if tags.one?
          "[#{tags[0]}] "
        elsif tags.any?
          tags.collect { |tag| "[#{tag}] " }.join
        end
      end
    end

    module LocalTagStorage # :nodoc:
      attr_accessor :current_tags

      def self.extended(base)
        base.current_tags = []
      end
    end

    def self.new(logger)
      logger = logger.clone

      if logger.formatter
        logger.formatter = logger.formatter.dup
      else
        # Ensure we set a default formatter so we aren't extending nil!
        logger.formatter = ActiveSupport::Logger::SimpleFormatter.new
      end

      logger.formatter.extend Formatter
      logger.extend(self)
    end

    delegate :push_tags, :pop_tags, :clear_tags!, to: :formatter

    def tagged(*tags)
      if block_given?
        formatter.tagged(*tags) { yield self }
      else
        logger = ActiveSupport::TaggedLogging.new(self)
        logger.formatter.extend LocalTagStorage
        logger.push_tags(*formatter.current_tags, *tags)
        logger
      end
    end

    def flush
      clear_tags!
      super if defined?(super)
# frozen_string_literal: true

require "active_support/core_ext/array/conversions"
require "active_support/core_ext/module/delegation"
require "active_support/core_ext/object/acts_like"
require "active_support/core_ext/string/filters"

module ActiveSupport
  # Provides accurate date and time measurements using Date#advance and
  # Time#advance, respectively. It mainly supports the methods on Numeric.
  #
  #   1.month.ago       # equivalent to Time.now.advance(months: -1)
  class Duration
    class Scalar < Numeric #:nodoc:
      attr_reader :value
      delegate :to_i, :to_f, :to_s, to: :value

      def initialize(value)
        @value = value
      end

      def coerce(other)
        [Scalar.new(other), self]
      end

      def -@
        Scalar.new(-value)
      end

      def <=>(other)
        if Scalar === other || Duration === other
          value <=> other.value
        elsif Numeric === other
          value <=> other
        else
          nil
        end
      end

      def +(other)
        if Duration === other
          seconds   = value + other.parts.fetch(:seconds, 0)
          new_parts = other.parts.merge(seconds: seconds)
          new_value = value + other.value

          Duration.new(new_value, new_parts)
        else
          calculate(:+, other)
        end
      end

      def -(other)
        if Duration === other
          seconds   = value - other.parts.fetch(:seconds, 0)
          new_parts = other.parts.transform_values(&:-@)
          new_parts = new_parts.merge(seconds: seconds)
          new_value = value - other.value

          Duration.new(new_value, new_parts)
        else
          calculate(:-, other)
        end
      end

      def *(other)
        if Duration === other
          new_parts = other.parts.transform_values { |other_value| value * other_value }
          new_value = value * other.value

          Duration.new(new_value, new_parts)
        else
          calculate(:*, other)
        end
      end

      def /(other)
        if Duration === other
          value / other.value
        else
          calculate(:/, other)
        end
      end

      def %(other)
        if Duration === other
          Duration.build(value % other.value)
        else
          calculate(:%, other)
        end
      end

      private
        def calculate(op, other)
          if Scalar === other
            Scalar.new(value.public_send(op, other.value))
          elsif Numeric === other
            Scalar.new(value.public_send(op, other))
          else
            raise_type_error(other)
          end
        end

        def raise_type_error(other)
          raise TypeError, "no implicit conversion of #{other.class} into #{self.class}"
        end
    end

    SECONDS_PER_MINUTE = 60
    SECONDS_PER_HOUR   = 3600
    SECONDS_PER_DAY    = 86400
    SECONDS_PER_WEEK   = 604800
    SECONDS_PER_MONTH  = 2629746  # 1/12 of a gregorian year
    SECONDS_PER_YEAR   = 31556952 # length of a gregorian year (365.2425 days)

    PARTS_IN_SECONDS = {
      seconds: 1,
      minutes: SECONDS_PER_MINUTE,
      hours:   SECONDS_PER_HOUR,
      days:    SECONDS_PER_DAY,
      weeks:   SECONDS_PER_WEEK,
      months:  SECONDS_PER_MONTH,
      years:   SECONDS_PER_YEAR
    }.freeze

    PARTS = [:years, :months, :weeks, :days, :hours, :minutes, :seconds].freeze

    attr_accessor :value, :parts

    autoload :ISO8601Parser,     "active_support/duration/iso8601_parser"
    autoload :ISO8601Serializer, "active_support/duration/iso8601_serializer"

    class << self
      # Creates a new Duration from string formatted according to ISO 8601 Duration.
      #
      # See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information.
      # This method allows negative parts to be present in pattern.
      # If invalid string is provided, it will raise +ActiveSupport::Duration::ISO8601Parser::ParsingError+.
      def parse(iso8601duration)
        parts = ISO8601Parser.new(iso8601duration).parse!
        new(calculate_total_seconds(parts), parts)
      end

      def ===(other) #:nodoc:
        other.is_a?(Duration)
      rescue ::NoMethodError
        false
      end

      def seconds(value) #:nodoc:
        new(value, seconds: value)
      end

      def minutes(value) #:nodoc:
        new(value * SECONDS_PER_MINUTE, minutes: value)
      end

      def hours(value) #:nodoc:
        new(value * SECONDS_PER_HOUR, hours: value)
      end

      def days(value) #:nodoc:
        new(value * SECONDS_PER_DAY, days: value)
      end

      def weeks(value) #:nodoc:
        new(value * SECONDS_PER_WEEK, weeks: value)
      end

      def months(value) #:nodoc:
        new(value * SECONDS_PER_MONTH, months: value)
      end

      def years(value) #:nodoc:
        new(value * SECONDS_PER_YEAR, years: value)
      end

      # Creates a new Duration from a seconds value that is converted
      # to the individual parts:
      #
      #   ActiveSupport::Duration.build(31556952).parts # => {:years=>1}
      #   ActiveSupport::Duration.build(2716146).parts  # => {:months=>1, :days=>1}
      #
      def build(value)
        unless value.is_a?(::Numeric)
          raise TypeError, "can't build an #{self.name} from a #{value.class.name}"
        end

        parts = {}
        remainder = value.round(9)

        PARTS.each do |part|
          unless part == :seconds
            part_in_seconds = PARTS_IN_SECONDS[part]
            parts[part] = remainder.div(part_in_seconds)
            remainder %= part_in_seconds
          end
        end unless value == 0

        parts[:seconds] = remainder

        new(value, parts)
      end

      private
        def calculate_total_seconds(parts)
          parts.inject(0) do |total, (part, value)|
            total + value * PARTS_IN_SECONDS[part]
          end
        end
    end

    def initialize(value, parts) #:nodoc:
      @value, @parts = value, parts
      @parts.reject! { |k, v| v.zero? } unless value == 0
    end

    def coerce(other) #:nodoc:
      case other
      when Scalar
        [other, self]
      when Duration
        [Scalar.new(other.value), self]
      else
        [Scalar.new(other), self]
      end
    end

    # Compares one Duration with another or a Numeric to this Duration.
    # Numeric values are treated as seconds.
    def <=>(other)
      if Duration === other
        value <=> other.value
      elsif Numeric === other
        value <=> other
      end
    end

    # Adds another Duration or a Numeric to this Duration. Numeric values
    # are treated as seconds.
    def +(other)
      if Duration === other
        parts = @parts.merge(other.parts) do |_key, value, other_value|
          value + other_value
        end
        Duration.new(value + other.value, parts)
      else
        seconds = @parts.fetch(:seconds, 0) + other
        Duration.new(value + other, @parts.merge(seconds: seconds))
      end
    end

    # Subtracts another Duration or a Numeric from this Duration. Numeric
    # values are treated as seconds.
    def -(other)
      self + (-other)
    end

    # Multiplies this Duration by a Numeric and returns a new Duration.
    def *(other)
      if Scalar === other || Duration === other
        Duration.new(value * other.value, parts.transform_values { |number| number * other.value })
      elsif Numeric === other
        Duration.new(value * other, parts.transform_values { |number| number * other })
      else
        raise_type_error(other)
      end
    end

    # Divides this Duration by a Numeric and returns a new Duration.
    def /(other)
      if Scalar === other
        Duration.new(value / other.value, parts.transform_values { |number| number / other.value })
      elsif Duration === other
        value / other.value
      elsif Numeric === other
        Duration.new(value / other, parts.transform_values { |number| number / other })
      else
        raise_type_error(other)
      end
    end

    # Returns the modulo of this Duration by another Duration or Numeric.
    # Numeric values are treated as seconds.
    def %(other)
      if Duration === other || Scalar === other
        Duration.build(value % other.value)
      elsif Numeric === other
        Duration.build(value % other)
      else
        raise_type_error(other)
      end
    end

    def -@ #:nodoc:
      Duration.new(-value, parts.transform_values(&:-@))
    end

    def +@ #:nodoc:
      self
    end

    def is_a?(klass) #:nodoc:
      Duration == klass || value.is_a?(klass)
    end
    alias :kind_of? :is_a?

    def instance_of?(klass) # :nodoc:
      Duration == klass || value.instance_of?(klass)
    end

    # Returns +true+ if +other+ is also a Duration instance with the
    # same +value+, or if <tt>other == value</tt>.
    def ==(other)
      if Duration === other
        other.value == value
      else
        other == value
      end
    end

    # Returns the amount of seconds a duration covers as a string.
    # For more information check to_i method.
    #
    #   1.day.to_s # => "86400"
    def to_s
      @value.to_s
    end

    # Returns the number of seconds that this Duration represents.
    #
    #   1.minute.to_i   # => 60
    #   1.hour.to_i     # => 3600
    #   1.day.to_i      # => 86400
    #
    # Note that this conversion makes some assumptions about the
    # duration of some periods, e.g. months are always 1/12 of year
    # and years are 365.2425 days:
    #
    #   # equivalent to (1.year / 12).to_i
    #   1.month.to_i    # => 2629746
    #
    #   # equivalent to 365.2425.days.to_i
    #   1.year.to_i     # => 31556952
    #
    # In such cases, Ruby's core
    # Date[https://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html] and
    # Time[https://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html] should be used for precision
    # date and time arithmetic.
    def to_i
      @value.to_i
    end
    alias :in_seconds :to_i

    # Returns the amount of minutes a duration covers as a float
    #
    #   1.day.in_minutes # => 1440.0
    def in_minutes
      in_seconds / SECONDS_PER_MINUTE.to_f
    end

    # Returns the amount of hours a duration covers as a float
    #
    #   1.day.in_hours # => 24.0
    def in_hours
      in_seconds / SECONDS_PER_HOUR.to_f
    end

    # Returns the amount of days a duration covers as a float
    #
    #   12.hours.in_days # => 0.5
    def in_days
      in_seconds / SECONDS_PER_DAY.to_f
    end

    # Returns the amount of weeks a duration covers as a float
    #
    #   2.months.in_weeks # => 8.696
    def in_weeks
      in_seconds / SECONDS_PER_WEEK.to_f
    end

    # Returns the amount of months a duration covers as a float
    #
    #   9.weeks.in_months # => 2.07
    def in_months
      in_seconds / SECONDS_PER_MONTH.to_f
    end

    # Returns the amount of years a duration covers as a float
    #
    #   30.days.in_years # => 0.082
    def in_years
      in_seconds / SECONDS_PER_YEAR.to_f
    end

    # Returns +true+ if +other+ is also a Duration instance, which has the
    # same parts as this one.
    def eql?(other)
      Duration === other && other.value.eql?(value)
    end

    def hash
      @value.hash
    end

    # Calculates a new Time or Date that is as far in the future
    # as this Duration represents.
    def since(time = ::Time.current)
      sum(1, time)
    end
    alias :from_now :since
    alias :after :since

    # Calculates a new Time or Date that is as far in the past
    # as this Duration represents.
    def ago(time = ::Time.current)
      sum(-1, time)
    end
    alias :until :ago
    alias :before :ago

    def inspect #:nodoc:
      return "#{value} seconds" if parts.empty?

      parts.
        sort_by { |unit,  _ | PARTS.index(unit) }.
        map     { |unit, val| "#{val} #{val == 1 ? unit.to_s.chop : unit.to_s}" }.
        to_sentence(locale: ::I18n.default_locale)
    end

    def as_json(options = nil) #:nodoc:
      to_i
    end

    def init_with(coder) #:nodoc:
      initialize(coder["value"], coder["parts"])
    end

    def encode_with(coder) #:nodoc:
      coder.map = { "value" => @value, "parts" => @parts }
    end

    # Build ISO 8601 Duration string for this duration.
    # The +precision+ parameter can be used to limit seconds' precision of duration.
    def iso8601(precision: nil)
      ISO8601Serializer.new(self, precision: precision).serialize
    end

    private
      def sum(sign, time = ::Time.current)
        unless time.acts_like?(:time) || time.acts_like?(:date)
          raise ::ArgumentError, "expected a time or date, got #{time.inspect}"
        end

        if parts.empty?
          time.since(sign * value)
        else
          parts.inject(time) do |t, (type, number)|
            if type == :seconds
              t.since(sign * number)
            elsif type == :minutes
              t.since(sign * number * 60)
            elsif type == :hours
              t.since(sign * number * 3600)
            else
              t.advance(type => sign * number)
            end
          end
        end
      end

      def respond_to_missing?(method, _)
        value.respond_to?(method)
      end

      def method_missing(method, *args, &block)
        value.public_send(method, *args, &block)
      end

      def raise_type_error(other)
# frozen_string_literal: true

require "active_support/json"
require "active_support/core_ext/string/access"
require "active_support/core_ext/string/behavior"
require "active_support/core_ext/module/delegation"

module ActiveSupport #:nodoc:
  module Multibyte #:nodoc:
    # Chars enables you to work transparently with UTF-8 encoding in the Ruby
    # String class without having extensive knowledge about the encoding. A
    # Chars object accepts a string upon initialization and proxies String
    # methods in an encoding safe manner. All the normal String methods are also
    # implemented on the proxy.
    #
    # String methods are proxied through the Chars object, and can be accessed
    # through the +mb_chars+ method. Methods which would normally return a
    # String object now return a Chars object so methods can be chained.
    #
    #   'The Perfect String  '.mb_chars.downcase.strip
    #   # => #<ActiveSupport::Multibyte::Chars:0x007fdc434ccc10 @wrapped_string="the perfect string">
    #
    # Chars objects are perfectly interchangeable with String objects as long as
    # no explicit class checks are made. If certain methods do explicitly check
    # the class, call +to_s+ before you pass chars objects to them.
    #
    #   bad.explicit_checking_method 'T'.mb_chars.downcase.to_s
    #
    # The default Chars implementation assumes that the encoding of the string
    # is UTF-8, if you want to handle different encodings you can write your own
    # multibyte string handler and configure it through
    # ActiveSupport::Multibyte.proxy_class.
    #
    #   class CharsForUTF32
    #     def size
    #       @wrapped_string.size / 4
    #     end
    #
    #     def self.accepts?(string)
    #       string.length % 4 == 0
    #     end
    #   end
    #
    #   ActiveSupport::Multibyte.proxy_class = CharsForUTF32
    class Chars
      include Comparable
      attr_reader :wrapped_string
      alias to_s wrapped_string
      alias to_str wrapped_string

      delegate :<=>, :=~, :match?, :acts_like_string?, to: :wrapped_string

      # Creates a new Chars instance by wrapping _string_.
      def initialize(string)
        @wrapped_string = string
        @wrapped_string.force_encoding(Encoding::UTF_8) unless @wrapped_string.frozen?
      end

      # Forward all undefined methods to the wrapped string.
      def method_missing(method, *args, &block)
        result = @wrapped_string.__send__(method, *args, &block)
        if method.end_with?("!")
          self if result
        else
          result.kind_of?(String) ? chars(result) : result
        end
      end

      # Returns +true+ if _obj_ responds to the given method. Private methods
      # are included in the search only if the optional second parameter
      # evaluates to +true+.
      def respond_to_missing?(method, include_private)
        @wrapped_string.respond_to?(method, include_private)
      end

      # Works just like <tt>String#split</tt>, with the exception that the items
      # in the resulting list are Chars instances instead of String. This makes
      # chaining methods easier.
      #
      #   'Caf priferl'.mb_chars.split(//).map { |part| part.upcase.to_s } # => ["CAF", " P", "RIFERL"]
      def split(*args)
        @wrapped_string.split(*args).map { |i| self.class.new(i) }
      end

      # Works like <tt>String#slice!</tt>, but returns an instance of
      # Chars, or +nil+ if the string was not modified. The string will not be
      # modified if the range given is out of bounds
      #
      #   string = 'Welcome'
      #   string.mb_chars.slice!(3)    # => #<ActiveSupport::Multibyte::Chars:0x000000038109b8 @wrapped_string="c">
      #   string # => 'Welome'
      #   string.mb_chars.slice!(0..3) # => #<ActiveSupport::Multibyte::Chars:0x00000002eb80a0 @wrapped_string="Welo">
      #   string # => 'me'
      def slice!(*args)
        string_sliced = @wrapped_string.slice!(*args)
        if string_sliced
          chars(string_sliced)
        end
      end

      # Reverses all characters in the string.
      #
      #   'Caf'.mb_chars.reverse.to_s # => 'faC'
      def reverse
        chars(@wrapped_string.grapheme_clusters.reverse.join)
      end

      # Limits the byte size of the string to a number of bytes without breaking
      # characters. Usable when the storage for a string is limited for some
      # reason.
      #
      #   ''.mb_chars.limit(7).to_s # => ""
      def limit(limit)
        chars(@wrapped_string.truncate_bytes(limit, omission: nil))
      end

      # Capitalizes the first letter of every word, when possible.
      #
      #   "L QUE SE ENTER".mb_chars.titleize.to_s    # => "l Que Se Enter"
      #   "".mb_chars.titleize.to_s               # => ""
      def titleize
        chars(downcase.to_s.gsub(/\b('?\S)/u) { $1.upcase })
      end
      alias_method :titlecase, :titleize

      # Performs canonical decomposition on all the characters.
      #
      #   ''.length                         # => 1
      #   ''.mb_chars.decompose.to_s.length # => 2
      def decompose
        chars(Unicode.decompose(:canonical, @wrapped_string.codepoints.to_a).pack("U*"))
      end

      # Performs composition on all the characters.
      #
      #   ''.length                       # => 1
      #   ''.mb_chars.compose.to_s.length # => 1
      def compose
        chars(Unicode.compose(@wrapped_string.codepoints.to_a).pack("U*"))
      end

      # Returns the number of grapheme clusters in the string.
      #
      #   ''.mb_chars.length   # => 4
      #   ''.mb_chars.grapheme_length # => 2
      def grapheme_length
        @wrapped_string.grapheme_clusters.length
      end

      # Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent
      # resulting in a valid UTF-8 string.
      #
      # Passing +true+ will forcibly tidy all bytes, assuming that the string's
      # encoding is entirely CP1252 or ISO-8859-1.
      def tidy_bytes(force = false)
        chars(Unicode.tidy_bytes(@wrapped_string, force))
      end

      def as_json(options = nil) #:nodoc:
        to_s.as_json(options)
      end

      %w(reverse tidy_bytes).each do |method|
        define_method("#{method}!") do |*args|
          @wrapped_string = public_send(method, *args).to_s
          self
        end
      end

      private
        def chars(string)
          self.class.new(string)
        end
    end
  end
# frozen_string_literal: true

module ActiveSupport
  module Multibyte
    module Unicode
      extend self

      # The Unicode version that is supported by the implementation
      UNICODE_VERSION = RbConfig::CONFIG["UNICODE_VERSION"]

      def default_normalization_form
        ActiveSupport::Deprecation.warn(
          "ActiveSupport::Multibyte::Unicode.default_normalization_form is deprecated and will be removed in Rails 7.0."
        )
      end

      def default_normalization_form=(_)
        ActiveSupport::Deprecation.warn(
          "ActiveSupport::Multibyte::Unicode.default_normalization_form= is deprecated and will be removed in Rails 7.0."
        )
      end

      # Decompose composed characters to the decomposed form.
      def decompose(type, codepoints)
        if type == :compatibility
          codepoints.pack("U*").unicode_normalize(:nfkd).codepoints
        else
          codepoints.pack("U*").unicode_normalize(:nfd).codepoints
        end
      end

      # Compose decomposed characters to the composed form.
      def compose(codepoints)
        codepoints.pack("U*").unicode_normalize(:nfc).codepoints
      end

      # Rubinius' String#scrub, however, doesn't support ASCII-incompatible chars.
      if !defined?(Rubinius)
        # Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent
        # resulting in a valid UTF-8 string.
        #
        # Passing +true+ will forcibly tidy all bytes, assuming that the string's
        # encoding is entirely CP1252 or ISO-8859-1.
        def tidy_bytes(string, force = false)
          return string if string.empty? || string.ascii_only?
          return recode_windows1252_chars(string) if force
          string.scrub { |bad| recode_windows1252_chars(bad) }
        end
      else
        def tidy_bytes(string, force = false)
          return string if string.empty?
          return recode_windows1252_chars(string) if force

          # We can't transcode to the same format, so we choose a nearly-identical encoding.
          # We're going to 'transcode' bytes from UTF-8 when possible, then fall back to
          # CP1252 when we get errors. The final string will be 'converted' back to UTF-8
          # before returning.
          reader = Encoding::Converter.new(Encoding::UTF_8, Encoding::UTF_16LE)

          source = string.dup
          out = "".force_encoding(Encoding::UTF_16LE)

          loop do
            reader.primitive_convert(source, out)
            _, _, _, error_bytes, _ = reader.primitive_errinfo
            break if error_bytes.nil?
            out << error_bytes.encode(Encoding::UTF_16LE, Encoding::Windows_1252, invalid: :replace, undef: :replace)
          end

          reader.finish

          out.encode!(Encoding::UTF_8)
        end
      end

      private
        def recode_windows1252_chars(string)
          string.encode(Encoding::UTF_8, Encoding::Windows_1252, invalid: :replace, undef: :replace)
        end
    end
# frozen_string_literal: true

require "active_support/callbacks"
require "concurrent/hash"

module ActiveSupport
  class ExecutionWrapper
    include ActiveSupport::Callbacks

    Null = Object.new # :nodoc:
    def Null.complete! # :nodoc:
    end

    define_callbacks :run
    define_callbacks :complete

    def self.to_run(*args, &block)
      set_callback(:run, *args, &block)
    end

    def self.to_complete(*args, &block)
      set_callback(:complete, *args, &block)
    end

    RunHook = Struct.new(:hook) do # :nodoc:
      def before(target)
        hook_state = target.send(:hook_state)
        hook_state[hook] = hook.run
      end
    end

    CompleteHook = Struct.new(:hook) do # :nodoc:
      def before(target)
        hook_state = target.send(:hook_state)
        if hook_state.key?(hook)
          hook.complete hook_state[hook]
        end
      end
      alias after before
    end

    # Register an object to be invoked during both the +run+ and
    # +complete+ steps.
    #
    # +hook.complete+ will be passed the value returned from +hook.run+,
    # and will only be invoked if +run+ has previously been called.
    # (Mostly, this means it won't be invoked if an exception occurs in
    # a preceding +to_run+ block; all ordinary +to_complete+ blocks are
    # invoked in that situation.)
    def self.register_hook(hook, outer: false)
      if outer
        to_run RunHook.new(hook), prepend: true
        to_complete :after, CompleteHook.new(hook)
      else
        to_run RunHook.new(hook)
        to_complete CompleteHook.new(hook)
      end
    end

    # Run this execution.
    #
    # Returns an instance, whose +complete!+ method *must* be invoked
    # after the work has been performed.
    #
    # Where possible, prefer +wrap+.
    def self.run!
      if active?
        Null
      else
        new.tap do |instance|
          success = nil
          begin
            instance.run!
            success = true
          ensure
            instance.complete! unless success
          end
        end
      end
    end

    # Perform the work in the supplied block as an execution.
    def self.wrap
      return yield if active?

      instance = run!
      begin
        yield
      ensure
        instance.complete!
      end
    end

    class << self # :nodoc:
      attr_accessor :active
    end

    def self.inherited(other) # :nodoc:
      super
      other.active = Concurrent::Hash.new
    end

    self.active = Concurrent::Hash.new

    def self.active? # :nodoc:
      @active[Thread.current]
    end

    def run! # :nodoc:
      self.class.active[Thread.current] = true
      run_callbacks(:run)
    end

    # Complete this in-flight execution. This method *must* be called
    # exactly once on the result of any call to +run!+.
    #
    # Where possible, prefer +wrap+.
    def complete!
      run_callbacks(:complete)
    ensure
      self.class.active.delete Thread.current
    end

    private
      def hook_state
# frozen_string_literal: true

module ActiveSupport
  autoload :Duration, "active_support/duration"
  autoload :TimeWithZone, "active_support/time_with_zone"
  autoload :TimeZone, "active_support/values/time_zone"
end

require "date"
require "time"

require "active_support/core_ext/time"
require "active_support/core_ext/date"
require "active_support/core_ext/date_time"

# frozen_string_literal: true

#--
# Copyright (c) 2005-2021 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "securerandom"
require "active_support/dependencies/autoload"
require "active_support/version"
require "active_support/logger"
require "active_support/lazy_load_hooks"
require "active_support/core_ext/date_and_time/compatibility"

module ActiveSupport
  extend ActiveSupport::Autoload

  autoload :Concern
  autoload :ActionableError
  autoload :ConfigurationFile
  autoload :CurrentAttributes
  autoload :Dependencies
  autoload :DescendantsTracker
  autoload :ExecutionWrapper
  autoload :Executor
  autoload :FileUpdateChecker
  autoload :EventedFileUpdateChecker
  autoload :ForkTracker
  autoload :LogSubscriber
  autoload :Notifications
  autoload :Reloader
  autoload :SecureCompareRotator

  eager_autoload do
    autoload :BacktraceCleaner
    autoload :ProxyObject
    autoload :Benchmarkable
    autoload :Cache
    autoload :Callbacks
    autoload :Configurable
    autoload :Deprecation
    autoload :Digest
    autoload :Gzip
    autoload :Inflector
    autoload :JSON
    autoload :KeyGenerator
    autoload :MessageEncryptor
    autoload :MessageVerifier
    autoload :Multibyte
    autoload :NumberHelper
    autoload :OptionMerger
    autoload :OrderedHash
    autoload :OrderedOptions
    autoload :StringInquirer
    autoload :EnvironmentInquirer
    autoload :TaggedLogging
    autoload :XmlMini
    autoload :ArrayInquirer
  end

  autoload :Rescuable
  autoload :SafeBuffer, "active_support/core_ext/string/output_safety"
  autoload :TestCase

  def self.eager_load!
    super

    NumberHelper.eager_load!
  end

  cattr_accessor :test_order # :nodoc:

  def self.to_time_preserves_timezone
    DateAndTime::Compatibility.preserve_timezone
  end

  def self.to_time_preserves_timezone=(value)
    DateAndTime::Compatibility.preserve_timezone = value
  end

  def self.utc_to_local_returns_utc_offset_times
    DateAndTime::Compatibility.utc_to_local_returns_utc_offset_times
  end

  def self.utc_to_local_returns_utc_offset_times=(value)
    DateAndTime::Compatibility.utc_to_local_returns_utc_offset_times = value
  end
# frozen_string_literal: true

require_relative "abstract_unit"
require_relative "multibyte_test_helpers"
require "active_support/core_ext/string/multibyte"

class MultibyteCharsTest < ActiveSupport::TestCase
  include MultibyteTestHelpers

  def setup
    @proxy_class = ActiveSupport::Multibyte::Chars
    @chars = @proxy_class.new UNICODE_STRING.dup
  end

  def test_wraps_the_original_string
    assert_equal UNICODE_STRING, @chars.to_s
    assert_equal UNICODE_STRING, @chars.wrapped_string
  end

  def test_should_allow_method_calls_to_string
    @chars.wrapped_string.singleton_class.class_eval { def __method_for_multibyte_testing; "result"; end }

    assert_nothing_raised do
      @chars.__method_for_multibyte_testing
    end
    assert_raise NoMethodError do
      @chars.__unknown_method
    end
  end

  def test_forwarded_method_calls_should_return_new_chars_instance
    @chars.wrapped_string.singleton_class.class_eval { def __method_for_multibyte_testing; "result"; end }

    assert_kind_of @proxy_class, @chars.__method_for_multibyte_testing
    assert_not_equal @chars.object_id, @chars.__method_for_multibyte_testing.object_id
  end

  def test_forwarded_bang_method_calls_should_return_the_original_chars_instance_when_result_is_not_nil
    @chars.wrapped_string.singleton_class.class_eval { def __method_for_multibyte_testing!; "result"; end }

    assert_kind_of @proxy_class, @chars.__method_for_multibyte_testing!
    assert_equal @chars.object_id, @chars.__method_for_multibyte_testing!.object_id
  end

  def test_forwarded_bang_method_calls_should_return_nil_when_result_is_nil
    @chars.wrapped_string.singleton_class.class_eval { def __method_for_multibyte_testing_that_returns_nil!; end }

    assert_nil @chars.__method_for_multibyte_testing_that_returns_nil!
  end

  def test_methods_are_forwarded_to_wrapped_string_for_byte_strings
    assert_equal BYTE_STRING.length, BYTE_STRING.mb_chars.length
  end

  def test_forwarded_method_with_non_string_result_should_be_returned_verbatim
    str = +""
    str.singleton_class.class_eval { def __method_for_multibyte_testing_with_integer_result; 1; end }
    @chars.wrapped_string.singleton_class.class_eval { def __method_for_multibyte_testing_with_integer_result; 1; end }

    assert_equal str.__method_for_multibyte_testing_with_integer_result, @chars.__method_for_multibyte_testing_with_integer_result
  end

  def test_should_concatenate
    mb_a = (+"a").mb_chars
    mb_b = (+"b").mb_chars
    assert_equal "ab", mb_a + "b"
    assert_equal "ab", "a" + mb_b
    assert_equal "ab", mb_a + mb_b

    assert_equal "ab", mb_a << "b"
    assert_equal "ab", (+"a") << mb_b
    assert_equal "abb", mb_a << mb_b
  end

  def test_concatenation_should_return_a_proxy_class_instance
    assert_equal ActiveSupport::Multibyte.proxy_class, ("a".mb_chars + "b").class
    assert_equal ActiveSupport::Multibyte.proxy_class, ((+"a").mb_chars << "b").class
  end

  def test_ascii_strings_are_treated_at_utf8_strings
    assert_equal ActiveSupport::Multibyte.proxy_class, ASCII_STRING.mb_chars.class
  end

  def test_concatenate_should_return_proxy_instance
    assert(("a".mb_chars + "b").kind_of?(@proxy_class))
    assert(("a".mb_chars + "b".mb_chars).kind_of?(@proxy_class))
    assert(((+"a").mb_chars << "b").kind_of?(@proxy_class))
    assert(((+"a").mb_chars << "b".mb_chars).kind_of?(@proxy_class))
  end

  def test_should_return_string_as_json
    assert_equal UNICODE_STRING, @chars.as_json
  end
end

class MultibyteCharsUTF8BehaviourTest < ActiveSupport::TestCase
  include MultibyteTestHelpers

  def setup
    @chars = UNICODE_STRING.dup.mb_chars
    # Ruby 1.9 only supports basic whitespace
    @whitespace = "\n\t "
  end

  def test_split_should_return_an_array_of_chars_instances
    @chars.split(//).each do |character|
      assert_kind_of ActiveSupport::Multibyte.proxy_class, character
    end
  end

  %w{capitalize downcase lstrip reverse rstrip swapcase upcase}.each do |method|
    class_eval(<<-EOTESTS, __FILE__, __LINE__ + 1)
      def test_#{method}_bang_should_return_self_when_modifying_wrapped_string
        chars = ' l piDi Un bUen caf '.dup
        assert_equal chars.object_id, chars.public_send("#{method}!").object_id
      end

      def test_#{method}_bang_should_change_wrapped_string
        original = ' l piDi Un bUen caf '.dup
        proxy = chars(original.dup)
        proxy.public_send("#{method}!")
        assert_not_equal original, proxy.to_s
      end
    EOTESTS
  end

  def test_tidy_bytes_bang_should_return_self
    assert_equal @chars.object_id, @chars.tidy_bytes!.object_id
  end

  def test_tidy_bytes_bang_should_change_wrapped_string
    original = +" Un bUen caf \x92"
    proxy = chars(original.dup)
    proxy.tidy_bytes!
    assert_not_equal original, proxy.to_s
  end

  def test_unicode_string_should_have_utf8_encoding
    assert_equal Encoding::UTF_8, UNICODE_STRING.encoding
  end

  def test_identity
    assert_equal @chars, @chars
    assert @chars.eql?(@chars)
    assert_not @chars.eql?(UNICODE_STRING)
  end

  def test_string_methods_are_chainable
    assert chars(+"").insert(0, "").kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").rjust(1).kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").ljust(1).kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").center(1).kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").rstrip.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").lstrip.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").strip.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").reverse.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars(" ").slice(0).kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").limit(0).kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").upcase.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").downcase.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").capitalize.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").decompose.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").compose.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").tidy_bytes.kind_of?(ActiveSupport::Multibyte.proxy_class)
    assert chars("").swapcase.kind_of?(ActiveSupport::Multibyte.proxy_class)
  end

  def test_should_be_equal_to_the_wrapped_string
    assert_equal UNICODE_STRING, @chars
    assert_equal @chars, UNICODE_STRING
  end

  def test_should_not_be_equal_to_an_other_string
    assert_not_equal @chars, "other"
    assert_not_equal "other", @chars
  end

  def test_sortability
    words = %w(builder armor zebra).sort_by(&:mb_chars)
    assert_equal %w(armor builder zebra), words
  end

  def test_should_return_character_offset_for_regexp_matches
    assert_nil(@chars =~ /wrong/u)
    assert_equal 0, (@chars =~ //u)
    assert_equal 0, (@chars =~ //u)
    assert_equal 1, (@chars =~ //u)
    assert_equal 2, (@chars =~ //u)
    assert_equal 3, (@chars =~ //u)
  end

  def test_match_should_return_boolean_for_regexp_match
    assert_not @chars.match?(/wrong/u)
    assert @chars.match?(//u)
    assert @chars.match?(//u)
  end

  def test_should_use_character_offsets_for_insert_offsets
    assert_equal "", (+"").mb_chars.insert(0, "")
    assert_equal "", @chars.insert(1, "")
    assert_equal "", @chars.insert(2, "")
    assert_equal "", @chars.insert(0, "")
    assert_equal "", @chars.wrapped_string
  end

  def test_insert_should_be_destructive
    @chars.insert(1, "")
    assert_equal "", @chars
  end

  def test_insert_throws_index_error
    assert_raise(IndexError) { @chars.insert(-12, "") }
    assert_raise(IndexError) { @chars.insert(12, "") }
  end

  def test_should_know_if_one_includes_the_other
    assert_includes @chars, ""
    assert_includes @chars, ""
    assert_includes @chars, ""
    assert_not_includes @chars, ""
    assert_not_includes @chars, "a"
  end

  def test_include_raises_when_nil_is_passed
    assert_raises TypeError, NoMethodError, "Expected chars.include?(nil) to raise TypeError or NoMethodError" do
      @chars.include?(nil)
    end
  end

  def test_index_should_return_character_offset
    assert_nil @chars.index("u")
    assert_equal 0, @chars.index("")
    assert_equal 2, @chars.index("")
    assert_equal 2, @chars.index("", -2)
    assert_nil @chars.index("", -1)
    assert_equal 3, @chars.index("")
    assert_equal 5, "xx".mb_chars.index("x", 4)
  end

  def test_rindex_should_return_character_offset
    assert_nil @chars.rindex("u")
    assert_equal 1, @chars.rindex("")
    assert_equal 2, @chars.rindex("", -2)
    assert_nil @chars.rindex("", -3)
    assert_equal 6, "Caf priferl".mb_chars.rindex("")
    assert_equal 13, "Caf priferl".mb_chars.rindex(/\w/u)
  end

  def test_indexed_insert_should_take_character_offsets
    @chars[2] = "a"
    assert_equal "a", @chars
    @chars[2] = ""
    assert_equal "", @chars
    @chars[3, 2] = ""
    assert_equal "", @chars
    @chars[1, 0] = ""
    assert_equal "", @chars
    @chars[4..6] = ""
    assert_equal "", @chars
    @chars[//] = ""
    assert_equal "", @chars
    @chars[/()(.)/, 2] = ""
    assert_equal "", @chars
    @chars[""] = ""
    assert_equal "", @chars
    @chars[""] = ""
    assert_equal "", @chars
  end

  def test_indexed_insert_should_raise_on_index_overflow
    before = @chars.to_s
    assert_raise(IndexError) { @chars[10] = "a" }
    assert_raise(IndexError) { @chars[10, 4] = "a" }
    assert_raise(IndexError) { @chars[/ii/] = "a" }
    assert_raise(IndexError) { @chars[/()/, 10] = "a" }
    assert_equal before, @chars
  end

  def test_indexed_insert_should_raise_on_range_overflow
    before = @chars.to_s
    assert_raise(RangeError) { @chars[10..12] = "a" }
    assert_equal before, @chars
  end

  def test_rjust_should_raise_argument_errors_on_bad_arguments
    assert_raise(ArgumentError) { @chars.rjust(10, "") }
    assert_raise(ArgumentError) { @chars.rjust }
  end

  def test_rjust_should_count_characters_instead_of_bytes
    assert_equal UNICODE_STRING, @chars.rjust(-3)
    assert_equal UNICODE_STRING, @chars.rjust(0)
    assert_equal UNICODE_STRING, @chars.rjust(4)
    assert_equal " #{UNICODE_STRING}", @chars.rjust(5)
    assert_equal "   #{UNICODE_STRING}", @chars.rjust(7)
    assert_equal "---#{UNICODE_STRING}", @chars.rjust(7, "-")
    assert_equal "#{UNICODE_STRING}", @chars.rjust(7, "")
    assert_equal "aba#{UNICODE_STRING}", @chars.rjust(7, "ab")
    assert_equal "#{UNICODE_STRING}", @chars.rjust(7, "")
    assert_equal "#{UNICODE_STRING}", @chars.rjust(8, "")
  end

  def test_ljust_should_raise_argument_errors_on_bad_arguments
    assert_raise(ArgumentError) { @chars.ljust(10, "") }
    assert_raise(ArgumentError) { @chars.ljust }
  end

  def test_ljust_should_count_characters_instead_of_bytes
    assert_equal UNICODE_STRING, @chars.ljust(-3)
    assert_equal UNICODE_STRING, @chars.ljust(0)
    assert_equal UNICODE_STRING, @chars.ljust(4)
    assert_equal "#{UNICODE_STRING} ", @chars.ljust(5)
    assert_equal "#{UNICODE_STRING}   ", @chars.ljust(7)
    assert_equal "#{UNICODE_STRING}---", @chars.ljust(7, "-")
    assert_equal "#{UNICODE_STRING}", @chars.ljust(7, "")
    assert_equal "#{UNICODE_STRING}aba", @chars.ljust(7, "ab")
    assert_equal "#{UNICODE_STRING}", @chars.ljust(7, "")
    assert_equal "#{UNICODE_STRING}", @chars.ljust(8, "")
  end

  def test_center_should_raise_argument_errors_on_bad_arguments
    assert_raise(ArgumentError) { @chars.center(10, "") }
    assert_raise(ArgumentError) { @chars.center }
  end

  def test_center_should_count_characters_instead_of_bytes
    assert_equal UNICODE_STRING, @chars.center(-3)
    assert_equal UNICODE_STRING, @chars.center(0)
    assert_equal UNICODE_STRING, @chars.center(4)
    assert_equal "#{UNICODE_STRING} ", @chars.center(5)
    assert_equal " #{UNICODE_STRING} ", @chars.center(6)
    assert_equal " #{UNICODE_STRING}  ", @chars.center(7)
    assert_equal "--#{UNICODE_STRING}--", @chars.center(8, "-")
    assert_equal "--#{UNICODE_STRING}---", @chars.center(9, "-")
    assert_equal "#{UNICODE_STRING}", @chars.center(8, "")
    assert_equal "#{UNICODE_STRING}", @chars.center(9, "")
    assert_equal "a#{UNICODE_STRING}ab", @chars.center(7, "ab")
    assert_equal "ab#{UNICODE_STRING}ab", @chars.center(8, "ab")
    assert_equal "abab#{UNICODE_STRING}abab", @chars.center(12, "ab")
    assert_equal "#{UNICODE_STRING}", @chars.center(7, "")
    assert_equal "#{UNICODE_STRING}", @chars.center(8, "")
  end

  def test_lstrip_strips_whitespace_from_the_left_of_the_string
    assert_equal UNICODE_STRING, UNICODE_STRING.mb_chars.lstrip
    assert_equal UNICODE_STRING, (@whitespace + UNICODE_STRING).mb_chars.lstrip
    assert_equal UNICODE_STRING + @whitespace, (@whitespace + UNICODE_STRING + @whitespace).mb_chars.lstrip
  end

  def test_rstrip_strips_whitespace_from_the_right_of_the_string
    assert_equal UNICODE_STRING, UNICODE_STRING.mb_chars.rstrip
    assert_equal UNICODE_STRING, (UNICODE_STRING + @whitespace).mb_chars.rstrip
    assert_equal @whitespace + UNICODE_STRING, (@whitespace + UNICODE_STRING + @whitespace).mb_chars.rstrip
  end

  def test_strip_strips_whitespace
    assert_equal UNICODE_STRING, UNICODE_STRING.mb_chars.strip
    assert_equal UNICODE_STRING, (@whitespace + UNICODE_STRING).mb_chars.strip
    assert_equal UNICODE_STRING, (UNICODE_STRING + @whitespace).mb_chars.strip
    assert_equal UNICODE_STRING, (@whitespace + UNICODE_STRING + @whitespace).mb_chars.strip
  end

  def test_stripping_whitespace_leaves_whitespace_within_the_string_intact
    string_with_whitespace = UNICODE_STRING + @whitespace + UNICODE_STRING
    assert_equal string_with_whitespace, string_with_whitespace.mb_chars.strip
    assert_equal string_with_whitespace, string_with_whitespace.mb_chars.lstrip
    assert_equal string_with_whitespace, string_with_whitespace.mb_chars.rstrip
  end

  def test_size_returns_characters_instead_of_bytes
    assert_equal 0, "".mb_chars.size
    assert_equal 4, @chars.size
    assert_equal 4, @chars.length
    assert_equal 5, ASCII_STRING.mb_chars.size
  end

  def test_reverse_reverses_characters
    assert_equal "", "".mb_chars.reverse
    assert_equal "", @chars.reverse
  end

  def test_reverse_should_work_with_normalized_strings
    str = "bs"
    reversed_str = "sb"
    assert_equal chars(reversed_str).decompose, chars(str).decompose.reverse
    assert_equal chars(reversed_str).compose, chars(str).compose.reverse
  end

  def test_slice_should_take_character_offsets
    assert_nil "".mb_chars.slice(0)
    assert_equal "", @chars.slice(0)
    assert_equal "", @chars.slice(3)
    assert_nil "".mb_chars.slice(-1..1)
    assert_nil "".mb_chars.slice(-1, 1)
    assert_equal "", "".mb_chars.slice(0..10)
    assert_equal "", @chars.slice(1..3)
    assert_equal "", @chars.slice(1, 3)
    assert_equal "", @chars.slice(0, 1)
    assert_equal "", @chars.slice(2..10)
    assert_equal "", @chars.slice(4..10)
    assert_equal "", @chars.slice(//u)
    assert_equal "", @chars.slice(/./u)
    assert_nil @chars.slice(/unknown/u)
    assert_equal "", @chars.slice(/()/u, 1)
    assert_nil @chars.slice(/()/u, 2)
    assert_nil @chars.slice(7..6)
  end

  def test_slice_bang_returns_sliced_out_substring
    assert_equal "", @chars.slice!(1..2)
  end

  def test_slice_bang_returns_nil_on_out_of_bound_arguments
    assert_nil @chars.mb_chars.slice!(9..10)
  end

  def test_slice_bang_removes_the_slice_from_the_receiver
    chars = (+"").mb_chars
    chars.slice!(0, 2)
    assert_equal "", chars
  end

  def test_slice_bang_returns_nil_and_does_not_modify_receiver_if_out_of_bounds
    string = +""
    chars = string.mb_chars
    assert_nil chars.slice!(4, 5)
    assert_equal "", chars
    assert_equal "", string
  end

  def test_slice_should_throw_exceptions_on_invalid_arguments
    assert_raise(TypeError) { @chars.slice(2..3, 1) }
    assert_raise(TypeError) { @chars.slice(1, 2..3) }
    assert_raise(ArgumentError) { @chars.slice(1, 1, 1) }
  end

  def test_ord_should_return_unicode_value_for_first_character
    assert_equal 12371, @chars.ord
  end

  def test_upcase_should_upcase_ascii_characters
    assert_equal "", "".mb_chars.upcase
    assert_equal "ABC", "aBc".mb_chars.upcase
  end

  def test_downcase_should_downcase_ascii_characters
    assert_equal "", "".mb_chars.downcase
    assert_equal "abc", "aBc".mb_chars.downcase
  end

  def test_swapcase_should_swap_ascii_characters
    assert_equal "", "".mb_chars.swapcase
    assert_equal "AbC", "aBc".mb_chars.swapcase
  end

  def test_capitalize_should_work_on_ascii_characters
    assert_equal "", "".mb_chars.capitalize
    assert_equal "Abc", "abc".mb_chars.capitalize
  end

  def test_titleize_should_work_on_ascii_characters
    assert_equal "", "".mb_chars.titleize
    assert_equal "Abc Abc", "abc abc".mb_chars.titleize
  end

  def test_respond_to_knows_which_methods_the_proxy_responds_to
    assert_respond_to "".mb_chars, :slice # Defined on Chars
    assert_respond_to "".mb_chars, :capitalize! # Defined on Chars
    assert_respond_to "".mb_chars, :gsub # Defined on String
    assert_not_respond_to "".mb_chars, :undefined_method # Not defined
  end

  def test_method_works_for_proxyed_methods
    assert_equal "ll", "hello".mb_chars.method(:slice).call(2..3) # Defined on Chars
    chars = +"hello".mb_chars
    assert_equal "Hello", chars.method(:capitalize!).call # Defined on Chars
    assert_equal "Hello", chars
    assert_equal "jello", "hello".mb_chars.method(:gsub).call(/h/, "j") # Defined on String
    assert_raise(NameError) { "".mb_chars.method(:undefined_method) } # Not defined
  end

  def test_acts_like_string
    assert_predicate "Bambi".mb_chars, :acts_like_string?
  end
end

# The default Multibyte Chars proxy has more features than the normal string implementation. Tests
# for the implementation of these features should run on all Ruby versions and shouldn't be tested
# through the proxy methods.
class MultibyteCharsExtrasTest < ActiveSupport::TestCase
  include MultibyteTestHelpers

  def test_upcase_should_be_unicode_aware
    assert_equal "\0F", chars("\0f").upcase
    assert_equal "", chars("").upcase
  end

  def test_downcase_should_be_unicode_aware
    assert_equal "\0f", chars("\0F").downcase
    assert_equal "", chars("").downcase
  end

  def test_swapcase_should_be_unicode_aware
    assert_equal "a\0f", chars("A\0F").swapcase
    assert_equal "", chars("").swapcase
  end

  def test_capitalize_should_be_unicode_aware
    { " " => " ",
      " " => " ",
      " " => " ",
      "" => "" }.each do |f, t|
      assert_equal t, chars(f).capitalize
    end
  end

  def test_titleize_should_be_unicode_aware
    assert_equal "l Que Se Enter", chars("L QUE SE ENTER").titleize
    assert_equal " ", chars(" ").titleize
  end

  def test_titleize_should_not_affect_characters_that_do_not_case_fold
    assert_equal "", chars("").titleize
  end

  def test_limit_should_not_break_on_blank_strings
    example = chars("")
    assert_equal example, example.limit(0)
    assert_equal example, example.limit(1)
  end

  def test_limit_should_work_on_a_multibyte_string
    example = chars(UNICODE_STRING)
    bytesize = UNICODE_STRING.bytesize

    assert_equal UNICODE_STRING, example.limit(bytesize)
    assert_equal "", example.limit(0)
    assert_equal "", example.limit(1)
    assert_equal "", example.limit(3)
    assert_equal "", example.limit(6)
    assert_equal "", example.limit(8)
    assert_equal "", example.limit(9)
    assert_equal "", example.limit(50)
  end

  def test_limit_should_work_on_an_ascii_string
    ascii = chars(ASCII_STRING)
    assert_equal ASCII_STRING, ascii.limit(ASCII_STRING.length)
    assert_equal "", ascii.limit(0)
    assert_equal "o", ascii.limit(1)
    assert_equal "oh", ascii.limit(2)
    assert_equal "ohay", ascii.limit(4)
    assert_equal "ohayo", ascii.limit(50)
  end

  def test_limit_should_keep_under_the_specified_byte_limit
    example = chars(UNICODE_STRING)
    (1..UNICODE_STRING.length).each do |limit|
      assert example.limit(limit).to_s.length <= limit
    end
  end

  def test_normalization_shouldnt_strip_null_bytes
    null_byte_str = "Test\0test"

    assert_equal null_byte_str, chars(null_byte_str).decompose
    assert_equal null_byte_str, chars(null_byte_str).compose
  end

  def test_should_compute_grapheme_length
    [
      ["", 0],
      ["abc", 3],
      ["", 4],
      [[0x0924, 0x094D, 0x0930].pack("U*"), 2],
      # GB3
      [%w(cr lf), 1],
      # GB4
      [%w(cr n), 2],
      [%w(lf n), 2],
      [%w(control n), 2],
      [%w(cr extend), 2],
      [%w(lf extend), 2],
      [%w(control extend), 2],
      # GB 5
      [%w(n cr), 2],
      [%w(n lf), 2],
      [%w(n control), 2],
      [%w(extend cr), 2],
      [%w(extend lf), 2],
      [%w(extend control), 2],
      # GB 6
      [%w(l l), 1],
      [%w(l v), 1],
      [%w(l lv), 1],
      [%w(l lvt), 1],
      # GB7
      [%w(lv v), 1],
      [%w(lv t), 1],
      [%w(v v), 1],
      [%w(v t), 1],
      # GB8
      [%w(lvt t), 1],
      [%w(t t), 1],
      # GB8a
      [%w(r r), 1],
      # GB9
      [%w(n extend), 1],
      # GB9a
      [%w(n spacingmark), 1],
      # GB10
      [%w(n n), 2],
      # Other
      [%w(n cr lf n), 3],
      [%w(n l v t), 2],
      [%w(cr extend n), 3],
    ].each do |input, expected_length|
      if input.kind_of?(Array)
        str = string_from_classes(input)
      else
        str = input
      end
      assert_equal expected_length, chars(str).grapheme_length, input.inspect
    end
  end

  def test_tidy_bytes_should_tidy_bytes
    single_byte_cases = {
      "\x21" => "!",   # Valid ASCII byte, low
      "\x41" => "A",   # Valid ASCII byte, mid
      "\x7E" => "~",   # Valid ASCII byte, high
      "\x80" => "",   # Continuation byte, low (cp125)
      "\x94" => "",   # Continuation byte, mid (cp125)
      "\x9F" => "",   # Continuation byte, high (cp125)
      "\xC0" => "",   # Overlong encoding, start of 2-byte sequence, but codepoint < 128
      "\xC1" => "",   # Overlong encoding, start of 2-byte sequence, but codepoint < 128
      "\xC2" => "",   # Start of 2-byte sequence, low
      "\xC8" => "",   # Start of 2-byte sequence, mid
      "\xDF" => "",   # Start of 2-byte sequence, high
      "\xE0" => "",   # Start of 3-byte sequence, low
      "\xE8" => "",   # Start of 3-byte sequence, mid
      "\xEF" => "",   # Start of 3-byte sequence, high
      "\xF0" => "",   # Start of 4-byte sequence
      "\xF1" => "",   # Unused byte
      "\xFF" => "",   # Restricted byte
      "\x00" => "\x00" # null char
    }

    single_byte_cases.each do |bad, good|
      assert_equal good, chars(bad).tidy_bytes.to_s
      assert_equal "#{good}#{good}", chars("#{bad}#{bad}").tidy_bytes
      assert_equal "#{good}#{good}#{good}", chars("#{bad}#{bad}#{bad}").tidy_bytes
      assert_equal "#{good}a", chars("#{bad}a").tidy_bytes
      assert_equal "#{good}", chars("#{bad}").tidy_bytes
      assert_equal "a#{good}a", chars("a#{bad}a").tidy_bytes
      assert_equal "#{good}", chars("#{bad}").tidy_bytes
      assert_equal "a#{good}", chars("a#{bad}").tidy_bytes
      assert_equal "#{good}", chars("#{bad}").tidy_bytes
    end

    byte_string = "\270\236\010\210\245"
    tidy_string = [0xb8, 0x17e, 0x8, 0x2c6, 0xa5].pack("U*")
    assert_equal_codepoints tidy_string, chars(byte_string).tidy_bytes
    assert_nothing_raised { chars(byte_string).tidy_bytes.to_s.unpack("U*") }

    # UTF-8 leading byte followed by too few continuation bytes
    assert_equal_codepoints "\xc3\xb0\xc2\xa5\xc2\xa4\x21", chars("\xf0\xa5\xa4\x21").tidy_bytes
  end

  def test_tidy_bytes_should_forcibly_tidy_bytes_if_specified
    byte_string = "\xF0\xA5\xA4\xA4" # valid as both CP-1252 and UTF-8, but with different interpretations.
    assert_not_equal "", chars(byte_string).tidy_bytes
    # Forcible conversion to UTF-8
    assert_equal "", chars(byte_string).tidy_bytes(true)
  end

  def test_class_is_not_forwarded
    assert_equal BYTE_STRING.dup.mb_chars.class, ActiveSupport::Multibyte::Chars
  end

  private
    def string_from_classes(classes)
      # Characters from the character classes as described in UAX #29
      character_from_class = {
        l: 0x1100, v: 0x1160, t: 0x11A8, lv: 0xAC00, lvt: 0xAC01, cr: 0x000D, lf: 0x000A,
        extend: 0x094D, n: 0x64, spacingmark: 0x0903, r: 0x1F1E6, control: 0x0001
      }
      classes.collect do |k|
        character_from_class[k.intern]
      end.pack("U*")
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/core_ext/hash"
require "bigdecimal"
require "active_support/core_ext/string/access"
require "active_support/ordered_hash"
require "active_support/core_ext/object/conversions"
require "active_support/core_ext/object/deep_dup"
require "active_support/inflections"

class HashWithIndifferentAccessTest < ActiveSupport::TestCase
  HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

  class IndifferentHash < ActiveSupport::HashWithIndifferentAccess
  end

  class SubclassingArray < Array
  end

  class SubclassingHash < Hash
  end

  class NonIndifferentHash < Hash
    def nested_under_indifferent_access
      self
    end
  end

  class HashByConversion
    def initialize(hash)
      @hash = hash
    end

    def to_hash
      @hash
    end
  end

  def setup
    @strings = { "a" => 1, "b" => 2 }
    @nested_strings = { "a" => { "b" => { "c" => 3 } } }
    @symbols = { a: 1, b: 2 }
    @nested_symbols = { a: { b: { c: 3 } } }
    @mixed = { :a => 1, "b" => 2 }
    @nested_mixed = { "a" => { b: { "c" => 3 } } }
    @integers = { 0 => 1, 1 => 2 }
    @nested_integers = { 0 => { 1 => { 2 => 3 } } }
    @illegal_symbols = { [] => 3 }
    @nested_illegal_symbols = { [] => { [] => 3 } }
  end

  def test_symbolize_keys_for_hash_with_indifferent_access
    assert_instance_of Hash, @symbols.with_indifferent_access.symbolize_keys
    assert_equal @symbols, @symbols.with_indifferent_access.symbolize_keys
    assert_equal @symbols, @strings.with_indifferent_access.symbolize_keys
    assert_equal @symbols, @mixed.with_indifferent_access.symbolize_keys
  end

  def test_to_options_for_hash_with_indifferent_access
    assert_instance_of Hash, @symbols.with_indifferent_access.to_options
    assert_equal @symbols, @symbols.with_indifferent_access.to_options
    assert_equal @symbols, @strings.with_indifferent_access.to_options
    assert_equal @symbols, @mixed.with_indifferent_access.to_options
  end

  def test_deep_symbolize_keys_for_hash_with_indifferent_access
    assert_instance_of Hash, @nested_symbols.with_indifferent_access.deep_symbolize_keys
    assert_equal @nested_symbols, @nested_symbols.with_indifferent_access.deep_symbolize_keys
    assert_equal @nested_symbols, @nested_strings.with_indifferent_access.deep_symbolize_keys
    assert_equal @nested_symbols, @nested_mixed.with_indifferent_access.deep_symbolize_keys
  end

  def test_symbolize_keys_bang_for_hash_with_indifferent_access
    assert_raise(NoMethodError) { @symbols.with_indifferent_access.dup.symbolize_keys! }
    assert_raise(NoMethodError) { @strings.with_indifferent_access.dup.symbolize_keys! }
    assert_raise(NoMethodError) { @mixed.with_indifferent_access.dup.symbolize_keys! }
  end

  def test_deep_symbolize_keys_bang_for_hash_with_indifferent_access
    assert_raise(NoMethodError) { @nested_symbols.with_indifferent_access.deep_dup.deep_symbolize_keys! }
    assert_raise(NoMethodError) { @nested_strings.with_indifferent_access.deep_dup.deep_symbolize_keys! }
    assert_raise(NoMethodError) { @nested_mixed.with_indifferent_access.deep_dup.deep_symbolize_keys! }
  end

  def test_symbolize_keys_preserves_keys_that_cant_be_symbolized_for_hash_with_indifferent_access
    assert_equal @illegal_symbols, @illegal_symbols.with_indifferent_access.symbolize_keys
    assert_raise(NoMethodError) { @illegal_symbols.with_indifferent_access.dup.symbolize_keys! }
  end

  def test_deep_symbolize_keys_preserves_keys_that_cant_be_symbolized_for_hash_with_indifferent_access
    assert_equal @nested_illegal_symbols, @nested_illegal_symbols.with_indifferent_access.deep_symbolize_keys
    assert_raise(NoMethodError) { @nested_illegal_symbols.with_indifferent_access.deep_dup.deep_symbolize_keys! }
  end

  def test_symbolize_keys_preserves_integer_keys_for_hash_with_indifferent_access
    assert_equal @integers, @integers.with_indifferent_access.symbolize_keys
    assert_raise(NoMethodError) { @integers.with_indifferent_access.dup.symbolize_keys! }
  end

  def test_deep_symbolize_keys_preserves_integer_keys_for_hash_with_indifferent_access
    assert_equal @nested_integers, @nested_integers.with_indifferent_access.deep_symbolize_keys
    assert_raise(NoMethodError) { @nested_integers.with_indifferent_access.deep_dup.deep_symbolize_keys! }
  end

  def test_stringify_keys_for_hash_with_indifferent_access
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, @symbols.with_indifferent_access.stringify_keys
    assert_equal @strings, @symbols.with_indifferent_access.stringify_keys
    assert_equal @strings, @strings.with_indifferent_access.stringify_keys
    assert_equal @strings, @mixed.with_indifferent_access.stringify_keys
  end

  def test_deep_stringify_keys_for_hash_with_indifferent_access
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, @nested_symbols.with_indifferent_access.deep_stringify_keys
    assert_equal @nested_strings, @nested_symbols.with_indifferent_access.deep_stringify_keys
    assert_equal @nested_strings, @nested_strings.with_indifferent_access.deep_stringify_keys
    assert_equal @nested_strings, @nested_mixed.with_indifferent_access.deep_stringify_keys
  end

  def test_stringify_keys_bang_for_hash_with_indifferent_access
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, @symbols.with_indifferent_access.dup.stringify_keys!
    assert_equal @strings, @symbols.with_indifferent_access.dup.stringify_keys!
    assert_equal @strings, @strings.with_indifferent_access.dup.stringify_keys!
    assert_equal @strings, @mixed.with_indifferent_access.dup.stringify_keys!
  end

  def test_deep_stringify_keys_bang_for_hash_with_indifferent_access
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, @nested_symbols.with_indifferent_access.dup.deep_stringify_keys!
    assert_equal @nested_strings, @nested_symbols.with_indifferent_access.deep_dup.deep_stringify_keys!
    assert_equal @nested_strings, @nested_strings.with_indifferent_access.deep_dup.deep_stringify_keys!
    assert_equal @nested_strings, @nested_mixed.with_indifferent_access.deep_dup.deep_stringify_keys!
  end

  def test_nested_under_indifferent_access
    foo = { "foo" => SubclassingHash.new.tap { |h| h["bar"] = "baz" } }.with_indifferent_access
    assert_kind_of ActiveSupport::HashWithIndifferentAccess, foo["foo"]

    foo = { "foo" => NonIndifferentHash.new.tap { |h| h["bar"] = "baz" } }.with_indifferent_access
    assert_kind_of NonIndifferentHash, foo["foo"]

    foo = { "foo" => IndifferentHash.new.tap { |h| h["bar"] = "baz" } }.with_indifferent_access
    assert_kind_of IndifferentHash, foo["foo"]
  end

  def test_indifferent_assorted
    @strings = @strings.with_indifferent_access
    @symbols = @symbols.with_indifferent_access
    @mixed   = @mixed.with_indifferent_access

    assert_equal "a", @strings.__send__(:convert_key, :a)

    assert_equal 1, @strings.fetch("a")
    assert_equal 1, @strings.fetch(:a.to_s)
    assert_equal 1, @strings.fetch(:a)

    hashes = { :@strings => @strings, :@symbols => @symbols, :@mixed => @mixed }
    method_map = { '[]': 1, fetch: 1, values_at: [1],
                   has_key?: true, include?: true, key?: true,
                   member?: true }

    hashes.each do |name, hash|
      method_map.sort_by(&:to_s).each do |meth, expected|
        assert_equal(expected, hash.__send__(meth, "a"),
                     "Calling #{name}.#{meth} 'a'")
        assert_equal(expected, hash.__send__(meth, :a),
                     "Calling #{name}.#{meth} :a")
      end
    end

    assert_equal [1, 2], @strings.values_at("a", "b")
    assert_equal [1, 2], @strings.values_at(:a, :b)
    assert_equal [1, 2], @symbols.values_at("a", "b")
    assert_equal [1, 2], @symbols.values_at(:a, :b)
    assert_equal [1, 2], @mixed.values_at("a", "b")
    assert_equal [1, 2], @mixed.values_at(:a, :b)
  end

  def test_indifferent_fetch_values
    @mixed = @mixed.with_indifferent_access

    assert_equal [1, 2], @mixed.fetch_values("a", "b")
    assert_equal [1, 2], @mixed.fetch_values(:a, :b)
    assert_equal [1, 2], @mixed.fetch_values(:a, "b")
    assert_equal [1, "c"], @mixed.fetch_values(:a, :c) { |key| key }
    assert_raise(KeyError) { @mixed.fetch_values(:a, :c) }
  end

  def test_indifferent_reading
    hash = HashWithIndifferentAccess.new
    hash["a"] = 1
    hash["b"] = true
    hash["c"] = false
    hash["d"] = nil

    assert_equal 1, hash[:a]
    assert_equal true, hash[:b]
    assert_equal false, hash[:c]
    assert_nil hash[:d]
    assert_nil hash[:e]
  end

  def test_indifferent_reading_with_nonnil_default
    hash = HashWithIndifferentAccess.new(1)
    hash["a"] = 1
    hash["b"] = true
    hash["c"] = false
    hash["d"] = nil

    assert_equal 1, hash[:a]
    assert_equal true, hash[:b]
    assert_equal false, hash[:c]
    assert_nil hash[:d]
    assert_equal 1, hash[:e]
  end

  def test_indifferent_writing
    hash = HashWithIndifferentAccess.new
    hash[:a] = 1
    hash["b"] = 2
    hash[3] = 3

    assert_equal 1, hash["a"]
    assert_equal 2, hash["b"]
    assert_equal 1, hash[:a]
    assert_equal 2, hash[:b]
    assert_equal 3, hash[3]
  end

  def test_indifferent_update
    hash = HashWithIndifferentAccess.new
    hash[:a] = "a"
    hash["b"] = "b"

    updated_with_strings = hash.update(@strings)
    updated_with_symbols = hash.update(@symbols)
    updated_with_mixed = hash.update(@mixed)

    assert_equal 1, updated_with_strings[:a]
    assert_equal 1, updated_with_strings["a"]
    assert_equal 2, updated_with_strings["b"]

    assert_equal 1, updated_with_symbols[:a]
    assert_equal 2, updated_with_symbols["b"]
    assert_equal 2, updated_with_symbols[:b]

    assert_equal 1, updated_with_mixed[:a]
    assert_equal 2, updated_with_mixed["b"]

    assert [updated_with_strings, updated_with_symbols, updated_with_mixed].all? { |h| h.keys.size == 2 }
  end

  def test_update_with_multiple_arguments
    hash = HashWithIndifferentAccess.new
    hash.update({ "a" => 1 }, { "b" => 2 })

    assert_equal 1, hash["a"]
    assert_equal 2, hash["b"]
  end

  def test_update_with_to_hash_conversion
    hash = HashWithIndifferentAccess.new
    hash.update HashByConversion.new(a: 1)
    assert_equal 1, hash["a"]
  end

  def test_indifferent_merging
    hash = HashWithIndifferentAccess.new
    hash[:a] = "failure"
    hash["b"] = "failure"

    other = { "a" => 1, :b => 2 }

    merged = hash.merge(other)

    assert_equal HashWithIndifferentAccess, merged.class
    assert_equal 1, merged[:a]
    assert_equal 2, merged["b"]

    hash.update(other)

    assert_equal 1, hash[:a]
    assert_equal 2, hash["b"]
  end

  def test_merging_with_multiple_arguments
    hash = HashWithIndifferentAccess.new
    merged = hash.merge({ "a" => 1 }, { "b" => 2 })

    assert_equal 1, merged["a"]
    assert_equal 2, merged["b"]
  end

  def test_merge_with_to_hash_conversion
    hash = HashWithIndifferentAccess.new
    merged = hash.merge HashByConversion.new(a: 1)
    assert_equal 1, merged["a"]
  end

  def test_indifferent_replace
    hash = HashWithIndifferentAccess.new
    hash[:a] = 42

    replaced = hash.replace(b: 12)

    assert hash.key?("b")
    assert_not hash.key?(:a)
    assert_equal 12, hash[:b]
    assert_same hash, replaced
  end

  def test_replace_with_to_hash_conversion
    hash = HashWithIndifferentAccess.new
    hash[:a] = 42

    replaced = hash.replace(HashByConversion.new(b: 12))

    assert hash.key?("b")
    assert_not hash.key?(:a)
    assert_equal 12, hash[:b]
    assert_same hash, replaced
  end

  def test_indifferent_merging_with_block
    hash = HashWithIndifferentAccess.new
    hash[:a] = 1
    hash["b"] = 3

    other = { "a" => 4, :b => 2, "c" => 10 }

    merged = hash.merge(other) { |key, old, new| old > new ? old : new }

    assert_equal HashWithIndifferentAccess, merged.class
    assert_equal 4, merged[:a]
    assert_equal 3, merged["b"]
    assert_equal 10, merged[:c]

    other_indifferent = HashWithIndifferentAccess.new("a" => 9, :b => 2)

    merged = hash.merge(other_indifferent) { |key, old, new| old + new }

    assert_equal HashWithIndifferentAccess, merged.class
    assert_equal 10, merged[:a]
    assert_equal 5, merged[:b]
  end

  def test_indifferent_reverse_merging
    hash = HashWithIndifferentAccess.new key: :old_value
    hash.reverse_merge! key: :new_value
    assert_equal :old_value, hash[:key]

    hash = HashWithIndifferentAccess.new("some" => "value", "other" => "value")
    hash.reverse_merge!(some: "noclobber", another: "clobber")
    assert_equal "value", hash[:some]
    assert_equal "clobber", hash[:another]
  end

  def test_indifferent_with_defaults_aliases_reverse_merge
    hash = HashWithIndifferentAccess.new key: :old_value
    actual = hash.with_defaults key: :new_value
    assert_equal :old_value, actual[:key]

    hash = HashWithIndifferentAccess.new key: :old_value
    hash.with_defaults! key: :new_value
    assert_equal :old_value, hash[:key]
  end

  def test_indifferent_deleting
    get_hash = proc { { a: "foo" }.with_indifferent_access }
    hash = get_hash.call
    assert_equal "foo", hash.delete(:a)
    assert_nil hash.delete(:a)
    hash = get_hash.call
    assert_equal "foo", hash.delete("a")
    assert_nil hash.delete("a")
  end

  def test_indifferent_select
    hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).select { |k, v| v == 1 }

    assert_equal({ "a" => 1 }, hash)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash
  end

  def test_indifferent_select_returns_enumerator
    enum = ActiveSupport::HashWithIndifferentAccess.new(@strings).select
    assert_instance_of Enumerator, enum
  end

  def test_indifferent_select_returns_a_hash_when_unchanged
    hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).select { |k, v| true }

    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash
  end

  def test_indifferent_select_bang
    indifferent_strings = ActiveSupport::HashWithIndifferentAccess.new(@strings)
    indifferent_strings.select! { |k, v| v == 1 }

    assert_equal({ "a" => 1 }, indifferent_strings)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, indifferent_strings
  end

  def test_indifferent_reject
    hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).reject { |k, v| v != 1 }

    assert_equal({ "a" => 1 }, hash)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash
  end

  def test_indifferent_reject_returns_enumerator
    enum = ActiveSupport::HashWithIndifferentAccess.new(@strings).reject
    assert_instance_of Enumerator, enum
  end

  def test_indifferent_reject_bang
    indifferent_strings = ActiveSupport::HashWithIndifferentAccess.new(@strings)
    indifferent_strings.reject! { |k, v| v != 1 }

    assert_equal({ "a" => 1 }, indifferent_strings)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, indifferent_strings
  end

  def test_indifferent_transform_keys
    hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).transform_keys { |k| k * 2 }

    assert_equal({ "aa" => 1, "bb" => 2 }, hash)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash

    hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).transform_keys { |k| k.to_sym }

    assert_equal(1, hash[:a])
    assert_equal(1, hash["a"])
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash
  end

  def test_indifferent_deep_transform_keys
    hash = ActiveSupport::HashWithIndifferentAccess.new(@nested_strings).deep_transform_keys { |k| k * 2 }

    assert_equal({ "aa" => { "bb" => { "cc" => 3 } } }, hash)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash

    hash = ActiveSupport::HashWithIndifferentAccess.new(@nested_strings).deep_transform_keys { |k| k.to_sym }

    assert_equal(3, hash[:a][:b][:c])
    assert_equal(3, hash["a"]["b"]["c"])
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash
  end

  def test_indifferent_transform_keys_bang
    indifferent_strings = ActiveSupport::HashWithIndifferentAccess.new(@strings)
    indifferent_strings.transform_keys! { |k| k * 2 }

    assert_equal({ "aa" => 1, "bb" => 2 }, indifferent_strings)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, indifferent_strings

    indifferent_strings = ActiveSupport::HashWithIndifferentAccess.new(@strings)
    indifferent_strings.transform_keys! { |k| k.to_sym }

    assert_equal(1, indifferent_strings[:a])
    assert_equal(1, indifferent_strings["a"])
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, indifferent_strings
  end

  def test_indifferent_deep_transform_keys_bang
    hash = ActiveSupport::HashWithIndifferentAccess.new(@nested_strings)
    hash.deep_transform_keys! { |k| k * 2 }

    assert_equal({ "aa" => { "bb" => { "cc" => 3 } } }, hash)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash

    hash = ActiveSupport::HashWithIndifferentAccess.new(@nested_strings)
    hash.deep_transform_keys! { |k| k.to_sym }

    assert_equal(3, hash[:a][:b][:c])
    assert_equal(3, hash["a"]["b"]["c"])
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash
  end

  def test_indifferent_transform_values
    hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).transform_values { |v| v * 2 }

    assert_equal({ "a" => 2, "b" => 4 }, hash)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, hash
  end

  def test_indifferent_transform_values_bang
    indifferent_strings = ActiveSupport::HashWithIndifferentAccess.new(@strings)
    indifferent_strings.transform_values! { |v| v * 2 }

    assert_equal({ "a" => 2, "b" => 4 }, indifferent_strings)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, indifferent_strings
  end

  def test_indifferent_assoc
    indifferent_strings = ActiveSupport::HashWithIndifferentAccess.new(@strings)
    key, value = indifferent_strings.assoc(:a)

    assert_equal("a", key)
    assert_equal(1, value)
  end

  def test_indifferent_compact
    hash_contain_nil_value = @strings.merge("z" => nil)
    hash = ActiveSupport::HashWithIndifferentAccess.new(hash_contain_nil_value)
    compacted_hash = hash.compact

    assert_equal(@strings, compacted_hash)
    assert_equal(hash_contain_nil_value, hash)
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, compacted_hash

    empty_hash = ActiveSupport::HashWithIndifferentAccess.new
    compacted_hash = empty_hash.compact

    assert_equal compacted_hash, empty_hash

    non_empty_hash = ActiveSupport::HashWithIndifferentAccess.new(foo: :bar)
    compacted_hash = non_empty_hash.compact

    assert_equal compacted_hash, non_empty_hash
  end

  def test_indifferent_to_hash
    # Should convert to a Hash with String keys.
    assert_equal @strings, @mixed.with_indifferent_access.to_hash

    # Should preserve the default value.
    mixed_with_default = @mixed.dup
    mixed_with_default.default = "1234"
    roundtrip = mixed_with_default.with_indifferent_access.to_hash
    assert_equal @strings, roundtrip
    assert_equal "1234", roundtrip.default

    # Ensure nested hashes are not HashWithIndifferentAccess
    new_to_hash = @nested_mixed.with_indifferent_access.to_hash
    assert_not new_to_hash.instance_of?(HashWithIndifferentAccess)
    assert_not new_to_hash["a"].instance_of?(HashWithIndifferentAccess)
    assert_not new_to_hash["a"]["b"].instance_of?(HashWithIndifferentAccess)
  end

  def test_lookup_returns_the_same_object_that_is_stored_in_hash_indifferent_access
    hash = HashWithIndifferentAccess.new { |h, k| h[k] = [] }
    hash[:a] << 1

    assert_equal [1], hash[:a]
  end

  def test_with_indifferent_access_has_no_side_effects_on_existing_hash
    hash = { content: [{ :foo => :bar, "bar" => "baz" }] }
    hash.with_indifferent_access

    assert_equal [:foo, "bar"], hash[:content].first.keys
  end

  def test_indifferent_hash_with_array_of_hashes
    hash = { "urls" => { "url" => [ { "address" => "1" }, { "address" => "2" } ] } }.with_indifferent_access
    assert_equal "1", hash[:urls][:url].first[:address]

    hash = hash.to_hash
    assert_not hash.instance_of?(HashWithIndifferentAccess)
    assert_not hash["urls"].instance_of?(HashWithIndifferentAccess)
    assert_not hash["urls"]["url"].first.instance_of?(HashWithIndifferentAccess)
  end

  def test_should_preserve_array_subclass_when_value_is_array
    array = SubclassingArray.new
    array << { "address" => "1" }
    hash = { "urls" => { "url" => array } }.with_indifferent_access
    assert_equal SubclassingArray, hash[:urls][:url].class
  end

  def test_should_preserve_array_class_when_hash_value_is_frozen_array
    array = SubclassingArray.new
    array << { "address" => "1" }
    hash = { "urls" => { "url" => array.freeze } }.with_indifferent_access
    assert_equal SubclassingArray, hash[:urls][:url].class
  end

  def test_stringify_and_symbolize_keys_on_indifferent_preserves_hash
    h = HashWithIndifferentAccess.new
    h[:first] = 1
    h = h.stringify_keys
    assert_equal 1, h["first"]
    h = HashWithIndifferentAccess.new
    h["first"] = 1
    h = h.symbolize_keys
    assert_equal 1, h[:first]
  end

  def test_deep_stringify_and_deep_symbolize_keys_on_indifferent_preserves_hash
    h = HashWithIndifferentAccess.new
    h[:first] = 1
    h = h.deep_stringify_keys
    assert_equal 1, h["first"]
    h = HashWithIndifferentAccess.new
    h["first"] = 1
    h = h.deep_symbolize_keys
    assert_equal 1, h[:first]
  end

  def test_to_options_on_indifferent_preserves_hash
    h = HashWithIndifferentAccess.new
    h["first"] = 1
    h.to_options!
    assert_equal 1, h["first"]
  end

  def test_to_options_on_indifferent_preserves_works_as_hash_with_dup
    h = HashWithIndifferentAccess.new(a: { b: "b" })
    dup = h.dup

    dup[:a][:c] = "c"
    assert_equal "c", h[:a][:c]
  end

  def test_indifferent_sub_hashes
    h = { "user" => { "id" => 5 } }.with_indifferent_access
    ["user", :user].each { |user| [:id, "id"].each { |id| assert_equal 5, h[user][id], "h[#{user.inspect}][#{id.inspect}] should be 5" } }

    h = { user: { id: 5 } }.with_indifferent_access
    ["user", :user].each { |user| [:id, "id"].each { |id| assert_equal 5, h[user][id], "h[#{user.inspect}][#{id.inspect}] should be 5" } }
  end

  def test_indifferent_duplication
    # Should preserve default value
    h = HashWithIndifferentAccess.new
    h.default = "1234"
    assert_equal h.default, h.dup.default

    # Should preserve class for subclasses
    h = IndifferentHash.new
    assert_equal h.class, h.dup.class
  end

  def test_nested_dig_indifferent_access
    data = { "this" => { "views" => 1234 } }.with_indifferent_access
    assert_equal 1234, data.dig(:this, :views)
  end

  def test_argless_default_with_existing_nil_key
    h = Hash.new(:default).merge(nil => "defined").with_indifferent_access

    assert_equal :default, h.default
  end

  def test_default_with_argument
    h = Hash.new { 5 }.merge(1 => 2).with_indifferent_access

    assert_equal 5, h.default(1)
  end

  def test_default_proc
    h = ActiveSupport::HashWithIndifferentAccess.new { |hash, key| key }

    assert_nil h.default
    assert_equal "foo", h.default("foo")
    assert_equal "foo", h.default(:foo)
  end

  def test_double_conversion_with_nil_key
    h = { nil => "defined" }.with_indifferent_access.with_indifferent_access

    assert_nil h[:undefined_key]
  end

  def test_assorted_keys_not_stringified
    original = { Object.new => 2, 1 => 2, [] => true }
    indiff = original.with_indifferent_access
    assert_not(indiff.keys.any? { |k| k.kind_of? String }, "A key was converted to a string!")
  end

  def test_deep_merge_on_indifferent_access
    hash_1 = HashWithIndifferentAccess.new(a: "a", b: "b", c: { c1: "c1", c2: "c2", c3: { d1: "d1" } })
    hash_2 = HashWithIndifferentAccess.new(a: 1, c: { c1: 2, c3: { d2: "d2" } })
    hash_3 = { a: 1, c: { c1: 2, c3: { d2: "d2" } } }
    expected = { "a" => 1, "b" => "b", "c" => { "c1" => 2, "c2" => "c2", "c3" => { "d1" => "d1", "d2" => "d2" } } }
    assert_equal expected, hash_1.deep_merge(hash_2)
    assert_equal expected, hash_1.deep_merge(hash_3)

    hash_1.deep_merge!(hash_2)
    assert_equal expected, hash_1
  end

  def test_store_on_indifferent_access
    hash = HashWithIndifferentAccess.new
    hash.store(:test1, 1)
    hash.store("test1", 11)
    hash[:test2] = 2
    hash["test2"] = 22
    expected = { "test1" => 11, "test2" => 22 }
    assert_equal expected, hash
  end

  def test_constructor_on_indifferent_access
    hash = HashWithIndifferentAccess[:foo, 1]
    assert_equal 1, hash[:foo]
    assert_equal 1, hash["foo"]
    hash[:foo] = 3
    assert_equal 3, hash[:foo]
    assert_equal 3, hash["foo"]
  end

  def test_indifferent_slice
    original = { a: "x", b: "y", c: 10 }.with_indifferent_access
    expected = { a: "x", b: "y" }.with_indifferent_access

    [["a", "b"], [:a, :b]].each do |keys|
      # Should return a new hash with only the given keys.
      assert_equal expected, original.slice(*keys), keys.inspect
      assert_not_equal expected, original
    end
  end

  def test_indifferent_slice_inplace
    original = { a: "x", b: "y", c: 10 }.with_indifferent_access
    expected = { c: 10 }.with_indifferent_access

    [["a", "b"], [:a, :b]].each do |keys|
      # Should replace the hash with only the given keys.
      copy = original.dup
      assert_equal expected, copy.slice!(*keys)
    end
  end

  def test_indifferent_slice_access_with_symbols
    original = { "login" => "bender", "password" => "shiny", "stuff" => "foo" }
    original = original.with_indifferent_access

    slice = original.slice(:login, :password)

    assert_equal "bender", slice[:login]
    assert_equal "bender", slice["login"]
  end

  def test_indifferent_without
    original = { a: "x", b: "y", c: 10 }.with_indifferent_access
    expected = { c: 10 }.with_indifferent_access

    [["a", "b"], [:a, :b]].each do |keys|
      # Should return a new hash without the given keys.
      assert_equal expected, original.without(*keys), keys.inspect
      assert_not_equal expected, original
    end
  end

  def test_indifferent_extract
    original = { :a => 1, "b" => 2, :c => 3, "d" => 4 }.with_indifferent_access
    expected = { a: 1, b: 2 }.with_indifferent_access
    remaining = { c: 3, d: 4 }.with_indifferent_access

    [["a", "b"], [:a, :b]].each do |keys|
      copy = original.dup
      assert_equal expected, copy.extract!(*keys)
      assert_equal remaining, copy
    end
  end

  def test_new_with_to_hash_conversion
    hash = HashWithIndifferentAccess.new(HashByConversion.new(a: 1))
    assert hash.key?("a")
    assert_equal 1, hash[:a]
  end

  def test_dup_with_default_proc
    hash = HashWithIndifferentAccess.new
    hash.default_proc = proc { |h, v| raise "walrus" }
    assert_nothing_raised { hash.dup }
  end

  def test_dup_with_default_proc_sets_proc
    hash = HashWithIndifferentAccess.new
    hash.default_proc = proc { |h, k| k + 1 }
    new_hash = hash.dup

    assert_equal 3, new_hash[2]

    new_hash.default = 2
    assert_equal 2, new_hash[:non_existent]
  end

  def test_to_hash_with_raising_default_proc
    hash = HashWithIndifferentAccess.new
    hash.default_proc = proc { |h, k| raise "walrus" }

    assert_nothing_raised { hash.to_hash }
  end

  def test_new_with_to_hash_conversion_copies_default
    normal_hash = Hash.new(3)
    normal_hash[:a] = 1

    hash = HashWithIndifferentAccess.new(HashByConversion.new(normal_hash))
    assert_equal 1, hash[:a]
    assert_equal 3, hash[:b]
  end

  def test_new_with_to_hash_conversion_copies_default_proc
    normal_hash = Hash.new { 1 + 2 }
    normal_hash[:a] = 1

    hash = HashWithIndifferentAccess.new(HashByConversion.new(normal_hash))
    assert_equal 1, hash[:a]
    assert_equal 3, hash[:b]
  end

  def test_inheriting_from_top_level_hash_with_indifferent_access_preserves_ancestors_chain
    klass = Class.new(::HashWithIndifferentAccess)
    assert_equal ActiveSupport::HashWithIndifferentAccess, klass.ancestors[1]
  end

  def test_inheriting_from_hash_with_indifferent_access_properly_dumps_ivars
    klass = Class.new(::HashWithIndifferentAccess) do
      def initialize(*)
        @foo = "bar"
        super
      end
    end

    yaml_output = klass.new.to_yaml

    # `hash-with-ivars` was introduced in 2.0.9 (https://git.io/vyUQW)
    if Gem::Version.new(Psych::VERSION) >= Gem::Version.new("2.0.9")
      assert_includes yaml_output, "hash-with-ivars"
      assert_includes yaml_output, "@foo: bar"
    else
      assert_includes yaml_output, "hash"
    end
  end

  def test_should_use_default_proc_for_unknown_key
    hash_wia = HashWithIndifferentAccess.new { 1 + 2 }
    assert_equal 3, hash_wia[:new_key]
  end

  def test_should_return_nil_if_no_key_is_supplied
    hash_wia = HashWithIndifferentAccess.new { 1 + 2 }
    assert_nil hash_wia.default
  end

  def test_should_use_default_value_for_unknown_key
    hash_wia = HashWithIndifferentAccess.new(3)
    assert_equal 3, hash_wia[:new_key]
  end

  def test_should_use_default_value_if_no_key_is_supplied
    hash_wia = HashWithIndifferentAccess.new(3)
    assert_equal 3, hash_wia.default
  end

  def test_should_nil_if_no_default_value_is_supplied
    hash_wia = HashWithIndifferentAccess.new
    assert_nil hash_wia.default
  end

  def test_should_return_dup_for_with_indifferent_access
    hash_wia = HashWithIndifferentAccess.new
    assert_equal hash_wia, hash_wia.with_indifferent_access
    assert_not_same hash_wia, hash_wia.with_indifferent_access
  end

  def test_allows_setting_frozen_array_values_with_indifferent_access
    value = [1, 2, 3].freeze
    hash = HashWithIndifferentAccess.new
    hash[:key] = value
    assert_equal hash[:key], value
  end

  def test_should_copy_the_default_value_when_converting_to_hash_with_indifferent_access
    hash = Hash.new(3)
    hash_wia = hash.with_indifferent_access
    assert_equal 3, hash_wia.default
  end

  def test_should_copy_the_default_proc_when_converting_to_hash_with_indifferent_access
    hash = Hash.new do
      2 + 1
    end
    assert_equal 3, hash[:foo]

    hash_wia = hash.with_indifferent_access
    assert_equal 3, hash_wia[:foo]
    assert_equal 3, hash_wia[:bar]
  end

  def test_should_copy_the_default_when_converting_non_hash_to_hash_with_indifferent_access
    non_hash = Object.new

    def non_hash.to_hash
      h = { foo: :bar }
      h.default = :baz
      h
    end

    hash_wia = HashWithIndifferentAccess.new(non_hash)
    assert_equal :bar, hash_wia[:foo]
    assert_equal :baz, hash_wia[:missing]
  end

  def test_should_copy_the_default_proc_when_converting_non_hash_to_hash_with_indifferent_access
    non_hash = Object.new

    def non_hash.to_hash
      h = { foo: :bar }
      h.default_proc = ->(hash, key) { hash[key] = :baz }
      h
    end

    hash_wia = HashWithIndifferentAccess.new(non_hash)
    assert_equal :bar, hash_wia[:foo]
    assert_equal :baz, hash_wia[:missing]
  end
# frozen_string_literal: true

require_relative "dependencies_test_helpers"

module Ace
  module Base
    class Case
      class Dice
      end
    end
    class Fase < Case
    end
  end
  class Gas
    include Base
  end
end

class Object
  module AddtlGlobalConstants
    class Case
      class Dice
      end
    end
  end
  include AddtlGlobalConstants
end

module ConstantizeTestCases
  include DependenciesTestHelpers

  def run_constantize_tests_on
    assert_equal Ace::Base::Case, yield("Ace::Base::Case")
    assert_equal Ace::Base::Case, yield("::Ace::Base::Case")
    assert_equal Ace::Base::Case::Dice, yield("Ace::Base::Case::Dice")
    assert_equal Ace::Base::Case::Dice, yield("Ace::Base::Fase::Dice")
    assert_equal Ace::Base::Fase::Dice, yield("Ace::Base::Fase::Dice")

    assert_equal Ace::Gas::Case, yield("Ace::Gas::Case")
    assert_equal Ace::Gas::Case::Dice, yield("Ace::Gas::Case::Dice")
    assert_equal Ace::Base::Case::Dice, yield("Ace::Gas::Case::Dice")

    assert_equal Case::Dice, yield("Case::Dice")
    assert_equal AddtlGlobalConstants::Case::Dice, yield("Case::Dice")
    assert_equal Object::AddtlGlobalConstants::Case::Dice, yield("Case::Dice")

    assert_equal Case::Dice, yield("Object::Case::Dice")
    assert_equal AddtlGlobalConstants::Case::Dice, yield("Object::Case::Dice")
    assert_equal Object::AddtlGlobalConstants::Case::Dice, yield("Case::Dice")

    assert_equal ConstantizeTestCases, yield("ConstantizeTestCases")
    assert_equal ConstantizeTestCases, yield("::ConstantizeTestCases")

    assert_raises(NameError) { yield("UnknownClass") }
    assert_raises(NameError) { yield("UnknownClass::Ace") }
    assert_raises(NameError) { yield("UnknownClass::Ace::Base") }
    assert_raises(NameError) { yield("An invalid string") }
    assert_raises(NameError) { yield("InvalidClass\n") }
    assert_raises(NameError) { yield("Ace::ConstantizeTestCases") }
    assert_raises(NameError) { yield("Ace::Base::ConstantizeTestCases") }
    assert_raises(NameError) { yield("Ace::Gas::Base") }
    assert_raises(NameError) { yield("Ace::Gas::ConstantizeTestCases") }
    assert_raises(NameError) { yield("") }
    assert_raises(NameError) { yield("::") }
    assert_raises(NameError) { yield("Ace::gas") }

    assert_raises(NameError) do
      with_autoloading_fixtures do
        yield("RaisesNameError")
      end
    end

    assert_raises(NoMethodError) do
      with_autoloading_fixtures do
        yield("RaisesNoMethodError")
      end
    end

    with_autoloading_fixtures do
      yield("Prepend::SubClassConflict")
      assert_equal "constant", defined?(Prepend::SubClassConflict)
    end
  end

  def run_safe_constantize_tests_on
    assert_equal Ace::Base::Case, yield("Ace::Base::Case")
    assert_equal Ace::Base::Case, yield("::Ace::Base::Case")
    assert_equal Ace::Base::Case::Dice, yield("Ace::Base::Case::Dice")
    assert_equal Ace::Base::Fase::Dice, yield("Ace::Base::Fase::Dice")
    assert_equal Ace::Gas::Case, yield("Ace::Gas::Case")
    assert_equal Ace::Gas::Case::Dice, yield("Ace::Gas::Case::Dice")
    assert_equal Case::Dice, yield("Case::Dice")
    assert_equal Case::Dice, yield("Object::Case::Dice")
    assert_equal ConstantizeTestCases, yield("ConstantizeTestCases")
    assert_equal ConstantizeTestCases, yield("::ConstantizeTestCases")
    assert_nil yield("")
    assert_nil yield("::")
    assert_nil yield("UnknownClass")
    assert_nil yield("UnknownClass::Ace")
    assert_nil yield("UnknownClass::Ace::Base")
    assert_nil yield("An invalid string")
    assert_nil yield("InvalidClass\n")
    assert_nil yield("blargle")
    assert_nil yield("Ace::ConstantizeTestCases")
    assert_nil yield("Ace::Base::ConstantizeTestCases")
    assert_nil yield("Ace::Gas::Base")
    assert_nil yield("Ace::Gas::ConstantizeTestCases")
    assert_nil yield("#<Class:0x7b8b718b>::Nested_1")
    assert_nil yield("Ace::gas")
    assert_nil yield("Object::ABC")
    assert_nil yield("Object::Object::Object::ABC")
    assert_nil yield("A::Object::B")
    assert_nil yield("A::Object::Object::Object::B")

    with_autoloading_fixtures do
      assert_nil yield("Em")
    end

    assert_raises(LoadError) do
      with_autoloading_fixtures do
        yield("RaisesLoadError")
      end
    end

    assert_raises(NameError) do
      with_autoloading_fixtures do
        yield("RaisesNameError")
      end
    end

    assert_raises(NoMethodError) do
      with_autoloading_fixtures do
        yield("RaisesNoMethodError")
      end
    end
# frozen_string_literal: true

module TimeZoneTestHelpers
  def with_tz_default(tz = nil)
    old_tz = Time.zone
    Time.zone = tz
    yield
  ensure
    Time.zone = old_tz
  end

  def with_env_tz(new_tz = "US/Eastern")
    old_tz, ENV["TZ"] = ENV["TZ"], new_tz
    yield
  ensure
    old_tz ? ENV["TZ"] = old_tz : ENV.delete("TZ")
  end

  def with_preserve_timezone(value)
    old_preserve_tz = ActiveSupport.to_time_preserves_timezone
    ActiveSupport.to_time_preserves_timezone = value
    yield
  ensure
    ActiveSupport.to_time_preserves_timezone = old_preserve_tz
  end

  def with_tz_mappings(mappings)
    old_mappings = ActiveSupport::TimeZone::MAPPING.dup
    ActiveSupport::TimeZone.clear
    ActiveSupport::TimeZone::MAPPING.clear
    ActiveSupport::TimeZone::MAPPING.merge!(mappings)

    yield
  ensure
    ActiveSupport::TimeZone.clear
    ActiveSupport::TimeZone::MAPPING.clear
    ActiveSupport::TimeZone::MAPPING.merge!(old_mappings)
  end

  def with_utc_to_local_returns_utc_offset_times(value)
    old_tzinfo2_format = ActiveSupport.utc_to_local_returns_utc_offset_times
    ActiveSupport.utc_to_local_returns_utc_offset_times = value
    yield
  ensure
    ActiveSupport.utc_to_local_returns_utc_offset_times = old_tzinfo2_format
# frozen_string_literal: true

require "active_support/concern"

module SomeConcern
  extend ActiveSupport::Concern

  included do
    # shouldn't raise when module is loaded more than once
  end
# frozen_string_literal: true

require_relative "abstract_unit"
require_relative "multibyte_test_helpers"
require "stringio"
require "fileutils"
require "tempfile"
require "tmpdir"
require "concurrent/atomics"

class LoggerTest < ActiveSupport::TestCase
  include MultibyteTestHelpers

  Logger = ActiveSupport::Logger

  def setup
    @message = "A debug message"
    @integer_message = 12345
    @output  = StringIO.new
    @logger  = Logger.new(@output)
  end

  def test_log_outputs_to
    assert Logger.logger_outputs_to?(@logger, @output),            "Expected logger_outputs_to? @output to return true but was false"
    assert Logger.logger_outputs_to?(@logger, @output, STDOUT),    "Expected logger_outputs_to? @output or STDOUT to return true but was false"

    assert_not Logger.logger_outputs_to?(@logger, STDOUT),         "Expected logger_outputs_to? to STDOUT to return false, but was true"
    assert_not Logger.logger_outputs_to?(@logger, STDOUT, STDERR), "Expected logger_outputs_to? to STDOUT or STDERR to return false, but was true"
  end

  def test_write_binary_data_to_existing_file
    t = Tempfile.new ["development", "log"]
    t.binmode
    t.write "hi mom!"
    t.close

    f = File.open(t.path, "w")
    f.binmode

    logger = Logger.new f
    logger.level = Logger::DEBUG

    str = +"\x80"
    str.force_encoding("ASCII-8BIT")

    logger.add Logger::DEBUG, str
  ensure
    logger.close
    t.close true
  end

  def test_write_binary_data_create_file
    fname = File.join Dir.tmpdir, "lol", "rofl.log"
    FileUtils.mkdir_p File.dirname(fname)
    f = File.open(fname, "w")
    f.binmode

    logger = Logger.new f
    logger.level = Logger::DEBUG

    str = +"\x80"
    str.force_encoding("ASCII-8BIT")

    logger.add Logger::DEBUG, str
  ensure
    logger.close
    File.unlink fname
  end

  def test_should_log_debugging_message_when_debugging
    @logger.level = Logger::DEBUG
    @logger.add(Logger::DEBUG, @message)
    assert_includes @output.string, @message
  end

  def test_should_not_log_debug_messages_when_log_level_is_info
    @logger.level = Logger::INFO
    @logger.add(Logger::DEBUG, @message)
    assert_not_includes @output.string, @message
  end

  def test_should_add_message_passed_as_block_when_using_add
    @logger.level = Logger::INFO
    @logger.add(Logger::INFO) { @message }
    assert_includes @output.string, @message
  end

  def test_should_add_message_passed_as_block_when_using_shortcut
    @logger.level = Logger::INFO
    @logger.info { @message }
    assert_includes @output.string, @message
  end

  def test_should_convert_message_to_string
    @logger.level = Logger::INFO
    @logger.info @integer_message
    assert_includes @output.string, @integer_message.to_s
  end

  def test_should_convert_message_to_string_when_passed_in_block
    @logger.level = Logger::INFO
    @logger.info { @integer_message }
    assert_includes @output.string, @integer_message.to_s
  end

  def test_should_not_evaluate_block_if_message_wont_be_logged
    @logger.level = Logger::INFO
    evaluated = false
    @logger.add(Logger::DEBUG) { evaluated = true }
    assert evaluated == false
  end

  def test_should_not_mutate_message
    message_copy = @message.dup
    @logger.info @message
    assert_equal message_copy, @message
  end

  def test_should_know_if_its_loglevel_is_below_a_given_level
    Logger::Severity.constants.each do |level|
      next if level.to_s == "UNKNOWN"
      @logger.level = Logger::Severity.const_get(level) - 1
      assert @logger.public_send("#{level.downcase}?"), "didn't know if it was #{level.downcase}? or below"
    end
  end

  def test_buffer_multibyte
    @logger.level = Logger::INFO
    @logger.info(UNICODE_STRING)
    @logger.info(BYTE_STRING)
    assert_includes @output.string, UNICODE_STRING
    byte_string = @output.string.dup
    byte_string.force_encoding("ASCII-8BIT")
    assert_includes byte_string, BYTE_STRING
  end

  def test_silencing_everything_but_errors
    @logger.silence do
      @logger.debug "NOT THERE"
      @logger.error "THIS IS HERE"
    end

    assert_not_includes @output.string, "NOT THERE"
    assert_includes @output.string, "THIS IS HERE"
  end

  def test_unsilencing
    @logger.level = Logger::INFO

    @logger.debug "NOT THERE"

    @logger.silence Logger::DEBUG do
      @logger.debug "THIS IS HERE"
    end

    assert_not_includes @output.string, "NOT THERE"
    assert_includes @output.string, "THIS IS HERE"
  end

  def test_logger_silencing_works_for_broadcast
    another_output  = StringIO.new
    another_logger  = ActiveSupport::Logger.new(another_output)

    @logger.extend ActiveSupport::Logger.broadcast(another_logger)

    @logger.debug "CORRECT DEBUG"
    @logger.silence do |logger|
      assert_kind_of ActiveSupport::Logger, logger
      @logger.debug "FAILURE"
      @logger.error "CORRECT ERROR"
    end

    assert_includes @output.string, "CORRECT DEBUG"
    assert_includes @output.string, "CORRECT ERROR"
    assert_not_includes @output.string, "FAILURE"

    assert_includes another_output.string, "CORRECT DEBUG"
    assert_includes another_output.string, "CORRECT ERROR"
    assert_not another_output.string.include?("FAILURE")
  end

  def test_broadcast_silencing_does_not_break_plain_ruby_logger
    another_output  = StringIO.new
    another_logger  = ::Logger.new(another_output)

    @logger.extend ActiveSupport::Logger.broadcast(another_logger)

    @logger.debug "CORRECT DEBUG"
    @logger.silence do |logger|
      assert_kind_of ActiveSupport::Logger, logger
      @logger.debug "FAILURE"
      @logger.error "CORRECT ERROR"
    end

    assert_includes @output.string, "CORRECT DEBUG"
    assert_includes @output.string, "CORRECT ERROR"
    assert_not_includes @output.string, "FAILURE"

    assert_includes another_output.string, "CORRECT DEBUG"
    assert_includes another_output.string, "CORRECT ERROR"
    assert_includes another_output.string, "FAILURE"
    # We can't silence plain ruby Logger cause with thread safety
    # but at least we don't break it
  end

  def test_logger_level_per_object_thread_safety
    logger1 = Logger.new(StringIO.new)
    logger2 = Logger.new(StringIO.new)

    level = Logger::DEBUG
    assert_equal level, logger1.level, "Expected level #{level_name(level)}, got #{level_name(logger1.level)}"
    assert_equal level, logger2.level, "Expected level #{level_name(level)}, got #{level_name(logger2.level)}"

    logger1.level = Logger::ERROR
    assert_equal level, logger2.level, "Expected level #{level_name(level)}, got #{level_name(logger2.level)}"
  end

  def test_logger_level_main_thread_safety
    @logger.level = Logger::INFO
    assert_level(Logger::INFO)

    latch  = Concurrent::CountDownLatch.new
    latch2 = Concurrent::CountDownLatch.new

    t = Thread.new do
      latch.wait
      assert_level(Logger::INFO)
      latch2.count_down
    end

    @logger.silence(Logger::ERROR) do
      assert_level(Logger::ERROR)
      latch.count_down
      latch2.wait
    end

    t.join
  end

  def test_logger_level_local_thread_safety
    @logger.level = Logger::INFO
    assert_level(Logger::INFO)

    thread_1_latch = Concurrent::CountDownLatch.new
    thread_2_latch = Concurrent::CountDownLatch.new

    threads = (1..2).collect do |thread_number|
      Thread.new do
        # force thread 2 to wait until thread 1 is already in @logger.silence
        thread_2_latch.wait if thread_number == 2

        @logger.silence(Logger::ERROR) do
          assert_level(Logger::ERROR)
          @logger.silence(Logger::DEBUG) do
            # allow thread 2 to finish but hold thread 1
            if thread_number == 1
              thread_2_latch.count_down
              thread_1_latch.wait
            end
            assert_level(Logger::DEBUG)
          end
        end

        # allow thread 1 to finish
        assert_level(Logger::INFO)
        thread_1_latch.count_down if thread_number == 2
      end
    end

    threads.each(&:join)
    assert_level(Logger::INFO)
  end

  def test_logger_level_main_fiber_safety
    @logger.level = Logger::INFO
    assert_level(Logger::INFO)

    fiber = Fiber.new do
      assert_level(Logger::INFO)
    end

    @logger.silence(Logger::ERROR) do
      assert_level(Logger::ERROR)
      fiber.resume
    end
  end

  def test_logger_level_local_fiber_safety
    @logger.level = Logger::INFO
    assert_level(Logger::INFO)

    another_fiber = Fiber.new do
      @logger.silence(Logger::ERROR) do
        assert_level(Logger::ERROR)
        @logger.silence(Logger::DEBUG) do
          assert_level(Logger::DEBUG)
        end
      end

      assert_level(Logger::INFO)
    end

    Fiber.new do
      @logger.silence(Logger::ERROR) do
        assert_level(Logger::ERROR)
        @logger.silence(Logger::DEBUG) do
          another_fiber.resume
          assert_level(Logger::DEBUG)
        end
      end

      assert_level(Logger::INFO)
    end.resume

    assert_level(Logger::INFO)
  end

  def test_temporarily_logging_at_a_noisier_level
    @logger.level = Logger::INFO

    @logger.debug "NOT THERE"

    @logger.log_at Logger::DEBUG do
      @logger.debug "THIS IS HERE"
    end

    @logger.debug "NOT THERE"

    assert_not_includes @output.string, "NOT THERE"
    assert_includes @output.string, "THIS IS HERE"
  end

  def test_temporarily_logging_at_a_quieter_level
    @logger.log_at Logger::ERROR do
      @logger.debug "NOT THERE"
      @logger.error "THIS IS HERE"
    end

    assert_not_includes @output.string, "NOT THERE"
    assert_includes @output.string, "THIS IS HERE"
  end

  def test_temporarily_logging_at_a_symbolic_level
    @logger.log_at :error do
      @logger.debug "NOT THERE"
      @logger.error "THIS IS HERE"
    end

    assert_not_includes @output.string, "NOT THERE"
    assert_includes @output.string, "THIS IS HERE"
  end

  private
    def level_name(level)
      ::Logger::Severity.constants.find do |severity|
        Logger.const_get(severity) == level
      end.to_s
    end

    def assert_level(level)
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/messages/rotation_configuration"

class MessagesRotationConfiguration < ActiveSupport::TestCase
  def setup
    @config = ActiveSupport::Messages::RotationConfiguration.new
  end

  def test_signed_configurations
    @config.rotate :signed, "older secret", salt: "salt", digest: "SHA1"
    @config.rotate :signed, "old secret", salt: "salt", digest: "SHA256"

    assert_equal [
      [ "older secret", salt: "salt", digest: "SHA1" ],
      [ "old secret", salt: "salt", digest: "SHA256" ] ], @config.signed
  end

  def test_encrypted_configurations
# frozen_string_literal: true

require_relative "../abstract_unit"
require "concurrent/atomic/count_down_latch"
require "active_support/concurrency/load_interlock_aware_monitor"

module ActiveSupport
  module Concurrency
    class LoadInterlockAwareMonitorTest < ActiveSupport::TestCase
      def setup
        @monitor = ActiveSupport::Concurrency::LoadInterlockAwareMonitor.new
      end

      def test_entering_with_no_blocking
        assert @monitor.mon_enter
      end

      def test_entering_with_blocking
        load_interlock_latch = Concurrent::CountDownLatch.new
        monitor_latch = Concurrent::CountDownLatch.new

        able_to_use_monitor = false
        able_to_load = false

        thread_with_load_interlock = Thread.new do
          ActiveSupport::Dependencies.interlock.running do
            load_interlock_latch.count_down
            monitor_latch.wait

            @monitor.synchronize do
              able_to_use_monitor = true
            end
          end
        end

        thread_with_monitor_lock = Thread.new do
          @monitor.synchronize do
            monitor_latch.count_down
            load_interlock_latch.wait

            ActiveSupport::Dependencies.interlock.loading do
              able_to_load = true
            end
          end
        end

        thread_with_load_interlock.join
        thread_with_monitor_lock.join

        assert able_to_use_monitor
# frozen_string_literal: true

module LoadsConstant
end

# frozen_string_literal: true

module HTML
  class SomeClass
  end
# frozen_string_literal: true

RaisesArbitraryException = 1
_ = A::B # Autoloading recursion, also expected to be watched and discarded.

# frozen_string_literal: true

Circular1

class Circular2
# frozen_string_literal: true

require "loaded_constant"

module RequiresConstant
# frozen_string_literal: true

class ClassFolder
  class NestedClass
  end
# frozen_string_literal: true

module ModuleFolder
  class NestedClass
  end
# frozen_string_literal: true

require "dependencies/module_folder/lib_class"

module ModuleFolder
# frozen_string_literal: true

$counting_loaded_times ||= 0
$counting_loaded_times += 1

# frozen_string_literal: true

silence_warnings do
  Circular2
end
# frozen_string_literal: true

class SubClassConflict
end

# frozen_string_literal: true

Throws = 1
_ = A::B # Autoloading recursion, expected to be discarded.

# frozen_string_literal: true

require "set"

module DescendantsTrackerTestCases
  class Parent
    extend ActiveSupport::DescendantsTracker
  end

  class Child1 < Parent
  end

  class Child2 < Parent
  end

  class Grandchild1 < Child1
  end

  class Grandchild2 < Child1
  end

  ALL = [Parent, Child1, Child2, Grandchild1, Grandchild2]

  def test_descendants
    assert_equal_sets [Child1, Grandchild1, Grandchild2, Child2], Parent.descendants
    assert_equal_sets [Grandchild1, Grandchild2], Child1.descendants
    assert_equal_sets [], Child2.descendants
  end

  def test_descendants_with_garbage_collected_classes
    1.times do
      child_klass = Class.new(Parent)
      assert_equal_sets [Child1, Grandchild1, Grandchild2, Child2, child_klass], Parent.descendants
    end
    GC.start
    assert_equal_sets [Child1, Grandchild1, Grandchild2, Child2], Parent.descendants
  end

  def test_direct_descendants
    assert_equal_sets [Child1, Child2], Parent.direct_descendants
    assert_equal_sets [Grandchild1, Grandchild2], Child1.direct_descendants
    assert_equal_sets [], Child2.direct_descendants
  end

  def test_subclasses
    [Parent, Child1, Child2].each do |klass|
      assert_equal klass.direct_descendants, klass.subclasses
    end
  end

  def test_clear
    mark_as_autoloaded(*ALL) do
      ActiveSupport::DescendantsTracker.clear
      ALL.each do |k|
        assert_empty ActiveSupport::DescendantsTracker.descendants(k)
      end
    end
  end

  private
    def assert_equal_sets(expected, actual)
      assert_equal Set.new(expected), Set.new(actual)
    end

    def mark_as_autoloaded(*klasses)
      # If ActiveSupport::Dependencies is not loaded, forget about autoloading.
      # This allows using AS::DescendantsTracker without AS::Dependencies.
      if defined? ActiveSupport::Dependencies
        old_autoloaded = ActiveSupport::Dependencies.autoloaded_constants.dup
        ActiveSupport::Dependencies.autoloaded_constants = klasses.map(&:name)
      end

      old_descendants = ActiveSupport::DescendantsTracker.class_eval("@@direct_descendants").dup
      old_descendants.each { |k, v| old_descendants[k] = v.dup }

      yield
    ensure
      ActiveSupport::Dependencies.autoloaded_constants = old_autoloaded if defined? ActiveSupport::Dependencies
      ActiveSupport::DescendantsTracker.class_eval("@@direct_descendants").replace(old_descendants)
    end
# frozen_string_literal: true

require_relative "abstract_unit"

begin
  require "openssl"
  OpenSSL::PKCS5
rescue LoadError, NameError
  $stderr.puts "Skipping KeyGenerator test: broken OpenSSL install"
else

  class KeyGeneratorTest < ActiveSupport::TestCase
    class InvalidDigest; end

    def setup
      @secret    = SecureRandom.hex(64)
      @generator = ActiveSupport::KeyGenerator.new(@secret, iterations: 2)
    end

    test "Generating a key of the default length" do
      derived_key = @generator.generate_key("some_salt")
      assert_kind_of String, derived_key
      assert_equal 64, derived_key.length, "Should have generated a key of the default size"
    end

    test "Generating a key of an alternative length" do
      derived_key = @generator.generate_key("some_salt", 32)
      assert_kind_of String, derived_key
      assert_equal 32, derived_key.length, "Should have generated a key of the right size"
    end

    test "Expected results" do
      # For any given set of inputs, this method must continue to return
      # the same output: if it changes, any existing values relying on a
      # key would break.

      expected = "b129376f68f1ecae788d7433310249d65ceec090ecacd4c872a3a9e9ec78e055739be5cc6956345d5ae38e7e1daa66f1de587dc8da2bf9e8b965af4b3918a122"
      assert_equal expected, ActiveSupport::KeyGenerator.new("0" * 64).generate_key("some_salt").unpack1("H*")

      expected = "b129376f68f1ecae788d7433310249d65ceec090ecacd4c872a3a9e9ec78e055"
      assert_equal expected, ActiveSupport::KeyGenerator.new("0" * 64).generate_key("some_salt", 32).unpack1("H*")

      expected = "cbea7f7f47df705967dc508f4e446fd99e7797b1d70011c6899cd39bbe62907b8508337d678505a7dc8184e037f1003ba3d19fc5d829454668e91d2518692eae"
      assert_equal expected, ActiveSupport::KeyGenerator.new("0" * 64, iterations: 2).generate_key("some_salt").unpack1("H*")
    end

    test "With custom hash digest class" do
      original_hash_digest_class = ActiveSupport::KeyGenerator.hash_digest_class

      ActiveSupport::KeyGenerator.hash_digest_class = ::OpenSSL::Digest::SHA256

      expected = "c92322ad55ee691520e8e0f279b53e7a5cc9c1f8efca98295ae252b04cc6e2274c3aaf75ef53b260a6dc548f3e5fbb8af0edf10e7663cf7054c35bcc12835fc0"
      assert_equal expected, ActiveSupport::KeyGenerator.new("0" * 64).generate_key("some_salt").unpack1("H*")
    ensure
      ActiveSupport::KeyGenerator.hash_digest_class = original_hash_digest_class
    end

    test "Raises if given a non digest instance" do
      assert_raises(ArgumentError) { ActiveSupport::KeyGenerator.hash_digest_class = InvalidDigest }
      assert_raises(ArgumentError) { ActiveSupport::KeyGenerator.hash_digest_class = InvalidDigest.new }
    end
  end

  class CachingKeyGeneratorTest < ActiveSupport::TestCase
    def setup
      @secret    = SecureRandom.hex(64)
      @generator = ActiveSupport::KeyGenerator.new(@secret, iterations: 2)
      @caching_generator = ActiveSupport::CachingKeyGenerator.new(@generator)
    end

    test "Generating a cached key for same salt and key size" do
      derived_key = @caching_generator.generate_key("some_salt", 32)
      cached_key = @caching_generator.generate_key("some_salt", 32)

      assert_equal derived_key, cached_key
      assert_equal derived_key.object_id, cached_key.object_id
    end

    test "Does not cache key for different salt" do
      derived_key = @caching_generator.generate_key("some_salt", 32)
      different_salt_key = @caching_generator.generate_key("other_salt", 32)

      assert_not_equal derived_key, different_salt_key
    end

    test "Does not cache key for different length" do
      derived_key = @caching_generator.generate_key("some_salt", 32)
      different_length_key = @caching_generator.generate_key("some_salt", 64)

      assert_not_equal derived_key, different_length_key
    end

    test "Does not cache key for different salts and lengths that are different but are equal when concatenated" do
      derived_key = @caching_generator.generate_key("13", 37)
      different_length_key = @caching_generator.generate_key("1", 337)

      assert_not_equal derived_key, different_length_key
    end
  end

# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/descendants_tracker"
require_relative "descendants_tracker_test_cases"

class DescendantsTrackerWithoutAutoloadingTest < ActiveSupport::TestCase
  include DescendantsTrackerTestCases

  # Regression test for #8422. https://github.com/rails/rails/issues/8442
  def test_clear_without_autoloaded_singleton_parent
    mark_as_autoloaded do
      parent_instance = Parent.new
      parent_instance.singleton_class.descendants
      ActiveSupport::DescendantsTracker.clear
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/xml_mini"
require "active_support/builder"
require "active_support/core_ext/hash"
require "active_support/core_ext/big_decimal"
require "active_support/core_ext/date/conversions"
require "yaml"

module XmlMiniTest
  class RenameKeyTest < ActiveSupport::TestCase
    def test_rename_key_dasherizes_by_default
      assert_equal "my-key", ActiveSupport::XmlMini.rename_key("my_key")
    end

    def test_rename_key_dasherizes_with_dasherize_true
      assert_equal "my-key", ActiveSupport::XmlMini.rename_key("my_key", dasherize: true)
    end

    def test_rename_key_does_nothing_with_dasherize_false
      assert_equal "my_key", ActiveSupport::XmlMini.rename_key("my_key", dasherize: false)
    end

    def test_rename_key_camelizes_with_camelize_true
      assert_equal "MyKey", ActiveSupport::XmlMini.rename_key("my_key", camelize: true)
    end

    def test_rename_key_lower_camelizes_with_camelize_lower
      assert_equal "myKey", ActiveSupport::XmlMini.rename_key("my_key", camelize: :lower)
    end

    def test_rename_key_lower_camelizes_with_camelize_upper
      assert_equal "MyKey", ActiveSupport::XmlMini.rename_key("my_key", camelize: :upper)
    end

    def test_rename_key_does_not_dasherize_leading_underscores
      assert_equal "_id", ActiveSupport::XmlMini.rename_key("_id")
    end

    def test_rename_key_with_leading_underscore_dasherizes_interior_underscores
      assert_equal "_my-key", ActiveSupport::XmlMini.rename_key("_my_key")
    end

    def test_rename_key_does_not_dasherize_trailing_underscores
      assert_equal "id_", ActiveSupport::XmlMini.rename_key("id_")
    end

    def test_rename_key_with_trailing_underscore_dasherizes_interior_underscores
      assert_equal "my-key_", ActiveSupport::XmlMini.rename_key("my_key_")
    end

    def test_rename_key_does_not_dasherize_multiple_leading_underscores
      assert_equal "__id", ActiveSupport::XmlMini.rename_key("__id")
    end

    def test_rename_key_does_not_dasherize_multiple_trailing_underscores
      assert_equal "id__", ActiveSupport::XmlMini.rename_key("id__")
    end
  end

  class ToTagTest < ActiveSupport::TestCase
    def assert_xml(xml)
      assert_equal xml, @options[:builder].target!
    end

    def setup
      @xml = ActiveSupport::XmlMini
      @options = { skip_instruct: true, builder: Builder::XmlMarkup.new }
    end

    test "#to_tag accepts a callable object and passes options with the builder" do
      @xml.to_tag(:some_tag, lambda { |o| o[:builder].br }, @options)
      assert_xml "<br/>"
    end

    test "#to_tag accepts a callable object and passes options and tag name" do
      @xml.to_tag(:tag, lambda { |o, t| o[:builder].b(t) }, @options)
      assert_xml "<b>tag</b>"
    end

    test "#to_tag accepts an object responding to #to_xml and passes the options, where :root is key" do
      obj = Object.new
      obj.instance_eval do
        def to_xml(options) options[:builder].yo(options[:root].to_s) end
      end

      @xml.to_tag(:tag, obj, @options)
      assert_xml "<yo>tag</yo>"
    end

    test "#to_tag accepts arbitrary objects responding to #to_str" do
      @xml.to_tag(:b, "Howdy", @options)
      assert_xml "<b>Howdy</b>"
    end

    test "#to_tag should use the type value in the options hash" do
      @xml.to_tag(:b, "blue", @options.merge(type: "color"))
      assert_xml("<b type=\"color\">blue</b>")
    end

    test "#to_tag accepts symbol types" do
      @xml.to_tag(:b, :name, @options)
      assert_xml("<b type=\"symbol\">name</b>")
    end

    test "#to_tag accepts boolean types" do
      @xml.to_tag(:b, true, @options)
      assert_xml("<b type=\"boolean\">true</b>")
    end

    test "#to_tag accepts float types" do
      @xml.to_tag(:b, 3.14, @options)
      assert_xml("<b type=\"float\">3.14</b>")
    end

    test "#to_tag accepts decimal types" do
      @xml.to_tag(:b, BigDecimal("1.2"), @options)
      assert_xml("<b type=\"decimal\">1.2</b>")
    end

    test "#to_tag accepts date types" do
      @xml.to_tag(:b, Date.new(2001, 2, 3), @options)
      assert_xml("<b type=\"date\">2001-02-03</b>")
    end

    test "#to_tag accepts datetime types" do
      @xml.to_tag(:b, DateTime.new(2001, 2, 3, 4, 5, 6, "+7"), @options)
      assert_xml("<b type=\"dateTime\">2001-02-03T04:05:06+07:00</b>")
    end

    test "#to_tag accepts time types" do
      @xml.to_tag(:b, Time.new(1993, 02, 24, 12, 0, 0, "+09:00"), @options)
      assert_xml("<b type=\"dateTime\">1993-02-24T12:00:00+09:00</b>")
    end

    test "#to_tag accepts array types" do
      @xml.to_tag(:b, ["first_name", "last_name"], @options)
      assert_xml("<b type=\"array\"><b>first_name</b><b>last_name</b></b>")
    end

    test "#to_tag accepts hash types" do
      @xml.to_tag(:b, { first_name: "Bob", last_name: "Marley" }, @options)
      assert_xml("<b><first-name>Bob</first-name><last-name>Marley</last-name></b>")
    end

    test "#to_tag should not add type when skip types option is set" do
      @xml.to_tag(:b, "Bob", @options.merge(skip_types: 1))
      assert_xml("<b>Bob</b>")
    end

    test "#to_tag should dasherize the space when passed a string with spaces as a key" do
      @xml.to_tag("New   York", 33, @options)
      assert_xml "<New---York type=\"integer\">33</New---York>"
    end

    test "#to_tag should dasherize the space when passed a symbol with spaces as a key" do
      @xml.to_tag(:"New   York", 33, @options)
      assert_xml "<New---York type=\"integer\">33</New---York>"
    end
  end

  class WithBackendTest < ActiveSupport::TestCase
    module REXML end
    module LibXML end
    module Nokogiri end

    setup do
      @xml, @default_backend = ActiveSupport::XmlMini, ActiveSupport::XmlMini.backend
    end

    teardown do
      ActiveSupport::XmlMini.backend = @default_backend
    end

    test "#with_backend should switch backend and then switch back" do
      @xml.backend = REXML
      @xml.with_backend(LibXML) do
        assert_equal LibXML, @xml.backend
        @xml.with_backend(Nokogiri) do
          assert_equal Nokogiri, @xml.backend
        end
        assert_equal LibXML, @xml.backend
      end
      assert_equal REXML, @xml.backend
    end

    test "backend switch inside #with_backend block" do
      @xml.with_backend(LibXML) do
        @xml.backend = REXML
        assert_equal REXML, @xml.backend
      end
      assert_equal REXML, @xml.backend
    end
  end

  class ThreadSafetyTest < ActiveSupport::TestCase
    module REXML end
    module LibXML end

    setup do
      @xml, @default_backend = ActiveSupport::XmlMini, ActiveSupport::XmlMini.backend
    end

    teardown do
      ActiveSupport::XmlMini.backend = @default_backend
    end

    test "#with_backend should be thread-safe" do
      @xml.backend = REXML
      t = Thread.new do
        @xml.with_backend(LibXML) { sleep 1 }
      end
      sleep 0.1 while t.status != "sleep"

      # We should get `old_backend` here even while another
      # thread is using `new_backend`.
      assert_equal REXML, @xml.backend
    end

    test "nested #with_backend should be thread-safe" do
      @xml.with_backend(REXML) do
        t = Thread.new do
          @xml.with_backend(LibXML) { sleep 1 }
        end
        sleep 0.1 while t.status != "sleep"

        assert_equal REXML, @xml.backend
      end
    end
  end

  class ParsingTest < ActiveSupport::TestCase
    def setup
      @parsing = ActiveSupport::XmlMini::PARSING
    end

    def test_symbol
      parser = @parsing["symbol"]
      assert_equal :symbol, parser.call("symbol")
      assert_equal :symbol, parser.call(:symbol)
      assert_equal :'123', parser.call(123)
      assert_raises(ArgumentError) { parser.call(Date.new(2013, 11, 12, 02, 11)) }
    end

    def test_date
      parser = @parsing["date"]
      assert_equal Date.new(2013, 11, 12), parser.call("2013-11-12T0211Z")
      assert_raises(TypeError) { parser.call(1384190018) }
      assert_raises(ArgumentError) { parser.call("not really a date") }
    end

    def test_datetime
      parser = @parsing["datetime"]
      assert_equal Time.new(2013, 11, 12, 02, 11, 00, 0), parser.call("2013-11-12T02:11:00Z")
      assert_equal DateTime.new(2013, 11, 12), parser.call("2013-11-12T0211Z")
      assert_equal DateTime.new(2013, 11, 12, 02, 11), parser.call("2013-11-12T02:11Z")
      assert_equal DateTime.new(2013, 11, 12, 02, 11), parser.call("2013-11-12T11:11+9")
      assert_raises(ArgumentError) { parser.call("1384190018") }
    end

    def test_integer
      parser = @parsing["integer"]
      assert_equal 123, parser.call(123)
      assert_equal 123, parser.call(123.003)
      assert_equal 123, parser.call("123")
      assert_equal 0, parser.call("")
      assert_raises(ArgumentError) { parser.call(Date.new(2013, 11, 12, 02, 11)) }
    end

    def test_float
      parser = @parsing["float"]
      assert_equal 123, parser.call("123")
      assert_equal 123.003, parser.call("123.003")
      assert_equal 123.0, parser.call("123,003")
      assert_equal 0.0, parser.call("")
      assert_equal 123, parser.call(123)
      assert_equal 123.05, parser.call(123.05)
      assert_raises(ArgumentError) { parser.call(Date.new(2013, 11, 12, 02, 11)) }
    end

    def test_decimal
      parser = @parsing["decimal"]
      assert_equal 123, parser.call("123")
      assert_equal 123.003, parser.call("123.003")
      assert_equal 123.0, parser.call("123,003")
      assert_equal 0.0, parser.call("")
      assert_equal 123, parser.call(123)
      assert_raises(ArgumentError) { parser.call(123.04) }
      assert_raises(ArgumentError) { parser.call(Date.new(2013, 11, 12, 02, 11)) }
    end

    def test_boolean
      parser = @parsing["boolean"]
      [1, true, "1"].each do |value|
        assert parser.call(value)
      end

      [0, false, "0"].each do |value|
        assert_not parser.call(value)
      end
    end

    def test_string
      parser = @parsing["string"]
      assert_equal "123", parser.call(123)
      assert_equal "123", parser.call("123")
      assert_equal "[]", parser.call("[]")
      assert_equal "[]", parser.call([])
      assert_equal "{}", parser.call({})
      assert_raises(ArgumentError) { parser.call(Date.new(2013, 11, 12, 02, 11)) }
    end

    def test_yaml
      yaml = <<YAML
product:
  - sku         : BL394D
    quantity    : 4
    description : Basketball
YAML
      expected = {
        "product" => [
          { "sku" => "BL394D", "quantity" => 4, "description" => "Basketball" }
        ]
      }
      parser = @parsing["yaml"]
      assert_equal(expected, parser.call(yaml))
      assert_equal({ 1 => "test" }, parser.call(1 => "test"))
      assert_equal({ "1 => 'test'" => nil }, parser.call("{1 => 'test'}"))
    end

    def test_base64Binary_and_binary
      base64 = <<BASE64
TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz
IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg
dGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu
dWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo
ZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=
BASE64
      expected_base64 = <<EXPECTED
Man is distinguished, not only by his reason, but by this singular passion from
other animals, which is a lust of the mind, that by a perseverance of delight
in the continued and indefatigable generation of knowledge, exceeds the short
vehemence of any carnal pleasure.
EXPECTED

      parser = @parsing["base64Binary"]
      assert_equal expected_base64.gsub(/\n/, " ").strip, parser.call(base64)
      parser.call("NON BASE64 INPUT")

      parser = @parsing["binary"]
      assert_equal expected_base64.gsub(/\n/, " ").strip, parser.call(base64, "encoding" => "base64")
      assert_equal "IGNORED INPUT", parser.call("IGNORED INPUT", {})
    end
  end
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/number_helper"
require "active_support/core_ext/string/output_safety"

module ActiveSupport
  module NumberHelper
    class NumberHelperTest < ActiveSupport::TestCase
      class TestClassWithInstanceNumberHelpers
        include ActiveSupport::NumberHelper
      end

      class TestClassWithClassNumberHelpers
        extend ActiveSupport::NumberHelper
      end

      def setup
        @instance_with_helpers = TestClassWithInstanceNumberHelpers.new
      end

      def kilobytes(number)
        number * 1024
      end

      def megabytes(number)
        kilobytes(number) * 1024
      end

      def gigabytes(number)
        megabytes(number) * 1024
      end

      def terabytes(number)
        gigabytes(number) * 1024
      end

      def petabytes(number)
        terabytes(number) * 1024
      end

      def exabytes(number)
        petabytes(number) * 1024
      end

      def test_number_to_phone
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal("555-1234", number_helper.number_to_phone(5551234))
          assert_equal("800-555-1212", number_helper.number_to_phone(8005551212))
          assert_equal("(800) 555-1212", number_helper.number_to_phone(8005551212, area_code: true))
          assert_equal("", number_helper.number_to_phone("", area_code: true))
          assert_equal("800 555 1212", number_helper.number_to_phone(8005551212, delimiter: " "))
          assert_equal("(800) 555-1212 x 123", number_helper.number_to_phone(8005551212, area_code: true, extension: 123))
          assert_equal("800-555-1212", number_helper.number_to_phone(8005551212, extension: "  "))
          assert_equal("555.1212", number_helper.number_to_phone(5551212, delimiter: "."))
          assert_equal("800-555-1212", number_helper.number_to_phone("8005551212"))
          assert_equal("+1-800-555-1212", number_helper.number_to_phone(8005551212, country_code: 1))
          assert_equal("+18005551212", number_helper.number_to_phone(8005551212, country_code: 1, delimiter: ""))
          assert_equal("22-555-1212", number_helper.number_to_phone(225551212))
          assert_equal("+45-22-555-1212", number_helper.number_to_phone(225551212, country_code: 45))
          assert_equal("(755) 6123-4567", number_helper.number_to_phone(75561234567, pattern: /(\d{3,4})(\d{4})(\d{4})/, area_code: true))
          assert_equal("133-1234-5678", number_helper.number_to_phone(13312345678, pattern: /(\d{3})(\d{4})(\d{4})/))
        end
      end

      def test_number_to_currency
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal("$1,234,567,890.50", number_helper.number_to_currency(1234567890.50))
          assert_equal("$1,234,567,890.51", number_helper.number_to_currency(1234567890.506))
          assert_equal("-$1,234,567,890.50", number_helper.number_to_currency(-1234567890.50))
          assert_equal("-$ 1,234,567,890.50", number_helper.number_to_currency(-1234567890.50, format: "%u %n"))
          assert_equal("($1,234,567,890.50)", number_helper.number_to_currency(-1234567890.50, negative_format: "(%u%n)"))
          assert_equal("$1,234,567,892", number_helper.number_to_currency(1234567891.50, precision: 0))
          assert_equal("$1,234,567,891", number_helper.number_to_currency(1234567891.50, precision: 0, round_mode: :down))
          assert_equal("$1,234,567,890.5", number_helper.number_to_currency(1234567890.50, precision: 1))
          assert_equal("&pound;1234567890,50", number_helper.number_to_currency(1234567890.50, unit: "&pound;", separator: ",", delimiter: ""))
          assert_equal("$1,234,567,890.50", number_helper.number_to_currency("1234567890.50"))
          assert_equal("1,234,567,890.50 K&#269;", number_helper.number_to_currency("1234567890.50", unit: "K&#269;", format: "%n %u"))
          assert_equal("1,234,567,890.50 - K&#269;", number_helper.number_to_currency("-1234567890.50", unit: "K&#269;", format: "%n %u", negative_format: "%n - %u"))
          assert_equal("0.00", number_helper.number_to_currency(+0.0, unit: "", negative_format: "(%n)"))
          assert_equal("$0", number_helper.number_to_currency(-0.456789, precision: 0))
          assert_equal("$1,11", number_helper.number_to_currency("1,11"))
          assert_equal("$0,11", number_helper.number_to_currency("0,11"))
          assert_equal("$,11", number_helper.number_to_currency(",11"))
          assert_equal("-$1,11", number_helper.number_to_currency("-1,11"))
          assert_equal("-$0,11", number_helper.number_to_currency("-0,11"))
          assert_equal("-$,11", number_helper.number_to_currency("-,11"))
        end
      end

      def test_number_to_percentage
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal("100.000%", number_helper.number_to_percentage(100))
          assert_equal("100%", number_helper.number_to_percentage(100, precision: 0))
          assert_equal("302.06%", number_helper.number_to_percentage(302.0574, precision: 2))
          assert_equal("302.05%", number_helper.number_to_percentage(302.0574, precision: 2, round_mode: :down))
          assert_equal("100.000%", number_helper.number_to_percentage("100"))
          assert_equal("1000.000%", number_helper.number_to_percentage("1000"))
          assert_equal("123.4%", number_helper.number_to_percentage(123.400, precision: 3, strip_insignificant_zeros: true))
          assert_equal("1.000,000%", number_helper.number_to_percentage(1000, delimiter: ".", separator: ","))
          assert_equal("1000.000  %", number_helper.number_to_percentage(1000, format: "%n  %"))
          assert_equal("98a%", number_helper.number_to_percentage("98a"))
          assert_equal("NaN%", number_helper.number_to_percentage(Float::NAN))
          assert_equal("Inf%", number_helper.number_to_percentage(Float::INFINITY))
          assert_equal("NaN%", number_helper.number_to_percentage(Float::NAN, precision: 0))
          assert_equal("Inf%", number_helper.number_to_percentage(Float::INFINITY, precision: 0))
          assert_equal("NaN%", number_helper.number_to_percentage(Float::NAN, precision: 1))
          assert_equal("Inf%", number_helper.number_to_percentage(Float::INFINITY, precision: 1))
          assert_equal("1000%", number_helper.number_to_percentage(1000, precision: nil))
          assert_equal("1000%", number_helper.number_to_percentage(1000, precision: nil))
          assert_equal("1000.1%", number_helper.number_to_percentage(1000.1, precision: nil))
          assert_equal("-0.13 %", number_helper.number_to_percentage("-0.13", precision: nil, format: "%n %"))
        end
      end

      def test_to_delimited
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal("12,345,678", number_helper.number_to_delimited(12345678))
          assert_equal("0", number_helper.number_to_delimited(0))
          assert_equal("123", number_helper.number_to_delimited(123))
          assert_equal("123,456", number_helper.number_to_delimited(123456))
          assert_equal("123,456.78", number_helper.number_to_delimited(123456.78))
          assert_equal("123,456.789", number_helper.number_to_delimited(123456.789))
          assert_equal("123,456.78901", number_helper.number_to_delimited(123456.78901))
          assert_equal("123,456,789.78901", number_helper.number_to_delimited(123456789.78901))
          assert_equal("0.78901", number_helper.number_to_delimited(0.78901))
          assert_equal("123,456.78", number_helper.number_to_delimited("123456.78"))
          assert_equal("1,23,456.78", number_helper.number_to_delimited("123456.78", delimiter_pattern: /(\d+?)(?=(\d\d)+(\d)(?!\d))/))
          assert_equal("123,456.78", number_helper.number_to_delimited("123456.78".html_safe))
        end
      end

      def test_to_delimited_with_options_hash
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "12 345 678", number_helper.number_to_delimited(12345678, delimiter: " ")
          assert_equal "12,345,678-05", number_helper.number_to_delimited(12345678.05, separator: "-")
          assert_equal "12.345.678,05", number_helper.number_to_delimited(12345678.05, separator: ",", delimiter: ".")
        end
      end

      def test_to_rounded
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal("-111.235", number_helper.number_to_rounded(-111.2346))
          assert_equal("111.235", number_helper.number_to_rounded(111.2346))
          assert_equal("31.83", number_helper.number_to_rounded(31.825, precision: 2))
          assert_equal("111.23", number_helper.number_to_rounded(111.2346, precision: 2))
          assert_equal("111.24", number_helper.number_to_rounded(111.2346, precision: 2, round_mode: :up))
          assert_equal("111.00", number_helper.number_to_rounded(111, precision: 2))
          assert_equal("111.235", number_helper.number_to_rounded("111.2346"))
          assert_equal("31.83", number_helper.number_to_rounded("31.825", precision: 2))
          assert_equal("3268", number_helper.number_to_rounded((32.6751 * 100.00), precision: 0))
          assert_equal("112", number_helper.number_to_rounded(111.50, precision: 0))
          assert_equal("1234567892", number_helper.number_to_rounded(1234567891.50, precision: 0))
          assert_equal("0", number_helper.number_to_rounded(0, precision: 0))
          assert_equal("0.00100", number_helper.number_to_rounded(0.001, precision: 5))
          assert_equal("0.001", number_helper.number_to_rounded(0.00111, precision: 3))
          assert_equal("10.00", number_helper.number_to_rounded(9.995, precision: 2))
          assert_equal("11.00", number_helper.number_to_rounded(10.995, precision: 2))
          assert_equal("0.00", number_helper.number_to_rounded(-0.001, precision: 2))

          assert_equal("111.23460000000000000000", number_helper.number_to_rounded(111.2346, precision: 20))
          assert_equal("111.23460000000000000000", number_helper.number_to_rounded(Rational(1112346, 10000), precision: 20))
          assert_equal("111.23460000000000000000", number_helper.number_to_rounded("111.2346", precision: 20))
          assert_equal("111.23460000000000000000", number_helper.number_to_rounded(BigDecimal(111.2346, Float::DIG), precision: 20))
          assert_equal("111.2346" + "0" * 96, number_helper.number_to_rounded("111.2346", precision: 100))
          assert_equal("111.2346", number_helper.number_to_rounded(Rational(1112346, 10000), precision: 4))
          assert_equal("0.00", number_helper.number_to_rounded(Rational(0, 1), precision: 2))
        end
      end

      def test_to_rounded_with_custom_delimiter_and_separator
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "31,83",       number_helper.number_to_rounded(31.825, precision: 2, separator: ",")
          assert_equal "1.231,83",    number_helper.number_to_rounded(1231.825, precision: 2, separator: ",", delimiter: ".")
        end
      end

      def test_to_rounded_with_significant_digits
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "124000", number_helper.number_to_rounded(123987, precision: 3, significant: true)
          assert_equal "120000000", number_helper.number_to_rounded(123987876, precision: 2, significant: true)
          assert_equal "40000", number_helper.number_to_rounded("43523", precision: 1, significant: true)
          assert_equal "9775", number_helper.number_to_rounded(9775, precision: 4, significant: true)
          assert_equal "5.4", number_helper.number_to_rounded(5.3923, precision: 2, significant: true)
          assert_equal "5", number_helper.number_to_rounded(5.3923, precision: 1, significant: true)
          assert_equal "1", number_helper.number_to_rounded(1.232, precision: 1, significant: true)
          assert_equal "7", number_helper.number_to_rounded(7, precision: 1, significant: true)
          assert_equal "1", number_helper.number_to_rounded(1, precision: 1, significant: true)
          assert_equal "53", number_helper.number_to_rounded(52.7923, precision: 2, significant: true)
          assert_equal "9775.00", number_helper.number_to_rounded(9775, precision: 6, significant: true)
          assert_equal "5.392900", number_helper.number_to_rounded(5.3929, precision: 7, significant: true)
          assert_equal "0.0", number_helper.number_to_rounded(0, precision: 2, significant: true)
          assert_equal "0", number_helper.number_to_rounded(0, precision: 1, significant: true)
          assert_equal "0.0001", number_helper.number_to_rounded(0.0001, precision: 1, significant: true)
          assert_equal "0.000100", number_helper.number_to_rounded(0.0001, precision: 3, significant: true)
          assert_equal "0.0001", number_helper.number_to_rounded(0.0001111, precision: 1, significant: true)
          assert_equal "10.0", number_helper.number_to_rounded(9.995, precision: 3, significant: true)
          assert_equal "9.99", number_helper.number_to_rounded(9.994, precision: 3, significant: true)
          assert_equal "11.0", number_helper.number_to_rounded(10.995, precision: 3, significant: true)
          assert_equal "123000", number_helper.number_to_rounded(123987, precision: 3, significant: true, round_mode: :down)

          assert_equal "9775.0000000000000000", number_helper.number_to_rounded(9775, precision: 20, significant: true)
          assert_equal "9775.0000000000000000", number_helper.number_to_rounded(9775.0, precision: 20, significant: true)
          assert_equal "9775.0000000000000000", number_helper.number_to_rounded(Rational(9775, 1), precision: 20, significant: true)
          assert_equal "97.750000000000000000", number_helper.number_to_rounded(Rational(9775, 100), precision: 20, significant: true)
          assert_equal "9775.0000000000000000", number_helper.number_to_rounded(BigDecimal(9775), precision: 20, significant: true)
          assert_equal "9775.0000000000000000", number_helper.number_to_rounded("9775", precision: 20, significant: true)
          assert_equal "9775." + "0" * 96, number_helper.number_to_rounded("9775", precision: 100, significant: true)
          assert_equal("97.7", number_helper.number_to_rounded(Rational(9772, 100), precision: 3, significant: true))
        end
      end

      def test_to_rounded_with_strip_insignificant_zeros
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "9775.43", number_helper.number_to_rounded(9775.43, precision: 4, strip_insignificant_zeros: true)
          assert_equal "9775.2", number_helper.number_to_rounded(9775.2, precision: 6, significant: true, strip_insignificant_zeros: true)
          assert_equal "0", number_helper.number_to_rounded(0, precision: 6, significant: true, strip_insignificant_zeros: true)
        end
      end

      def test_to_rounded_with_significant_true_and_zero_precision
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          # Zero precision with significant is a mistake (would always return zero),
          # so we treat it as if significant was false (increases backwards compatibility for number_to_human_size)
          assert_equal "124", number_helper.number_to_rounded(123.987, precision: 0, significant: true)
          assert_equal "12", number_helper.number_to_rounded(12, precision: 0, significant: true)
          assert_equal "12", number_helper.number_to_rounded("12.3", precision: 0, significant: true)
        end
      end

      def test_number_number_to_human_size
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "0 Bytes",   number_helper.number_to_human_size(0)
          assert_equal "1 Byte",    number_helper.number_to_human_size(1)
          assert_equal "3 Bytes",   number_helper.number_to_human_size(3.14159265)
          assert_equal "123 Bytes", number_helper.number_to_human_size(123.0)
          assert_equal "123 Bytes", number_helper.number_to_human_size(123)
          assert_equal "1.21 KB",    number_helper.number_to_human_size(1234)
          assert_equal "12.1 KB",   number_helper.number_to_human_size(12345)
          assert_equal "1.18 MB",    number_helper.number_to_human_size(1234567)
          assert_equal "1.15 GB",    number_helper.number_to_human_size(1234567890)
          assert_equal "1.12 TB",    number_helper.number_to_human_size(1234567890123)
          assert_equal "1.1 PB",   number_helper.number_to_human_size(1234567890123456)
          assert_equal "1.07 EB",   number_helper.number_to_human_size(1234567890123456789)
          assert_equal "1030 EB",   number_helper.number_to_human_size(exabytes(1026))
          assert_equal "444 KB",    number_helper.number_to_human_size(kilobytes(444))
          assert_equal "1020 MB",   number_helper.number_to_human_size(megabytes(1023))
          assert_equal "3 TB",      number_helper.number_to_human_size(terabytes(3))
          assert_equal "1.2 MB",   number_helper.number_to_human_size(1234567, precision: 2)
          assert_equal "1.1 MB",   number_helper.number_to_human_size(1234567, precision: 2, round_mode: :down)
          assert_equal "3 Bytes",   number_helper.number_to_human_size(3.14159265, precision: 4)
          assert_equal "123 Bytes", number_helper.number_to_human_size("123")
          assert_equal "1 KB",   number_helper.number_to_human_size(kilobytes(1.0123), precision: 2)
          assert_equal "1.01 KB",   number_helper.number_to_human_size(kilobytes(1.0100), precision: 4)
          assert_equal "10 KB",   number_helper.number_to_human_size(kilobytes(10.000), precision: 4)
          assert_equal "1 Byte",   number_helper.number_to_human_size(1.1)
          assert_equal "10 Bytes", number_helper.number_to_human_size(10)
        end
      end

      def test_number_to_human_size_with_options_hash
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "1.2 MB",   number_helper.number_to_human_size(1234567, precision: 2)
          assert_equal "3 Bytes",   number_helper.number_to_human_size(3.14159265, precision: 4)
          assert_equal "1 KB",   number_helper.number_to_human_size(kilobytes(1.0123), precision: 2)
          assert_equal "1.01 KB",   number_helper.number_to_human_size(kilobytes(1.0100), precision: 4)
          assert_equal "10 KB",     number_helper.number_to_human_size(kilobytes(10.000), precision: 4)
          assert_equal "1 TB", number_helper.number_to_human_size(1234567890123, precision: 1)
          assert_equal "500 MB", number_helper.number_to_human_size(524288000, precision: 3)
          assert_equal "10 MB", number_helper.number_to_human_size(9961472, precision: 0)
          assert_equal "40 KB", number_helper.number_to_human_size(41010, precision: 1)
          assert_equal "40 KB", number_helper.number_to_human_size(41100, precision: 2)
          assert_equal "50 KB", number_helper.number_to_human_size(41100, precision: 1, round_mode: :up)
          assert_equal "1.0 KB",   number_helper.number_to_human_size(kilobytes(1.0123), precision: 2, strip_insignificant_zeros: false)
          assert_equal "1.012 KB",   number_helper.number_to_human_size(kilobytes(1.0123), precision: 3, significant: false)
          assert_equal "1 KB",   number_helper.number_to_human_size(kilobytes(1.0123), precision: 0, significant: true) # ignores significant it precision is 0
        end
      end

      def test_number_to_human_size_with_custom_delimiter_and_separator
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "1,01 KB",     number_helper.number_to_human_size(kilobytes(1.0123), precision: 3, separator: ",")
          assert_equal "1,01 KB",     number_helper.number_to_human_size(kilobytes(1.0100), precision: 4, separator: ",")
          assert_equal "1.000,1 TB",  number_helper.number_to_human_size(terabytes(1000.1), precision: 5, delimiter: ".", separator: ",")
        end
      end

      def test_number_to_human
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "-123", number_helper.number_to_human(-123)
          assert_equal "-0.5", number_helper.number_to_human(-0.5)
          assert_equal "0",   number_helper.number_to_human(0)
          assert_equal "0.5", number_helper.number_to_human(0.5)
          assert_equal "123", number_helper.number_to_human(123)
          assert_equal "1.23 Thousand", number_helper.number_to_human(1234)
          assert_equal "12.3 Thousand", number_helper.number_to_human(12345)
          assert_equal "1.23 Million", number_helper.number_to_human(1234567)
          assert_equal "1.23 Billion", number_helper.number_to_human(1234567890)
          assert_equal "1.23 Trillion", number_helper.number_to_human(1234567890123)
          assert_equal "1.23 Quadrillion", number_helper.number_to_human(1234567890123456)
          assert_equal "1230 Quadrillion", number_helper.number_to_human(1234567890123456789)
          assert_equal "490 Thousand", number_helper.number_to_human(489939, precision: 2)
          assert_equal "489.9 Thousand", number_helper.number_to_human(489939, precision: 4)
          assert_equal "489 Thousand", number_helper.number_to_human(489000, precision: 4)
          assert_equal "480 Thousand", number_helper.number_to_human(489939, precision: 2, round_mode: :down)
          assert_equal "489.0 Thousand", number_helper.number_to_human(489000, precision: 4, strip_insignificant_zeros: false)
          assert_equal "1.2346 Million", number_helper.number_to_human(1234567, precision: 4, significant: false)
          assert_equal "1,2 Million", number_helper.number_to_human(1234567, precision: 1, significant: false, separator: ",")
          assert_equal "1 Million", number_helper.number_to_human(1234567, precision: 0, significant: true, separator: ",") # significant forced to false
          assert_equal "1 Million", number_helper.number_to_human(999999)
          assert_equal "1 Billion", number_helper.number_to_human(999999999)
        end
      end

      def test_number_to_human_with_custom_units
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          # Only integers
          volume = { unit: "ml", thousand: "lt", million: "m3" }
          assert_equal "123 lt", number_helper.number_to_human(123456, units: volume)
          assert_equal "12 ml", number_helper.number_to_human(12, units: volume)
          assert_equal "1.23 m3", number_helper.number_to_human(1234567, units: volume)

          # Including fractionals
          distance = { mili: "mm", centi: "cm", deci: "dm", unit: "m", ten: "dam", hundred: "hm", thousand: "km" }
          assert_equal "1.23 mm", number_helper.number_to_human(0.00123, units: distance)
          assert_equal "1.23 cm", number_helper.number_to_human(0.0123, units: distance)
          assert_equal "1.23 dm", number_helper.number_to_human(0.123, units: distance)
          assert_equal "1.23 m", number_helper.number_to_human(1.23, units: distance)
          assert_equal "1.23 dam", number_helper.number_to_human(12.3, units: distance)
          assert_equal "1.23 hm", number_helper.number_to_human(123, units: distance)
          assert_equal "1.23 km", number_helper.number_to_human(1230, units: distance)
          assert_equal "1.23 km", number_helper.number_to_human(1230, units: distance)
          assert_equal "1.23 km", number_helper.number_to_human(1230, units: distance)
          assert_equal "12.3 km", number_helper.number_to_human(12300, units: distance)

          # The quantifiers don't need to be a continuous sequence
          gangster = { hundred: "hundred bucks", million: "thousand quids" }
          assert_equal "1 hundred bucks", number_helper.number_to_human(100, units: gangster)
          assert_equal "25 hundred bucks", number_helper.number_to_human(2500, units: gangster)
          assert_equal "1000 hundred bucks", number_helper.number_to_human(100_000, units: gangster)
          assert_equal "1 thousand quids", number_helper.number_to_human(999_999, units: gangster)
          assert_equal "1 thousand quids", number_helper.number_to_human(1_000_000, units: gangster)
          assert_equal "25 thousand quids", number_helper.number_to_human(25000000, units: gangster)
          assert_equal "12300 thousand quids", number_helper.number_to_human(12345000000, units: gangster)

          # Spaces are stripped from the resulting string
          assert_equal "4", number_helper.number_to_human(4, units: { unit: "", ten: "tens " })
          assert_equal "4.5  tens", number_helper.number_to_human(45, units: { unit: "", ten: " tens   " })

          # Uses only the provided units and does not try to use larger ones
          assert_equal "1000 kilometers", number_helper.number_to_human(1_000_000, units: { unit: "meter", thousand: "kilometers" })
        end
      end

      def test_number_to_human_with_custom_units_that_are_missing_the_needed_key
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "123", number_helper.number_to_human(123, units: { thousand: "k" })
          assert_equal "123", number_helper.number_to_human(123, units: {})
        end
      end

      def test_number_to_human_with_custom_format
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal "123 times Thousand", number_helper.number_to_human(123456, format: "%n times %u")
          volume = { unit: "ml", thousand: "lt", million: "m3" }
          assert_equal "123.lt", number_helper.number_to_human(123456, units: volume, format: "%n.%u")
        end
      end

      def test_number_helpers_should_return_nil_when_given_nil
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_nil number_helper.number_to_phone(nil)
          assert_nil number_helper.number_to_currency(nil)
          assert_nil number_helper.number_to_percentage(nil)
          assert_nil number_helper.number_to_delimited(nil)
          assert_nil number_helper.number_to_rounded(nil)
          assert_nil number_helper.number_to_human_size(nil)
          assert_nil number_helper.number_to_human(nil)
        end
      end

      def test_number_helpers_do_not_mutate_options_hash
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          options = { "raise" => true }

          number_helper.number_to_phone(1, options)
          assert_equal({ "raise" => true }, options)

          number_helper.number_to_currency(1, options)
          assert_equal({ "raise" => true }, options)

          number_helper.number_to_percentage(1, options)
          assert_equal({ "raise" => true }, options)

          number_helper.number_to_delimited(1, options)
          assert_equal({ "raise" => true }, options)

          number_helper.number_to_rounded(1, options)
          assert_equal({ "raise" => true }, options)

          number_helper.number_to_human_size(1, options)
          assert_equal({ "raise" => true }, options)

          number_helper.number_to_human(1, options)
          assert_equal({ "raise" => true }, options)
        end
      end

      def test_number_helpers_should_return_non_numeric_param_unchanged
        [@instance_with_helpers, TestClassWithClassNumberHelpers, ActiveSupport::NumberHelper].each do |number_helper|
          assert_equal("+1-x x 123", number_helper.number_to_phone("x", country_code: 1, extension: 123))
          assert_equal("x", number_helper.number_to_phone("x"))
          assert_equal("$x.", number_helper.number_to_currency("x."))
          assert_equal("$x", number_helper.number_to_currency("x"))
          assert_equal("x%", number_helper.number_to_percentage("x"))
          assert_equal("x", number_helper.number_to_delimited("x"))
          assert_equal("x.", number_helper.number_to_rounded("x."))
          assert_equal("x", number_helper.number_to_rounded("x"))
          assert_equal "x", number_helper.number_to_human_size("x")
          assert_equal "x", number_helper.number_to_human("x")
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/inflector"

require_relative "inflector_test_cases"
require_relative "constantize_test_cases"

class InflectorTest < ActiveSupport::TestCase
  include InflectorTestCases
  include ConstantizeTestCases

  def setup
    # Dups the singleton before each test, restoring the original inflections later.
    #
    # This helper is implemented by setting @__instance__ because in some tests
    # there are module functions that access ActiveSupport::Inflector.inflections,
    # so we need to replace the singleton itself.
    @original_inflections = ActiveSupport::Inflector::Inflections.instance_variable_get(:@__instance__)[:en]
    ActiveSupport::Inflector::Inflections.instance_variable_set(:@__instance__, en: @original_inflections.dup)
  end

  def teardown
    ActiveSupport::Inflector::Inflections.instance_variable_set(:@__instance__, en: @original_inflections)
  end

  def test_pluralize_plurals
    assert_equal "plurals", ActiveSupport::Inflector.pluralize("plurals")
    assert_equal "Plurals", ActiveSupport::Inflector.pluralize("Plurals")
  end

  def test_pluralize_empty_string
    assert_equal "", ActiveSupport::Inflector.pluralize("")
  end

  def test_pluralize_with_fallback
    I18n.stub(:default_locale, :"en-GB") do
      assert_equal "days", ActiveSupport::Inflector.pluralize("day")
    end
  end

  test "uncountability of ascii word" do
    word = "HTTP"
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.uncountable word
    end

    assert_equal word, ActiveSupport::Inflector.pluralize(word)
    assert_equal word, ActiveSupport::Inflector.singularize(word)
    assert_equal ActiveSupport::Inflector.pluralize(word), ActiveSupport::Inflector.singularize(word)

    ActiveSupport::Inflector.inflections.uncountables.pop
  end

  test "uncountability of non-ascii word" do
    word = ""
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.uncountable word
    end

    assert_equal word, ActiveSupport::Inflector.pluralize(word)
    assert_equal word, ActiveSupport::Inflector.singularize(word)
    assert_equal ActiveSupport::Inflector.pluralize(word), ActiveSupport::Inflector.singularize(word)

    ActiveSupport::Inflector.inflections.uncountables.pop
  end

  ActiveSupport::Inflector.inflections.uncountable.each do |word|
    define_method "test_uncountability_of_#{word}" do
      assert_equal word, ActiveSupport::Inflector.singularize(word)
      assert_equal word, ActiveSupport::Inflector.pluralize(word)
      assert_equal ActiveSupport::Inflector.pluralize(word), ActiveSupport::Inflector.singularize(word)
    end
  end

  def test_uncountable_word_is_not_greedy
    uncountable_word = "ors"
    countable_word = "sponsor"

    ActiveSupport::Inflector.inflections.uncountable << uncountable_word

    assert_equal uncountable_word, ActiveSupport::Inflector.singularize(uncountable_word)
    assert_equal uncountable_word, ActiveSupport::Inflector.pluralize(uncountable_word)
    assert_equal ActiveSupport::Inflector.pluralize(uncountable_word), ActiveSupport::Inflector.singularize(uncountable_word)

    assert_equal "sponsor", ActiveSupport::Inflector.singularize(countable_word)
    assert_equal "sponsors", ActiveSupport::Inflector.pluralize(countable_word)
    assert_equal "sponsor", ActiveSupport::Inflector.singularize(ActiveSupport::Inflector.pluralize(countable_word))
  end

  SingularToPlural.each do |singular, plural|
    define_method "test_pluralize_singular_#{singular}" do
      assert_equal(plural, ActiveSupport::Inflector.pluralize(singular))
      assert_equal(plural.capitalize, ActiveSupport::Inflector.pluralize(singular.capitalize))
    end
  end

  SingularToPlural.each do |singular, plural|
    define_method "test_singularize_plural_#{plural}" do
      assert_equal(singular, ActiveSupport::Inflector.singularize(plural))
      assert_equal(singular.capitalize, ActiveSupport::Inflector.singularize(plural.capitalize))
    end
  end

  SingularToPlural.each do |singular, plural|
    define_method "test_pluralize_plural_#{plural}" do
      assert_equal(plural, ActiveSupport::Inflector.pluralize(plural))
      assert_equal(plural.capitalize, ActiveSupport::Inflector.pluralize(plural.capitalize))
    end

    define_method "test_singularize_singular_#{singular}" do
      assert_equal(singular, ActiveSupport::Inflector.singularize(singular))
      assert_equal(singular.capitalize, ActiveSupport::Inflector.singularize(singular.capitalize))
    end
  end

  def test_overwrite_previous_inflectors
    assert_equal("series", ActiveSupport::Inflector.singularize("series"))
    ActiveSupport::Inflector.inflections.singular "series", "serie"
    assert_equal("serie", ActiveSupport::Inflector.singularize("series"))
  end

  MixtureToTitleCase.each_with_index do |(before, titleized), index|
    define_method "test_titleize_mixture_to_title_case_#{index}" do
      assert_equal(titleized, ActiveSupport::Inflector.titleize(before), "mixture \
        to TitleCase failed for #{before}")
    end
  end

  MixtureToTitleCaseWithKeepIdSuffix.each_with_index do |(before, titleized), index|
    define_method "test_titleize_with_keep_id_suffix_mixture_to_title_case_#{index}" do
      assert_equal(titleized, ActiveSupport::Inflector.titleize(before, keep_id_suffix: true),
        "mixture to TitleCase with keep_id_suffix failed for #{before}")
    end
  end

  def test_camelize
    CamelToUnderscore.each do |camel, underscore|
      assert_equal(camel, ActiveSupport::Inflector.camelize(underscore))
    end
  end

  def test_camelize_with_true_upcases_the_first_letter
    assert_equal("Capital", ActiveSupport::Inflector.camelize("Capital", true))
    assert_equal("Capital", ActiveSupport::Inflector.camelize("capital", true))
  end

  def test_camelize_with_upper_upcases_the_first_letter
    assert_equal("Capital", ActiveSupport::Inflector.camelize("Capital", :upper))
    assert_equal("Capital", ActiveSupport::Inflector.camelize("capital", :upper))
  end

  def test_camelize_with_false_downcases_the_first_letter
    assert_equal("capital", ActiveSupport::Inflector.camelize("Capital", false))
    assert_equal("capital", ActiveSupport::Inflector.camelize("capital", false))
  end

  def test_camelize_with_nil_downcases_the_first_letter
    assert_equal("capital", ActiveSupport::Inflector.camelize("Capital", nil))
    assert_equal("capital", ActiveSupport::Inflector.camelize("capital", nil))
  end

  def test_camelize_with_lower_downcases_the_first_letter
    assert_equal("capital", ActiveSupport::Inflector.camelize("Capital", :lower))
    assert_equal("capital", ActiveSupport::Inflector.camelize("capital", :lower))
  end

  def test_camelize_with_any_other_arg_upcases_the_first_letter
    assert_equal("Capital", ActiveSupport::Inflector.camelize("capital", :true))
    assert_equal("Capital", ActiveSupport::Inflector.camelize("Capital", :true))

    assert_equal("Capital", ActiveSupport::Inflector.camelize("capital", :false))
    assert_equal("Capital", ActiveSupport::Inflector.camelize("capital", :foo))
    assert_equal("Capital", ActiveSupport::Inflector.camelize("capital", 42))
    assert_equal("Capital", ActiveSupport::Inflector.camelize("capital"))
  end

  def test_camelize_with_underscores
    assert_equal("CamelCase", ActiveSupport::Inflector.camelize("Camel_Case"))
  end

  def test_acronyms
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.acronym("API")
      inflect.acronym("HTML")
      inflect.acronym("HTTP")
      inflect.acronym("RESTful")
      inflect.acronym("W3C")
      inflect.acronym("PhD")
      inflect.acronym("RoR")
      inflect.acronym("SSL")
    end

    #  camelize             underscore            humanize              titleize
    [
      ["API",               "api",                "API",                "API"],
      ["APIController",     "api_controller",     "API controller",     "API Controller"],
      ["Nokogiri::HTML",    "nokogiri/html",      "Nokogiri/HTML",      "Nokogiri/HTML"],
      ["HTTPAPI",           "http_api",           "HTTP API",           "HTTP API"],
      ["HTTP::Get",         "http/get",           "HTTP/get",           "HTTP/Get"],
      ["SSLError",          "ssl_error",          "SSL error",          "SSL Error"],
      ["RESTful",           "restful",            "RESTful",            "RESTful"],
      ["RESTfulController", "restful_controller", "RESTful controller", "RESTful Controller"],
      ["Nested::RESTful",   "nested/restful",     "Nested/RESTful",     "Nested/RESTful"],
      ["IHeartW3C",         "i_heart_w3c",        "I heart W3C",        "I Heart W3C"],
      ["PhDRequired",       "phd_required",       "PhD required",       "PhD Required"],
      ["IRoRU",             "i_ror_u",            "I RoR u",            "I RoR U"],
      ["RESTfulHTTPAPI",    "restful_http_api",   "RESTful HTTP API",   "RESTful HTTP API"],
      ["HTTP::RESTful",     "http/restful",       "HTTP/RESTful",       "HTTP/RESTful"],
      ["HTTP::RESTfulAPI",  "http/restful_api",   "HTTP/RESTful API",   "HTTP/RESTful API"],
      ["APIRESTful",        "api_restful",        "API RESTful",        "API RESTful"],

      # misdirection
      ["Capistrano",        "capistrano",         "Capistrano",       "Capistrano"],
      ["CapiController",    "capi_controller",    "Capi controller",  "Capi Controller"],
      ["HttpsApis",         "https_apis",         "Https apis",       "Https Apis"],
      ["Html5",             "html5",              "Html5",            "Html5"],
      ["Restfully",         "restfully",          "Restfully",        "Restfully"],
      ["RoRails",           "ro_rails",           "Ro rails",         "Ro Rails"]
    ].each do |camel, under, human, title|
      assert_equal(camel, ActiveSupport::Inflector.camelize(under))
      assert_equal(camel, ActiveSupport::Inflector.camelize(camel))
      assert_equal(under, ActiveSupport::Inflector.underscore(under))
      assert_equal(under, ActiveSupport::Inflector.underscore(camel))
      assert_equal(title, ActiveSupport::Inflector.titleize(under))
      assert_equal(title, ActiveSupport::Inflector.titleize(camel))
      assert_equal(human, ActiveSupport::Inflector.humanize(under))
    end
  end

  def test_acronym_override
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.acronym("API")
      inflect.acronym("LegacyApi")
    end

    assert_equal("LegacyApi", ActiveSupport::Inflector.camelize("legacyapi"))
    assert_equal("LegacyAPI", ActiveSupport::Inflector.camelize("legacy_api"))
    assert_equal("SomeLegacyApi", ActiveSupport::Inflector.camelize("some_legacyapi"))
    assert_equal("Nonlegacyapi", ActiveSupport::Inflector.camelize("nonlegacyapi"))
  end

  def test_acronyms_camelize_lower
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.acronym("API")
      inflect.acronym("HTML")
    end

    assert_equal("htmlAPI", ActiveSupport::Inflector.camelize("html_api", false))
    assert_equal("htmlAPI", ActiveSupport::Inflector.camelize("htmlAPI", false))
    assert_equal("htmlAPI", ActiveSupport::Inflector.camelize("HTMLAPI", false))
  end

  def test_underscore_acronym_sequence
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.acronym("API")
      inflect.acronym("JSON")
      inflect.acronym("HTML")
    end

    assert_equal("json_html_api", ActiveSupport::Inflector.underscore("JSONHTMLAPI"))
  end

  def test_underscore
    CamelToUnderscore.each do |camel, underscore|
      assert_equal(underscore, ActiveSupport::Inflector.underscore(camel))
    end
    CamelToUnderscoreWithoutReverse.each do |camel, underscore|
      assert_equal(underscore, ActiveSupport::Inflector.underscore(camel))
    end
  end

  def test_camelize_with_module
    CamelWithModuleToUnderscoreWithSlash.each do |camel, underscore|
      assert_equal(camel, ActiveSupport::Inflector.camelize(underscore))
    end
  end

  def test_underscore_with_slashes
    CamelWithModuleToUnderscoreWithSlash.each do |camel, underscore|
      assert_equal(underscore, ActiveSupport::Inflector.underscore(camel))
    end
  end

  def test_demodulize
    assert_equal "Account", ActiveSupport::Inflector.demodulize("MyApplication::Billing::Account")
    assert_equal "Account", ActiveSupport::Inflector.demodulize("Account")
    assert_equal "Account", ActiveSupport::Inflector.demodulize("::Account")
    assert_equal "", ActiveSupport::Inflector.demodulize("")
  end

  def test_deconstantize
    assert_equal "MyApplication::Billing", ActiveSupport::Inflector.deconstantize("MyApplication::Billing::Account")
    assert_equal "::MyApplication::Billing", ActiveSupport::Inflector.deconstantize("::MyApplication::Billing::Account")

    assert_equal "MyApplication", ActiveSupport::Inflector.deconstantize("MyApplication::Billing")
    assert_equal "::MyApplication", ActiveSupport::Inflector.deconstantize("::MyApplication::Billing")

    assert_equal "", ActiveSupport::Inflector.deconstantize("Account")
    assert_equal "", ActiveSupport::Inflector.deconstantize("::Account")
    assert_equal "", ActiveSupport::Inflector.deconstantize("")
  end

  def test_foreign_key
    ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|
      assert_equal(foreign_key, ActiveSupport::Inflector.foreign_key(klass))
    end

    ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|
      assert_equal(foreign_key, ActiveSupport::Inflector.foreign_key(klass, false))
    end
  end

  def test_tableize
    ClassNameToTableName.each do |class_name, table_name|
      assert_equal(table_name, ActiveSupport::Inflector.tableize(class_name))
    end
  end

  def test_parameterize
    StringToParameterized.each do |some_string, parameterized_string|
      assert_equal(parameterized_string, ActiveSupport::Inflector.parameterize(some_string))
    end
  end

  def test_parameterize_and_normalize
    StringToParameterizedAndNormalized.each do |some_string, parameterized_string|
      assert_equal(parameterized_string, ActiveSupport::Inflector.parameterize(some_string))
    end
  end

  def test_parameterize_with_custom_separator
    StringToParameterizeWithUnderscore.each do |some_string, parameterized_string|
      assert_equal(parameterized_string, ActiveSupport::Inflector.parameterize(some_string, separator: "_"))
    end
  end

  def test_parameterize_with_multi_character_separator
    StringToParameterized.each do |some_string, parameterized_string|
      assert_equal(parameterized_string.gsub("-", "__sep__"), ActiveSupport::Inflector.parameterize(some_string, separator: "__sep__"))
    end
  end

  def test_parameterize_with_locale
    word = "Fnf autos"
    I18n.backend.store_translations(:de, i18n: { transliterate: { rule: { "" => "ue" } } })
    assert_equal("fuenf-autos", ActiveSupport::Inflector.parameterize(word, locale: :de))
  end

  def test_classify
    ClassNameToTableName.each do |class_name, table_name|
      assert_equal(class_name, ActiveSupport::Inflector.classify(table_name))
      assert_equal(class_name, ActiveSupport::Inflector.classify("table_prefix." + table_name))
    end
  end

  def test_classify_with_symbol
    assert_nothing_raised do
      assert_equal "FooBar", ActiveSupport::Inflector.classify(:foo_bars)
    end
  end

  def test_classify_with_leading_schema_name
    assert_equal "FooBar", ActiveSupport::Inflector.classify("schema.foo_bar")
  end

  def test_humanize
    UnderscoreToHuman.each do |underscore, human|
      assert_equal(human, ActiveSupport::Inflector.humanize(underscore))
    end
  end

  def test_humanize_without_capitalize
    UnderscoreToHumanWithoutCapitalize.each do |underscore, human|
      assert_equal(human, ActiveSupport::Inflector.humanize(underscore, capitalize: false))
    end
  end

  def test_humanize_with_keep_id_suffix
    UnderscoreToHumanWithKeepIdSuffix.each do |underscore, human|
      assert_equal(human, ActiveSupport::Inflector.humanize(underscore, keep_id_suffix: true))
    end
  end

  def test_humanize_by_rule
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.human(/_cnt$/i, '\1_count')
      inflect.human(/^prefx_/i, '\1')
    end
    assert_equal("Jargon count", ActiveSupport::Inflector.humanize("jargon_cnt"))
    assert_equal("Request", ActiveSupport::Inflector.humanize("prefx_request"))
  end

  def test_humanize_by_string
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.human("col_rpted_bugs", "Reported bugs")
    end
    assert_equal("Reported bugs", ActiveSupport::Inflector.humanize("col_rpted_bugs"))
    assert_equal("Col rpted bugs", ActiveSupport::Inflector.humanize("COL_rpted_bugs"))
  end

  def test_humanize_with_acronyms
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.acronym "LAX"
      inflect.acronym "SFO"
    end
    assert_equal("LAX roundtrip to SFO", ActiveSupport::Inflector.humanize("LAX ROUNDTRIP TO SFO"))
    assert_equal("LAX roundtrip to SFO", ActiveSupport::Inflector.humanize("LAX ROUNDTRIP TO SFO", capitalize: false))
    assert_equal("LAX roundtrip to SFO", ActiveSupport::Inflector.humanize("lax roundtrip to sfo"))
    assert_equal("LAX roundtrip to SFO", ActiveSupport::Inflector.humanize("lax roundtrip to sfo", capitalize: false))
    assert_equal("LAX roundtrip to SFO", ActiveSupport::Inflector.humanize("Lax Roundtrip To Sfo"))
    assert_equal("LAX roundtrip to SFO", ActiveSupport::Inflector.humanize("Lax Roundtrip To Sfo", capitalize: false))
  end

  def test_constantize
    run_constantize_tests_on do |string|
      ActiveSupport::Inflector.constantize(string)
    end
  end

  def test_safe_constantize
    run_safe_constantize_tests_on do |string|
      ActiveSupport::Inflector.safe_constantize(string)
    end
  end

  def test_ordinal
    OrdinalNumbers.each do |number, ordinalized|
      assert_equal(ordinalized, number + ActiveSupport::Inflector.ordinal(number))
    end
  end

  def test_ordinalize
    OrdinalNumbers.each do |number, ordinalized|
      assert_equal(ordinalized, ActiveSupport::Inflector.ordinalize(number))
    end
  end

  def test_dasherize
    UnderscoresToDashes.each do |underscored, dasherized|
      assert_equal(dasherized, ActiveSupport::Inflector.dasherize(underscored))
    end
  end

  def test_underscore_as_reverse_of_dasherize
    UnderscoresToDashes.each_key do |underscored|
      assert_equal(underscored, ActiveSupport::Inflector.underscore(ActiveSupport::Inflector.dasherize(underscored)))
    end
  end

  def test_underscore_to_lower_camel
    UnderscoreToLowerCamel.each do |underscored, lower_camel|
      assert_equal(lower_camel, ActiveSupport::Inflector.camelize(underscored, false))
    end
  end

  def test_symbol_to_lower_camel
    SymbolToLowerCamel.each do |symbol, lower_camel|
      assert_equal(lower_camel, ActiveSupport::Inflector.camelize(symbol, false))
    end
  end

  %w{plurals singulars uncountables humans}.each do |inflection_type|
    class_eval <<-RUBY, __FILE__, __LINE__ + 1
      def test_clear_#{inflection_type}
        ActiveSupport::Inflector.inflections.clear :#{inflection_type}
        assert ActiveSupport::Inflector.inflections.#{inflection_type}.empty?, \"#{inflection_type} inflections should be empty after clear :#{inflection_type}\"
      end
    RUBY
  end

  def test_inflector_locality
    ActiveSupport::Inflector.inflections(:es) do |inflect|
      inflect.plural(/$/, "s")
      inflect.plural(/z$/i, "ces")

      inflect.singular(/s$/, "")
      inflect.singular(/es$/, "")

      inflect.irregular("el", "los")

      inflect.uncountable("agua")
    end

    assert_equal("hijos", "hijo".pluralize(:es))
    assert_equal("luces", "luz".pluralize(:es))
    assert_equal("luzs", "luz".pluralize)

    assert_equal("sociedad", "sociedades".singularize(:es))
    assert_equal("sociedade", "sociedades".singularize)

    assert_equal("los", "el".pluralize(:es))
    assert_equal("els", "el".pluralize)

    assert_equal("agua", "agua".pluralize(:es))
    assert_equal("aguas", "agua".pluralize)

    ActiveSupport::Inflector.inflections(:es) { |inflect| inflect.clear }

    assert_empty ActiveSupport::Inflector.inflections(:es).plurals
    assert_empty ActiveSupport::Inflector.inflections(:es).singulars
    assert_empty ActiveSupport::Inflector.inflections(:es).uncountables
    assert_not_empty ActiveSupport::Inflector.inflections.plurals
    assert_not_empty ActiveSupport::Inflector.inflections.singulars
    assert_not_empty ActiveSupport::Inflector.inflections.uncountables
  end

  def test_clear_all
    ActiveSupport::Inflector.inflections do |inflect|
      # ensure any data is present
      inflect.plural(/(quiz)$/i, '\1zes')
      inflect.singular(/(database)s$/i, '\1')
      inflect.uncountable("series")
      inflect.human("col_rpted_bugs", "Reported bugs")

      inflect.clear :all

      assert_empty inflect.plurals
      assert_empty inflect.singulars
      assert_empty inflect.uncountables
      assert_empty inflect.humans
    end
  end

  def test_clear_with_default
    ActiveSupport::Inflector.inflections do |inflect|
      # ensure any data is present
      inflect.plural(/(quiz)$/i, '\1zes')
      inflect.singular(/(database)s$/i, '\1')
      inflect.uncountable("series")
      inflect.human("col_rpted_bugs", "Reported bugs")

      inflect.clear

      assert_empty inflect.plurals
      assert_empty inflect.singulars
      assert_empty inflect.uncountables
      assert_empty inflect.humans
    end
  end

  Irregularities.each do |singular, plural|
    define_method("test_irregularity_between_#{singular}_and_#{plural}") do
      ActiveSupport::Inflector.inflections do |inflect|
        inflect.irregular(singular, plural)
        assert_equal singular, ActiveSupport::Inflector.singularize(plural)
        assert_equal plural, ActiveSupport::Inflector.pluralize(singular)
      end
    end
  end

  Irregularities.each do |singular, plural|
    define_method("test_pluralize_of_irregularity_#{plural}_should_be_the_same") do
      ActiveSupport::Inflector.inflections do |inflect|
        inflect.irregular(singular, plural)
        assert_equal plural, ActiveSupport::Inflector.pluralize(plural)
      end
    end
  end

  Irregularities.each do |singular, plural|
    define_method("test_singularize_of_irregularity_#{singular}_should_be_the_same") do
      ActiveSupport::Inflector.inflections do |inflect|
        inflect.irregular(singular, plural)
        assert_equal singular, ActiveSupport::Inflector.singularize(singular)
      end
    end
  end

  [ :all, [] ].each do |scope|
    ActiveSupport::Inflector.inflections do |inflect|
      define_method("test_clear_inflections_with_#{scope.kind_of?(Array) ? "no_arguments" : scope}") do
        # save all the inflections
        singulars, plurals, uncountables = inflect.singulars, inflect.plurals, inflect.uncountables

        # clear all the inflections
        inflect.clear(*scope)

        assert_equal [], inflect.singulars
        assert_equal [], inflect.plurals
        assert_equal [], inflect.uncountables

        # restore all the inflections
        singulars.reverse_each { |singular| inflect.singular(*singular) }
        plurals.reverse_each   { |plural|   inflect.plural(*plural) }
        inflect.uncountable(uncountables)

        assert_equal singulars, inflect.singulars
        assert_equal plurals, inflect.plurals
        assert_equal uncountables, inflect.uncountables
      end
    end
  end

  %w(plurals singulars uncountables humans acronyms).each do |scope|
    define_method("test_clear_inflections_with_#{scope}") do
      # clear the inflections
      ActiveSupport::Inflector.inflections do |inflect|
        inflect.clear(scope)
        assert_equal [], inflect.public_send(scope)
# frozen_string_literal: true

require_relative "abstract_unit"
require "openssl"
require "active_support/time"
require "active_support/json"
require_relative "metadata/shared_metadata_tests"

class MessageVerifierTest < ActiveSupport::TestCase
  class JSONSerializer
    def dump(value)
      ActiveSupport::JSON.encode(value)
    end

    def load(value)
      ActiveSupport::JSON.decode(value)
    end
  end

  def setup
    @verifier = ActiveSupport::MessageVerifier.new("Hey, I'm a secret!")
    @data = { some: "data", now: Time.utc(2010) }
    @secret = SecureRandom.random_bytes(32)
  end

  def test_valid_message
    data, hash = @verifier.generate(@data).split("--")
    assert_not @verifier.valid_message?(nil)
    assert_not @verifier.valid_message?("")
    assert_not @verifier.valid_message?("\xff") # invalid encoding
    assert_not @verifier.valid_message?("#{data.reverse}--#{hash}")
    assert_not @verifier.valid_message?("#{data}--#{hash.reverse}")
    assert_not @verifier.valid_message?("purejunk")
  end

  def test_simple_round_tripping
    message = @verifier.generate(@data)
    assert_equal @data, @verifier.verified(message)
    assert_equal @data, @verifier.verify(message)
  end

  def test_verified_returns_false_on_invalid_message
    assert_not @verifier.verified("purejunk")
  end

  def test_verify_exception_on_invalid_message
    assert_raise(ActiveSupport::MessageVerifier::InvalidSignature) do
      @verifier.verify("purejunk")
    end
  end

  def test_alternative_serialization_method
    prev = ActiveSupport.use_standard_json_time_format
    ActiveSupport.use_standard_json_time_format = true
    verifier = ActiveSupport::MessageVerifier.new("Hey, I'm a secret!", serializer: JSONSerializer.new)
    message = verifier.generate({ :foo => 123, "bar" => Time.utc(2010) })
    exp = { "foo" => 123, "bar" => "2010-01-01T00:00:00.000Z" }
    assert_equal exp, verifier.verified(message)
    assert_equal exp, verifier.verify(message)
  ensure
    ActiveSupport.use_standard_json_time_format = prev
  end

  def test_verify_with_parse_json_times
    previous = [ ActiveSupport.parse_json_times, Time.zone ]
    ActiveSupport.parse_json_times, Time.zone = true, "UTC"

    assert_equal "hi", @verifier.verify(@verifier.generate("hi", expires_at: Time.now.utc + 10))
  ensure
    ActiveSupport.parse_json_times, Time.zone = previous
  end

  def test_raise_error_when_argument_class_is_not_loaded
    # To generate the valid message below:
    #
    #   AutoloadClass = Struct.new(:foo)
    #   valid_message = @verifier.generate(foo: AutoloadClass.new('foo'))
    #
    valid_message = "BAh7BjoIZm9vbzonTWVzc2FnZVZlcmlmaWVyVGVzdDo6QXV0b2xvYWRDbGFzcwY6CUBmb29JIghmb28GOgZFVA==--f3ef39a5241c365083770566dc7a9eb5d6ace914"
    exception = assert_raise(ArgumentError, NameError) do
      @verifier.verified(valid_message)
    end
    assert_includes ["uninitialized constant MessageVerifierTest::AutoloadClass",
                    "undefined class/module MessageVerifierTest::AutoloadClass"], exception.message
    exception = assert_raise(ArgumentError, NameError) do
      @verifier.verify(valid_message)
    end
    assert_includes ["uninitialized constant MessageVerifierTest::AutoloadClass",
                    "undefined class/module MessageVerifierTest::AutoloadClass"], exception.message
  end

  def test_raise_error_when_secret_is_nil
    exception = assert_raise(ArgumentError) do
      ActiveSupport::MessageVerifier.new(nil)
    end
    assert_equal "Secret should not be nil.", exception.message
  end

  def test_backward_compatibility_messages_signed_without_metadata
    signed_message = "BAh7BzoJc29tZUkiCWRhdGEGOgZFVDoIbm93SXU6CVRpbWUNIIAbgAAAAAAHOgtvZmZzZXRpADoJem9uZUkiCFVUQwY7BkY=--d03c52c91dfe4ccc5159417c660461bcce005e96"
    assert_equal @data, @verifier.verify(signed_message)
  end


  def test_rotating_secret
    old_message = ActiveSupport::MessageVerifier.new("old", digest: "SHA1").generate("old")

    verifier = ActiveSupport::MessageVerifier.new(@secret, digest: "SHA1")
    verifier.rotate "old"

    assert_equal "old", verifier.verified(old_message)
  end

  def test_multiple_rotations
    old_message   = ActiveSupport::MessageVerifier.new("old", digest: "SHA256").generate("old")
    older_message = ActiveSupport::MessageVerifier.new("older", digest: "SHA1").generate("older")

    verifier = ActiveSupport::MessageVerifier.new(@secret, digest: "SHA512")
    verifier.rotate "old",   digest: "SHA256"
    verifier.rotate "older", digest: "SHA1"

    assert_equal "new",   verifier.verified(verifier.generate("new"))
    assert_equal "old",   verifier.verified(old_message)
    assert_equal "older", verifier.verified(older_message)
  end

  def test_on_rotation_is_called_and_verified_returns_message
    older_message = ActiveSupport::MessageVerifier.new("older", digest: "SHA1").generate({ encoded: "message" })

    verifier = ActiveSupport::MessageVerifier.new(@secret, digest: "SHA512")
    verifier.rotate "old",   digest: "SHA256"
    verifier.rotate "older", digest: "SHA1"

    rotated = false
    message = verifier.verified(older_message, on_rotation: proc { rotated = true })

    assert_equal({ encoded: "message" }, message)
    assert rotated
  end

  def test_rotations_with_metadata
    old_message = ActiveSupport::MessageVerifier.new("old").generate("old", purpose: :rotation)

    verifier = ActiveSupport::MessageVerifier.new(@secret)
    verifier.rotate "old"

    assert_equal "old", verifier.verified(old_message, purpose: :rotation)
  end
end

class MessageVerifierMetadataTest < ActiveSupport::TestCase
  include SharedMessageMetadataTests

  setup do
    @verifier = ActiveSupport::MessageVerifier.new("Hey, I'm a secret!", **verifier_options)
  end

  def test_verify_raises_when_purpose_differs
    assert_raise(ActiveSupport::MessageVerifier::InvalidSignature) do
      @verifier.verify(generate(data, purpose: "payment"), purpose: "shipping")
    end
  end

  def test_verify_with_use_standard_json_time_format_as_false
    format_before = ActiveSupport.use_standard_json_time_format
    ActiveSupport.use_standard_json_time_format = false
    assert_equal "My Name", @verifier.verify(generate("My Name"))
  ensure
    ActiveSupport.use_standard_json_time_format = format_before
  end

  def test_verify_raises_when_expired
    signed_message = generate(data, expires_in: 1.month)

    travel 2.months
    assert_raise(ActiveSupport::MessageVerifier::InvalidSignature) do
      @verifier.verify(signed_message)
    end
  end

  private
    def generate(message, **options)
      @verifier.generate(message, **options)
    end

    def parse(message, **options)
      @verifier.verified(message, **options)
    end

    def verifier_options
      Hash.new
    end
end

class MessageVerifierMetadataMarshalTest < MessageVerifierMetadataTest
  private
    def verifier_options
      { serializer: Marshal }
    end
end

class MessageVerifierMetadataJSONTest < MessageVerifierMetadataTest
  private
    def verifier_options
      { serializer: MessageVerifierTest::JSONSerializer.new }
    end
end

class MessageEncryptorMetadataNullSerializerTest < MessageVerifierMetadataTest
  private
    def data
      "string message"
    end

    def null_serializing?
      true
    end

    def verifier_options
      { serializer: ActiveSupport::MessageEncryptor::NullSerializer }
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/log_subscriber/test_helper"

class MyLogSubscriber < ActiveSupport::LogSubscriber
  attr_reader :event

  def some_event(event)
    @event = event
    info event.name
  end

  def foo(event)
    debug "debug"
    info { "info" }
    warn "warn"
  end

  def bar(event)
    info "#{color("cool", :red)}, #{color("isn't it?", :blue, true)}"
  end

  def puke(event)
    raise "puke"
  end
end

class SyncLogSubscriberTest < ActiveSupport::TestCase
  include ActiveSupport::LogSubscriber::TestHelper

  def setup
    super
    @log_subscriber = MyLogSubscriber.new
  end

  def teardown
    super
    ActiveSupport::LogSubscriber.log_subscribers.clear
  end

  def instrument(*args, &block)
    ActiveSupport::Notifications.instrument(*args, &block)
  end

  def test_proxies_method_to_rails_logger
    @log_subscriber.foo(nil)
    assert_equal %w(debug), @logger.logged(:debug)
    assert_equal %w(info), @logger.logged(:info)
    assert_equal %w(warn), @logger.logged(:warn)
  end

  def test_set_color_for_messages
    ActiveSupport::LogSubscriber.colorize_logging = true
    @log_subscriber.bar(nil)
    assert_equal "\e[31mcool\e[0m, \e[1m\e[34misn't it?\e[0m", @logger.logged(:info).last
  end

  def test_does_not_set_color_if_colorize_logging_is_set_to_false
    @log_subscriber.bar(nil)
    assert_equal "cool, isn't it?", @logger.logged(:info).last
  end

  def test_event_is_sent_to_the_registered_class
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    instrument "some_event.my_log_subscriber"
    wait
    assert_equal %w(some_event.my_log_subscriber), @logger.logged(:info)
  end

  def test_event_is_an_active_support_notifications_event
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    instrument "some_event.my_log_subscriber"
    wait
    assert_kind_of ActiveSupport::Notifications::Event, @log_subscriber.event
  end

  def test_event_attributes
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    instrument "some_event.my_log_subscriber"
    wait
    event = @log_subscriber.event
    if defined?(JRUBY_VERSION)
      assert_equal 0, event.cpu_time
      assert_equal 0, event.allocations
    else
      assert_operator event.cpu_time, :>, 0
      assert_operator event.allocations, :>, 0
    end
    assert_operator event.duration, :>, 0
    assert_operator event.idle_time, :>, 0
  end

  def test_does_not_send_the_event_if_it_doesnt_match_the_class
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    instrument "unknown_event.my_log_subscriber"
    wait
    # If we get here, it means that NoMethodError was not raised.
  end

  def test_does_not_send_the_event_if_logger_is_nil
    ActiveSupport::LogSubscriber.logger = nil
    assert_not_called(@log_subscriber, :some_event) do
      ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
      instrument "some_event.my_log_subscriber"
      wait
    end
  end

  def test_does_not_fail_with_non_namespaced_events
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    instrument "whatever"
    wait
  end

  def test_flushes_loggers
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    ActiveSupport::LogSubscriber.flush_all!
    assert_equal 1, @logger.flush_count
  end

  def test_flushes_the_same_logger_just_once
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    ActiveSupport::LogSubscriber.attach_to :another, @log_subscriber
    ActiveSupport::LogSubscriber.flush_all!
    wait
    assert_equal 1, @logger.flush_count
  end

  def test_logging_does_not_die_on_failures
    ActiveSupport::LogSubscriber.attach_to :my_log_subscriber, @log_subscriber
    instrument "puke.my_log_subscriber"
    instrument "some_event.my_log_subscriber"
    wait

    assert_equal 1, @logger.logged(:info).size
    assert_equal "some_event.my_log_subscriber", @logger.logged(:info).last

    assert_equal 1, @logger.logged(:error).size
    assert_match 'Could not log "puke.my_log_subscriber" event. RuntimeError: puke', @logger.logged(:error).last
# frozen_string_literal: true

require_relative "abstract_unit"

class GrandParent
  include ActiveSupport::Callbacks

  attr_reader :log, :action_name
  def initialize(action_name)
    @action_name, @log = action_name, []
  end

  define_callbacks :dispatch
  set_callback :dispatch, :before, :before1, :before2, if: proc { |c| c.action_name == "index" || c.action_name == "update" }
  set_callback :dispatch, :after, :after1, :after2, if: proc { |c| c.action_name == "update" || c.action_name == "delete" }

  def before1
    @log << "before1"
  end

  def before2
    @log << "before2"
  end

  def after1
    @log << "after1"
  end

  def after2
    @log << "after2"
  end

  def dispatch
    run_callbacks :dispatch do
      @log << action_name
    end
    self
  end
end

class Parent < GrandParent
  skip_callback :dispatch, :before, :before2, unless: proc { |c| c.action_name == "update" }
  skip_callback :dispatch, :after, :after2, unless: proc { |c| c.action_name == "delete" }
end

class Child < GrandParent
  skip_callback :dispatch, :before, :before2, unless: proc { |c| c.action_name == "update" }, if: :state_open?

  def state_open?
    @state == :open
  end

  def initialize(action_name, state)
    super(action_name)
    @state = state
  end
end

class EmptyParent
  include ActiveSupport::Callbacks

  def performed?
    @performed ||= false
  end

  define_callbacks :dispatch

  def perform!
    @performed = true
  end

  def dispatch
    run_callbacks :dispatch
    self
  end
end

class EmptyChild < EmptyParent
  set_callback :dispatch, :before, :do_nothing

  def do_nothing
  end
end

class CountingParent
  include ActiveSupport::Callbacks

  attr_reader :count

  define_callbacks :dispatch

  def initialize
    @count = 0
  end

  def count!
    @count += 1
  end

  def dispatch
    run_callbacks(:dispatch)
    self
  end
end

class CountingChild < CountingParent
end

class BasicCallbacksTest < ActiveSupport::TestCase
  def setup
    @index    = GrandParent.new("index").dispatch
    @update   = GrandParent.new("update").dispatch
    @delete   = GrandParent.new("delete").dispatch
  end

  def test_basic_conditional_callback1
    assert_equal %w(before1 before2 index), @index.log
  end

  def test_basic_conditional_callback2
    assert_equal %w(before1 before2 update after2 after1), @update.log
  end

  def test_basic_conditional_callback3
    assert_equal %w(delete after2 after1), @delete.log
  end
end

class InheritedCallbacksTest < ActiveSupport::TestCase
  def setup
    @index    = Parent.new("index").dispatch
    @update   = Parent.new("update").dispatch
    @delete   = Parent.new("delete").dispatch
  end

  def test_inherited_excluded
    assert_equal %w(before1 index), @index.log
  end

  def test_inherited_not_excluded
    assert_equal %w(before1 before2 update after1), @update.log
  end

  def test_partially_excluded
    assert_equal %w(delete after2 after1), @delete.log
  end
end

class InheritedCallbacksTest2 < ActiveSupport::TestCase
  def setup
    @update1 = Child.new("update", :open).dispatch
    @update2 = Child.new("update", :closed).dispatch
  end

  def test_crazy_mix_on
    assert_equal %w(before1 update after2 after1), @update1.log
  end

  def test_crazy_mix_off
    assert_equal %w(before1 before2 update after2 after1), @update2.log
  end
end

class DynamicInheritedCallbacks < ActiveSupport::TestCase
  def test_callbacks_looks_to_the_superclass_before_running
    child = EmptyChild.new.dispatch
    assert_not_predicate child, :performed?
    EmptyParent.set_callback :dispatch, :before, :perform!
    child = EmptyChild.new.dispatch
    assert_predicate child, :performed?
  end

  def test_callbacks_should_be_performed_once_in_child_class
    CountingParent.set_callback(:dispatch, :before) { count! }
    child = CountingChild.new.dispatch
    assert_equal 1, child.count
  end
end

class DynamicDefinedCallbacks < ActiveSupport::TestCase
  def test_callbacks_should_be_performed_once_in_child_class_after_dynamic_define
    GrandParent.define_callbacks(:foo)
    GrandParent.set_callback(:foo, :before, :before1)
    parent = Parent.new("foo")
    parent.run_callbacks(:foo)
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/actionable_error"

class ActionableErrorTest < ActiveSupport::TestCase
  NonActionableError = Class.new(StandardError)

  class DispatchableError < StandardError
    include ActiveSupport::ActionableError

    class_attribute :flip1, default: false
    class_attribute :flip2, default: false

    action "Flip 1" do
      self.flip1 = true
    end

    action "Flip 2" do
      self.flip2 = true
    end
  end

  test "returns all action of an actionable error" do
    assert_equal ["Flip 1", "Flip 2"], ActiveSupport::ActionableError.actions(DispatchableError).keys
    assert_equal ["Flip 1", "Flip 2"], ActiveSupport::ActionableError.actions(DispatchableError.new).keys
  end

  test "returns no actions for non-actionable errors" do
    assert ActiveSupport::ActionableError.actions(Exception).empty?
    assert ActiveSupport::ActionableError.actions(Exception.new).empty?
  end

  test "dispatches actions from error and name" do
    assert_changes "DispatchableError.flip1", from: false, to: true do
      ActiveSupport::ActionableError.dispatch DispatchableError, "Flip 1"
    end
  end

  test "cannot dispatch missing actions" do
    err = assert_raises ActiveSupport::ActionableError::NonActionable do
      ActiveSupport::ActionableError.dispatch NonActionableError, "action"
    end

    assert_equal 'Cannot find action "action"', err.to_s
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/symbol"

class SymbolStartsEndsWithTest < ActiveSupport::TestCase
  def test_starts_ends_with_alias
    s = :hello
    assert s.starts_with?("h")
    assert s.starts_with?("hel")
    assert_not s.starts_with?("el")
    assert s.starts_with?("he", "lo")
    assert_not s.starts_with?("el", "lo")

    assert s.ends_with?("o")
    assert s.ends_with?("lo")
    assert_not s.ends_with?("el")
    assert s.ends_with?("he", "lo")
    assert_not s.ends_with?("he", "ll")
  end
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/time"
require_relative "../core_ext/date_and_time_behavior"
require_relative "../time_zone_test_helpers"

class DateExtCalculationsTest < ActiveSupport::TestCase
  def date_time_init(year, month, day, *args)
    Date.new(year, month, day)
  end

  include DateAndTimeBehavior
  include TimeZoneTestHelpers

  def test_yesterday_in_calendar_reform
    assert_equal Date.new(1582, 10, 4), Date.new(1582, 10, 15).yesterday
  end

  def test_tomorrow_in_calendar_reform
    assert_equal Date.new(1582, 10, 15), Date.new(1582, 10, 4).tomorrow
  end

  def test_to_s
    date = Date.new(2005, 2, 21)
    assert_equal "2005-02-21",          date.to_s
    assert_equal "21 Feb",              date.to_s(:short)
    assert_equal "February 21, 2005",   date.to_s(:long)
    assert_equal "February 21st, 2005", date.to_s(:long_ordinal)
    assert_equal "2005-02-21",          date.to_s(:db)
    assert_equal "2005-02-21",          date.to_s(:inspect)
    assert_equal "21 Feb 2005",         date.to_s(:rfc822)
    assert_equal "2005-02-21",          date.to_s(:iso8601)
  end

  def test_to_s_with_single_digit_day
    date = Date.new(2005, 2, 1)
    assert_equal "2005-02-01",          date.to_s
    assert_equal "01 Feb",              date.to_s(:short)
    assert_equal "February 01, 2005",   date.to_s(:long)
    assert_equal "February 1st, 2005",  date.to_s(:long_ordinal)
    assert_equal "2005-02-01",          date.to_s(:db)
    assert_equal "2005-02-01",          date.to_s(:inspect)
    assert_equal "01 Feb 2005",         date.to_s(:rfc822)
    assert_equal "2005-02-01",          date.to_s(:iso8601)
  end

  def test_readable_inspect
    assert_equal "Mon, 21 Feb 2005", Date.new(2005, 2, 21).readable_inspect
    assert_equal Date.new(2005, 2, 21).readable_inspect, Date.new(2005, 2, 21).inspect
  end

  def test_to_time
    with_env_tz "US/Eastern" do
      assert_equal Time, Date.new(2005, 2, 21).to_time.class
      assert_equal Time.local(2005, 2, 21), Date.new(2005, 2, 21).to_time
      assert_equal Time.local(2005, 2, 21).utc_offset, Date.new(2005, 2, 21).to_time.utc_offset
    end

    silence_warnings do
      0.upto(138) do |year|
        [:utc, :local].each do |format|
          assert_equal year, Date.new(year).to_time(format).year
        end
      end
    end

    assert_raise(ArgumentError) do
      Date.new(2005, 2, 21).to_time(:tokyo)
    end
  end

  def test_compare_to_time
    assert Date.yesterday < Time.now
  end

  def test_to_datetime
    assert_equal DateTime.civil(2005, 2, 21), Date.new(2005, 2, 21).to_datetime
    assert_equal 0, Date.new(2005, 2, 21).to_datetime.offset # use UTC offset
    assert_equal ::Date::ITALY, Date.new(2005, 2, 21).to_datetime.start # use Ruby's default start value
  end

  def test_to_date
    assert_equal Date.new(2005, 2, 21), Date.new(2005, 2, 21).to_date
  end

  def test_change
    assert_equal Date.new(2005, 2, 21), Date.new(2005, 2, 11).change(day: 21)
    assert_equal Date.new(2007, 5, 11), Date.new(2005, 2, 11).change(year: 2007, month: 5)
    assert_equal Date.new(2006, 2, 22), Date.new(2005, 2, 22).change(year: 2006)
    assert_equal Date.new(2005, 6, 22), Date.new(2005, 2, 22).change(month: 6)
  end

  def test_sunday
    assert_equal Date.new(2008, 3, 2), Date.new(2008, 3, 02).sunday
    assert_equal Date.new(2008, 3, 2), Date.new(2008, 2, 29).sunday
  end

  def test_beginning_of_week_in_calendar_reform
    assert_equal Date.new(1582, 10, 1), Date.new(1582, 10, 15).beginning_of_week # friday
  end

  def test_end_of_week_in_calendar_reform
    assert_equal Date.new(1582, 10, 17), Date.new(1582, 10, 4).end_of_week # thursday
  end

  def test_end_of_year
    assert_equal Date.new(2008, 12, 31).to_s, Date.new(2008, 2, 22).end_of_year.to_s
  end

  def test_end_of_month
    assert_equal Date.new(2005, 3, 31), Date.new(2005, 3, 20).end_of_month
    assert_equal Date.new(2005, 2, 28), Date.new(2005, 2, 20).end_of_month
    assert_equal Date.new(2005, 4, 30), Date.new(2005, 4, 20).end_of_month
  end

  def test_last_year_in_leap_years
    assert_equal Date.new(1999, 2, 28), Date.new(2000, 2, 29).last_year
  end

  def test_last_year_in_calendar_reform
    assert_equal Date.new(1582, 10, 4), Date.new(1583, 10, 14).last_year
  end

  def test_advance
    assert_equal Date.new(2006, 2, 28), Date.new(2005, 2, 28).advance(years: 1)
    assert_equal Date.new(2005, 6, 28), Date.new(2005, 2, 28).advance(months: 4)
    assert_equal Date.new(2005, 3, 21), Date.new(2005, 2, 28).advance(weeks: 3)
    assert_equal Date.new(2005, 3, 5), Date.new(2005, 2, 28).advance(days: 5)
    assert_equal Date.new(2012, 9, 28), Date.new(2005, 2, 28).advance(years: 7, months: 7)
    assert_equal Date.new(2013, 10, 3), Date.new(2005, 2, 28).advance(years: 7, months: 19, days: 5)
    assert_equal Date.new(2013, 10, 17), Date.new(2005, 2, 28).advance(years: 7, months: 19, weeks: 2, days: 5)
    assert_equal Date.new(2005, 2, 28), Date.new(2004, 2, 29).advance(years: 1) # leap day plus one year
  end

  def test_advance_does_first_years_and_then_days
    assert_equal Date.new(2012, 2, 29), Date.new(2011, 2, 28).advance(years: 1, days: 1)
    # If day was done first we would jump to 2012-03-01 instead.
  end

  def test_advance_does_first_months_and_then_days
    assert_equal Date.new(2010, 3, 29), Date.new(2010, 2, 28).advance(months: 1, days: 1)
    # If day was done first we would jump to 2010-04-01 instead.
  end

  def test_advance_in_calendar_reform
    assert_equal Date.new(1582, 10, 15), Date.new(1582, 10, 4).advance(days: 1)
    assert_equal Date.new(1582, 10, 4), Date.new(1582, 10, 15).advance(days: -1)
    5.upto(14) do |day|
      assert_equal Date.new(1582, 10, 4), Date.new(1582, 9, day).advance(months: 1)
      assert_equal Date.new(1582, 10, 4), Date.new(1582, 11, day).advance(months: -1)
      assert_equal Date.new(1582, 10, 4), Date.new(1581, 10, day).advance(years: 1)
      assert_equal Date.new(1582, 10, 4), Date.new(1583, 10, day).advance(years: -1)
    end
  end

  def test_last_week
    assert_equal Date.new(2005, 5, 9), Date.new(2005, 5, 17).last_week
    assert_equal Date.new(2006, 12, 25), Date.new(2007, 1, 7).last_week
    assert_equal Date.new(2010, 2, 12), Date.new(2010, 2, 19).last_week(:friday)
    assert_equal Date.new(2010, 2, 13), Date.new(2010, 2, 19).last_week(:saturday)
    assert_equal Date.new(2010, 2, 27), Date.new(2010, 3, 4).last_week(:saturday)
  end

  def test_next_week_in_calendar_reform
    assert_equal Date.new(1582, 10, 15), Date.new(1582, 9, 30).next_week(:friday)
    assert_equal Date.new(1582, 10, 18), Date.new(1582, 10, 4).next_week
  end

  def test_last_quarter_on_31st
    assert_equal Date.new(2004, 2, 29), Date.new(2004, 5, 31).last_quarter
  end

  def test_yesterday_constructor
    assert_equal Date.current - 1, Date.yesterday
  end

  def test_yesterday_constructor_when_zone_is_not_set
    with_env_tz "UTC" do
      with_tz_default do
        assert_equal(Date.today - 1, Date.yesterday)
      end
    end
  end

  def test_yesterday_constructor_when_zone_is_set
    with_env_tz "UTC" do
      with_tz_default ActiveSupport::TimeZone["Eastern Time (US & Canada)"] do # UTC -5
        Time.stub(:now, Time.local(2000, 1, 1)) do
          assert_equal Date.new(1999, 12, 30), Date.yesterday
        end
      end
    end
  end

  def test_tomorrow_constructor
    assert_equal Date.current + 1, Date.tomorrow
  end

  def test_tomorrow_constructor_when_zone_is_not_set
    with_env_tz "UTC" do
      with_tz_default do
        assert_equal(Date.today + 1, Date.tomorrow)
      end
    end
  end

  def test_tomorrow_constructor_when_zone_is_set
    with_env_tz "UTC" do
      with_tz_default ActiveSupport::TimeZone["Europe/Paris"] do # UTC +1
        Time.stub(:now, Time.local(1999, 12, 31, 23)) do
          assert_equal Date.new(2000, 1, 2), Date.tomorrow
        end
      end
    end
  end

  def test_since
    assert_equal Time.local(2005, 2, 21, 0, 0, 45), Date.new(2005, 2, 21).since(45)
  end

  def test_since_when_zone_is_set
    zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "UTC" do
      with_tz_default zone do
        assert_equal zone.local(2005, 2, 21, 0, 0, 45), Date.new(2005, 2, 21).since(45)
        assert_equal zone, Date.new(2005, 2, 21).since(45).time_zone
      end
    end
  end

  def test_ago
    assert_equal Time.local(2005, 2, 20, 23, 59, 15), Date.new(2005, 2, 21).ago(45)
  end

  def test_ago_when_zone_is_set
    zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "UTC" do
      with_tz_default zone do
        assert_equal zone.local(2005, 2, 20, 23, 59, 15), Date.new(2005, 2, 21).ago(45)
        assert_equal zone, Date.new(2005, 2, 21).ago(45).time_zone
      end
    end
  end

  def test_beginning_of_day
    assert_equal Time.local(2005, 2, 21, 0, 0, 0), Date.new(2005, 2, 21).beginning_of_day
  end

  def test_middle_of_day
    assert_equal Time.local(2005, 2, 21, 12, 0, 0), Date.new(2005, 2, 21).middle_of_day
  end

  def test_beginning_of_day_when_zone_is_set
    zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "UTC" do
      with_tz_default zone do
        assert_equal zone.local(2005, 2, 21, 0, 0, 0), Date.new(2005, 2, 21).beginning_of_day
        assert_equal zone, Date.new(2005, 2, 21).beginning_of_day.time_zone
      end
    end
  end

  def test_end_of_day
    assert_equal Time.local(2005, 2, 21, 23, 59, 59, Rational(999999999, 1000)), Date.new(2005, 2, 21).end_of_day
  end

  def test_end_of_day_when_zone_is_set
    zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "UTC" do
      with_tz_default zone do
        assert_equal zone.local(2005, 2, 21, 23, 59, 59, Rational(999999999, 1000)), Date.new(2005, 2, 21).end_of_day
        assert_equal zone, Date.new(2005, 2, 21).end_of_day.time_zone
      end
    end
  end

  def test_all_day
    beginning_of_day = Time.local(2011, 6, 7, 0, 0, 0)
    end_of_day = Time.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000))
    assert_equal beginning_of_day..end_of_day, Date.new(2011, 6, 7).all_day
  end

  def test_all_day_when_zone_is_set
    zone = ActiveSupport::TimeZone["Hawaii"]
    with_env_tz "UTC" do
      with_tz_default zone do
        beginning_of_day = zone.local(2011, 6, 7, 0, 0, 0)
        end_of_day = zone.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000))
        assert_equal beginning_of_day..end_of_day, Date.new(2011, 6, 7).all_day
      end
    end
  end

  def test_all_week
    assert_equal Date.new(2011, 6, 6)..Date.new(2011, 6, 12), Date.new(2011, 6, 7).all_week
    assert_equal Date.new(2011, 6, 5)..Date.new(2011, 6, 11), Date.new(2011, 6, 7).all_week(:sunday)
  end

  def test_all_month
    assert_equal Date.new(2011, 6, 1)..Date.new(2011, 6, 30), Date.new(2011, 6, 7).all_month
  end

  def test_all_quarter
    assert_equal Date.new(2011, 4, 1)..Date.new(2011, 6, 30), Date.new(2011, 6, 7).all_quarter
  end

  def test_all_year
    assert_equal Date.new(2011, 1, 1)..Date.new(2011, 12, 31), Date.new(2011, 6, 7).all_year
  end

  def test_xmlschema
    with_env_tz "US/Eastern" do
      assert_match(/^1980-02-28T00:00:00-05:?00$/, Date.new(1980, 2, 28).xmlschema)
      assert_match(/^1980-06-28T00:00:00-04:?00$/, Date.new(1980, 6, 28).xmlschema)
      # these tests are only of interest on platforms where older dates #to_time fail over to DateTime
      if ::DateTime === Date.new(1880, 6, 28).to_time
        assert_match(/^1880-02-28T00:00:00-05:?00$/, Date.new(1880, 2, 28).xmlschema)
        assert_match(/^1880-06-28T00:00:00-05:?00$/, Date.new(1880, 6, 28).xmlschema) # DateTimes aren't aware of DST rules
      end
    end
  end

  def test_xmlschema_when_zone_is_set
    with_env_tz "UTC" do
      with_tz_default ActiveSupport::TimeZone["Eastern Time (US & Canada)"] do # UTC -5
        assert_match(/^1980-02-28T00:00:00-05:?00$/, Date.new(1980, 2, 28).xmlschema)
        assert_match(/^1980-06-28T00:00:00-04:?00$/, Date.new(1980, 6, 28).xmlschema)
      end
    end
  end

  def test_past
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true, Date.new(1999, 12, 31).past?
      assert_equal false, Date.new(2000, 1, 1).past?
      assert_equal false, Date.new(2000, 1, 2).past?
    end
  end

  def test_future
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, Date.new(1999, 12, 31).future?
      assert_equal false, Date.new(2000, 1, 1).future?
      assert_equal true, Date.new(2000, 1, 2).future?
    end
  end

  def test_current_returns_date_today_when_zone_not_set
    with_env_tz "US/Central" do
      Time.stub(:now, Time.local(1999, 12, 31, 23)) do
        assert_equal Date.today, Date.current
      end
    end
  end

  def test_current_returns_time_zone_today_when_zone_is_set
    Time.zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "US/Central" do
      assert_equal ::Time.zone.today, Date.current
    end
  ensure
    Time.zone = nil
  end

  def test_date_advance_should_not_change_passed_options_hash
    options = { years: 3, months: 11, days: 2 }
    Date.new(2005, 2, 28).advance(options)
    assert_equal({ years: 3, months: 11, days: 2 }, options)
  end
end

class DateExtBehaviorTest < ActiveSupport::TestCase
  def test_date_acts_like_date
    assert_predicate Date.new, :acts_like_date?
  end

  def test_blank?
    assert_not_predicate Date.new, :blank?
  end

  def test_freeze_doesnt_clobber_memoized_instance_methods
    assert_nothing_raised do
      Date.today.freeze.inspect
    end
  end

  def test_can_freeze_twice
    assert_nothing_raised do
      Date.today.freeze.freeze
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/time"
require_relative "../time_zone_test_helpers"
require "yaml"

class TimeWithZoneTest < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def setup
    @utc = Time.utc(2000, 1, 1, 0)
    @time_zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    @twz = ActiveSupport::TimeWithZone.new(@utc, @time_zone)
    @dt_twz = ActiveSupport::TimeWithZone.new(@utc.to_datetime, @time_zone)
  end

  def test_utc
    assert_equal @utc, @twz.utc
    assert_instance_of Time, @twz.utc
    assert_instance_of Time, @dt_twz.utc
  end

  def test_time
    assert_equal Time.utc(1999, 12, 31, 19), @twz.time
  end

  def test_time_zone
    assert_equal @time_zone, @twz.time_zone
  end

  def test_in_time_zone
    Time.use_zone "Alaska" do
      assert_equal ActiveSupport::TimeWithZone.new(@utc, ActiveSupport::TimeZone["Alaska"]), @twz.in_time_zone
    end
  end

  def test_in_time_zone_with_argument
    assert_equal ActiveSupport::TimeWithZone.new(@utc, ActiveSupport::TimeZone["Alaska"]), @twz.in_time_zone("Alaska")
  end

  def test_in_time_zone_with_new_zone_equal_to_old_zone_does_not_create_new_object
    assert_equal @twz.object_id, @twz.in_time_zone(ActiveSupport::TimeZone["Eastern Time (US & Canada)"]).object_id
  end

  def test_in_time_zone_with_bad_argument
    assert_raise(ArgumentError) { @twz.in_time_zone("No such timezone exists") }
    assert_raise(ArgumentError) { @twz.in_time_zone(-15.hours) }
    assert_raise(ArgumentError) { @twz.in_time_zone(Object.new) }
  end

  def test_in_time_zone_with_ambiguous_time
    with_env_tz "Europe/Moscow" do
      assert_equal Time.utc(2014, 10, 25, 22, 0, 0), Time.local(2014, 10, 26, 1, 0, 0).in_time_zone("Moscow")
    end
  end

  def test_localtime
    assert_equal @twz.localtime, @twz.utc.getlocal
    assert_instance_of Time, @twz.localtime
    assert_instance_of Time, @dt_twz.localtime
  end

  def test_utc?
    assert_equal false, @twz.utc?

    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["UTC"]).utc?
    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Etc/UTC"]).utc?
    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Universal"]).utc?
    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["UCT"]).utc?
    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Etc/UCT"]).utc?
    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Etc/Universal"]).utc?

    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Africa/Abidjan"]).utc?
    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Africa/Banjul"]).utc?
    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Africa/Freetown"]).utc?
    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["GMT"]).utc?
    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["GMT0"]).utc?
    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Greenwich"]).utc?
    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Iceland"]).utc?
    assert_equal false, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Africa/Monrovia"]).utc?
  end

  def test_formatted_offset
    assert_equal "-05:00", @twz.formatted_offset
    assert_equal "-04:00", ActiveSupport::TimeWithZone.new(Time.utc(2000, 6), @time_zone).formatted_offset # dst
  end

  def test_dst?
    assert_equal false, @twz.dst?
    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000, 6), @time_zone).dst?
  end

  def test_zone
    assert_equal "EST", @twz.zone
    assert_equal "EDT", ActiveSupport::TimeWithZone.new(Time.utc(2000, 6), @time_zone).zone # dst
  end

  def test_nsec
    local     = Time.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000))
    with_zone = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Hawaii"], local)

    assert_equal local.nsec, with_zone.nsec
    assert_equal with_zone.nsec, 999999999
  end

  def test_strftime
    assert_equal "1999-12-31 19:00:00 EST -0500", @twz.strftime("%Y-%m-%d %H:%M:%S %Z %z")
  end

  def test_strftime_with_escaping
    assert_equal "%Z %z", @twz.strftime("%%Z %%z")
    assert_equal "%EST %-0500", @twz.strftime("%%%Z %%%z")
  end

  def test_inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect

    nsec          = Time.utc(1986, 12, 12, 6, 23, 00, Rational(1, 1000))
    nsec          = ActiveSupport::TimeWithZone.new(nsec, @time_zone)
    assert_equal "Fri, 12 Dec 1986 01:23:00.000000001 EST -05:00", nsec.inspect

    handred_nsec  = Time.utc(1986, 12, 12, 6, 23, 00, Rational(100, 1000))
    handred_nsec  = ActiveSupport::TimeWithZone.new(handred_nsec, @time_zone)
    assert_equal "Fri, 12 Dec 1986 01:23:00.000000100 EST -05:00", handred_nsec.inspect

    one_third_sec = Time.utc(1986, 12, 12, 6, 23, 00, Rational(1000000, 3))
    one_third_sec = ActiveSupport::TimeWithZone.new(one_third_sec, @time_zone)
    assert_equal "Fri, 12 Dec 1986 01:23:00.333333333 EST -05:00", one_third_sec.inspect
  end

  def test_to_s
    assert_equal "1999-12-31 19:00:00 -0500", @twz.to_s
  end

  def test_to_formatted_s
    assert_equal "1999-12-31 19:00:00 -0500", @twz.to_formatted_s
  end

  def test_to_s_db
    assert_equal "2000-01-01 00:00:00", @twz.to_s(:db)
  end

  def test_to_s_inspect
    assert_equal "1999-12-31 19:00:00.000000000 -0500", @twz.to_s(:inspect)
  end

  def test_xmlschema
    assert_equal "1999-12-31T19:00:00-05:00", @twz.xmlschema
  end

  def test_xmlschema_with_fractional_seconds
    @twz += 0.1234560001 # advance the time by a fraction of a second
    assert_equal "1999-12-31T19:00:00.123-05:00", @twz.xmlschema(3)
    assert_equal "1999-12-31T19:00:00.123456-05:00", @twz.xmlschema(6)
    assert_equal "1999-12-31T19:00:00.123456000100-05:00", @twz.xmlschema(12)
  end

  def test_xmlschema_with_fractional_seconds_lower_than_hundred_thousand
    @twz += 0.001234 # advance the time by a fraction
    assert_equal "1999-12-31T19:00:00.001-05:00", @twz.xmlschema(3)
    assert_equal "1999-12-31T19:00:00.001234-05:00", @twz.xmlschema(6)
    assert_equal "1999-12-31T19:00:00.001234000000-05:00", @twz.xmlschema(12)
  end

  def test_xmlschema_with_nil_fractional_seconds
    assert_equal "1999-12-31T19:00:00-05:00", @twz.xmlschema(nil)
  end

  def test_iso8601_with_fractional_seconds
    @twz += Rational(1, 8)
    assert_equal "1999-12-31T19:00:00.125-05:00", @twz.iso8601(3)
  end

  def test_rfc3339_with_fractional_seconds
    @twz += Rational(1, 8)
    assert_equal "1999-12-31T19:00:00.125-05:00", @twz.rfc3339(3)
  end

  def test_to_yaml
    yaml = <<~EOF
      --- !ruby/object:ActiveSupport::TimeWithZone
      utc: 2000-01-01 00:00:00.000000000 Z
      zone: !ruby/object:ActiveSupport::TimeZone
        name: America/New_York
      time: 1999-12-31 19:00:00.000000000 Z
    EOF

    assert_equal(yaml, @twz.to_yaml)
  end

  def test_ruby_to_yaml
    yaml = <<~EOF
      ---
      twz: !ruby/object:ActiveSupport::TimeWithZone
        utc: 2000-01-01 00:00:00.000000000 Z
        zone: !ruby/object:ActiveSupport::TimeZone
          name: America/New_York
        time: 1999-12-31 19:00:00.000000000 Z
    EOF

    assert_equal(yaml, { "twz" => @twz }.to_yaml)
  end

  def test_yaml_load
    yaml = <<~EOF
      --- !ruby/object:ActiveSupport::TimeWithZone
      utc: 2000-01-01 00:00:00.000000000 Z
      zone: !ruby/object:ActiveSupport::TimeZone
        name: America/New_York
      time: 1999-12-31 19:00:00.000000000 Z
    EOF

    assert_equal(@twz, YAML.load(yaml))
  end

  def test_ruby_yaml_load
    yaml = <<~EOF
      ---
      twz: !ruby/object:ActiveSupport::TimeWithZone
        utc: 2000-01-01 00:00:00.000000000 Z
        zone: !ruby/object:ActiveSupport::TimeZone
          name: America/New_York
        time: 1999-12-31 19:00:00.000000000 Z
    EOF

    assert_equal({ "twz" => @twz }, YAML.load(yaml))
  end

  def test_httpdate
    assert_equal "Sat, 01 Jan 2000 00:00:00 GMT", @twz.httpdate
  end

  def test_rfc2822
    assert_equal "Fri, 31 Dec 1999 19:00:00 -0500", @twz.rfc2822
  end

  def test_compare_with_time
    assert_equal 1, @twz <=> Time.utc(1999, 12, 31, 23, 59, 59)
    assert_equal 0, @twz <=> Time.utc(2000, 1, 1, 0, 0, 0)
    assert_equal(-1, @twz <=> Time.utc(2000, 1, 1, 0, 0, 1))
  end

  def test_compare_with_datetime
    assert_equal 1, @twz <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
    assert_equal 0, @twz <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
    assert_equal(-1, @twz <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
  end

  def test_compare_with_time_with_zone
    assert_equal 1, @twz <=> ActiveSupport::TimeWithZone.new(Time.utc(1999, 12, 31, 23, 59, 59), ActiveSupport::TimeZone["UTC"])
    assert_equal 0, @twz <=> ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone["UTC"])
    assert_equal(-1, @twz <=> ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 1), ActiveSupport::TimeZone["UTC"]))
  end

  def test_between?
    assert @twz.between?(Time.utc(1999, 12, 31, 23, 59, 59), Time.utc(2000, 1, 1, 0, 0, 1))
    assert_equal false, @twz.between?(Time.utc(2000, 1, 1, 0, 0, 1), Time.utc(2000, 1, 1, 0, 0, 2))
  end

  def test_today
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 23, 59, 59)).today?
      assert_equal true, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 1, 0)).today?
      assert_equal true, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 1, 23, 59, 59)).today?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 2, 0)).today?
    end
  end

  def test_yesterday?
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 23, 59, 59)).yesterday?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 1, 0)).yesterday?
      assert_equal true,  ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31)).yesterday?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 2, 0)).yesterday?
    end
  end

  def test_prev_day?
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 23, 59, 59)).prev_day?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 1, 0)).prev_day?
      assert_equal true,  ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31)).prev_day?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 2, 0)).prev_day?
    end
  end

  def test_tomorrow?
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 23, 59, 59)).tomorrow?
      assert_equal true,  ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 2, 0)).tomorrow?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 1, 23, 59, 59)).tomorrow?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 0)).tomorrow?
    end
  end

  def test_next_day?
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 23, 59, 59)).next_day?
      assert_equal true,  ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 2, 0)).next_day?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 1, 23, 59, 59)).next_day?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 0)).next_day?
    end
  end

  def test_past_with_time_current_as_time_local
    with_env_tz "US/Eastern" do
      Time.stub(:current, Time.local(2005, 2, 10, 15, 30, 45)) do
        assert_equal true, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 44)).past?
        assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 45)).past?
        assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 46)).past?
      end
    end
  end

  def test_past_with_time_current_as_time_with_zone
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 45))
    Time.stub(:current, twz) do
      assert_equal true, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 44)).past?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 45)).past?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 46)).past?
    end
  end

  def test_future_with_time_current_as_time_local
    with_env_tz "US/Eastern" do
      Time.stub(:current, Time.local(2005, 2, 10, 15, 30, 45)) do
        assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 44)).future?
        assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 45)).future?
        assert_equal true, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 46)).future?
      end
    end
  end

  def test_future_with_time_current_as_time_with_zone
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 45))
    Time.stub(:current, twz) do
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 44)).future?
      assert_equal false, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 45)).future?
      assert_equal true, ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.local(2005, 2, 10, 15, 30, 46)).future?
    end
  end

  def test_before
    twz = ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 12, 0, 0), @time_zone)
    assert_equal false, twz.before?(ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 11, 59, 59), @time_zone))
    assert_equal false, twz.before?(ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 12, 0, 0), @time_zone))
    assert_equal true, twz.before?(ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 12, 00, 1), @time_zone))
  end

  def test_after
    twz = ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 12, 0, 0), @time_zone)
    assert_equal true, twz.after?(ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 11, 59, 59), @time_zone))
    assert_equal false, twz.after?(ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 12, 0, 0), @time_zone))
    assert_equal false, twz.after?(ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 12, 00, 1), @time_zone))
  end

  def test_eql?
    assert_equal true, @twz.eql?(@twz.dup)
    assert_equal true, @twz.eql?(Time.utc(2000))
    assert_equal true, @twz.eql?(ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Hawaii"]))
    assert_equal false, @twz.eql?(Time.utc(2000, 1, 1, 0, 0, 1))
    assert_equal false, @twz.eql?(DateTime.civil(1999, 12, 31, 23, 59, 59))

    other_twz = ActiveSupport::TimeWithZone.new(DateTime.now.utc, @time_zone)
    assert_equal true, other_twz.eql?(other_twz.dup)
  end

  def test_hash
    assert_equal Time.utc(2000).hash, @twz.hash
    assert_equal Time.utc(2000).hash, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Hawaii"]).hash
  end

  def test_plus_with_integer
    assert_equal Time.utc(1999, 12, 31, 19, 0, 5), (@twz + 5).time
  end

  def test_plus_with_integer_when_self_wraps_datetime
    datetime = DateTime.civil(2000, 1, 1, 0)
    twz = ActiveSupport::TimeWithZone.new(datetime, @time_zone)
    assert_equal DateTime.civil(1999, 12, 31, 19, 0, 5), (twz + 5).time
  end

  def test_plus_when_crossing_time_class_limit
    twz = ActiveSupport::TimeWithZone.new(Time.utc(2038, 1, 19), @time_zone)
    assert_equal [0, 0, 19, 19, 1, 2038], (twz + 86_400).to_a[0, 6]
  end

  def test_plus_with_duration
    assert_equal Time.utc(2000, 1, 5, 19, 0, 0), (@twz + 5.days).time
  end

  def test_minus_with_integer
    assert_equal Time.utc(1999, 12, 31, 18, 59, 55), (@twz - 5).time
  end

  def test_minus_with_integer_when_self_wraps_datetime
    datetime = DateTime.civil(2000, 1, 1, 0)
    twz = ActiveSupport::TimeWithZone.new(datetime, @time_zone)
    assert_equal DateTime.civil(1999, 12, 31, 18, 59, 55), (twz - 5).time
  end

  def test_minus_with_duration
    assert_equal Time.utc(1999, 12, 26, 19, 0, 0), (@twz - 5.days).time
  end

  def test_minus_with_time
    assert_equal 86_400.0,  ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2), ActiveSupport::TimeZone["UTC"]) - Time.utc(2000, 1, 1)
    assert_equal 86_400.0,  ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2), ActiveSupport::TimeZone["Hawaii"]) - Time.utc(2000, 1, 1)
  end

  def test_minus_with_time_precision
    assert_equal 86_399.999999998,  ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2, 23, 59, 59, Rational(999999999, 1000)), ActiveSupport::TimeZone["UTC"]) - Time.utc(2000, 1, 2, 0, 0, 0, Rational(1, 1000))
    assert_equal 86_399.999999998,  ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2, 23, 59, 59, Rational(999999999, 1000)), ActiveSupport::TimeZone["Hawaii"]) - Time.utc(2000, 1, 2, 0, 0, 0, Rational(1, 1000))
  end

  def test_minus_with_time_with_zone
    twz1 = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1), ActiveSupport::TimeZone["UTC"])
    twz2 = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2), ActiveSupport::TimeZone["UTC"])
    assert_equal 86_400.0,  twz2 - twz1
  end

  def test_minus_with_time_with_zone_precision
    twz1 = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 0, Rational(1, 1000)), ActiveSupport::TimeZone["UTC"])
    twz2 = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 23, 59, 59, Rational(999999999, 1000)), ActiveSupport::TimeZone["UTC"])
    assert_equal 86_399.999999998,  twz2 - twz1
  end

  def test_minus_with_datetime
    assert_equal 86_400.0,  ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2), ActiveSupport::TimeZone["UTC"]) - DateTime.civil(2000, 1, 1)
  end

  def test_minus_with_datetime_precision
    assert_equal 86_399.999999999,  ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 23, 59, 59, Rational(999999999, 1000)), ActiveSupport::TimeZone["UTC"]) - DateTime.civil(2000, 1, 1)
  end

  def test_minus_with_wrapped_datetime
    assert_equal 86_400.0,  ActiveSupport::TimeWithZone.new(DateTime.civil(2000, 1, 2), ActiveSupport::TimeZone["UTC"]) - Time.utc(2000, 1, 1)
    assert_equal 86_400.0,  ActiveSupport::TimeWithZone.new(DateTime.civil(2000, 1, 2), ActiveSupport::TimeZone["UTC"]) - DateTime.civil(2000, 1, 1)
  end

  def test_plus_and_minus_enforce_spring_dst_rules
    utc = Time.utc(2006, 4, 2, 6, 59, 59) # == Apr 2 2006 01:59:59 EST; i.e., 1 second before daylight savings start
    twz = ActiveSupport::TimeWithZone.new(utc, @time_zone)
    assert_equal Time.utc(2006, 4, 2, 1, 59, 59), twz.time
    assert_equal false, twz.dst?
    assert_equal "EST", twz.zone
    twz = twz + 1
    assert_equal Time.utc(2006, 4, 2, 3), twz.time # adding 1 sec springs forward to 3:00AM EDT
    assert_equal true, twz.dst?
    assert_equal "EDT", twz.zone
    twz = twz - 1 # subtracting 1 second takes goes back to 1:59:59AM EST
    assert_equal Time.utc(2006, 4, 2, 1, 59, 59), twz.time
    assert_equal false, twz.dst?
    assert_equal "EST", twz.zone
  end

  def test_plus_and_minus_enforce_fall_dst_rules
    utc = Time.utc(2006, 10, 29, 5, 59, 59) # == Oct 29 2006 01:59:59 EST; i.e., 1 second before daylight savings end
    twz = ActiveSupport::TimeWithZone.new(utc, @time_zone)
    assert_equal Time.utc(2006, 10, 29, 1, 59, 59), twz.time
    assert_equal true, twz.dst?
    assert_equal "EDT", twz.zone
    twz = twz + 1
    assert_equal Time.utc(2006, 10, 29, 1), twz.time # adding 1 sec falls back from 1:59:59 EDT to 1:00AM EST
    assert_equal false, twz.dst?
    assert_equal "EST", twz.zone
    twz = twz - 1
    assert_equal Time.utc(2006, 10, 29, 1, 59, 59), twz.time # subtracting 1 sec goes back to 1:59:59AM EDT
    assert_equal true, twz.dst?
    assert_equal "EDT", twz.zone
  end

  def test_to_a
    assert_equal [45, 30, 5, 1, 2, 2000, 2, 32, false, "HST"], ActiveSupport::TimeWithZone.new(Time.utc(2000, 2, 1, 15, 30, 45), ActiveSupport::TimeZone["Hawaii"]).to_a
  end

  def test_to_f
    result = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1), ActiveSupport::TimeZone["Hawaii"]).to_f
    assert_equal 946684800.0, result
    assert_kind_of Float, result
  end

  def test_to_i
    result = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1), ActiveSupport::TimeZone["Hawaii"]).to_i
    assert_equal 946684800, result
    assert_kind_of Integer, result
  end

  def test_to_i_with_wrapped_datetime
    datetime = DateTime.civil(2000, 1, 1, 0)
    twz = ActiveSupport::TimeWithZone.new(datetime, @time_zone)
    assert_equal 946684800, twz.to_i
  end

  def test_to_r
    result = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1), ActiveSupport::TimeZone["Hawaii"]).to_r
    assert_equal Rational(946684800, 1), result
    assert_kind_of Rational, result
  end

  def test_time_at
    time = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1), ActiveSupport::TimeZone["Hawaii"])
    assert_equal time, Time.at(time)
  end

  def test_to_time_with_preserve_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        time = @twz.to_time

        assert_equal Time, time.class
        assert_equal time.object_id, @twz.to_time.object_id
        assert_equal Time.local(1999, 12, 31, 19), time
        assert_equal Time.local(1999, 12, 31, 19).utc_offset, time.utc_offset
      end
    end
  end

  def test_to_time_without_preserve_timezone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        time = @twz.to_time

        assert_equal Time, time.class
        assert_equal time.object_id, @twz.to_time.object_id
        assert_equal Time.local(1999, 12, 31, 19), time
        assert_equal Time.local(1999, 12, 31, 19).utc_offset, time.utc_offset
      end
    end
  end

  def test_to_date
    # 1 sec before midnight Jan 1 EST
    assert_equal Date.new(1999, 12, 31), ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 4, 59, 59), ActiveSupport::TimeZone["Eastern Time (US & Canada)"]).to_date
    # midnight Jan 1 EST
    assert_equal Date.new(2000,  1,  1), ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 5,  0,  0), ActiveSupport::TimeZone["Eastern Time (US & Canada)"]).to_date
    # 1 sec before midnight Jan 2 EST
    assert_equal Date.new(2000,  1,  1), ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2, 4, 59, 59), ActiveSupport::TimeZone["Eastern Time (US & Canada)"]).to_date
    # midnight Jan 2 EST
    assert_equal Date.new(2000,  1,  2), ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 2, 5,  0,  0), ActiveSupport::TimeZone["Eastern Time (US & Canada)"]).to_date
  end

  def test_to_datetime
    assert_equal DateTime.civil(1999, 12, 31, 19, 0, 0, Rational(-18_000, 86_400)),  @twz.to_datetime
  end

  def test_acts_like_time
    assert_predicate @twz, :acts_like_time?
    assert @twz.acts_like?(:time)
    assert ActiveSupport::TimeWithZone.new(DateTime.civil(2000), @time_zone).acts_like?(:time)
  end

  def test_acts_like_date
    assert_equal false, @twz.acts_like?(:date)
    assert_equal false, ActiveSupport::TimeWithZone.new(DateTime.civil(2000), @time_zone).acts_like?(:date)
  end

  def test_blank?
    assert_not_predicate @twz, :blank?
  end

  def test_is_a
    assert_kind_of Time, @twz
    assert_kind_of Time, @twz
    assert_kind_of ActiveSupport::TimeWithZone, @twz
  end

  def test_class_name
    assert_equal "Time", ActiveSupport::TimeWithZone.name
  end

  def test_method_missing_with_time_return_value
    assert_instance_of ActiveSupport::TimeWithZone, @twz.months_since(1)
    assert_equal Time.utc(2000, 1, 31, 19, 0, 0), @twz.months_since(1).time
  end

  def test_marshal_dump_and_load
    marshal_str = Marshal.dump(@twz)
    mtime = Marshal.load(marshal_str)
    assert_equal Time.utc(2000, 1, 1, 0), mtime.utc
    assert_predicate mtime.utc, :utc?
    assert_equal ActiveSupport::TimeZone["Eastern Time (US & Canada)"], mtime.time_zone
    assert_equal Time.utc(1999, 12, 31, 19), mtime.time
    assert_predicate mtime.time, :utc?
    assert_equal @twz.inspect, mtime.inspect
  end

  def test_marshal_dump_and_load_with_tzinfo_identifier
    twz = ActiveSupport::TimeWithZone.new(@utc, TZInfo::Timezone.get("America/New_York"))
    marshal_str = Marshal.dump(twz)
    mtime = Marshal.load(marshal_str)
    assert_equal Time.utc(2000, 1, 1, 0), mtime.utc
    assert_predicate mtime.utc, :utc?
    assert_equal "America/New_York", mtime.time_zone.name
    assert_equal Time.utc(1999, 12, 31, 19), mtime.time
    assert_predicate mtime.time, :utc?
    assert_equal @twz.inspect, mtime.inspect
  end

  def test_freeze
    @twz.freeze
    assert_predicate @twz, :frozen?
  end

  def test_freeze_preloads_instance_variables
    @twz.freeze
    assert_nothing_raised do
      @twz.period
      @twz.time
      @twz.to_datetime
      @twz.to_time
    end
  end

  def test_method_missing_with_non_time_return_value
    time = @twz.time
    def time.foo; "bar"; end
    assert_equal "bar", @twz.foo
  end

  def test_date_part_value_methods
    twz = ActiveSupport::TimeWithZone.new(Time.utc(1999, 12, 31, 19, 18, 17, 500), @time_zone)
    assert_not_called(twz, :method_missing) do
      assert_equal 1999, twz.year
      assert_equal 12, twz.month
      assert_equal 31, twz.day
      assert_equal 14, twz.hour
      assert_equal 18, twz.min
      assert_equal 17, twz.sec
      assert_equal 500, twz.usec
      assert_equal 5, twz.wday
      assert_equal 365, twz.yday
    end
  end

  def test_usec_returns_0_when_datetime_is_wrapped
    twz = ActiveSupport::TimeWithZone.new(DateTime.civil(2000), @time_zone)
    assert_equal 0, twz.usec
  end

  def test_usec_returns_sec_fraction_when_datetime_is_wrapped
    twz = ActiveSupport::TimeWithZone.new(DateTime.civil(2000, 1, 1, 0, 0, Rational(1, 2)), @time_zone)
    assert_equal 500000, twz.usec
  end

  def test_nsec_returns_sec_fraction_when_datetime_is_wrapped
    twz = ActiveSupport::TimeWithZone.new(DateTime.civil(2000, 1, 1, 0, 0, Rational(1, 2)), @time_zone)
    assert_equal 500000000, twz.nsec
  end

  def test_utc_to_local_conversion_saves_period_in_instance_variable
    assert_nil @twz.instance_variable_get("@period")
    @twz.time
    assert_kind_of TZInfo::TimezonePeriod, @twz.instance_variable_get("@period")
  end

  def test_instance_created_with_local_time_returns_correct_utc_time
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 19))
    assert_equal Time.utc(2000), twz.utc
  end

  def test_instance_created_with_local_time_enforces_spring_dst_rules
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 2, 2)) # first second of DST
    assert_equal Time.utc(2006, 4, 2, 3), twz.time # springs forward to 3AM
    assert_equal true, twz.dst?
    assert_equal "EDT", twz.zone
  end

  def test_instance_created_with_local_time_enforces_fall_dst_rules
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 10, 29, 1)) # 1AM can be either DST or non-DST; we'll pick DST
    assert_equal Time.utc(2006, 10, 29, 1), twz.time
    assert_equal true, twz.dst?
    assert_equal "EDT", twz.zone
  end

  def test_ruby_19_weekday_name_query_methods
    %w(sunday? monday? tuesday? wednesday? thursday? friday? saturday?).each do |name|
      assert_respond_to @twz, name
      assert_equal @twz.public_send(name), @twz.method(name).call
    end
  end

  def test_utc_to_local_conversion_with_far_future_datetime
    assert_equal [0, 0, 19, 31, 12, 2049], ActiveSupport::TimeWithZone.new(DateTime.civil(2050), @time_zone).to_a[0, 6]
  end

  def test_local_to_utc_conversion_with_far_future_datetime
    assert_equal DateTime.civil(2050).to_f, ActiveSupport::TimeWithZone.new(nil, @time_zone, DateTime.civil(2049, 12, 31, 19)).to_f
  end

  def test_change
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Mon, 31 Dec 2001 19:00:00.000000000 EST -05:00", @twz.change(year: 2001).inspect
    assert_equal "Wed, 31 Mar 1999 19:00:00.000000000 EST -05:00", @twz.change(month: 3).inspect
    assert_equal "Wed, 03 Mar 1999 19:00:00.000000000 EST -05:00", @twz.change(month: 2).inspect
    assert_equal "Wed, 15 Dec 1999 19:00:00.000000000 EST -05:00", @twz.change(day: 15).inspect
    assert_equal "Fri, 31 Dec 1999 06:00:00.000000000 EST -05:00", @twz.change(hour: 6).inspect
    assert_equal "Fri, 31 Dec 1999 19:15:00.000000000 EST -05:00", @twz.change(min: 15).inspect
    assert_equal "Fri, 31 Dec 1999 19:00:30.000000000 EST -05:00", @twz.change(sec: 30).inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 HST -10:00", @twz.change(offset: "-10:00").inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 HST -10:00", @twz.change(offset: -36000).inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 HST -10:00", @twz.change(zone: "Hawaii").inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 HST -10:00", @twz.change(zone: -10).inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 HST -10:00", @twz.change(zone: -36000).inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 HST -10:00", @twz.change(zone: "Pacific/Honolulu").inspect
  end

  def test_change_at_dst_boundary
    twz = ActiveSupport::TimeWithZone.new(Time.at(1319936400).getutc, ActiveSupport::TimeZone["Madrid"])
    assert_equal twz, twz.change(min: 0)
  end

  def test_round_at_dst_boundary
    twz = ActiveSupport::TimeWithZone.new(Time.at(1319936400).getutc, ActiveSupport::TimeZone["Madrid"])
    assert_equal twz, twz.round
  end

  def test_advance
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Mon, 31 Dec 2001 19:00:00.000000000 EST -05:00", @twz.advance(years: 2).inspect
    assert_equal "Fri, 31 Mar 2000 19:00:00.000000000 EST -05:00", @twz.advance(months: 3).inspect
    assert_equal "Tue, 04 Jan 2000 19:00:00.000000000 EST -05:00", @twz.advance(days: 4).inspect
    assert_equal "Sat, 01 Jan 2000 01:00:00.000000000 EST -05:00", @twz.advance(hours: 6).inspect
    assert_equal "Fri, 31 Dec 1999 19:15:00.000000000 EST -05:00", @twz.advance(minutes: 15).inspect
    assert_equal "Fri, 31 Dec 1999 19:00:30.000000000 EST -05:00", @twz.advance(seconds: 30).inspect
  end

  def test_beginning_of_year
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Fri, 01 Jan 1999 00:00:00.000000000 EST -05:00", @twz.beginning_of_year.inspect
  end

  def test_end_of_year
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Fri, 31 Dec 1999 23:59:59.999999999 EST -05:00", @twz.end_of_year.inspect
  end

  def test_beginning_of_month
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Wed, 01 Dec 1999 00:00:00.000000000 EST -05:00", @twz.beginning_of_month.inspect
  end

  def test_end_of_month
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Fri, 31 Dec 1999 23:59:59.999999999 EST -05:00", @twz.end_of_month.inspect
  end

  def test_beginning_of_day
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Fri, 31 Dec 1999 00:00:00.000000000 EST -05:00", @twz.beginning_of_day.inspect
  end

  def test_end_of_day
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", @twz.inspect
    assert_equal "Fri, 31 Dec 1999 23:59:59.999999999 EST -05:00", @twz.end_of_day.inspect
  end

  def test_beginning_of_hour
    utc = Time.utc(2000, 1, 1, 0, 30)
    twz = ActiveSupport::TimeWithZone.new(utc, @time_zone)
    assert_equal "Fri, 31 Dec 1999 19:30:00.000000000 EST -05:00", twz.inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", twz.beginning_of_hour.inspect
  end

  def test_end_of_hour
    utc = Time.utc(2000, 1, 1, 0, 30)
    twz = ActiveSupport::TimeWithZone.new(utc, @time_zone)
    assert_equal "Fri, 31 Dec 1999 19:30:00.000000000 EST -05:00", twz.inspect
    assert_equal "Fri, 31 Dec 1999 19:59:59.999999999 EST -05:00", twz.end_of_hour.inspect
  end

  def test_beginning_of_minute
    utc = Time.utc(2000, 1, 1, 0, 30, 10)
    twz = ActiveSupport::TimeWithZone.new(utc, @time_zone)
    assert_equal "Fri, 31 Dec 1999 19:30:10.000000000 EST -05:00", twz.inspect
    assert_equal "Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00", twz.beginning_of_hour.inspect
  end

  def test_end_of_minute
    utc = Time.utc(2000, 1, 1, 0, 30, 10)
    twz = ActiveSupport::TimeWithZone.new(utc, @time_zone)
    assert_equal "Fri, 31 Dec 1999 19:30:10.000000000 EST -05:00", twz.inspect
    assert_equal "Fri, 31 Dec 1999 19:30:59.999999999 EST -05:00", twz.end_of_minute.inspect
  end

  def test_since
    assert_equal "Fri, 31 Dec 1999 19:00:01.000000000 EST -05:00", @twz.since(1).inspect
  end

  def test_in
    assert_equal "Fri, 31 Dec 1999 19:00:01.000000000 EST -05:00", @twz.in(1).inspect
  end

  def test_ago
    assert_equal "Fri, 31 Dec 1999 18:59:59.000000000 EST -05:00", @twz.ago(1).inspect
  end

  def test_seconds_since_midnight
    assert_equal 19 * 60 * 60, @twz.seconds_since_midnight
  end

  def test_advance_1_year_from_leap_day
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2004, 2, 29))
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.advance(years: 1).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.years_since(1).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.since(1.year).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.in(1.year).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", (twz + 1.year).inspect
  end

  def test_advance_1_month_from_last_day_of_january
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2005, 1, 31))
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.advance(months: 1).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.months_since(1).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.since(1.month).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", twz.in(1.month).inspect
    assert_equal "Mon, 28 Feb 2005 00:00:00.000000000 EST -05:00", (twz + 1.month).inspect
  end

  def test_advance_1_month_from_last_day_of_january_during_leap_year
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000, 1, 31))
    assert_equal "Tue, 29 Feb 2000 00:00:00.000000000 EST -05:00", twz.advance(months: 1).inspect
    assert_equal "Tue, 29 Feb 2000 00:00:00.000000000 EST -05:00", twz.months_since(1).inspect
    assert_equal "Tue, 29 Feb 2000 00:00:00.000000000 EST -05:00", twz.since(1.month).inspect
    assert_equal "Tue, 29 Feb 2000 00:00:00.000000000 EST -05:00", twz.in(1.month).inspect
    assert_equal "Tue, 29 Feb 2000 00:00:00.000000000 EST -05:00", (twz + 1.month).inspect
  end

  def test_advance_1_month_into_spring_dst_gap
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 3, 2, 2))
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.advance(months: 1).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.months_since(1).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.since(1.month).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.in(1.month).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", (twz + 1.month).inspect
  end

  def test_advance_1_second_into_spring_dst_gap
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 2, 1, 59, 59))
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.advance(seconds: 1).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", (twz + 1).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", (twz + 1.second).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.since(1).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.since(1.second).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.in(1).inspect
    assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", twz.in(1.second).inspect
  end

  def test_advance_1_day_across_spring_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 1, 10, 30))
    # In 2006, spring DST transition occurred Apr 2 at 2AM; this day was only 23 hours long
    # When we advance 1 day, we want to end up at the same time on the next day
    assert_equal "Sun, 02 Apr 2006 10:30:00.000000000 EDT -04:00", twz.advance(days: 1).inspect
    assert_equal "Sun, 02 Apr 2006 10:30:00.000000000 EDT -04:00", twz.since(1.days).inspect
    assert_equal "Sun, 02 Apr 2006 10:30:00.000000000 EDT -04:00", twz.in(1.days).inspect
    assert_equal "Sun, 02 Apr 2006 10:30:00.000000000 EDT -04:00", (twz + 1.days).inspect
    assert_equal "Sun, 02 Apr 2006 10:30:01.000000000 EDT -04:00", twz.since(1.days + 1.second).inspect
    assert_equal "Sun, 02 Apr 2006 10:30:01.000000000 EDT -04:00", twz.in(1.days + 1.second).inspect
    assert_equal "Sun, 02 Apr 2006 10:30:01.000000000 EDT -04:00", (twz + 1.days + 1.second).inspect
  end

  def test_advance_1_day_across_spring_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 2, 10, 30))
    # In 2006, spring DST transition occurred Apr 2 at 2AM; this day was only 23 hours long
    # When we advance back 1 day, we want to end up at the same time on the previous day
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.advance(days: -1).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.ago(1.days).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", (twz - 1.days).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:01.000000000 EST -05:00", twz.ago(1.days - 1.second).inspect
  end

  def test_advance_1_day_expressed_as_number_of_seconds_minutes_or_hours_across_spring_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 1, 10, 30))
    # In 2006, spring DST transition occurred Apr 2 at 2AM; this day was only 23 hours long
    # When we advance a specific number of hours, minutes or seconds, we want to advance exactly that amount
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", (twz + 86400).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", (twz + 86400.seconds).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.since(86400).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.since(86400.seconds).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.in(86400).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.in(86400.seconds).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.advance(seconds: 86400).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", (twz + 1440.minutes).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.since(1440.minutes).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.in(1440.minutes).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.advance(minutes: 1440).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", (twz + 24.hours).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.since(24.hours).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.in(24.hours).inspect
    assert_equal "Sun, 02 Apr 2006 11:30:00.000000000 EDT -04:00", twz.advance(hours: 24).inspect
  end

  def test_advance_1_day_expressed_as_number_of_seconds_minutes_or_hours_across_spring_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 2, 11, 30))
    # In 2006, spring DST transition occurred Apr 2 at 2AM; this day was only 23 hours long
    # When we advance a specific number of hours, minutes or seconds, we want to advance exactly that amount
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", (twz - 86400).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", (twz - 86400.seconds).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.ago(86400).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.ago(86400.seconds).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.advance(seconds: -86400).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", (twz - 1440.minutes).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.ago(1440.minutes).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.advance(minutes: -1440).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", (twz - 24.hours).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.ago(24.hours).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.advance(hours: -24).inspect
  end

  def test_advance_1_day_across_fall_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 10, 28, 10, 30))
    # In 2006, fall DST transition occurred Oct 29 at 2AM; this day was 25 hours long
    # When we advance 1 day, we want to end up at the same time on the next day
    assert_equal "Sun, 29 Oct 2006 10:30:00.000000000 EST -05:00", twz.advance(days: 1).inspect
    assert_equal "Sun, 29 Oct 2006 10:30:00.000000000 EST -05:00", twz.since(1.days).inspect
    assert_equal "Sun, 29 Oct 2006 10:30:00.000000000 EST -05:00", twz.in(1.days).inspect
    assert_equal "Sun, 29 Oct 2006 10:30:00.000000000 EST -05:00", (twz + 1.days).inspect
    assert_equal "Sun, 29 Oct 2006 10:30:01.000000000 EST -05:00", twz.since(1.days + 1.second).inspect
    assert_equal "Sun, 29 Oct 2006 10:30:01.000000000 EST -05:00", twz.in(1.days + 1.second).inspect
    assert_equal "Sun, 29 Oct 2006 10:30:01.000000000 EST -05:00", (twz + 1.days + 1.second).inspect
  end

  def test_advance_1_day_across_fall_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 10, 29, 10, 30))
    # In 2006, fall DST transition occurred Oct 29 at 2AM; this day was 25 hours long
    # When we advance backwards 1 day, we want to end up at the same time on the previous day
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.advance(days: -1).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.ago(1.days).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", (twz - 1.days).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:01.000000000 EDT -04:00", twz.ago(1.days - 1.second).inspect
  end

  def test_advance_1_day_expressed_as_number_of_seconds_minutes_or_hours_across_fall_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 10, 28, 10, 30))
    # In 2006, fall DST transition occurred Oct 29 at 2AM; this day was 25 hours long
    # When we advance a specific number of hours, minutes or seconds, we want to advance exactly that amount
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", (twz + 86400).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", (twz + 86400.seconds).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.since(86400).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.since(86400.seconds).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.in(86400).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.in(86400.seconds).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.advance(seconds: 86400).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", (twz + 1440.minutes).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.since(1440.minutes).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.in(1440.minutes).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.advance(minutes: 1440).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", (twz + 24.hours).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.since(24.hours).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.in(24.hours).inspect
    assert_equal "Sun, 29 Oct 2006 09:30:00.000000000 EST -05:00", twz.advance(hours: 24).inspect
  end

  def test_advance_1_day_expressed_as_number_of_seconds_minutes_or_hours_across_fall_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 10, 29, 9, 30))
    # In 2006, fall DST transition occurred Oct 29 at 2AM; this day was 25 hours long
    # When we advance a specific number of hours, minutes or seconds, we want to advance exactly that amount
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", (twz - 86400).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", (twz - 86400.seconds).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.ago(86400).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.ago(86400.seconds).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.advance(seconds: -86400).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", (twz - 1440.minutes).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.ago(1440.minutes).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.advance(minutes: -1440).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", (twz - 24.hours).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.ago(24.hours).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.advance(hours: -24).inspect
  end

  def test_advance_1_week_across_spring_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 1, 10, 30))
    assert_equal "Sat, 08 Apr 2006 10:30:00.000000000 EDT -04:00", twz.advance(weeks: 1).inspect
    assert_equal "Sat, 08 Apr 2006 10:30:00.000000000 EDT -04:00", twz.weeks_since(1).inspect
    assert_equal "Sat, 08 Apr 2006 10:30:00.000000000 EDT -04:00", twz.since(1.week).inspect
    assert_equal "Sat, 08 Apr 2006 10:30:00.000000000 EDT -04:00", twz.in(1.week).inspect
    assert_equal "Sat, 08 Apr 2006 10:30:00.000000000 EDT -04:00", (twz + 1.week).inspect
  end

  def test_advance_1_week_across_spring_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 8, 10, 30))
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.advance(weeks: -1).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.weeks_ago(1).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.ago(1.week).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", (twz - 1.week).inspect
  end

  def test_advance_1_week_across_fall_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 10, 28, 10, 30))
    assert_equal "Sat, 04 Nov 2006 10:30:00.000000000 EST -05:00", twz.advance(weeks: 1).inspect
    assert_equal "Sat, 04 Nov 2006 10:30:00.000000000 EST -05:00", twz.weeks_since(1).inspect
    assert_equal "Sat, 04 Nov 2006 10:30:00.000000000 EST -05:00", twz.since(1.week).inspect
    assert_equal "Sat, 04 Nov 2006 10:30:00.000000000 EST -05:00", twz.in(1.week).inspect
    assert_equal "Sat, 04 Nov 2006 10:30:00.000000000 EST -05:00", (twz + 1.week).inspect
  end

  def test_advance_1_week_across_fall_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 11, 4, 10, 30))
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.advance(weeks: -1).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.weeks_ago(1).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.ago(1.week).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", (twz - 1.week).inspect
  end

  def test_advance_1_month_across_spring_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 1, 10, 30))
    assert_equal "Mon, 01 May 2006 10:30:00.000000000 EDT -04:00", twz.advance(months: 1).inspect
    assert_equal "Mon, 01 May 2006 10:30:00.000000000 EDT -04:00", twz.months_since(1).inspect
    assert_equal "Mon, 01 May 2006 10:30:00.000000000 EDT -04:00", twz.since(1.month).inspect
    assert_equal "Mon, 01 May 2006 10:30:00.000000000 EDT -04:00", twz.in(1.month).inspect
    assert_equal "Mon, 01 May 2006 10:30:00.000000000 EDT -04:00", (twz + 1.month).inspect
  end

  def test_advance_1_month_across_spring_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 5, 1, 10, 30))
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.advance(months: -1).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.months_ago(1).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", twz.ago(1.month).inspect
    assert_equal "Sat, 01 Apr 2006 10:30:00.000000000 EST -05:00", (twz - 1.month).inspect
  end

  def test_advance_1_month_across_fall_dst_transition
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 10, 28, 10, 30))
    assert_equal "Tue, 28 Nov 2006 10:30:00.000000000 EST -05:00", twz.advance(months: 1).inspect
    assert_equal "Tue, 28 Nov 2006 10:30:00.000000000 EST -05:00", twz.months_since(1).inspect
    assert_equal "Tue, 28 Nov 2006 10:30:00.000000000 EST -05:00", twz.since(1.month).inspect
    assert_equal "Tue, 28 Nov 2006 10:30:00.000000000 EST -05:00", twz.in(1.month).inspect
    assert_equal "Tue, 28 Nov 2006 10:30:00.000000000 EST -05:00", (twz + 1.month).inspect
  end

  def test_advance_1_month_across_fall_dst_transition_backwards
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 11, 28, 10, 30))
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.advance(months: -1).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.months_ago(1).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", twz.ago(1.month).inspect
    assert_equal "Sat, 28 Oct 2006 10:30:00.000000000 EDT -04:00", (twz - 1.month).inspect
  end

  def test_advance_1_year
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2008, 2, 15, 10, 30))
    assert_equal "Sun, 15 Feb 2009 10:30:00.000000000 EST -05:00", twz.advance(years: 1).inspect
    assert_equal "Sun, 15 Feb 2009 10:30:00.000000000 EST -05:00", twz.years_since(1).inspect
    assert_equal "Sun, 15 Feb 2009 10:30:00.000000000 EST -05:00", twz.since(1.year).inspect
    assert_equal "Sun, 15 Feb 2009 10:30:00.000000000 EST -05:00", twz.in(1.year).inspect
    assert_equal "Sun, 15 Feb 2009 10:30:00.000000000 EST -05:00", (twz + 1.year).inspect
    assert_equal "Thu, 15 Feb 2007 10:30:00.000000000 EST -05:00", twz.advance(years: -1).inspect
    assert_equal "Thu, 15 Feb 2007 10:30:00.000000000 EST -05:00", twz.years_ago(1).inspect
    assert_equal "Thu, 15 Feb 2007 10:30:00.000000000 EST -05:00", (twz - 1.year).inspect
  end

  def test_advance_1_year_during_dst
    twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2008, 7, 15, 10, 30))
    assert_equal "Wed, 15 Jul 2009 10:30:00.000000000 EDT -04:00", twz.advance(years: 1).inspect
    assert_equal "Wed, 15 Jul 2009 10:30:00.000000000 EDT -04:00", twz.years_since(1).inspect
    assert_equal "Wed, 15 Jul 2009 10:30:00.000000000 EDT -04:00", twz.since(1.year).inspect
    assert_equal "Wed, 15 Jul 2009 10:30:00.000000000 EDT -04:00", twz.in(1.year).inspect
    assert_equal "Wed, 15 Jul 2009 10:30:00.000000000 EDT -04:00", (twz + 1.year).inspect
    assert_equal "Sun, 15 Jul 2007 10:30:00.000000000 EDT -04:00", twz.advance(years: -1).inspect
    assert_equal "Sun, 15 Jul 2007 10:30:00.000000000 EDT -04:00", twz.years_ago(1).inspect
    assert_equal "Sun, 15 Jul 2007 10:30:00.000000000 EDT -04:00", (twz - 1.year).inspect
  end

  def test_no_method_error_has_proper_context
    rubinius_skip "Error message inconsistency"

    e = assert_raises(NoMethodError) {
      @twz.this_method_does_not_exist
    }
    assert_equal "undefined method `this_method_does_not_exist' for Fri, 31 Dec 1999 19:00:00.000000000 EST -05:00:Time", e.message
    assert_no_match "rescue", e.backtrace.first
  end
end

class TimeWithZoneMethodsForTimeAndDateTimeTest < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def setup
    @t, @dt, @zone = Time.utc(2000), DateTime.civil(2000), Time.zone
  end

  def teardown
    Time.zone = @zone
  end

  def test_in_time_zone
    Time.use_zone "Alaska" do
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @t.in_time_zone.inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @dt.in_time_zone.inspect
    end
    Time.use_zone "Hawaii" do
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @t.in_time_zone.inspect
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @dt.in_time_zone.inspect
    end
    Time.use_zone nil do
      assert_equal @t, @t.in_time_zone
      assert_equal @dt, @dt.in_time_zone
    end
  end

  def test_nil_time_zone
    Time.use_zone nil do
      assert_not_respond_to @t.in_time_zone, :period, "no period method"
      assert_not_respond_to @dt.in_time_zone, :period, "no period method"
    end
  end

  def test_in_time_zone_with_argument
    Time.use_zone "Eastern Time (US & Canada)" do # Time.zone will not affect #in_time_zone(zone)
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @t.in_time_zone("Alaska").inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @dt.in_time_zone("Alaska").inspect
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @t.in_time_zone("Hawaii").inspect
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @dt.in_time_zone("Hawaii").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 UTC +00:00", @t.in_time_zone("UTC").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 UTC +00:00", @dt.in_time_zone("UTC").inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @t.in_time_zone(-9.hours).inspect
    end
  end

  def test_in_time_zone_with_invalid_argument
    assert_raise(ArgumentError) {  @t.in_time_zone("No such timezone exists") }
    assert_raise(ArgumentError) { @dt.in_time_zone("No such timezone exists") }
    assert_raise(ArgumentError) {  @t.in_time_zone(-15.hours) }
    assert_raise(ArgumentError) { @dt.in_time_zone(-15.hours) }
    assert_raise(ArgumentError) {  @t.in_time_zone(Object.new) }
    assert_raise(ArgumentError) { @dt.in_time_zone(Object.new) }
  end

  def test_in_time_zone_with_time_local_instance
    with_env_tz "US/Eastern" do
      time = Time.local(1999, 12, 31, 19) # == Time.utc(2000)
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", time.in_time_zone("Alaska").inspect
    end
  end

  def test_localtime
    Time.zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    assert_equal @dt.in_time_zone.localtime, @dt.in_time_zone.utc.to_time.getlocal
  end

  def test_use_zone
    Time.zone = "Alaska"
    Time.use_zone "Hawaii" do
      assert_equal ActiveSupport::TimeZone["Hawaii"], Time.zone
    end
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
  end

  def test_use_zone_with_exception_raised
    Time.zone = "Alaska"
    assert_raise RuntimeError do
      Time.use_zone("Hawaii") { raise RuntimeError }
    end
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
  end

  def test_use_zone_raises_on_invalid_timezone
    Time.zone = "Alaska"
    assert_raise ArgumentError do
      Time.use_zone("No such timezone exists") { }
    end
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
  end

  def test_time_at_precision
    Time.use_zone "UTC" do
      time = "2019-01-01 00:00:00Z".to_time.end_of_month
      assert_equal Time.at(time), Time.at(time.in_time_zone)
    end
  end

  def test_time_zone_getter_and_setter
    Time.zone = ActiveSupport::TimeZone["Alaska"]
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
    Time.zone = "Alaska"
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
    Time.zone = -9.hours
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
    Time.zone = nil
    assert_nil Time.zone
  end

  def test_time_zone_getter_and_setter_with_zone_default_set
    old_zone_default = Time.zone_default
    Time.zone_default = ActiveSupport::TimeZone["Alaska"]
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
    Time.zone = ActiveSupport::TimeZone["Hawaii"]
    assert_equal ActiveSupport::TimeZone["Hawaii"], Time.zone
    Time.zone = nil
    assert_equal ActiveSupport::TimeZone["Alaska"], Time.zone
  ensure
    Time.zone_default = old_zone_default
  end

  def test_time_zone_setter_is_thread_safe
    Time.use_zone "Paris" do
      t1 = Thread.new { Time.zone = "Alaska" }.join
      t2 = Thread.new { Time.zone = "Hawaii" }.join
      assert t1.stop?, "Thread 1 did not finish running"
      assert t2.stop?, "Thread 2 did not finish running"
      assert_equal ActiveSupport::TimeZone["Paris"], Time.zone
      assert_equal ActiveSupport::TimeZone["Alaska"], t1[:time_zone]
      assert_equal ActiveSupport::TimeZone["Hawaii"], t2[:time_zone]
    end
  end

  def test_time_zone_setter_with_tzinfo_timezone_object_wraps_in_rails_time_zone
    tzinfo = TZInfo::Timezone.get("America/New_York")
    Time.zone = tzinfo
    assert_kind_of ActiveSupport::TimeZone, Time.zone
    assert_equal tzinfo, Time.zone.tzinfo
    assert_equal "America/New_York", Time.zone.name
    assert_equal(-18_000, Time.zone.utc_offset)
  end

  def test_time_zone_setter_with_tzinfo_timezone_identifier_does_lookup_and_wraps_in_rails_time_zone
    Time.zone = "America/New_York"
    assert_kind_of ActiveSupport::TimeZone, Time.zone
    assert_equal "America/New_York", Time.zone.tzinfo.name
    assert_equal "America/New_York", Time.zone.name
    assert_equal(-18_000, Time.zone.utc_offset)
  end

  def test_time_zone_setter_with_invalid_zone
    assert_raise(ArgumentError) { Time.zone = "No such timezone exists" }
    assert_raise(ArgumentError) { Time.zone = -15.hours }
    assert_raise(ArgumentError) { Time.zone = Object.new }
  end

  def test_find_zone_without_bang_returns_nil_if_time_zone_can_not_be_found
    assert_nil Time.find_zone("No such timezone exists")
    assert_nil Time.find_zone(-15.hours)
    assert_nil Time.find_zone(Object.new)
  end

  def test_find_zone_with_bang_raises_if_time_zone_can_not_be_found
    assert_raise(ArgumentError) { Time.find_zone!("No such timezone exists") }
    assert_raise(ArgumentError) { Time.find_zone!(-15.hours) }
    assert_raise(ArgumentError) { Time.find_zone!(Object.new) }
  end

  def test_time_zone_setter_with_find_zone_without_bang
    assert_nil Time.zone = Time.find_zone("No such timezone exists")
    assert_nil Time.zone = Time.find_zone(-15.hours)
    assert_nil Time.zone = Time.find_zone(Object.new)
  end

  def test_current_returns_time_now_when_zone_not_set
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2000)) do
        assert_equal false, Time.current.is_a?(ActiveSupport::TimeWithZone)
        assert_equal Time.local(2000), Time.current
      end
    end
  end

  def test_current_returns_time_zone_now_when_zone_set
    Time.zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2000)) do
        assert_equal true, Time.current.is_a?(ActiveSupport::TimeWithZone)
        assert_equal "Eastern Time (US & Canada)", Time.current.time_zone.name
        assert_equal Time.utc(2000), Time.current.time
      end
    end
  end

  def test_time_in_time_zone_doesnt_affect_receiver
    with_env_tz "Europe/London" do
      time = Time.local(2000, 7, 1)
      time_with_zone = time.in_time_zone("Eastern Time (US & Canada)")
      assert_equal Time.utc(2000, 6, 30, 23, 0, 0), time_with_zone
      assert_not time.utc?, "time expected to be local, but is UTC"
    end
  end
end

class TimeWithZoneMethodsForDate < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def setup
    @d = Date.civil(2000)
  end

  def test_in_time_zone
    with_tz_default "Alaska" do
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 AKST -09:00", @d.in_time_zone.inspect
    end
    with_tz_default "Hawaii" do
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 HST -10:00", @d.in_time_zone.inspect
    end
    with_tz_default nil do
      assert_equal @d.to_time, @d.in_time_zone
    end
  end

  def test_nil_time_zone
    with_tz_default nil do
      assert_not_respond_to @d.in_time_zone, :period, "no period method"
    end
  end

  def test_in_time_zone_with_argument
    with_tz_default "Eastern Time (US & Canada)" do # Time.zone will not affect #in_time_zone(zone)
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 AKST -09:00", @d.in_time_zone("Alaska").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 HST -10:00", @d.in_time_zone("Hawaii").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 UTC +00:00", @d.in_time_zone("UTC").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 AKST -09:00", @d.in_time_zone(-9.hours).inspect
    end
  end

  def test_in_time_zone_with_invalid_argument
    assert_raise(ArgumentError) { @d.in_time_zone("No such timezone exists") }
    assert_raise(ArgumentError) { @d.in_time_zone(-15.hours) }
    assert_raise(ArgumentError) { @d.in_time_zone(Object.new) }
  end
end

class TimeWithZoneMethodsForString < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def setup
    @s = "Sat, 01 Jan 2000 00:00:00"
    @u = "Sat, 01 Jan 2000 00:00:00 UTC +00:00"
    @z = "Fri, 31 Dec 1999 19:00:00 EST -05:00"
  end

  def test_in_time_zone
    with_tz_default "Alaska" do
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 AKST -09:00", @s.in_time_zone.inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @u.in_time_zone.inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @z.in_time_zone.inspect
    end
    with_tz_default "Hawaii" do
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 HST -10:00", @s.in_time_zone.inspect
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @u.in_time_zone.inspect
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @z.in_time_zone.inspect
    end
    with_tz_default nil do
      assert_equal @s.to_time, @s.in_time_zone
      assert_equal @u.to_time, @u.in_time_zone
      assert_equal @z.to_time, @z.in_time_zone
    end
  end

  def test_nil_time_zone
    with_tz_default nil do
      assert_not_respond_to @s.in_time_zone, :period, "no period method"
      assert_not_respond_to @u.in_time_zone, :period, "no period method"
      assert_not_respond_to @z.in_time_zone, :period, "no period method"
    end
  end

  def test_in_time_zone_with_argument
    with_tz_default "Eastern Time (US & Canada)" do # Time.zone will not affect #in_time_zone(zone)
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 AKST -09:00", @s.in_time_zone("Alaska").inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @u.in_time_zone("Alaska").inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @z.in_time_zone("Alaska").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 HST -10:00", @s.in_time_zone("Hawaii").inspect
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @u.in_time_zone("Hawaii").inspect
      assert_equal "Fri, 31 Dec 1999 14:00:00.000000000 HST -10:00", @z.in_time_zone("Hawaii").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 UTC +00:00", @s.in_time_zone("UTC").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 UTC +00:00", @u.in_time_zone("UTC").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 UTC +00:00", @z.in_time_zone("UTC").inspect
      assert_equal "Sat, 01 Jan 2000 00:00:00.000000000 AKST -09:00", @s.in_time_zone(-9.hours).inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @u.in_time_zone(-9.hours).inspect
      assert_equal "Fri, 31 Dec 1999 15:00:00.000000000 AKST -09:00", @z.in_time_zone(-9.hours).inspect
    end
  end

  def test_in_time_zone_with_invalid_argument
    assert_raise(ArgumentError) { @s.in_time_zone("No such timezone exists") }
    assert_raise(ArgumentError) { @u.in_time_zone("No such timezone exists") }
    assert_raise(ArgumentError) { @z.in_time_zone("No such timezone exists") }
    assert_raise(ArgumentError) { @s.in_time_zone(-15.hours) }
    assert_raise(ArgumentError) { @u.in_time_zone(-15.hours) }
    assert_raise(ArgumentError) { @z.in_time_zone(-15.hours) }
    assert_raise(ArgumentError) { @s.in_time_zone(Object.new) }
    assert_raise(ArgumentError) { @u.in_time_zone(Object.new) }
    assert_raise(ArgumentError) { @z.in_time_zone(Object.new) }
  end

  def test_in_time_zone_with_ambiguous_time
    with_tz_default "Moscow" do
      assert_equal Time.utc(2014, 10, 25, 22, 0, 0), "2014-10-26 01:00:00".in_time_zone
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/time"
require_relative "../core_ext/date_and_time_behavior"
require_relative "../time_zone_test_helpers"

class DateTimeExtCalculationsTest < ActiveSupport::TestCase
  def date_time_init(year, month, day, hour, minute, second, usec = 0)
    DateTime.civil(year, month, day, hour, minute, second + (usec / 1000000))
  end

  include DateAndTimeBehavior
  include TimeZoneTestHelpers

  def test_to_s
    datetime = DateTime.new(2005, 2, 21, 14, 30, 0, 0)
    assert_equal "2005-02-21 14:30:00",                 datetime.to_s(:db)
    assert_equal "2005-02-21 14:30:00.000000000 +0000", datetime.to_s(:inspect)
    assert_equal "14:30",                               datetime.to_s(:time)
    assert_equal "21 Feb 14:30",                        datetime.to_s(:short)
    assert_equal "February 21, 2005 14:30",             datetime.to_s(:long)
    assert_equal "Mon, 21 Feb 2005 14:30:00 +0000",     datetime.to_s(:rfc822)
    assert_equal "February 21st, 2005 14:30",           datetime.to_s(:long_ordinal)
    assert_match(/^2005-02-21T14:30:00(Z|\+00:00)$/,    datetime.to_s)

    with_env_tz "US/Central" do
      assert_equal "2009-02-05T14:30:05-06:00", DateTime.civil(2009, 2, 5, 14, 30, 5, Rational(-21600, 86400)).to_s(:iso8601)
      assert_equal "2008-06-09T04:05:01-05:00", DateTime.civil(2008, 6, 9, 4, 5, 1, Rational(-18000, 86400)).to_s(:iso8601)
      assert_equal "2009-02-05T14:30:05+00:00", DateTime.civil(2009, 2, 5, 14, 30, 5).to_s(:iso8601)
    end
  end

  def test_readable_inspect
    datetime = DateTime.new(2005, 2, 21, 14, 30, 0)
    assert_equal "Mon, 21 Feb 2005 14:30:00 +0000", datetime.readable_inspect
    assert_equal datetime.readable_inspect, datetime.inspect
  end

  def test_custom_date_format
    Time::DATE_FORMATS[:custom] = "%Y%m%d%H%M%S"
    assert_equal "20050221143000", DateTime.new(2005, 2, 21, 14, 30, 0).to_s(:custom)
    Time::DATE_FORMATS.delete(:custom)
  end

  def test_localtime
    with_env_tz "US/Eastern" do
      assert_instance_of Time, DateTime.new(2016, 3, 11, 15, 11, 12, 0).localtime
      assert_equal Time.local(2016, 3, 11, 10, 11, 12), DateTime.new(2016, 3, 11, 15, 11, 12, 0).localtime
      assert_equal Time.local(2016, 3, 21, 11, 11, 12), DateTime.new(2016, 3, 21, 15, 11, 12, 0).localtime
      assert_equal Time.local(2016, 4, 1, 11, 11, 12), DateTime.new(2016, 4, 1, 16, 11, 12, Rational(1, 24)).localtime
    end
  end

  def test_getlocal
    with_env_tz "US/Eastern" do
      assert_instance_of Time, DateTime.new(2016, 3, 11, 15, 11, 12, 0).getlocal
      assert_equal Time.local(2016, 3, 11, 10, 11, 12), DateTime.new(2016, 3, 11, 15, 11, 12, 0).getlocal
      assert_equal Time.local(2016, 3, 21, 11, 11, 12), DateTime.new(2016, 3, 21, 15, 11, 12, 0).getlocal
      assert_equal Time.local(2016, 4, 1, 11, 11, 12), DateTime.new(2016, 4, 1, 16, 11, 12, Rational(1, 24)).getlocal
    end
  end

  def test_to_date
    assert_equal Date.new(2005, 2, 21), DateTime.new(2005, 2, 21, 14, 30, 0).to_date
  end

  def test_to_datetime
    assert_equal DateTime.new(2005, 2, 21, 14, 30, 0), DateTime.new(2005, 2, 21, 14, 30, 0).to_datetime
  end

  def test_to_time
    with_env_tz "US/Eastern" do
      assert_instance_of Time, DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time

      if ActiveSupport.to_time_preserves_timezone
        assert_equal Time.local(2005, 2, 21, 5, 11, 12).getlocal(0), DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time
        assert_equal Time.local(2005, 2, 21, 5, 11, 12).getlocal(0).utc_offset, DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time.utc_offset
      else
        assert_equal Time.local(2005, 2, 21, 5, 11, 12), DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time
        assert_equal Time.local(2005, 2, 21, 5, 11, 12).utc_offset, DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time.utc_offset
      end
    end
  end

  def test_to_time_preserves_fractional_seconds
    assert_equal Time.utc(2005, 2, 21, 10, 11, 12, 256), DateTime.new(2005, 2, 21, 10, 11, 12 + Rational(256, 1000000), 0).to_time
  end

  def test_civil_from_format
    assert_equal Time.local(2010, 5, 4, 0, 0, 0), DateTime.civil_from_format(:local, 2010, 5, 4)
    assert_equal Time.utc(2010, 5, 4, 0, 0, 0), DateTime.civil_from_format(:utc, 2010, 5, 4)
  end

  def test_seconds_since_midnight
    assert_equal 1, DateTime.civil(2005, 1, 1, 0, 0, 1).seconds_since_midnight
    assert_equal 60, DateTime.civil(2005, 1, 1, 0, 1, 0).seconds_since_midnight
    assert_equal 3660, DateTime.civil(2005, 1, 1, 1, 1, 0).seconds_since_midnight
    assert_equal 86399, DateTime.civil(2005, 1, 1, 23, 59, 59).seconds_since_midnight
  end

  def test_seconds_until_end_of_day
    assert_equal 0, DateTime.civil(2005, 1, 1, 23, 59, 59).seconds_until_end_of_day
    assert_equal 1, DateTime.civil(2005, 1, 1, 23, 59, 58).seconds_until_end_of_day
    assert_equal 60, DateTime.civil(2005, 1, 1, 23, 58, 59).seconds_until_end_of_day
    assert_equal 3660, DateTime.civil(2005, 1, 1, 22, 58, 59).seconds_until_end_of_day
    assert_equal 86399, DateTime.civil(2005, 1, 1, 0, 0, 0).seconds_until_end_of_day
  end

  def test_beginning_of_day
    assert_equal DateTime.civil(2005, 2, 4, 0, 0, 0), DateTime.civil(2005, 2, 4, 10, 10, 10).beginning_of_day
  end

  def test_middle_of_day
    assert_equal DateTime.civil(2005, 2, 4, 12, 0, 0), DateTime.civil(2005, 2, 4, 10, 10, 10).middle_of_day
  end

  def test_end_of_day
    assert_equal DateTime.civil(2005, 2, 4, 23, 59, Rational(59999999999, 1000000000)), DateTime.civil(2005, 2, 4, 10, 10, 10).end_of_day
  end

  def test_beginning_of_hour
    assert_equal DateTime.civil(2005, 2, 4, 19, 0, 0), DateTime.civil(2005, 2, 4, 19, 30, 10).beginning_of_hour
  end

  def test_end_of_hour
    assert_equal DateTime.civil(2005, 2, 4, 19, 59, Rational(59999999999, 1000000000)), DateTime.civil(2005, 2, 4, 19, 30, 10).end_of_hour
  end

  def test_beginning_of_minute
    assert_equal DateTime.civil(2005, 2, 4, 19, 30, 0), DateTime.civil(2005, 2, 4, 19, 30, 10).beginning_of_minute
  end

  def test_end_of_minute
    assert_equal DateTime.civil(2005, 2, 4, 19, 30, Rational(59999999999, 1000000000)), DateTime.civil(2005, 2, 4, 19, 30, 10).end_of_minute
  end

  def test_end_of_month
    assert_equal DateTime.civil(2005, 3, 31, 23, 59, Rational(59999999999, 1000000000)), DateTime.civil(2005, 3, 20, 10, 10, 10).end_of_month
    assert_equal DateTime.civil(2005, 2, 28, 23, 59, Rational(59999999999, 1000000000)), DateTime.civil(2005, 2, 20, 10, 10, 10).end_of_month
    assert_equal DateTime.civil(2005, 4, 30, 23, 59, Rational(59999999999, 1000000000)), DateTime.civil(2005, 4, 20, 10, 10, 10).end_of_month
  end

  def test_ago
    assert_equal DateTime.civil(2005, 2, 22, 10, 10, 9),  DateTime.civil(2005, 2, 22, 10, 10, 10).ago(1)
    assert_equal DateTime.civil(2005, 2, 22, 9, 10, 10),  DateTime.civil(2005, 2, 22, 10, 10, 10).ago(3600)
    assert_equal DateTime.civil(2005, 2, 20, 10, 10, 10), DateTime.civil(2005, 2, 22, 10, 10, 10).ago(86400 * 2)
    assert_equal DateTime.civil(2005, 2, 20, 9, 9, 45),   DateTime.civil(2005, 2, 22, 10, 10, 10).ago(86400 * 2 + 3600 + 25)
  end

  def test_since
    assert_equal DateTime.civil(2005, 2, 22, 10, 10, 11), DateTime.civil(2005, 2, 22, 10, 10, 10).since(1)
    assert_equal DateTime.civil(2005, 2, 22, 11, 10, 10), DateTime.civil(2005, 2, 22, 10, 10, 10).since(3600)
    assert_equal DateTime.civil(2005, 2, 24, 10, 10, 10), DateTime.civil(2005, 2, 22, 10, 10, 10).since(86400 * 2)
    assert_equal DateTime.civil(2005, 2, 24, 11, 10, 35), DateTime.civil(2005, 2, 22, 10, 10, 10).since(86400 * 2 + 3600 + 25)
    assert_not_equal DateTime.civil(2005, 2, 22, 10, 10, 11), DateTime.civil(2005, 2, 22, 10, 10, 10).since(1.333)
    assert_not_equal DateTime.civil(2005, 2, 22, 10, 10, 12), DateTime.civil(2005, 2, 22, 10, 10, 10).since(1.667)
  end

  def test_change
    assert_equal DateTime.civil(2006, 2, 22, 15, 15, 10), DateTime.civil(2005, 2, 22, 15, 15, 10).change(year: 2006)
    assert_equal DateTime.civil(2005, 6, 22, 15, 15, 10), DateTime.civil(2005, 2, 22, 15, 15, 10).change(month: 6)
    assert_equal DateTime.civil(2012, 9, 22, 15, 15, 10), DateTime.civil(2005, 2, 22, 15, 15, 10).change(year: 2012, month: 9)
    assert_equal DateTime.civil(2005, 2, 22, 16),         DateTime.civil(2005, 2, 22, 15, 15, 10).change(hour: 16)
    assert_equal DateTime.civil(2005, 2, 22, 16, 45),     DateTime.civil(2005, 2, 22, 15, 15, 10).change(hour: 16, min: 45)
    assert_equal DateTime.civil(2005, 2, 22, 15, 45),     DateTime.civil(2005, 2, 22, 15, 15, 10).change(min: 45)

    # datetime with non-zero offset
    assert_equal DateTime.civil(2005, 2, 22, 15, 15, 10, Rational(-5, 24)), DateTime.civil(2005, 2, 22, 15, 15, 10, 0).change(offset: Rational(-5, 24))

    # datetime with fractions of a second
    assert_equal DateTime.civil(2005, 2, 1, 15, 15, 10.7), DateTime.civil(2005, 2, 22, 15, 15, 10.7).change(day: 1)
    assert_equal DateTime.civil(2005, 1, 2, 11, 22, Rational(33000008, 1000000)), DateTime.civil(2005, 1, 2, 11, 22, 33).change(usec: 8)
    assert_equal DateTime.civil(2005, 1, 2, 11, 22, Rational(33000008, 1000000)), DateTime.civil(2005, 1, 2, 11, 22, 33).change(nsec: 8000)
    assert_raise(ArgumentError) { DateTime.civil(2005, 1, 2, 11, 22, 0).change(usec: 1, nsec: 1) }
    assert_raise(ArgumentError) { DateTime.civil(2005, 1, 2, 11, 22, 0).change(usec: 1000000) }
    assert_raise(ArgumentError) { DateTime.civil(2005, 1, 2, 11, 22, 0).change(nsec: 1000000000) }
    assert_nothing_raised { DateTime.civil(2005, 1, 2, 11, 22, 0).change(usec: 999999) }
    assert_nothing_raised { DateTime.civil(2005, 1, 2, 11, 22, 0).change(nsec: 999999999) }
  end

  def test_advance
    assert_equal DateTime.civil(2006, 2, 28, 15, 15, 10),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: 1)
    assert_equal DateTime.civil(2005, 6, 28, 15, 15, 10),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(months: 4)
    assert_equal DateTime.civil(2005, 3, 21, 15, 15, 10),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(weeks: 3)
    assert_equal DateTime.civil(2005, 3, 5, 15, 15, 10),   DateTime.civil(2005, 2, 28, 15, 15, 10).advance(days: 5)
    assert_equal DateTime.civil(2012, 9, 28, 15, 15, 10),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 7)
    assert_equal DateTime.civil(2013, 10, 3, 15, 15, 10),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, days: 5)
    assert_equal DateTime.civil(2013, 10, 17, 15, 15, 10), DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5)
    assert_equal DateTime.civil(2001, 12, 27, 15, 15, 10), DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: -3, months: -2, days: -1)
    assert_equal DateTime.civil(2005, 2, 28, 15, 15, 10),  DateTime.civil(2004, 2, 29, 15, 15, 10).advance(years: 1) # leap day plus one year
    assert_equal DateTime.civil(2005, 2, 28, 20, 15, 10),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(hours: 5)
    assert_equal DateTime.civil(2005, 2, 28, 15, 22, 10),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(minutes: 7)
    assert_equal DateTime.civil(2005, 2, 28, 15, 15, 19),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(seconds: 9)
    assert_equal DateTime.civil(2005, 2, 28, 20, 22, 19),  DateTime.civil(2005, 2, 28, 15, 15, 10).advance(hours: 5, minutes: 7, seconds: 9)
    assert_equal DateTime.civil(2005, 2, 28, 10, 8, 1),    DateTime.civil(2005, 2, 28, 15, 15, 10).advance(hours: -5, minutes: -7, seconds: -9)
    assert_equal DateTime.civil(2013, 10, 17, 20, 22, 19), DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5, hours: 5, minutes: 7, seconds: 9)
  end

  def test_advance_partial_days
    assert_equal DateTime.civil(2012, 9, 29, 13, 15, 10),  DateTime.civil(2012, 9, 28, 1, 15, 10).advance(days: 1.5)
    assert_equal DateTime.civil(2012, 9, 28, 13, 15, 10),  DateTime.civil(2012, 9, 28, 1, 15, 10).advance(days: 0.5)
    assert_equal DateTime.civil(2012, 10, 29, 13, 15, 10), DateTime.civil(2012, 9, 28, 1, 15, 10).advance(days: 1.5, months: 1)
  end

  def test_advanced_processes_first_the_date_deltas_and_then_the_time_deltas
    # If the time deltas were processed first, the following datetimes would be advanced to 2010/04/01 instead.
    assert_equal DateTime.civil(2010, 3, 29), DateTime.civil(2010, 2, 28, 23, 59, 59).advance(months: 1, seconds: 1)
    assert_equal DateTime.civil(2010, 3, 29), DateTime.civil(2010, 2, 28, 23, 59).advance(months: 1, minutes: 1)
    assert_equal DateTime.civil(2010, 3, 29), DateTime.civil(2010, 2, 28, 23).advance(months: 1, hours: 1)
    assert_equal DateTime.civil(2010, 3, 29), DateTime.civil(2010, 2, 28, 22, 58, 59).advance(months: 1, hours: 1, minutes: 1, seconds: 1)
  end

  def test_last_week
    assert_equal DateTime.civil(2005, 2, 21), DateTime.civil(2005, 3, 1, 15, 15, 10).last_week
    assert_equal DateTime.civil(2005, 2, 22), DateTime.civil(2005, 3, 1, 15, 15, 10).last_week(:tuesday)
    assert_equal DateTime.civil(2005, 2, 25), DateTime.civil(2005, 3, 1, 15, 15, 10).last_week(:friday)
    assert_equal DateTime.civil(2006, 10, 30), DateTime.civil(2006, 11, 6, 0, 0, 0).last_week
    assert_equal DateTime.civil(2006, 11, 15), DateTime.civil(2006, 11, 23, 0, 0, 0).last_week(:wednesday)
  end

  def test_date_time_should_have_correct_last_week_for_leap_year
    assert_equal DateTime.civil(2016, 2, 29), DateTime.civil(2016, 3, 7).last_week
  end

  def test_last_quarter_on_31st
    assert_equal DateTime.civil(2004, 2, 29), DateTime.civil(2004, 5, 31).last_quarter
  end

  def test_xmlschema
    assert_match(/^1880-02-28T15:15:10\+00:?00$/, DateTime.civil(1880, 2, 28, 15, 15, 10).xmlschema)
    assert_match(/^1980-02-28T15:15:10\+00:?00$/, DateTime.civil(1980, 2, 28, 15, 15, 10).xmlschema)
    assert_match(/^2080-02-28T15:15:10\+00:?00$/, DateTime.civil(2080, 2, 28, 15, 15, 10).xmlschema)
    assert_match(/^1880-02-28T15:15:10-06:?00$/, DateTime.civil(1880, 2, 28, 15, 15, 10, -0.25).xmlschema)
    assert_match(/^1980-02-28T15:15:10-06:?00$/, DateTime.civil(1980, 2, 28, 15, 15, 10, -0.25).xmlschema)
    assert_match(/^2080-02-28T15:15:10-06:?00$/, DateTime.civil(2080, 2, 28, 15, 15, 10, -0.25).xmlschema)
  end

  def test_today_with_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, DateTime.civil(1999, 12, 31, 23, 59, 59, Rational(-18000, 86400)).today?
      assert_equal true,  DateTime.civil(2000, 1, 1, 0, 0, 0, Rational(-18000, 86400)).today?
      assert_equal true,  DateTime.civil(2000, 1, 1, 23, 59, 59, Rational(-18000, 86400)).today?
      assert_equal false, DateTime.civil(2000, 1, 2, 0, 0, 0, Rational(-18000, 86400)).today?
    end
  end

  def test_today_without_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, DateTime.civil(1999, 12, 31, 23, 59, 59).today?
      assert_equal true,  DateTime.civil(2000, 1, 1, 0).today?
      assert_equal true,  DateTime.civil(2000, 1, 1, 23, 59, 59).today?
      assert_equal false, DateTime.civil(2000, 1, 2, 0).today?
    end
  end

  def test_yesterday_with_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  DateTime.civil(1999, 12, 31, 23, 59, 59, Rational(-18000, 86400)).yesterday?
      assert_equal false, DateTime.civil(2000, 1, 1, 0, 0, 0, Rational(-18000, 86400)).yesterday?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59, Rational(-18000, 86400)).yesterday?
      assert_equal true,  DateTime.civil(1999, 12, 31, 0, 0, 0, Rational(-18000, 86400)).yesterday?
    end
  end

  def test_yesterday_without_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  DateTime.civil(1999, 12, 31, 23, 59, 59).yesterday?
      assert_equal false, DateTime.civil(2000, 1, 1, 0).yesterday?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59).yesterday?
      assert_equal false, DateTime.civil(2000, 1, 2, 0).yesterday?
    end
  end

  def test_prev_day_with_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  DateTime.civil(1999, 12, 31, 23, 59, 59, Rational(-18000, 86400)).prev_day?
      assert_equal false, DateTime.civil(2000, 1, 1, 0, 0, 0, Rational(-18000, 86400)).prev_day?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59, Rational(-18000, 86400)).prev_day?
      assert_equal true,  DateTime.civil(1999, 12, 31, 0, 0, 0, Rational(-18000, 86400)).prev_day?
    end
  end

  def test_prev_day_without_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  DateTime.civil(1999, 12, 31, 23, 59, 59).prev_day?
      assert_equal false, DateTime.civil(2000, 1, 1, 0).prev_day?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59).prev_day?
      assert_equal false, DateTime.civil(2000, 1, 2, 0).prev_day?
    end
  end

  def test_tomorrow_with_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, DateTime.civil(1999, 12, 31, 23, 59, 59, Rational(-18000, 86400)).tomorrow?
      assert_equal true,  DateTime.civil(2000, 1, 2, 0, 0, 0, Rational(-18000, 86400)).tomorrow?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59, Rational(-18000, 86400)).tomorrow?
      assert_equal true,  DateTime.civil(2000, 1, 2, 23, 59, 59, Rational(-18000, 86400)).tomorrow?
    end
  end

  def test_tomorrow_without_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, DateTime.civil(1999, 12, 31, 23, 59, 59).tomorrow?
      assert_equal true,  DateTime.civil(2000, 1, 2, 0).tomorrow?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59).tomorrow?
      assert_equal false, DateTime.civil(2000, 1, 3, 0).tomorrow?
    end
  end

  def test_next_day_with_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, DateTime.civil(1999, 12, 31, 23, 59, 59, Rational(-18000, 86400)).next_day?
      assert_equal true,  DateTime.civil(2000, 1, 2, 0, 0, 0, Rational(-18000, 86400)).next_day?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59, Rational(-18000, 86400)).next_day?
      assert_equal true,  DateTime.civil(2000, 1, 2, 23, 59, 59, Rational(-18000, 86400)).next_day?
    end
  end

  def test_next_day_without_offset
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, DateTime.civil(1999, 12, 31, 23, 59, 59).next_day?
      assert_equal true,  DateTime.civil(2000, 1, 2, 0).next_day?
      assert_equal false, DateTime.civil(2000, 1, 1, 23, 59, 59).next_day?
      assert_equal false, DateTime.civil(2000, 1, 3, 0).next_day?
    end
  end

  def test_past_with_offset
    DateTime.stub(:current, DateTime.civil(2005, 2, 10, 15, 30, 45, Rational(-18000, 86400))) do
      assert_equal true,   DateTime.civil(2005, 2, 10, 15, 30, 44, Rational(-18000, 86400)).past?
      assert_equal false,  DateTime.civil(2005, 2, 10, 15, 30, 45, Rational(-18000, 86400)).past?
      assert_equal false,  DateTime.civil(2005, 2, 10, 15, 30, 46, Rational(-18000, 86400)).past?
    end
  end

  def test_past_without_offset
    DateTime.stub(:current, DateTime.civil(2005, 2, 10, 15, 30, 45, Rational(-18000, 86400))) do
      assert_equal true,  DateTime.civil(2005, 2, 10, 20, 30, 44).past?
      assert_equal false,  DateTime.civil(2005, 2, 10, 20, 30, 45).past?
      assert_equal false,  DateTime.civil(2005, 2, 10, 20, 30, 46).past?
    end
  end

  def test_future_with_offset
    DateTime.stub(:current, DateTime.civil(2005, 2, 10, 15, 30, 45, Rational(-18000, 86400))) do
      assert_equal false,  DateTime.civil(2005, 2, 10, 15, 30, 44, Rational(-18000, 86400)).future?
      assert_equal false,  DateTime.civil(2005, 2, 10, 15, 30, 45, Rational(-18000, 86400)).future?
      assert_equal true,  DateTime.civil(2005, 2, 10, 15, 30, 46, Rational(-18000, 86400)).future?
    end
  end

  def test_future_without_offset
    DateTime.stub(:current, DateTime.civil(2005, 2, 10, 15, 30, 45, Rational(-18000, 86400))) do
      assert_equal false,  DateTime.civil(2005, 2, 10, 20, 30, 44).future?
      assert_equal false,  DateTime.civil(2005, 2, 10, 20, 30, 45).future?
      assert_equal true,  DateTime.civil(2005, 2, 10, 20, 30, 46).future?
    end
  end

  def test_current_returns_date_today_when_zone_is_not_set
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(1999, 12, 31, 23, 59, 59)) do
        assert_equal DateTime.new(1999, 12, 31, 23, 59, 59, Rational(-18000, 86400)), DateTime.current
      end
    end
  end

  def test_current_returns_time_zone_today_when_zone_is_set
    Time.zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(1999, 12, 31, 23, 59, 59)) do
        assert_equal DateTime.new(1999, 12, 31, 23, 59, 59, Rational(-18000, 86400)), DateTime.current
      end
    end
  ensure
    Time.zone = nil
  end

  def test_current_without_time_zone
    assert_kind_of DateTime, DateTime.current
  end

  def test_current_with_time_zone
    with_env_tz "US/Eastern" do
      assert_kind_of DateTime, DateTime.current
    end
  end

  def test_acts_like_date
    assert_predicate DateTime.new, :acts_like_date?
  end

  def test_acts_like_time
    assert_predicate DateTime.new, :acts_like_time?
  end

  def test_blank?
    assert_not_predicate DateTime.new, :blank?
  end

  def test_utc?
    assert_equal true, DateTime.civil(2005, 2, 21, 10, 11, 12).utc?
    assert_equal true, DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc?
    assert_equal false, DateTime.civil(2005, 2, 21, 10, 11, 12, 0.25).utc?
    assert_equal false, DateTime.civil(2005, 2, 21, 10, 11, 12, -0.25).utc?
  end

  def test_utc_offset
    assert_equal 0, DateTime.civil(2005, 2, 21, 10, 11, 12).utc_offset
    assert_equal 0, DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc_offset
    assert_equal 21600, DateTime.civil(2005, 2, 21, 10, 11, 12, 0.25).utc_offset
    assert_equal(-21600, DateTime.civil(2005, 2, 21, 10, 11, 12, -0.25).utc_offset)
    assert_equal(-18000, DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24)).utc_offset)
  end

  def test_utc
    assert_instance_of Time, DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc
    assert_equal DateTime.civil(2005, 2, 21, 16, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc
    assert_equal DateTime.civil(2005, 2, 21, 15, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24)).utc
    assert_equal DateTime.civil(2005, 2, 21, 10, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc
    assert_equal DateTime.civil(2005, 2, 21, 9, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(1, 24)).utc
    assert_equal DateTime.civil(2005, 2, 21, 9, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(1, 24)).getutc
  end

  def test_formatted_offset_with_utc
    assert_equal "+00:00", DateTime.civil(2000).formatted_offset
    assert_equal "+0000", DateTime.civil(2000).formatted_offset(false)
    assert_equal "UTC", DateTime.civil(2000).formatted_offset(true, "UTC")
  end

  def test_formatted_offset_with_local
    dt = DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24))
    assert_equal "-05:00", dt.formatted_offset
    assert_equal "-0500", dt.formatted_offset(false)
  end

  def test_compare_with_time
    assert_equal 1, DateTime.civil(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59)
    assert_equal 0, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0)
    assert_equal(-1, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 1))
  end

  def test_compare_with_datetime
    assert_equal 1, DateTime.civil(2000) <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
    assert_equal 0, DateTime.civil(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
    assert_equal(-1, DateTime.civil(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
  end

  def test_compare_with_time_with_zone
    assert_equal 1, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new(Time.utc(1999, 12, 31, 23, 59, 59), ActiveSupport::TimeZone["UTC"])
    assert_equal 0, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone["UTC"])
    assert_equal(-1, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 1), ActiveSupport::TimeZone["UTC"]))
  end

  def test_compare_with_string
    assert_equal 1, DateTime.civil(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59).to_s
    assert_equal 0, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0).to_s
    assert_equal(-1, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 1).to_s)
    assert_nil DateTime.civil(2000) <=> "Invalid as Time"
  end

  def test_compare_with_integer
    assert_equal 1, DateTime.civil(1970, 1, 1, 12, 0, 0) <=> 2440587
    assert_equal 0, DateTime.civil(1970, 1, 1, 12, 0, 0) <=> 2440588
    assert_equal(-1, DateTime.civil(1970, 1, 1, 12, 0, 0) <=> 2440589)
  end

  def test_compare_with_float
    assert_equal 1, DateTime.civil(1970) <=> 2440586.5
    assert_equal 0, DateTime.civil(1970) <=> 2440587.5
    assert_equal(-1, DateTime.civil(1970) <=> 2440588.5)
  end

  def test_compare_with_rational
    assert_equal 1, DateTime.civil(1970) <=> Rational(4881173, 2)
    assert_equal 0, DateTime.civil(1970) <=> Rational(4881175, 2)
    assert_equal(-1, DateTime.civil(1970) <=> Rational(4881177, 2))
  end

  def test_to_f
    assert_equal 946684800.0, DateTime.civil(2000).to_f
    assert_equal 946684800.0, DateTime.civil(1999, 12, 31, 19, 0, 0, Rational(-5, 24)).to_f
    assert_equal 946684800.5, DateTime.civil(1999, 12, 31, 19, 0, 0.5, Rational(-5, 24)).to_f
  end

  def test_to_i
    assert_equal 946684800, DateTime.civil(2000).to_i
    assert_equal 946684800, DateTime.civil(1999, 12, 31, 19, 0, 0, Rational(-5, 24)).to_i
  end

  def test_usec
    assert_equal 0, DateTime.civil(2000).usec
    assert_equal 500000, DateTime.civil(2000, 1, 1, 0, 0, Rational(1, 2)).usec
  end

  def test_nsec
    assert_equal 0, DateTime.civil(2000).nsec
    assert_equal 500000000, DateTime.civil(2000, 1, 1, 0, 0, Rational(1, 2)).nsec
  end

  def test_subsec
    assert_equal 0, DateTime.civil(2000).subsec
    assert_equal Rational(1, 2), DateTime.civil(2000, 1, 1, 0, 0, Rational(1, 2)).subsec
  end
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/kernel"

class KernelTest < ActiveSupport::TestCase
  def test_silence_warnings
    silence_warnings { assert_nil $VERBOSE }
    assert_equal 1234, silence_warnings { 1234 }
  end

  def test_silence_warnings_verbose_invariant
    old_verbose = $VERBOSE
    silence_warnings { raise }
    flunk
  rescue
    assert_equal old_verbose, $VERBOSE
  end

  def test_enable_warnings
    enable_warnings { assert_equal true, $VERBOSE }
    assert_equal 1234, enable_warnings { 1234 }
  end

  def test_enable_warnings_verbose_invariant
    old_verbose = $VERBOSE
    enable_warnings { raise }
    flunk
  rescue
    assert_equal old_verbose, $VERBOSE
  end

  def test_class_eval
    o = Object.new
    class << o; @x = 1; end
    assert_equal 1, o.class_eval { @x }
  end
end

class KernelSuppressTest < ActiveSupport::TestCase
  def test_reraise
    assert_raise(LoadError) do
      suppress(ArgumentError) { raise LoadError }
    end
  end

  def test_suppression
    suppress(ArgumentError) { raise ArgumentError }
    suppress(LoadError) { raise LoadError }
    suppress(LoadError, ArgumentError) { raise LoadError }
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/time"
require "active_support/core_ext/numeric"
require "active_support/core_ext/range"

class RangeTest < ActiveSupport::TestCase
  def test_to_s_from_dates
    date_range = Date.new(2005, 12, 10)..Date.new(2005, 12, 12)
    assert_equal "BETWEEN '2005-12-10' AND '2005-12-12'", date_range.to_s(:db)
  end

  def test_to_s_from_times
    date_range = Time.utc(2005, 12, 10, 15, 30)..Time.utc(2005, 12, 10, 17, 30)
    assert_equal "BETWEEN '2005-12-10 15:30:00' AND '2005-12-10 17:30:00'", date_range.to_s(:db)
  end

  def test_to_s_with_alphabets
    alphabet_range = ("a".."z")
    assert_equal "BETWEEN 'a' AND 'z'", alphabet_range.to_s(:db)
  end

  def test_to_s_with_numeric
    number_range = (1..100)
    assert_equal "BETWEEN '1' AND '100'", number_range.to_s(:db)
  end

  def test_date_range
    assert_instance_of Range, DateTime.new..DateTime.new
    assert_instance_of Range, DateTime::Infinity.new..DateTime::Infinity.new
    assert_instance_of Range, DateTime.new..DateTime::Infinity.new
  end

  def test_overlaps_last_inclusive
    assert((1..5).overlaps?(5..10))
  end

  def test_overlaps_last_exclusive
    assert_not (1...5).overlaps?(5..10)
  end

  def test_overlaps_first_inclusive
    assert((5..10).overlaps?(1..5))
  end

  def test_overlaps_first_exclusive
    assert_not (5..10).overlaps?(1...5)
  end

  def test_should_include_identical_inclusive
    assert((1..10).include?(1..10))
  end

  def test_should_include_identical_exclusive
    assert((1...10).include?(1...10))
  end

  def test_should_include_other_with_exclusive_end
    assert((1..10).include?(1...11))
  end

  def test_include_returns_false_for_backwards
    assert_not((1..10).include?(5..3))
  end

  # Match quirky plain-Ruby behavior
  def test_include_returns_false_for_empty_exclusive_end
    assert_not((1..5).include?(3...3))
  end

  def test_include_with_endless_range
    assert((1..).include?(2))
  end

  def test_should_include_range_with_endless_range
    assert((1..).include?(2..4))
  end

  def test_should_not_include_range_with_endless_range
    assert_not((1..).include?(0..4))
  end

  def test_include_with_beginless_range
    assert((..2).include?(1))
  end

  def test_should_include_range_with_beginless_range
    assert((..2).include?(-1..1))
  end

  def test_should_not_include_range_with_beginless_range
    assert_not((..2).include?(-1..3))
  end

  def test_should_compare_identical_inclusive
    assert((1..10) === (1..10))
  end

  def test_should_compare_identical_exclusive
    assert((1...10) === (1...10))
  end

  def test_should_compare_other_with_exclusive_end
    assert((1..10) === (1...11))
  end

  def test_compare_returns_false_for_backwards
    assert_not((1..10) === (5..3))
  end

  # Match quirky plain-Ruby behavior
  def test_compare_returns_false_for_empty_exclusive_end
    assert_not((1..5) === (3...3))
  end

  def test_should_compare_range_with_endless_range
    assert((1..) === (2..4))
  end

  def test_should_not_compare_range_with_endless_range
    assert_not((1..) === (0..4))
  end

  def test_should_compare_range_with_beginless_range
    assert((..2) === (-1..1))
  end

  def test_should_not_compare_range_with_beginless_range
    assert_not((..2) === (-1..3))
  end

  def test_exclusive_end_should_not_include_identical_with_inclusive_end
    assert_not_includes (1...10), 1..10
  end

  def test_should_not_include_overlapping_first
    assert_not_includes (2..8), 1..3
  end

  def test_should_not_include_overlapping_last
    assert_not_includes (2..8), 5..9
  end

  def test_should_include_identical_exclusive_with_floats
    assert((1.0...10.0).include?(1.0...10.0))
  end

  def test_cover_is_not_override
    range = (1..3)
    assert range.method(:include?) != range.method(:cover?)
  end

  def test_overlaps_on_time
    time_range_1 = Time.utc(2005, 12, 10, 15, 30)..Time.utc(2005, 12, 10, 17, 30)
    time_range_2 = Time.utc(2005, 12, 10, 17, 00)..Time.utc(2005, 12, 10, 18, 00)
    assert time_range_1.overlaps?(time_range_2)
  end

  def test_no_overlaps_on_time
    time_range_1 = Time.utc(2005, 12, 10, 15, 30)..Time.utc(2005, 12, 10, 17, 30)
    time_range_2 = Time.utc(2005, 12, 10, 17, 31)..Time.utc(2005, 12, 10, 18, 00)
    assert_not time_range_1.overlaps?(time_range_2)
  end

  def test_each_on_time_with_zone
    twz = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Eastern Time (US & Canada)"], Time.utc(2006, 11, 28, 10, 30))
    assert_raises TypeError do
      ((twz - 1.hour)..twz).each { }
    end
  end

  def test_step_on_time_with_zone
    twz = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Eastern Time (US & Canada)"], Time.utc(2006, 11, 28, 10, 30))
    assert_raises TypeError do
      ((twz - 1.hour)..twz).step(1) { }
    end
  end

  def test_cover_on_time_with_zone
    twz = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Eastern Time (US & Canada)"], Time.utc(2006, 11, 28, 10, 30))
    assert ((twz - 1.hour)..twz).cover?(twz)
  end

  def test_include_on_time_with_zone
    twz = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Eastern Time (US & Canada)"], Time.utc(2006, 11, 28, 10, 30))
    assert_deprecated do
      ((twz - 1.hour)..twz).include?(twz)
    end
  end

  def test_case_equals_on_time_with_zone
    twz = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Eastern Time (US & Canada)"], Time.utc(2006, 11, 28, 10, 30))
    assert ((twz - 1.hour)..twz) === twz
  end

  def test_date_time_with_each
    datetime = DateTime.now
    assert(((datetime - 1.hour)..datetime).each { })
  end

  def test_date_time_with_step
    datetime = DateTime.now
    assert(((datetime - 1.hour)..datetime).step(1) { })
  end
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/regexp"

class RegexpExtAccessTests < ActiveSupport::TestCase
  def test_multiline
    assert_equal true, //m.multiline?
    assert_equal false, //.multiline?
    assert_equal false, /(?m:)/.multiline?
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/kernel/concern"

class KernelConcernTest < ActiveSupport::TestCase
  def test_may_be_defined_at_toplevel
    mod = ::TOPLEVEL_BINDING.eval "concern(:ToplevelConcern) { }"
    assert_equal mod, ::ToplevelConcern
    assert_kind_of ActiveSupport::Concern, ::ToplevelConcern
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/integer"

class IntegerExtTest < ActiveSupport::TestCase
  PRIME = 22953686867719691230002707821868552601124472329079

  def test_multiple_of
    [ -7, 0, 7, 14 ].each { |i| assert i.multiple_of?(7) }
    [ -7, 7, 14 ].each { |i| assert_not i.multiple_of?(6) }

    # test the 0 edge case
    assert 0.multiple_of?(0)
    assert_not 5.multiple_of?(0)

    # test with a prime
    [2, 3, 5, 7].each { |i| assert_not PRIME.multiple_of?(i) }
  end

  def test_ordinalize
    # These tests are mostly just to ensure that the ordinalize method exists.
    # Its results are tested comprehensively in the inflector test cases.
    assert_equal "1st", 1.ordinalize
    assert_equal "8th", 8.ordinalize
  end

  def test_ordinal
    assert_equal "st", 1.ordinal
    assert_equal "th", 8.ordinal
# frozen_string_literal: true

require_relative "../abstract_unit"
require "uri"
require "active_support/core_ext/uri"

class URIExtTest < ActiveSupport::TestCase
  def test_uri_decode_handle_multibyte
    str = "\xE6\x97\xA5\xE6\x9C\xAC\xE8\xAA\x9E" # Ni-ho-nn-go in UTF-8, means Japanese.

# frozen_string_literal: true

require "date"
require_relative "../abstract_unit"
require "timeout"
require_relative "../inflector_test_cases"
require_relative "../constantize_test_cases"

require "active_support/inflector"
require "active_support/core_ext/string"
require "active_support/time"
require "active_support/core_ext/string/output_safety"
require "active_support/core_ext/string/indent"
require "active_support/core_ext/string/strip"
require_relative "../time_zone_test_helpers"
require "yaml"

class StringInflectionsTest < ActiveSupport::TestCase
  include InflectorTestCases
  include ConstantizeTestCases
  include TimeZoneTestHelpers

  def test_strip_heredoc_on_an_empty_string
    assert_equal "", "".strip_heredoc
  end

  def test_strip_heredoc_on_a_frozen_string
    assert "".strip_heredoc.frozen?
  end

  def test_strip_heredoc_on_a_string_with_no_lines
    assert_equal "x", "x".strip_heredoc
    assert_equal "x", "    x".strip_heredoc
  end

  def test_strip_heredoc_on_a_heredoc_with_no_margin
    assert_equal "foo\nbar", "foo\nbar".strip_heredoc
    assert_equal "foo\n  bar", "foo\n  bar".strip_heredoc
  end

  def test_strip_heredoc_on_a_regular_indented_heredoc
    assert_equal "foo\n  bar\nbaz\n", <<-EOS.strip_heredoc
      foo
        bar
      baz
    EOS
  end

  def test_strip_heredoc_on_a_regular_indented_heredoc_with_blank_lines
    assert_equal "foo\n  bar\n\nbaz\n", <<-EOS.strip_heredoc
      foo
        bar

      baz
    EOS
  end

  def test_pluralize
    SingularToPlural.each do |singular, plural|
      assert_equal(plural, singular.pluralize)
    end

    assert_equal("plurals", "plurals".pluralize)

    assert_equal("blargles", "blargle".pluralize(0))
    assert_equal("blargle", "blargle".pluralize(1))
    assert_equal("blargles", "blargle".pluralize(2))
  end

  test "pluralize with count = 1 still returns new string" do
    name = "Kuldeep"
    assert_not_same name.pluralize(1), name
  end

  def test_singularize
    SingularToPlural.each do |singular, plural|
      assert_equal(singular, plural.singularize)
    end
  end

  def test_titleize
    MixtureToTitleCase.each do |before, titleized|
      assert_equal(titleized, before.titleize)
    end
  end

  def test_titleize_with_keep_id_suffix
    MixtureToTitleCaseWithKeepIdSuffix.each do |before, titleized|
      assert_equal(titleized, before.titleize(keep_id_suffix: true))
    end
  end

  def test_upcase_first
    assert_equal "What a Lovely Day", "what a Lovely Day".upcase_first
  end

  def test_upcase_first_with_one_char
    assert_equal "W", "w".upcase_first
  end

  def test_upcase_first_with_empty_string
    assert_equal "", "".upcase_first
  end

  def test_camelize
    CamelToUnderscore.each do |camel, underscore|
      assert_equal(camel, underscore.camelize)
    end
  end

  def test_camelize_lower
    assert_equal("capital", "Capital".camelize(:lower))
  end

  def test_camelize_upper
    assert_equal("Capital", "Capital".camelize(:upper))
  end

  def test_camelize_invalid_option
    e = assert_raise ArgumentError do
      "Capital".camelize(nil)
    end
    assert_equal("Invalid option, use either :upper or :lower.", e.message)
  end

  def test_dasherize
    UnderscoresToDashes.each do |underscored, dasherized|
      assert_equal(dasherized, underscored.dasherize)
    end
  end

  def test_underscore
    CamelToUnderscore.each do |camel, underscore|
      assert_equal(underscore, camel.underscore)
    end

    assert_equal "html_tidy", "HTMLTidy".underscore
    assert_equal "html_tidy_generator", "HTMLTidyGenerator".underscore
  end

  def test_underscore_to_lower_camel
    UnderscoreToLowerCamel.each do |underscored, lower_camel|
      assert_equal(lower_camel, underscored.camelize(:lower))
    end
  end

  def test_demodulize
    assert_equal "Account", "MyApplication::Billing::Account".demodulize
  end

  def test_deconstantize
    assert_equal "MyApplication::Billing", "MyApplication::Billing::Account".deconstantize
  end

  def test_foreign_key
    ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|
      assert_equal(foreign_key, klass.foreign_key)
    end

    ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|
      assert_equal(foreign_key, klass.foreign_key(false))
    end
  end

  def test_tableize
    ClassNameToTableName.each do |class_name, table_name|
      assert_equal(table_name, class_name.tableize)
    end
  end

  def test_classify
    ClassNameToTableName.each do |class_name, table_name|
      assert_equal(class_name, table_name.classify)
    end
  end

  def test_string_parameterized_normal
    StringToParameterized.each do |normal, slugged|
      assert_equal(slugged, normal.parameterize)
    end
  end

  def test_string_parameterized_normal_preserve_case
    StringToParameterizedPreserveCase.each do |normal, slugged|
      assert_equal(slugged, normal.parameterize(preserve_case: true))
    end
  end

  def test_string_parameterized_no_separator
    StringToParameterizeWithNoSeparator.each do |normal, slugged|
      assert_equal(slugged, normal.parameterize(separator: ""))
    end
  end

  def test_string_parameterized_no_separator_preserve_case
    StringToParameterizePreserveCaseWithNoSeparator.each do |normal, slugged|
      assert_equal(slugged, normal.parameterize(separator: "", preserve_case: true))
    end
  end

  def test_string_parameterized_underscore
    StringToParameterizeWithUnderscore.each do |normal, slugged|
      assert_equal(slugged, normal.parameterize(separator: "_"))
    end
  end

  def test_string_parameterized_underscore_preserve_case
    StringToParameterizePreserveCaseWithUnderscore.each do |normal, slugged|
      assert_equal(slugged, normal.parameterize(separator: "_", preserve_case: true))
    end
  end

  def test_parameterize_with_locale
    word = "Fnf autos"
    I18n.backend.store_translations(:de, i18n: { transliterate: { rule: { "" => "ue" } } })
    assert_equal("fuenf-autos", word.parameterize(locale: :de))
  end

  def test_humanize
    UnderscoreToHuman.each do |underscore, human|
      assert_equal(human, underscore.humanize)
    end
  end

  def test_humanize_without_capitalize
    UnderscoreToHumanWithoutCapitalize.each do |underscore, human|
      assert_equal(human, underscore.humanize(capitalize: false))
    end
  end

  def test_humanize_with_keep_id_suffix
    UnderscoreToHumanWithKeepIdSuffix.each do |underscore, human|
      assert_equal(human, underscore.humanize(keep_id_suffix: true))
    end
  end

  def test_humanize_with_html_escape
    assert_equal "Hello", ERB::Util.html_escape("hello").humanize
  end

  def test_ord
    assert_equal 97, "a".ord
    assert_equal 97, "abc".ord
  end

  def test_starts_ends_with_alias
    s = "hello"
    assert s.starts_with?("h")
    assert s.starts_with?("hel")
    assert_not s.starts_with?("el")

    assert s.ends_with?("o")
    assert s.ends_with?("lo")
    assert_not s.ends_with?("el")
  end

  def test_string_squish
    original = +%{\u205f\u3000 A string surrounded by various unicode spaces,
      with tabs(\t\t), newlines(\n\n), unicode nextlines(\u0085\u0085) and many spaces(  ). \u00a0\u2007}

    expected = "A string surrounded by various unicode spaces, " \
      "with tabs( ), newlines( ), unicode nextlines( ) and many spaces( )."

    # Make sure squish returns what we expect:
    assert_equal expected, original.squish
    # But doesn't modify the original string:
    assert_not_equal expected, original

    # Make sure squish! returns what we expect:
    assert_equal expected, original.squish!
    # And changes the original string:
    assert_equal expected, original
  end

  def test_string_inquiry
    assert_predicate "production".inquiry, :production?
    assert_not_predicate "production".inquiry, :development?
  end

  def test_truncate
    assert_equal "Hello World!", "Hello World!".truncate(12)
    assert_equal "Hello Wor...", "Hello World!!".truncate(12)
  end

  def test_truncate_with_omission_and_separator
    assert_equal "Hello[...]", "Hello World!".truncate(10, omission: "[...]")
    assert_equal "Hello[...]", "Hello Big World!".truncate(13, omission: "[...]", separator: " ")
    assert_equal "Hello Big[...]", "Hello Big World!".truncate(14, omission: "[...]", separator: " ")
    assert_equal "Hello Big[...]", "Hello Big World!".truncate(15, omission: "[...]", separator: " ")
  end

  def test_truncate_with_omission_and_regexp_separator
    assert_equal "Hello[...]", "Hello Big World!".truncate(13, omission: "[...]", separator: /\s/)
    assert_equal "Hello Big[...]", "Hello Big World!".truncate(14, omission: "[...]", separator: /\s/)
    assert_equal "Hello Big[...]", "Hello Big World!".truncate(15, omission: "[...]", separator: /\s/)
  end

  def test_truncate_returns_frozen_string
    assert_not "Hello World!".truncate(12).frozen?
    assert_not "Hello World!!".truncate(12).frozen?
  end

  def test_truncate_bytes
    assert_equal "", "".truncate_bytes(16)
    assert_equal "", "".truncate_bytes(16, omission: nil)
    assert_equal "", "".truncate_bytes(16, omission: " ")
    assert_equal "", "".truncate_bytes(16, omission: "")

    assert_equal "", "".truncate_bytes(15)
    assert_equal "", "".truncate_bytes(15, omission: nil)
    assert_equal " ", "".truncate_bytes(15, omission: " ")
    assert_equal "", "".truncate_bytes(15, omission: "")

    assert_equal "", "".truncate_bytes(5)
    assert_equal "", "".truncate_bytes(5, omission: nil)
    assert_equal " ", "".truncate_bytes(5, omission: " ")
    assert_equal "", "".truncate_bytes(5, omission: "")

    assert_equal "", "".truncate_bytes(4)
    assert_equal "", "".truncate_bytes(4, omission: nil)
    assert_equal " ", "".truncate_bytes(4, omission: " ")
    assert_equal "", "".truncate_bytes(4, omission: "")

    assert_raise ArgumentError do
      "".truncate_bytes(3, omission: "")
    end
  end

  def test_truncate_bytes_preserves_codepoints
    assert_equal "", "".truncate_bytes(16)
    assert_equal "", "".truncate_bytes(16, omission: nil)
    assert_equal "", "".truncate_bytes(16, omission: " ")
    assert_equal "", "".truncate_bytes(16, omission: "")

    assert_equal "", "".truncate_bytes(15)
    assert_equal "", "".truncate_bytes(15, omission: nil)
    assert_equal " ", "".truncate_bytes(15, omission: " ")
    assert_equal "", "".truncate_bytes(15, omission: "")

    assert_equal "", "".truncate_bytes(5)
    assert_equal "", "".truncate_bytes(5, omission: nil)
    assert_equal " ", "".truncate_bytes(5, omission: " ")
    assert_equal "", "".truncate_bytes(5, omission: "")

    assert_equal "", "".truncate_bytes(4)
    assert_equal "", "".truncate_bytes(4, omission: nil)
    assert_equal " ", "".truncate_bytes(4, omission: " ")
    assert_equal "", "".truncate_bytes(4, omission: "")

    assert_raise ArgumentError do
      "".truncate_bytes(3, omission: "")
    end
  end

  def test_truncates_bytes_preserves_grapheme_clusters
    assert_equal "a ", "a  b".truncate_bytes(2, omission: nil)
    assert_equal "a ", "a  b".truncate_bytes(3, omission: nil)
    assert_equal "a ", "a  b".truncate_bytes(7, omission: nil)
    assert_equal "a ", "a  b".truncate_bytes(8, omission: nil)

    assert_equal "a ", "a ".truncate_bytes(13, omission: nil)
    assert_equal "", "".truncate_bytes(13, omission: nil)
  end

  def test_truncate_words
    assert_equal "Hello Big World!", "Hello Big World!".truncate_words(3)
    assert_equal "Hello Big...", "Hello Big World!".truncate_words(2)
  end

  def test_truncate_words_with_omission
    assert_equal "Hello Big World!", "Hello Big World!".truncate_words(3, omission: "[...]")
    assert_equal "Hello Big[...]", "Hello Big World!".truncate_words(2, omission: "[...]")
  end

  def test_truncate_words_with_separator
    assert_equal "Hello<br>Big<br>World!...", "Hello<br>Big<br>World!<br>".truncate_words(3, separator: "<br>")
    assert_equal "Hello<br>Big<br>World!", "Hello<br>Big<br>World!".truncate_words(3, separator: "<br>")
    assert_equal "Hello\n<br>Big...", "Hello\n<br>Big<br>Wide<br>World!".truncate_words(2, separator: "<br>")
  end

  def test_truncate_words_with_separator_and_omission
    assert_equal "Hello<br>Big<br>World![...]", "Hello<br>Big<br>World!<br>".truncate_words(3, omission: "[...]", separator: "<br>")
    assert_equal "Hello<br>Big<br>World!", "Hello<br>Big<br>World!".truncate_words(3, omission: "[...]", separator: "<br>")
  end

  def test_truncate_words_with_complex_string
    Timeout.timeout(10) do
      complex_string = "aa aa aaa aa aaa aaa aaa aa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaaa aaaaa aaaaaa aa aa aa aaa aa  aaa aa aa aa aa a aaa aaa \n a aaa <<s"
      assert_equal complex_string, complex_string.truncate_words(80)
    end
  rescue Timeout::Error
    assert false
  end

  def test_truncate_multibyte
    assert_equal (+"\354\225\204\353\246\254\353\236\221 \354\225\204\353\246\254 ...").force_encoding(Encoding::UTF_8),
      (+"\354\225\204\353\246\254\353\236\221 \354\225\204\353\246\254 \354\225\204\353\235\274\353\246\254\354\230\244").force_encoding(Encoding::UTF_8).truncate(10)
  end

  def test_truncate_should_not_be_html_safe
    assert_not_predicate "Hello World!".truncate(12), :html_safe?
  end

  def test_remove
    original = "This is a good day to die"
    assert_equal "This is a good day", original.remove(" to die")
    assert_equal "This is a good day", original.remove(" to ", /die/)
    assert_equal "This is a good day to die", original
  end

  def test_remove_for_multiple_occurrences
    original = "This is a good day to die to die"
    assert_equal "This is a good day", original.remove(" to die")
    assert_equal "This is a good day to die to die", original
  end

  def test_remove!
    original = +"This is a very good day to die"
    assert_equal "This is a good day to die", original.remove!(" very")
    assert_equal "This is a good day to die", original
    assert_equal "This is a good day", original.remove!(" to ", /die/)
    assert_equal "This is a good day", original
  end

  def test_constantize
    run_constantize_tests_on(&:constantize)
  end

  def test_safe_constantize
    run_safe_constantize_tests_on(&:safe_constantize)
  end
end

class StringAccessTest < ActiveSupport::TestCase
  test "#at with Integer, returns a substring of one character at that position" do
    assert_equal "h", "hello".at(0)
  end

  test "#at with Range, returns a substring containing characters at offsets" do
    assert_equal "lo", "hello".at(-2..-1)
  end

  test "#at with Regex, returns the matching portion of the string" do
    assert_equal "lo", "hello".at(/lo/)
    assert_nil "hello".at(/nonexisting/)
  end

  test "#from with positive Integer, returns substring from the given position to the end" do
    assert_equal "llo", "hello".from(2)
  end

  test "#from with negative Integer, position is counted from the end" do
    assert_equal "lo", "hello".from(-2)
  end

  test "#to with positive Integer, substring from the beginning to the given position" do
    assert_equal "hel", "hello".to(2)
  end

  test "#to with negative Integer, position is counted from the end" do
    assert_equal "hell", "hello".to(-2)
    assert_equal "h", "hello".to(-5)
    assert_equal "", "hello".to(-7)
  end

  test "#from and #to can be combined" do
    assert_equal "hello", "hello".from(0).to(-1)
    assert_equal "ell", "hello".from(1).to(-2)
  end

  test "#first returns the first character" do
    assert_equal "h", "hello".first
    assert_equal "x", "x".first
  end

  test "#first with Integer, returns a substring from the beginning to position" do
    assert_equal "he", "hello".first(2)
    assert_equal "", "hello".first(0)
    assert_equal "hello", "hello".first(10)
    assert_equal "x", "x".first(4)
  end

  test "#first with Integer >= string length still returns a new string" do
    string = "hello"
    different_string = string.first(5)
    assert_not_same different_string, string
  end

  test "#first with Integer returns a non-frozen string" do
    string = "he"
    (0..string.length + 1).each do |limit|
      assert_not string.first(limit).frozen?
    end
  end

  test "#first with negative Integer raises ArgumentError" do
    assert_raise ArgumentError do
      "hello".first(-1)
    end
  end

  test "#last returns the last character" do
    assert_equal "o", "hello".last
    assert_equal "x", "x".last
  end

  test "#last with Integer, returns a substring from the end to position" do
    assert_equal "llo", "hello".last(3)
    assert_equal "hello", "hello".last(10)
    assert_equal "", "hello".last(0)
    assert_equal "x", "x".last(4)
  end

  test "#last with Integer >= string length still returns a new string" do
    string = "hello"
    different_string = string.last(5)
    assert_not_same different_string, string
  end

  test "#last with Integer returns a non-frozen string" do
    string = "he"
    (0..string.length + 1).each do |limit|
      assert_not string.last(limit).frozen?
    end
  end

  test "#last with negative Integer raises ArgumentError" do
    assert_raise ArgumentError do
      "hello".last(-1)
    end
  end

  test "access returns a real string" do
    hash = {}
    hash["h"] = true
    hash["hello123".at(0)] = true
    assert_equal %w(h), hash.keys

    hash = {}
    hash["llo"] = true
    hash["hello".from(2)] = true
    assert_equal %w(llo), hash.keys

    hash = {}
    hash["hel"] = true
    hash["hello".to(2)] = true
    assert_equal %w(hel), hash.keys

    hash = {}
    hash["hello"] = true
    hash["123hello".last(5)] = true
    assert_equal %w(hello), hash.keys

    hash = {}
    hash["hello"] = true
    hash["hello123".first(5)] = true
    assert_equal %w(hello), hash.keys
  end
end

class StringConversionsTest < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def test_string_to_time
    with_env_tz "Europe/Moscow" do
      assert_equal Time.utc(2005, 2, 27, 23, 50), "2005-02-27 23:50".to_time(:utc)
      assert_equal Time.local(2005, 2, 27, 23, 50), "2005-02-27 23:50".to_time
      assert_equal Time.utc(2005, 2, 27, 23, 50, 19, 275038), "2005-02-27T23:50:19.275038".to_time(:utc)
      assert_equal Time.local(2005, 2, 27, 23, 50, 19, 275038), "2005-02-27T23:50:19.275038".to_time
      assert_equal Time.utc(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_time(:utc)
      assert_equal Time.local(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_time
      assert_equal Time.local(2011, 2, 27, 17, 50), "2011-02-27 13:50 -0100".to_time
      assert_equal Time.utc(2011, 2, 27, 23, 50), "2011-02-27 22:50 -0100".to_time(:utc)
      assert_equal Time.local(2005, 2, 27, 22, 50), "2005-02-27 14:50 -0500".to_time
      assert_nil "010".to_time
      assert_nil "".to_time
    end
  end

  def test_timestamp_string_to_time
    exception = assert_raises(ArgumentError) do
      "1604326192".to_time
    end

    assert_equal "argument out of range", exception.message
  end

  def test_string_to_time_utc_offset
    with_env_tz "US/Eastern" do
      if ActiveSupport.to_time_preserves_timezone
        assert_equal 0, "2005-02-27 23:50".to_time(:utc).utc_offset
        assert_equal(-18000, "2005-02-27 23:50".to_time.utc_offset)
        assert_equal 0, "2005-02-27 22:50 -0100".to_time(:utc).utc_offset
        assert_equal(-3600, "2005-02-27 22:50 -0100".to_time.utc_offset)
      else
        assert_equal 0, "2005-02-27 23:50".to_time(:utc).utc_offset
        assert_equal(-18000, "2005-02-27 23:50".to_time.utc_offset)
        assert_equal 0, "2005-02-27 22:50 -0100".to_time(:utc).utc_offset
        assert_equal(-18000, "2005-02-27 22:50 -0100".to_time.utc_offset)
      end
    end
  end

  def test_partial_string_to_time
    with_env_tz "Europe/Moscow" do # use timezone which does not observe DST.
      now = Time.now
      assert_equal Time.local(now.year, now.month, now.day, 23, 50), "23:50".to_time
      assert_equal Time.utc(now.year, now.month, now.day, 23, 50), "23:50".to_time(:utc)
      assert_equal Time.local(now.year, now.month, now.day, 17, 50), "13:50 -0100".to_time
      assert_equal Time.utc(now.year, now.month, now.day, 23, 50), "22:50 -0100".to_time(:utc)
    end
  end

  def test_standard_time_string_to_time_when_current_time_is_standard_time
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2012, 1, 1)) do
        assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00".to_time
        assert_equal Time.utc(2012, 1, 1, 10, 0), "2012-01-01 10:00".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 13, 0), "2012-01-01 10:00 -0800".to_time
        assert_equal Time.utc(2012, 1, 1, 18, 0), "2012-01-01 10:00 -0800".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00 -0500".to_time
        assert_equal Time.utc(2012, 1, 1, 15, 0), "2012-01-01 10:00 -0500".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 5, 0), "2012-01-01 10:00 UTC".to_time
        assert_equal Time.utc(2012, 1, 1, 10, 0), "2012-01-01 10:00 UTC".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 13, 0), "2012-01-01 10:00 PST".to_time
        assert_equal Time.utc(2012, 1, 1, 18, 0), "2012-01-01 10:00 PST".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00 EST".to_time
        assert_equal Time.utc(2012, 1, 1, 15, 0), "2012-01-01 10:00 EST".to_time(:utc)
      end
    end
  end

  def test_standard_time_string_to_time_when_current_time_is_daylight_savings
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2012, 7, 1)) do
        assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00".to_time
        assert_equal Time.utc(2012, 1, 1, 10, 0), "2012-01-01 10:00".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 13, 0), "2012-01-01 10:00 -0800".to_time
        assert_equal Time.utc(2012, 1, 1, 18, 0), "2012-01-01 10:00 -0800".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00 -0500".to_time
        assert_equal Time.utc(2012, 1, 1, 15, 0), "2012-01-01 10:00 -0500".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 5, 0), "2012-01-01 10:00 UTC".to_time
        assert_equal Time.utc(2012, 1, 1, 10, 0), "2012-01-01 10:00 UTC".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 13, 0), "2012-01-01 10:00 PST".to_time
        assert_equal Time.utc(2012, 1, 1, 18, 0), "2012-01-01 10:00 PST".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00 EST".to_time
        assert_equal Time.utc(2012, 1, 1, 15, 0), "2012-01-01 10:00 EST".to_time(:utc)
      end
    end
  end

  def test_daylight_savings_string_to_time_when_current_time_is_standard_time
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2012, 1, 1)) do
        assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00".to_time
        assert_equal Time.utc(2012, 7, 1, 10, 0), "2012-07-01 10:00".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 13, 0), "2012-07-01 10:00 -0700".to_time
        assert_equal Time.utc(2012, 7, 1, 17, 0), "2012-07-01 10:00 -0700".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00 -0400".to_time
        assert_equal Time.utc(2012, 7, 1, 14, 0), "2012-07-01 10:00 -0400".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 6, 0), "2012-07-01 10:00 UTC".to_time
        assert_equal Time.utc(2012, 7, 1, 10, 0), "2012-07-01 10:00 UTC".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 13, 0), "2012-07-01 10:00 PDT".to_time
        assert_equal Time.utc(2012, 7, 1, 17, 0), "2012-07-01 10:00 PDT".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00 EDT".to_time
        assert_equal Time.utc(2012, 7, 1, 14, 0), "2012-07-01 10:00 EDT".to_time(:utc)
      end
    end
  end

  def test_daylight_savings_string_to_time_when_current_time_is_daylight_savings
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2012, 7, 1)) do
        assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00".to_time
        assert_equal Time.utc(2012, 7, 1, 10, 0), "2012-07-01 10:00".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 13, 0), "2012-07-01 10:00 -0700".to_time
        assert_equal Time.utc(2012, 7, 1, 17, 0), "2012-07-01 10:00 -0700".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00 -0400".to_time
        assert_equal Time.utc(2012, 7, 1, 14, 0), "2012-07-01 10:00 -0400".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 6, 0), "2012-07-01 10:00 UTC".to_time
        assert_equal Time.utc(2012, 7, 1, 10, 0), "2012-07-01 10:00 UTC".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 13, 0), "2012-07-01 10:00 PDT".to_time
        assert_equal Time.utc(2012, 7, 1, 17, 0), "2012-07-01 10:00 PDT".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00 EDT".to_time
        assert_equal Time.utc(2012, 7, 1, 14, 0), "2012-07-01 10:00 EDT".to_time(:utc)
      end
    end
  end

  def test_partial_string_to_time_when_current_time_is_standard_time
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2012, 1, 1)) do
        assert_equal Time.local(2012, 1, 1, 10, 0), "10:00".to_time
        assert_equal Time.utc(2012, 1, 1, 10, 0),  "10:00".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 6, 0), "10:00 -0100".to_time
        assert_equal Time.utc(2012, 1, 1, 11, 0), "10:00 -0100".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 10, 0), "10:00 -0500".to_time
        assert_equal Time.utc(2012, 1, 1, 15, 0), "10:00 -0500".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 5, 0), "10:00 UTC".to_time
        assert_equal Time.utc(2012, 1, 1, 10, 0), "10:00 UTC".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 13, 0), "10:00 PST".to_time
        assert_equal Time.utc(2012, 1, 1, 18, 0), "10:00 PST".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 12, 0), "10:00 PDT".to_time
        assert_equal Time.utc(2012, 1, 1, 17, 0), "10:00 PDT".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 10, 0), "10:00 EST".to_time
        assert_equal Time.utc(2012, 1, 1, 15, 0), "10:00 EST".to_time(:utc)
        assert_equal Time.local(2012, 1, 1, 9, 0), "10:00 EDT".to_time
        assert_equal Time.utc(2012, 1, 1, 14, 0), "10:00 EDT".to_time(:utc)
      end
    end
  end

  def test_partial_string_to_time_when_current_time_is_daylight_savings
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2012, 7, 1)) do
        assert_equal Time.local(2012, 7, 1, 10, 0), "10:00".to_time
        assert_equal Time.utc(2012, 7, 1, 10, 0), "10:00".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 7, 0), "10:00 -0100".to_time
        assert_equal Time.utc(2012, 7, 1, 11, 0), "10:00 -0100".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 11, 0), "10:00 -0500".to_time
        assert_equal Time.utc(2012, 7, 1, 15, 0), "10:00 -0500".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 6, 0), "10:00 UTC".to_time
        assert_equal Time.utc(2012, 7, 1, 10, 0), "10:00 UTC".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 14, 0), "10:00 PST".to_time
        assert_equal Time.utc(2012, 7, 1, 18, 0), "10:00 PST".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 13, 0), "10:00 PDT".to_time
        assert_equal Time.utc(2012, 7, 1, 17, 0), "10:00 PDT".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 11, 0), "10:00 EST".to_time
        assert_equal Time.utc(2012, 7, 1, 15, 0), "10:00 EST".to_time(:utc)
        assert_equal Time.local(2012, 7, 1, 10, 0), "10:00 EDT".to_time
        assert_equal Time.utc(2012, 7, 1, 14, 0), "10:00 EDT".to_time(:utc)
      end
    end
  end

  def test_string_to_datetime
    assert_equal DateTime.civil(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_datetime
    assert_equal 0, "2039-02-27 23:50".to_datetime.offset # use UTC offset
    assert_equal ::Date::ITALY, "2039-02-27 23:50".to_datetime.start # use Ruby's default start value
    assert_equal DateTime.civil(2039, 2, 27, 23, 50, 19 + Rational(275038, 1000000), "-04:00"), "2039-02-27T23:50:19.275038-04:00".to_datetime
    assert_nil "".to_datetime
  end

  def test_partial_string_to_datetime
    now = DateTime.now
    assert_equal DateTime.civil(now.year, now.month, now.day, 23, 50), "23:50".to_datetime
    assert_equal DateTime.civil(now.year, now.month, now.day, 23, 50, 0, "-04:00"), "23:50 -0400".to_datetime
  end

  def test_string_to_date
    assert_equal Date.new(2005, 2, 27), "2005-02-27".to_date
    assert_nil "".to_date
    assert_equal Date.new(Date.today.year, 2, 3), "Feb 3rd".to_date
  end
end

class StringBehaviourTest < ActiveSupport::TestCase
  def test_acts_like_string
    assert_predicate "Bambi", :acts_like_string?
  end
end

class CoreExtStringMultibyteTest < ActiveSupport::TestCase
  UTF8_STRING = ""
  ASCII_STRING = "ohayo".encode("US-ASCII")
  EUC_JP_STRING = "".encode("EUC-JP")
  INVALID_UTF8_STRING = "\270\236\010\210\245"

  def test_core_ext_adds_mb_chars
    assert_respond_to UTF8_STRING, :mb_chars
  end

  def test_string_should_recognize_utf8_strings
    assert_predicate UTF8_STRING, :is_utf8?
    assert_predicate ASCII_STRING, :is_utf8?
    assert_not_predicate EUC_JP_STRING, :is_utf8?
    assert_not_predicate INVALID_UTF8_STRING, :is_utf8?
  end

  def test_mb_chars_returns_instance_of_proxy_class
    assert_kind_of ActiveSupport::Multibyte.proxy_class, UTF8_STRING.mb_chars
  end
end

class OutputSafetyTest < ActiveSupport::TestCase
  def setup
    @string = +"hello"
    @object = Class.new(Object) do
      def to_s
        "other"
      end
    end.new
  end

  test "A string is unsafe by default" do
    assert_not_predicate @string, :html_safe?
  end

  test "A string can be marked safe" do
    string = @string.html_safe
    assert_predicate string, :html_safe?
  end

  test "Marking a string safe returns the string" do
    assert_equal @string, @string.html_safe
  end

  test "An integer is safe by default" do
    assert_predicate 5, :html_safe?
  end

  test "a float is safe by default" do
    assert_predicate 5.7, :html_safe?
  end

  test "An object is unsafe by default" do
    assert_not_predicate @object, :html_safe?
  end

  test "Adding an object to a safe string returns a safe string" do
    string = @string.html_safe
    string << @object

    assert_equal "helloother", string
    assert_predicate string, :html_safe?
  end

  test "Adding a safe string to another safe string returns a safe string" do
    @other_string = "other".html_safe
    string = @string.html_safe
    @combination = @other_string + string

    assert_equal "otherhello", @combination
    assert_predicate @combination, :html_safe?
  end

  test "Adding an unsafe string to a safe string escapes it and returns a safe string" do
    @other_string = "other".html_safe
    @combination = @other_string + "<foo>"
    @other_combination = @string + "<foo>"

    assert_equal "other&lt;foo&gt;", @combination
    assert_equal "hello<foo>", @other_combination

    assert_predicate @combination, :html_safe?
    assert_not_predicate @other_combination, :html_safe?
  end

  test "Prepending safe onto unsafe yields unsafe" do
    @string.prepend "other".html_safe
    assert_not_predicate @string, :html_safe?
    assert_equal "otherhello", @string
  end

  test "Prepending unsafe onto safe yields escaped safe" do
    other = "other".html_safe
    other.prepend "<foo>"
    assert_predicate other, :html_safe?
    assert_equal "&lt;foo&gt;other", other
  end

  test "Concatting safe onto unsafe yields unsafe" do
    @other_string = +"other"

    string = @string.html_safe
    @other_string.concat(string)
    assert_not_predicate @other_string, :html_safe?
  end

  test "Concatting unsafe onto safe yields escaped safe" do
    @other_string = "other".html_safe
    string = @other_string.concat("<foo>")
    assert_equal "other&lt;foo&gt;", string
    assert_predicate string, :html_safe?
  end

  test "Concatting safe onto safe yields safe" do
    @other_string = "other".html_safe
    string = @string.html_safe

    @other_string.concat(string)
    assert_predicate @other_string, :html_safe?
  end

  test "Concatting safe onto unsafe with << yields unsafe" do
    @other_string = +"other"
    string = @string.html_safe

    @other_string << string
    assert_not_predicate @other_string, :html_safe?
  end

  test "Concatting unsafe onto safe with << yields escaped safe" do
    @other_string = "other".html_safe
    string = @other_string << "<foo>"
    assert_equal "other&lt;foo&gt;", string
    assert_predicate string, :html_safe?
  end

  test "Concatting safe onto safe with << yields safe" do
    @other_string = "other".html_safe
    string = @string.html_safe

    @other_string << string
    assert_predicate @other_string, :html_safe?
  end

  test "Concatting safe onto unsafe with % yields unsafe" do
    @other_string = "other%s"
    string = @string.html_safe

    @other_string = @other_string % string
    assert_not_predicate @other_string, :html_safe?
  end

  test "Concatting unsafe onto safe with % yields escaped safe" do
    @other_string = "other%s".html_safe
    string = @other_string % "<foo>"

    assert_equal "other&lt;foo&gt;", string
    assert_predicate string, :html_safe?
  end

  test "Concatting safe onto safe with % yields safe" do
    @other_string = "other%s".html_safe
    string = @string.html_safe

    @other_string = @other_string % string
    assert_predicate @other_string, :html_safe?
  end

  test "Concatting with % doesn't modify a string" do
    @other_string = ["<p>", "<b>", "<h1>"]
    _ = "%s %s %s".html_safe % @other_string

    assert_equal ["<p>", "<b>", "<h1>"], @other_string
  end

  test "Concatting an integer to safe always yields safe" do
    string = @string.html_safe
    string = string.concat(13)
    assert_equal (+"hello").concat(13), string
    assert_predicate string, :html_safe?
  end

  test "Inserting safe into safe yields safe" do
    string = "foo".html_safe
    string.insert(0, "<b>".html_safe)

    assert_equal "<b>foo", string
    assert_predicate string, :html_safe?
  end

  test "Inserting unsafe into safe yields escaped safe" do
    string = "foo".html_safe
    string.insert(0, "<b>")

    assert_equal "&lt;b&gt;foo", string
    assert_predicate string, :html_safe?
  end

  test "Replacing safe with safe yields safe" do
    string = "foo".html_safe
    string.replace("<b>".html_safe)

    assert_equal "<b>", string
    assert_predicate string, :html_safe?
  end

  test "Replacing safe with unsafe yields escaped safe" do
    string = "foo".html_safe
    string.replace("<b>")

    assert_equal "&lt;b&gt;", string
    assert_predicate string, :html_safe?
  end

  test "Replacing index of safe with safe yields safe" do
    string = "foo".html_safe
    string[0] = "<b>".html_safe

    assert_equal "<b>oo", string
    assert_predicate string, :html_safe?
  end

  test "Replacing index of safe with unsafe yields escaped safe" do
    string = "foo".html_safe
    string[0] = "<b>"

    assert_equal "&lt;b&gt;oo", string
    assert_predicate string, :html_safe?
  end

  test "emits normal string yaml" do
    assert_equal "foo".to_yaml, "foo".html_safe.to_yaml(foo: 1)
  end

  test "call to_param returns a normal string" do
    string = @string.html_safe
    assert_predicate string, :html_safe?
    assert_not_predicate string.to_param, :html_safe?
  end

  test "ERB::Util.html_escape should escape unsafe characters" do
    string = '<>&"\''
    expected = "&lt;&gt;&amp;&quot;&#39;"
    assert_equal expected, ERB::Util.html_escape(string)
  end

  test "ERB::Util.html_escape should correctly handle invalid UTF-8 strings" do
    string = "\251 <"
    expected = " &lt;"
    assert_equal expected, ERB::Util.html_escape(string)
  end

  test "ERB::Util.html_escape should not escape safe strings" do
    string = "<b>hello</b>".html_safe
    assert_equal string, ERB::Util.html_escape(string)
  end

  test "ERB::Util.html_escape_once only escapes once" do
    string = "1 < 2 &amp; 3"
    escaped_string = "1 &lt; 2 &amp; 3"

    assert_equal escaped_string, ERB::Util.html_escape_once(string)
    assert_equal escaped_string, ERB::Util.html_escape_once(escaped_string)
  end

  test "ERB::Util.html_escape_once should correctly handle invalid UTF-8 strings" do
    string = "\251 <"
    expected = " &lt;"
    assert_equal expected, ERB::Util.html_escape_once(string)
  end
end

class StringExcludeTest < ActiveSupport::TestCase
  test "inverse of #include" do
    assert_equal false, "foo".exclude?("o")
    assert_equal true, "foo".exclude?("p")
  end
end

class StringIndentTest < ActiveSupport::TestCase
  test "does not indent strings that only contain newlines (edge cases)" do
    ["", "\n", "\n" * 7].each do |string|
      str = string.dup
      assert_nil str.indent!(8)
      assert_equal str, str.indent(8)
      assert_equal str, str.indent(1, "\t")
    end
  end

  test "by default, indents with spaces if the existing indentation uses them" do
    assert_equal "    foo\n      bar", "foo\n  bar".indent(4)
  end

  test "by default, indents with tabs if the existing indentation uses them" do
    assert_equal "\tfoo\n\t\t\bar", "foo\n\t\bar".indent(1)
  end

  test "by default, indents with spaces as a fallback if there is no indentation" do
    assert_equal "   foo\n   bar\n   baz", "foo\nbar\nbaz".indent(3)
  end

  # Nothing is said about existing indentation that mixes spaces and tabs, so
  # there is nothing to test.

  test "uses the indent char if passed" do
    assert_equal <<EXPECTED, <<ACTUAL.indent(4, ".")
....  def some_method(x, y)
....    some_code
....  end
EXPECTED
  def some_method(x, y)
    some_code
  end
ACTUAL

    assert_equal <<EXPECTED, <<ACTUAL.indent(2, "&nbsp;")
&nbsp;&nbsp;&nbsp;&nbsp;def some_method(x, y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;some_code
&nbsp;&nbsp;&nbsp;&nbsp;end
EXPECTED
&nbsp;&nbsp;def some_method(x, y)
&nbsp;&nbsp;&nbsp;&nbsp;some_code
&nbsp;&nbsp;end
ACTUAL
  end

  test "does not indent blank lines by default" do
    assert_equal " foo\n\n bar", "foo\n\nbar".indent(1)
  end

  test "indents blank lines if told so" do
    assert_equal " foo\n \n bar", "foo\n\nbar".indent(1, nil, true)
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/class"
require "set"

class ClassTest < ActiveSupport::TestCase
  class Parent; end
  class Foo < Parent; end
  class Bar < Foo; end
  class Baz < Bar; end

  class A < Parent; end
  class B < A; end
  class C < B; end

  def test_descendants
    assert_equal [Foo, Bar, Baz, A, B, C].to_set, Parent.descendants.to_set
    assert_equal [Bar, Baz].to_set, Foo.descendants.to_set
    assert_equal [Baz], Bar.descendants
    assert_equal [], Baz.descendants
  end

  def test_subclasses
    assert_equal [Foo, A].to_set, Parent.subclasses.to_set
    assert_equal [Bar], Foo.subclasses
    assert_equal [Baz], Bar.subclasses
    assert_equal [], Baz.subclasses
  end

  def test_descendants_excludes_singleton_classes
    klass = Parent.new.singleton_class
    assert_not Parent.descendants.include?(klass), "descendants should not include singleton classes"
  end

# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/marshal"
require_relative "../dependencies_test_helpers"

class MarshalTest < ActiveSupport::TestCase
  include ActiveSupport::Testing::Isolation
  include DependenciesTestHelpers

  def teardown
    ActiveSupport::Dependencies.clear
    remove_constants(:EM, :ClassFolder)
  end

  test "that Marshal#load still works" do
    sanity_data = ["test", [1, 2, 3], { a: [1, 2, 3] }, ActiveSupport::TestCase]
    sanity_data.each do |obj|
      dumped = Marshal.dump(obj)
      assert_equal Marshal.method(:load).super_method.call(dumped), Marshal.load(dumped)
    end
  end

  test "that Marshal#load still works when passed a proc" do
    example_string = "test"

    example_proc = Proc.new do |o|
      if o.is_a?(String)
        o.capitalize!
      end
    end

    dumped = Marshal.dump(example_string)
    assert_equal Marshal.load(dumped, example_proc), "Test"
  end

  test "that a missing class is autoloaded from string" do
    dumped = nil
    with_autoloading_fixtures do
      dumped = Marshal.dump(EM.new)
    end

    remove_constants(:EM)
    ActiveSupport::Dependencies.clear

    with_autoloading_fixtures do
      object = nil
      assert_nothing_raised do
        object = Marshal.load(dumped)
      end

      assert_kind_of EM, object
    end
  end

  test "that classes in sub modules work" do
    dumped = nil
    with_autoloading_fixtures do
      dumped = Marshal.dump(ClassFolder::ClassFolderSubclass.new)
    end

    remove_constants(:ClassFolder)
    ActiveSupport::Dependencies.clear

    with_autoloading_fixtures do
      object = nil
      assert_nothing_raised do
        object = Marshal.load(dumped)
      end

      assert_kind_of ClassFolder::ClassFolderSubclass, object
    end
  end

  test "that more than one missing class is autoloaded" do
    dumped = nil
    with_autoloading_fixtures do
      dumped = Marshal.dump([EM.new, ClassFolder.new])
    end

    remove_constants(:EM, :ClassFolder)
    ActiveSupport::Dependencies.clear

    with_autoloading_fixtures do
      loaded = Marshal.load(dumped)
      assert_equal 2, loaded.size
      assert_kind_of EM, loaded[0]
      assert_kind_of ClassFolder, loaded[1]
    end
  end

  test "when one constant resolves to another" do
    class Parent; C = Class.new; end
    class Child < Parent; C = Class.new; end

    dump = Marshal.dump(Child::C.new)

    Child.send(:remove_const, :C)

    assert_raise(ArgumentError) { Marshal.load(dump) }
  end

  test "that a real missing class is causing an exception" do
    dumped = nil
    with_autoloading_fixtures do
      dumped = Marshal.dump(EM.new)
    end

    remove_constants(:EM)
    ActiveSupport::Dependencies.clear

    assert_raise(NameError) do
      Marshal.load(dumped)
    end
  end

  test "when first class is autoloaded and second not" do
    dumped = nil
    class SomeClass
    end

    with_autoloading_fixtures do
      dumped = Marshal.dump([EM.new, SomeClass.new])
    end

    remove_constants(:EM)
    self.class.send(:remove_const, :SomeClass)
    ActiveSupport::Dependencies.clear

    with_autoloading_fixtures do
      assert_raise(NameError) do
        Marshal.load(dumped)
      end

      assert_nothing_raised do
        EM.new
      end

      assert_raise(NameError, "We expected SomeClass to not be loaded but it is!") do
        SomeClass.new
      end
    end
  end

  test "loading classes from files trigger autoloading" do
    Tempfile.open("object_serializer_test") do |f|
      with_autoloading_fixtures do
        Marshal.dump(EM.new, f)
      end

      f.rewind
      remove_constants(:EM)
      ActiveSupport::Dependencies.clear

      with_autoloading_fixtures do
        object = nil
        assert_nothing_raised do
          object = Marshal.load(f)
        end

# frozen_string_literal: true

require_relative "../../abstract_unit"

# These test cases were added to test that cherry-picking the json extensions
# works correctly, primarily for dependencies problems reported in #16131. They
# need to be executed in isolation to reproduce the scenario correctly, because
# other test cases might have already loaded additional dependencies.

class JsonCherryPickTest < ActiveSupport::TestCase
  include ActiveSupport::Testing::Isolation

  def test_time_as_json
    require_or_skip "active_support/core_ext/object/json"

    expected = Time.new(2004, 7, 25)
    actual   = Time.parse(expected.as_json)

    assert_equal expected, actual
  end

  def test_date_as_json
    require_or_skip "active_support/core_ext/object/json"

    expected = Date.new(2004, 7, 25)
    actual   = Date.parse(expected.as_json)

    assert_equal expected, actual
  end

  def test_datetime_as_json
    require_or_skip "active_support/core_ext/object/json"

    expected = DateTime.new(2004, 7, 25)
    actual   = DateTime.parse(expected.as_json)

    assert_equal expected, actual
  end

  private
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/object/to_param"

class ToParamTest < ActiveSupport::TestCase
  class CustomString < String
    def to_param
      "custom-#{ self }"
    end
  end

  def test_object
    foo = Object.new
    def foo.to_s; "foo" end
    assert_equal "foo", foo.to_param
  end

  def test_nil
    assert_nil nil.to_param
  end

  def test_boolean
    assert_equal true, true.to_param
    assert_equal false, false.to_param
  end

  def test_array
    # Empty Array
    assert_equal "", [].to_param

    array = [1, 2, 3, 4]
    assert_equal "1/2/3/4", array.to_param

    # Array of different objects
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/date/acts_like"
require "active_support/core_ext/time/acts_like"
require "active_support/core_ext/date_time/acts_like"
require "active_support/core_ext/object/acts_like"

class ObjectTests < ActiveSupport::TestCase
  class DuckTime
    def acts_like_time?
      true
    end
  end

  def test_duck_typing
    object = Object.new
    time   = Time.now
    date   = Date.today
    dt     = DateTime.new
    duck   = DuckTime.new

    assert_not object.acts_like?(:time)
    assert_not object.acts_like?(:date)

    assert time.acts_like?(:time)
    assert_not time.acts_like?(:date)

    assert_not date.acts_like?(:time)
    assert date.acts_like?(:date)

    assert dt.acts_like?(:time)
    assert dt.acts_like?(:date)

    assert duck.acts_like?(:time)
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/object/inclusion"

class InTest < ActiveSupport::TestCase
  def test_in_array
    assert 1.in?([1, 2])
    assert_not 3.in?([1, 2])
  end

  def test_in_hash
    h = { "a" => 100, "b" => 200 }
    assert "a".in?(h)
    assert_not "z".in?(h)
  end

  def test_in_string
    assert "lo".in?("hello")
    assert_not "ol".in?("hello")
    assert ?h.in?("hello")
  end

  def test_in_range
    assert 25.in?(1..50)
    assert_not 75.in?(1..50)
  end

  def test_in_set
    s = Set.new([1, 2])
    assert 1.in?(s)
    assert_not 3.in?(s)
  end

  module A
  end
  class B
    include A
  end
  class C < B
  end
  class D
  end

  def test_in_module
    assert A.in?(B)
    assert A.in?(C)
    assert_not A.in?(A)
    assert_not A.in?(D)
  end

  def test_no_method_catching
    assert_raise(ArgumentError) { 1.in?(1) }
  end

  def test_presence_in
    assert_equal "stuff", "stuff".presence_in(%w( lots of stuff ))
    assert_nil "stuff".presence_in(%w( lots of crap ))
    assert_raise(ArgumentError) { 1.presence_in(1) }
  end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/ordered_hash"
require "active_support/core_ext/object/to_query"
require "active_support/core_ext/string/output_safety"

class ToQueryTest < ActiveSupport::TestCase
  def test_simple_conversion
    assert_query_equal "a=10", a: 10
  end

  def test_cgi_escaping
    assert_query_equal "a%3Ab=c+d", "a:b" => "c d"
  end

  def test_html_safe_parameter_key
    assert_query_equal "a%3Ab=c+d", "a:b".html_safe => "c d"
  end

  def test_html_safe_parameter_value
    assert_query_equal "a=%5B10%5D", "a" => "[10]".html_safe
  end

  def test_nil_parameter_value
    empty = Object.new
    def empty.to_param; nil end
    assert_query_equal "a=", "a" => empty
  end

  def test_nested_conversion
    assert_query_equal "person%5Blogin%5D=seckar&person%5Bname%5D=Nicholas",
      person: Hash[:login, "seckar", :name, "Nicholas"]
  end

  def test_multiple_nested
    assert_query_equal "account%5Bperson%5D%5Bid%5D=20&person%5Bid%5D=10",
      Hash[:account, { person: { id: 20 } }, :person, { id: 10 }]
  end

  def test_array_values
    assert_query_equal "person%5Bid%5D%5B%5D=10&person%5Bid%5D%5B%5D=20",
      person: { id: [10, 20] }
  end

  def test_array_values_are_not_sorted
    assert_query_equal "person%5Bid%5D%5B%5D=20&person%5Bid%5D%5B%5D=10",
      person: { id: [20, 10] }
  end

  def test_empty_array
    assert_equal "person%5B%5D=", [].to_query("person")
  end

  def test_nested_empty_hash
    assert_equal "",
      {}.to_query
    assert_query_equal "a=1&b%5Bc%5D=3",
      a: 1, b: { c: 3, d: {} }
    assert_query_equal "",
      a: { b: { c: {} } }
    assert_query_equal "b%5Bc%5D=false&b%5Be%5D=&b%5Bf%5D=&p=12",
      p: 12, b: { c: false, e: nil, f: "" }
    assert_query_equal "b%5Bc%5D=3&b%5Bf%5D=",
      b: { c: 3, k: {}, f: "" }
    assert_query_equal "b=3",
      a: [], b: 3
  end

  def test_hash_with_namespace
    hash = { name: "Nakshay", nationality: "Indian" }
    assert_equal "user%5Bname%5D=Nakshay&user%5Bnationality%5D=Indian", hash.to_query("user")
  end

  def test_hash_sorted_lexicographically
    hash = { type: "human", name: "Nakshay" }
    assert_equal "name=Nakshay&type=human", hash.to_query
  end

  def test_hash_not_sorted_lexicographically_for_nested_structure
    params = {
      "foo" => {
        "contents" => [
          { "name" => "gorby", "id" => "123" },
          { "name" => "puff", "d" => "true" }
        ]
      }
    }
    expected = "foo[contents][][name]=gorby&foo[contents][][id]=123&foo[contents][][name]=puff&foo[contents][][d]=true"

    assert_equal expected, URI.decode_www_form_component(params.to_query)
  end

  private
    def assert_query_equal(expected, actual)
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/object/blank"

class BlankTest < ActiveSupport::TestCase
  class EmptyTrue
    def empty?
      0
    end
  end

  class EmptyFalse
    def empty?
      nil
    end
  end

  BLANK = [ EmptyTrue.new, nil, false, "", "   ", "  \n\t  \r ", "", "\u00a0", [], {}, " ".encode("UTF-16LE") ]
  NOT   = [ EmptyFalse.new, Object.new, true, 0, 1, "a", [nil], { nil => 0 }, Time.now, "my value".encode("UTF-16LE") ]

  def test_blank
    BLANK.each { |v| assert_equal true, v.blank?,  "#{v.inspect} should be blank" }
    NOT.each   { |v| assert_equal false, v.blank?, "#{v.inspect} should not be blank" }
  end

  def test_present
    BLANK.each { |v| assert_equal false, v.present?, "#{v.inspect} should not be present" }
    NOT.each   { |v| assert_equal true, v.present?,  "#{v.inspect} should be present" }
  end

  def test_presence
    BLANK.each { |v| assert_nil v.presence, "#{v.inspect}.presence should return nil" }
    NOT.each   { |v| assert_equal v,   v.presence, "#{v.inspect}.presence should return self" }
  end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/object/deep_dup"

class DeepDupTest < ActiveSupport::TestCase
  def test_array_deep_dup
    array = [1, [2, 3]]
    dup = array.deep_dup
    dup[1][2] = 4
    assert_nil array[1][2]
    assert_equal 4, dup[1][2]
  end

  def test_hash_deep_dup
    hash = { a: { b: "b" } }
    dup = hash.deep_dup
    dup[:a][:c] = "c"
    assert_nil hash[:a][:c]
    assert_equal "c", dup[:a][:c]
  end

  def test_array_deep_dup_with_hash_inside
    array = [1, { a: 2, b: 3 } ]
    dup = array.deep_dup
    dup[1][:c] = 4
    assert_nil array[1][:c]
    assert_equal 4, dup[1][:c]
  end

  def test_hash_deep_dup_with_array_inside
    hash = { a: [1, 2] }
    dup = hash.deep_dup
    dup[:a][2] = "c"
    assert_nil hash[:a][2]
    assert_equal "c", dup[:a][2]
  end

  def test_deep_dup_initialize
    zero_hash = Hash.new 0
    hash = { a: zero_hash }
    dup = hash.deep_dup
    assert_equal 0, dup[:a][44]
  end

  def test_object_deep_dup
    object = Object.new
    dup = object.deep_dup
    dup.instance_variable_set(:@a, 1)
    assert_not object.instance_variable_defined?(:@a)
    assert dup.instance_variable_defined?(:@a)
  end

  def test_deep_dup_with_hash_class_key
    hash = { Integer => 1 }
    dup = hash.deep_dup
    assert_equal 1, dup.keys.length
  end

  def test_deep_dup_with_mutable_frozen_key
    key = { array: [] }.freeze
    hash = { key => :value }

    dup = hash.deep_dup
    dup.transform_keys { |k| k[:array] << :array_element }
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "bigdecimal"
require "active_support/core_ext/object/duplicable"
require "active_support/core_ext/numeric/time"

class DuplicableTest < ActiveSupport::TestCase
  RAISE_DUP = [method(:puts), method(:puts).unbind, Class.new.include(Singleton).instance]
  ALLOW_DUP = ["1", "symbol_from_string".to_sym, Object.new, /foo/, [], {}, Time.now, Class.new, Module.new, BigDecimal("4.56"), nil, false, true, 1, 2.3, Complex(1), Rational(1)]

  def test_duplicable
    rubinius_skip "* Method#dup is allowed at the moment on Rubinius\n" \
                  "* https://github.com/rubinius/rubinius/issues/3089"

    RAISE_DUP.each do |v|
      assert_not v.duplicable?, "#{ v.inspect } should not be duplicable"
      assert_raises(TypeError, v.class.name) { v.dup }
    end

    ALLOW_DUP.each do |v|
      assert v.duplicable?, "#{ v.class } should be duplicable"
      assert_nothing_raised { v.dup }
    end
  end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "json"
require_relative "../../json/encoding_test_cases"

# These test cases were added to test that we do not interfere with json gem's
# output when the AS encoder is loaded, primarily for problems reported in
# #20775. They need to be executed in isolation to reproduce the scenario
# correctly, because other test cases might have already loaded additional
# dependencies.

# The AS::JSON encoder requires the BigDecimal core_ext, which, unfortunately,
# changes the BigDecimal#to_s output, and consequently the JSON gem output. So
# we need to require this upfront to ensure we don't get a false failure, but
# ideally we should just fix the BigDecimal core_ext to not change to_s without
# arguments.
require "active_support/core_ext/big_decimal"

class JsonGemEncodingTest < ActiveSupport::TestCase
  include ActiveSupport::Testing::Isolation

  JSONTest::EncodingTestCases.constants.each_with_index do |name|
    JSONTest::EncodingTestCases.const_get(name).each_with_index do |(subject, _), i|
      test("#{name[0..-6]} #{i}") do
        assert_same_with_or_without_active_support(subject)
      end
    end
  end

  class CustomToJson
    def to_json(*)
      '"custom"'
    end
  end

  test "custom to_json" do
    assert_same_with_or_without_active_support(CustomToJson.new)
  end

  private
    def require_or_skip(file)
      require(file) || skip("'#{file}' was already loaded")
    end

    def assert_same_with_or_without_active_support(subject)
      begin
        expected = JSON.generate(subject, quirks_mode: true)
      rescue JSON::GeneratorError => e
        exception = e
      end

      require_or_skip "active_support/core_ext/object/json"

      if exception
        assert_raises_with_message JSON::GeneratorError, e.message do
          JSON.generate(subject, quirks_mode: true)
        end
      else
        assert_equal expected, JSON.generate(subject, quirks_mode: true)
      end
    end

    def assert_raises_with_message(exception_class, message, &block)
      err = assert_raises(exception_class) { block.call }
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/object/instance_variables"

class ObjectInstanceVariableTest < ActiveSupport::TestCase
  def setup
    @source, @dest = Object.new, Object.new
    @source.instance_variable_set(:@bar, "bar")
    @source.instance_variable_set(:@baz, "baz")
  end

  def test_instance_variable_names
    assert_equal %w(@bar @baz), @source.instance_variable_names.sort
  end

  def test_instance_values
    assert_equal({ "bar" => "bar", "baz" => "baz" }, @source.instance_values)
  end

  def test_instance_exec_passes_arguments_to_block
    assert_equal %w(hello goodbye), (+"hello").instance_exec("goodbye") { |v| [self, v] }
  end

  def test_instance_exec_with_frozen_obj
    assert_equal %w(olleh goodbye), "hello".instance_exec("goodbye") { |v| [reverse, v] }
  end

  def test_instance_exec_nested
    assert_equal %w(goodbye olleh bar), (+"hello").instance_exec("goodbye") { |arg|
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/object"

class ObjectTryTest < ActiveSupport::TestCase
  def setup
    @string = "Hello"
  end

  def test_nonexisting_method
    method = :undefined_method
    assert_not_respond_to @string, method
    assert_nil @string.try(method)
  end

  def test_nonexisting_method_with_arguments
    method = :undefined_method
    assert_not_respond_to @string, method
    assert_nil @string.try(method, "llo", "y")
  end

  def test_nonexisting_method_bang
    method = :undefined_method
    assert_not_respond_to @string, method
    assert_raise(NoMethodError) { @string.try!(method) }
  end

  def test_nonexisting_method_with_arguments_bang
    method = :undefined_method
    assert_not_respond_to @string, method
    assert_raise(NoMethodError) { @string.try!(method, "llo", "y") }
  end

  def test_valid_method
    assert_equal 5, @string.try(:size)
  end

  def test_argument_forwarding
    assert_equal "Hey", @string.try(:sub, "llo", "y")
  end

  def test_block_forwarding
    assert_equal "Hey", @string.try(:sub, "llo") { |match| "y" }
  end

  def test_nil_to_type
    assert_nil nil.try(:to_s)
    assert_nil nil.try(:to_i)
  end

  def test_false_try
    assert_equal "false", false.try(:to_s)
  end

  def test_try_only_block
    assert_equal @string.reverse, @string.try(&:reverse)
  end

  def test_try_only_block_bang
    assert_equal @string.reverse, @string.try!(&:reverse)
  end

  def test_try_only_block_nil
    ran = false
    nil.try { ran = true }
    assert_equal false, ran
  end

  def test_try_with_instance_eval_block
    assert_equal @string.reverse, @string.try { reverse }
  end

  def test_try_with_instance_eval_block_bang
    assert_equal @string.reverse, @string.try! { reverse }
  end

  def test_try_with_private_method_bang
    klass = Class.new do
      private
        def private_method
          "private method"
        end
    end

    assert_raise(NoMethodError) { klass.new.try!(:private_method) }
  end

  def test_try_with_private_method
    klass = Class.new do
      private
        def private_method
          "private method"
        end
    end

    assert_nil klass.new.try(:private_method)
  end

  class Decorator < SimpleDelegator
    def delegator_method
      "delegator method"
    end

    def reverse
      "overridden reverse"
    end

    private
      def private_delegator_method
        "private delegator method"
      end
  end

  def test_try_with_method_on_delegator
    assert_equal "delegator method", Decorator.new(@string).try(:delegator_method)
  end

  def test_try_with_method_on_delegator_target
    assert_equal 5, Decorator.new(@string).try(:size)
  end

  def test_try_with_overridden_method_on_delegator
    assert_equal "overridden reverse", Decorator.new(@string).try(:reverse)
  end

  def test_try_with_private_method_on_delegator
    assert_nil Decorator.new(@string).try(:private_delegator_method)
  end

  def test_try_with_private_method_on_delegator_bang
    assert_raise(NoMethodError) do
      Decorator.new(@string).try!(:private_delegator_method)
    end
  end

  def test_try_with_private_method_on_delegator_target
    klass = Class.new do
      private
        def private_method
          "private method"
        end
    end

    assert_nil Decorator.new(klass.new).try(:private_method)
  end

  def test_try_with_private_method_on_delegator_target_bang
    klass = Class.new do
      private
        def private_method
          "private method"
        end
    end

# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/anonymous"

class AnonymousTest < ActiveSupport::TestCase
  test "an anonymous class or module are anonymous" do
    assert_predicate Module.new, :anonymous?
    assert_predicate Class.new, :anonymous?
  end

  test "a named class or module are not anonymous" do
    assert_not_predicate Kernel, :anonymous?
    assert_not_predicate Object, :anonymous?
  end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/concerning"

class ModuleConcerningTest < ActiveSupport::TestCase
  def test_concerning_declares_a_concern_and_includes_it_immediately
    klass = Class.new { concerning(:Foo) { } }
    assert_includes klass.ancestors, klass::Foo, klass.ancestors.inspect

    klass = Class.new { concerning(:Foo, prepend: true) { } }
    assert_includes klass.ancestors, klass::Foo, klass.ancestors.inspect
  end

  def test_concerning_can_prepend_concern
    klass = Class.new do
      def hi; "self"; end

      concerning(:Foo, prepend: true) do
        def hi; "hello, #{super}"; end
      end
    end

    assert_equal "hello, self", klass.new.hi
  end
end

class ModuleConcernTest < ActiveSupport::TestCase
  def test_concern_creates_a_module_extended_with_active_support_concern
    klass = Class.new do
      concern :Baz do
        included { @foo = 1 }
        prepended { @foo = 2 }
        def should_be_public; end
      end
    end

    # Declares a concern but doesn't include it
    assert klass.const_defined?(:Baz, false)
    assert_not ModuleConcernTest.const_defined?(:Baz)
    assert_kind_of ActiveSupport::Concern, klass::Baz
    assert_not_includes klass.ancestors, klass::Baz, klass.ancestors.inspect

    # Public method visibility by default
    assert_includes klass::Baz.public_instance_methods.map(&:to_s), "should_be_public"

    # Calls included hook
    assert_equal 1, Class.new { include klass::Baz }.instance_variable_get("@foo")

    # Calls prepended hook
    assert_equal 2, Class.new { prepend klass::Baz }.instance_variable_get("@foo")
  end

  class Foo
    concerning :Bar do
      module ClassMethods
        def will_be_orphaned; end
      end

      const_set :ClassMethods, Module.new {
        def hacked_on; end
      }

      # Doesn't overwrite existing ClassMethods module.
      class_methods do
        def nicer_dsl; end
      end

      # Doesn't overwrite previous class_methods definitions.
      class_methods do
        def doesnt_clobber; end
      end
    end

    concerning :Baz, prepend: true do
      module ClassMethods
        def will_be_orphaned_also; end
      end

      const_set :ClassMethods, Module.new {
        def hacked_on_also; end
      }

      # Doesn't overwrite existing ClassMethods module.
      class_methods do
        def nicer_dsl_also; end
      end

      # Doesn't overwrite previous class_methods definitions.
      class_methods do
        def doesnt_clobber_also; end
      end
    end
  end

  def test_using_class_methods_blocks_instead_of_ClassMethods_module
    assert_not_respond_to Foo, :will_be_orphaned
    assert_respond_to Foo, :hacked_on
    assert_respond_to Foo, :nicer_dsl
    assert_respond_to Foo, :doesnt_clobber

    # Orphan in Foo::ClassMethods, not Bar::ClassMethods.
    assert Foo.const_defined?(:ClassMethods)
    assert Foo::ClassMethods.method_defined?(:will_be_orphaned)
  end

  def test_using_class_methods_blocks_instead_of_ClassMethods_module_prepend
    assert_not_respond_to Foo, :will_be_orphaned_also
    assert_respond_to Foo, :hacked_on_also
    assert_respond_to Foo, :nicer_dsl_also
    assert_respond_to Foo, :doesnt_clobber_also

    # Orphan in Foo::ClassMethods, not Bar::ClassMethods.
    assert Foo.const_defined?(:ClassMethods)
    assert Foo::ClassMethods.method_defined?(:will_be_orphaned_also)
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/attribute_accessors_per_thread"

class ModuleAttributeAccessorPerThreadTest < ActiveSupport::TestCase
  class MyClass
    thread_mattr_accessor :foo
    thread_mattr_accessor :bar,  instance_writer: false
    thread_mattr_reader   :shaq, instance_reader: false
    thread_mattr_accessor :camp, instance_accessor: false
  end

  class SubMyClass < MyClass
  end

  setup do
    @class = MyClass
    @subclass = SubMyClass
    @object = @class.new
  end

  def test_can_initialize_with_default_value
    Thread.new do
      @class.thread_mattr_accessor :baz, default: "default_value"

      assert_equal "default_value", @class.baz
    end.join

    assert_nil @class.baz
  end

  def test_should_use_mattr_default
    Thread.new do
      assert_nil @class.foo
      assert_nil @object.foo
    end.join
  end

  def test_should_set_mattr_value
    Thread.new do
      @class.foo = :test
      assert_equal :test, @class.foo

      @class.foo = :test2
      assert_equal :test2, @class.foo
    end.join
  end

  def test_should_not_create_instance_writer
    Thread.new do
      assert_respond_to @class, :foo
      assert_respond_to @class, :foo=
      assert_respond_to @object, :bar
      assert_not_respond_to @object, :bar=
    end.join
  end

  def test_should_not_create_instance_reader
    Thread.new do
      assert_respond_to @class, :shaq
      assert_not_respond_to @object, :shaq
    end.join
  end

  def test_should_not_create_instance_accessors
    Thread.new do
      assert_respond_to @class, :camp
      assert_not_respond_to @object, :camp
      assert_not_respond_to @object, :camp=
    end.join
  end

  def test_values_should_not_bleed_between_threads
    threads = []
    threads << Thread.new do
      @class.foo = "things"
      Thread.pass
      assert_equal "things", @class.foo
    end

    threads << Thread.new do
      @class.foo = "other things"
      Thread.pass
      assert_equal "other things", @class.foo
    end

    threads << Thread.new do
      @class.foo = "really other things"
      Thread.pass
      assert_equal "really other things", @class.foo
    end

    threads.each(&:join)
  end

  def test_should_raise_name_error_if_attribute_name_is_invalid
    exception = assert_raises NameError do
      Class.new do
        thread_cattr_reader "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        thread_cattr_writer "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        thread_mattr_reader "1valid_part"
      end
    end
    assert_equal "invalid attribute name: 1valid_part", exception.message

    exception = assert_raises NameError do
      Class.new do
        thread_mattr_writer "2valid_part"
      end
    end
    assert_equal "invalid attribute name: 2valid_part", exception.message
  end

  def test_should_return_same_value_by_class_or_instance_accessor
    @class.foo = "fries"

    assert_equal @class.foo, @object.foo
  end

  def test_should_not_affect_superclass_if_subclass_set_value
    @class.foo = "super"
    assert_equal "super", @class.foo
    assert_nil @subclass.foo

    @subclass.foo = "sub"
    assert_equal "super", @class.foo
    assert_equal "sub", @subclass.foo
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/aliasing"

module AttributeAliasing
  class Content
    attr_accessor :title, :Data

    def initialize
      @title, @Data = nil, nil
    end

    def title?
      !title.nil?
    end

    def Data?
      !self.Data.nil?
    end
  end

  class Email < Content
    alias_attribute :subject, :title
    alias_attribute :body, :Data
  end
end

class AttributeAliasingTest < ActiveSupport::TestCase
  def test_attribute_alias
    e = AttributeAliasing::Email.new

    assert_not_predicate e, :subject?

    e.title = "Upgrade computer"
    assert_equal "Upgrade computer", e.subject
    assert_predicate e, :subject?

    e.subject = "We got a long way to go"
    assert_equal "We got a long way to go", e.title
    assert_predicate e, :title?
  end

  def test_aliasing_to_uppercase_attributes
    # Although it's very un-Ruby, some people's AR-mapped tables have
    # upper-case attributes, and when people want to alias those names
    # to more sensible ones, everything goes *foof*.
    e = AttributeAliasing::Email.new

    assert_not_predicate e, :body?
    assert_not_predicate e, :Data?

    e.body = "No, really, this is not a joke."
    assert_equal "No, really, this is not a joke.", e.Data
    assert_predicate e, :Data?

    e.Data = "Uppercased methods are the suck"
    assert_equal "Uppercased methods are the suck", e.body
    assert_predicate e, :body?
  end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/attribute_accessors"

class ModuleAttributeAccessorTest < ActiveSupport::TestCase
  def setup
    m = @module = Module.new do
      mattr_accessor :foo
      mattr_accessor :bar, instance_writer: false
      mattr_reader   :shaq, instance_reader: false
      mattr_accessor :camp, instance_accessor: false

      cattr_accessor(:defa) { "default_accessor_value" }
      cattr_reader(:defr) { "default_reader_value" }
      cattr_writer(:defw) { "default_writer_value" }
      cattr_accessor(:deff) { false }
      cattr_accessor(:quux) { :quux }

      cattr_accessor :def_accessor, default: "default_accessor_value"
      cattr_reader :def_reader, default: "default_reader_value"
      cattr_writer :def_writer, default: "default_writer_value"
      cattr_accessor :def_false, default: false
      cattr_accessor(:def_priority, default: false) { :no_priority }
    end
    @class = Class.new
    @class.instance_eval { include m }
    @object = @class.new
  end

  def test_should_use_mattr_default
    assert_nil @module.foo
    assert_nil @object.foo
  end

  def test_mattr_default_keyword_arguments
    assert_equal "default_accessor_value", @module.def_accessor
    assert_equal "default_reader_value", @module.def_reader
    assert_equal "default_writer_value", @module.class_variable_get(:@@def_writer)
  end

  def test_mattr_can_default_to_false
    assert_equal false, @module.def_false
    assert_equal false, @module.deff
  end

  def test_mattr_default_priority
    assert_equal false, @module.def_priority
  end

  def test_should_set_mattr_value
    @module.foo = :test
    assert_equal :test, @object.foo

    @object.foo = :test2
    assert_equal :test2, @module.foo
  end

  def test_cattr_accessor_default_value
    assert_equal :quux, @module.quux
    assert_equal :quux, @object.quux
  end

  def test_should_not_create_instance_writer
    assert_respond_to @module, :foo
    assert_respond_to @module, :foo=
    assert_respond_to @object, :bar
    assert_not_respond_to @object, :bar=
  end

  def test_should_not_create_instance_reader
    assert_respond_to @module, :shaq
    assert_not_respond_to @object, :shaq
  end

  def test_should_not_create_instance_accessors
    assert_respond_to @module, :camp
    assert_not_respond_to @object, :camp
    assert_not_respond_to @object, :camp=
  end

  def test_should_raise_name_error_if_attribute_name_is_invalid
    exception = assert_raises NameError do
      Class.new do
        cattr_reader "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        cattr_writer "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        mattr_reader "valid_part\ninvalid_part"
      end
    end
    assert_equal "invalid attribute name: valid_part\ninvalid_part", exception.message

    exception = assert_raises NameError do
      Class.new do
        mattr_writer "valid_part\ninvalid_part"
      end
    end
    assert_equal "invalid attribute name: valid_part\ninvalid_part", exception.message
  end

  def test_should_use_default_value_if_block_passed
    assert_equal "default_accessor_value", @module.defa
    assert_equal "default_reader_value", @module.defr
    assert_equal "default_writer_value", @module.class_variable_get("@@defw")
  end

  def test_method_invocation_should_not_invoke_the_default_block
    count = 0

    @module.cattr_accessor(:defcount) { count += 1 }

    assert_equal 1, count
    assert_no_difference "count" do
      @module.defcount
    end
  end

  def test_declaring_multiple_attributes_at_once_invokes_the_block_multiple_times
    count = 0

    @module.cattr_accessor(:defn1, :defn2) { count += 1 }

    assert_equal 1, @module.defn1
    assert_equal 2, @module.defn2
  end

  def test_declaring_attributes_on_singleton_errors
    klass = Class.new

    ex = assert_raises TypeError do
      class << klass
        mattr_accessor :my_attr
      end
    end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/introspection"

module ParentA
  module B
    module C; end
    module FrozenC; end
    FrozenC.freeze
  end

  module FrozenB; end
  FrozenB.freeze
end

class IntrospectionTest < ActiveSupport::TestCase
  def test_module_parent_name
    assert_equal "ParentA", ParentA::B.module_parent_name
    assert_equal "ParentA::B", ParentA::B::C.module_parent_name
    assert_nil ParentA.module_parent_name
  end

  def test_module_parent_name_when_frozen
    assert_equal "ParentA", ParentA::FrozenB.module_parent_name
    assert_equal "ParentA::B", ParentA::B::FrozenC.module_parent_name
  end

  def test_module_parent
    assert_equal ParentA::B, ParentA::B::C.module_parent
    assert_equal ParentA, ParentA::B.module_parent
    assert_equal Object, ParentA.module_parent
  end

  def test_module_parents
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/attr_internal"

class AttrInternalTest < ActiveSupport::TestCase
  def setup
    @target = Class.new
    @instance = @target.new
  end

  def test_reader
    assert_nothing_raised { @target.attr_internal_reader :foo }

    assert_not @instance.instance_variable_defined?("@_foo")
    assert_raise(NoMethodError) { @instance.foo = 1 }

    @instance.instance_variable_set("@_foo", 1)
    assert_nothing_raised { assert_equal 1, @instance.foo }
  end

  def test_writer
    assert_nothing_raised { @target.attr_internal_writer :foo }

    assert_not @instance.instance_variable_defined?("@_foo")
    assert_nothing_raised { assert_equal 1, @instance.foo = 1 }

    assert_equal 1, @instance.instance_variable_get("@_foo")
    assert_raise(NoMethodError) { @instance.foo }
  end

  def test_accessor
    assert_nothing_raised { @target.attr_internal :foo }

    assert_not @instance.instance_variable_defined?("@_foo")
    assert_nothing_raised { assert_equal 1, @instance.foo = 1 }

    assert_equal 1, @instance.instance_variable_get("@_foo")
    assert_nothing_raised { assert_equal 1, @instance.foo }
  end

  def test_naming_format
    assert_equal "@_%s", Module.attr_internal_naming_format
    assert_nothing_raised { Module.attr_internal_naming_format = "@abc%sdef" }
    @target.attr_internal :foo

    assert_not @instance.instance_variable_defined?("@_foo")
    assert_not @instance.instance_variable_defined?("@abcfoodef")
    assert_nothing_raised { @instance.foo = 1 }
    assert_not @instance.instance_variable_defined?("@_foo")
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/module/remove_method"

module RemoveMethodTests
  class A
    def do_something
      1
    end

    def do_something_protected
      1
    end
    protected :do_something_protected

    def do_something_private
      1
    end
    private :do_something_private

    class << self
      def do_something_else
        2
      end
    end
  end
end

class RemoveMethodTest < ActiveSupport::TestCase
  def test_remove_method_from_an_object
    RemoveMethodTests::A.class_eval {
      remove_possible_method(:do_something)
    }
    assert_not_respond_to RemoveMethodTests::A.new, :do_something
  end

  def test_remove_singleton_method_from_an_object
    RemoveMethodTests::A.class_eval {
      remove_possible_singleton_method(:do_something_else)
    }
    assert_not_respond_to RemoveMethodTests::A, :do_something_else
  end

  def test_redefine_method_in_an_object
    RemoveMethodTests::A.class_eval {
      redefine_method(:do_something) { return 100 }
      redefine_method(:do_something_protected) { return 100 }
      redefine_method(:do_something_private) { return 100 }
    }
    assert_equal 100, RemoveMethodTests::A.new.do_something
    assert_equal 100, RemoveMethodTests::A.new.send(:do_something_protected)
    assert_equal 100, RemoveMethodTests::A.new.send(:do_something_private)

    assert RemoveMethodTests::A.public_method_defined? :do_something
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/inflector"
require "active_support/time"
require "active_support/json"
require_relative "../time_zone_test_helpers"
require "yaml"

class DurationTest < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def test_is_a
    d = 1.day
    assert d.is_a?(ActiveSupport::Duration)
    assert_kind_of ActiveSupport::Duration, d
    assert_kind_of Numeric, d
    assert_kind_of Integer, d
    assert_not d.is_a?(Hash)

    k = Class.new
    class << k; undef_method :== end
    assert_not d.is_a?(k)
  end

  def test_instance_of
    assert 1.minute.instance_of?(Integer)
    assert 2.days.instance_of?(ActiveSupport::Duration)
    assert_not 3.second.instance_of?(Numeric)
  end

  def test_threequals
    assert ActiveSupport::Duration === 1.day
    assert_not (ActiveSupport::Duration === 1.day.to_i)
    assert_not (ActiveSupport::Duration === "foo")
  end

  def test_equals
    assert 1.day == 1.day
    assert 1.day == 1.day.to_i
    assert 1.day.to_i == 1.day
    assert_not (1.day == "foo")
  end

  def test_to_s
    assert_equal "1", 1.second.to_s
  end

  def test_in_seconds
    assert_equal 86400.0, 1.day.in_seconds
    assert_equal 1.week.to_i, 1.week.in_seconds
  end

  def test_in_minutes
    assert_in_delta 1440.0, 1.day.in_minutes
    assert_in_delta 0.5, 30.seconds.in_minutes
  end

  def test_in_hours
    assert_in_delta 24.0, 1.day.in_hours
    assert_in_delta 336.0, 2.weeks.in_hours
  end

  def test_in_days
    assert_in_delta 0.5, 12.hours.in_days
    assert_in_delta 30.437, 1.month.in_days
  end

  def test_in_weeks
    assert_in_delta 8.696, 2.months.in_weeks
    assert_in_delta 52.178, 1.year.in_weeks
  end

  def test_in_months
    assert_in_delta 2.07, 9.weeks.in_months
    assert_in_delta 12.0, 1.year.in_months
  end

  def test_in_years
    assert_in_delta 0.082, 30.days.in_years
    assert_in_delta 1.0, 365.days.in_years
  end

  def test_eql
    rubinius_skip "Rubinius' #eql? definition relies on #instance_of? " \
                  "which behaves oddly for the sake of backward-compatibility."

    assert 1.minute.eql?(1.minute)
    assert 1.minute.eql?(60.seconds)
    assert 2.days.eql?(48.hours)
    assert_not 1.second.eql?(1)
    assert_not 1.eql?(1.second)
    assert 1.minute.eql?(180.seconds - 2.minutes)
    assert_not 1.minute.eql?(60)
    assert_not 1.minute.eql?("foo")
  end

  def test_inspect
    assert_equal "0 seconds",                       0.seconds.inspect
    assert_equal "0 days",                          0.days.inspect
    assert_equal "1 month",                         1.month.inspect
    assert_equal "1 month and 1 day",               (1.month + 1.day).inspect
    assert_equal "6 months and -2 days",            (6.months - 2.days).inspect
    assert_equal "10 seconds",                      10.seconds.inspect
    assert_equal "10 years, 2 months, and 1 day",   (10.years + 2.months + 1.day).inspect
    assert_equal "10 years, 2 months, and 1 day",   (10.years + 1.month  + 1.day + 1.month).inspect
    assert_equal "10 years, 2 months, and 1 day",   (1.day + 10.years + 2.months).inspect
    assert_equal "7 days",                          7.days.inspect
    assert_equal "1 week",                          1.week.inspect
    assert_equal "2 weeks",                         1.fortnight.inspect
    assert_equal "0 seconds",                       (10 % 5.seconds).inspect
    assert_equal "10 minutes",                      (10.minutes + 0.seconds).inspect
    assert_equal "3600 seconds",                    (1.day / 24).inspect
  end

  def test_inspect_locale
    current_locale = I18n.default_locale
    I18n.default_locale = :de
    I18n.backend.store_translations(:de, support: { array: { last_word_connector: " und " } })
    assert_equal "10 years, 1 month und 1 day", (10.years + 1.month + 1.day).inspect
  ensure
    I18n.default_locale = current_locale
  end

  def test_minus_with_duration_does_not_break_subtraction_of_date_from_date
    assert_nothing_raised { Date.today - Date.today }
  end

  def test_unary_plus
    assert_equal (+ 1.second), 1.second
    assert_instance_of ActiveSupport::Duration, + 1.second
  end

  def test_plus
    assert_equal 2.seconds, 1.second + 1.second
    assert_instance_of ActiveSupport::Duration, 1.second + 1.second
    assert_equal 2.seconds, 1.second + 1
    assert_instance_of ActiveSupport::Duration, 1.second + 1
  end

  def test_minus
    assert_equal 1.second, 2.seconds - 1.second
    assert_instance_of ActiveSupport::Duration, 2.seconds - 1.second
    assert_equal 1.second, 2.seconds - 1
    assert_instance_of ActiveSupport::Duration, 2.seconds - 1
    assert_equal 1.second, 2 - 1.second
    assert_instance_of ActiveSupport::Duration, 2.seconds - 1
  end

  def test_multiply
    assert_equal 7.days, 1.day * 7
    assert_instance_of ActiveSupport::Duration, 1.day * 7
    assert_equal 86400, 1.day * 1.second
  end

  def test_divide
    assert_equal 1.day, 7.days / 7
    assert_instance_of ActiveSupport::Duration, 7.days / 7

    assert_equal 1.hour, 1.day / 24
    assert_instance_of ActiveSupport::Duration, 1.day / 24

    assert_equal 24, 86400 / 1.hour
    assert_kind_of Integer, 86400 / 1.hour

    assert_equal 24, 1.day / 1.hour
    assert_kind_of Integer, 1.day / 1.hour

    assert_equal 1, 1.day / 1.day
    assert_kind_of Integer, 1.day / 1.hour
  end

  def test_modulo
    assert_equal 1.minute, 5.minutes % 120
    assert_instance_of ActiveSupport::Duration, 5.minutes % 120

    assert_equal 1.minute, 5.minutes % 2.minutes
    assert_instance_of ActiveSupport::Duration, 5.minutes % 2.minutes

    assert_equal 1.minute, 5.minutes % 120.seconds
    assert_instance_of ActiveSupport::Duration, 5.minutes % 120.seconds

    assert_equal 5.minutes, 5.minutes % 1.hour
    assert_instance_of ActiveSupport::Duration, 5.minutes % 1.hour

    assert_equal 1.day, 36.days % 604800
    assert_instance_of ActiveSupport::Duration, 36.days % 604800

    assert_equal 1.day, 36.days % 7.days
    assert_instance_of ActiveSupport::Duration, 36.days % 7.days

    assert_equal 800.seconds, 8000 % 1.hour
    assert_instance_of ActiveSupport::Duration, 8000 % 1.hour

    assert_equal 1.month, 13.months % 1.year
    assert_instance_of ActiveSupport::Duration, 13.months % 1.year
  end

  def test_date_added_with_zero_days
    assert_equal Date.civil(2017, 1, 1), Date.civil(2017, 1, 1) + 0.days
    assert_instance_of Date, Date.civil(2017, 1, 1) + 0.days
  end

  def test_date_added_with_multiplied_duration
    assert_equal Date.civil(2017, 1, 3), Date.civil(2017, 1, 1) + 1.day * 2
    assert_instance_of Date, Date.civil(2017, 1, 1) + 1.day * 2
  end

  def test_date_added_with_multiplied_duration_larger_than_one_month
    assert_equal Date.civil(2017, 2, 15), Date.civil(2017, 1, 1) + 1.day * 45
    assert_instance_of Date, Date.civil(2017, 1, 1) + 1.day * 45
  end

  def test_date_added_with_divided_duration
    assert_equal Date.civil(2017, 1, 3), Date.civil(2017, 1, 1) + 4.days / 2
    assert_instance_of Date, Date.civil(2017, 1, 1) + 4.days / 2
  end

  def test_date_added_with_divided_duration_larger_than_one_month
    assert_equal Date.civil(2017, 2, 15), Date.civil(2017, 1, 1) + 90.days / 2
    assert_instance_of Date, Date.civil(2017, 1, 1) + 90.days / 2
  end

  def test_plus_with_time
    assert_equal 1 + 1.second, 1.second + 1, "Duration + Numeric should == Numeric + Duration"
  end

  def test_time_plus_duration_returns_same_time_datatype
    twz = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Moscow"], Time.utc(2016, 4, 28, 00, 45))
    now = Time.now.utc
    %w( second minute hour day week month year ).each do |unit|
      assert_equal((now + 1.public_send(unit)).class, Time, "Time + 1.#{unit} must be Time")
      assert_equal((twz + 1.public_send(unit)).class, ActiveSupport::TimeWithZone, "TimeWithZone + 1.#{unit} must be TimeWithZone")
    end
  end

  def test_argument_error
    e = assert_raise ArgumentError do
      1.second.ago("")
    end
    assert_equal 'expected a time or date, got ""', e.message, "ensure ArgumentError is not being raised by dependencies.rb"
  end

  def test_fractional_weeks
    assert_equal((86400 * 7) * 1.5, 1.5.weeks)
    assert_equal((86400 * 7) * 1.7, 1.7.weeks)
  end

  def test_fractional_days
    assert_equal 86400 * 1.5, 1.5.days
    assert_equal 86400 * 1.7, 1.7.days
  end

  def test_since_and_ago
    t = Time.local(2000)
    assert_equal t + 1, 1.second.since(t)
    assert_equal t + 1, (1.minute / 60).since(t)
    assert_equal t - 1, 1.second.ago(t)
    assert_equal t - 1, (1.minute / 60).ago(t)
  end

  def test_since_and_ago_without_argument
    now = Time.now
    assert 1.second.since >= now + 1
    now = Time.now
    assert 1.second.ago >= now - 1
  end

  def test_since_and_ago_with_fractional_days
    t = Time.local(2000)
    # since
    assert_equal 36.hours.since(t), 1.5.days.since(t)
    assert_in_delta((24 * 1.7).hours.since(t), 1.7.days.since(t), 1)
    # ago
    assert_equal 36.hours.ago(t), 1.5.days.ago(t)
    assert_in_delta((24 * 1.7).hours.ago(t), 1.7.days.ago(t), 1)
  end

  def test_since_and_ago_with_fractional_weeks
    t = Time.local(2000)
    # since
    assert_equal((7 * 36).hours.since(t), 1.5.weeks.since(t))
    assert_in_delta((7 * 24 * 1.7).hours.since(t), 1.7.weeks.since(t), 1)
    # ago
    assert_equal((7 * 36).hours.ago(t), 1.5.weeks.ago(t))
    assert_in_delta((7 * 24 * 1.7).hours.ago(t), 1.7.weeks.ago(t), 1)
  end

  def test_since_and_ago_anchored_to_time_now_when_time_zone_is_not_set
    Time.zone = nil
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2000)) do
        # since
        assert_not_instance_of ActiveSupport::TimeWithZone, 5.seconds.since
        assert_equal Time.local(2000, 1, 1, 0, 0, 5), 5.seconds.since
        # ago
        assert_not_instance_of ActiveSupport::TimeWithZone, 5.seconds.ago
        assert_equal Time.local(1999, 12, 31, 23, 59, 55), 5.seconds.ago
      end
    end
  end

  def test_since_and_ago_anchored_to_time_zone_now_when_time_zone_is_set
    Time.zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    with_env_tz "US/Eastern" do
      Time.stub(:now, Time.local(2000)) do
        # since
        assert_instance_of ActiveSupport::TimeWithZone, 5.seconds.since
        assert_equal Time.utc(2000, 1, 1, 0, 0, 5), 5.seconds.since.time
        assert_equal "Eastern Time (US & Canada)", 5.seconds.since.time_zone.name
        # ago
        assert_instance_of ActiveSupport::TimeWithZone, 5.seconds.ago
        assert_equal Time.utc(1999, 12, 31, 23, 59, 55), 5.seconds.ago.time
        assert_equal "Eastern Time (US & Canada)", 5.seconds.ago.time_zone.name
      end
    end
  ensure
    Time.zone = nil
  end

  def test_before_and_afer
    t = Time.local(2000)
    assert_equal t + 1, 1.second.after(t)
    assert_equal t - 1, 1.second.before(t)
  end

  def test_before_and_after_without_argument
    Time.stub(:now, Time.local(2000)) do
      assert_equal Time.now - 1.second, 1.second.before
      assert_equal Time.now + 1.second, 1.second.after
    end
  end

  def test_adding_hours_across_dst_boundary
    with_env_tz "CET" do
      assert_equal Time.local(2009, 3, 29, 0, 0, 0) + 24.hours, Time.local(2009, 3, 30, 1, 0, 0)
    end
  end

  def test_adding_day_across_dst_boundary
    with_env_tz "CET" do
      assert_equal Time.local(2009, 3, 29, 0, 0, 0) + 1.day, Time.local(2009, 3, 30, 0, 0, 0)
    end
  end

  def test_delegation_with_block_works
    counter = 0
    assert_nothing_raised do
      1.minute.times { counter += 1 }
    end
    assert_equal 60, counter
  end

  def test_as_json
    assert_equal 172800, 2.days.as_json
  end

  def test_to_json
    assert_equal "172800", 2.days.to_json
  end

  def test_case_when
    cased = \
      case 1.day
      when 1.day
        "ok"
      end
    assert_equal "ok", cased
  end

  def test_respond_to
    assert_respond_to 1.day, :since
    assert_respond_to 1.day, :zero?
  end

  def test_hash
    assert_equal 1.minute.hash, 60.seconds.hash
  end

  def test_comparable
    assert_equal(-1, (0.seconds <=> 1.second))
    assert_equal(-1, (1.second <=> 1.minute))
    assert_equal(-1, (1 <=> 1.minute))
    assert_equal(0, (0.seconds <=> 0.seconds))
    assert_equal(0, (0.seconds <=> 0.minutes))
    assert_equal(0, (1.second <=> 1.second))
    assert_equal(1, (1.second <=> 0.second))
    assert_equal(1, (1.minute <=> 1.second))
    assert_equal(1, (61 <=> 1.minute))
  end

  def test_implicit_coercion
    assert_equal 2.days, 2 * 1.day
    assert_instance_of ActiveSupport::Duration, 2 * 1.day
    assert_equal Time.utc(2017, 1, 3), Time.utc(2017, 1, 1) + 2 * 1.day
    assert_equal Date.civil(2017, 1, 3), Date.civil(2017, 1, 1) + 2 * 1.day
  end

  def test_scalar_coerce
    scalar = ActiveSupport::Duration::Scalar.new(10)
    assert_instance_of ActiveSupport::Duration::Scalar, 10 + scalar
    assert_instance_of ActiveSupport::Duration, 10.seconds + scalar
  end

  def test_scalar_delegations
    scalar = ActiveSupport::Duration::Scalar.new(10)
    assert_kind_of Float, scalar.to_f
    assert_kind_of Integer, scalar.to_i
    assert_kind_of String, scalar.to_s
  end

  def test_scalar_unary_minus
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal(-10, -scalar)
    assert_instance_of ActiveSupport::Duration::Scalar, -scalar
  end

  def test_scalar_compare
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal(1, scalar <=> 5)
    assert_equal(0, scalar <=> 10)
    assert_equal(-1, scalar <=> 15)
    assert_nil(scalar <=> "foo")
  end

  def test_scalar_plus
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal 20, 10 + scalar
    assert_instance_of ActiveSupport::Duration::Scalar, 10 + scalar
    assert_equal 20, scalar + 10
    assert_instance_of ActiveSupport::Duration::Scalar, scalar + 10
    assert_equal 20, 10.seconds + scalar
    assert_instance_of ActiveSupport::Duration, 10.seconds + scalar
    assert_equal 20, scalar + 10.seconds
    assert_instance_of ActiveSupport::Duration, scalar + 10.seconds

    exception = assert_raises(TypeError) do
      scalar + "foo"
    end

    assert_equal "no implicit conversion of String into ActiveSupport::Duration::Scalar", exception.message
  end

  def test_scalar_plus_parts
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal({ days: 1, seconds: 10 }, (scalar + 1.day).parts)
    assert_equal({ days: -1, seconds: 10 }, (scalar + -1.day).parts)
  end

  def test_scalar_minus
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal 10, 20 - scalar
    assert_instance_of ActiveSupport::Duration::Scalar, 20 - scalar
    assert_equal 5, scalar - 5
    assert_instance_of ActiveSupport::Duration::Scalar, scalar - 5
    assert_equal 10, 20.seconds - scalar
    assert_instance_of ActiveSupport::Duration, 20.seconds - scalar
    assert_equal 5, scalar - 5.seconds
    assert_instance_of ActiveSupport::Duration, scalar - 5.seconds

    assert_equal({ days: -1, seconds: 10 }, (scalar - 1.day).parts)
    assert_equal({ days: 1, seconds: 10 }, (scalar - -1.day).parts)

    exception = assert_raises(TypeError) do
      scalar - "foo"
    end

    assert_equal "no implicit conversion of String into ActiveSupport::Duration::Scalar", exception.message
  end

  def test_scalar_minus_parts
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal({ days: -1, seconds: 10 }, (scalar - 1.day).parts)
    assert_equal({ days: 1, seconds: 10 }, (scalar - -1.day).parts)
  end

  def test_scalar_multiply
    scalar = ActiveSupport::Duration::Scalar.new(5)

    assert_equal 10, 2 * scalar
    assert_instance_of ActiveSupport::Duration::Scalar, 2 * scalar
    assert_equal 10, scalar * 2
    assert_instance_of ActiveSupport::Duration::Scalar, scalar * 2
    assert_equal 10, 2.seconds * scalar
    assert_instance_of ActiveSupport::Duration, 2.seconds * scalar
    assert_equal 10, scalar * 2.seconds
    assert_instance_of ActiveSupport::Duration, scalar * 2.seconds

    exception = assert_raises(TypeError) do
      scalar * "foo"
    end

    assert_equal "no implicit conversion of String into ActiveSupport::Duration::Scalar", exception.message
  end

  def test_scalar_multiply_parts
    scalar = ActiveSupport::Duration::Scalar.new(1)
    assert_equal({ days: 2 }, (scalar * 2.days).parts)
    assert_equal(172800, (scalar * 2.days).value)
    assert_equal({ days: -2 }, (scalar * -2.days).parts)
    assert_equal(-172800, (scalar * -2.days).value)
  end

  def test_scalar_divide
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal 10, 100 / scalar
    assert_instance_of ActiveSupport::Duration::Scalar, 100 / scalar
    assert_equal 5, scalar / 2
    assert_instance_of ActiveSupport::Duration::Scalar, scalar / 2
    assert_equal 10, 100.seconds / scalar
    assert_instance_of ActiveSupport::Duration, 100.seconds / scalar
    assert_equal 5, scalar / 2.seconds
    assert_kind_of Integer, scalar / 2.seconds

    exception = assert_raises(TypeError) do
      scalar / "foo"
    end

    assert_equal "no implicit conversion of String into ActiveSupport::Duration::Scalar", exception.message
  end

  def test_scalar_modulo
    scalar = ActiveSupport::Duration::Scalar.new(10)

    assert_equal 1, 31 % scalar
    assert_instance_of ActiveSupport::Duration::Scalar, 31 % scalar
    assert_equal 1, scalar % 3
    assert_instance_of ActiveSupport::Duration::Scalar, scalar % 3
    assert_equal 1, 31.seconds % scalar
    assert_instance_of ActiveSupport::Duration, 31.seconds % scalar
    assert_equal 1, scalar % 3.seconds
    assert_instance_of ActiveSupport::Duration, scalar % 3.seconds

    exception = assert_raises(TypeError) do
      scalar % "foo"
    end

    assert_equal "no implicit conversion of String into ActiveSupport::Duration::Scalar", exception.message
  end

  def test_scalar_modulo_parts
    scalar = ActiveSupport::Duration::Scalar.new(82800)
    assert_equal({ hours: 1 }, (scalar % 2.hours).parts)
    assert_equal(3600, (scalar % 2.hours).value)
  end

  def test_twelve_months_equals_one_year
    assert_equal 12.months, 1.year
  end

  def test_thirty_days_does_not_equal_one_month
    assert_not_equal 30.days, 1.month
  end

  def test_adding_one_month_maintains_day_of_month
    (1..11).each do |month|
      [1, 14, 28].each do |day|
        assert_equal Date.civil(2016, month + 1, day), Date.civil(2016, month, day) + 1.month
      end
    end

    assert_equal Date.civil(2017, 1, 1),  Date.civil(2016, 12, 1) + 1.month
    assert_equal Date.civil(2017, 1, 14),  Date.civil(2016, 12, 14) + 1.month
    assert_equal Date.civil(2017, 1, 28),  Date.civil(2016, 12, 28) + 1.month

    assert_equal Date.civil(2015, 2, 28), Date.civil(2015, 1, 31) + 1.month
    assert_equal Date.civil(2016, 2, 29), Date.civil(2016, 1, 31) + 1.month
  end

  # ISO8601 string examples are taken from ISO8601 gem at https://github.com/arnau/ISO8601/blob/b93d466840/spec/iso8601/duration_spec.rb
  # published under the conditions of MIT license at https://github.com/arnau/ISO8601/blob/b93d466840/LICENSE
  #
  # Copyright (c) 2012-2014 Arnau Siches
  #
  # MIT License
  #
  # Permission is hereby granted, free of charge, to any person obtaining
  # a copy of this software and associated documentation files (the
  # "Software"), to deal in the Software without restriction, including
  # without limitation the rights to use, copy, modify, merge, publish,
  # distribute, sublicense, and/or sell copies of the Software, and to
  # permit persons to whom the Software is furnished to do so, subject to
  # the following conditions:
  #
  # The above copyright notice and this permission notice shall be
  # included in all copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  # EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  def test_iso8601_parsing_wrong_patterns_with_raise
    invalid_patterns = ["", "P", "PT", "P1YT", "T", "PW", "P1Y1W", "~P1Y", ".P1Y", "P1.5Y0.5M", "P1.5Y1M", "P1.5MT10.5S"]
    invalid_patterns.each do |pattern|
      assert_raise ActiveSupport::Duration::ISO8601Parser::ParsingError, pattern.inspect do
        ActiveSupport::Duration.parse(pattern)
      end
    end
  end

  def test_iso8601_output
    expectations = [
      ["P1Y",           1.year                           ],
      ["P1W",           1.week                           ],
      ["P4W",           4.week                           ],
      ["P1Y7D",         1.year + 1.week                  ],
      ["P1Y1M21D",      1.year + 1.month + 3.week        ],
      ["P1Y1M",         1.year + 1.month                 ],
      ["P1Y1M1D",       1.year + 1.month + 1.day         ],
      ["P-1Y-1D",       -1.year - 1.day                  ],
      ["P1Y-1DT-1S",    1.year - 1.day - 1.second        ], # Parts with different signs are exists in PostgreSQL interval datatype.
      ["PT1S",          1.second                         ],
      ["PT1.4S",        (1.4).seconds                    ],
      ["P1Y1M1DT1H",    1.year + 1.month + 1.day + 1.hour],
      ["PT0S",          0.minutes                        ],
      ["PT-0.2S",       (-0.2).seconds                   ],
    ]
    expectations.each do |expected_output, duration|
      assert_equal expected_output, duration.iso8601, expected_output.inspect
    end
  end

  def test_iso8601_output_precision
    expectations = [
        [nil, "P1Y1MT8.55S",  1.year + 1.month + (8.55).seconds ],
        [0,   "P1Y1MT9S",     1.year + 1.month + (8.55).seconds ],
        [1,   "P1Y1MT8.6S",   1.year + 1.month + (8.55).seconds ],
        [2,   "P1Y1MT8.55S",  1.year + 1.month + (8.55).seconds ],
        [3,   "P1Y1MT8.550S", 1.year + 1.month + (8.55).seconds ],
        [nil, "PT1S",         1.second                          ],
        [2,   "PT1.00S",      1.second                          ],
        [nil, "PT1.4S",       (1.4).seconds                     ],
        [0,   "PT1S",         (1.4).seconds                     ],
        [1,   "PT1.4S",       (1.4).seconds                     ],
        [5,   "PT1.40000S",   (1.4).seconds                     ],
    ]
    expectations.each do |precision, expected_output, duration|
      assert_equal expected_output, duration.iso8601(precision: precision), expected_output.inspect
    end
  end

  def test_iso8601_output_and_reparsing
    patterns = %w[
      P1Y P0.5Y P0,5Y P1Y1M P1Y0.5M P1Y0,5M P1Y1M1D P1Y1M0.5D P1Y1M0,5D P1Y1M1DT1H P1Y1M1DT0.5H P1Y1M1DT0,5H P1W +P1Y -P1Y P-1Y
      P1Y1M1DT1H1M P1Y1M1DT1H0.5M P1Y1M1DT1H0,5M P1Y1M1DT1H1M1S P1Y1M1DT1H1M1.0S P1Y1M1DT1H1M1,0S P-1Y-2M3DT-4H-5M-6S
    ]
    # That could be weird, but if we parse P1Y1M0.5D and output it to ISO 8601, we'll get P1Y1MT12.0H.
    # So we check that initially parsed and reparsed duration added to time will result in the same time.
    time = Time.current
    patterns.each do |pattern|
      duration = ActiveSupport::Duration.parse(pattern)
      assert_equal time + duration, time + ActiveSupport::Duration.parse(duration.iso8601), pattern.inspect
    end
  end

  def test_iso8601_parsing_across_spring_dst_boundary
    with_env_tz eastern_time_zone do
      with_tz_default "Eastern Time (US & Canada)" do
        travel_to Time.utc(2016, 3, 11) do
          assert_equal 604800, ActiveSupport::Duration.parse("P7D").to_i
          assert_equal 604800, ActiveSupport::Duration.parse("P1W").to_i
        end
      end
    end
  end

  def test_iso8601_parsing_across_autumn_dst_boundary
    with_env_tz eastern_time_zone do
      with_tz_default "Eastern Time (US & Canada)" do
        travel_to Time.utc(2016, 11, 4) do
          assert_equal 604800, ActiveSupport::Duration.parse("P7D").to_i
          assert_equal 604800, ActiveSupport::Duration.parse("P1W").to_i
        end
      end
    end
  end

  def test_iso8601_parsing_equivalence_with_numeric_extensions_over_long_periods
    with_env_tz eastern_time_zone do
      with_tz_default "Eastern Time (US & Canada)" do
        assert_equal 3.months, ActiveSupport::Duration.parse("P3M")
        assert_equal 3.months.to_i, ActiveSupport::Duration.parse("P3M").to_i
        assert_equal 10.months, ActiveSupport::Duration.parse("P10M")
        assert_equal 10.months.to_i, ActiveSupport::Duration.parse("P10M").to_i
        assert_equal 3.years, ActiveSupport::Duration.parse("P3Y")
        assert_equal 3.years.to_i, ActiveSupport::Duration.parse("P3Y").to_i
        assert_equal 10.years, ActiveSupport::Duration.parse("P10Y")
        assert_equal 10.years.to_i, ActiveSupport::Duration.parse("P10Y").to_i
      end
    end
  end

  def test_adding_durations_do_not_hold_prior_states
    time = Time.parse("Nov 29, 2016")
    # If the implementation adds and subtracts 3 months, the
    # resulting date would have been in February so the day will
    # change to the 29th.
    d1 = 3.months - 3.months
    d2 = 2.months - 2.months

    assert_equal time + d1, time + d2
  end

  def test_durations_survive_yaml_serialization
    d1 = YAML.load(YAML.dump(10.minutes))
    assert_equal 600, d1.to_i
    assert_equal 660, (d1 + 60).to_i
  end

  def test_string_build_raises_error
    error = assert_raises(TypeError) do
      ActiveSupport::Duration.build("9")
    end

    assert_equal "can't build an ActiveSupport::Duration from a String", error.message
  end

  def test_non_numeric_build_raises_error
    error = assert_raises(TypeError) do
      ActiveSupport::Duration.build(nil)
    end

    assert_equal "can't build an ActiveSupport::Duration from a NilClass", error.message
  end

  private
    def eastern_time_zone
      if Gem.win_platform?
        "EST5EDT"
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/class/attribute"

class ClassAttributeTest < ActiveSupport::TestCase
  def setup
    @klass = Class.new do
      class_attribute :setting
      class_attribute :timeout, default: 5
    end

    @sub = Class.new(@klass)
  end

  test "defaults to nil" do
    assert_nil @klass.setting
    assert_nil @sub.setting
  end

  test "custom default" do
    assert_equal 5, @klass.timeout
  end

  test "inheritable" do
    @klass.setting = 1
    assert_equal 1, @sub.setting
  end

  test "overridable" do
    @sub.setting = 1
    assert_nil @klass.setting

    @klass.setting = 2
    assert_equal 1, @sub.setting

    assert_equal 1, Class.new(@sub).setting
  end

  test "predicate method" do
    assert_equal false, @klass.setting?
    @klass.setting = 1
    assert_equal true, @klass.setting?
  end

  test "instance reader delegates to class" do
    assert_nil @klass.new.setting

    @klass.setting = 1
    assert_equal 1, @klass.new.setting
  end

  test "instance override" do
    object = @klass.new
    object.setting = 1
    assert_nil @klass.setting
    @klass.setting = 2
    assert_equal 1, object.setting
  end

  test "instance predicate" do
    object = @klass.new
    assert_equal false, object.setting?
    object.setting = 1
    assert_equal true, object.setting?
  end

  test "disabling instance writer" do
    object = Class.new { class_attribute :setting, instance_writer: false }.new
    assert_raise(NoMethodError) { object.setting = "boom" }
    assert_not_respond_to object, :setting=
  end

  test "disabling instance reader" do
    object = Class.new { class_attribute :setting, instance_reader: false }.new
    assert_raise(NoMethodError) { object.setting }
    assert_not_respond_to object, :setting
    assert_raise(NoMethodError) { object.setting? }
    assert_not_respond_to object, :setting?
  end

  test "disabling both instance writer and reader" do
    object = Class.new { class_attribute :setting, instance_accessor: false }.new
    assert_raise(NoMethodError) { object.setting }
    assert_not_respond_to object, :setting
    assert_raise(NoMethodError) { object.setting? }
    assert_not_respond_to object, :setting?
    assert_raise(NoMethodError) { object.setting = "boom" }
    assert_not_respond_to object, :setting=
  end

  test "disabling instance predicate" do
    object = Class.new { class_attribute :setting, instance_predicate: false }.new
    assert_raise(NoMethodError) { object.setting? }
    assert_not_respond_to object, :setting?
  end

  test "works well with singleton classes" do
    object = @klass.new
    object.singleton_class.setting = "foo"
    assert_equal "foo", object.setting
  end

  test "works well with module singleton classes" do
    @module = Module.new do
      class << self
        class_attribute :settings, default: 42
      end
    end

    assert_equal 42, @module.settings
  end

  test "setter returns set value" do
    val = @klass.public_send(:setting=, 1)
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/array"
require "active_support/core_ext/enumerable"

Payment = Struct.new(:price)
ExpandedPayment = Struct.new(:dollars, :cents)

class SummablePayment < Payment
  def +(p) self.class.new(price + p.price) end
end

class EnumerableTests < ActiveSupport::TestCase
  class GenericEnumerable
    include Enumerable

    def initialize(values = [1, 2, 3])
      @values = values
    end

    def each
      @values.each { |v| yield v }
    end
  end

  def assert_typed_equal(e, v, cls, msg = nil)
    assert_kind_of(cls, v, msg)
    assert_equal(e, v, msg)
  end

  def test_minimum
    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10) ])
    assert_equal 5, payments.minimum(:price)
  end

  def test_minimum_with_empty_enumerable
    payments = GenericEnumerable.new([])
    assert_nil payments.minimum(:price)
  end

  def test_maximum
    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10) ])
    assert_equal 15, payments.maximum(:price)
  end

  def test_maximum_with_empty_enumerable
    payments = GenericEnumerable.new([])
    assert_nil payments.maximum(:price)
  end

  def test_sums
    enum = GenericEnumerable.new([5, 15, 10])
    assert_equal 30, enum.sum
    assert_equal 60, enum.sum { |i| i * 2 }

    enum = GenericEnumerable.new(%w(a b c))
    assert_equal "abc", enum.sum
    assert_equal "aabbcc", enum.sum { |i| i * 2 }

    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10) ])
    assert_equal 30, payments.sum(&:price)
    assert_equal 60, payments.sum { |p| p.price * 2 }

    payments = GenericEnumerable.new([ SummablePayment.new(5), SummablePayment.new(15) ])
    assert_equal SummablePayment.new(20), payments.sum
    assert_equal SummablePayment.new(20), payments.sum { |p| p }

    sum = GenericEnumerable.new([3, 5.quo(1)]).sum
    assert_typed_equal(8, sum, Rational)

    sum = GenericEnumerable.new([3, 5.quo(1)]).sum(0.0)
    assert_typed_equal(8.0, sum, Float)

    sum = GenericEnumerable.new([3, 5.quo(1), 7.0]).sum
    assert_typed_equal(15.0, sum, Float)

    sum = GenericEnumerable.new([3, 5.quo(1), Complex(7)]).sum
    assert_typed_equal(Complex(15), sum, Complex)
    assert_typed_equal(15, sum.real, Rational)
    assert_typed_equal(0, sum.imag, Integer)

    sum = GenericEnumerable.new([3.5, 5]).sum
    assert_typed_equal(8.5, sum, Float)

    sum = GenericEnumerable.new([2, 8.5]).sum
    assert_typed_equal(10.5, sum, Float)

    sum = GenericEnumerable.new([1.quo(2), 1]).sum
    assert_typed_equal(3.quo(2), sum, Rational)

    sum = GenericEnumerable.new([1.quo(2), 1.quo(3)]).sum
    assert_typed_equal(5.quo(6), sum, Rational)

    sum = GenericEnumerable.new([2.0, 3.0 * Complex::I]).sum
    assert_typed_equal(Complex(2.0, 3.0), sum, Complex)
    assert_typed_equal(2.0, sum.real, Float)
    assert_typed_equal(3.0, sum.imag, Float)

    sum = GenericEnumerable.new([1, 2]).sum(10) { |v| v * 2 }
    assert_typed_equal(16, sum, Integer)
  end

  def test_nil_sums
    expected_raise = TypeError

    assert_raise(expected_raise) { GenericEnumerable.new([5, 15, nil]).sum }

    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10), Payment.new(nil) ])
    assert_raise(expected_raise) { payments.sum(&:price) }

    assert_equal 60, payments.sum { |p| p.price.to_i * 2 }
  end

  def test_empty_sums
    assert_equal 0, GenericEnumerable.new([]).sum
    assert_equal 0, GenericEnumerable.new([]).sum { |i| i + 10 }
    assert_equal Payment.new(0), GenericEnumerable.new([]).sum(Payment.new(0))
    assert_typed_equal 0.0, GenericEnumerable.new([]).sum(0.0), Float
  end

  def test_range_sums
    assert_equal 20, (1..4).sum { |i| i * 2 }
    assert_equal 10, (1..4).sum
    assert_equal 10, (1..4.5).sum
    assert_equal 6, (1...4).sum
    assert_equal "abc", ("a".."c").sum
    assert_equal 50_000_005_000_000, (0..10_000_000).sum
    assert_equal 0, (10..0).sum
    assert_equal 5, (10..0).sum(5)
    assert_equal 10, (10..10).sum
    assert_equal 42, (10...10).sum(42)
    assert_typed_equal 20.0, (1..4).sum(0.0) { |i| i * 2 }, Float
    assert_typed_equal 10.0, (1..4).sum(0.0), Float
    assert_typed_equal 20.0, (1..4).sum(10.0), Float
    assert_typed_equal 5.0, (10..0).sum(5.0), Float
  end

  def test_array_sums
    enum = [5, 15, 10]
    assert_equal 30, enum.sum
    assert_equal 60, enum.sum { |i| i * 2 }

    enum = %w(a b c)
    assert_equal "abc", enum.sum
    assert_equal "aabbcc", enum.sum { |i| i * 2 }

    payments = [ Payment.new(5), Payment.new(15), Payment.new(10) ]
    assert_equal 30, payments.sum(&:price)
    assert_equal 60, payments.sum { |p| p.price * 2 }

    payments = [ SummablePayment.new(5), SummablePayment.new(15) ]
    assert_equal SummablePayment.new(20), payments.sum
    assert_equal SummablePayment.new(20), payments.sum { |p| p }

    sum = [3, 5.quo(1)].sum
    assert_typed_equal(8, sum, Rational)

    sum = [3, 5.quo(1)].sum(0.0)
    assert_typed_equal(8.0, sum, Float)

    sum = [3, 5.quo(1), 7.0].sum
    assert_typed_equal(15.0, sum, Float)

    sum = [3, 5.quo(1), Complex(7)].sum
    assert_typed_equal(Complex(15), sum, Complex)
    assert_typed_equal(15, sum.real, Rational)
    assert_typed_equal(0, sum.imag, Integer)

    sum = [3.5, 5].sum
    assert_typed_equal(8.5, sum, Float)

    sum = [2, 8.5].sum
    assert_typed_equal(10.5, sum, Float)

    sum = [1.quo(2), 1].sum
    assert_typed_equal(3.quo(2), sum, Rational)

    sum = [1.quo(2), 1.quo(3)].sum
    assert_typed_equal(5.quo(6), sum, Rational)

    sum = [2.0, 3.0 * Complex::I].sum
    assert_typed_equal(Complex(2.0, 3.0), sum, Complex)
    assert_typed_equal(2.0, sum.real, Float)
    assert_typed_equal(3.0, sum.imag, Float)

    sum = [1, 2].sum(10) { |v| v * 2 }
    assert_typed_equal(16, sum, Integer)
  end

  def test_index_by
    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10) ])
    assert_equal({ 5 => Payment.new(5), 15 => Payment.new(15), 10 => Payment.new(10) },
                 payments.index_by(&:price))
    assert_equal Enumerator, payments.index_by.class
    assert_nil payments.index_by.size
    assert_equal 42, (1..42).index_by.size
    assert_equal({ 5 => Payment.new(5), 15 => Payment.new(15), 10 => Payment.new(10) },
                 payments.index_by.each(&:price))
  end

  def test_index_with
    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10) ])

    assert_equal({ Payment.new(5) => 5, Payment.new(15) => 15, Payment.new(10) => 10 }, payments.index_with(&:price))

    assert_equal({ title: nil, body: nil }, %i( title body ).index_with(nil))
    assert_equal({ title: [], body: [] }, %i( title body ).index_with([]))
    assert_equal({ title: {}, body: {} }, %i( title body ).index_with({}))

    assert_equal Enumerator, payments.index_with.class
    assert_nil payments.index_with.size
    assert_equal 42, (1..42).index_with.size
    assert_equal({ Payment.new(5) => 5, Payment.new(15) => 15, Payment.new(10) => 10 }, payments.index_with.each(&:price))
  end

  def test_many
    assert_equal false, GenericEnumerable.new([]).many?
    assert_equal false, GenericEnumerable.new([ 1 ]).many?
    assert_equal true,  GenericEnumerable.new([ 1, 2 ]).many?

    assert_equal false, GenericEnumerable.new([]).many? { |x| x > 1 }
    assert_equal false, GenericEnumerable.new([ 2 ]).many? { |x| x > 1 }
    assert_equal false, GenericEnumerable.new([ 1, 2 ]).many? { |x| x > 1 }
    assert_equal true,  GenericEnumerable.new([ 1, 2, 2 ]).many? { |x| x > 1 }
  end

  def test_many_iterates_only_on_what_is_needed
    infinity = 1.0 / 0.0
    very_long_enum = 0..infinity
    assert_equal true, very_long_enum.many?
    assert_equal true, very_long_enum.many? { |x| x > 100 }
  end

  def test_exclude?
    assert_equal true,  GenericEnumerable.new([ 1 ]).exclude?(2)
    assert_equal false, GenericEnumerable.new([ 1 ]).exclude?(1)
  end

  def test_excluding
    assert_equal [1, 2, 4], GenericEnumerable.new((1..5).to_a).excluding(3, 5)
    assert_equal [3, 4, 5], GenericEnumerable.new((1..5).to_a).excluding([1, 2])
    assert_equal [[0, 1]], GenericEnumerable.new([[0, 1], [1, 0]]).excluding([[1, 0]])
    assert_equal [1, 2, 4], (1..5).to_a.excluding(3, 5)
    assert_equal [1, 2, 4], (1..5).to_set.excluding(3, 5)
    assert_equal({ foo: 1, baz: 3 }, { foo: 1, bar: 2, baz: 3 }.excluding(:bar))
  end

  def test_without
    assert_equal [1, 2, 4], GenericEnumerable.new((1..5).to_a).without(3, 5)
    assert_equal [3, 4, 5], GenericEnumerable.new((1..5).to_a).without([1, 2])
  end

  def test_pluck
    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10) ])
    assert_equal [5, 15, 10], payments.pluck(:price)

    payments = GenericEnumerable.new([
      ExpandedPayment.new(5, 99),
      ExpandedPayment.new(15, 0),
      ExpandedPayment.new(10, 50)
    ])
    assert_equal [[5, 99], [15, 0], [10, 50]], payments.pluck(:dollars, :cents)

    assert_equal [], [].pluck(:price)
    assert_equal [], [].pluck(:dollars, :cents)
  end

  def test_pick
    payments = GenericEnumerable.new([ Payment.new(5), Payment.new(15), Payment.new(10) ])
    assert_equal 5, payments.pick(:price)

    payments = GenericEnumerable.new([
      ExpandedPayment.new(5, 99),
      ExpandedPayment.new(15, 0),
      ExpandedPayment.new(10, 50)
    ])
    assert_equal [5, 99], payments.pick(:dollars, :cents)

    assert_nil [].pick(:price)
    assert_nil [].pick(:dollars, :cents)
  end

  def test_compact_blank
    values = GenericEnumerable.new([1, "", nil, 2, " ", [], {}, false, true])

    assert_equal [1, 2, true], values.compact_blank
  end

  def test_array_compact_blank!
    values = [1, "", nil, 2, " ", [], {}, false, true]
    values.compact_blank!

    assert_equal [1, 2, true], values
  end

  def test_hash_compact_blank
    values = { a: "", b: 1, c: nil, d: [], e: false, f: true }
    assert_equal({ b: 1, f: true }, values.compact_blank)
  end

  def test_hash_compact_blank!
    values = { a: "", b: 1, c: nil, d: [], e: false, f: true }
    values.compact_blank!
    assert_equal({ b: 1, f: true }, values)
  end

  def test_in_order_of
    values = [ Payment.new(5), Payment.new(1), Payment.new(3) ]
    assert_equal [ Payment.new(1), Payment.new(5), Payment.new(3) ], values.in_order_of(:price, [ 1, 5, 3 ])
  end

  def test_in_order_of_ignores_missing_series
    values = [ Payment.new(5), Payment.new(1), Payment.new(3) ]
    assert_equal [ Payment.new(1), Payment.new(5), Payment.new(3) ], values.in_order_of(:price, [ 1, 2, 4, 5, 3 ])
  end

  def test_in_order_of_drops_elements_not_named_in_series
    values = [ Payment.new(5), Payment.new(1), Payment.new(3) ]
    assert_equal [ Payment.new(1), Payment.new(5) ], values.in_order_of(:price, [ 1, 5 ])
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/time"
require_relative "../core_ext/date_and_time_behavior"
require_relative "../time_zone_test_helpers"

class TimeExtCalculationsTest < ActiveSupport::TestCase
  def date_time_init(year, month, day, hour, minute, second, usec = 0)
    Time.local(year, month, day, hour, minute, second, usec)
  end

  include DateAndTimeBehavior
  include TimeZoneTestHelpers

  def test_seconds_since_midnight
    assert_equal 1, Time.local(2005, 1, 1, 0, 0, 1).seconds_since_midnight
    assert_equal 60, Time.local(2005, 1, 1, 0, 1, 0).seconds_since_midnight
    assert_equal 3660, Time.local(2005, 1, 1, 1, 1, 0).seconds_since_midnight
    assert_equal 86399, Time.local(2005, 1, 1, 23, 59, 59).seconds_since_midnight
    assert_equal 60.00001, Time.local(2005, 1, 1, 0, 1, 0, 10).seconds_since_midnight
  end

  def test_seconds_since_midnight_at_daylight_savings_time_start
    with_env_tz "US/Eastern" do
      # dt: US: 2005 April 3rd 2:00am ST => April 3rd 3:00am DT
      assert_equal 2 * 3600 - 1, Time.local(2005, 4, 3, 1, 59, 59).seconds_since_midnight, "just before DST start"
      assert_equal 2 * 3600 + 1, Time.local(2005, 4, 3, 3, 0, 1).seconds_since_midnight, "just after DST start"
    end

    with_env_tz "NZ" do
      # dt: New Zealand: 2006 October 1st 2:00am ST => October 1st 3:00am DT
      assert_equal 2 * 3600 - 1, Time.local(2006, 10, 1, 1, 59, 59).seconds_since_midnight, "just before DST start"
      assert_equal 2 * 3600 + 1, Time.local(2006, 10, 1, 3, 0, 1).seconds_since_midnight, "just after DST start"
    end
  end

  def test_seconds_since_midnight_at_daylight_savings_time_end
    with_env_tz "US/Eastern" do
      # st: US: 2005 October 30th 2:00am DT => October 30th 1:00am ST
      # avoid setting a time between 1:00 and 2:00 since that requires specifying whether DST is active
      assert_equal 1 * 3600 - 1, Time.local(2005, 10, 30, 0, 59, 59).seconds_since_midnight, "just before DST end"
      assert_equal 3 * 3600 + 1, Time.local(2005, 10, 30, 2, 0, 1).seconds_since_midnight, "just after DST end"

      # now set a time between 1:00 and 2:00 by specifying whether DST is active
      # uses: Time.local( sec, min, hour, day, month, year, wday, yday, isdst, tz )
      assert_equal 1 * 3600 + 30 * 60, Time.local(0, 30, 1, 30, 10, 2005, 0, 0, true, ENV["TZ"]).seconds_since_midnight, "before DST end"
      assert_equal 2 * 3600 + 30 * 60, Time.local(0, 30, 1, 30, 10, 2005, 0, 0, false, ENV["TZ"]).seconds_since_midnight, "after DST end"
    end

    with_env_tz "NZ" do
      # st: New Zealand: 2006 March 19th 3:00am DT => March 19th 2:00am ST
      # avoid setting a time between 2:00 and 3:00 since that requires specifying whether DST is active
      assert_equal 2 * 3600 - 1, Time.local(2006, 3, 19, 1, 59, 59).seconds_since_midnight, "just before DST end"
      assert_equal 4 * 3600 + 1, Time.local(2006, 3, 19, 3, 0, 1).seconds_since_midnight, "just after DST end"

      # now set a time between 2:00 and 3:00 by specifying whether DST is active
      # uses: Time.local( sec, min, hour, day, month, year, wday, yday, isdst, tz )
      assert_equal 2 * 3600 + 30 * 60, Time.local(0, 30, 2, 19, 3, 2006, 0, 0, true, ENV["TZ"]).seconds_since_midnight, "before DST end"
      assert_equal 3 * 3600 + 30 * 60, Time.local(0, 30, 2, 19, 3, 2006, 0, 0, false, ENV["TZ"]).seconds_since_midnight, "after DST end"
    end
  end

  def test_seconds_until_end_of_day
    assert_equal 0, Time.local(2005, 1, 1, 23, 59, 59).seconds_until_end_of_day
    assert_equal 1, Time.local(2005, 1, 1, 23, 59, 58).seconds_until_end_of_day
    assert_equal 60, Time.local(2005, 1, 1, 23, 58, 59).seconds_until_end_of_day
    assert_equal 3660, Time.local(2005, 1, 1, 22, 58, 59).seconds_until_end_of_day
    assert_equal 86399, Time.local(2005, 1, 1, 0, 0, 0).seconds_until_end_of_day
  end

  def test_seconds_until_end_of_day_at_daylight_savings_time_start
    with_env_tz "US/Eastern" do
      # dt: US: 2005 April 3rd 2:00am ST => April 3rd 3:00am DT
      assert_equal 21 * 3600, Time.local(2005, 4, 3, 1, 59, 59).seconds_until_end_of_day, "just before DST start"
      assert_equal 21 * 3600 - 2, Time.local(2005, 4, 3, 3, 0, 1).seconds_until_end_of_day, "just after DST start"
    end

    with_env_tz "NZ" do
      # dt: New Zealand: 2006 October 1st 2:00am ST => October 1st 3:00am DT
      assert_equal 21 * 3600, Time.local(2006, 10, 1, 1, 59, 59).seconds_until_end_of_day, "just before DST start"
      assert_equal 21 * 3600 - 2, Time.local(2006, 10, 1, 3, 0, 1).seconds_until_end_of_day, "just after DST start"
    end
  end

  def test_seconds_until_end_of_day_at_daylight_savings_time_end
    with_env_tz "US/Eastern" do
      # st: US: 2005 October 30th 2:00am DT => October 30th 1:00am ST
      # avoid setting a time between 1:00 and 2:00 since that requires specifying whether DST is active
      assert_equal 24 * 3600, Time.local(2005, 10, 30, 0, 59, 59).seconds_until_end_of_day, "just before DST end"
      assert_equal 22 * 3600 - 2, Time.local(2005, 10, 30, 2, 0, 1).seconds_until_end_of_day, "just after DST end"

      # now set a time between 1:00 and 2:00 by specifying whether DST is active
      # uses: Time.local( sec, min, hour, day, month, year, wday, yday, isdst, tz )
      assert_equal 24 * 3600 - 30 * 60 - 1, Time.local(0, 30, 1, 30, 10, 2005, 0, 0, true, ENV["TZ"]).seconds_until_end_of_day, "before DST end"
      assert_equal 23 * 3600 - 30 * 60 - 1, Time.local(0, 30, 1, 30, 10, 2005, 0, 0, false, ENV["TZ"]).seconds_until_end_of_day, "after DST end"
    end

    with_env_tz "NZ" do
      # st: New Zealand: 2006 March 19th 3:00am DT => March 19th 2:00am ST
      # avoid setting a time between 2:00 and 3:00 since that requires specifying whether DST is active
      assert_equal 23 * 3600, Time.local(2006, 3, 19, 1, 59, 59).seconds_until_end_of_day, "just before DST end"
      assert_equal 21 * 3600 - 2, Time.local(2006, 3, 19, 3, 0, 1).seconds_until_end_of_day, "just after DST end"

      # now set a time between 2:00 and 3:00 by specifying whether DST is active
      # uses: Time.local( sec, min, hour, day, month, year, wday, yday, isdst, tz )
      assert_equal 23 * 3600 - 30 * 60 - 1, Time.local(0, 30, 2, 19, 3, 2006, 0, 0, true, ENV["TZ"]).seconds_until_end_of_day, "before DST end"
      assert_equal 22 * 3600 - 30 * 60 - 1, Time.local(0, 30, 2, 19, 3, 2006, 0, 0, false, ENV["TZ"]).seconds_until_end_of_day, "after DST end"
    end
  end

  def test_sec_fraction
    time = Time.utc(2016, 4, 23, 0, 0, Rational(1, 1_000_000_000))
    assert_equal Rational(1, 1_000_000_000), time.sec_fraction

    time = Time.utc(2016, 4, 23, 0, 0, 0.000_000_001)
    assert_kind_of Rational, time.sec_fraction
    assert_equal 0.000_000_001, time.sec_fraction.to_f

    time = Time.utc(2016, 4, 23, 0, 0, 0, Rational(1, 1_000))
    assert_equal Rational(1, 1_000_000_000), time.sec_fraction

    time = Time.utc(2016, 4, 23, 0, 0, 0, 0.001)
    assert_kind_of Rational, time.sec_fraction
    assert_equal 0.001.to_r / 1000000, time.sec_fraction.to_f
  end

  def test_floor
    time = Time.utc(2016, 4, 23, 0, 0, "0.123456789".to_r)

    assert_equal "0".to_r, time.floor.subsec
    assert_equal "0.1".to_r, time.floor(1).subsec
    assert_equal "0.12".to_r, time.floor(2).subsec
    assert_equal "0.123456789".to_r, time.floor(9).subsec
    assert_equal "0.123456789".to_r, time.floor(10).subsec
  end

  def test_ceil
    time = Time.utc(2016, 4, 30, 23, 59, "59.123456789".to_r)

    assert_equal "0".to_r, time.ceil.subsec
    assert_equal Time.utc(2016, 5, 1, 0, 0), time.ceil

    assert_equal "0.124".to_r, time.ceil(3).subsec
    assert_equal "0.12346".to_r, time.ceil(5).subsec
    assert_equal "0.12345679".to_r, time.ceil(8).subsec
    assert_equal "0.123456789".to_r, time.ceil(9).subsec
    assert_equal "0.123456789".to_r.to_f, time.ceil(11).subsec.to_f
  end

  def test_beginning_of_day
    assert_equal Time.local(2005, 2, 4, 0, 0, 0), Time.local(2005, 2, 4, 10, 10, 10).beginning_of_day
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2006, 4, 2, 0, 0, 0), Time.local(2006, 4, 2, 10, 10, 10).beginning_of_day, "start DST"
      assert_equal Time.local(2006, 10, 29, 0, 0, 0), Time.local(2006, 10, 29, 10, 10, 10).beginning_of_day, "ends DST"
    end
    with_env_tz "NZ" do
      assert_equal Time.local(2006, 3, 19, 0, 0, 0), Time.local(2006, 3, 19, 10, 10, 10).beginning_of_day, "ends DST"
      assert_equal Time.local(2006, 10, 1, 0, 0, 0), Time.local(2006, 10, 1, 10, 10, 10).beginning_of_day, "start DST"
    end
  end

  def test_middle_of_day
    assert_equal Time.local(2005, 2, 4, 12, 0, 0), Time.local(2005, 2, 4, 10, 10, 10).middle_of_day
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2006, 4, 2, 12, 0, 0), Time.local(2006, 4, 2, 10, 10, 10).middle_of_day, "start DST"
      assert_equal Time.local(2006, 10, 29, 12, 0, 0), Time.local(2006, 10, 29, 10, 10, 10).middle_of_day, "ends DST"
    end
    with_env_tz "NZ" do
      assert_equal Time.local(2006, 3, 19, 12, 0, 0), Time.local(2006, 3, 19, 10, 10, 10).middle_of_day, "ends DST"
      assert_equal Time.local(2006, 10, 1, 12, 0, 0), Time.local(2006, 10, 1, 10, 10, 10).middle_of_day, "start DST"
    end
  end

  def test_beginning_of_hour
    assert_equal Time.local(2005, 2, 4, 19, 0, 0), Time.local(2005, 2, 4, 19, 30, 10).beginning_of_hour
  end

  def test_beginning_of_minute
    assert_equal Time.local(2005, 2, 4, 19, 30, 0), Time.local(2005, 2, 4, 19, 30, 10).beginning_of_minute
  end

  def test_end_of_day
    assert_equal Time.local(2007, 8, 12, 23, 59, 59, Rational(999999999, 1000)), Time.local(2007, 8, 12, 10, 10, 10).end_of_day
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2007, 4, 2, 23, 59, 59, Rational(999999999, 1000)), Time.local(2007, 4, 2, 10, 10, 10).end_of_day, "start DST"
      assert_equal Time.local(2007, 10, 29, 23, 59, 59, Rational(999999999, 1000)), Time.local(2007, 10, 29, 10, 10, 10).end_of_day, "ends DST"
    end
    with_env_tz "NZ" do
      assert_equal Time.local(2006, 3, 19, 23, 59, 59, Rational(999999999, 1000)), Time.local(2006, 3, 19, 10, 10, 10).end_of_day, "ends DST"
      assert_equal Time.local(2006, 10, 1, 23, 59, 59, Rational(999999999, 1000)), Time.local(2006, 10, 1, 10, 10, 10).end_of_day, "start DST"
    end
    with_env_tz "Asia/Yekaterinburg" do
      assert_equal Time.local(2015, 2, 8, 23, 59, 59, Rational(999999999, 1000)), Time.new(2015, 2, 8, 8, 0, 0, "+05:00").end_of_day
    end
  end

  def test_end_of_hour
    assert_equal Time.local(2005, 2, 4, 19, 59, 59, Rational(999999999, 1000)), Time.local(2005, 2, 4, 19, 30, 10).end_of_hour
  end

  def test_end_of_minute
    assert_equal Time.local(2005, 2, 4, 19, 30, 59, Rational(999999999, 1000)), Time.local(2005, 2, 4, 19, 30, 10).end_of_minute
  end

  def test_ago
    assert_equal Time.local(2005, 2, 22, 10, 10, 9),  Time.local(2005, 2, 22, 10, 10, 10).ago(1)
    assert_equal Time.local(2005, 2, 22, 9, 10, 10),  Time.local(2005, 2, 22, 10, 10, 10).ago(3600)
    assert_equal Time.local(2005, 2, 20, 10, 10, 10), Time.local(2005, 2, 22, 10, 10, 10).ago(86400 * 2)
    assert_equal Time.local(2005, 2, 20, 9, 9, 45),   Time.local(2005, 2, 22, 10, 10, 10).ago(86400 * 2 + 3600 + 25)
  end

  def test_daylight_savings_time_crossings_backward_start
    with_env_tz "US/Eastern" do
      # dt: US: 2005 April 3rd 4:18am
      assert_equal Time.local(2005, 4, 2, 3, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(24.hours), "dt-24.hours=>st"
      assert_equal Time.local(2005, 4, 2, 3, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(86400), "dt-86400=>st"
      assert_equal Time.local(2005, 4, 2, 3, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(86400.seconds), "dt-86400.seconds=>st"

      assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(24.hours), "st-24.hours=>st"
      assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(86400), "st-86400=>st"
      assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(86400.seconds), "st-86400.seconds=>st"
    end
    with_env_tz "NZ" do
      # dt: New Zealand: 2006 October 1st 4:18am
      assert_equal Time.local(2006, 9, 30, 3, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(24.hours), "dt-24.hours=>st"
      assert_equal Time.local(2006, 9, 30, 3, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(86400), "dt-86400=>st"
      assert_equal Time.local(2006, 9, 30, 3, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(86400.seconds), "dt-86400.seconds=>st"

      assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(24.hours), "st-24.hours=>st"
      assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(86400), "st-86400=>st"
      assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(86400.seconds), "st-86400.seconds=>st"
    end
  end

  def test_daylight_savings_time_crossings_backward_end
    with_env_tz "US/Eastern" do
      # st: US: 2005 October 30th 4:03am
      assert_equal Time.local(2005, 10, 29, 5, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(24.hours), "st-24.hours=>dt"
      assert_equal Time.local(2005, 10, 29, 5, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(86400), "st-86400=>dt"
      assert_equal Time.local(2005, 10, 29, 5, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(86400.seconds), "st-86400.seconds=>dt"

      assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(24.hours), "dt-24.hours=>dt"
      assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(86400), "dt-86400=>dt"
      assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(86400.seconds), "dt-86400.seconds=>dt"
    end
    with_env_tz "NZ" do
      # st: New Zealand: 2006 March 19th 4:03am
      assert_equal Time.local(2006, 3, 18, 5, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(24.hours), "st-24.hours=>dt"
      assert_equal Time.local(2006, 3, 18, 5, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(86400), "st-86400=>dt"
      assert_equal Time.local(2006, 3, 18, 5, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(86400.seconds), "st-86400.seconds=>dt"

      assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(24.hours), "dt-24.hours=>dt"
      assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(86400), "dt-86400=>dt"
      assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(86400.seconds), "dt-86400.seconds=>dt"
    end
  end

  def test_daylight_savings_time_crossings_backward_start_1day
    with_env_tz "US/Eastern" do
      # dt: US: 2005 April 3rd 4:18am
      assert_equal Time.local(2005, 4, 2, 4, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(1.day), "dt-1.day=>st"
      assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(1.day), "st-1.day=>st"
    end
    with_env_tz "NZ" do
      # dt: New Zealand: 2006 October 1st 4:18am
      assert_equal Time.local(2006, 9, 30, 4, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(1.day), "dt-1.day=>st"
      assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(1.day), "st-1.day=>st"
    end
  end

  def test_daylight_savings_time_crossings_backward_end_1day
    with_env_tz "US/Eastern" do
      # st: US: 2005 October 30th 4:03am
      assert_equal Time.local(2005, 10, 29, 4, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(1.day), "st-1.day=>dt"
      assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(1.day), "dt-1.day=>dt"
    end
    with_env_tz "NZ" do
      # st: New Zealand: 2006 March 19th 4:03am
      assert_equal Time.local(2006, 3, 18, 4, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(1.day), "st-1.day=>dt"
      assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(1.day), "dt-1.day=>dt"
    end
  end

  def test_since
    assert_equal Time.local(2005, 2, 22, 10, 10, 11), Time.local(2005, 2, 22, 10, 10, 10).since(1)
    assert_equal Time.local(2005, 2, 22, 11, 10, 10), Time.local(2005, 2, 22, 10, 10, 10).since(3600)
    assert_equal Time.local(2005, 2, 24, 10, 10, 10), Time.local(2005, 2, 22, 10, 10, 10).since(86400 * 2)
    assert_equal Time.local(2005, 2, 24, 11, 10, 35), Time.local(2005, 2, 22, 10, 10, 10).since(86400 * 2 + 3600 + 25)
    # when out of range of Time, returns a DateTime
    assert_equal DateTime.civil(2038, 1, 20, 11, 59, 59), Time.utc(2038, 1, 18, 11, 59, 59).since(86400 * 2)
  end

  def test_daylight_savings_time_crossings_forward_start
    with_env_tz "US/Eastern" do
      # st: US: 2005 April 2nd 7:27pm
      assert_equal Time.local(2005, 4, 3, 20, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(24.hours), "st+24.hours=>dt"
      assert_equal Time.local(2005, 4, 3, 20, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(86400), "st+86400=>dt"
      assert_equal Time.local(2005, 4, 3, 20, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(86400.seconds), "st+86400.seconds=>dt"

      assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(24.hours), "dt+24.hours=>dt"
      assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(86400), "dt+86400=>dt"
      assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(86400.seconds), "dt+86400.seconds=>dt"
    end
    with_env_tz "NZ" do
      # st: New Zealand: 2006 September 30th 7:27pm
      assert_equal Time.local(2006, 10, 1, 20, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(24.hours), "st+24.hours=>dt"
      assert_equal Time.local(2006, 10, 1, 20, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(86400), "st+86400=>dt"
      assert_equal Time.local(2006, 10, 1, 20, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(86400.seconds), "st+86400.seconds=>dt"

      assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(24.hours), "dt+24.hours=>dt"
      assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(86400), "dt+86400=>dt"
      assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(86400.seconds), "dt+86400.seconds=>dt"
    end
  end

  def test_daylight_savings_time_crossings_forward_start_1day
    with_env_tz "US/Eastern" do
      # st: US: 2005 April 2nd 7:27pm
      assert_equal Time.local(2005, 4, 3, 19, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(1.day), "st+1.day=>dt"
      assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(1.day), "dt+1.day=>dt"
    end
    with_env_tz "NZ" do
      # st: New Zealand: 2006 September 30th 7:27pm
      assert_equal Time.local(2006, 10, 1, 19, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(1.day), "st+1.day=>dt"
      assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(1.day), "dt+1.day=>dt"
    end
  end

  def test_daylight_savings_time_crossings_forward_start_tomorrow
    with_env_tz "US/Eastern" do
      # st: US: 2005 April 2nd 7:27pm
      assert_equal Time.local(2005, 4, 3, 19, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).tomorrow, "st+1.day=>dt"
      assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).tomorrow, "dt+1.day=>dt"
    end
    with_env_tz "NZ" do
      # st: New Zealand: 2006 September 30th 7:27pm
      assert_equal Time.local(2006, 10, 1, 19, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).tomorrow, "st+1.day=>dt"
      assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).tomorrow, "dt+1.day=>dt"
    end
  end

  def test_daylight_savings_time_crossings_backward_start_yesterday
    with_env_tz "US/Eastern" do
      # st: US: 2005 April 2nd 7:27pm
      assert_equal Time.local(2005, 4, 2, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).yesterday, "dt-1.day=>st"
      assert_equal Time.local(2005, 4, 3, 19, 27, 0), Time.local(2005, 4, 4, 19, 27, 0).yesterday, "dt-1.day=>dt"
    end
    with_env_tz "NZ" do
      # st: New Zealand: 2006 September 30th 7:27pm
      assert_equal Time.local(2006, 9, 30, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).yesterday, "dt-1.day=>st"
      assert_equal Time.local(2006, 10, 1, 19, 27, 0), Time.local(2006, 10, 2, 19, 27, 0).yesterday, "dt-1.day=>dt"
    end
  end

  def test_daylight_savings_time_crossings_forward_end
    with_env_tz "US/Eastern" do
      # dt: US: 2005 October 30th 12:45am
      assert_equal Time.local(2005, 10, 30, 23, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(24.hours), "dt+24.hours=>st"
      assert_equal Time.local(2005, 10, 30, 23, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(86400), "dt+86400=>st"
      assert_equal Time.local(2005, 10, 30, 23, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(86400.seconds), "dt+86400.seconds=>st"

      assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(24.hours), "st+24.hours=>st"
      assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(86400), "st+86400=>st"
      assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(86400.seconds), "st+86400.seconds=>st"
    end
    with_env_tz "NZ" do
      # dt: New Zealand: 2006 March 19th 1:45am
      assert_equal Time.local(2006, 3, 20, 0, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(24.hours), "dt+24.hours=>st"
      assert_equal Time.local(2006, 3, 20, 0, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(86400), "dt+86400=>st"
      assert_equal Time.local(2006, 3, 20, 0, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(86400.seconds), "dt+86400.seconds=>st"

      assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(24.hours), "st+24.hours=>st"
      assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(86400), "st+86400=>st"
      assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(86400.seconds), "st+86400.seconds=>st"
    end
  end

  def test_daylight_savings_time_crossings_forward_end_1day
    with_env_tz "US/Eastern" do
      # dt: US: 2005 October 30th 12:45am
      assert_equal Time.local(2005, 10, 31, 0, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(1.day), "dt+1.day=>st"
      assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(1.day), "st+1.day=>st"
    end
    with_env_tz "NZ" do
      # dt: New Zealand: 2006 March 19th 1:45am
      assert_equal Time.local(2006, 3, 20, 1, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(1.day), "dt+1.day=>st"
      assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(1.day), "st+1.day=>st"
    end
  end

  def test_daylight_savings_time_crossings_forward_end_tomorrow
    with_env_tz "US/Eastern" do
      # dt: US: 2005 October 30th 12:45am
      assert_equal Time.local(2005, 10, 31, 0, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).tomorrow, "dt+1.day=>st"
      assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).tomorrow, "st+1.day=>st"
    end
    with_env_tz "NZ" do
      # dt: New Zealand: 2006 March 19th 1:45am
      assert_equal Time.local(2006, 3, 20, 1, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).tomorrow, "dt+1.day=>st"
      assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).tomorrow, "st+1.day=>st"
    end
  end

  def test_daylight_savings_time_crossings_backward_end_yesterday
    with_env_tz "US/Eastern" do
      # dt: US: 2005 October 30th 12:45am
      assert_equal Time.local(2005, 10, 30, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).yesterday, "st-1.day=>dt"
      assert_equal Time.local(2005, 10, 31, 0, 45, 0), Time.local(2005, 11, 1, 0, 45, 0).yesterday, "st-1.day=>st"
    end
    with_env_tz "NZ" do
      # dt: New Zealand: 2006 March 19th 1:45am
      assert_equal Time.local(2006, 3, 19, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).yesterday, "st-1.day=>dt"
      assert_equal Time.local(2006, 3, 20, 1, 45, 0), Time.local(2006, 3, 21, 1, 45, 0).yesterday, "st-1.day=>st"
    end
  end

  def test_change
    assert_equal Time.local(2006, 2, 22, 15, 15, 10), Time.local(2005, 2, 22, 15, 15, 10).change(year: 2006)
    assert_equal Time.local(2005, 6, 22, 15, 15, 10), Time.local(2005, 2, 22, 15, 15, 10).change(month: 6)
    assert_equal Time.local(2012, 9, 22, 15, 15, 10), Time.local(2005, 2, 22, 15, 15, 10).change(year: 2012, month: 9)
    assert_equal Time.local(2005, 2, 22, 16),       Time.local(2005, 2, 22, 15, 15, 10).change(hour: 16)
    assert_equal Time.local(2005, 2, 22, 16, 45),    Time.local(2005, 2, 22, 15, 15, 10).change(hour: 16, min: 45)
    assert_equal Time.local(2005, 2, 22, 15, 45),    Time.local(2005, 2, 22, 15, 15, 10).change(min: 45)

    assert_equal Time.local(2005, 1, 2, 5, 0, 0, 0), Time.local(2005, 1, 2, 11, 22, 33, 44).change(hour: 5)
    assert_equal Time.local(2005, 1, 2, 11, 6, 0, 0), Time.local(2005, 1, 2, 11, 22, 33, 44).change(min: 6)
    assert_equal Time.local(2005, 1, 2, 11, 22, 7, 0), Time.local(2005, 1, 2, 11, 22, 33, 44).change(sec: 7)
    assert_equal Time.local(2005, 1, 2, 11, 22, 33, 8), Time.local(2005, 1, 2, 11, 22, 33, 44).change(usec: 8)
    assert_equal Time.local(2005, 1, 2, 11, 22, 33, 8), Time.local(2005, 1, 2, 11, 22, 33, 2).change(nsec: 8000)
    assert_raise(ArgumentError) { Time.local(2005, 1, 2, 11, 22, 33, 8).change(usec: 1, nsec: 1) }
    assert_nothing_raised { Time.new(2015, 5, 9, 10, 00, 00, "+03:00").change(nsec: 999999999) }
  end

  def test_utc_change
    assert_equal Time.utc(2006, 2, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).change(year: 2006)
    assert_equal Time.utc(2005, 6, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).change(month: 6)
    assert_equal Time.utc(2012, 9, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).change(year: 2012, month: 9)
    assert_equal Time.utc(2005, 2, 22, 16),       Time.utc(2005, 2, 22, 15, 15, 10).change(hour: 16)
    assert_equal Time.utc(2005, 2, 22, 16, 45),    Time.utc(2005, 2, 22, 15, 15, 10).change(hour: 16, min: 45)
    assert_equal Time.utc(2005, 2, 22, 15, 45),    Time.utc(2005, 2, 22, 15, 15, 10).change(min: 45)
    assert_equal Time.utc(2005, 1, 2, 11, 22, 33, 8), Time.utc(2005, 1, 2, 11, 22, 33, 2).change(nsec: 8000)
  end

  def test_offset_change
    assert_equal Time.new(2006, 2, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(year: 2006)
    assert_equal Time.new(2005, 6, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(month: 6)
    assert_equal Time.new(2012, 9, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(year: 2012, month: 9)
    assert_equal Time.new(2005, 2, 22, 16, 0, 0, "-08:00"),   Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(hour: 16)
    assert_equal Time.new(2005, 2, 22, 16, 45, 0, "-08:00"),  Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(hour: 16, min: 45)
    assert_equal Time.new(2005, 2, 22, 15, 45, 0, "-08:00"),  Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(min: 45)
    assert_equal Time.new(2005, 2, 22, 15, 15, 10, "-08:00"),  Time.new(2005, 2, 22, 15, 15, 0, "-08:00").change(sec: 10)
    assert_equal 10, Time.new(2005, 2, 22, 15, 15, 0, "-08:00").change(usec: 10).usec
    assert_equal 10, Time.new(2005, 2, 22, 15, 15, 0, "-08:00").change(nsec: 10).nsec
    assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "-08:00").change(usec: 1000000) }
    assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "-08:00").change(nsec: 1000000000) }
  end

  def test_change_offset
    assert_equal Time.new(2006, 2, 22, 15, 15, 10, "-08:00"), Time.new(2006, 2, 22, 15, 15, 10, "+01:00").change(offset: "-08:00")
    assert_equal Time.new(2006, 2, 22, 15, 15, 10, -28800), Time.new(2006, 2, 22, 15, 15, 10, 3600).change(offset: -28800)
    assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "+01:00").change(usec: 1000000, offset: "-08:00") }
    assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "+01:00").change(nsec: 1000000000, offset: -28800) }
  end

  def test_advance
    assert_equal Time.local(2006, 2, 28, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 1)
    assert_equal Time.local(2005, 6, 28, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(months: 4)
    assert_equal Time.local(2005, 3, 21, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(weeks: 3)
    assert_equal Time.local(2005, 3, 25, 3, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(weeks: 3.5)
    assert_in_delta Time.local(2005, 3, 26, 12, 51, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(weeks: 3.7), 1
    assert_equal Time.local(2005, 3, 5, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(days: 5)
    assert_equal Time.local(2005, 3, 6, 3, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(days: 5.5)
    assert_in_delta Time.local(2005, 3, 6, 8, 3, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(days: 5.7), 1
    assert_equal Time.local(2012, 9, 28, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 7)
    assert_equal Time.local(2013, 10, 3, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, days: 5)
    assert_equal Time.local(2013, 10, 17, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5)
    assert_equal Time.local(2001, 12, 27, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: -3, months: -2, days: -1)
    assert_equal Time.local(2005, 2, 28, 15, 15, 10), Time.local(2004, 2, 29, 15, 15, 10).advance(years: 1) # leap day plus one year
    assert_equal Time.local(2005, 2, 28, 20, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(hours: 5)
    assert_equal Time.local(2005, 2, 28, 15, 22, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(minutes: 7)
    assert_equal Time.local(2005, 2, 28, 15, 15, 19), Time.local(2005, 2, 28, 15, 15, 10).advance(seconds: 9)
    assert_equal Time.local(2005, 2, 28, 20, 22, 19), Time.local(2005, 2, 28, 15, 15, 10).advance(hours: 5, minutes: 7, seconds: 9)
    assert_equal Time.local(2005, 2, 28, 10, 8, 1), Time.local(2005, 2, 28, 15, 15, 10).advance(hours: -5, minutes: -7, seconds: -9)
    assert_equal Time.local(2013, 10, 17, 20, 22, 19), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5, hours: 5, minutes: 7, seconds: 9)
  end

  def test_utc_advance
    assert_equal Time.utc(2006, 2, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(years: 1)
    assert_equal Time.utc(2005, 6, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(months: 4)
    assert_equal Time.utc(2005, 3, 21, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(weeks: 3)
    assert_equal Time.utc(2005, 3, 25, 3, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(weeks: 3.5)
    assert_in_delta Time.utc(2005, 3, 26, 12, 51, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(weeks: 3.7), 1
    assert_equal Time.utc(2005, 3, 5, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(days: 5)
    assert_equal Time.utc(2005, 3, 6, 3, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(days: 5.5)
    assert_in_delta Time.utc(2005, 3, 6, 8, 3, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(days: 5.7), 1
    assert_equal Time.utc(2012, 9, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(years: 7, months: 7)
    assert_equal Time.utc(2013, 10, 3, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(years: 7, months: 19, days: 11)
    assert_equal Time.utc(2013, 10, 17, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5)
    assert_equal Time.utc(2001, 12, 27, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(years: -3, months: -2, days: -1)
    assert_equal Time.utc(2005, 2, 28, 15, 15, 10), Time.utc(2004, 2, 29, 15, 15, 10).advance(years: 1) # leap day plus one year
    assert_equal Time.utc(2005, 2, 28, 20, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(hours: 5)
    assert_equal Time.utc(2005, 2, 28, 15, 22, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(minutes: 7)
    assert_equal Time.utc(2005, 2, 28, 15, 15, 19), Time.utc(2005, 2, 28, 15, 15, 10).advance(seconds: 9)
    assert_equal Time.utc(2005, 2, 28, 20, 22, 19), Time.utc(2005, 2, 28, 15, 15, 10).advance(hours: 5, minutes: 7, seconds: 9)
    assert_equal Time.utc(2005, 2, 28, 10, 8, 1), Time.utc(2005, 2, 28, 15, 15, 10).advance(hours: -5, minutes: -7, seconds: -9)
    assert_equal Time.utc(2013, 10, 17, 20, 22, 19), Time.utc(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5, hours: 5, minutes: 7, seconds: 9)
  end

  def test_offset_advance
    assert_equal Time.new(2006, 2, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(years: 1)
    assert_equal Time.new(2005, 6, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(months: 4)
    assert_equal Time.new(2005, 3, 21, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(weeks: 3)
    assert_equal Time.new(2005, 3, 25, 3, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(weeks: 3.5)
    assert_in_delta Time.new(2005, 3, 26, 12, 51, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(weeks: 3.7), 1
    assert_equal Time.new(2005, 3, 5, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(days: 5)
    assert_equal Time.new(2005, 3, 6, 3, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(days: 5.5)
    assert_in_delta Time.new(2005, 3, 6, 8, 3, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(days: 5.7), 1
    assert_equal Time.new(2012, 9, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(years: 7, months: 7)
    assert_equal Time.new(2013, 10, 3, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(years: 7, months: 19, days: 11)
    assert_equal Time.new(2013, 10, 17, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(years: 7, months: 19, weeks: 2, days: 5)
    assert_equal Time.new(2001, 12, 27, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(years: -3, months: -2, days: -1)
    assert_equal Time.new(2005, 2, 28, 15, 15, 10, "-08:00"), Time.new(2004, 2, 29, 15, 15, 10, "-08:00").advance(years: 1) # leap day plus one year
    assert_equal Time.new(2005, 2, 28, 20, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(hours: 5)
    assert_equal Time.new(2005, 2, 28, 15, 22, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(minutes: 7)
    assert_equal Time.new(2005, 2, 28, 15, 15, 19, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(seconds: 9)
    assert_equal Time.new(2005, 2, 28, 20, 22, 19, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(hours: 5, minutes: 7, seconds: 9)
    assert_equal Time.new(2005, 2, 28, 10, 8, 1, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(hours: -5, minutes: -7, seconds: -9)
    assert_equal Time.new(2013, 10, 17, 20, 22, 19, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(years: 7, months: 19, weeks: 2, days: 5, hours: 5, minutes: 7, seconds: 9)
  end

  def test_advance_with_nsec
    t = Time.at(0, Rational(108635108, 1000))
    assert_equal t, t.advance(months: 0)
  end

  def test_advance_gregorian_proleptic
    assert_equal Time.local(1582, 10, 14, 15, 15, 10), Time.local(1582, 10, 15, 15, 15, 10).advance(days: -1)
    assert_equal Time.local(1582, 10, 15, 15, 15, 10), Time.local(1582, 10, 14, 15, 15, 10).advance(days: 1)
    assert_equal Time.local(1582, 10, 5, 15, 15, 10), Time.local(1582, 10, 4, 15, 15, 10).advance(days: 1)
    assert_equal Time.local(1582, 10, 4, 15, 15, 10), Time.local(1582, 10, 5, 15, 15, 10).advance(days: -1)
    assert_equal Time.local(999, 10, 4, 15, 15, 10), Time.local(1000, 10, 4, 15, 15, 10).advance(years: -1)
    assert_equal Time.local(1000, 10, 4, 15, 15, 10), Time.local(999, 10, 4, 15, 15, 10).advance(years: 1)
  end

  def test_last_week
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2005, 2, 21), Time.local(2005, 3, 1, 15, 15, 10).last_week
      assert_equal Time.local(2005, 2, 22), Time.local(2005, 3, 1, 15, 15, 10).last_week(:tuesday)
      assert_equal Time.local(2005, 2, 25), Time.local(2005, 3, 1, 15, 15, 10).last_week(:friday)
      assert_equal Time.local(2006, 10, 30), Time.local(2006, 11, 6, 0, 0, 0).last_week
      assert_equal Time.local(2006, 11, 15), Time.local(2006, 11, 23, 0, 0, 0).last_week(:wednesday)
    end
  end

  def test_next_week_near_daylight_start
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2006, 4, 3), Time.local(2006, 4, 2, 23, 1, 0).next_week, "just crossed standard => daylight"
    end
    with_env_tz "NZ" do
      assert_equal Time.local(2006, 10, 2), Time.local(2006, 10, 1, 23, 1, 0).next_week, "just crossed standard => daylight"
    end
  end

  def test_next_week_near_daylight_end
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2006, 10, 30), Time.local(2006, 10, 29, 23, 1, 0).next_week, "just crossed daylight => standard"
    end
    with_env_tz "NZ" do
      assert_equal Time.local(2006, 3, 20), Time.local(2006, 3, 19, 23, 1, 0).next_week, "just crossed daylight => standard"
    end
  end

  def test_to_s
    time = Time.utc(2005, 2, 21, 17, 44, 30.12345678901)
    assert_equal time.to_default_s,                 time.to_s
    assert_equal time.to_default_s,                 time.to_s(:doesnt_exist)
    assert_equal "2005-02-21 17:44:30",             time.to_s(:db)
    assert_equal "21 Feb 17:44",                    time.to_s(:short)
    assert_equal "17:44",                           time.to_s(:time)
    assert_equal "20050221174430",                  time.to_s(:number)
    assert_equal "20050221174430123456789",         time.to_s(:nsec)
    assert_equal "20050221174430123456",            time.to_s(:usec)
    assert_equal "February 21, 2005 17:44",         time.to_s(:long)
    assert_equal "February 21st, 2005 17:44",       time.to_s(:long_ordinal)
    with_env_tz "UTC" do
      assert_equal "Mon, 21 Feb 2005 17:44:30 +0000", time.to_s(:rfc822)
      assert_equal "2005-02-21 17:44:30.123456789 +0000", time.to_s(:inspect)
    end
    with_env_tz "US/Central" do
      assert_equal "Thu, 05 Feb 2009 14:30:05 -0600", Time.local(2009, 2, 5, 14, 30, 5).to_s(:rfc822)
      assert_equal "Mon, 09 Jun 2008 04:05:01 -0500", Time.local(2008, 6, 9, 4, 5, 1).to_s(:rfc822)
      assert_equal "2009-02-05T14:30:05-06:00", Time.local(2009, 2, 5, 14, 30, 5).to_s(:iso8601)
      assert_equal "2008-06-09T04:05:01-05:00", Time.local(2008, 6, 9, 4, 5, 1).to_s(:iso8601)
      assert_equal "2009-02-05T14:30:05Z", Time.utc(2009, 2, 5, 14, 30, 5).to_s(:iso8601)
      assert_equal "2009-02-05 14:30:05.000000000 -0600", Time.local(2009, 2, 5, 14, 30, 5).to_s(:inspect)
      assert_equal "2008-06-09 04:05:01.000000000 -0500", Time.local(2008, 6, 9, 4, 5, 1).to_s(:inspect)
    end
  end

  def test_custom_date_format
    Time::DATE_FORMATS[:custom] = "%Y%m%d%H%M%S"
    assert_equal "20050221143000", Time.local(2005, 2, 21, 14, 30, 0).to_s(:custom)
    Time::DATE_FORMATS.delete(:custom)
  end

  def test_rfc3339_with_fractional_seconds
    time = Time.new(1999, 12, 31, 19, 0, Rational(1, 8), -18000)
    assert_equal "1999-12-31T19:00:00.125-05:00", time.rfc3339(3)
  end

  def test_to_date
    assert_equal Date.new(2005, 2, 21), Time.local(2005, 2, 21, 17, 44, 30).to_date
  end

  def test_to_datetime
    assert_equal Time.utc(2005, 2, 21, 17, 44, 30).to_datetime, DateTime.civil(2005, 2, 21, 17, 44, 30, 0)
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2005, 2, 21, 17, 44, 30).to_datetime, DateTime.civil(2005, 2, 21, 17, 44, 30, Rational(Time.local(2005, 2, 21, 17, 44, 30).utc_offset, 86400))
    end
    with_env_tz "NZ" do
      assert_equal Time.local(2005, 2, 21, 17, 44, 30).to_datetime, DateTime.civil(2005, 2, 21, 17, 44, 30, Rational(Time.local(2005, 2, 21, 17, 44, 30).utc_offset, 86400))
    end
    assert_equal ::Date::ITALY, Time.utc(2005, 2, 21, 17, 44, 30).to_datetime.start # use Ruby's default start value
  end

  def test_to_time
    with_env_tz "US/Eastern" do
      assert_equal Time, Time.local(2005, 2, 21, 17, 44, 30).to_time.class
      assert_equal Time.local(2005, 2, 21, 17, 44, 30), Time.local(2005, 2, 21, 17, 44, 30).to_time
      assert_equal Time.local(2005, 2, 21, 17, 44, 30).utc_offset, Time.local(2005, 2, 21, 17, 44, 30).to_time.utc_offset
    end
  end

  # NOTE: this test seems to fail (changeset 1958) only on certain platforms,
  # like OSX, and FreeBSD 5.4.
  def test_fp_inaccuracy_ticket_1836
    midnight = Time.local(2005, 2, 21, 0, 0, 0)
    assert_equal midnight.midnight, (midnight + 1.hour + 0.000001).midnight
  end

  def test_days_in_month_with_year
    assert_equal 31, Time.days_in_month(1, 2005)

    assert_equal 28, Time.days_in_month(2, 2005)
    assert_equal 29, Time.days_in_month(2, 2004)
    assert_equal 29, Time.days_in_month(2, 2000)
    assert_equal 28, Time.days_in_month(2, 1900)

    assert_equal 31, Time.days_in_month(3, 2005)
    assert_equal 30, Time.days_in_month(4, 2005)
    assert_equal 31, Time.days_in_month(5, 2005)
    assert_equal 30, Time.days_in_month(6, 2005)
    assert_equal 31, Time.days_in_month(7, 2005)
    assert_equal 31, Time.days_in_month(8, 2005)
    assert_equal 30, Time.days_in_month(9, 2005)
    assert_equal 31, Time.days_in_month(10, 2005)
    assert_equal 30, Time.days_in_month(11, 2005)
    assert_equal 31, Time.days_in_month(12, 2005)
  end

  def test_days_in_month_feb_in_common_year_without_year_arg
    Time.stub(:now, Time.utc(2007)) do
      assert_equal 28, Time.days_in_month(2)
    end
  end

  def test_days_in_month_feb_in_leap_year_without_year_arg
    Time.stub(:now, Time.utc(2008)) do
      assert_equal 29, Time.days_in_month(2)
    end
  end

  def test_days_in_year_with_year
    assert_equal 365, Time.days_in_year(2005)
    assert_equal 366, Time.days_in_year(2004)
    assert_equal 366, Time.days_in_year(2000)
    assert_equal 365, Time.days_in_year(1900)
  end

  def test_days_in_year_in_common_year_without_year_arg
    Time.stub(:now, Time.utc(2007)) do
      assert_equal 365, Time.days_in_year
    end
  end

  def test_days_in_year_in_leap_year_without_year_arg
    Time.stub(:now, Time.utc(2008)) do
      assert_equal 366, Time.days_in_year
    end
  end

  def test_xmlschema_is_available
    assert_nothing_raised { Time.now.xmlschema }
  end

  def test_today_with_time_local
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, Time.local(1999, 12, 31, 23, 59, 59).today?
      assert_equal true,  Time.local(2000, 1, 1, 0).today?
      assert_equal true,  Time.local(2000, 1, 1, 23, 59, 59).today?
      assert_equal false, Time.local(2000, 1, 2, 0).today?
    end
  end

  def test_today_with_time_utc
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, Time.utc(1999, 12, 31, 23, 59, 59).today?
      assert_equal true,  Time.utc(2000, 1, 1, 0).today?
      assert_equal true,  Time.utc(2000, 1, 1, 23, 59, 59).today?
      assert_equal false, Time.utc(2000, 1, 2, 0).today?
    end
  end

  def test_yesterday_with_time_local
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  Time.local(1999, 12, 31, 23, 59, 59).yesterday?
      assert_equal false, Time.local(2000, 1, 1, 0).yesterday?
      assert_equal true,  Time.local(1999, 12, 31).yesterday?
      assert_equal false, Time.local(2000, 1, 2, 0).yesterday?
    end
  end

  def test_yesterday_with_time_utc
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  Time.utc(1999, 12, 31, 23, 59, 59).yesterday?
      assert_equal false, Time.utc(2000, 1, 1, 0).yesterday?
      assert_equal true,  Time.utc(1999, 12, 31).yesterday?
      assert_equal false, Time.utc(2000, 1, 2, 0).yesterday?
    end
  end

  def test_prev_day_with_time_local
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  Time.local(1999, 12, 31, 23, 59, 59).prev_day?
      assert_equal false, Time.local(2000, 1, 1, 0).prev_day?
      assert_equal true,  Time.local(1999, 12, 31).prev_day?
      assert_equal false, Time.local(2000, 1, 2, 0).prev_day?
    end
  end

  def test_prev_day_with_time_utc
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal true,  Time.utc(1999, 12, 31, 23, 59, 59).prev_day?
      assert_equal false, Time.utc(2000, 1, 1, 0).prev_day?
      assert_equal true,  Time.utc(1999, 12, 31).prev_day?
      assert_equal false, Time.utc(2000, 1, 2, 0).prev_day?
    end
  end

  def test_tomorrow_with_time_local
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, Time.local(1999, 12, 31, 23, 59, 59).tomorrow?
      assert_equal true,  Time.local(2000, 1, 2, 0).tomorrow?
      assert_equal true,  Time.local(2000, 1, 2, 23, 59, 59).tomorrow?
      assert_equal false, Time.local(2000, 1, 1, 0).tomorrow?
    end
  end

  def test_tomorrow_with_time_utc
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, Time.utc(1999, 12, 31, 23, 59, 59).tomorrow?
      assert_equal true,  Time.utc(2000, 1, 2, 0).tomorrow?
      assert_equal true,  Time.utc(2000, 1, 2, 23, 59, 59).tomorrow?
      assert_equal false, Time.utc(2000, 1, 1, 0).tomorrow?
    end
  end

  def test_next_day_with_time_local
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, Time.local(1999, 12, 31, 23, 59, 59).next_day?
      assert_equal true,  Time.local(2000, 1, 2, 0).next_day?
      assert_equal true,  Time.local(2000, 1, 2, 23, 59, 59).next_day?
      assert_equal false, Time.local(2000, 1, 1, 0).next_day?
    end
  end

  def test_next_day_with_time_utc
    Date.stub(:current, Date.new(2000, 1, 1)) do
      assert_equal false, Time.utc(1999, 12, 31, 23, 59, 59).next_day?
      assert_equal true,  Time.utc(2000, 1, 2, 0).next_day?
      assert_equal true,  Time.utc(2000, 1, 2, 23, 59, 59).next_day?
      assert_equal false, Time.utc(2000, 1, 1, 0).next_day?
    end
  end

  def test_past_with_time_current_as_time_local
    with_env_tz "US/Eastern" do
      Time.stub(:current, Time.local(2005, 2, 10, 15, 30, 45)) do
        assert_equal true,  Time.local(2005, 2, 10, 15, 30, 44).past?
        assert_equal false,  Time.local(2005, 2, 10, 15, 30, 45).past?
        assert_equal false,  Time.local(2005, 2, 10, 15, 30, 46).past?
        assert_equal true,  Time.utc(2005, 2, 10, 20, 30, 44).past?
        assert_equal false,  Time.utc(2005, 2, 10, 20, 30, 45).past?
        assert_equal false,  Time.utc(2005, 2, 10, 20, 30, 46).past?
      end
    end
  end

  def test_past_with_time_current_as_time_with_zone
    with_env_tz "US/Eastern" do
      twz = Time.utc(2005, 2, 10, 15, 30, 45).in_time_zone("Central Time (US & Canada)")
      Time.stub(:current, twz) do
        assert_equal true,  Time.local(2005, 2, 10, 10, 30, 44).past?
        assert_equal false,  Time.local(2005, 2, 10, 10, 30, 45).past?
        assert_equal false,  Time.local(2005, 2, 10, 10, 30, 46).past?
        assert_equal true,  Time.utc(2005, 2, 10, 15, 30, 44).past?
        assert_equal false,  Time.utc(2005, 2, 10, 15, 30, 45).past?
        assert_equal false,  Time.utc(2005, 2, 10, 15, 30, 46).past?
      end
    end
  end

  def test_future_with_time_current_as_time_local
    with_env_tz "US/Eastern" do
      Time.stub(:current, Time.local(2005, 2, 10, 15, 30, 45)) do
        assert_equal false,  Time.local(2005, 2, 10, 15, 30, 44).future?
        assert_equal false,  Time.local(2005, 2, 10, 15, 30, 45).future?
        assert_equal true,  Time.local(2005, 2, 10, 15, 30, 46).future?
        assert_equal false,  Time.utc(2005, 2, 10, 20, 30, 44).future?
        assert_equal false,  Time.utc(2005, 2, 10, 20, 30, 45).future?
        assert_equal true,  Time.utc(2005, 2, 10, 20, 30, 46).future?
      end
    end
  end

  def test_future_with_time_current_as_time_with_zone
    with_env_tz "US/Eastern" do
      twz = Time.utc(2005, 2, 10, 15, 30, 45).in_time_zone("Central Time (US & Canada)")
      Time.stub(:current, twz) do
        assert_equal false,  Time.local(2005, 2, 10, 10, 30, 44).future?
        assert_equal false,  Time.local(2005, 2, 10, 10, 30, 45).future?
        assert_equal true,  Time.local(2005, 2, 10, 10, 30, 46).future?
        assert_equal false,  Time.utc(2005, 2, 10, 15, 30, 44).future?
        assert_equal false,  Time.utc(2005, 2, 10, 15, 30, 45).future?
        assert_equal true,  Time.utc(2005, 2, 10, 15, 30, 46).future?
      end
    end
  end

  def test_acts_like_time
    assert_predicate Time.new, :acts_like_time?
  end

  def test_formatted_offset_with_utc
    assert_equal "+00:00", Time.utc(2000).formatted_offset
    assert_equal "+0000", Time.utc(2000).formatted_offset(false)
    assert_equal "UTC", Time.utc(2000).formatted_offset(true, "UTC")
  end

  def test_formatted_offset_with_local
    with_env_tz "US/Eastern" do
      assert_equal "-05:00", Time.local(2000).formatted_offset
      assert_equal "-0500", Time.local(2000).formatted_offset(false)
      assert_equal "-04:00", Time.local(2000, 7).formatted_offset
      assert_equal "-0400", Time.local(2000, 7).formatted_offset(false)
    end
  end

  def test_compare_with_time
    assert_equal 1, Time.utc(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59, 999)
    assert_equal 0, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0)
    assert_equal(-1, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0, 001))
  end

  def test_compare_with_datetime
    assert_equal 1, Time.utc(2000) <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
    assert_equal 0, Time.utc(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
    assert_equal(-1, Time.utc(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
  end

  def test_compare_with_time_with_zone
    assert_equal 1, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new(Time.utc(1999, 12, 31, 23, 59, 59), ActiveSupport::TimeZone["UTC"])
    assert_equal 0, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone["UTC"])
    assert_equal(-1, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 1), ActiveSupport::TimeZone["UTC"]))
  end

  def test_compare_with_string
    assert_equal 1, Time.utc(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59, 999).to_s
    assert_equal 0, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0).to_s
    assert_equal(-1, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 1, 0).to_s)
    assert_nil Time.utc(2000) <=> "Invalid as Time"
  end

  def test_at_with_datetime
    assert_equal Time.utc(2000, 1, 1, 0, 0, 0), Time.at(DateTime.civil(2000, 1, 1, 0, 0, 0))

    # Only test this if the underlying Time.at raises a TypeError
    begin
      Time.at_without_coercion(Time.now, 0)
    rescue TypeError
      assert_raise(TypeError) { assert_equal(Time.utc(2000, 1, 1, 0, 0, 0), Time.at(DateTime.civil(2000, 1, 1, 0, 0, 0), 0)) }
    end
  end

  def test_at_with_datetime_returns_local_time
    with_env_tz "US/Eastern" do
      dt = DateTime.civil(2000, 1, 1, 0, 0, 0, "+0")
      assert_equal Time.local(1999, 12, 31, 19, 0, 0), Time.at(dt)
      assert_equal "EST", Time.at(dt).zone
      assert_equal(-18000, Time.at(dt).utc_offset)

      # Daylight savings
      dt = DateTime.civil(2000, 7, 1, 1, 0, 0, "+1")
      assert_equal Time.local(2000, 6, 30, 20, 0, 0), Time.at(dt)
      assert_equal "EDT", Time.at(dt).zone
      assert_equal(-14400, Time.at(dt).utc_offset)
    end
  end

  def test_at_with_time_with_zone
    assert_equal Time.utc(2000, 1, 1, 0, 0, 0), Time.at(ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone["UTC"]))

    # Only test this if the underlying Time.at raises a TypeError
    begin
      Time.at_without_coercion(Time.now, 0)
    rescue TypeError
      assert_raise(TypeError) { assert_equal(Time.utc(2000, 1, 1, 0, 0, 0), Time.at(ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone["UTC"]), 0)) }
    end
  end

  def test_at_with_in_option
    assert_equal Time.new(1970, 1, 1, 0, 42, 17, "-08:00"), Time.at(31337, in: -28800)
  end

  def test_at_with_time_with_zone_returns_local_time
    with_env_tz "US/Eastern" do
      twz = ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone["London"])
      assert_equal Time.local(1999, 12, 31, 19, 0, 0), Time.at(twz)
      assert_equal "EST", Time.at(twz).zone
      assert_equal(-18000, Time.at(twz).utc_offset)

      # Daylight savings
      twz = ActiveSupport::TimeWithZone.new(Time.utc(2000, 7, 1, 0, 0, 0), ActiveSupport::TimeZone["London"])
      assert_equal Time.local(2000, 6, 30, 20, 0, 0), Time.at(twz)
      assert_equal "EDT", Time.at(twz).zone
      assert_equal(-14400, Time.at(twz).utc_offset)
    end
  end

  def test_at_with_time_microsecond_precision
    assert_equal Time.at(Time.utc(2000, 1, 1, 0, 0, 0, 111)).to_f, Time.utc(2000, 1, 1, 0, 0, 0, 111).to_f
  end

  def test_at_with_utc_time
    with_env_tz "US/Eastern" do
      assert_equal Time.utc(2000), Time.at(Time.utc(2000))
      assert_equal "UTC", Time.at(Time.utc(2000)).zone
      assert_equal(0, Time.at(Time.utc(2000)).utc_offset)
    end
  end

  def test_at_with_local_time
    with_env_tz "US/Eastern" do
      assert_equal Time.local(2000), Time.at(Time.local(2000))
      assert_equal "EST", Time.at(Time.local(2000)).zone
      assert_equal(-18000, Time.at(Time.local(2000)).utc_offset)

      assert_equal Time.local(2000, 7, 1), Time.at(Time.local(2000, 7, 1))
      assert_equal "EDT", Time.at(Time.local(2000, 7, 1)).zone
      assert_equal(-14400, Time.at(Time.local(2000, 7, 1)).utc_offset)
    end
  end

  def test_eql?
    assert_equal true, Time.utc(2000).eql?(ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["UTC"]))
    assert_equal true, Time.utc(2000).eql?(ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Hawaii"]))
    assert_equal false, Time.utc(2000, 1, 1, 0, 0, 1).eql?(ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["UTC"]))
  end

  def test_minus_with_time_with_zone
    assert_equal 86_400.0, Time.utc(2000, 1, 2) - ActiveSupport::TimeWithZone.new(Time.utc(2000, 1, 1), ActiveSupport::TimeZone["UTC"])
  end

  def test_minus_with_datetime
    assert_equal 86_400.0, Time.utc(2000, 1, 2) - DateTime.civil(2000, 1, 1)
  end

  def test_time_created_with_local_constructor_cannot_represent_times_during_hour_skipped_by_dst
    with_env_tz "US/Eastern" do
      # On Apr 2 2006 at 2:00AM in US, clocks were moved forward to 3:00AM.
      # Therefore, 2AM EST doesn't exist for this date; Time.local fails over to 3:00AM EDT
      assert_equal Time.local(2006, 4, 2, 3), Time.local(2006, 4, 2, 2)
      assert_predicate Time.local(2006, 4, 2, 2), :dst?
    end
  end

  def test_case_equality
    assert Time === Time.utc(2000)
    assert Time === ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["UTC"])
    assert Time === Class.new(Time).utc(2000)
    assert_equal false, Time === DateTime.civil(2000)
    assert_equal false, Class.new(Time) === Time.utc(2000)
    assert_equal false, Class.new(Time) === ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["UTC"])
  end

  def test_all_day
    assert_equal Time.local(2011, 6, 7, 0, 0, 0)..Time.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_day
  end

  def test_all_day_with_timezone
    beginning_of_day = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Hawaii"], Time.local(2011, 6, 7, 0, 0, 0))
    end_of_day = ActiveSupport::TimeWithZone.new(nil, ActiveSupport::TimeZone["Hawaii"], Time.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000)))

    assert_equal beginning_of_day, ActiveSupport::TimeWithZone.new(Time.local(2011, 6, 7, 10, 10, 10), ActiveSupport::TimeZone["Hawaii"]).all_day.begin
    assert_equal end_of_day, ActiveSupport::TimeWithZone.new(Time.local(2011, 6, 7, 10, 10, 10), ActiveSupport::TimeZone["Hawaii"]).all_day.end
  end

  def test_all_week
    assert_equal Time.local(2011, 6, 6, 0, 0, 0)..Time.local(2011, 6, 12, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_week
    assert_equal Time.local(2011, 6, 5, 0, 0, 0)..Time.local(2011, 6, 11, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_week(:sunday)
  end

  def test_all_month
    assert_equal Time.local(2011, 6, 1, 0, 0, 0)..Time.local(2011, 6, 30, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_month
  end

  def test_all_quarter
    assert_equal Time.local(2011, 4, 1, 0, 0, 0)..Time.local(2011, 6, 30, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_quarter
  end

  def test_all_year
    assert_equal Time.local(2011, 1, 1, 0, 0, 0)..Time.local(2011, 12, 31, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_year
  end

  def test_rfc3339_parse
    time = Time.rfc3339("1999-12-31T19:00:00.125-05:00")

    assert_equal 1999, time.year
    assert_equal 12, time.month
    assert_equal 31, time.day
    assert_equal 19, time.hour
    assert_equal 0, time.min
    assert_equal 0, time.sec
    assert_equal 125000, time.usec
    assert_equal(-18000, time.utc_offset)

    exception = assert_raises(ArgumentError) do
      Time.rfc3339("1999-12-31")
    end

    assert_equal "invalid date", exception.message

    exception = assert_raises(ArgumentError) do
      Time.rfc3339("1999-12-31T19:00:00")
    end

    assert_equal "invalid date", exception.message

    exception = assert_raises(ArgumentError) do
      Time.rfc3339("foobar")
    end

    assert_equal "invalid date", exception.message
  end

  def test_prev_day
    assert_equal date_time_init(2005, 2, 24, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(-2)
    assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(-1)
    assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(0)
    assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(1)
    assert_equal date_time_init(2005, 2, 20, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(2)
    assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day
    assert_equal date_time_init(2005, 2, 28, 10, 10, 10), date_time_init(2005, 3, 2, 10, 10, 10).prev_day.prev_day
  end

  def test_next_day
    assert_equal date_time_init(2005, 2, 20, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(-2)
    assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(-1)
    assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(0)
    assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(1)
    assert_equal date_time_init(2005, 2, 24, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(2)
    assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day
    assert_equal date_time_init(2005, 3, 2, 10, 10, 10),  date_time_init(2005, 2, 28, 10, 10, 10).next_day.next_day
  end

  def test_prev_month
    assert_equal date_time_init(2005, 4, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(-2)
    assert_equal date_time_init(2005, 3, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(-1)
    assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(0)
    assert_equal date_time_init(2005, 1, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(1)
    assert_equal date_time_init(2004, 12, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(2)
    assert_equal date_time_init(2005, 1, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month
    assert_equal date_time_init(2004, 12, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month.prev_month
  end

  def test_next_month
    assert_equal date_time_init(2004, 12, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(-2)
    assert_equal date_time_init(2005, 1, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(-1)
    assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(0)
    assert_equal date_time_init(2005, 3, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(1)
    assert_equal date_time_init(2005, 4, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(2)
    assert_equal date_time_init(2005, 3, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month
    assert_equal date_time_init(2005, 4, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month.next_month
  end

  def test_prev_year
    assert_equal date_time_init(2007, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).prev_year(-2)
    assert_equal date_time_init(2006, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).prev_year(-1)
    assert_equal date_time_init(2005, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).prev_year(0)
    assert_equal date_time_init(2004, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).prev_year(1)
    assert_equal date_time_init(2003, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).prev_year(2)
    assert_equal date_time_init(2004, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).prev_year
    assert_equal date_time_init(2003, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).prev_year.prev_year
  end

  def test_next_year
    assert_equal date_time_init(2003, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(-2)
    assert_equal date_time_init(2004, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(-1)
    assert_equal date_time_init(2005, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(0)
    assert_equal date_time_init(2006, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(1)
    assert_equal date_time_init(2007, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(2)
    assert_equal date_time_init(2006, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year
    assert_equal date_time_init(2007, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year.next_year
  end
end

class TimeExtMarshalingTest < ActiveSupport::TestCase
  def test_marshalling_with_utc_instance
    t = Time.utc(2000)
    unmarshalled = Marshal.load(Marshal.dump(t))
    assert_equal "UTC", unmarshalled.zone
    assert_equal t, unmarshalled
  end

  def test_marshalling_with_local_instance
    t = Time.local(2000)
    unmarshalled = Marshal.load(Marshal.dump(t))
    assert_equal t.zone, unmarshalled.zone
    assert_equal t, unmarshalled
  end

  def test_marshalling_with_frozen_utc_instance
    t = Time.utc(2000).freeze
    unmarshalled = Marshal.load(Marshal.dump(t))
    assert_equal "UTC", unmarshalled.zone
    assert_equal t, unmarshalled
  end

  def test_marshalling_with_frozen_local_instance
    t = Time.local(2000).freeze
    unmarshalled = Marshal.load(Marshal.dump(t))
    assert_equal t.zone, unmarshalled.zone
    assert_equal t, unmarshalled
  end

  def test_marshalling_preserves_fractional_seconds
    t = Time.parse("00:00:00.500")
    unmarshalled = Marshal.load(Marshal.dump(t))
    assert_equal t.to_f, unmarshalled.to_f
    assert_equal t, unmarshalled
  end

  def test_last_quarter_on_31st
    assert_equal Time.local(2004, 2, 29), Time.local(2004, 5, 31).last_quarter
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/hash"
require "bigdecimal"
require "active_support/core_ext/string/access"
require "active_support/ordered_hash"
require "active_support/core_ext/object/conversions"
require "active_support/core_ext/date/conversions"
require "active_support/core_ext/object/deep_dup"
require "active_support/inflections"

class HashExtTest < ActiveSupport::TestCase
  def setup
    @strings = { "a" => 1, "b" => 2 }
    @nested_strings = { "a" => { "b" => { "c" => 3 } } }
    @symbols = { a: 1, b: 2 }
    @nested_symbols = { a: { b: { c: 3 } } }
    @mixed = { :a => 1, "b" => 2 }
    @nested_mixed = { "a" => { b: { "c" => 3 } } }
    @integers = { 0 => 1, 1 => 2 }
    @nested_integers = { 0 => { 1 => { 2 => 3 } } }
    @illegal_symbols = { [] => 3 }
    @nested_illegal_symbols = { [] => { [] => 3 } }
    @upcase_strings = { "A" => 1, "B" => 2 }
    @nested_upcase_strings = { "A" => { "B" => { "C" => 3 } } }
    @string_array_of_hashes = { "a" => [ { "b" => 2 }, { "c" => 3 }, 4 ] }
    @symbol_array_of_hashes = { a: [ { b: 2 }, { c: 3 }, 4 ] }
    @mixed_array_of_hashes = { a: [ { b: 2 }, { "c" => 3 }, 4 ] }
    @upcase_array_of_hashes = { "A" => [ { "B" => 2 }, { "C" => 3 }, 4 ] }
  end

  def test_methods
    h = {}
    assert_respond_to h, :deep_transform_keys
    assert_respond_to h, :deep_transform_keys!
    assert_respond_to h, :deep_transform_values
    assert_respond_to h, :deep_transform_values!
    assert_respond_to h, :symbolize_keys
    assert_respond_to h, :symbolize_keys!
    assert_respond_to h, :deep_symbolize_keys
    assert_respond_to h, :deep_symbolize_keys!
    assert_respond_to h, :stringify_keys
    assert_respond_to h, :stringify_keys!
    assert_respond_to h, :deep_stringify_keys
    assert_respond_to h, :deep_stringify_keys!
    assert_respond_to h, :to_options
    assert_respond_to h, :to_options!
    assert_respond_to h, :except
    assert_respond_to h, :except!
  end

  def test_deep_transform_keys
    assert_equal @nested_upcase_strings, @nested_symbols.deep_transform_keys { |key| key.to_s.upcase }
    assert_equal @nested_upcase_strings, @nested_strings.deep_transform_keys { |key| key.to_s.upcase }
    assert_equal @nested_upcase_strings, @nested_mixed.deep_transform_keys { |key| key.to_s.upcase }
    assert_equal @upcase_array_of_hashes, @string_array_of_hashes.deep_transform_keys { |key| key.to_s.upcase }
    assert_equal @upcase_array_of_hashes, @symbol_array_of_hashes.deep_transform_keys { |key| key.to_s.upcase }
    assert_equal @upcase_array_of_hashes, @mixed_array_of_hashes.deep_transform_keys { |key| key.to_s.upcase }
  end

  def test_deep_transform_keys_not_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_transform_keys { |key| key.to_s.upcase }
    assert_equal @nested_mixed, transformed_hash
  end

  def test_deep_transform_keys!
    assert_equal @nested_upcase_strings, @nested_symbols.deep_dup.deep_transform_keys! { |key| key.to_s.upcase }
    assert_equal @nested_upcase_strings, @nested_strings.deep_dup.deep_transform_keys! { |key| key.to_s.upcase }
    assert_equal @nested_upcase_strings, @nested_mixed.deep_dup.deep_transform_keys! { |key| key.to_s.upcase }
    assert_equal @upcase_array_of_hashes, @string_array_of_hashes.deep_dup.deep_transform_keys! { |key| key.to_s.upcase }
    assert_equal @upcase_array_of_hashes, @symbol_array_of_hashes.deep_dup.deep_transform_keys! { |key| key.to_s.upcase }
    assert_equal @upcase_array_of_hashes, @mixed_array_of_hashes.deep_dup.deep_transform_keys! { |key| key.to_s.upcase }
  end

  def test_deep_transform_keys_with_bang_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_transform_keys! { |key| key.to_s.upcase }
    assert_equal @nested_upcase_strings, transformed_hash
    assert_equal({ "a" => { b: { "c" => 3 } } }, @nested_mixed)
  end

  def test_deep_transform_values
    assert_equal({ "a" => "1", "b" => "2" }, @strings.deep_transform_values { |value| value.to_s })
    assert_equal({ "a" => { "b" => { "c" => "3" } } }, @nested_strings.deep_transform_values { |value| value.to_s })
    assert_equal({ "a" => [ { "b" => "2" }, { "c" => "3" }, "4" ] }, @string_array_of_hashes.deep_transform_values { |value| value.to_s })
  end

  def test_deep_transform_values_not_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_transform_values { |value| value.to_s }
    assert_equal @nested_mixed, transformed_hash
  end

  def test_deep_transform_values!
    assert_equal({ "a" => "1", "b" => "2" }, @strings.deep_transform_values! { |value| value.to_s })
    assert_equal({ "a" => { "b" => { "c" => "3" } } }, @nested_strings.deep_transform_values! { |value| value.to_s })
    assert_equal({ "a" => [ { "b" => "2" }, { "c" => "3" }, "4" ] }, @string_array_of_hashes.deep_transform_values! { |value| value.to_s })
  end

  def test_deep_transform_values_with_bang_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_transform_values! { |value| value.to_s }
    assert_equal({ "a" => { b: { "c" => "3" } } }, transformed_hash)
    assert_equal({ "a" => { b: { "c" => 3 } } }, @nested_mixed)
  end

  def test_symbolize_keys
    assert_equal @symbols, @symbols.symbolize_keys
    assert_equal @symbols, @strings.symbolize_keys
    assert_equal @symbols, @mixed.symbolize_keys
  end

  def test_symbolize_keys_not_mutates
    transformed_hash = @mixed.dup
    transformed_hash.symbolize_keys
    assert_equal @mixed, transformed_hash
  end

  def test_deep_symbolize_keys
    assert_equal @nested_symbols, @nested_symbols.deep_symbolize_keys
    assert_equal @nested_symbols, @nested_strings.deep_symbolize_keys
    assert_equal @nested_symbols, @nested_mixed.deep_symbolize_keys
    assert_equal @symbol_array_of_hashes, @string_array_of_hashes.deep_symbolize_keys
    assert_equal @symbol_array_of_hashes, @symbol_array_of_hashes.deep_symbolize_keys
    assert_equal @symbol_array_of_hashes, @mixed_array_of_hashes.deep_symbolize_keys
  end

  def test_deep_symbolize_keys_not_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_symbolize_keys
    assert_equal @nested_mixed, transformed_hash
  end

  def test_symbolize_keys!
    assert_equal @symbols, @symbols.dup.symbolize_keys!
    assert_equal @symbols, @strings.dup.symbolize_keys!
    assert_equal @symbols, @mixed.dup.symbolize_keys!
  end

  def test_symbolize_keys_with_bang_mutates
    transformed_hash = @mixed.dup
    transformed_hash.deep_symbolize_keys!
    assert_equal @symbols, transformed_hash
    assert_equal({ :a => 1, "b" => 2 }, @mixed)
  end

  def test_deep_symbolize_keys!
    assert_equal @nested_symbols, @nested_symbols.deep_dup.deep_symbolize_keys!
    assert_equal @nested_symbols, @nested_strings.deep_dup.deep_symbolize_keys!
    assert_equal @nested_symbols, @nested_mixed.deep_dup.deep_symbolize_keys!
    assert_equal @symbol_array_of_hashes, @string_array_of_hashes.deep_dup.deep_symbolize_keys!
    assert_equal @symbol_array_of_hashes, @symbol_array_of_hashes.deep_dup.deep_symbolize_keys!
    assert_equal @symbol_array_of_hashes, @mixed_array_of_hashes.deep_dup.deep_symbolize_keys!
  end

  def test_deep_symbolize_keys_with_bang_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_symbolize_keys!
    assert_equal @nested_symbols, transformed_hash
    assert_equal({ "a" => { b: { "c" => 3 } } }, @nested_mixed)
  end

  def test_symbolize_keys_preserves_keys_that_cant_be_symbolized
    assert_equal @illegal_symbols, @illegal_symbols.symbolize_keys
    assert_equal @illegal_symbols, @illegal_symbols.dup.symbolize_keys!
  end

  def test_deep_symbolize_keys_preserves_keys_that_cant_be_symbolized
    assert_equal @nested_illegal_symbols, @nested_illegal_symbols.deep_symbolize_keys
    assert_equal @nested_illegal_symbols, @nested_illegal_symbols.deep_dup.deep_symbolize_keys!
  end

  def test_symbolize_keys_preserves_integer_keys
    assert_equal @integers, @integers.symbolize_keys
    assert_equal @integers, @integers.dup.symbolize_keys!
  end

  def test_deep_symbolize_keys_preserves_integer_keys
    assert_equal @nested_integers, @nested_integers.deep_symbolize_keys
    assert_equal @nested_integers, @nested_integers.deep_dup.deep_symbolize_keys!
  end

  def test_stringify_keys
    assert_equal @strings, @symbols.stringify_keys
    assert_equal @strings, @strings.stringify_keys
    assert_equal @strings, @mixed.stringify_keys
  end

  def test_stringify_keys_not_mutates
    transformed_hash = @mixed.dup
    transformed_hash.stringify_keys
    assert_equal @mixed, transformed_hash
  end

  def test_deep_stringify_keys
    assert_equal @nested_strings, @nested_symbols.deep_stringify_keys
    assert_equal @nested_strings, @nested_strings.deep_stringify_keys
    assert_equal @nested_strings, @nested_mixed.deep_stringify_keys
    assert_equal @string_array_of_hashes, @string_array_of_hashes.deep_stringify_keys
    assert_equal @string_array_of_hashes, @symbol_array_of_hashes.deep_stringify_keys
    assert_equal @string_array_of_hashes, @mixed_array_of_hashes.deep_stringify_keys
  end

  def test_deep_stringify_keys_not_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_stringify_keys
    assert_equal @nested_mixed, transformed_hash
  end

  def test_stringify_keys!
    assert_equal @strings, @symbols.dup.stringify_keys!
    assert_equal @strings, @strings.dup.stringify_keys!
    assert_equal @strings, @mixed.dup.stringify_keys!
  end

  def test_stringify_keys_with_bang_mutates
    transformed_hash = @mixed.dup
    transformed_hash.stringify_keys!
    assert_equal @strings, transformed_hash
    assert_equal({ :a => 1, "b" => 2 }, @mixed)
  end

  def test_deep_stringify_keys!
    assert_equal @nested_strings, @nested_symbols.deep_dup.deep_stringify_keys!
    assert_equal @nested_strings, @nested_strings.deep_dup.deep_stringify_keys!
    assert_equal @nested_strings, @nested_mixed.deep_dup.deep_stringify_keys!
    assert_equal @string_array_of_hashes, @string_array_of_hashes.deep_dup.deep_stringify_keys!
    assert_equal @string_array_of_hashes, @symbol_array_of_hashes.deep_dup.deep_stringify_keys!
    assert_equal @string_array_of_hashes, @mixed_array_of_hashes.deep_dup.deep_stringify_keys!
  end

  def test_deep_stringify_keys_with_bang_mutates
    transformed_hash = @nested_mixed.deep_dup
    transformed_hash.deep_stringify_keys!
    assert_equal @nested_strings, transformed_hash
    assert_equal({ "a" => { b: { "c" => 3 } } }, @nested_mixed)
  end

  def test_assert_valid_keys
    assert_nothing_raised do
      { failure: "stuff", funny: "business" }.assert_valid_keys([ :failure, :funny ])
      { failure: "stuff", funny: "business" }.assert_valid_keys(:failure, :funny)
    end
    # not all valid keys are required to be present
    assert_nothing_raised do
      { failure: "stuff", funny: "business" }.assert_valid_keys([ :failure, :funny, :sunny ])
      { failure: "stuff", funny: "business" }.assert_valid_keys(:failure, :funny, :sunny)
    end

    exception = assert_raise ArgumentError do
      { failore: "stuff", funny: "business" }.assert_valid_keys([ :failure, :funny ])
    end
    assert_equal "Unknown key: :failore. Valid keys are: :failure, :funny", exception.message

    exception = assert_raise ArgumentError do
      { failore: "stuff", funny: "business" }.assert_valid_keys(:failure, :funny)
    end
    assert_equal "Unknown key: :failore. Valid keys are: :failure, :funny", exception.message

    exception = assert_raise ArgumentError do
      { failore: "stuff", funny: "business" }.assert_valid_keys([ :failure ])
    end
    assert_equal "Unknown key: :failore. Valid keys are: :failure", exception.message

    exception = assert_raise ArgumentError do
      { failore: "stuff", funny: "business" }.assert_valid_keys(:failure)
    end
    assert_equal "Unknown key: :failore. Valid keys are: :failure", exception.message
  end

  def test_deep_merge
    hash_1 = { a: "a", b: "b", c: { c1: "c1", c2: "c2", c3: { d1: "d1" } } }
    hash_2 = { a: 1, c: { c1: 2, c3: { d2: "d2" } } }
    expected = { a: 1, b: "b", c: { c1: 2, c2: "c2", c3: { d1: "d1", d2: "d2" } } }
    assert_equal expected, hash_1.deep_merge(hash_2)

    hash_1.deep_merge!(hash_2)
    assert_equal expected, hash_1
  end

  def test_deep_merge_with_block
    hash_1 = { a: "a", b: "b", c: { c1: "c1", c2: "c2", c3: { d1: "d1" } } }
    hash_2 = { a: 1, c: { c1: 2, c3: { d2: "d2" } } }
    expected = { a: [:a, "a", 1], b: "b", c: { c1: [:c1, "c1", 2], c2: "c2", c3: { d1: "d1", d2: "d2" } } }
    assert_equal(expected, hash_1.deep_merge(hash_2) { |k, o, n| [k, o, n] })

    hash_1.deep_merge!(hash_2) { |k, o, n| [k, o, n] }
    assert_equal expected, hash_1
  end

  def test_deep_merge_with_falsey_values
    hash_1 = { e: false }
    hash_2 = { e: "e" }
    expected = { e: [:e, false, "e"] }
    assert_equal(expected, hash_1.deep_merge(hash_2) { |k, o, n| [k, o, n] })

    hash_1.deep_merge!(hash_2) { |k, o, n| [k, o, n] }
    assert_equal expected, hash_1
  end

  def test_reverse_merge
    defaults = { d: 0, a: "x", b: "y", c: 10 }.freeze
    options  = { a: 1, b: 2 }
    expected = { d: 0, a: 1, b: 2, c: 10 }

    # Should merge defaults into options, creating a new hash.
    assert_equal expected, options.reverse_merge(defaults)
    assert_not_equal expected, options

    # Should merge! defaults into options, replacing options.
    merged = options.dup
    assert_equal expected, merged.reverse_merge!(defaults)
    assert_equal expected, merged

    # Make the order consistent with the non-overwriting reverse merge.
    assert_equal expected.keys, merged.keys

    # Should be an alias for reverse_merge!
    merged = options.dup
    assert_equal expected, merged.reverse_update(defaults)
    assert_equal expected, merged
  end

  def test_with_defaults_aliases_reverse_merge
    defaults = { a: "x", b: "y", c: 10 }.freeze
    options  = { a: 1, b: 2 }
    expected = { a: 1, b: 2, c: 10 }

    # Should be an alias for reverse_merge
    assert_equal expected, options.with_defaults(defaults)
    assert_not_equal expected, options

    # Should be an alias for reverse_merge!
    merged = options.dup
    assert_equal expected, merged.with_defaults!(defaults)
    assert_equal expected, merged
  end

  def test_slice_inplace
    original = { a: "x", b: "y", c: 10 }
    expected_return = { c: 10 }
    expected_original = { a: "x", b: "y" }

    # Should return a hash containing the removed key/value pairs.
    assert_equal expected_return, original.slice!(:a, :b)

    # Should replace the hash with only the given keys.
    assert_equal expected_original, original
  end

  def test_slice_inplace_with_an_array_key
    original = { :a => "x", :b => "y", :c => 10, [:a, :b] => "an array key" }
    expected = { a: "x", b: "y" }

    # Should replace the hash with only the given keys when given an array key.
    assert_equal expected, original.slice!([:a, :b], :c)
  end

  def test_slice_bang_does_not_override_default
    hash = Hash.new(0)
    hash.update(a: 1, b: 2)

    hash.slice!(:a)

    assert_equal 0, hash[:c]
  end

  def test_slice_bang_does_not_override_default_proc
    hash = Hash.new { |h, k| h[k] = [] }
    hash.update(a: 1, b: 2)

    hash.slice!(:a)

    assert_equal [], hash[:c]
  end

  def test_extract
    original = { a: 1, b: 2, c: 3, d: 4 }
    expected = { a: 1, b: 2 }
    remaining = { c: 3, d: 4 }

    assert_equal expected, original.extract!(:a, :b, :x)
    assert_equal remaining, original
  end

  def test_extract_nils
    original = { a: nil, b: nil }
    expected = { a: nil }
    remaining = { b: nil }
    extracted = original.extract!(:a, :x)

    assert_equal expected, extracted
    assert_nil extracted[:a]
    assert_nil extracted[:x]
    assert_equal remaining, original
  end

  def test_except
    original = { a: "x", b: "y", c: 10 }
    expected = { a: "x", b: "y" }

    # Should return a new hash without the given keys.
    assert_equal expected, original.except(:c)
    assert_not_equal expected, original

    # Should replace the hash without the given keys.
    assert_equal expected, original.except!(:c)
    assert_equal expected, original
  end

  def test_except_with_more_than_one_argument
    original = { a: "x", b: "y", c: 10 }
    expected = { a: "x" }

    assert_equal expected, original.except(:b, :c)

    assert_equal expected, original.except!(:b, :c)
    assert_equal expected, original
  end

  def test_except_with_original_frozen
    original = { a: "x", b: "y" }
    original.freeze
    assert_nothing_raised { original.except(:a) }

    assert_raise(FrozenError) { original.except!(:a) }
  end

  def test_except_does_not_delete_values_in_original
    original = { a: "x", b: "y" }
    assert_not_called(original, :delete) do
      original.except(:a)
    end
  end
end

class IWriteMyOwnXML
  def to_xml(options = {})
    options[:indent] ||= 2
    xml = options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])
    xml.instruct! unless options[:skip_instruct]
    xml.level_one do
      xml.tag!(:second_level, "content")
    end
  end
end

class HashExtToParamTests < ActiveSupport::TestCase
  class ToParam < String
    def to_param
      "#{self}-1"
    end
  end

  def test_string_hash
    assert_equal "", {}.to_param
    assert_equal "hello=world", { hello: "world" }.to_param
    assert_equal "hello=10", { "hello" => 10 }.to_param
    assert_equal "hello=world&say_bye=true", { :hello => "world", "say_bye" => true }.to_param
  end

  def test_number_hash
    assert_equal "10=20&30=40&50=60", { 10 => 20, 30 => 40, 50 => 60 }.to_param
  end

  def test_to_param_hash
    assert_equal "custom-1=param-1&custom2-1=param2-1", { ToParam.new("custom") => ToParam.new("param"), ToParam.new("custom2") => ToParam.new("param2") }.to_param
  end

  def test_to_param_hash_escapes_its_keys_and_values
    assert_equal "param+1=A+string+with+%2F+characters+%26+that+should+be+%3F+escaped", { "param 1" => "A string with / characters & that should be ? escaped" }.to_param
  end

  def test_to_param_orders_by_key_in_ascending_order
    assert_equal "a=2&b=1&c=0", Hash[*%w(b 1 c 0 a 2)].to_param
  end
end

class HashToXmlTest < ActiveSupport::TestCase
  def setup
    @xml_options = { root: :person, skip_instruct: true, indent: 0 }
  end

  def test_one_level
    xml = { name: "David", street: "Paulina" }.to_xml(@xml_options)
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<street>Paulina</street>)
    assert_includes xml, %(<name>David</name>)
  end

  def test_one_level_dasherize_false
    xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(dasherize: false))
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<street_name>Paulina</street_name>)
    assert_includes xml, %(<name>David</name>)
  end

  def test_one_level_dasherize_true
    xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(dasherize: true))
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<street-name>Paulina</street-name>)
    assert_includes xml, %(<name>David</name>)
  end

  def test_one_level_camelize_true
    xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(camelize: true))
    assert_equal "<Person>", xml.first(8)
    assert_includes xml, %(<StreetName>Paulina</StreetName>)
    assert_includes xml, %(<Name>David</Name>)
  end

  def test_one_level_camelize_lower
    xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(camelize: :lower))
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<streetName>Paulina</streetName>)
    assert_includes xml, %(<name>David</name>)
  end

  def test_one_level_with_types
    xml = { name: "David", street: "Paulina", age: 26, age_in_millis: 820497600000, moved_on: Date.new(2005, 11, 15), resident: :yes }.to_xml(@xml_options)
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<street>Paulina</street>)
    assert_includes xml, %(<name>David</name>)
    assert_includes xml, %(<age type="integer">26</age>)
    assert_includes xml, %(<age-in-millis type="integer">820497600000</age-in-millis>)
    assert_includes xml, %(<moved-on type="date">2005-11-15</moved-on>)
    assert_includes xml, %(<resident type="symbol">yes</resident>)
  end

  def test_one_level_with_nils
    xml = { name: "David", street: "Paulina", age: nil }.to_xml(@xml_options)
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<street>Paulina</street>)
    assert_includes xml, %(<name>David</name>)
    assert_includes xml, %(<age nil="true"/>)
  end

  def test_one_level_with_skipping_types
    xml = { name: "David", street: "Paulina", age: nil }.to_xml(@xml_options.merge(skip_types: true))
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<street>Paulina</street>)
    assert_includes xml, %(<name>David</name>)
    assert_includes xml, %(<age nil="true"/>)
  end

  def test_one_level_with_yielding
    xml = { name: "David", street: "Paulina" }.to_xml(@xml_options) do |x|
      x.creator("Rails")
    end

    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<street>Paulina</street>)
    assert_includes xml, %(<name>David</name>)
    assert_includes xml, %(<creator>Rails</creator>)
  end

  def test_two_levels
    xml = { name: "David", address: { street: "Paulina" } }.to_xml(@xml_options)
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<address><street>Paulina</street></address>)
    assert_includes xml, %(<name>David</name>)
  end

  def test_two_levels_with_second_level_overriding_to_xml
    xml = { name: "David", address: { street: "Paulina" }, child: IWriteMyOwnXML.new }.to_xml(@xml_options)
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<address><street>Paulina</street></address>)
    assert_includes xml, %(<level_one><second_level>content</second_level></level_one>)
  end

  def test_two_levels_with_array
    xml = { name: "David", addresses: [{ street: "Paulina" }, { street: "Evergreen" }] }.to_xml(@xml_options)
    assert_equal "<person>", xml.first(8)
    assert_includes xml, %(<addresses type="array"><address>)
    assert_includes xml, %(<address><street>Paulina</street></address>)
    assert_includes xml, %(<address><street>Evergreen</street></address>)
    assert_includes xml, %(<name>David</name>)
  end

  def test_three_levels_with_array
    xml = { name: "David", addresses: [{ streets: [ { name: "Paulina" }, { name: "Paulina" } ] } ] }.to_xml(@xml_options)
    assert_includes xml, %(<addresses type="array"><address><streets type="array"><street><name>)
  end

  def test_timezoned_attributes
    xml = {
      created_at: Time.utc(1999, 2, 2),
      local_created_at: Time.utc(1999, 2, 2).in_time_zone("Eastern Time (US & Canada)")
    }.to_xml(@xml_options)
    assert_match %r{<created-at type="dateTime">1999-02-02T00:00:00Z</created-at>}, xml
    assert_match %r{<local-created-at type="dateTime">1999-02-01T19:00:00-05:00</local-created-at>}, xml
  end

  def test_multiple_records_from_xml_with_attributes_other_than_type_ignores_them_without_exploding
    topics_xml = <<-EOT
      <topics type="array" page="1" page-count="1000" per-page="2">
        <topic>
          <title>The First Topic</title>
          <author-name>David</author-name>
          <id type="integer">1</id>
          <approved type="boolean">false</approved>
          <replies-count type="integer">0</replies-count>
          <replies-close-in type="integer">2592000000</replies-close-in>
          <written-on type="date">2003-07-16</written-on>
          <viewed-at type="datetime">2003-07-16T09:28:00+0000</viewed-at>
          <content>Have a nice day</content>
          <author-email-address>david@loudthinking.com</author-email-address>
          <parent-id nil="true"></parent-id>
        </topic>
        <topic>
          <title>The Second Topic</title>
          <author-name>Jason</author-name>
          <id type="integer">1</id>
          <approved type="boolean">false</approved>
          <replies-count type="integer">0</replies-count>
          <replies-close-in type="integer">2592000000</replies-close-in>
          <written-on type="date">2003-07-16</written-on>
          <viewed-at type="datetime">2003-07-16T09:28:00+0000</viewed-at>
          <content>Have a nice day</content>
          <author-email-address>david@loudthinking.com</author-email-address>
          <parent-id></parent-id>
        </topic>
      </topics>
    EOT

    expected_topic_hash = {
      title: "The First Topic",
      author_name: "David",
      id: 1,
      approved: false,
      replies_count: 0,
      replies_close_in: 2592000000,
      written_on: Date.new(2003, 7, 16),
      viewed_at: Time.utc(2003, 7, 16, 9, 28),
      content: "Have a nice day",
      author_email_address: "david@loudthinking.com",
      parent_id: nil
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topics_xml)["topics"].first
  end

  def test_single_record_from_xml
    topic_xml = <<-EOT
      <topic>
        <title>The First Topic</title>
        <author-name>David</author-name>
        <id type="integer">1</id>
        <approved type="boolean"> true </approved>
        <replies-count type="integer">0</replies-count>
        <replies-close-in type="integer">2592000000</replies-close-in>
        <written-on type="date">2003-07-16</written-on>
        <viewed-at type="datetime">2003-07-16T09:28:00+0000</viewed-at>
        <author-email-address>david@loudthinking.com</author-email-address>
        <parent-id></parent-id>
        <ad-revenue type="decimal">1.5</ad-revenue>
        <optimum-viewing-angle type="float">135</optimum-viewing-angle>
      </topic>
    EOT

    expected_topic_hash = {
      title: "The First Topic",
      author_name: "David",
      id: 1,
      approved: true,
      replies_count: 0,
      replies_close_in: 2592000000,
      written_on: Date.new(2003, 7, 16),
      viewed_at: Time.utc(2003, 7, 16, 9, 28),
      author_email_address: "david@loudthinking.com",
      parent_id: nil,
      ad_revenue: BigDecimal("1.50"),
      optimum_viewing_angle: 135.0,
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topic_xml)["topic"]
  end

  def test_single_record_from_xml_with_nil_values
    topic_xml = <<-EOT
      <topic>
        <title></title>
        <id type="integer"></id>
        <approved type="boolean"></approved>
        <written-on type="date"></written-on>
        <viewed-at type="datetime"></viewed-at>
        <parent-id></parent-id>
      </topic>
    EOT

    expected_topic_hash = {
      title: nil,
      id: nil,
      approved: nil,
      written_on: nil,
      viewed_at: nil,
      parent_id: nil
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topic_xml)["topic"]
  end

  def test_multiple_records_from_xml
    topics_xml = <<-EOT
      <topics type="array">
        <topic>
          <title>The First Topic</title>
          <author-name>David</author-name>
          <id type="integer">1</id>
          <approved type="boolean">false</approved>
          <replies-count type="integer">0</replies-count>
          <replies-close-in type="integer">2592000000</replies-close-in>
          <written-on type="date">2003-07-16</written-on>
          <viewed-at type="datetime">2003-07-16T09:28:00+0000</viewed-at>
          <content>Have a nice day</content>
          <author-email-address>david@loudthinking.com</author-email-address>
          <parent-id nil="true"></parent-id>
        </topic>
        <topic>
          <title>The Second Topic</title>
          <author-name>Jason</author-name>
          <id type="integer">1</id>
          <approved type="boolean">false</approved>
          <replies-count type="integer">0</replies-count>
          <replies-close-in type="integer">2592000000</replies-close-in>
          <written-on type="date">2003-07-16</written-on>
          <viewed-at type="datetime">2003-07-16T09:28:00+0000</viewed-at>
          <content>Have a nice day</content>
          <author-email-address>david@loudthinking.com</author-email-address>
          <parent-id></parent-id>
        </topic>
      </topics>
    EOT

    expected_topic_hash = {
      title: "The First Topic",
      author_name: "David",
      id: 1,
      approved: false,
      replies_count: 0,
      replies_close_in: 2592000000,
      written_on: Date.new(2003, 7, 16),
      viewed_at: Time.utc(2003, 7, 16, 9, 28),
      content: "Have a nice day",
      author_email_address: "david@loudthinking.com",
      parent_id: nil
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topics_xml)["topics"].first
  end

  def test_single_record_from_xml_with_attributes_other_than_type
    topic_xml = <<-EOT
    <rsp stat="ok">
      <photos page="1" pages="1" perpage="100" total="16">
        <photo id="175756086" owner="55569174@N00" secret="0279bf37a1" server="76" title="Colored Pencil PhotoBooth Fun" ispublic="1" isfriend="0" isfamily="0"/>
      </photos>
    </rsp>
    EOT

    expected_topic_hash = {
      id: "175756086",
      owner: "55569174@N00",
      secret: "0279bf37a1",
      server: "76",
      title: "Colored Pencil PhotoBooth Fun",
      ispublic: "1",
      isfriend: "0",
      isfamily: "0",
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topic_xml)["rsp"]["photos"]["photo"]
  end

  def test_all_caps_key_from_xml
    test_xml = <<-EOT
      <ABC3XYZ>
        <TEST>Lorem Ipsum</TEST>
      </ABC3XYZ>
    EOT

    expected_hash = {
      "ABC3XYZ" => {
        "TEST" => "Lorem Ipsum"
      }
    }

    assert_equal expected_hash, Hash.from_xml(test_xml)
  end

  def test_empty_array_from_xml
    blog_xml = <<-XML
      <blog>
        <posts type="array"></posts>
      </blog>
    XML
    expected_blog_hash = { "blog" => { "posts" => [] } }
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_empty_array_with_whitespace_from_xml
    blog_xml = <<-XML
      <blog>
        <posts type="array">
        </posts>
      </blog>
    XML
    expected_blog_hash = { "blog" => { "posts" => [] } }
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_array_with_one_entry_from_xml
    blog_xml = <<-XML
      <blog>
        <posts type="array">
          <post>a post</post>
        </posts>
      </blog>
    XML
    expected_blog_hash = { "blog" => { "posts" => ["a post"] } }
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_array_with_multiple_entries_from_xml
    blog_xml = <<-XML
      <blog>
        <posts type="array">
          <post>a post</post>
          <post>another post</post>
        </posts>
      </blog>
    XML
    expected_blog_hash = { "blog" => { "posts" => ["a post", "another post"] } }
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_file_from_xml
    blog_xml = <<-XML
      <blog>
        <logo type="file" name="logo.png" content_type="image/png">
        </logo>
      </blog>
    XML
    hash = Hash.from_xml(blog_xml)
    assert hash.has_key?("blog")
    assert hash["blog"].has_key?("logo")

    file = hash["blog"]["logo"]
    assert_equal "logo.png", file.original_filename
    assert_equal "image/png", file.content_type
  end

  def test_file_from_xml_with_defaults
    blog_xml = <<-XML
      <blog>
        <logo type="file">
        </logo>
      </blog>
    XML
    file = Hash.from_xml(blog_xml)["blog"]["logo"]
    assert_equal "untitled", file.original_filename
    assert_equal "application/octet-stream", file.content_type
  end

  def test_tag_with_attrs_and_whitespace
    xml = <<-XML
      <blog name="bacon is the best">
      </blog>
    XML
    hash = Hash.from_xml(xml)
    assert_equal "bacon is the best", hash["blog"]["name"]
  end

  def test_empty_cdata_from_xml
    xml = "<data><![CDATA[]]></data>"

    assert_equal "", Hash.from_xml(xml)["data"]
  end

  def test_xsd_like_types_from_xml
    bacon_xml = <<-EOT
    <bacon>
      <weight type="double">0.5</weight>
      <price type="decimal">12.50</price>
      <chunky type="boolean"> 1 </chunky>
      <expires-at type="dateTime">2007-12-25T12:34:56+0000</expires-at>
      <notes type="string"></notes>
      <illustration type="base64Binary">YmFiZS5wbmc=</illustration>
      <caption type="binary" encoding="base64">VGhhdCdsbCBkbywgcGlnLg==</caption>
    </bacon>
    EOT

    expected_bacon_hash = {
      weight: 0.5,
      chunky: true,
      price: BigDecimal("12.50"),
      expires_at: Time.utc(2007, 12, 25, 12, 34, 56),
      notes: "",
      illustration: "babe.png",
      caption: "That'll do, pig."
    }.stringify_keys

    assert_equal expected_bacon_hash, Hash.from_xml(bacon_xml)["bacon"]
  end

  def test_type_trickles_through_when_unknown
    product_xml = <<-EOT
    <product>
      <weight type="double">0.5</weight>
      <image type="ProductImage"><filename>image.gif</filename></image>

    </product>
    EOT

    expected_product_hash = {
      weight: 0.5,
      image: { "type" => "ProductImage", "filename" => "image.gif" },
    }.stringify_keys

    assert_equal expected_product_hash, Hash.from_xml(product_xml)["product"]
  end

  def test_from_xml_raises_on_disallowed_type_attributes
    assert_raise ActiveSupport::XMLConverter::DisallowedType do
      Hash.from_xml '<product><name type="foo">value</name></product>', %w(foo)
    end
  end

  def test_from_xml_disallows_symbol_and_yaml_types_by_default
    assert_raise ActiveSupport::XMLConverter::DisallowedType do
      Hash.from_xml '<product><name type="symbol">value</name></product>'
    end

    assert_raise ActiveSupport::XMLConverter::DisallowedType do
      Hash.from_xml '<product><name type="yaml">value</name></product>'
    end
  end

  def test_from_xml_array_one
    expected = { "numbers" => { "type" => "Array", "value" => "1" } }
    assert_equal expected, Hash.from_xml('<numbers type="Array"><value>1</value></numbers>')
  end

  def test_from_xml_array_many
    expected = { "numbers" => { "type" => "Array", "value" => [ "1", "2" ] } }
    assert_equal expected, Hash.from_xml('<numbers type="Array"><value>1</value><value>2</value></numbers>')
  end

  def test_from_trusted_xml_allows_symbol_and_yaml_types
    expected = { "product" => { "name" => :value } }
    assert_equal expected, Hash.from_trusted_xml('<product><name type="symbol">value</name></product>')
    assert_equal expected, Hash.from_trusted_xml('<product><name type="yaml">:value</name></product>')
  end

  # The XML builder seems to fail miserably when trying to tag something
  # with the same name as a Kernel method (throw, test, loop, select ...)
  def test_kernel_method_names_to_xml
    hash     = { throw: { ball: "red" } }
    expected = "<person><throw><ball>red</ball></throw></person>"

    assert_nothing_raised do
      assert_equal expected, hash.to_xml(@xml_options)
    end
  end

  def test_empty_string_works_for_typecast_xml_value
    assert_nothing_raised do
      ActiveSupport::XMLConverter.new("").to_h
    end
  end

  def test_escaping_to_xml
    hash = {
      bare_string: "First & Last Name",
      pre_escaped_string: "First &amp; Last Name"
    }.stringify_keys

    expected_xml = "<person><bare-string>First &amp; Last Name</bare-string><pre-escaped-string>First &amp;amp; Last Name</pre-escaped-string></person>"
    assert_equal expected_xml, hash.to_xml(@xml_options)
  end

  def test_unescaping_from_xml
    xml_string = "<person><bare-string>First &amp; Last Name</bare-string><pre-escaped-string>First &amp;amp; Last Name</pre-escaped-string></person>"
    expected_hash = {
      bare_string: "First & Last Name",
      pre_escaped_string: "First &amp; Last Name"
    }.stringify_keys
    assert_equal expected_hash, Hash.from_xml(xml_string)["person"]
  end

  def test_roundtrip_to_xml_from_xml
    hash = {
      bare_string: "First & Last Name",
      pre_escaped_string: "First &amp; Last Name"
    }.stringify_keys

    assert_equal hash, Hash.from_xml(hash.to_xml(@xml_options))["person"]
  end

  def test_datetime_xml_type_with_utc_time
    alert_xml = <<-XML
      <alert>
        <alert_at type="datetime">2008-02-10T15:30:45Z</alert_at>
      </alert>
    XML
    alert_at = Hash.from_xml(alert_xml)["alert"]["alert_at"]
    assert_predicate alert_at, :utc?
    assert_equal Time.utc(2008, 2, 10, 15, 30, 45), alert_at
  end

  def test_datetime_xml_type_with_non_utc_time
    alert_xml = <<-XML
      <alert>
        <alert_at type="datetime">2008-02-10T10:30:45-05:00</alert_at>
      </alert>
    XML
    alert_at = Hash.from_xml(alert_xml)["alert"]["alert_at"]
    assert_predicate alert_at, :utc?
    assert_equal Time.utc(2008, 2, 10, 15, 30, 45), alert_at
  end

  def test_datetime_xml_type_with_far_future_date
    alert_xml = <<-XML
      <alert>
        <alert_at type="datetime">2050-02-10T15:30:45Z</alert_at>
      </alert>
    XML
    alert_at = Hash.from_xml(alert_xml)["alert"]["alert_at"]
    assert_predicate alert_at, :utc?
    assert_equal 2050,  alert_at.year
    assert_equal 2,     alert_at.month
    assert_equal 10,    alert_at.day
    assert_equal 15,    alert_at.hour
    assert_equal 30,    alert_at.min
    assert_equal 45,    alert_at.sec
  end

  def test_to_xml_dups_options
    options = { skip_instruct: true }
    {}.to_xml(options)
    # :builder, etc, shouldn't be added to options
    assert_equal({ skip_instruct: true }, options)
  end

  def test_expansion_count_is_limited
    expected =
      case ActiveSupport::XmlMini.backend.name
      when "ActiveSupport::XmlMini_REXML";        RuntimeError
      when "ActiveSupport::XmlMini_Nokogiri";     Nokogiri::XML::SyntaxError
      when "ActiveSupport::XmlMini_NokogiriSAX";  RuntimeError
      when "ActiveSupport::XmlMini_LibXML";       LibXML::XML::Error
      when "ActiveSupport::XmlMini_LibXMLSAX";    LibXML::XML::Error
      end

    assert_raise expected do
      attack_xml = <<-EOT
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE member [
        <!ENTITY a "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
        <!ENTITY b "&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;">
        <!ENTITY c "&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;">
        <!ENTITY d "&e;&e;&e;&e;&e;&e;&e;&e;&e;&e;">
        <!ENTITY e "&f;&f;&f;&f;&f;&f;&f;&f;&f;&f;">
        <!ENTITY f "&g;&g;&g;&g;&g;&g;&g;&g;&g;&g;">
        <!ENTITY g "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx">
      ]>
      <member>
      &a;
      </member>
      EOT
      Hash.from_xml(attack_xml)
    end
  end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/hash/indifferent_access"

class IndifferentTransformValuesTest < ActiveSupport::TestCase
  test "indifferent access is still indifferent after mapping values" do
    original = { a: "a", b: "b" }.with_indifferent_access
    mapped = original.transform_values { |v| v + "!" }

# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/digest/uuid"

class DigestUUIDExt < ActiveSupport::TestCase
  def test_v3_uuids
    assert_equal "3d813cbb-47fb-32ba-91df-831e1593ac29", Digest::UUID.uuid_v3(Digest::UUID::DNS_NAMESPACE, "www.widgets.com")
    assert_equal "86df55fb-428e-3843-8583-ba3c05f290bc", Digest::UUID.uuid_v3(Digest::UUID::URL_NAMESPACE, "http://www.widgets.com")
    assert_equal "8c29ab0e-a2dc-3482-b5eb-20cb2e2387a1", Digest::UUID.uuid_v3(Digest::UUID::OID_NAMESPACE, "1.2.3")
    assert_equal "ee49149d-53a4-304a-890b-468229f6afc3", Digest::UUID.uuid_v3(Digest::UUID::X500_NAMESPACE, "cn=John Doe, ou=People, o=Acme, Inc., c=US")
  end

  def test_v5_uuids
    assert_equal "21f7f8de-8051-5b89-8680-0195ef798b6a", Digest::UUID.uuid_v5(Digest::UUID::DNS_NAMESPACE, "www.widgets.com")
    assert_equal "4e570fd8-186d-5a74-90f0-4d28e34673a1", Digest::UUID.uuid_v5(Digest::UUID::URL_NAMESPACE, "http://www.widgets.com")
    assert_equal "42d5e23b-3a02-5135-85c6-52d1102f1f00", Digest::UUID.uuid_v5(Digest::UUID::OID_NAMESPACE, "1.2.3")
    assert_equal "fd5b2ddf-bcfe-58b6-90d6-db50f74db527", Digest::UUID.uuid_v5(Digest::UUID::X500_NAMESPACE, "cn=John Doe, ou=People, o=Acme, Inc., c=US")
  end

  def test_invalid_hash_class
    assert_raise ArgumentError do
      Digest::UUID.uuid_from_hash(Digest::SHA2, Digest::UUID::OID_NAMESPACE, "1.2.3")
    end
  end
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/securerandom"

class SecureRandomTest < ActiveSupport::TestCase
  def test_base58
    s1 = SecureRandom.base58
    s2 = SecureRandom.base58

    assert_not_equal s1, s2
    assert_equal 16, s1.length
  end

  def test_base58_with_length
    s1 = SecureRandom.base58(24)
    s2 = SecureRandom.base58(24)

    assert_not_equal s1, s2
    assert_equal 24, s1.length
  end

  def test_base36
    s1 = SecureRandom.base36
    s2 = SecureRandom.base36

    assert_not_equal s1, s2
    assert_equal 16, s1.length
    assert_match(/^[a-z0-9]+$/, s1)
    assert_match(/^[a-z0-9]+$/, s2)
  end

  def test_base36_with_length
    s1 = SecureRandom.base36(24)
    s2 = SecureRandom.base36(24)

    assert_not_equal s1, s2
    assert_equal 24, s1.length
    assert_match(/^[a-z0-9]+$/, s1)
    assert_match(/^[a-z0-9]+$/, s2)
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/big_decimal"

class BigDecimalTest < ActiveSupport::TestCase
  def test_to_s
    bd = BigDecimal "0.01"
    assert_equal "0.01", bd.to_s
    assert_equal "+0.01", bd.to_s("+F")
# frozen_string_literal: true

require_relative "../abstract_unit"

module DateAndTimeBehavior
  def test_yesterday
    assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).yesterday
    assert_equal date_time_init(2005, 2, 28, 10, 10, 10), date_time_init(2005, 3, 2, 10, 10, 10).yesterday.yesterday
  end

  def test_tomorrow
    assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).tomorrow
    assert_equal date_time_init(2005, 3, 2, 10, 10, 10),  date_time_init(2005, 2, 28, 10, 10, 10).tomorrow.tomorrow
  end

  def test_days_ago
    assert_equal date_time_init(2005, 6, 4, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).days_ago(1)
    assert_equal date_time_init(2005, 5, 31, 10, 10, 10),   date_time_init(2005, 6, 5, 10, 10, 10).days_ago(5)
  end

  def test_days_since
    assert_equal date_time_init(2005, 6, 6, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).days_since(1)
    assert_equal date_time_init(2005, 1, 1, 10, 10, 10), date_time_init(2004, 12, 31, 10, 10, 10).days_since(1)
  end

  def test_weeks_ago
    assert_equal date_time_init(2005, 5, 29, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).weeks_ago(1)
    assert_equal date_time_init(2005, 5, 1, 10, 10, 10),   date_time_init(2005, 6, 5, 10, 10, 10).weeks_ago(5)
    assert_equal date_time_init(2005, 4, 24, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).weeks_ago(6)
    assert_equal date_time_init(2005, 2, 27, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).weeks_ago(14)
    assert_equal date_time_init(2004, 12, 25, 10, 10, 10), date_time_init(2005, 1, 1, 10, 10, 10).weeks_ago(1)
  end

  def test_weeks_since
    assert_equal date_time_init(2005, 7, 14, 10, 10, 10), date_time_init(2005, 7, 7, 10, 10, 10).weeks_since(1)
    assert_equal date_time_init(2005, 7, 14, 10, 10, 10), date_time_init(2005, 7, 7, 10, 10, 10).weeks_since(1)
    assert_equal date_time_init(2005, 7, 4, 10, 10, 10),  date_time_init(2005, 6, 27, 10, 10, 10).weeks_since(1)
    assert_equal date_time_init(2005, 1, 4, 10, 10, 10),  date_time_init(2004, 12, 28, 10, 10, 10).weeks_since(1)
  end

  def test_months_ago
    assert_equal date_time_init(2005, 5, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).months_ago(1)
    assert_equal date_time_init(2004, 11, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).months_ago(7)
    assert_equal date_time_init(2004, 12, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).months_ago(6)
    assert_equal date_time_init(2004, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).months_ago(12)
    assert_equal date_time_init(2003, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).months_ago(24)
  end

  def test_months_since
    assert_equal date_time_init(2005, 7, 5, 10, 10, 10),   date_time_init(2005, 6, 5, 10, 10, 10).months_since(1)
    assert_equal date_time_init(2006, 1, 5, 10, 10, 10),   date_time_init(2005, 12, 5, 10, 10, 10).months_since(1)
    assert_equal date_time_init(2005, 12, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).months_since(6)
    assert_equal date_time_init(2006, 6, 5, 10, 10, 10),   date_time_init(2005, 12, 5, 10, 10, 10).months_since(6)
    assert_equal date_time_init(2006, 1, 5, 10, 10, 10),   date_time_init(2005, 6, 5, 10, 10, 10).months_since(7)
    assert_equal date_time_init(2006, 6, 5, 10, 10, 10),   date_time_init(2005, 6, 5, 10, 10, 10).months_since(12)
    assert_equal date_time_init(2007, 6, 5, 10, 10, 10),   date_time_init(2005, 6, 5, 10, 10, 10).months_since(24)
    assert_equal date_time_init(2005, 4, 30, 10, 10, 10),  date_time_init(2005, 3, 31, 10, 10, 10).months_since(1)
    assert_equal date_time_init(2005, 2, 28, 10, 10, 10),  date_time_init(2005, 1, 29, 10, 10, 10).months_since(1)
    assert_equal date_time_init(2005, 2, 28, 10, 10, 10),  date_time_init(2005, 1, 30, 10, 10, 10).months_since(1)
    assert_equal date_time_init(2005, 2, 28, 10, 10, 10),  date_time_init(2005, 1, 31, 10, 10, 10).months_since(1)
  end

  def test_years_ago
    assert_equal date_time_init(2004, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).years_ago(1)
    assert_equal date_time_init(1998, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).years_ago(7)
    assert_equal date_time_init(2003, 2, 28, 10, 10, 10), date_time_init(2004, 2, 29, 10, 10, 10).years_ago(1) # 1 year ago from leap day
  end

  def test_years_since
    assert_equal date_time_init(2006, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).years_since(1)
    assert_equal date_time_init(2012, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).years_since(7)
    assert_equal date_time_init(2005, 2, 28, 10, 10, 10), date_time_init(2004, 2, 29, 10, 10, 10).years_since(1) # 1 year since leap day
    assert_equal date_time_init(2182, 6, 5, 10, 10, 10),  date_time_init(2005, 6, 5, 10, 10, 10).years_since(177)
  end

  def test_beginning_of_month
    assert_equal date_time_init(2005, 2, 1, 0, 0, 0), date_time_init(2005, 2, 22, 10, 10, 10).beginning_of_month
  end

  def test_beginning_of_quarter
    assert_equal date_time_init(2005, 1, 1, 0, 0, 0),  date_time_init(2005, 2, 15, 10, 10, 10).beginning_of_quarter
    assert_equal date_time_init(2005, 1, 1, 0, 0, 0),  date_time_init(2005, 1, 1, 0, 0, 0).beginning_of_quarter
    assert_equal date_time_init(2005, 10, 1, 0, 0, 0), date_time_init(2005, 12, 31, 10, 10, 10).beginning_of_quarter
    assert_equal date_time_init(2005, 4, 1, 0, 0, 0),  date_time_init(2005, 6, 30, 23, 59, 59).beginning_of_quarter
  end

  def test_end_of_quarter
    assert_equal date_time_init(2007, 3, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 2, 15, 10, 10, 10).end_of_quarter
    assert_equal date_time_init(2007, 3, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 3, 31, 0, 0, 0).end_of_quarter
    assert_equal date_time_init(2007, 12, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 12, 21, 10, 10, 10).end_of_quarter
    assert_equal date_time_init(2007, 6, 30, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 4, 1, 0, 0, 0).end_of_quarter
    assert_equal date_time_init(2008, 6, 30, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2008, 5, 31, 0, 0, 0).end_of_quarter
  end

  def test_beginning_of_year
    assert_equal date_time_init(2005, 1, 1, 0, 0, 0), date_time_init(2005, 2, 22, 10, 10, 10).beginning_of_year
  end

  def test_next_week
    #   M   |   T  | W | T | F | S | S #   M   | T |   W   | T |  F  | S | S #
    #       | 22/2 |   |   |   |   |   # 28/2  |   |       |   |     |   |   # monday in next week `next_week`
    #       | 22/2 |   |   |   |   |   #       |   |       |   | 4/3 |   |   # friday in next week `next_week(:friday)`
    # 23/10 |      |   |   |   |   |   # 30/10 |   |       |   |     |   |   # monday in next week `next_week`
    # 23/10 |      |   |   |   |   |   #       |   |  1/11 |   |     |   |   # wednesday in next week `next_week(:wednesday)`
    assert_equal date_time_init(2005, 2, 28, 0, 0, 0),  date_time_init(2005, 2, 22, 15, 15, 10).next_week
    assert_equal date_time_init(2005, 3, 4, 0, 0, 0),   date_time_init(2005, 2, 22, 15, 15, 10).next_week(:friday)
    assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 10, 23, 0, 0, 0).next_week
    assert_equal date_time_init(2006, 11, 1, 0, 0, 0),  date_time_init(2006, 10, 23, 0, 0, 0).next_week(:wednesday)
  end

  def test_next_week_with_default_beginning_of_week_set
    with_bw_default(:tuesday) do
      assert_equal Time.local(2012, 3, 28), Time.local(2012, 3, 21).next_week(:wednesday)
      assert_equal Time.local(2012, 3, 31), Time.local(2012, 3, 21).next_week(:saturday)
      assert_equal Time.local(2012, 3, 27), Time.local(2012, 3, 21).next_week(:tuesday)
      assert_equal Time.local(2012, 4, 02), Time.local(2012, 3, 21).next_week(:monday)
    end
  end

  def test_next_week_at_same_time
    assert_equal date_time_init(2005, 2, 28, 15, 15, 10), date_time_init(2005, 2, 22, 15, 15, 10).next_week(:monday, same_time: true)
    assert_equal date_time_init(2005, 2, 28, 15, 15, 10, 999999), date_time_init(2005, 2, 22, 15, 15, 10, 999999).next_week(:monday, same_time: true)
    assert_equal date_time_init(2005, 2, 28, 15, 15, 10, Rational(999999999, 1000)), date_time_init(2005, 2, 22, 15, 15, 10, Rational(999999999, 1000)).next_week(:monday, same_time: true)
    assert_equal date_time_init(2005, 3, 4, 15, 15, 10),   date_time_init(2005, 2, 22, 15, 15, 10).next_week(:friday, same_time: true)
    assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 10, 23, 0, 0, 0).next_week(:monday, same_time: true)
    assert_equal date_time_init(2006, 11, 1, 0, 0, 0),  date_time_init(2006, 10, 23, 0, 0, 0).next_week(:wednesday, same_time: true)
  end

  def test_next_weekday_on_wednesday
    assert_equal date_time_init(2015, 1, 8, 0, 0, 0), date_time_init(2015, 1, 7, 0, 0, 0).next_weekday
    assert_equal date_time_init(2015, 1, 8, 15, 15, 10), date_time_init(2015, 1, 7, 15, 15, 10).next_weekday
  end

  def test_next_weekday_on_friday
    assert_equal date_time_init(2015, 1, 5, 0, 0, 0), date_time_init(2015, 1, 2, 0, 0, 0).next_weekday
    assert_equal date_time_init(2015, 1, 5, 15, 15, 10), date_time_init(2015, 1, 2, 15, 15, 10).next_weekday
  end

  def test_next_weekday_on_saturday
    assert_equal date_time_init(2015, 1, 5, 0, 0, 0), date_time_init(2015, 1, 3, 0, 0, 0).next_weekday
    assert_equal date_time_init(2015, 1, 5, 15, 15, 10), date_time_init(2015, 1, 3, 15, 15, 10).next_weekday
  end

  def test_next_month_on_31st
    assert_equal date_time_init(2005, 9, 30, 15, 15, 10), date_time_init(2005, 8, 31, 15, 15, 10).next_month
  end

  def test_next_quarter_on_31st
    assert_equal date_time_init(2005, 11, 30, 15, 15, 10), date_time_init(2005, 8, 31, 15, 15, 10).next_quarter
  end

  def test_prev_week
    assert_equal date_time_init(2005, 2, 21, 0, 0, 0),  date_time_init(2005, 3, 1, 15, 15, 10).prev_week
    assert_equal date_time_init(2005, 2, 22, 0, 0, 0),  date_time_init(2005, 3, 1, 15, 15, 10).prev_week(:tuesday)
    assert_equal date_time_init(2005, 2, 25, 0, 0, 0),  date_time_init(2005, 3, 1, 15, 15, 10).prev_week(:friday)
    assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 11, 6, 0, 0, 0).prev_week
    assert_equal date_time_init(2006, 11, 15, 0, 0, 0), date_time_init(2006, 11, 23, 0, 0, 0).prev_week(:wednesday)
  end

  def test_prev_week_with_default_beginning_of_week
    with_bw_default(:tuesday) do
      assert_equal Time.local(2012, 3, 14), Time.local(2012, 3, 21).prev_week(:wednesday)
      assert_equal Time.local(2012, 3, 17), Time.local(2012, 3, 21).prev_week(:saturday)
      assert_equal Time.local(2012, 3, 13), Time.local(2012, 3, 21).prev_week(:tuesday)
      assert_equal Time.local(2012, 3, 19), Time.local(2012, 3, 21).prev_week(:monday)
    end
  end

  def test_prev_week_at_same_time
    assert_equal date_time_init(2005, 2, 21, 15, 15, 10),  date_time_init(2005, 3, 1, 15, 15, 10).prev_week(:monday, same_time: true)
    assert_equal date_time_init(2005, 2, 22, 15, 15, 10),  date_time_init(2005, 3, 1, 15, 15, 10).prev_week(:tuesday, same_time: true)
    assert_equal date_time_init(2005, 2, 25, 15, 15, 10),  date_time_init(2005, 3, 1, 15, 15, 10).prev_week(:friday, same_time: true)
    assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 11, 6, 0, 0, 0).prev_week(:monday, same_time: true)
    assert_equal date_time_init(2006, 11, 15, 0, 0, 0), date_time_init(2006, 11, 23, 0, 0, 0).prev_week(:wednesday, same_time: true)
  end

  def test_prev_weekday_on_wednesday
    assert_equal date_time_init(2015, 1, 6, 0, 0, 0), date_time_init(2015, 1, 7, 0, 0, 0).prev_weekday
    assert_equal date_time_init(2015, 1, 6, 15, 15, 10), date_time_init(2015, 1, 7, 15, 15, 10).prev_weekday
  end

  def test_prev_weekday_on_monday
    assert_equal date_time_init(2015, 1, 2, 0, 0, 0), date_time_init(2015, 1, 5, 0, 0, 0).prev_weekday
    assert_equal date_time_init(2015, 1, 2, 15, 15, 10), date_time_init(2015, 1, 5, 15, 15, 10).prev_weekday
  end

  def test_prev_weekday_on_sunday
    assert_equal date_time_init(2015, 1, 2, 0, 0, 0), date_time_init(2015, 1, 4, 0, 0, 0).prev_weekday
    assert_equal date_time_init(2015, 1, 2, 15, 15, 10), date_time_init(2015, 1, 4, 15, 15, 10).prev_weekday
  end

  def test_prev_month_on_31st
    assert_equal date_time_init(2004, 2, 29, 10, 10, 10), date_time_init(2004, 3, 31, 10, 10, 10).prev_month
  end

  def test_prev_quarter_on_31st
    assert_equal date_time_init(2004, 2, 29, 10, 10, 10), date_time_init(2004, 5, 31, 10, 10, 10).prev_quarter
  end

  def test_last_month_on_31st
    assert_equal date_time_init(2004, 2, 29, 0, 0, 0), date_time_init(2004, 3, 31, 0, 0, 0).last_month
  end

  def test_last_year
    assert_equal date_time_init(2004, 6, 5, 10, 0, 0), date_time_init(2005, 6, 5, 10, 0, 0).last_year
  end

  def test_days_to_week_start
    assert_equal 0, date_time_init(2011, 11, 01, 0, 0, 0).days_to_week_start(:tuesday)
    assert_equal 1, date_time_init(2011, 11, 02, 0, 0, 0).days_to_week_start(:tuesday)
    assert_equal 2, date_time_init(2011, 11, 03, 0, 0, 0).days_to_week_start(:tuesday)
    assert_equal 3, date_time_init(2011, 11, 04, 0, 0, 0).days_to_week_start(:tuesday)
    assert_equal 4, date_time_init(2011, 11, 05, 0, 0, 0).days_to_week_start(:tuesday)
    assert_equal 5, date_time_init(2011, 11, 06, 0, 0, 0).days_to_week_start(:tuesday)
    assert_equal 6, date_time_init(2011, 11, 07, 0, 0, 0).days_to_week_start(:tuesday)

    assert_equal 3, date_time_init(2011, 11, 03, 0, 0, 0).days_to_week_start(:monday)
    assert_equal 3, date_time_init(2011, 11, 04, 0, 0, 0).days_to_week_start(:tuesday)
    assert_equal 3, date_time_init(2011, 11, 05, 0, 0, 0).days_to_week_start(:wednesday)
    assert_equal 3, date_time_init(2011, 11, 06, 0, 0, 0).days_to_week_start(:thursday)
    assert_equal 3, date_time_init(2011, 11, 07, 0, 0, 0).days_to_week_start(:friday)
    assert_equal 3, date_time_init(2011, 11, 8, 0, 0, 0).days_to_week_start(:saturday)
    assert_equal 3, date_time_init(2011, 11, 9, 0, 0, 0).days_to_week_start(:sunday)
  end

  def test_days_to_week_start_with_default_set
    with_bw_default(:friday) do
      assert_equal 6, Time.local(2012, 03, 8, 0, 0, 0).days_to_week_start
      assert_equal 5, Time.local(2012, 03, 7, 0, 0, 0).days_to_week_start
      assert_equal 4, Time.local(2012, 03, 6, 0, 0, 0).days_to_week_start
      assert_equal 3, Time.local(2012, 03, 5, 0, 0, 0).days_to_week_start
      assert_equal 2, Time.local(2012, 03, 4, 0, 0, 0).days_to_week_start
      assert_equal 1, Time.local(2012, 03, 3, 0, 0, 0).days_to_week_start
      assert_equal 0, Time.local(2012, 03, 2, 0, 0, 0).days_to_week_start
    end
  end

  def test_beginning_of_week
    assert_equal date_time_init(2005, 1, 31, 0, 0, 0),  date_time_init(2005, 2, 4, 10, 10, 10).beginning_of_week
    assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 11, 28, 0, 0, 0).beginning_of_week # monday
    assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 11, 29, 0, 0, 0).beginning_of_week # tuesday
    assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 11, 30, 0, 0, 0).beginning_of_week # wednesday
    assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 01, 0, 0, 0).beginning_of_week # thursday
    assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 02, 0, 0, 0).beginning_of_week # friday
    assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 03, 0, 0, 0).beginning_of_week # saturday
    assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 04, 0, 0, 0).beginning_of_week # sunday
  end

  def test_end_of_week
    assert_equal date_time_init(2008, 1, 6, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 12, 31, 10, 10, 10).end_of_week
    assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 27, 0, 0, 0).end_of_week # monday
    assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 28, 0, 0, 0).end_of_week # tuesday
    assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 29, 0, 0, 0).end_of_week # wednesday
    assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 30, 0, 0, 0).end_of_week # thursday
    assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 31, 0, 0, 0).end_of_week # friday
    assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 9, 01, 0, 0, 0).end_of_week # saturday
    assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 9, 02, 0, 0, 0).end_of_week # sunday
  end

  def test_end_of_month
    assert_equal date_time_init(2005, 3, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2005, 3, 20, 10, 10, 10).end_of_month
    assert_equal date_time_init(2005, 2, 28, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2005, 2, 20, 10, 10, 10).end_of_month
    assert_equal date_time_init(2005, 4, 30, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2005, 4, 20, 10, 10, 10).end_of_month
  end

  def test_end_of_year
    assert_equal date_time_init(2007, 12, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 2, 22, 10, 10, 10).end_of_year
    assert_equal date_time_init(2007, 12, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 12, 31, 10, 10, 10).end_of_year
  end

  def test_next_occurring
    assert_equal date_time_init(2017, 12, 18, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:monday)
    assert_equal date_time_init(2017, 12, 19, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:tuesday)
    assert_equal date_time_init(2017, 12, 20, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:wednesday)
    assert_equal date_time_init(2017, 12, 21, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:thursday)
    assert_equal date_time_init(2017, 12, 15, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:friday)
    assert_equal date_time_init(2017, 12, 16, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:saturday)
    assert_equal date_time_init(2017, 12, 17, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:sunday)
  end

  def test_prev_occurring
    assert_equal date_time_init(2017, 12, 11, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:monday)
    assert_equal date_time_init(2017, 12, 12, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:tuesday)
    assert_equal date_time_init(2017, 12, 13, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:wednesday)
    assert_equal date_time_init(2017, 12,  7, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:thursday)
    assert_equal date_time_init(2017, 12,  8, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:friday)
    assert_equal date_time_init(2017, 12,  9, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:saturday)
    assert_equal date_time_init(2017, 12, 10, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:sunday)
  end

  def test_monday_with_default_beginning_of_week_set
    with_bw_default(:saturday) do
      assert_equal date_time_init(2012, 9, 17, 0, 0, 0), date_time_init(2012, 9, 18, 0, 0, 0).monday
    end
  end

  def test_sunday_with_default_beginning_of_week_set
    with_bw_default(:wednesday) do
      assert_equal date_time_init(2012, 9, 23, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2012, 9, 19, 0, 0, 0).sunday
    end
  end

  def test_on_weekend_on_saturday
    assert_predicate date_time_init(2015, 1, 3, 0, 0, 0), :on_weekend?
    assert_predicate date_time_init(2015, 1, 3, 15, 15, 10), :on_weekend?
  end

  def test_on_weekend_on_sunday
    assert_predicate date_time_init(2015, 1, 4, 0, 0, 0), :on_weekend?
    assert_predicate date_time_init(2015, 1, 4, 15, 15, 10), :on_weekend?
  end

  def test_on_weekend_on_monday
    assert_not_predicate date_time_init(2015, 1, 5, 0, 0, 0), :on_weekend?
    assert_not_predicate date_time_init(2015, 1, 5, 15, 15, 10), :on_weekend?
  end

  def test_on_weekday_on_sunday
    assert_not_predicate date_time_init(2015, 1, 4, 0, 0, 0), :on_weekday?
    assert_not_predicate date_time_init(2015, 1, 4, 15, 15, 10), :on_weekday?
  end

  def test_on_weekday_on_monday
    assert_predicate date_time_init(2015, 1, 5, 0, 0, 0), :on_weekday?
    assert_predicate date_time_init(2015, 1, 5, 15, 15, 10), :on_weekday?
  end

  def test_before
    assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).before?(date_time_init(2017, 3, 5, 12, 0, 0))
    assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).before?(date_time_init(2017, 3, 6, 12, 0, 0))
    assert_equal true, date_time_init(2017, 3, 6, 12, 0, 0).before?(date_time_init(2017, 3, 7, 12, 0, 0))
  end

  def test_after
    assert_equal true, date_time_init(2017, 3, 6, 12, 0, 0).after?(date_time_init(2017, 3, 5, 12, 0, 0))
    assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).after?(date_time_init(2017, 3, 6, 12, 0, 0))
    assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).after?(date_time_init(2017, 3, 7, 12, 0, 0))
  end

  def with_bw_default(bw = :monday)
    old_bw = Date.beginning_of_week
    Date.beginning_of_week = bw
    yield
  ensure
    Date.beginning_of_week = old_bw
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/load_error"

class TestLoadError < ActiveSupport::TestCase
  def test_with_require
    assert_raise(LoadError) { require "no_this_file_don't_exist" }
  end

  def test_with_load
    assert_raise(LoadError) { load "nor_does_this_one" }
  end

  def test_path
    load "nor/this/one.rb"
  rescue LoadError => e
    assert_equal "nor/this/one.rb", e.path
  end

# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/file"

class AtomicWriteTest < ActiveSupport::TestCase
  def test_atomic_write_without_errors
    contents = "Atomic Text"
    File.atomic_write(file_name, Dir.pwd) do |file|
      file.write(contents)
      assert_not File.exist?(file_name)
    end
    assert File.exist?(file_name)
    assert_equal contents, File.read(file_name)
  ensure
    File.unlink(file_name) rescue nil
  end

  def test_atomic_write_doesnt_write_when_block_raises
    File.atomic_write(file_name) do |file|
      file.write("testing")
      raise "something bad"
    end
  rescue
    assert_not File.exist?(file_name)
  end

  def test_atomic_write_preserves_file_permissions
    contents = "Atomic Text"
    File.open(file_name, "w", 0755) do |file|
      file.write(contents)
      assert File.exist?(file_name)
    end
    assert File.exist?(file_name)
    assert_equal 0100755 & ~File.umask, file_mode
    assert_equal contents, File.read(file_name)

    File.atomic_write(file_name, Dir.pwd) do |file|
      file.write(contents)
      assert File.exist?(file_name)
    end
    assert File.exist?(file_name)
    assert_equal 0100755 & ~File.umask, file_mode
    assert_equal contents, File.read(file_name)
  ensure
    File.unlink(file_name) rescue nil
  end

  def test_atomic_write_preserves_default_file_permissions
    contents = "Atomic Text"
    File.atomic_write(file_name, Dir.pwd) do |file|
      file.write(contents)
      assert_not File.exist?(file_name)
    end
    assert File.exist?(file_name)
    assert_equal File.probe_stat_in(Dir.pwd).mode, file_mode
    assert_equal contents, File.read(file_name)
  ensure
    File.unlink(file_name) rescue nil
  end

  def test_atomic_write_preserves_file_permissions_same_directory
    Dir.mktmpdir do |temp_dir|
      File.chmod 0700, temp_dir

      probed_permissions = File.probe_stat_in(temp_dir).mode.to_s(8)

      File.atomic_write(File.join(temp_dir, file_name), &:close)

      actual_permissions = File.stat(File.join(temp_dir, file_name)).mode.to_s(8)

      assert_equal actual_permissions, probed_permissions
    end
  end

  def test_atomic_write_returns_result_from_yielded_block
    block_return_value = File.atomic_write(file_name, Dir.pwd) do |file|
      "Hello world!"
    end

    assert_equal "Hello world!", block_return_value
  ensure
    File.unlink(file_name) rescue nil
  end

  private
    def file_name
      "atomic-#{Process.pid}.file"
    end

# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/time"
require_relative "../time_zone_test_helpers"

class DateAndTimeCompatibilityTest < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def setup
    @utc_time = Time.utc(2016, 4, 23, 14, 11, 12)
    @date_time = DateTime.new(2016, 4, 23, 14, 11, 12, 0)
    @utc_offset = 3600
    @system_offset = -14400
    @zone = ActiveSupport::TimeZone["London"]
  end

  def test_time_to_time_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = Time.new(2016, 4, 23, 15, 11, 12, 3600)
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @utc_offset, time.utc_offset
        assert_equal source.object_id, time.object_id
      end
    end
  end

  def test_time_to_time_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = Time.new(2016, 4, 23, 15, 11, 12, 3600)
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @system_offset, time.utc_offset
        assert_not_equal source.object_id, time.object_id
      end
    end
  end

  def test_time_to_time_frozen_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = Time.new(2016, 4, 23, 15, 11, 12, 3600).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @utc_offset, time.utc_offset
        assert_equal source.object_id, time.object_id
        assert_predicate time, :frozen?
      end
    end
  end

  def test_time_to_time_frozen_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = Time.new(2016, 4, 23, 15, 11, 12, 3600).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @system_offset, time.utc_offset
        assert_not_equal source.object_id, time.object_id
        assert_not_predicate time, :frozen?
      end
    end
  end

  def test_datetime_to_time_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = DateTime.new(2016, 4, 23, 15, 11, 12, Rational(1, 24))
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @utc_offset, time.utc_offset
      end
    end
  end

  def test_datetime_to_time_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = DateTime.new(2016, 4, 23, 15, 11, 12, Rational(1, 24))
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @system_offset, time.utc_offset
      end
    end
  end

  def test_datetime_to_time_frozen_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = DateTime.new(2016, 4, 23, 15, 11, 12, Rational(1, 24)).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @utc_offset, time.utc_offset
        assert_not_predicate time, :frozen?
      end
    end
  end

  def test_datetime_to_time_frozen_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = DateTime.new(2016, 4, 23, 15, 11, 12, Rational(1, 24)).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @system_offset, time.utc_offset
        assert_not_predicate time, :frozen?
      end
    end
  end

  def test_twz_to_time_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = ActiveSupport::TimeWithZone.new(@utc_time, @zone)
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @utc_offset, time.utc_offset

        source = ActiveSupport::TimeWithZone.new(@date_time, @zone)
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @date_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @utc_offset, time.utc_offset
      end
    end
  end

  def test_twz_to_time_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = ActiveSupport::TimeWithZone.new(@utc_time, @zone)
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @system_offset, time.utc_offset

        source = ActiveSupport::TimeWithZone.new(@date_time, @zone)
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @date_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @system_offset, time.utc_offset
      end
    end
  end

  def test_twz_to_time_frozen_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = ActiveSupport::TimeWithZone.new(@utc_time, @zone).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @utc_offset, time.utc_offset
        assert_not_predicate time, :frozen?

        source = ActiveSupport::TimeWithZone.new(@date_time, @zone).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @date_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @utc_offset, time.utc_offset
        assert_not_predicate time, :frozen?
      end
    end
  end

  def test_twz_to_time_frozen_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = ActiveSupport::TimeWithZone.new(@utc_time, @zone).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @system_offset, time.utc_offset
        assert_not_predicate time, :frozen?

        source = ActiveSupport::TimeWithZone.new(@date_time, @zone).freeze
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @date_time, time.getutc
        assert_instance_of Time, time.getutc
        assert_equal @system_offset, time.utc_offset
        assert_not_predicate time, :frozen?
      end
    end
  end

  def test_string_to_time_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = "2016-04-23T15:11:12+01:00"
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @utc_offset, time.utc_offset
      end
    end
  end

  def test_string_to_time_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = "2016-04-23T15:11:12+01:00"
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @system_offset, time.utc_offset
      end
    end
  end

  def test_string_to_time_frozen_preserves_timezone
    with_preserve_timezone(true) do
      with_env_tz "US/Eastern" do
        source = "2016-04-23T15:11:12+01:00"
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @utc_offset, time.utc_offset
        assert_not_predicate time, :frozen?
      end
    end
  end

  def test_string_to_time_frozen_does_not_preserve_time_zone
    with_preserve_timezone(false) do
      with_env_tz "US/Eastern" do
        source = "2016-04-23T15:11:12+01:00"
        time = source.to_time

        assert_instance_of Time, time
        assert_equal @utc_time, time.getutc
        assert_equal @system_offset, time.utc_offset
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/module"

Somewhere = Struct.new(:street, :city) do
  attr_accessor :name
end

Someone = Struct.new(:name, :place) do
  delegate :street, :city, :to_f, to: :place
  delegate :name=, to: :place, prefix: true
  delegate :upcase, to: "place.city"
  delegate :table_name, to: :class
  delegate :table_name, to: :class, prefix: true

  def self.table_name
    "some_table"
  end

  self::FAILED_DELEGATE_LINE = __LINE__ + 1
  delegate :foo, to: :place

  self::FAILED_DELEGATE_LINE_2 = __LINE__ + 1
  delegate :bar, to: :place, allow_nil: true

  def kw_send(method:)
    public_send(method)
  end

  private
    def private_name
      "Private"
    end
end

Invoice = Struct.new(:client) do
  delegate :street, :city, :name, to: :client, prefix: true
  delegate :street, :city, :name, to: :client, prefix: :customer
end

Project = Struct.new(:description, :person) do
  delegate :name, to: :person, allow_nil: true
  delegate :to_f, to: :description, allow_nil: true
end

Developer = Struct.new(:client) do
  delegate :name, to: :client, prefix: nil
end

Event = Struct.new(:case) do
  delegate :foo, to: :case
end

Tester = Struct.new(:client) do
  delegate :name, to: :client, prefix: false

  def foo; 1; end
end

Product = Struct.new(:name) do
  delegate :name, to: :manufacturer, prefix: true
  delegate :name, to: :type, prefix: true

  def manufacturer
    @manufacturer ||= begin
      nil.unknown_method
    end
  end

  def type
    @type ||= begin
      nil.type_name
    end
  end
end

module ExtraMissing
  def method_missing(sym, *args)
    if sym == :extra_missing
      42
    else
      super
    end
  end

  def respond_to_missing?(sym, priv = false)
    sym == :extra_missing || super
  end
end

DecoratedTester = Struct.new(:client) do
  include ExtraMissing

  delegate_missing_to :client
end

class DecoratedMissingAllowNil
  delegate_missing_to :case, allow_nil: true

  attr_reader :case

  def initialize(kase)
    @case = kase
  end
end

class DecoratedReserved
  delegate_missing_to :case

  attr_reader :case

  def initialize(kase)
    @case = kase
  end
end

class Maze
  attr_accessor :cavern, :passages
end

class Cavern
  delegate_missing_to :target

  attr_reader :maze

  def initialize(maze)
    @maze = maze
  end

  def target
    @maze.passages = :twisty
  end
end

class Block
  def hello?
    true
  end
end

HasBlock = Struct.new(:block) do
  delegate :hello?, to: :block
end

class ParameterSet
  delegate :[], :[]=, to: :@params

  def initialize
    @params = { foo: "bar" }
  end
end

class Name
  delegate :upcase, to: :@full_name

  def initialize(first, last)
    @full_name = "#{first} #{last}"
  end
end

class SideEffect
  attr_reader :ints

  delegate :to_i, to: :shift, allow_nil: true
  delegate :to_s, to: :shift

  def initialize
    @ints = [1, 2, 3]
  end

  def shift
    @ints.shift
  end
end

class ModuleTest < ActiveSupport::TestCase
  def setup
    @david = Someone.new("David", Somewhere.new("Paulina", "Chicago"))
  end

  def test_delegation_to_methods
    assert_equal "Paulina", @david.street
    assert_equal "Chicago", @david.city
  end

  def test_delegation_to_assignment_method
    @david.place_name = "Fred"
    assert_equal "Fred", @david.place.name
  end

  def test_delegation_to_index_get_method
    @params = ParameterSet.new
    assert_equal "bar", @params[:foo]
  end

  def test_delegation_to_index_set_method
    @params = ParameterSet.new
    @params[:foo] = "baz"
    assert_equal "baz", @params[:foo]
  end

  def test_delegation_down_hierarchy
    assert_equal "CHICAGO", @david.upcase
  end

  def test_delegation_to_instance_variable
    david = Name.new("David", "Hansson")
    assert_equal "DAVID HANSSON", david.upcase
  end

  def test_delegation_to_class_method
    assert_equal "some_table", @david.table_name
    assert_equal "some_table", @david.class_table_name
  end

  def test_missing_delegation_target
    assert_raise(ArgumentError) do
      Name.send :delegate, :nowhere
    end
    assert_raise(ArgumentError) do
      Name.send :delegate, :noplace, tos: :hollywood
    end
  end

  def test_delegation_target_when_prefix_is_true
    assert_nothing_raised do
      Name.send :delegate, :go, to: :you, prefix: true
    end
    assert_nothing_raised do
      Name.send :delegate, :go, to: :_you, prefix: true
    end
    assert_raise(ArgumentError) do
      Name.send :delegate, :go, to: :You, prefix: true
    end
    assert_raise(ArgumentError) do
      Name.send :delegate, :go, to: :@you, prefix: true
    end
  end

  def test_delegation_prefix
    invoice = Invoice.new(@david)
    assert_equal "David", invoice.client_name
    assert_equal "Paulina", invoice.client_street
    assert_equal "Chicago", invoice.client_city
  end

  def test_delegation_custom_prefix
    invoice = Invoice.new(@david)
    assert_equal "David", invoice.customer_name
    assert_equal "Paulina", invoice.customer_street
    assert_equal "Chicago", invoice.customer_city
  end

  def test_delegation_prefix_with_nil_or_false
    assert_equal "David", Developer.new(@david).name
    assert_equal "David", Tester.new(@david).name
  end

  def test_delegation_prefix_with_instance_variable
    assert_raise ArgumentError do
      Class.new do
        def initialize(client)
          @client = client
        end
        delegate :name, :address, to: :@client, prefix: true
      end
    end
  end

  def test_delegation_with_allow_nil
    rails = Project.new("Rails", Someone.new("David"))
    assert_equal "David", rails.name
  end

  def test_delegation_with_allow_nil_and_nil_value
    rails = Project.new("Rails")
    assert_nil rails.name
  end

  # Ensures with check for nil, not for a falsy target.
  def test_delegation_with_allow_nil_and_false_value
    project = Project.new(false, false)
    assert_raise(NoMethodError) { project.name }
  end

  def test_delegation_with_allow_nil_and_invalid_value
    rails = Project.new("Rails", "David")
    assert_raise(NoMethodError) { rails.name }
  end

  def test_delegation_with_allow_nil_and_nil_value_and_prefix
    Project.class_eval do
      delegate :name, to: :person, allow_nil: true, prefix: true
    end
    rails = Project.new("Rails")
    assert_nil rails.person_name
  end

  def test_delegation_without_allow_nil_and_nil_value
    david = Someone.new("David")
    assert_raise(Module::DelegationError) { david.street }
  end

  def test_delegation_to_method_that_exists_on_nil
    nil_person = Someone.new(nil)
    assert_equal 0.0, nil_person.to_f
  end

  def test_delegation_to_method_that_exists_on_nil_when_allowing_nil
    nil_project = Project.new(nil)
    assert_equal 0.0, nil_project.to_f
  end

  def test_delegation_does_not_raise_error_when_removing_singleton_instance_methods
    parent = Class.new do
      def self.parent_method; end
    end

    assert_nothing_raised do
      Class.new(parent) do
        class << self
          delegate :parent_method, to: :superclass
        end
      end
    end
  end

  def test_delegation_line_number
    _, line = Someone.instance_method(:foo).source_location
    assert_equal Someone::FAILED_DELEGATE_LINE, line
  end

  def test_delegate_line_with_nil
    _, line = Someone.instance_method(:bar).source_location
    assert_equal Someone::FAILED_DELEGATE_LINE_2, line
  end

  def test_delegation_exception_backtrace
    someone = Someone.new("foo", "bar")
    someone.foo
  rescue NoMethodError => e
    file_and_line = "#{__FILE__}:#{Someone::FAILED_DELEGATE_LINE}"
    # We can't simply check the first line of the backtrace, because JRuby reports the call to __send__ in the backtrace.
    assert e.backtrace.any? { |a| a.include?(file_and_line) },
           "[#{e.backtrace.inspect}] did not include [#{file_and_line}]"
  end

  def test_delegation_exception_backtrace_with_allow_nil
    someone = Someone.new("foo", "bar")
    someone.bar
  rescue NoMethodError => e
    file_and_line = "#{__FILE__}:#{Someone::FAILED_DELEGATE_LINE_2}"
    # We can't simply check the first line of the backtrace, because JRuby reports the call to __send__ in the backtrace.
    assert e.backtrace.any? { |a| a.include?(file_and_line) },
           "[#{e.backtrace.inspect}] did not include [#{file_and_line}]"
  end

  def test_delegation_invokes_the_target_exactly_once
    se = SideEffect.new

    assert_equal 1, se.to_i
    assert_equal [2, 3], se.ints

    assert_equal "2", se.to_s
    assert_equal [3], se.ints
  end

  def test_delegation_doesnt_mask_nested_no_method_error_on_nil_receiver
    product = Product.new("Widget")

    # Nested NoMethodError is a different name from the delegation
    assert_raise(NoMethodError) { product.manufacturer_name }

    # Nested NoMethodError is the same name as the delegation
    assert_raise(NoMethodError) { product.type_name }
  end

  def test_delegation_with_method_arguments
    has_block = HasBlock.new(Block.new)
    assert_predicate has_block, :hello?
  end

  def test_delegate_missing_to_with_method
    assert_equal "David", DecoratedTester.new(@david).name
  end

  def test_delegate_missing_to_with_reserved_methods
    assert_equal "David", DecoratedReserved.new(@david).name
  end

  def test_delegate_missing_to_with_keyword_methods
    assert_equal "David", DecoratedReserved.new(@david).kw_send(method: "name")
  end

  def test_delegate_missing_to_does_not_delegate_to_private_methods
    e = assert_raises(NoMethodError) do
      DecoratedReserved.new(@david).private_name
    end

    assert_match(/undefined method `private_name' for/, e.message)
  end

  def test_delegate_missing_to_does_not_delegate_to_fake_methods
    e = assert_raises(NoMethodError) do
      DecoratedReserved.new(@david).my_fake_method
    end

    assert_match(/undefined method `my_fake_method' for/, e.message)
  end

  def test_delegate_missing_to_raises_delegation_error_if_target_nil
    e = assert_raises(Module::DelegationError) do
      DecoratedTester.new(nil).name
    end

    assert_equal "name delegated to client, but client is nil", e.message
  end

  def test_delegate_missing_to_returns_nil_if_allow_nil_and_nil_target
    assert_nil DecoratedMissingAllowNil.new(nil).name
  end

  def test_delegate_missing_to_affects_respond_to
    assert_respond_to DecoratedTester.new(@david), :name
    assert_not_respond_to DecoratedTester.new(@david), :private_name
    assert_not_respond_to DecoratedTester.new(@david), :my_fake_method

    assert DecoratedTester.new(@david).respond_to?(:name, true)
    assert_not DecoratedTester.new(@david).respond_to?(:private_name, true)
    assert_not DecoratedTester.new(@david).respond_to?(:my_fake_method, true)
  end

  def test_delegate_missing_to_respects_superclass_missing
    assert_equal 42, DecoratedTester.new(@david).extra_missing

    assert_respond_to DecoratedTester.new(@david), :extra_missing
  end

  def test_delegate_missing_to_does_not_interfere_with_marshallization
    maze = Maze.new
    maze.cavern = Cavern.new(maze)

    array = [maze, nil]
    serialized_array = Marshal.dump(array)
    deserialized_array = Marshal.load(serialized_array)

    assert_nil deserialized_array[1]
  end

  def test_delegate_with_case
    event = Event.new(Tester.new)
    assert_equal 1, event.foo
  end

  def test_private_delegate
    location = Class.new do
      def initialize(place)
        @place = place
      end

      private(*delegate(:street, :city, to: :@place))
    end

    place = location.new(Somewhere.new("Such street", "Sad city"))

    assert_not_respond_to place, :street
    assert_not_respond_to place, :city

    assert place.respond_to?(:street, true) # Asking for private method
    assert place.respond_to?(:city, true)
  end

  def test_private_delegate_prefixed
    location = Class.new do
      def initialize(place)
        @place = place
      end

      private(*delegate(:street, :city, to: :@place, prefix: :the))
    end

    place = location.new(Somewhere.new("Such street", "Sad city"))

    assert_not_respond_to place, :street
    assert_not_respond_to place, :city

    assert_not_respond_to place, :the_street
    assert place.respond_to?(:the_street, true)
    assert_not_respond_to place, :the_city
    assert place.respond_to?(:the_city, true)
  end

  def test_private_delegate_with_private_option
    location = Class.new do
      def initialize(place)
        @place = place
      end

      delegate(:street, :city, to: :@place, private: true)
    end

    place = location.new(Somewhere.new("Such street", "Sad city"))

    assert_not_respond_to place, :street
    assert_not_respond_to place, :city

    assert place.respond_to?(:street, true) # Asking for private method
    assert place.respond_to?(:city, true)
  end

  def test_some_public_some_private_delegate_with_private_option
    location = Class.new do
      def initialize(place)
        @place = place
      end

      delegate(:street, to: :@place)
      delegate(:city, to: :@place, private: true)
    end

    place = location.new(Somewhere.new("Such street", "Sad city"))

    assert_respond_to place, :street
    assert_not_respond_to place, :city

    assert place.respond_to?(:city, true) # Asking for private method
  end

  def test_private_delegate_prefixed_with_private_option
    location = Class.new do
      def initialize(place)
        @place = place
      end

      delegate(:street, :city, to: :@place, prefix: :the, private: true)
    end

    place = location.new(Somewhere.new("Such street", "Sad city"))

    assert_not_respond_to place, :the_street
    assert place.respond_to?(:the_street, true)
    assert_not_respond_to place, :the_city
    assert place.respond_to?(:the_city, true)
  end

  def test_delegate_with_private_option_returns_names_of_delegate_methods
    location = Class.new do
      def initialize(place)
        @place = place
      end
    end

    assert_equal [:street, :city],
      location.delegate(:street, :city, to: :@place, private: true)
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/core_ext/name_error"

class NameErrorTest < ActiveSupport::TestCase
  def test_name_error_should_set_missing_name
    exc = assert_raise NameError do
      SomeNameThatNobodyWillUse____Really ? 1 : 0
    end
    assert_equal "NameErrorTest::SomeNameThatNobodyWillUse____Really", exc.missing_name
    assert exc.missing_name?(:SomeNameThatNobodyWillUse____Really)
    assert exc.missing_name?("NameErrorTest::SomeNameThatNobodyWillUse____Really")
    assert_equal NameErrorTest, exc.receiver
  end

  def test_missing_method_should_ignore_missing_name
    exc = assert_raise NameError do
      some_method_that_does_not_exist
    end
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/time"
require "active_support/core_ext/numeric"
require "active_support/core_ext/integer"

class NumericExtTimeAndDateTimeTest < ActiveSupport::TestCase
  def setup
    @now = Time.local(2005, 2, 10, 15, 30, 45)
    @dtnow = DateTime.civil(2005, 2, 10, 15, 30, 45)
    @seconds = {
      1.minute   => 60,
      10.minutes => 600,
      1.hour + 15.minutes => 4500,
      2.days + 4.hours + 30.minutes => 189000,
      5.years + 1.month + 1.fortnight => 161624106
    }
  end

  def test_units
    @seconds.each do |actual, expected|
      assert_equal expected, actual
    end
  end

  def test_irregular_durations
    assert_equal @now.advance(days: 3000), 3000.days.since(@now)
    assert_equal @now.advance(months: 1), 1.month.since(@now)
    assert_equal @now.advance(months: -1), 1.month.until(@now)
    assert_equal @now.advance(years: 20), 20.years.since(@now)
    assert_equal @dtnow.advance(days: 3000), 3000.days.since(@dtnow)
    assert_equal @dtnow.advance(months: 1), 1.month.since(@dtnow)
    assert_equal @dtnow.advance(months: -1), 1.month.until(@dtnow)
    assert_equal @dtnow.advance(years: 20), 20.years.since(@dtnow)
  end

  def test_duration_addition
    assert_equal @now.advance(days: 1).advance(months: 1), (1.day + 1.month).since(@now)
    assert_equal @now.advance(days: 7), (1.week + 5.seconds - 5.seconds).since(@now)
    assert_equal @now.advance(years: 2), (4.years - 2.years).since(@now)
    assert_equal @dtnow.advance(days: 1).advance(months: 1), (1.day + 1.month).since(@dtnow)
    assert_equal @dtnow.advance(days: 7), (1.week + 5.seconds - 5.seconds).since(@dtnow)
    assert_equal @dtnow.advance(years: 2), (4.years - 2.years).since(@dtnow)
  end

  def test_time_plus_duration
    assert_equal @now + 8, @now + 8.seconds
    assert_equal @now + 22.9, @now + 22.9.seconds
    assert_equal @now.advance(days: 15), @now + 15.days
    assert_equal @now.advance(months: 1), @now + 1.month
    assert_equal @dtnow.since(8), @dtnow + 8.seconds
    assert_equal @dtnow.since(22.9), @dtnow + 22.9.seconds
    assert_equal @dtnow.advance(days: 15), @dtnow + 15.days
    assert_equal @dtnow.advance(months: 1), @dtnow + 1.month
  end

  def test_chaining_duration_operations
    assert_equal @now.advance(days: 2).advance(months: -3), @now + 2.days - 3.months
    assert_equal @now.advance(days: 1).advance(months: 2), @now + 1.day + 2.months
    assert_equal @dtnow.advance(days: 2).advance(months: -3), @dtnow + 2.days - 3.months
    assert_equal @dtnow.advance(days: 1).advance(months: 2), @dtnow + 1.day + 2.months
  end

  def test_duration_after_conversion_is_no_longer_accurate
    assert_equal (1.year / 12).to_i.seconds.since(@now), 1.month.to_i.seconds.since(@now)
    assert_equal 365.2425.days.to_f.seconds.since(@now), 1.year.to_f.seconds.since(@now)
    assert_equal (1.year / 12).to_i.seconds.since(@dtnow), 1.month.to_i.seconds.since(@dtnow)
    assert_equal 365.2425.days.to_f.seconds.since(@dtnow), 1.year.to_f.seconds.since(@dtnow)
  end

  def test_add_one_year_to_leap_day
    assert_equal Time.utc(2005, 2, 28, 15, 15, 10), Time.utc(2004, 2, 29, 15, 15, 10) + 1.year
    assert_equal DateTime.civil(2005, 2, 28, 15, 15, 10), DateTime.civil(2004, 2, 29, 15, 15, 10) + 1.year
  end
end

class NumericExtDateTest < ActiveSupport::TestCase
  def setup
    @today = Date.today
  end

  def test_date_plus_duration
    assert_equal @today + 1, @today + 1.day
    assert_equal @today >> 1, @today + 1.month
    assert_equal @today.to_time.since(1), @today + 1.second
    assert_equal @today.to_time.since(60), @today + 1.minute
    assert_equal @today.to_time.since(60 * 60), @today + 1.hour
  end

  def test_chaining_duration_operations
    assert_equal @today.advance(days: 2).advance(months: -3), @today + 2.days - 3.months
    assert_equal @today.advance(days: 1).advance(months: 2), @today + 1.day + 2.months
  end

  def test_add_one_year_to_leap_day
    assert_equal Date.new(2005, 2, 28), Date.new(2004, 2, 29) + 1.year
  end
end

class NumericExtSizeTest < ActiveSupport::TestCase
  def test_unit_in_terms_of_another
    assert_equal 1024.bytes, 1.kilobyte
    assert_equal 1024.kilobytes, 1.megabyte
    assert_equal 3584.0.kilobytes, 3.5.megabytes
    assert_equal 3584.0.megabytes, 3.5.gigabytes
    assert_equal 1.kilobyte**4, 1.terabyte
    assert_equal 1024.kilobytes + 2.megabytes, 3.megabytes
    assert_equal 2.gigabytes / 4, 512.megabytes
    assert_equal 256.megabytes * 20 + 5.gigabytes, 10.gigabytes
    assert_equal 1.kilobyte**5, 1.petabyte
    assert_equal 1.kilobyte**6, 1.exabyte
  end

  def test_units_as_bytes_independently
    assert_equal 3145728, 3.megabytes
    assert_equal 3145728, 3.megabyte
    assert_equal 3072, 3.kilobytes
    assert_equal 3072, 3.kilobyte
    assert_equal 3221225472, 3.gigabytes
    assert_equal 3221225472, 3.gigabyte
    assert_equal 3298534883328, 3.terabytes
    assert_equal 3298534883328, 3.terabyte
    assert_equal 3377699720527872, 3.petabytes
    assert_equal 3377699720527872, 3.petabyte
    assert_equal 3458764513820540928, 3.exabytes
    assert_equal 3458764513820540928, 3.exabyte
  end
end

class NumericExtFormattingTest < ActiveSupport::TestCase
  def kilobytes(number)
    number * 1024
  end

  def megabytes(number)
    kilobytes(number) * 1024
  end

  def gigabytes(number)
    megabytes(number) * 1024
  end

  def terabytes(number)
    gigabytes(number) * 1024
  end

  def petabytes(number)
    terabytes(number) * 1024
  end

  def exabytes(number)
    petabytes(number) * 1024
  end

  def test_to_s__phone
    assert_equal("555-1234", 5551234.to_s(:phone))
    assert_equal("800-555-1212", 8005551212.to_s(:phone))
    assert_equal("(800) 555-1212", 8005551212.to_s(:phone, area_code: true))
    assert_equal("800 555 1212", 8005551212.to_s(:phone, delimiter: " "))
    assert_equal("(800) 555-1212 x 123", 8005551212.to_s(:phone, area_code: true, extension: 123))
    assert_equal("800-555-1212", 8005551212.to_s(:phone, extension: "  "))
    assert_equal("555.1212", 5551212.to_s(:phone, delimiter: "."))
    assert_equal("+1-800-555-1212", 8005551212.to_s(:phone, country_code: 1))
    assert_equal("+18005551212", 8005551212.to_s(:phone, country_code: 1, delimiter: ""))
    assert_equal("22-555-1212", 225551212.to_s(:phone))
    assert_equal("+45-22-555-1212", 225551212.to_s(:phone, country_code: 45))
  end

  def test_to_s__currency
    assert_equal("$1,234,567,890.50", 1234567890.50.to_s(:currency))
    assert_equal("$1,234,567,890.51", 1234567890.506.to_s(:currency))
    assert_equal("-$1,234,567,890.50", -1234567890.50.to_s(:currency))
    assert_equal("-$ 1,234,567,890.50", -1234567890.50.to_s(:currency, format: "%u %n"))
    assert_equal("($1,234,567,890.50)", -1234567890.50.to_s(:currency, negative_format: "(%u%n)"))
    assert_equal("$1,234,567,892", 1234567891.50.to_s(:currency, precision: 0))
    assert_equal("$1,234,567,891", 1234567891.50.to_s(:currency, precision: 0, round_mode: :down))
    assert_equal("$1,234,567,890.5", 1234567890.50.to_s(:currency, precision: 1))
    assert_equal("&pound;1234567890,50", 1234567890.50.to_s(:currency, unit: "&pound;", separator: ",", delimiter: ""))
  end

  def test_to_s__rounded
    assert_equal("-111.235", -111.2346.to_s(:rounded))
    assert_equal("111.235", 111.2346.to_s(:rounded))
    assert_equal("31.83", 31.825.to_s(:rounded, precision: 2))
    assert_equal("31.82", 31.825.to_s(:rounded, precision: 2, round_mode: :down))
    assert_equal("111.23", 111.2346.to_s(:rounded, precision: 2))
    assert_equal("111.00", 111.to_s(:rounded, precision: 2))
    assert_equal("3268", (32.6751 * 100.00).to_s(:rounded, precision: 0))
    assert_equal("112", 111.50.to_s(:rounded, precision: 0))
    assert_equal("1234567892", 1234567891.50.to_s(:rounded, precision: 0))
    assert_equal("0", 0.to_s(:rounded, precision: 0))
    assert_equal("0.00100", 0.001.to_s(:rounded, precision: 5))
    assert_equal("0.001", 0.00111.to_s(:rounded, precision: 3))
    assert_equal("10.00", 9.995.to_s(:rounded, precision: 2))
    assert_equal("11.00", 10.995.to_s(:rounded, precision: 2))
    assert_equal("0.00", -0.001.to_s(:rounded, precision: 2))
  end

  def test_to_s__percentage
    assert_equal("100.000%", 100.to_s(:percentage))
    assert_equal("100%", 100.to_s(:percentage, precision: 0))
    assert_equal("302.06%", 302.0574.to_s(:percentage, precision: 2))
    assert_equal("302.05%", 302.0574.to_s(:percentage, precision: 2, round_mode: :down))
    assert_equal("123.4%", 123.400.to_s(:percentage, precision: 3, strip_insignificant_zeros: true))
    assert_equal("1.000,000%", 1000.to_s(:percentage, delimiter: ".", separator: ","))
    assert_equal("1000.000  %", 1000.to_s(:percentage, format: "%n  %"))
  end

  def test_to_s__delimited
    assert_equal("12,345,678", 12345678.to_s(:delimited))
    assert_equal("0", 0.to_s(:delimited))
    assert_equal("123", 123.to_s(:delimited))
    assert_equal("123,456", 123456.to_s(:delimited))
    assert_equal("123,456.78", 123456.78.to_s(:delimited))
    assert_equal("123,456.789", 123456.789.to_s(:delimited))
    assert_equal("123,456.78901", 123456.78901.to_s(:delimited))
    assert_equal("123,456,789.78901", 123456789.78901.to_s(:delimited))
    assert_equal("0.78901", 0.78901.to_s(:delimited))
  end

  def test_to_s__delimited__with_options_hash
    assert_equal "12 345 678", 12345678.to_s(:delimited, delimiter: " ")
    assert_equal "12,345,678-05", 12345678.05.to_s(:delimited, separator: "-")
    assert_equal "12.345.678,05", 12345678.05.to_s(:delimited, separator: ",", delimiter: ".")
    assert_equal "12.345.678,05", 12345678.05.to_s(:delimited, delimiter: ".", separator: ",")
  end

  def test_to_s__rounded_with_custom_delimiter_and_separator
    assert_equal "31,83",       31.825.to_s(:rounded, precision: 2, separator: ",")
    assert_equal "1.231,83",    1231.825.to_s(:rounded, precision: 2, separator: ",", delimiter: ".")
  end

  def test_to_s__rounded__with_significant_digits
    assert_equal "124000", 123987.to_s(:rounded, precision: 3, significant: true)
    assert_equal "120000000", 123987876.to_s(:rounded, precision: 2, significant: true)
    assert_equal "9775", 9775.to_s(:rounded, precision: 4, significant: true)
    assert_equal "5.4", 5.3923.to_s(:rounded, precision: 2, significant: true)
    assert_equal "5", 5.3923.to_s(:rounded, precision: 1, significant: true)
    assert_equal "1", 1.232.to_s(:rounded, precision: 1, significant: true)
    assert_equal "7", 7.to_s(:rounded, precision: 1, significant: true)
    assert_equal "1", 1.to_s(:rounded, precision: 1, significant: true)
    assert_equal "53", 52.7923.to_s(:rounded, precision: 2, significant: true)
    assert_equal "9775.00", 9775.to_s(:rounded, precision: 6, significant: true)
    assert_equal "5.392900", 5.3929.to_s(:rounded, precision: 7, significant: true)
    assert_equal "0.0", 0.to_s(:rounded, precision: 2, significant: true)
    assert_equal "0", 0.to_s(:rounded, precision: 1, significant: true)
    assert_equal "0.0001", 0.0001.to_s(:rounded, precision: 1, significant: true)
    assert_equal "0.000100", 0.0001.to_s(:rounded, precision: 3, significant: true)
    assert_equal "0.0001", 0.0001111.to_s(:rounded, precision: 1, significant: true)
    assert_equal "10.0", 9.995.to_s(:rounded, precision: 3, significant: true)
    assert_equal "9.99", 9.994.to_s(:rounded, precision: 3, significant: true)
    assert_equal "11.0", 10.995.to_s(:rounded, precision: 3, significant: true)
    assert_equal "10.9", 10.995.to_s(:rounded, precision: 3, significant: true, round_mode: :down)
  end

  def test_to_s__rounded__with_strip_insignificant_zeros
    assert_equal "9775.43", 9775.43.to_s(:rounded, precision: 4, strip_insignificant_zeros: true)
    assert_equal "9775.2", 9775.2.to_s(:rounded, precision: 6, significant: true, strip_insignificant_zeros: true)
    assert_equal "0", 0.to_s(:rounded, precision: 6, significant: true, strip_insignificant_zeros: true)
  end

  def test_to_s__rounded__with_significant_true_and_zero_precision
    # Zero precision with significant is a mistake (would always return zero),
    # so we treat it as if significant was false (increases backwards compatibility for number_to_human_size)
    assert_equal "124", 123.987.to_s(:rounded, precision: 0, significant: true)
    assert_equal "12", 12.to_s(:rounded, precision: 0, significant: true)
  end

  def test_to_s__human_size
    assert_equal "0 Bytes",   0.to_s(:human_size)
    assert_equal "1 Byte",    1.to_s(:human_size)
    assert_equal "3 Bytes",   3.14159265.to_s(:human_size)
    assert_equal "123 Bytes", 123.0.to_s(:human_size)
    assert_equal "123 Bytes", 123.to_s(:human_size)
    assert_equal "1.21 KB",   1234.to_s(:human_size)
    assert_equal "12.1 KB",   12345.to_s(:human_size)
    assert_equal "1.18 MB",   1234567.to_s(:human_size)
    assert_equal "1.15 GB",   1234567890.to_s(:human_size)
    assert_equal "1.12 TB",   1234567890123.to_s(:human_size)
    assert_equal "1.1 PB",    1234567890123456.to_s(:human_size)
    assert_equal "1.07 EB",   1234567890123456789.to_s(:human_size)
    assert_equal "1030 EB",   exabytes(1026).to_s(:human_size)
    assert_equal "444 KB",    kilobytes(444).to_s(:human_size)
    assert_equal "1020 MB",   megabytes(1023).to_s(:human_size)
    assert_equal "3 TB",      terabytes(3).to_s(:human_size)
    assert_equal "1.2 MB",    1234567.to_s(:human_size, precision: 2)
    assert_equal "3 Bytes",   3.14159265.to_s(:human_size, precision: 4)
    assert_equal "1 KB",      kilobytes(1.0123).to_s(:human_size, precision: 2)
    assert_equal "1.01 KB",   kilobytes(1.0100).to_s(:human_size, precision: 4)
    assert_equal "10 KB",     kilobytes(10.000).to_s(:human_size, precision: 4)
    assert_equal "1 Byte",    1.1.to_s(:human_size)
    assert_equal "10 Bytes",  10.to_s(:human_size)
  end

  def test_to_s__human_size_with_options_hash
    assert_equal "1.2 MB",   1234567.to_s(:human_size, precision: 2)
    assert_equal "3 Bytes",  3.14159265.to_s(:human_size, precision: 4)
    assert_equal "1 KB",     kilobytes(1.0123).to_s(:human_size, precision: 2)
    assert_equal "1.01 KB",  kilobytes(1.0100).to_s(:human_size, precision: 4)
    assert_equal "10 KB",    kilobytes(10.000).to_s(:human_size, precision: 4)
    assert_equal "1 TB",     1234567890123.to_s(:human_size, precision: 1)
    assert_equal "500 MB",   524288000.to_s(:human_size, precision: 3)
    assert_equal "10 MB",    9961472.to_s(:human_size, precision: 0)
    assert_equal "40 KB",    41010.to_s(:human_size, precision: 1)
    assert_equal "40 KB",    41100.to_s(:human_size, precision: 2)
    assert_equal "50 KB",    41100.to_s(:human_size, precision: 1, round_mode: :up)
    assert_equal "1.0 KB",   kilobytes(1.0123).to_s(:human_size, precision: 2, strip_insignificant_zeros: false)
    assert_equal "1.012 KB", kilobytes(1.0123).to_s(:human_size, precision: 3, significant: false)
    assert_equal "1 KB",     kilobytes(1.0123).to_s(:human_size, precision: 0, significant: true) # ignores significant it precision is 0
  end

  def test_to_s__human_size_with_custom_delimiter_and_separator
    assert_equal "1,01 KB",     kilobytes(1.0123).to_s(:human_size, precision: 3, separator: ",")
    assert_equal "1,01 KB",     kilobytes(1.0100).to_s(:human_size, precision: 4, separator: ",")
    assert_equal "1.000,1 TB",  terabytes(1000.1).to_s(:human_size, precision: 5, delimiter: ".", separator: ",")
  end

  def test_number_to_human
    assert_equal "-123", -123.to_s(:human)
    assert_equal "-0.5", -0.5.to_s(:human)
    assert_equal "0",   0.to_s(:human)
    assert_equal "0.5", 0.5.to_s(:human)
    assert_equal "123", 123.to_s(:human)
    assert_equal "1.23 Thousand", 1234.to_s(:human)
    assert_equal "12.3 Thousand", 12345.to_s(:human)
    assert_equal "1.23 Million", 1234567.to_s(:human)
    assert_equal "1.23 Billion", 1234567890.to_s(:human)
    assert_equal "1.23 Trillion", 1234567890123.to_s(:human)
    assert_equal "1.23 Quadrillion", 1234567890123456.to_s(:human)
    assert_equal "1230 Quadrillion", 1234567890123456789.to_s(:human)
    assert_equal "490 Thousand", 489939.to_s(:human, precision: 2)
    assert_equal "489.9 Thousand", 489939.to_s(:human, precision: 4)
    assert_equal "489 Thousand", 489000.to_s(:human, precision: 4)
    assert_equal "480 Thousand", 489939.to_s(:human, precision: 2, round_mode: :down)
    assert_equal "489.0 Thousand", 489000.to_s(:human, precision: 4, strip_insignificant_zeros: false)
    assert_equal "1.2346 Million", 1234567.to_s(:human, precision: 4, significant: false)
    assert_equal "1,2 Million", 1234567.to_s(:human, precision: 1, significant: false, separator: ",")
    assert_equal "1 Million", 1234567.to_s(:human, precision: 0, significant: true, separator: ",") # significant forced to false
  end

  def test_number_to_human_with_custom_units
    # Only integers
    volume = { unit: "ml", thousand: "lt", million: "m3" }
    assert_equal "123 lt", 123456.to_s(:human, units: volume)
    assert_equal "12 ml", 12.to_s(:human, units: volume)
    assert_equal "1.23 m3", 1234567.to_s(:human, units: volume)

    # Including fractionals
    distance = { mili: "mm", centi: "cm", deci: "dm", unit: "m", ten: "dam", hundred: "hm", thousand: "km" }
    assert_equal "1.23 mm", 0.00123.to_s(:human, units: distance)
    assert_equal "1.23 cm", 0.0123.to_s(:human, units: distance)
    assert_equal "1.23 dm", 0.123.to_s(:human, units: distance)
    assert_equal "1.23 m",  1.23.to_s(:human, units: distance)
    assert_equal "1.23 dam", 12.3.to_s(:human, units: distance)
    assert_equal "1.23 hm", 123.to_s(:human, units: distance)
    assert_equal "1.23 km", 1230.to_s(:human, units: distance)
    assert_equal "1.23 km", 1230.to_s(:human, units: distance)
    assert_equal "1.23 km", 1230.to_s(:human, units: distance)
    assert_equal "12.3 km", 12300.to_s(:human, units: distance)

    # The quantifiers don't need to be a continuous sequence
    gangster = { hundred: "hundred bucks", million: "thousand quids" }
    assert_equal "1 hundred bucks", 100.to_s(:human, units: gangster)
    assert_equal "25 hundred bucks", 2500.to_s(:human, units: gangster)
    assert_equal "25 thousand quids", 25000000.to_s(:human, units: gangster)
    assert_equal "12300 thousand quids", 12345000000.to_s(:human, units: gangster)

    # Spaces are stripped from the resulting string
    assert_equal "4", 4.to_s(:human, units: { unit: "", ten: "tens " })
    assert_equal "4.5  tens", 45.to_s(:human, units: { unit: "", ten: " tens   " })
  end

  def test_number_to_human_with_custom_format
    assert_equal "123 times Thousand", 123456.to_s(:human, format: "%n times %u")
    volume = { unit: "ml", thousand: "lt", million: "m3" }
    assert_equal "123.lt", 123456.to_s(:human, units: volume, format: "%n.%u")
  end

  def test_to_s__injected_on_proper_types
    assert_equal "1.23 Thousand", 1230.to_s(:human)
    assert_equal "1.23 Thousand", Float(1230).to_s(:human)
    assert_equal "100000 Quadrillion", (100**10).to_s(:human)
    assert_equal "1 Million", BigDecimal("1000010").to_s(:human)
  end

  def test_to_s_with_invalid_formatter
    assert_equal "123", 123.to_s(:invalid)
    assert_equal "2.5", 2.5.to_s(:invalid)
    assert_equal "100000000000000000000", (100**10).to_s(:invalid)
    assert_equal "1000010.0", BigDecimal("1000010").to_s(:invalid)
  end

  def test_default_to_s
    assert_equal "123", 123.to_s
    assert_equal "1111011", 123.to_s(2)

    assert_equal "2.5", 2.5.to_s

    assert_equal "100000000000000000000", (100**10).to_s
    assert_equal "1010110101111000111010111100010110101100011000100000000000000000000", (100**10).to_s(2)

    assert_equal "1000010.0", BigDecimal("1000010").to_s
    assert_equal "10000 10.0", BigDecimal("1000010").to_s("5F")

    assert_raises TypeError do
      1.to_s({})
    end
  end

# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/array"

class GroupingTest < ActiveSupport::TestCase
  def test_in_groups_of_with_perfect_fit
    groups = []
    ("a".."i").to_a.in_groups_of(3) do |group|
      groups << group
    end

    assert_equal [%w(a b c), %w(d e f), %w(g h i)], groups
    assert_equal [%w(a b c), %w(d e f), %w(g h i)], ("a".."i").to_a.in_groups_of(3)
  end

  def test_in_groups_of_with_padding
    groups = []
    ("a".."g").to_a.in_groups_of(3) do |group|
      groups << group
    end

    assert_equal [%w(a b c), %w(d e f), ["g", nil, nil]], groups
  end

  def test_in_groups_of_pads_with_specified_values
    groups = []

    ("a".."g").to_a.in_groups_of(3, "foo") do |group|
      groups << group
    end

    assert_equal [%w(a b c), %w(d e f), %w(g foo foo)], groups
  end

  def test_in_groups_of_without_padding
    groups = []

    ("a".."g").to_a.in_groups_of(3, false) do |group|
      groups << group
    end

    assert_equal [%w(a b c), %w(d e f), %w(g)], groups
  end

  def test_in_groups_returned_array_size
    array = (1..7).to_a

    1.upto(array.size + 1) do |number|
      assert_equal number, array.in_groups(number).size
    end
  end

  def test_in_groups_with_empty_array
    assert_equal [[], [], []], [].in_groups(3)
  end

  def test_in_groups_with_block
    array = (1..9).to_a
    groups = []

    array.in_groups(3) do |group|
      groups << group
    end

    assert_equal array.in_groups(3), groups
  end

  def test_in_groups_with_perfect_fit
    assert_equal [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
      (1..9).to_a.in_groups(3)
  end

  def test_in_groups_with_padding
    array = (1..7).to_a

    assert_equal [[1, 2, 3], [4, 5, nil], [6, 7, nil]],
      array.in_groups(3)
    assert_equal [[1, 2, 3], [4, 5, "foo"], [6, 7, "foo"]],
      array.in_groups(3, "foo")
  end

  def test_in_groups_without_padding
    assert_equal [[1, 2, 3], [4, 5], [6, 7]],
      (1..7).to_a.in_groups(3, false)
  end

  def test_in_groups_invalid_argument
    assert_raises(ArgumentError) { [].in_groups_of(0) }
    assert_raises(ArgumentError) { [].in_groups_of(-1) }
    assert_raises(ArgumentError) { [].in_groups_of(nil) }
  end
end

class SplitTest < ActiveSupport::TestCase
  def test_split_with_empty_array
    assert_equal [[]], [].split(0)
  end

  def test_split_with_argument
    a = [1, 2, 3, 4, 5]
    assert_equal [[1, 2], [4, 5]],  a.split(3)
    assert_equal [[1, 2, 3, 4, 5]], a.split(0)
    assert_equal [1, 2, 3, 4, 5], a
  end

  def test_split_with_block
    a = (1..10).to_a
    assert_equal [[1, 2], [4, 5], [7, 8], [10]], a.split { |i| i % 3 == 0 }
    assert_equal [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], a
  end

  def test_split_with_edge_values
    a = [1, 2, 3, 4, 5]
    assert_equal [[], [2, 3, 4, 5]],  a.split(1)
    assert_equal [[1, 2, 3, 4], []],  a.split(5)
    assert_equal [[], [2, 3, 4], []], a.split { |i| i == 1 || i == 5 }
    assert_equal [1, 2, 3, 4, 5], a
  end

  def test_split_with_repeated_values
    a = [1, 2, 3, 5, 5, 3, 4, 6, 2, 1, 3]
    assert_equal [[1, 2], [5, 5], [4, 6, 2, 1], []], a.split(3)
    assert_equal [[1, 2, 3], [], [3, 4, 6, 2, 1, 3]], a.split(5)
    assert_equal [[1, 2], [], [], [], [4, 6, 2, 1], []], a.split { |i| i == 3 || i == 5 }
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/array"

class WrapTest < ActiveSupport::TestCase
  class FakeCollection
    def to_ary
      ["foo", "bar"]
    end
  end

  class Proxy
    def initialize(target) @target = target end
    def method_missing(*a) @target.public_send(*a) end
  end

  class DoubtfulToAry
    def to_ary
      :not_an_array
    end
  end

  class NilToAry
    def to_ary
      nil
    end
  end

  def test_array
    ary = %w(foo bar)
    assert_same ary, Array.wrap(ary)
  end

  def test_nil
    assert_equal [], Array.wrap(nil)
  end

  def test_object
    o = Object.new
    assert_equal [o], Array.wrap(o)
  end

  def test_string
    assert_equal ["foo"], Array.wrap("foo")
  end

  def test_string_with_newline
    assert_equal ["foo\nbar"], Array.wrap("foo\nbar")
  end

  def test_object_with_to_ary
    assert_equal ["foo", "bar"], Array.wrap(FakeCollection.new)
  end

  def test_proxy_object
    p = Proxy.new(Object.new)
    assert_equal [p], Array.wrap(p)
  end

  def test_proxy_to_object_with_to_ary
    p = Proxy.new(FakeCollection.new)
    assert_equal [p], Array.wrap(p)
  end

  def test_struct
    o = Struct.new(:foo).new(123)
    assert_equal [o], Array.wrap(o)
  end

  def test_wrap_returns_wrapped_if_to_ary_returns_nil
    o = NilToAry.new
    assert_equal [o], Array.wrap(o)
  end

# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/array"

class AccessTest < ActiveSupport::TestCase
  def test_from
    assert_equal %w( a b c d ), %w( a b c d ).from(0)
    assert_equal %w( c d ), %w( a b c d ).from(2)
    assert_equal %w(), %w( a b c d ).from(10)
    assert_equal %w( d e ), %w( a b c d e ).from(-2)
    assert_equal %w(), %w( a b c d e ).from(-10)
  end

  def test_to
    assert_equal %w( a ), %w( a b c d ).to(0)
    assert_equal %w( a b c ), %w( a b c d ).to(2)
    assert_equal %w( a b c d ), %w( a b c d ).to(10)
    assert_equal %w( a b c ), %w( a b c d ).to(-2)
    assert_equal %w(), %w( a b c ).to(-10)
  end

  def test_specific_accessor
    array = (1..42).to_a

    assert_equal array[1], array.second
    assert_equal array[2], array.third
    assert_equal array[3], array.fourth
    assert_equal array[4], array.fifth
    assert_equal array[41], array.forty_two
    assert_equal array[-3], array.third_to_last
    assert_equal array[-2], array.second_to_last
  end

  def test_including
    assert_equal [1, 2, 3, 4, 5], [1, 2, 4].including(3, 5).sort
    assert_equal [1, 2, 3, 4, 5], [1, 2, 4].including([3, 5]).sort
    assert_equal [[0, 1], [1, 0]], [[0, 1]].including([[1, 0]])
  end

  def test_excluding
    assert_equal [1, 2, 4], [1, 2, 3, 4, 5].excluding(3, 5)
    assert_equal [1, 2, 4], [1, 2, 3, 4, 5].excluding([3, 5])
    assert_equal [[0, 1]], [[0, 1], [1, 0]].excluding([[1, 0]])
  end
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/array"

class ExtractTest < ActiveSupport::TestCase
  def test_extract
    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    array_id = numbers.object_id

    odd_numbers = numbers.extract!(&:odd?)

    assert_equal [1, 3, 5, 7, 9], odd_numbers
    assert_equal [0, 2, 4, 6, 8], numbers
    assert_equal array_id, numbers.object_id
  end

  def test_extract_without_block
    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    array_id = numbers.object_id

    extract_enumerator = numbers.extract!

    assert_instance_of Enumerator, extract_enumerator
    assert_equal numbers.size, extract_enumerator.size

    odd_numbers = extract_enumerator.each(&:odd?)

    assert_equal [1, 3, 5, 7, 9], odd_numbers
    assert_equal [0, 2, 4, 6, 8], numbers
    assert_equal array_id, numbers.object_id
  end

  def test_extract_on_empty_array
    empty_array = []
    array_id = empty_array.object_id

    new_empty_array = empty_array.extract! { }

    assert_equal [], new_empty_array
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/array"
require "active_support/core_ext/hash"
require "active_support/ordered_options"

class ExtractOptionsTest < ActiveSupport::TestCase
  class HashSubclass < Hash
  end

  class ExtractableHashSubclass < Hash
    def extractable_options?
      true
    end
  end

  def test_extract_options
    assert_equal({}, [].extract_options!)
    assert_equal({}, [1].extract_options!)
    assert_equal({ a: :b }, [{ a: :b }].extract_options!)
    assert_equal({ a: :b }, [1, { a: :b }].extract_options!)
  end

  def test_extract_options_doesnt_extract_hash_subclasses
    hash = HashSubclass.new
    hash[:foo] = 1
    array = [hash]
    options = array.extract_options!
    assert_equal({}, options)
    assert_equal([hash], array)
  end

  def test_extract_options_extracts_extractable_subclass
    hash = ExtractableHashSubclass.new
    hash[:foo] = 1
    array = [hash]
    options = array.extract_options!
    assert_equal({ foo: 1 }, options)
    assert_equal([], array)
  end

  def test_extract_options_extracts_hash_with_indifferent_access
    array = [{ foo: 1 }.with_indifferent_access]
    options = array.extract_options!
    assert_equal(1, options[:foo])
  end

  def test_extract_options_extracts_ordered_options
    hash = ActiveSupport::OrderedOptions.new
    hash.foo = 1
    array = [hash]
    options = array.extract_options!
    assert_equal({ foo: 1 }, options)
    assert_equal([], array)
# frozen_string_literal: true

require_relative "../../abstract_unit"
require "active_support/core_ext/array"
require "active_support/core_ext/big_decimal"
require "active_support/core_ext/hash"
require "active_support/core_ext/string"

class ToSentenceTest < ActiveSupport::TestCase
  def test_plain_array_to_sentence
    assert_equal "", [].to_sentence
    assert_equal "one", ["one"].to_sentence
    assert_equal "one and two", ["one", "two"].to_sentence
    assert_equal "one, two, and three", ["one", "two", "three"].to_sentence
  end

  def test_to_sentence_with_words_connector
    assert_equal "one two, and three", ["one", "two", "three"].to_sentence(words_connector: " ")
    assert_equal "one & two, and three", ["one", "two", "three"].to_sentence(words_connector: " & ")
    assert_equal "onetwo, and three", ["one", "two", "three"].to_sentence(words_connector: nil)
  end

  def test_to_sentence_with_last_word_connector
    assert_equal "one, two, and also three", ["one", "two", "three"].to_sentence(last_word_connector: ", and also ")
    assert_equal "one, twothree", ["one", "two", "three"].to_sentence(last_word_connector: nil)
    assert_equal "one, two three", ["one", "two", "three"].to_sentence(last_word_connector: " ")
    assert_equal "one, two and three", ["one", "two", "three"].to_sentence(last_word_connector: " and ")
  end

  def test_two_elements
    assert_equal "one and two", ["one", "two"].to_sentence
    assert_equal "one two", ["one", "two"].to_sentence(two_words_connector: " ")
  end

  def test_one_element
    assert_equal "one", ["one"].to_sentence
  end

  def test_one_element_not_same_object
    elements = ["one"]
    assert_not_equal elements[0].object_id, elements.to_sentence.object_id
  end

  def test_one_non_string_element
    assert_equal "1", [1].to_sentence
  end

  def test_does_not_modify_given_hash
    options = { words_connector: " " }
    assert_equal "one two, and three", ["one", "two", "three"].to_sentence(options)
    assert_equal({ words_connector: " " }, options)
  end

  def test_with_blank_elements
    assert_equal ", one, , two, and three", [nil, "one", "", "two", "three"].to_sentence
  end

  def test_with_invalid_options
    exception = assert_raise ArgumentError do
      ["one", "two"].to_sentence(passing: "invalid option")
    end

    assert_equal "Unknown key: :passing. Valid keys are: :words_connector, :two_words_connector, :last_word_connector, :locale", exception.message
  end

  def test_always_returns_string
    assert_instance_of String, [ActiveSupport::SafeBuffer.new("one")].to_sentence
    assert_instance_of String, [ActiveSupport::SafeBuffer.new("one"), "two"].to_sentence
    assert_instance_of String, [ActiveSupport::SafeBuffer.new("one"), "two", "three"].to_sentence
  end

  def test_returns_no_frozen_string
    assert_not [].to_sentence.frozen?
    assert_not ["one"].to_sentence.frozen?
    assert_not ["one", "two"].to_sentence.frozen?
    assert_not ["one", "two", "three"].to_sentence.frozen?
  end
end

class ToSTest < ActiveSupport::TestCase
  class TestDB
    @@counter = 0
    def id
      @@counter += 1
    end
  end

  def test_to_s_db
    collection = [TestDB.new, TestDB.new, TestDB.new]

    assert_equal "null", [].to_s(:db)
    assert_equal "1,2,3", collection.to_s(:db)
  end
end

class ToXmlTest < ActiveSupport::TestCase
  def test_to_xml_with_hash_elements
    xml = [
      { name: "David", age: 26, age_in_millis: 820497600000 },
      { name: "Jason", age: 31, age_in_millis: BigDecimal("1.0") }
    ].to_xml(skip_instruct: true, indent: 0)

    assert_equal '<objects type="array"><object>', xml.first(30)
    assert_includes xml, %(<age type="integer">26</age>), xml
    assert_includes xml, %(<age-in-millis type="integer">820497600000</age-in-millis>), xml
    assert_includes xml, %(<name>David</name>), xml
    assert_includes xml, %(<age type="integer">31</age>), xml
    assert_includes xml, %(<age-in-millis type="decimal">1.0</age-in-millis>), xml
    assert_includes xml, %(<name>Jason</name>), xml
  end

  def test_to_xml_with_non_hash_elements
    xml = %w[1 2 3].to_xml(skip_instruct: true, indent: 0)

    assert_equal '<strings type="array"><string', xml.first(29)
    assert_includes xml, %(<string>2</string>), xml
  end

  def test_to_xml_with_non_hash_different_type_elements
    xml = [1, 2.0, "3"].to_xml(skip_instruct: true, indent: 0)

    assert_equal '<objects type="array"><object', xml.first(29)
    assert_includes xml, %(<object type="integer">1</object>), xml
    assert_includes xml, %(<object type="float">2.0</object>), xml
    assert_includes xml, %(object>3</object>), xml
  end

  def test_to_xml_with_dedicated_name
    xml = [
      { name: "David", age: 26, age_in_millis: 820497600000 }, { name: "Jason", age: 31 }
    ].to_xml(skip_instruct: true, indent: 0, root: "people")

    assert_equal '<people type="array"><person>', xml.first(29)
  end

  def test_to_xml_with_options
    xml = [
      { name: "David", street_address: "Paulina" }, { name: "Jason", street_address: "Evergreen" }
    ].to_xml(skip_instruct: true, skip_types: true, indent: 0)

    assert_equal "<objects><object>", xml.first(17)
    assert_includes xml, %(<street-address>Paulina</street-address>)
    assert_includes xml, %(<name>David</name>)
    assert_includes xml, %(<street-address>Evergreen</street-address>)
    assert_includes xml, %(<name>Jason</name>)
  end

  def test_to_xml_with_indent_set
    xml = [
      { name: "David", street_address: "Paulina" }, { name: "Jason", street_address: "Evergreen" }
    ].to_xml(skip_instruct: true, skip_types: true, indent: 4)

    assert_equal "<objects>\n    <object>", xml.first(22)
    assert_includes xml, %(\n        <street-address>Paulina</street-address>)
    assert_includes xml, %(\n        <name>David</name>)
    assert_includes xml, %(\n        <street-address>Evergreen</street-address>)
    assert_includes xml, %(\n        <name>Jason</name>)
  end

  def test_to_xml_with_dasherize_false
    xml = [
      { name: "David", street_address: "Paulina" }, { name: "Jason", street_address: "Evergreen" }
    ].to_xml(skip_instruct: true, skip_types: true, indent: 0, dasherize: false)

    assert_equal "<objects><object>", xml.first(17)
    assert_includes xml, %(<street_address>Paulina</street_address>)
    assert_includes xml, %(<street_address>Evergreen</street_address>)
  end

  def test_to_xml_with_dasherize_true
    xml = [
      { name: "David", street_address: "Paulina" }, { name: "Jason", street_address: "Evergreen" }
    ].to_xml(skip_instruct: true, skip_types: true, indent: 0, dasherize: true)

    assert_equal "<objects><object>", xml.first(17)
    assert_includes xml, %(<street-address>Paulina</street-address>)
    assert_includes xml, %(<street-address>Evergreen</street-address>)
  end

  def test_to_xml_with_instruct
    xml = [
      { name: "David", age: 26, age_in_millis: 820497600000 },
      { name: "Jason", age: 31, age_in_millis: BigDecimal("1.0") }
    ].to_xml(skip_instruct: false, indent: 0)

    assert_match(/^<\?xml [^>]*/, xml)
    assert_equal 0, xml.rindex(/<\?xml /)
  end

  def test_to_xml_with_block
    xml = [
      { name: "David", age: 26, age_in_millis: 820497600000 },
      { name: "Jason", age: 31, age_in_millis: BigDecimal("1.0") }
    ].to_xml(skip_instruct: true, indent: 0) do |builder|
      builder.count 2
    end

    assert_includes xml, %(<count>2</count>), xml
  end

  def test_to_xml_with_empty
    xml = [].to_xml
    assert_match(/type="array"\/>/, xml)
  end

  def test_to_xml_dups_options
    options = { skip_instruct: true }
    [].to_xml(options)
    # :builder, etc, shouldn't be added to options
    assert_equal({ skip_instruct: true }, options)
# frozen_string_literal: true

require_relative "abstract_unit"

module ActiveSupport
  class BroadcastLoggerTest < TestCase
    attr_reader :logger, :log1, :log2

    setup do
      @log1 = FakeLogger.new
      @log2 = FakeLogger.new
      @log1.extend Logger.broadcast @log2
      @logger = @log1
    end

    Logger::Severity.constants.each do |level_name|
      method = level_name.downcase
      level = Logger::Severity.const_get(level_name)

      test "##{method} adds the message to all loggers" do
        logger.public_send(method, "msg")

        assert_equal [level, "msg", nil], log1.adds.first
        assert_equal [level, "msg", nil], log2.adds.first
      end
    end

    test "#close broadcasts to all loggers" do
      logger.close

      assert log1.closed, "should be closed"
      assert log2.closed, "should be closed"
    end

    test "#<< shovels the value into all loggers" do
      logger << "foo"

      assert_equal %w{ foo }, log1.chevrons
      assert_equal %w{ foo }, log2.chevrons
    end

    test "#level= assigns the level to all loggers" do
      assert_equal ::Logger::DEBUG, logger.level
      logger.level = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.level
      assert_equal ::Logger::FATAL, log2.level
    end

    test "#progname= assigns to all the loggers" do
      assert_nil logger.progname
      logger.progname = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.progname
      assert_equal ::Logger::FATAL, log2.progname
    end

    test "#formatter= assigns to all the loggers" do
      assert_nil logger.formatter
      logger.formatter = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.formatter
      assert_equal ::Logger::FATAL, log2.formatter
    end

    test "#local_level= assigns the local_level to all loggers" do
      assert_equal ::Logger::DEBUG, logger.local_level
      logger.local_level = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.local_level
      assert_equal ::Logger::FATAL, log2.local_level
    end

    test "#silence does not break custom loggers" do
      new_logger = FakeLogger.new
      custom_logger = CustomLogger.new
      custom_logger.extend(Logger.broadcast(new_logger))

      custom_logger.silence do
        custom_logger.error "from error"
        custom_logger.unknown "from unknown"
      end

      assert_equal [[::Logger::ERROR, "from error", nil], [::Logger::UNKNOWN, "from unknown", nil]], custom_logger.adds
      assert_equal [[::Logger::ERROR, "from error", nil], [::Logger::UNKNOWN, "from unknown", nil]], new_logger.adds
    end

    test "#silence silences all loggers below the default level of ERROR" do
      logger.silence do
        logger.debug "test"
      end

      assert_equal [], log1.adds
      assert_equal [], log2.adds
    end

    test "#silence does not silence at or above ERROR" do
      logger.silence do
        logger.error "from error"
        logger.unknown "from unknown"
      end

      assert_equal [[::Logger::ERROR, "from error", nil], [::Logger::UNKNOWN, "from unknown", nil]], log1.adds
      assert_equal [[::Logger::ERROR, "from error", nil], [::Logger::UNKNOWN, "from unknown", nil]], log2.adds
    end

    test "#silence allows you to override the silence level" do
      logger.silence(::Logger::FATAL) do
        logger.error "unseen"
        logger.fatal "seen"
      end

      assert_equal [[::Logger::FATAL, "seen", nil]], log1.adds
      assert_equal [[::Logger::FATAL, "seen", nil]], log2.adds
    end

    class CustomLogger
      include ActiveSupport::LoggerSilence

      attr_reader :adds, :closed, :chevrons
      attr_accessor :level, :progname, :formatter, :local_level

      def initialize
        @adds        = []
        @closed      = false
        @chevrons    = []
        @level       = ::Logger::DEBUG
        @local_level = ::Logger::DEBUG
        @progname    = nil
        @formatter   = nil
      end

      def debug(message, &block)
        add(::Logger::DEBUG, message, &block)
      end

      def info(message, &block)
        add(::Logger::INFO, message, &block)
      end

      def warn(message, &block)
        add(::Logger::WARN, message, &block)
      end

      def error(message, &block)
        add(::Logger::ERROR, message, &block)
      end

      def fatal(message, &block)
        add(::Logger::FATAL, message, &block)
      end

      def unknown(message, &block)
        add(::Logger::UNKNOWN, message, &block)
      end

      def <<(x)
        @chevrons << x
      end

      def add(message_level, message = nil, progname = nil, &block)
        @adds << [message_level, message, progname] if message_level >= local_level
      end

      def close
        @closed = true
      end
    end

    class FakeLogger < CustomLogger
# frozen_string_literal: true

require_relative "abstract_unit"

class ReloaderTest < ActiveSupport::TestCase
  def test_prepare_callback
    prepared = completed = false
    reloader.to_prepare { prepared = true }
    reloader.to_complete { completed = true }

    assert_not prepared
    assert_not completed
    reloader.prepare!
    assert prepared
    assert_not completed

    prepared = false
    reloader.wrap do
      assert prepared
      prepared = false
    end
    assert_not prepared
  end

  def test_prepend_prepare_callback
    i = 10
    reloader.to_prepare { i += 1 }
    reloader.to_prepare(prepend: true) { i = 0 }

    reloader.prepare!
    assert_equal 1, i
  end

  def test_only_run_when_check_passes
    r = new_reloader { true }
    invoked = false
    r.to_run { invoked = true }
    r.wrap { }
    assert invoked

    r = new_reloader { false }
    invoked = false
    r.to_run { invoked = true }
    r.wrap { }
    assert_not invoked
  end

  def test_full_reload_sequence
    called = []
    reloader.to_prepare { called << :prepare }
    reloader.to_run { called << :reloader_run }
    reloader.to_complete { called << :reloader_complete }
    reloader.executor.to_run { called << :executor_run }
    reloader.executor.to_complete { called << :executor_complete }

    reloader.wrap { }
    assert_equal [:executor_run, :reloader_run, :prepare, :reloader_complete, :executor_complete], called

    called = []
    reloader.reload!
    assert_equal [:executor_run, :reloader_run, :prepare, :reloader_complete, :executor_complete, :prepare], called

    reloader.check = lambda { false }

    called = []
    reloader.wrap { }
    assert_equal [:executor_run, :executor_complete], called

    called = []
    reloader.reload!
    assert_equal [:executor_run, :reloader_run, :prepare, :reloader_complete, :executor_complete, :prepare], called
  end

  def test_class_unload_block
    called = []
    reloader.before_class_unload { called << :before_unload }
    reloader.after_class_unload { called << :after_unload }
    reloader.to_run do
      class_unload! do
        called << :unload
      end
    end
    reloader.wrap { called << :body }

    assert_equal [:before_unload, :unload, :after_unload, :body], called
  end

  private
    def new_reloader(&check)
      Class.new(ActiveSupport::Reloader).tap do |r|
        r.check = check
        r.executor = Class.new(ActiveSupport::Executor)
      end
    end

# frozen_string_literal: true

module DependenciesTestHelpers
  def with_loading(*from)
    old_mechanism, ActiveSupport::Dependencies.mechanism = ActiveSupport::Dependencies.mechanism, :load
    this_dir = __dir__
    parent_dir = File.dirname(this_dir)
    path_copy = $LOAD_PATH.dup
    $LOAD_PATH.unshift(parent_dir) unless $LOAD_PATH.include?(parent_dir)
    prior_autoload_paths = ActiveSupport::Dependencies.autoload_paths
    ActiveSupport::Dependencies.autoload_paths = from.collect { |f| "#{this_dir}/#{f}" }
    yield
  ensure
    $LOAD_PATH.replace(path_copy)
    ActiveSupport::Dependencies.autoload_paths = prior_autoload_paths
    ActiveSupport::Dependencies.mechanism = old_mechanism
    ActiveSupport::Dependencies.explicitly_unloadable_constants = []
    ActiveSupport::Dependencies.clear
  end

  def with_autoloading_fixtures(&block)
    with_loading "autoloading_fixtures", &block
  end

  def remove_constants(*constants)
# frozen_string_literal: true

require_relative "abstract_unit"
require "stringio"
require "active_support/logger"

class CleanLoggerTest < ActiveSupport::TestCase
  def setup
    @out = StringIO.new
    @logger = ActiveSupport::Logger.new(@out)
  end

  def test_format_message
    @logger.error "error"
    assert_equal "error\n", @out.string
  end

  def test_datetime_format
    @logger.formatter = Logger::Formatter.new
    @logger.formatter.datetime_format = "%Y-%m-%d"
    @logger.debug "debug"
    assert_equal "%Y-%m-%d", @logger.formatter.datetime_format
    assert_match(/D, \[\d\d\d\d-\d\d-\d\d#\d+\] DEBUG -- : debug/, @out.string)
  end

  def test_nonstring_formatting
    an_object = [1, 2, 3, 4, 5]
    @logger.debug an_object
    assert_equal("#{an_object.inspect}\n", @out.string)
  end
# frozen_string_literal: true

require_relative "abstract_unit"
require "pp"
require "active_support/dependencies"
require_relative "dependencies_test_helpers"

module ModuleWithMissing
  mattr_accessor :missing_count
  def self.const_missing(name)
    self.missing_count += 1
    name
  end
end

module ModuleWithConstant
  InheritedConstant = "Hello"
end

class DependenciesTest < ActiveSupport::TestCase
  include DependenciesTestHelpers

  setup do
    @loaded_features_copy = $LOADED_FEATURES.dup
    $LOAD_PATH << "test"
  end

  teardown do
    ActiveSupport::Dependencies.clear
    $LOADED_FEATURES.replace(@loaded_features_copy)
    $LOAD_PATH.pop
  end

  def test_depend_on_path
    expected = assert_raises(LoadError) do
      Kernel.require "omgwtfbbq"
    end

    e = assert_raises(LoadError) do
      ActiveSupport::Dependencies.depend_on "omgwtfbbq"
    end
    assert_equal expected.path, e.path
  end

  def test_depend_on_message
    e = assert_raises(LoadError) do
      ActiveSupport::Dependencies.depend_on "omgwtfbbq"
    end
    assert_equal "No such file to load -- omgwtfbbq.rb", e.message
  end

  def test_require_dependency_accepts_an_object_which_implements_to_path
    o = Object.new
    def o.to_path; "dependencies/service_one"; end
    assert_nothing_raised {
      require_dependency o
    }
    assert defined?(ServiceOne)
  ensure
    remove_constants(:ServiceOne)
  end

  def test_tracking_loaded_files
    with_loading do
      require_dependency "dependencies/service_one"
      require_dependency "dependencies/service_two"
      assert_equal 2, ActiveSupport::Dependencies.loaded.size
    end
  ensure
    remove_constants(:ServiceOne, :ServiceTwo)
  end

  def test_tracking_identical_loaded_files
    with_loading do
      require_dependency "dependencies/service_one"
      require_dependency "dependencies/service_one"
      assert_equal 1, ActiveSupport::Dependencies.loaded.size
    end
  ensure
    remove_constants(:ServiceOne)
  end

  def test_missing_dependency_raises_missing_source_file
    assert_raise(LoadError) { require_dependency("missing_service") }
  end

  def test_dependency_which_raises_exception_isnt_added_to_loaded_set
    with_loading do
      filename = "dependencies/raises_exception"
      expanded = File.expand_path(filename)
      $raises_exception_load_count = 0

      5.times do |count|
        e = assert_raise Exception, "should have loaded dependencies/raises_exception which raises an exception" do
          require_dependency filename
        end

        assert_equal "Loading me failed, so do not add to loaded or history.", e.message
        assert_equal count + 1, $raises_exception_load_count

        assert_not ActiveSupport::Dependencies.loaded.include?(expanded)
        assert_not ActiveSupport::Dependencies.history.include?(expanded)
      end
    end
  end

  def test_dependency_which_raises_doesnt_blindly_call_blame_file!
    with_loading do
      filename = "dependencies/raises_exception_without_blame_file"
      assert_raises(Exception) { require_dependency filename }
    end
  end

  def test_warnings_should_be_enabled_on_first_load
    with_loading "dependencies" do
      old_warnings, ActiveSupport::Dependencies.warnings_on_first_load = ActiveSupport::Dependencies.warnings_on_first_load, true
      filename = "check_warnings"
      expanded = File.expand_path("dependencies/#{filename}", __dir__)
      $check_warnings_load_count = 0

      assert_not ActiveSupport::Dependencies.loaded.include?(expanded)
      assert_not ActiveSupport::Dependencies.history.include?(expanded)

      silence_warnings { require_dependency filename }
      assert_equal 1, $check_warnings_load_count
      assert_equal true, $checked_verbose, "On first load warnings should be enabled."

      assert_includes ActiveSupport::Dependencies.loaded, expanded
      ActiveSupport::Dependencies.clear
      assert_not ActiveSupport::Dependencies.loaded.include?(expanded)
      assert_includes ActiveSupport::Dependencies.history, expanded

      silence_warnings { require_dependency filename }
      assert_equal 2, $check_warnings_load_count
      assert_nil $checked_verbose, "After first load warnings should be left alone."

      assert_includes ActiveSupport::Dependencies.loaded, expanded
      ActiveSupport::Dependencies.clear
      assert_not ActiveSupport::Dependencies.loaded.include?(expanded)
      assert_includes ActiveSupport::Dependencies.history, expanded

      enable_warnings { require_dependency filename }
      assert_equal 3, $check_warnings_load_count
      assert_equal true, $checked_verbose, "After first load warnings should be left alone."

      assert_includes ActiveSupport::Dependencies.loaded, expanded
      ActiveSupport::Dependencies.warnings_on_first_load = old_warnings
    end
  end

  def test_mutual_dependencies_dont_infinite_loop
    with_loading "dependencies" do
      $mutual_dependencies_count = 0
      assert_nothing_raised { require_dependency "mutual_one" }
      assert_equal 2, $mutual_dependencies_count

      ActiveSupport::Dependencies.clear

      $mutual_dependencies_count = 0
      assert_nothing_raised { require_dependency "mutual_two" }
      assert_equal 2, $mutual_dependencies_count
    end
  end

  def test_circular_autoloading_detection
    with_autoloading_fixtures do
      e = assert_raise(RuntimeError) { Circular1 }
      assert_equal "Circular dependency detected while autoloading constant Circular1", e.message
    end
  end

  def test_ensures_the_expected_constant_is_defined
    with_autoloading_fixtures do
      e = assert_raise(LoadError) { Typo }
      assert_match %r{Unable to autoload constant Typo, expected .*/test/autoloading_fixtures/typo.rb to define it}, e.message
    end
  end

  def test_require_dependency_does_not_assume_any_particular_constant_is_defined
    with_autoloading_fixtures do
      require_dependency "typo"
      assert_equal 1, TypO
    end
  end

  # Regression, see https://github.com/rails/rails/issues/16468.
  def test_require_dependency_interaction_with_autoloading
    with_autoloading_fixtures do
      require_dependency "typo"
      assert_equal 1, TypO

      e = assert_raise(LoadError) { Typo }
      assert_match %r{Unable to autoload constant Typo, expected .*/test/autoloading_fixtures/typo.rb to define it}, e.message
    end
  end

  # Regression see https://github.com/rails/rails/issues/31694
  def test_included_constant_that_changes_to_have_exception_then_back_does_not_loop_forever
    # This constant references a nested constant whose namespace will be auto-generated
    parent_constant = <<-RUBY
      class ConstantReloadError
        AnotherConstant::ReloadError
      end
    RUBY

    # This constant's namespace will be auto-generated,
    # also, we'll edit it to contain an error at load-time
    child_constant = <<-RUBY
      class AnotherConstant::ReloadError
        # no_such_method_as_this
      end
    RUBY

    # Create a version which contains an error during loading
    child_constant_with_error = child_constant.sub("# no_such_method_as_this", "no_such_method_as_this")

    fixtures_path = File.join(__dir__, "autoloading_fixtures")
    Dir.mktmpdir(nil, fixtures_path) do |tmpdir|
      # Set up the file structure where constants will be loaded from
      child_constant_path = "#{tmpdir}/another_constant/reload_error.rb"
      File.write("#{tmpdir}/constant_reload_error.rb", parent_constant)
      Dir.mkdir("#{tmpdir}/another_constant")
      File.write(child_constant_path, child_constant_with_error)

      tmpdir_name = tmpdir.split("/").last
      with_loading("autoloading_fixtures/#{tmpdir_name}") do
        # Load the file, with the error:
        assert_raises(NameError) {
          ConstantReloadError
        }

        Timeout.timeout(0.1) do
          # Remove the constant, as if Rails development middleware is reloading changed files:
          ActiveSupport::Dependencies.remove_unloadable_constants!
          assert_not defined?(AnotherConstant::ReloadError)
        end

        # Change the file, so that it is **correct** this time:
        File.write(child_constant_path, child_constant)

        # Again: Remove the constant, as if Rails development middleware is reloading changed files:
        ActiveSupport::Dependencies.remove_unloadable_constants!
        assert_not defined?(AnotherConstant::ReloadError)

        # Now, reload the _fixed_ constant:
        assert ConstantReloadError
        assert AnotherConstant::ReloadError
      end
    end
  end

  def test_module_loading
    with_autoloading_fixtures do
      assert_kind_of Module, A
      assert_kind_of Class, A::B
      assert_kind_of Class, A::C::D
      assert_kind_of Class, A::C::EM::F
    end
  end

  def test_non_existing_const_raises_name_error
    with_autoloading_fixtures do
      assert_raise(NameError) { DoesNotExist }
      assert_raise(NameError) { NoModule::DoesNotExist }
      assert_raise(NameError) { A::DoesNotExist }
      assert_raise(NameError) { A::B::DoesNotExist }
    end
  end

  def test_directories_manifest_as_modules_unless_const_defined
    with_autoloading_fixtures do
      assert_kind_of Module, ModuleFolder
    end
  ensure
    remove_constants(:ModuleFolder)
  end

  def test_module_with_nested_class
    with_autoloading_fixtures do
      assert_kind_of Class, ModuleFolder::NestedClass
    end
  ensure
    remove_constants(:ModuleFolder)
  end

  def test_module_with_nested_inline_class
    with_autoloading_fixtures do
      assert_kind_of Class, ModuleFolder::InlineClass
    end
  ensure
    remove_constants(:ModuleFolder)
  end

  def test_module_with_nested_class_requiring_lib_class
    with_autoloading_fixtures do
      _ = ModuleFolder::NestedWithRequire # assignment to silence parse-time warning "possibly useless use of :: in void context"

      assert defined?(ModuleFolder::LibClass)
      assert_not ActiveSupport::Dependencies.autoloaded_constants.include?("ModuleFolder::LibClass")
      assert_not ActiveSupport::Dependencies.autoloaded_constants.include?("ConstFromLib")
    end
  ensure
    remove_constants(:ModuleFolder)
    remove_constants(:ConstFromLib)
  end

  def test_module_with_nested_class_and_parent_requiring_lib_class
    with_autoloading_fixtures do
      _ = NestedWithRequireParent # assignment to silence parse-time warning "possibly useless use of a constant in void context"

      assert defined?(ModuleFolder::LibClass)
      assert_not ActiveSupport::Dependencies.autoloaded_constants.include?("ModuleFolder::LibClass")
      assert_not ActiveSupport::Dependencies.autoloaded_constants.include?("ConstFromLib")
    end
  ensure
    remove_constants(:ModuleFolder)
    remove_constants(:ConstFromLib)
  end

  def test_directories_may_manifest_as_nested_classes
    with_autoloading_fixtures do
      assert_kind_of Class, ClassFolder
    end
  ensure
    remove_constants(:ClassFolder)
  end

  def test_class_with_nested_class
    with_autoloading_fixtures do
      assert_kind_of Class, ClassFolder::NestedClass
    end
  ensure
    remove_constants(:ClassFolder)
  end

  def test_class_with_nested_inline_class
    with_autoloading_fixtures do
      assert_kind_of Class, ClassFolder::InlineClass
    end
  ensure
    remove_constants(:ClassFolder)
  end

  def test_class_with_nested_inline_subclass_of_parent
    with_autoloading_fixtures do
      assert_kind_of Class, ClassFolder::ClassFolderSubclass
      assert_kind_of Class, ClassFolder
      assert_equal "indeed", ClassFolder::ClassFolderSubclass::ConstantInClassFolder
    end
  ensure
    remove_constants(:ClassFolder)
  end

  def test_nested_class_can_access_sibling
    with_autoloading_fixtures do
      sibling = ModuleFolder::NestedClass.class_eval "NestedSibling"
      assert defined?(ModuleFolder::NestedSibling)
      assert_equal ModuleFolder::NestedSibling, sibling
    end
  ensure
    remove_constants(:ModuleFolder)
  end

  def test_raising_discards_autoloaded_constants
    with_autoloading_fixtures do
      e = assert_raises(Exception) { RaisesArbitraryException }
      assert_equal("arbitrary exception message", e.message)
      assert_not defined?(A)
      assert_not defined?(RaisesArbitraryException)
    end
  ensure
    remove_constants(:A, :RaisesArbitraryException)
  end

  def test_throwing_discards_autoloaded_constants
    with_autoloading_fixtures do
      catch :t do
        Throws
      end
      assert_not defined?(A)
      assert_not defined?(Throws)
    end
  ensure
    remove_constants(:A, :Throws)
  end

  def test_doesnt_break_normal_require
    path = File.expand_path("autoloading_fixtures/load_path", __dir__)
    original_path = $:.dup
    $:.push(path)
    with_autoloading_fixtures do
      # The _ = assignments are to prevent warnings
      _ = RequiresConstant
      assert defined?(RequiresConstant)
      assert defined?(LoadedConstant)
      ActiveSupport::Dependencies.clear
      _ = RequiresConstant
      assert defined?(RequiresConstant)
      assert defined?(LoadedConstant)
    end
  ensure
    remove_constants(:RequiresConstant, :LoadedConstant)
    $:.replace(original_path)
  end

  def test_doesnt_break_normal_require_nested
    path = File.expand_path("autoloading_fixtures/load_path", __dir__)
    original_path = $:.dup
    $:.push(path)

    with_autoloading_fixtures do
      # The _ = assignments are to prevent warnings
      _ = LoadsConstant
      assert defined?(LoadsConstant)
      assert defined?(LoadedConstant)
      ActiveSupport::Dependencies.clear
      _ = LoadsConstant
      assert defined?(LoadsConstant)
      assert defined?(LoadedConstant)
    end
  ensure
    remove_constants(:RequiresConstant, :LoadedConstant, :LoadsConstant)
    $:.replace(original_path)
  end

  def test_require_returns_true_when_file_not_yet_required
    path = File.expand_path("autoloading_fixtures/load_path", __dir__)
    original_path = $:.dup
    $:.push(path)

    with_loading do
      assert_equal true, require("loaded_constant")
    end
  ensure
    remove_constants(:LoadedConstant)
    $:.replace(original_path)
  end

  def test_require_returns_true_when_file_not_yet_required_even_when_no_new_constants_added
    path = File.expand_path("autoloading_fixtures/load_path", __dir__)
    original_path = $:.dup
    $:.push(path)

    with_loading do
      Object.module_eval "module LoadedConstant; end"
      assert_equal true, require("loaded_constant")
    end
  ensure
    remove_constants(:LoadedConstant)
    $:.replace(original_path)
  end

  def test_require_returns_false_when_file_already_required
    path = File.expand_path("autoloading_fixtures/load_path", __dir__)
    original_path = $:.dup
    $:.push(path)

    with_loading do
      require "loaded_constant"
      assert_equal false, require("loaded_constant")
    end
  ensure
    remove_constants(:LoadedConstant)
    $:.replace(original_path)
  end

  def test_require_raises_load_error_when_file_not_found
    with_loading do
      assert_raise(LoadError) { require "this_file_dont_exist_dude" }
    end
  end

  def test_load_returns_true_when_file_found
    path = File.expand_path("autoloading_fixtures/load_path", __dir__)
    original_path = $:.dup
    $:.push(path)

    with_loading do
      assert_equal true, load("loaded_constant.rb")
      assert_equal true, load("loaded_constant.rb")
    end
  ensure
    remove_constants(:LoadedConstant)
    $:.replace(original_path)
  end

  def test_load_raises_load_error_when_file_not_found
    with_loading do
      assert_raise(LoadError) { load "this_file_dont_exist_dude.rb" }
    end
  end

  def test_access_thru_and_upwards_fails
    with_autoloading_fixtures do
      assert_not defined?(ModuleFolder)
      assert_raise(NameError) { ModuleFolder::Object }
      assert_raise(NameError) { ModuleFolder::NestedClass::Object }
    end
  ensure
    remove_constants(:ModuleFolder)
  end

  def test_non_existing_const_raises_name_error_with_fully_qualified_name
    with_autoloading_fixtures do
      e = assert_raise(NameError) { A::DoesNotExist.nil? }
      assert_equal "uninitialized constant A::DoesNotExist", e.message
      assert_equal :DoesNotExist, e.name

      e = assert_raise(NameError) { A::B::DoesNotExist.nil? }
      assert_equal "uninitialized constant A::B::DoesNotExist", e.message
      assert_equal :DoesNotExist, e.name
    end
  ensure
    remove_constants(:A)
  end

  def test_smart_name_error_strings
    e = assert_raise NameError do
      Object.module_eval "ImaginaryObject"
    end
    assert_includes "uninitialized constant ImaginaryObject", e.message
  end

  def test_loadable_constants_for_path_should_handle_empty_autoloads
    assert_equal [], ActiveSupport::Dependencies.loadable_constants_for_path("hello")
  end

  def test_loadable_constants_for_path_should_handle_relative_paths
    fake_root = "dependencies"
    relative_root = File.expand_path("dependencies", __dir__)
    ["", "/"].each do |suffix|
      with_loading fake_root + suffix do
        assert_equal ["A::B"], ActiveSupport::Dependencies.loadable_constants_for_path(relative_root + "/a/b")
      end
    end
  end

  def test_loadable_constants_for_path_should_provide_all_results
    fake_root = "/usr/apps/backpack"
    with_loading fake_root, fake_root + "/lib" do
      root = ActiveSupport::Dependencies.autoload_paths.first
      assert_equal ["Lib::A::B", "A::B"], ActiveSupport::Dependencies.loadable_constants_for_path(root + "/lib/a/b")
    end
  end

  def test_loadable_constants_for_path_should_uniq_results
    fake_root = "/usr/apps/backpack/lib"
    with_loading fake_root, fake_root + "/" do
      root = ActiveSupport::Dependencies.autoload_paths.first
      assert_equal ["A::B"], ActiveSupport::Dependencies.loadable_constants_for_path(root + "/a/b")
    end
  end

  def test_loadable_constants_with_load_path_without_trailing_slash
    path = File.expand_path("autoloading_fixtures/class_folder/inline_class.rb", __dir__)
    with_loading "autoloading_fixtures/class/" do
      assert_equal [], ActiveSupport::Dependencies.loadable_constants_for_path(path)
    end
  end

  def test_qualified_const_defined
    assert ActiveSupport::Dependencies.qualified_const_defined?("Object")
    assert ActiveSupport::Dependencies.qualified_const_defined?("::Object")
    assert ActiveSupport::Dependencies.qualified_const_defined?("::Object::Kernel")
    assert ActiveSupport::Dependencies.qualified_const_defined?("::ActiveSupport::TestCase")
  end

  def test_qualified_const_defined_should_not_call_const_missing
    ModuleWithMissing.missing_count = 0
    assert_not ActiveSupport::Dependencies.qualified_const_defined?("ModuleWithMissing::A")
    assert_equal 0, ModuleWithMissing.missing_count
    assert_not ActiveSupport::Dependencies.qualified_const_defined?("ModuleWithMissing::A::B")
    assert_equal 0, ModuleWithMissing.missing_count
  end

  def test_qualified_const_defined_explodes_with_invalid_const_name
    assert_raises(NameError) { ActiveSupport::Dependencies.qualified_const_defined?("invalid") }
  end

  def test_autoloaded?
    with_autoloading_fixtures do
      assert_not ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
      assert_not ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")

      assert ActiveSupport::Dependencies.autoloaded?(ModuleFolder)

      assert ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
      assert_not ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")

      assert ActiveSupport::Dependencies.autoloaded?(ModuleFolder::NestedClass)

      assert ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
      assert ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")

      assert ActiveSupport::Dependencies.autoloaded?("::ModuleFolder")
      assert ActiveSupport::Dependencies.autoloaded?(:ModuleFolder)

      # Anonymous modules aren't autoloaded.
      assert_not ActiveSupport::Dependencies.autoloaded?(Module.new)

      nil_name = Module.new
      def nil_name.name() nil end
      assert_not ActiveSupport::Dependencies.autoloaded?(nil_name)

      invalid_constant_name = Module.new do
        def self.name
          "primary::SchemaMigration"
        end
      end
      assert_not ActiveSupport::Dependencies.autoloaded?(invalid_constant_name)
    end
  ensure
    remove_constants(:ModuleFolder)
  end

  def test_qualified_name_for
    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for(Object, :A)
    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for(:Object, :A)
    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for("Object", :A)
    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for("::Object", :A)

    assert_equal "ActiveSupport::Dependencies::A", ActiveSupport::Dependencies.qualified_name_for(:'ActiveSupport::Dependencies', :A)
    assert_equal "ActiveSupport::Dependencies::A", ActiveSupport::Dependencies.qualified_name_for(ActiveSupport::Dependencies, :A)
  end

  def test_file_search
    with_loading "dependencies" do
      root = ActiveSupport::Dependencies.autoload_paths.first
      assert_nil ActiveSupport::Dependencies.search_for_file("service_three")
      assert_nil ActiveSupport::Dependencies.search_for_file("service_three.rb")
      assert_equal root + "/service_one.rb", ActiveSupport::Dependencies.search_for_file("service_one")
      assert_equal root + "/service_one.rb", ActiveSupport::Dependencies.search_for_file("service_one.rb")
    end
  end

  def test_file_search_uses_first_in_load_path
    with_loading "dependencies", "autoloading_fixtures" do
      deps, autoload = ActiveSupport::Dependencies.autoload_paths
      assert_match %r/dependencies/, deps
      assert_match %r/autoloading_fixtures/, autoload

      assert_equal deps + "/conflict.rb", ActiveSupport::Dependencies.search_for_file("conflict")
    end
    with_loading "autoloading_fixtures", "dependencies" do
      autoload, deps = ActiveSupport::Dependencies.autoload_paths
      assert_match %r/dependencies/, deps
      assert_match %r/autoloading_fixtures/, autoload

      assert_equal autoload + "/conflict.rb", ActiveSupport::Dependencies.search_for_file("conflict")
    end
  end

  def test_custom_const_missing_should_work
    Object.module_eval <<-end_eval, __FILE__, __LINE__ + 1
      module ModuleWithCustomConstMissing
        def self.const_missing(name)
          const_set name, name.to_s.hash
        end

        module A
        end
      end
    end_eval

    with_autoloading_fixtures do
      assert_kind_of Integer, ::ModuleWithCustomConstMissing::B
      assert_kind_of Module, ::ModuleWithCustomConstMissing::A
      assert_kind_of String, ::ModuleWithCustomConstMissing::A::B
    end
  ensure
    remove_constants(:ModuleWithCustomConstMissing)
  end

  def test_const_missing_in_anonymous_modules_loads_top_level_constants
    with_autoloading_fixtures do
      # class_eval STRING pushes the class to the nesting of the eval'ed code.
      klass = Class.new.class_eval "EM"
      assert_equal EM, klass
    end
  ensure
    remove_constants(:EM)
  end

  def test_const_missing_in_anonymous_modules_raises_if_the_constant_belongs_to_Object
    with_autoloading_fixtures do
      require_dependency "em"

      mod = Module.new
      e = assert_raise(NameError) { mod::EM }
      assert_equal "EM cannot be autoloaded from an anonymous class or module", e.message
      assert_equal :EM, e.name
    end
  ensure
    remove_constants(:EM)
  end

  def test_removal_from_tree_should_be_detected
    with_loading "dependencies" do
      c = ServiceOne
      ActiveSupport::Dependencies.clear
      assert_not defined?(ServiceOne)
      e = assert_raise ArgumentError do
        ActiveSupport::Dependencies.load_missing_constant(c, :FakeMissing)
      end
      assert_match %r{ServiceOne has been removed from the module tree}i, e.message
    end
  ensure
    remove_constants(:ServiceOne)
  end

  def test_references_should_work
    with_loading "dependencies" do
      c = ActiveSupport::Dependencies.reference("ServiceOne")
      service_one_first = ServiceOne
      assert_equal service_one_first, c.get("ServiceOne")
      ActiveSupport::Dependencies.clear
      assert_not defined?(ServiceOne)
      service_one_second = ServiceOne
      assert_not_equal service_one_first, c.get("ServiceOne")
      assert_equal service_one_second, c.get("ServiceOne")
    end
  ensure
    remove_constants(:ServiceOne)
  end

  def test_constantize_shortcut_for_cached_constant_lookups
    with_loading "dependencies" do
      assert_equal ServiceOne, ActiveSupport::Dependencies.constantize("ServiceOne")
    end
  ensure
    remove_constants(:ServiceOne)
  end

  def test_nested_load_error_isnt_rescued
    with_loading "dependencies" do
      assert_raise(LoadError) do
        RequiresNonexistent1
      end
    end
  end

  def test_autoload_once_paths_do_not_add_to_autoloaded_constants
    old_path = ActiveSupport::Dependencies.autoload_once_paths
    with_autoloading_fixtures do
      ActiveSupport::Dependencies.autoload_once_paths = ActiveSupport::Dependencies.autoload_paths.dup

      assert_not ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
      assert_not ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")
      assert_not ActiveSupport::Dependencies.autoloaded?(ModuleFolder)

      1 if ModuleFolder::NestedClass # 1 if to avoid warning
      assert_not ActiveSupport::Dependencies.autoloaded?(ModuleFolder::NestedClass)
    end
  ensure
    remove_constants(:ModuleFolder)
    ActiveSupport::Dependencies.autoload_once_paths = old_path
  end

  def test_autoload_once_pathnames_do_not_add_to_autoloaded_constants
    with_autoloading_fixtures do
      pathnames = ActiveSupport::Dependencies.autoload_paths.collect { |p| Pathname.new(p) }
      ActiveSupport::Dependencies.autoload_paths = pathnames
      ActiveSupport::Dependencies.autoload_once_paths = pathnames

      assert_not ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
      assert_not ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")
      assert_not ActiveSupport::Dependencies.autoloaded?(ModuleFolder)

      1 if ModuleFolder::NestedClass # 1 if to avoid warning
      assert_not ActiveSupport::Dependencies.autoloaded?(ModuleFolder::NestedClass)
    end
  ensure
    remove_constants(:ModuleFolder)
    ActiveSupport::Dependencies.autoload_once_paths = []
  end

  def test_application_should_special_case_application_controller
    with_autoloading_fixtures do
      require_dependency "application"
      assert_equal 10, ApplicationController
      assert ActiveSupport::Dependencies.autoloaded?(:ApplicationController)
    end
  ensure
    remove_constants(:ApplicationController)
  end

  def test_preexisting_constants_are_not_marked_as_autoloaded
    with_autoloading_fixtures do
      require_dependency "em"
      assert ActiveSupport::Dependencies.autoloaded?(:EM)
      ActiveSupport::Dependencies.clear
    end

    Object.const_set :EM, Class.new
    with_autoloading_fixtures do
      require_dependency "em"
      assert_not ActiveSupport::Dependencies.autoloaded?(:EM), "EM shouldn't be marked autoloaded!"
      ActiveSupport::Dependencies.clear
    end
  ensure
    remove_constants(:EM)
  end

  def test_constants_in_capitalized_nesting_marked_as_autoloaded
    with_autoloading_fixtures do
      ActiveSupport::Dependencies.load_missing_constant(HTML, "SomeClass")

      assert ActiveSupport::Dependencies.autoloaded?("HTML::SomeClass")
    end
  ensure
    remove_constants(:HTML)
  end

  def test_unloadable
    with_autoloading_fixtures do
      Object.const_set :M, Module.new
      M.unloadable

      ActiveSupport::Dependencies.clear
      assert_not defined?(M)

      Object.const_set :M, Module.new
      ActiveSupport::Dependencies.clear
      assert_not defined?(M), "Dependencies should unload unloadable constants each time"
    end
  end

  def test_unloadable_should_fail_with_anonymous_modules
    with_autoloading_fixtures do
      m = Module.new
      assert_raise(ArgumentError) { m.unloadable }
    end
  end

  def test_unloadable_should_return_change_flag
    with_autoloading_fixtures do
      Object.const_set :M, Module.new
      assert_equal true, M.unloadable
      assert_equal false, M.unloadable
    end
  ensure
    remove_constants(:M)
  end

  def test_unloadable_constants_should_receive_callback
    Object.const_set :C, Class.new { def self.before_remove_const; end }
    C.unloadable
    assert_called(C, :before_remove_const, times: 1) do
      assert_respond_to C, :before_remove_const
      ActiveSupport::Dependencies.clear
      assert_not defined?(C)
    end
  ensure
    remove_constants(:C)
  end

  def test_new_constants_in_without_constants
    assert_equal [], (ActiveSupport::Dependencies.new_constants_in(Object) { })
    assert ActiveSupport::Dependencies.constant_watch_stack.all? { |k, v| v.empty? }
  end

  def test_new_constants_in_with_a_single_constant
    assert_equal ["Hello"], ActiveSupport::Dependencies.new_constants_in(Object) {
                              Object.const_set :Hello, 10
                            }.map(&:to_s)
    assert ActiveSupport::Dependencies.constant_watch_stack.all? { |k, v| v.empty? }
  ensure
    remove_constants(:Hello)
  end

  def test_new_constants_in_with_nesting
    outer = ActiveSupport::Dependencies.new_constants_in(Object) do
      Object.const_set :OuterBefore, 10

      assert_equal ["Inner"], ActiveSupport::Dependencies.new_constants_in(Object) {
                                Object.const_set :Inner, 20
                              }.map(&:to_s)

      Object.const_set :OuterAfter, 30
    end

    assert_equal ["OuterAfter", "OuterBefore"], outer.sort.map(&:to_s)
    assert ActiveSupport::Dependencies.constant_watch_stack.all? { |k, v| v.empty? }
  ensure
    remove_constants(:OuterBefore, :Inner, :OuterAfter)
  end

  def test_new_constants_in_module
    Object.const_set :M, Module.new

    outer = ActiveSupport::Dependencies.new_constants_in(M) do
      M.const_set :OuterBefore, 10

      inner = ActiveSupport::Dependencies.new_constants_in(M) do
        M.const_set :Inner, 20
      end
      assert_equal ["M::Inner"], inner

      M.const_set :OuterAfter, 30
    end
    assert_equal ["M::OuterAfter", "M::OuterBefore"], outer.sort
    assert ActiveSupport::Dependencies.constant_watch_stack.all? { |k, v| v.empty? }
  ensure
    remove_constants(:M)
  end

  def test_new_constants_in_module_using_name
    outer = ActiveSupport::Dependencies.new_constants_in(:M) do
      Object.const_set :M, Module.new
      M.const_set :OuterBefore, 10

      inner = ActiveSupport::Dependencies.new_constants_in(:M) do
        M.const_set :Inner, 20
      end
      assert_equal ["M::Inner"], inner

      M.const_set :OuterAfter, 30
    end
    assert_equal ["M::OuterAfter", "M::OuterBefore"], outer.sort
    assert ActiveSupport::Dependencies.constant_watch_stack.all? { |k, v| v.empty? }
  ensure
    remove_constants(:M)
  end

  def test_new_constants_in_with_inherited_constants
    m = ActiveSupport::Dependencies.new_constants_in(:Object) do
      Object.class_eval { include ModuleWithConstant }
    end
    assert_equal [], m
  end

  def test_new_constants_in_with_illegal_module_name_raises_correct_error
    assert_raise(NameError) do
      ActiveSupport::Dependencies.new_constants_in("Illegal-Name") { }
    end
  end

  def test_file_with_multiple_constants_and_require_dependency
    with_autoloading_fixtures do
      assert_not defined?(MultipleConstantFile)
      assert_not defined?(SiblingConstant)

      require_dependency "multiple_constant_file"
      assert defined?(MultipleConstantFile)
      assert defined?(SiblingConstant)
      assert ActiveSupport::Dependencies.autoloaded?(:MultipleConstantFile)
      assert ActiveSupport::Dependencies.autoloaded?(:SiblingConstant)
      ActiveSupport::Dependencies.clear

      assert_not defined?(MultipleConstantFile)
      assert_not defined?(SiblingConstant)
    end
  ensure
    remove_constants(:MultipleConstantFile, :SiblingConstant)
  end

  def test_file_with_multiple_constants_and_auto_loading
    with_autoloading_fixtures do
      assert_not defined?(MultipleConstantFile)
      assert_not defined?(SiblingConstant)

      assert_equal 10, MultipleConstantFile

      assert defined?(MultipleConstantFile)
      assert defined?(SiblingConstant)
      assert ActiveSupport::Dependencies.autoloaded?(:MultipleConstantFile)
      assert ActiveSupport::Dependencies.autoloaded?(:SiblingConstant)

      ActiveSupport::Dependencies.clear

      assert_not defined?(MultipleConstantFile)
      assert_not defined?(SiblingConstant)
    end
  ensure
    remove_constants(:MultipleConstantFile, :SiblingConstant)
  end

  def test_nested_file_with_multiple_constants_and_require_dependency
    with_autoloading_fixtures do
      assert_not defined?(ClassFolder::NestedClass)
      assert_not defined?(ClassFolder::SiblingClass)

      require_dependency "class_folder/nested_class"

      assert defined?(ClassFolder::NestedClass)
      assert defined?(ClassFolder::SiblingClass)
      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::NestedClass")
      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::SiblingClass")

      ActiveSupport::Dependencies.clear

      assert_not defined?(ClassFolder::NestedClass)
      assert_not defined?(ClassFolder::SiblingClass)
    end
  ensure
    remove_constants(:ClassFolder)
  end

  def test_nested_file_with_multiple_constants_and_auto_loading
    with_autoloading_fixtures do
      assert_not defined?(ClassFolder::NestedClass)
      assert_not defined?(ClassFolder::SiblingClass)

      assert_kind_of Class, ClassFolder::NestedClass

      assert defined?(ClassFolder::NestedClass)
      assert defined?(ClassFolder::SiblingClass)
      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::NestedClass")
      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::SiblingClass")

      ActiveSupport::Dependencies.clear

      assert_not defined?(ClassFolder::NestedClass)
      assert_not defined?(ClassFolder::SiblingClass)
    end
  ensure
    remove_constants(:ClassFolder)
  end

  def test_autoload_doesnt_shadow_no_method_error_with_relative_constant
    with_autoloading_fixtures do
      assert_not defined?(::RaisesNoMethodError), "::RaisesNoMethodError is defined but it hasn't been referenced yet!"
      2.times do
        assert_raise(NoMethodError) { RaisesNoMethodError }
        assert_not defined?(::RaisesNoMethodError), "::RaisesNoMethodError is defined but it should have failed!"
      end
    end
  ensure
    remove_constants(:RaisesNoMethodError)
  end

  def test_autoload_doesnt_shadow_no_method_error_with_absolute_constant
    with_autoloading_fixtures do
      assert_not defined?(::RaisesNoMethodError), "::RaisesNoMethodError is defined but it hasn't been referenced yet!"
      2.times do
        assert_raise(NoMethodError) { ::RaisesNoMethodError }
        assert_not defined?(::RaisesNoMethodError), "::RaisesNoMethodError is defined but it should have failed!"
      end
    end
  ensure
    remove_constants(:RaisesNoMethodError)
  end

  def test_autoload_doesnt_shadow_error_when_mechanism_not_set_to_load
    with_autoloading_fixtures do
      ActiveSupport::Dependencies.mechanism = :require
      2.times do
        assert_raise(NameError) { assert_equal 123, ::RaisesNameError::FooBarBaz }
      end
    end
  ensure
    remove_constants(:RaisesNameError)
  end

  def test_autoload_doesnt_shadow_name_error
    with_autoloading_fixtures do
      2.times do
        e = assert_raise NameError do
          ::RaisesNameError::FooBarBaz.object_id
        end
        assert_equal "uninitialized constant RaisesNameError::FooBarBaz", e.message
        assert_not defined?(::RaisesNameError), "::RaisesNameError is defined but it should have failed!"
      end

      assert_not defined?(::RaisesNameError)
      2.times do
        assert_raise(NameError) { ::RaisesNameError }
        assert_not defined?(::RaisesNameError), "::RaisesNameError is defined but it should have failed!"
      end
    end
  ensure
    remove_constants(:RaisesNameError)
  end

  def test_remove_constant_handles_double_colon_at_start
    Object.const_set "DeleteMe", Module.new
    DeleteMe.const_set "OrMe", Module.new
    ActiveSupport::Dependencies.remove_constant "::DeleteMe::OrMe"
    assert_not defined?(DeleteMe::OrMe)
    assert defined?(DeleteMe)
    ActiveSupport::Dependencies.remove_constant "::DeleteMe"
    assert_not defined?(DeleteMe)
  ensure
    remove_constants(:DeleteMe)
  end

  def test_remove_constant_does_not_trigger_loading_autoloads
    constant = "ShouldNotBeAutoloaded"
    Object.class_eval do
      autoload constant, File.expand_path("autoloading_fixtures/should_not_be_required", __dir__)
    end

    assert_nil ActiveSupport::Dependencies.remove_constant(constant), "Kernel#autoload has been triggered by remove_constant"
    assert_not defined?(ShouldNotBeAutoloaded)
  ensure
    remove_constants(constant)
  end

  def test_remove_constant_does_not_autoload_already_removed_parents_as_a_side_effect
    with_autoloading_fixtures do
      _ = ::A    # assignment to silence parse-time warning "possibly useless use of :: in void context"
      _ = ::A::B # assignment to silence parse-time warning "possibly useless use of :: in void context"
      ActiveSupport::Dependencies.remove_constant("A")
      ActiveSupport::Dependencies.remove_constant("A::B")
      assert_not defined?(A)
    end
  ensure
    remove_constants(:A)
  end

  def test_load_once_constants_should_not_be_unloaded
    old_path = ActiveSupport::Dependencies.autoload_once_paths
    with_autoloading_fixtures do
      ActiveSupport::Dependencies.autoload_once_paths = ActiveSupport::Dependencies.autoload_paths
      _ = ::A # assignment to silence parse-time warning "possibly useless use of :: in void context"
      assert defined?(A)
      ActiveSupport::Dependencies.clear
      assert defined?(A)
    end
  ensure
    ActiveSupport::Dependencies.autoload_once_paths = old_path
    remove_constants(:A)
  end

  def test_access_unloaded_constants_for_reload
    with_autoloading_fixtures do
      assert_kind_of Module, A
      assert_kind_of Class, A::B # Necessary to load A::B for the test
      ActiveSupport::Dependencies.mark_for_unload(A::B)
      ActiveSupport::Dependencies.remove_unloadable_constants!

      A::B # Make sure no circular dependency error
    end
  ensure
    remove_constants(:A)
  end

  def test_autoload_once_paths_should_behave_when_recursively_loading
    old_path = ActiveSupport::Dependencies.autoload_once_paths
    with_loading "dependencies", "autoloading_fixtures" do
      ActiveSupport::Dependencies.autoload_once_paths = [ActiveSupport::Dependencies.autoload_paths.last]
      assert_not defined?(CrossSiteDependency)
      assert_nothing_raised { CrossSiteDepender.nil? }
      assert defined?(CrossSiteDependency)
      assert_not ActiveSupport::Dependencies.autoloaded?(CrossSiteDependency),
        "CrossSiteDependency shouldn't be marked as autoloaded!"
      ActiveSupport::Dependencies.clear
      assert defined?(CrossSiteDependency),
        "CrossSiteDependency shouldn't have been unloaded!"
    end
  ensure
    ActiveSupport::Dependencies.autoload_once_paths = old_path
    remove_constants(:CrossSiteDependency)
  end

  def test_hook_called_multiple_times
    assert_nothing_raised { ActiveSupport::Dependencies.hook! }
  end

  def test_load_and_require_stay_private
    assert_includes Object.private_methods, :load
    assert_includes Object.private_methods, :require

    ActiveSupport::Dependencies.unhook!

    assert_includes Object.private_methods, :load
    assert_includes Object.private_methods, :require
  ensure
    ActiveSupport::Dependencies.hook!
  end
end

class DependenciesLogging < ActiveSupport::TestCase
  MESSAGE = "message"

  def with_settings(logger, verbose)
    original_logger = ActiveSupport::Dependencies.logger
    original_verbose = ActiveSupport::Dependencies.verbose

    ActiveSupport::Dependencies.logger = logger
    ActiveSupport::Dependencies.verbose = verbose

    yield
  ensure
    ActiveSupport::Dependencies.logger = original_logger
    ActiveSupport::Dependencies.verbose = original_verbose
  end

  def fake_logger
    Class.new do
      def self.debug(message)
        message
      end
    end
  end

  test "does not log if the logger is nil and verbose is false" do
    with_settings(nil, false) do
      assert_nil ActiveSupport::Dependencies.log(MESSAGE)
    end
  end

  test "does not log if the logger is nil and verbose is true" do
    with_settings(nil, true) do
      assert_nil ActiveSupport::Dependencies.log(MESSAGE)
    end
  end

  test "does not log if the logger is set and verbose is false" do
    with_settings(fake_logger, false) do
      assert_nil ActiveSupport::Dependencies.log(MESSAGE)
    end
  end

  test "logs if the logger is set and verbose is true" do
# frozen_string_literal: true

require_relative "abstract_unit"

class WraithAttack < StandardError
end

class MadRonon < StandardError
end

class CoolError < StandardError
end

module WeirdError
  def self.===(other)
    Exception === other && other.respond_to?(:weird?)
  end
end

class Stargate
  # Nest this so the 'NuclearExplosion' handler needs a lexical const_get
  # to find it.
  class NuclearExplosion < StandardError; end

  attr_accessor :result

  include ActiveSupport::Rescuable

  rescue_from WraithAttack, with: :sos_first

  rescue_from WraithAttack, with: :sos

  rescue_from "NuclearExplosion" do
    @result = "alldead"
  end

  rescue_from MadRonon do |e|
    @result = e.message
  end

  rescue_from WeirdError do
    @result = "weird"
  end

  def dispatch(method)
    send(method)
  rescue Exception => e
    unless rescue_with_handler(e)
      @result = "unhandled"
    end
  end

  def attack
    raise WraithAttack
  end

  def nuke
    raise NuclearExplosion
  end

  def ronanize
    raise MadRonon.new("dex")
  end

  def crash
    raise "unhandled RuntimeError"
  end

  def looped_crash
    ex1 = StandardError.new("error 1")
    ex2 = StandardError.new("error 2")
    begin
      begin
        raise ex1
      rescue
        # sets the cause on ex2 to be ex1
        raise ex2
      end
    rescue
      # sets the cause on ex1 to be ex2
      raise ex1
    end
  end

  def fall_back_to_cause
    # This exception is the cause and has a handler.
    ronanize
  rescue
    # This is the exception we'll handle that doesn't have a cause.
    raise "unhandled RuntimeError with a handleable cause"
  end

  def weird
    StandardError.new.tap do |exc|
      def exc.weird?
        true
      end

      raise exc
    end
  end

  def sos
    @result = "killed"
  end

  def sos_first
    @result = "sos_first"
  end
end

class CoolStargate < Stargate
  attr_accessor :result

  include ActiveSupport::Rescuable

  rescue_from CoolError, with: :sos_cool_error

  def sos_cool_error
    @result = "sos_cool_error"
  end
end

class RescuableTest < ActiveSupport::TestCase
  def setup
    @stargate = Stargate.new
    @cool_stargate = CoolStargate.new
  end

  def test_rescue_from_with_method
    @stargate.dispatch :attack
    assert_equal "killed", @stargate.result
  end

  def test_rescue_from_with_block
    @stargate.dispatch :nuke
    assert_equal "alldead", @stargate.result
  end

  def test_rescue_from_with_block_with_args
    @stargate.dispatch :ronanize
    assert_equal "dex", @stargate.result
  end

  def test_rescue_from_error_dispatchers_with_case_operator
    @stargate.dispatch :weird
    assert_equal "weird", @stargate.result
  end

  def test_rescues_defined_later_are_added_at_end_of_the_rescue_handlers_array
    expected = ["WraithAttack", "WraithAttack", "NuclearExplosion", "MadRonon", "WeirdError"]
    result = @stargate.send(:rescue_handlers).collect(&:first)
    assert_equal expected, result
  end

  def test_children_should_inherit_rescue_definitions_from_parents_and_child_rescue_should_be_appended
    expected = ["WraithAttack", "WraithAttack", "NuclearExplosion", "MadRonon", "WeirdError", "CoolError"]
    result = @cool_stargate.send(:rescue_handlers).collect(&:first)
    assert_equal expected, result
  end

  def test_rescue_falls_back_to_exception_cause
    @stargate.dispatch :fall_back_to_cause
    assert_equal "dex", @stargate.result
  end

  def test_unhandled_exceptions
    @stargate.dispatch(:crash)
    assert_equal "unhandled", @stargate.result
  end

  def test_rescue_handles_loops_in_exception_cause_chain
    @stargate.dispatch :looped_crash
    assert_equal "unhandled", @stargate.result
  end
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/core_ext/hash"
require "active_support/parameter_filter"

class ParameterFilterTest < ActiveSupport::TestCase
  test "process parameter filter" do
    test_hashes = [
    [{ "foo" => "bar" }, { "foo" => "bar" }, %w'food'],
    [{ "foo" => "bar" }, { "foo" => "[FILTERED]" }, %w'foo'],
    [{ "foo" => "bar", "bar" => "foo" }, { "foo" => "[FILTERED]", "bar" => "foo" }, %w'foo baz'],
    [{ "foo" => "bar", "baz" => "foo" }, { "foo" => "[FILTERED]", "baz" => "[FILTERED]" }, %w'foo baz'],
    [{ "bar" => { "foo" => "bar", "bar" => "foo" } }, { "bar" => { "foo" => "[FILTERED]", "bar" => "foo" } }, %w'fo'],
    [{ "foo" => { "foo" => "bar", "bar" => "foo" } }, { "foo" => "[FILTERED]" }, %w'f banana'],
    [{ "deep" => { "cc" => { "code" => "bar", "bar" => "foo" }, "ss" => { "code" => "bar" } } }, { "deep" => { "cc" => { "code" => "[FILTERED]", "bar" => "foo" }, "ss" => { "code" => "bar" } } }, %w'deep.cc.code'],
    [{ "baz" => [{ "foo" => "baz" }, "1"] }, { "baz" => [{ "foo" => "[FILTERED]" }, "1"] }, [/foo/]]]

    test_hashes.each do |before_filter, after_filter, filter_words|
      parameter_filter = ActiveSupport::ParameterFilter.new(filter_words)
      assert_equal after_filter, parameter_filter.filter(before_filter)

      filter_words << "blah"
      filter_words << lambda { |key, value|
        value.reverse! if /bargain/.match?(key)
      }
      filter_words << lambda { |key, value, original_params|
        value.replace("world!") if original_params["barg"]["blah"] == "bar" && key == "hello"
      }

      filter_words << lambda { |key, value|
        value.upcase! if key == "array_elements"
      }

      parameter_filter = ActiveSupport::ParameterFilter.new(filter_words)
      before_filter["barg"] = { :bargain => "gain", "blah" => "bar", "bar" => { "bargain" => { "blah" => "foo", "hello" => "world" } } }
      after_filter["barg"]  = { :bargain => "niag", "blah" => "[FILTERED]", "bar" => { "bargain" => { "blah" => "[FILTERED]", "hello" => "world!" } } }

      before_filter["array_elements"] = %w(element1 element2)
      after_filter["array_elements"] = %w(ELEMENT1 ELEMENT2)

      assert_equal after_filter, parameter_filter.filter(before_filter)
    end
  end

  test "filter should return mask option when value is filtered" do
    mask = Object.new.freeze
    test_hashes = [
    [{ "foo" => "bar" }, { "foo" => "bar" }, %w'food'],
    [{ "foo" => "bar" }, { "foo" => mask }, %w'foo'],
    [{ "foo" => "bar", "bar" => "foo" }, { "foo" => mask, "bar" => "foo" }, %w'foo baz'],
    [{ "foo" => "bar", "baz" => "foo" }, { "foo" => mask, "baz" => mask }, %w'foo baz'],
    [{ "bar" => { "foo" => "bar", "bar" => "foo" } }, { "bar" => { "foo" => mask, "bar" => "foo" } }, %w'fo'],
    [{ "foo" => { "foo" => "bar", "bar" => "foo" } }, { "foo" => mask }, %w'f banana'],
    [{ "deep" => { "cc" => { "code" => "bar", "bar" => "foo" }, "ss" => { "code" => "bar" } } }, { "deep" => { "cc" => { "code" => mask, "bar" => "foo" }, "ss" => { "code" => "bar" } } }, %w'deep.cc.code'],
    [{ "baz" => [{ "foo" => "baz" }, "1"] }, { "baz" => [{ "foo" => mask }, "1"] }, [/foo/]]]

    test_hashes.each do |before_filter, after_filter, filter_words|
      parameter_filter = ActiveSupport::ParameterFilter.new(filter_words, mask: mask)
      assert_equal after_filter, parameter_filter.filter(before_filter)

      filter_words << "blah"
      filter_words << lambda { |key, value|
        value.reverse! if /bargain/.match?(key)
      }
      filter_words << lambda { |key, value, original_params|
        value.replace("world!") if original_params["barg"]["blah"] == "bar" && key == "hello"
      }

      parameter_filter = ActiveSupport::ParameterFilter.new(filter_words, mask: mask)
      before_filter["barg"] = { :bargain => "gain", "blah" => "bar", "bar" => { "bargain" => { "blah" => "foo", "hello" => "world" } } }
      after_filter["barg"]  = { :bargain => "niag", "blah" => mask, "bar" => { "bargain" => { "blah" => mask, "hello" => "world!" } } }

      assert_equal after_filter, parameter_filter.filter(before_filter)
    end
  end

  test "filter_param" do
    parameter_filter = ActiveSupport::ParameterFilter.new(["foo", /bar/])
    assert_equal "[FILTERED]", parameter_filter.filter_param("food", "secret vlaue")
    assert_equal "[FILTERED]", parameter_filter.filter_param("baz.foo", "secret vlaue")
    assert_equal "[FILTERED]", parameter_filter.filter_param("barbar", "secret vlaue")
    assert_equal "non secret value", parameter_filter.filter_param("baz", "non secret value")
  end

  test "filter_param can work with empty filters" do
    parameter_filter = ActiveSupport::ParameterFilter.new
    assert_equal "bar", parameter_filter.filter_param("foo", "bar")
  end

  test "parameter filter should maintain hash with indifferent access" do
    test_hashes = [
      [{ "foo" => "bar" }.with_indifferent_access, ["blah"]],
      [{ "foo" => "bar" }.with_indifferent_access, []]
    ]

    test_hashes.each do |before_filter, filter_words|
      parameter_filter = ActiveSupport::ParameterFilter.new(filter_words)
      assert_instance_of ActiveSupport::HashWithIndifferentAccess,
                         parameter_filter.filter(before_filter)
    end
  end

  test "filter_param should return mask option when value is filtered" do
    mask = Object.new.freeze
    parameter_filter = ActiveSupport::ParameterFilter.new(["foo", /bar/], mask: mask)
    assert_equal mask, parameter_filter.filter_param("food", "secret vlaue")
    assert_equal mask, parameter_filter.filter_param("baz.foo", "secret vlaue")
    assert_equal mask, parameter_filter.filter_param("barbar", "secret vlaue")
    assert_equal "non secret value", parameter_filter.filter_param("baz", "non secret value")
  end

  test "process parameter filter with hash having integer keys" do
    test_hashes = [
      [{ 13 => "bar" }, { 13 => "[FILTERED]" }, %w'13'],
      [{ 20 => "bar" }, { 20 => "bar" }, %w'13'],
    ]

    test_hashes.each do |before_filter, after_filter, filter_words|
      parameter_filter = ActiveSupport::ParameterFilter.new(filter_words)
# frozen_string_literal: true

require "securerandom"
require_relative "../abstract_unit"
require "active_support/core_ext/string/inflections"
require "active_support/json"
require "active_support/time"
require_relative "../time_zone_test_helpers"
require_relative "../json/encoding_test_cases"

class TestJSONEncoding < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  def sorted_json(json)
    if json.start_with?("{") && json.end_with?("}")
      "{" + json[1..-2].split(",").sort.join(",") + "}"
    else
      json
    end
  end

  JSONTest::EncodingTestCases.constants.each do |class_tests|
    define_method("test_#{class_tests[0..-6].underscore}") do
      prev = ActiveSupport.use_standard_json_time_format

      standard_class_tests = /Standard/.match?(class_tests)

      ActiveSupport.escape_html_entities_in_json  = !standard_class_tests
      ActiveSupport.use_standard_json_time_format = standard_class_tests
      JSONTest::EncodingTestCases.const_get(class_tests).each do |pair|
        assert_equal pair.last, sorted_json(ActiveSupport::JSON.encode(pair.first))
      end
    ensure
      ActiveSupport.escape_html_entities_in_json  = false
      ActiveSupport.use_standard_json_time_format = prev
    end
  end

  def test_process_status
    rubinius_skip "https://github.com/rubinius/rubinius/issues/3334"

    # There doesn't seem to be a good way to get a handle on a Process::Status object without actually
    # creating a child process, hence this to populate $?
    system("not_a_real_program_#{SecureRandom.hex}")
    assert_equal %({"exitstatus":#{$?.exitstatus},"pid":#{$?.pid}}), ActiveSupport::JSON.encode($?)
  end

  def test_hash_encoding
    assert_equal %({\"a\":\"b\"}), ActiveSupport::JSON.encode(a: :b)
    assert_equal %({\"a\":1}), ActiveSupport::JSON.encode("a" => 1)
    assert_equal %({\"a\":[1,2]}), ActiveSupport::JSON.encode("a" => [1, 2])
    assert_equal %({"1":2}), ActiveSupport::JSON.encode(1 => 2)

    assert_equal %({\"a\":\"b\",\"c\":\"d\"}), sorted_json(ActiveSupport::JSON.encode(a: :b, c: :d))
  end

  def test_hash_keys_encoding
    ActiveSupport.escape_html_entities_in_json = true
    assert_equal "{\"\\u003c\\u003e\":\"\\u003c\\u003e\"}", ActiveSupport::JSON.encode("<>" => "<>")
  ensure
    ActiveSupport.escape_html_entities_in_json = false
  end

  def test_utf8_string_encoded_properly
    result = ActiveSupport::JSON.encode("2.99")
    assert_equal '"2.99"', result
    assert_equal(Encoding::UTF_8, result.encoding)

    result = ActiveSupport::JSON.encode("")
    assert_equal '""', result
    assert_equal(Encoding::UTF_8, result.encoding)
  end

  def test_non_utf8_string_transcodes
    s = "".encode("Shift_JIS")
    result = ActiveSupport::JSON.encode(s)
    assert_equal '""', result
    assert_equal Encoding::UTF_8, result.encoding
  end

  def test_wide_utf8_chars
    w = ""
    result = ActiveSupport::JSON.encode(w)
    assert_equal '""', result
  end

  def test_wide_utf8_roundtrip
    hash = { string: "" }
    json = ActiveSupport::JSON.encode(hash)
    decoded_hash = ActiveSupport::JSON.decode(json)
    assert_equal "", decoded_hash["string"]
  end

  def test_hash_key_identifiers_are_always_quoted
    values = { 0 => 0, 1 => 1, :_ => :_, "$" => "$", "a" => "a", :A => :A, :A0 => :A0, "A0B" => "A0B" }
    assert_equal %w( "$" "A" "A0" "A0B" "_" "a" "0" "1" ).sort, object_keys(ActiveSupport::JSON.encode(values))
  end

  def test_hash_should_allow_key_filtering_with_only
    assert_equal %({"a":1}), ActiveSupport::JSON.encode({ "a" => 1, :b => 2, :c => 3 }, { only: "a" })
  end

  def test_hash_should_allow_key_filtering_with_except
    assert_equal %({"b":2}), ActiveSupport::JSON.encode({ "foo" => "bar", :b => 2, :c => 3 }, { except: ["foo", :c] })
  end

  def test_time_to_json_includes_local_offset
    with_standard_json_time_format(true) do
      with_env_tz "US/Eastern" do
        assert_equal %("2005-02-01T15:15:10.000-05:00"), ActiveSupport::JSON.encode(Time.local(2005, 2, 1, 15, 15, 10))
      end
    end
  end

  def test_hash_with_time_to_json
    with_standard_json_time_format(false) do
      assert_equal '{"time":"2009/01/01 00:00:00 +0000"}', { time: Time.utc(2009) }.to_json
    end
  end

  def test_nested_hash_with_float
    assert_nothing_raised do
      hash = {
        "CHI" => {
          display_name: "chicago",
          latitude: 123.234
        }
      }
      ActiveSupport::JSON.encode(hash)
    end
  end

  def test_hash_like_with_options
    h = JSONTest::Hashlike.new
    json = h.to_json only: [:foo]

    assert_equal({ "foo" => "hello" }, JSON.parse(json))
  end

  def test_object_to_json_with_options
    obj = Object.new
    obj.instance_variable_set :@foo, "hello"
    obj.instance_variable_set :@bar, "world"
    json = obj.to_json only: ["foo"]

    assert_equal({ "foo" => "hello" }, JSON.parse(json))
  end

  def test_struct_to_json_with_options
    struct = Struct.new(:foo, :bar).new
    struct.foo = "hello"
    struct.bar = "world"
    json = struct.to_json only: [:foo]

    assert_equal({ "foo" => "hello" }, JSON.parse(json))
  end

  def test_struct_to_json_with_options_nested
    klass = Struct.new(:foo, :bar)
    struct = klass.new "hello", "world"
    parent_struct = klass.new struct, "world"
    json = parent_struct.to_json only: [:foo]

    assert_equal({ "foo" => { "foo" => "hello" } }, JSON.parse(json))
  end

  def test_hash_should_pass_encoding_options_to_children_in_as_json
    person = {
      name: "John",
      address: {
        city: "London",
        country: "UK"
      }
    }
    json = person.as_json only: [:address, :city]

    assert_equal({ "address" => { "city" => "London" } }, json)
  end

  def test_hash_should_pass_encoding_options_to_children_in_to_json
    person = {
      name: "John",
      address: {
        city: "London",
        country: "UK"
      }
    }
    json = person.to_json only: [:address, :city]

    assert_equal(%({"address":{"city":"London"}}), json)
  end

  def test_array_should_pass_encoding_options_to_children_in_as_json
    people = [
      { name: "John", address: { city: "London", country: "UK" } },
      { name: "Jean", address: { city: "Paris", country: "France" } }
    ]
    json = people.as_json only: [:address, :city]
    expected = [
      { "address" => { "city" => "London" } },
      { "address" => { "city" => "Paris" } }
    ]

    assert_equal(expected, json)
  end

  def test_array_should_pass_encoding_options_to_children_in_to_json
    people = [
      { name: "John", address: { city: "London", country: "UK" } },
      { name: "Jean", address: { city: "Paris", country: "France" } }
    ]
    json = people.to_json only: [:address, :city]

    assert_equal(%([{"address":{"city":"London"}},{"address":{"city":"Paris"}}]), json)
  end

  People = Class.new(BasicObject) do
    include Enumerable
    def initialize
      @people = [
        { name: "John", address: { city: "London", country: "UK" } },
        { name: "Jean", address: { city: "Paris", country: "France" } }
      ]
    end
    def each(*, &blk)
      @people.each do |p|
        yield p if blk
        p
      end.each
    end
  end

  def test_enumerable_should_generate_json_with_as_json
    json = People.new.as_json only: [:address, :city]
    expected = [
      { "address" => { "city" => "London" } },
      { "address" => { "city" => "Paris" } }
    ]

    assert_equal(expected, json)
  end

  def test_enumerable_should_generate_json_with_to_json
    json = People.new.to_json only: [:address, :city]
    assert_equal(%([{"address":{"city":"London"}},{"address":{"city":"Paris"}}]), json)
  end

  def test_enumerable_should_pass_encoding_options_to_children_in_as_json
    json = People.new.each.as_json only: [:address, :city]
    expected = [
      { "address" => { "city" => "London" } },
      { "address" => { "city" => "Paris" } }
    ]

    assert_equal(expected, json)
  end

  def test_enumerable_should_pass_encoding_options_to_children_in_to_json
    json = People.new.each.to_json only: [:address, :city]

    assert_equal(%([{"address":{"city":"London"}},{"address":{"city":"Paris"}}]), json)
  end

  class CustomWithOptions
    attr_accessor :foo, :bar

    def as_json(options = {})
      options[:only] = %w(foo bar)
      super(options)
    end
  end

  def test_hash_to_json_should_not_keep_options_around
    f = CustomWithOptions.new
    f.foo = "hello"
    f.bar = "world"

    hash = { "foo" => f, "other_hash" => { "foo" => "other_foo", "test" => "other_test" } }
    assert_equal({ "foo" => { "foo" => "hello", "bar" => "world" },
                  "other_hash" => { "foo" => "other_foo", "test" => "other_test" } }, ActiveSupport::JSON.decode(hash.to_json))
  end

  def test_array_to_json_should_not_keep_options_around
    f = CustomWithOptions.new
    f.foo = "hello"
    f.bar = "world"

    array = [f, { "foo" => "other_foo", "test" => "other_test" }]
    assert_equal([{ "foo" => "hello", "bar" => "world" },
                  { "foo" => "other_foo", "test" => "other_test" }], ActiveSupport::JSON.decode(array.to_json))
  end

  class OptionsTest
    def as_json(options = :default)
      options
    end
  end

  def test_hash_as_json_without_options
    json = { foo: OptionsTest.new }.as_json
    assert_equal({ "foo" => :default }, json)
  end

  def test_array_as_json_without_options
    json = [ OptionsTest.new ].as_json
    assert_equal([:default], json)
  end

  def test_struct_encoding
    Struct.new("UserNameAndEmail", :name, :email)
    Struct.new("UserNameAndDate", :name, :date)
    Struct.new("Custom", :name, :sub)
    user_email = Struct::UserNameAndEmail.new "David", "sample@example.com"
    user_birthday = Struct::UserNameAndDate.new "David", Date.new(2010, 01, 01)
    custom = Struct::Custom.new "David", user_birthday

    json_strings = ""
    json_string_and_date = ""
    json_custom = ""

    assert_nothing_raised do
      json_strings = user_email.to_json
      json_string_and_date = user_birthday.to_json
      json_custom = custom.to_json
    end

    assert_equal({ "name" => "David",
                  "sub" => {
                    "name" => "David",
                    "date" => "2010-01-01" } }, ActiveSupport::JSON.decode(json_custom))

    assert_equal({ "name" => "David", "email" => "sample@example.com" },
                 ActiveSupport::JSON.decode(json_strings))

    assert_equal({ "name" => "David", "date" => "2010-01-01" },
                 ActiveSupport::JSON.decode(json_string_and_date))
  end

  def test_nil_true_and_false_represented_as_themselves
    assert_nil nil.as_json
    assert_equal true,  true.as_json
    assert_equal false, false.as_json
  end

  class HashWithAsJson < Hash
    attr_accessor :as_json_called

    def initialize(*)
      super
    end

    def as_json(options = {})
      @as_json_called = true
      super
    end
  end

  def test_json_gem_dump_by_passing_active_support_encoder
    h = HashWithAsJson.new
    h[:foo] = "hello"
    h[:bar] = "world"

    assert_equal %({"foo":"hello","bar":"world"}), JSON.dump(h)
    assert_nil h.as_json_called
  end

  def test_json_gem_generate_by_passing_active_support_encoder
    h = HashWithAsJson.new
    h[:foo] = "hello"
    h[:bar] = "world"

    assert_equal %({"foo":"hello","bar":"world"}), JSON.generate(h)
    assert_nil h.as_json_called
  end

  def test_json_gem_pretty_generate_by_passing_active_support_encoder
    h = HashWithAsJson.new
    h[:foo] = "hello"
    h[:bar] = "world"

    assert_equal <<EXPECTED.chomp, JSON.pretty_generate(h)
{
  "foo": "hello",
  "bar": "world"
}
EXPECTED
    assert_nil h.as_json_called
  end

  def test_twz_to_json_with_use_standard_json_time_format_config_set_to_false
    with_standard_json_time_format(false) do
      zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
      time = ActiveSupport::TimeWithZone.new(Time.utc(2000), zone)
      assert_equal "\"1999/12/31 19:00:00 -0500\"", ActiveSupport::JSON.encode(time)
    end
  end

  def test_twz_to_json_with_use_standard_json_time_format_config_set_to_true
    with_standard_json_time_format(true) do
      zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
      time = ActiveSupport::TimeWithZone.new(Time.utc(2000), zone)
      assert_equal "\"1999-12-31T19:00:00.000-05:00\"", ActiveSupport::JSON.encode(time)
    end
  end

  def test_twz_to_json_with_custom_time_precision
    with_standard_json_time_format(true) do
      with_time_precision(0) do
        zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
        time = ActiveSupport::TimeWithZone.new(Time.utc(2000), zone)
        assert_equal "\"1999-12-31T19:00:00-05:00\"", ActiveSupport::JSON.encode(time)
      end
    end
  end

  def test_time_to_json_with_custom_time_precision
    with_standard_json_time_format(true) do
      with_time_precision(0) do
        assert_equal "\"2000-01-01T00:00:00Z\"", ActiveSupport::JSON.encode(Time.utc(2000))
      end
    end
  end

  def test_datetime_to_json_with_custom_time_precision
    with_standard_json_time_format(true) do
      with_time_precision(0) do
        assert_equal "\"2000-01-01T00:00:00+00:00\"", ActiveSupport::JSON.encode(DateTime.new(2000))
      end
    end
  end

  def test_twz_to_json_when_wrapping_a_date_time
    zone = ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
    time = ActiveSupport::TimeWithZone.new(DateTime.new(2000), zone)
    assert_equal '"1999-12-31T19:00:00.000-05:00"', ActiveSupport::JSON.encode(time)
  end

  def test_exception_to_json
    exception = Exception.new("foo")
    assert_equal '"foo"', ActiveSupport::JSON.encode(exception)
  end

  class InfiniteNumber
    def as_json(options = nil)
      { "number" => Float::INFINITY }
    end
  end

  def test_to_json_works_when_as_json_returns_infinite_number
    assert_equal '{"number":null}', InfiniteNumber.new.to_json
  end

  class NaNNumber
    def as_json(options = nil)
      { "number" => Float::NAN }
    end
  end

  def test_to_json_works_when_as_json_returns_NaN_number
    assert_equal '{"number":null}', NaNNumber.new.to_json
  end

  def test_to_json_works_on_io_objects
    assert_equal STDOUT.to_s.to_json, STDOUT.to_json
  end

  private
    def object_keys(json_object)
      json_object[1..-2].scan(/([^{}:,\s]+):/).flatten.sort
    end

    def with_standard_json_time_format(boolean = true)
      old, ActiveSupport.use_standard_json_time_format = ActiveSupport.use_standard_json_time_format, boolean
      yield
    ensure
      ActiveSupport.use_standard_json_time_format = old
    end

    def with_time_precision(value)
      old_value = ActiveSupport::JSON::Encoding.time_precision
      ActiveSupport::JSON::Encoding.time_precision = value
      yield
    ensure
      ActiveSupport::JSON::Encoding.time_precision = old_value
    end
# frozen_string_literal: true

require "bigdecimal"
require "date"
require "time"
require "pathname"
require "uri"

module JSONTest
  class Foo
    def initialize(a, b)
      @a, @b = a, b
    end
  end

  class Hashlike
    def to_hash
      { foo: "hello", bar: "world" }
    end
  end

  class Custom
    def initialize(serialized)
      @serialized = serialized
    end

    def as_json(options = nil)
      @serialized
    end
  end

  MyStruct = Struct.new(:name, :value) do
    def initialize(*)
      @unused = "unused instance variable"
      super
    end
  end

  module EncodingTestCases
    TrueTests     = [[ true,  %(true)  ]]
    FalseTests    = [[ false, %(false) ]]
    NilTests      = [[ nil,   %(null)  ]]
    NumericTests  = [[ 1,     %(1)     ],
                     [ 2.5,   %(2.5)   ],
                     [ 0.0 / 0.0,   %(null) ],
                     [ 1.0 / 0.0,   %(null) ],
                     [ -1.0 / 0.0,  %(null) ],
                     [ BigDecimal("0.0") / BigDecimal("0.0"),  %(null) ],
                     [ BigDecimal("2.5"), %("#{BigDecimal('2.5')}") ]]

    StringTests   = [[ "this is the <string>",     %("this is the \\u003cstring\\u003e")],
                     [ 'a "string" with quotes & an ampersand', %("a \\"string\\" with quotes \\u0026 an ampersand") ],
                     [ "http://test.host/posts/1", %("http://test.host/posts/1")],
                     [ "Control characters: \x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\u2028\u2029",
                       %("Control characters: \\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\\u2028\\u2029") ]]

    ArrayTests    = [[ ["a", "b", "c"],          %([\"a\",\"b\",\"c\"])        ],
                     [ [1, "a", :b, nil, false], %([1,\"a\",\"b\",null,false]) ]]

    HashTests     = [[ { foo: "bar" }, %({\"foo\":\"bar\"}) ],
                     [ { 1 => 1, 2 => "a", 3 => :b, 4 => nil, 5 => false }, %({\"1\":1,\"2\":\"a\",\"3\":\"b\",\"4\":null,\"5\":false}) ]]

    RangeTests    = [[ 1..2,     %("1..2")],
                     [ 1...2,    %("1...2")],
                     [ 1.5..2.5, %("1.5..2.5")]]

    SymbolTests   = [[ :a,     %("a")    ],
                     [ :this,  %("this") ],
                     [ :"a b", %("a b")  ]]

    ObjectTests   = [[ Foo.new(1, 2), %({\"a\":1,\"b\":2}) ]]
    HashlikeTests = [[ Hashlike.new, %({\"bar\":\"world\",\"foo\":\"hello\"}) ]]
    StructTests   = [[ MyStruct.new(:foo, "bar"), %({\"name\":\"foo\",\"value\":\"bar\"}) ],
                     [ MyStruct.new(nil, nil), %({\"name\":null,\"value\":null}) ]]
    CustomTests   = [[ Custom.new("custom"), '"custom"' ],
                     [ Custom.new(nil), "null" ],
                     [ Custom.new(:a), '"a"' ],
                     [ Custom.new([ :foo, "bar" ]), '["foo","bar"]' ],
                     [ Custom.new(foo: "hello", bar: "world"), '{"bar":"world","foo":"hello"}' ],
                     [ Custom.new(Hashlike.new), '{"bar":"world","foo":"hello"}' ],
                     [ Custom.new(Custom.new(Custom.new(:a))), '"a"' ]]

    RegexpTests   = [[ /^a/, '"(?-mix:^a)"' ], [/^\w{1,2}[a-z]+/ix, '"(?ix-m:^\\\\w{1,2}[a-z]+)"']]

    URITests      = [[ URI.parse("http://example.com"), %("http://example.com") ]]

    PathnameTests = [[ Pathname.new("lib/index.rb"), %("lib/index.rb") ]]

    IPAddrTests   = [[  IPAddr.new("127.0.0.1"), %("127.0.0.1") ]]

    DateTests     = [[ Date.new(2005, 2, 1), %("2005/02/01") ]]
    TimeTests     = [[ Time.utc(2005, 2, 1, 15, 15, 10), %("2005/02/01 15:15:10 +0000") ]]
    DateTimeTests = [[ DateTime.civil(2005, 2, 1, 15, 15, 10), %("2005/02/01 15:15:10 +0000") ]]

    StandardDateTests     = [[ Date.new(2005, 2, 1), %("2005-02-01") ]]
# frozen_string_literal: true

require_relative "../abstract_unit"
require "active_support/json"
require "active_support/time"
require_relative "../time_zone_test_helpers"

class TestJSONDecoding < ActiveSupport::TestCase
  include TimeZoneTestHelpers

  class Foo
    def self.json_create(object)
      "Foo"
    end
  end

  TESTS = {
    %q({"returnTo":{"\/categories":"\/"}})        => { "returnTo" => { "/categories" => "/" } },
    %q({"return\\"To\\":":{"\/categories":"\/"}}) => { "return\"To\":" => { "/categories" => "/" } },
    %q({"returnTo":{"\/categories":1}}) => { "returnTo" => { "/categories" => 1 } },
    %({"returnTo":[1,"a"]})                    => { "returnTo" => [1, "a"] },
    %({"returnTo":[1,"\\"a\\",", "b"]})        => { "returnTo" => [1, "\"a\",", "b"] },
    %({"a": "'", "b": "5,000"})                  => { "a" => "'", "b" => "5,000" },
    %({"a": "a's, b's and c's", "b": "5,000"})   => { "a" => "a's, b's and c's", "b" => "5,000" },
    # multibyte
    %({"matzue": "", "asakusa": ""}) => { "matzue" => "", "asakusa" => "" },
    %({"a": "2007-01-01"})                       => { "a" => Date.new(2007, 1, 1) },
    %({"a": "2007-01-01 01:12:34 Z"})            => { "a" => Time.utc(2007, 1, 1, 1, 12, 34) },
    %(["2007-01-01 01:12:34 Z"])                 => [Time.utc(2007, 1, 1, 1, 12, 34)],
    %(["2007-01-01 01:12:34 Z", "2007-01-01 01:12:35 Z"]) => [Time.utc(2007, 1, 1, 1, 12, 34), Time.utc(2007, 1, 1, 1, 12, 35)],
    # no time zone
    %({"a": "2007-01-01 01:12:34"})              => { "a" => Time.new(2007, 1, 1, 1, 12, 34, "-05:00") },
    # invalid date
    %({"a": "1089-10-40"})                       => { "a" => "1089-10-40" },
    # xmlschema date notation
    %({"a": "2009-08-10T19:01:02"})              => { "a" => Time.new(2009, 8, 10, 19, 1, 2, "-04:00") },
    %({"a": "2009-08-10T19:01:02Z"})             => { "a" => Time.utc(2009, 8, 10, 19, 1, 2) },
    %({"a": "2009-08-10T19:01:02+02:00"})        => { "a" => Time.utc(2009, 8, 10, 17, 1, 2) },
    %({"a": "2009-08-10T19:01:02-05:00"})        => { "a" => Time.utc(2009, 8, 11, 00, 1, 2) },
    # needs to be *exact*
    %({"a": " 2007-01-01 01:12:34 Z "})          => { "a" => " 2007-01-01 01:12:34 Z " },
    %({"a": "2007-01-01 : it's your birthday"})  => { "a" => "2007-01-01 : it's your birthday" },
    %({"a": "Today is:\\n2020-05-21"})           => { "a" => "Today is:\n2020-05-21" },
    %({"a": "2007-01-01 01:12:34 Z\\nwas my birthday"}) => { "a" => "2007-01-01 01:12:34 Z\nwas my birthday" },
    %([])    => [],
    %({})    => {},
    %({"a":1}) => { "a" => 1 },
    %({"a": ""}) => { "a" => "" },
    %({"a":"\\""}) => { "a" => "\"" },
    %({"a": null})  => { "a" => nil },
    %({"a": true})  => { "a" => true },
    %({"a": false}) => { "a" => false },
    '{"bad":"\\\\","trailing":""}' => { "bad" => "\\", "trailing" => "" },
    %q({"a": "http:\/\/test.host\/posts\/1"}) => { "a" => "http://test.host/posts/1" },
    %q({"a": "\u003cunicode\u0020escape\u003e"}) => { "a" => "<unicode escape>" },
    '{"a": "\\\\u0020skip double backslashes"}' => { "a" => "\\u0020skip double backslashes" },
    %q({"a": "\u003cbr /\u003e"}) => { "a" => "<br />" },
    %q({"b":["\u003ci\u003e","\u003cb\u003e","\u003cu\u003e"]}) => { "b" => ["<i>", "<b>", "<u>"] },
    # test combination of dates and escaped or unicode encoded data in arrays
    %q([{"d":"1970-01-01", "s":"\u0020escape"},{"d":"1970-01-01", "s":"\u0020escape"}]) =>
      [{ "d" => Date.new(1970, 1, 1), "s" => " escape" }, { "d" => Date.new(1970, 1, 1), "s" => " escape" }],
    %q([{"d":"1970-01-01","s":"http:\/\/example.com"},{"d":"1970-01-01","s":"http:\/\/example.com"}]) =>
      [{ "d" => Date.new(1970, 1, 1), "s" => "http://example.com" },
       { "d" => Date.new(1970, 1, 1), "s" => "http://example.com" }],
    # tests escaping of "\n" char with Yaml backend
    %q({"a":"\n"}) => { "a" => "\n" },
    %q({"a":"\u000a"}) => { "a" => "\n" },
    %q({"a":"Line1\u000aLine2"}) => { "a" => "Line1\nLine2" },
    # prevent json unmarshalling
    '{"json_class":"TestJSONDecoding::Foo"}' => { "json_class" => "TestJSONDecoding::Foo" },
    # json "fragments" - these are invalid JSON, but ActionPack relies on this
    '"a string"' => "a string",
    "1.1" => 1.1,
    "1" => 1,
    "-1" => -1,
    "true" => true,
    "false" => false,
    "null" => nil
  }

  TESTS.each_with_index do |(json, expected), index|
    fail_message = "JSON decoding failed for #{json}"

    test "json decodes #{index}" do
      with_tz_default "Eastern Time (US & Canada)" do
        with_parse_json_times(true) do
          silence_warnings do
            if expected.nil?
              assert_nil ActiveSupport::JSON.decode(json), fail_message
            else
              assert_equal expected, ActiveSupport::JSON.decode(json), fail_message
            end
          end
        end
      end
    end
  end

  test "json decodes time json with time parsing disabled" do
    with_parse_json_times(false) do
      expected = { "a" => "2007-01-01 01:12:34 Z" }
      assert_equal expected, ActiveSupport::JSON.decode(%({"a": "2007-01-01 01:12:34 Z"}))
    end
  end

  def test_failed_json_decoding
    assert_raise(ActiveSupport::JSON.parse_error) { ActiveSupport::JSON.decode(%(undefined)) }
    assert_raise(ActiveSupport::JSON.parse_error) { ActiveSupport::JSON.decode(%({a: 1})) }
    assert_raise(ActiveSupport::JSON.parse_error) { ActiveSupport::JSON.decode(%({: 1})) }
    assert_raise(ActiveSupport::JSON.parse_error) { ActiveSupport::JSON.decode(%()) }
  end

  def test_cannot_pass_unsupported_options
    assert_raise(ArgumentError) { ActiveSupport::JSON.decode("", create_additions: true) }
  end

  private
    def with_parse_json_times(value)
      old_value = ActiveSupport.parse_json_times
      ActiveSupport.parse_json_times = value
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/dependencies/zeitwerk_integration"

class ZeitwerkInflectorTest < ActiveSupport::TestCase
  INFLECTOR = ActiveSupport::Dependencies::ZeitwerkIntegration::Inflector

  def reset_overrides
    INFLECTOR.instance_variable_get(:@overrides).clear
  end

  def camelize(basename)
    INFLECTOR.camelize(basename, nil)
  end

  setup do
    reset_overrides
    @original_inflections = ActiveSupport::Inflector::Inflections.instance_variable_get(:@__instance__)[:en]
    ActiveSupport::Inflector::Inflections.instance_variable_set(:@__instance__, en: @original_inflections.dup)
  end

  teardown do
    reset_overrides
    ActiveSupport::Inflector::Inflections.instance_variable_set(:@__instance__, en: @original_inflections)
  end

  test "it camelizes regular basenames with String#camelize" do
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.acronym("SSL")
    end

    assert_equal "User", camelize("user")
    assert_equal "UsersController", camelize("users_controller")
    assert_equal "Point3d", camelize("point_3d")
    assert_equal "SSLError", camelize("ssl_error")
  end

  test "overrides take precedence" do
    # Precondition, ensure we are testing something.
    assert_equal "MysqlAdapter", camelize("mysql_adapter")

    INFLECTOR.inflect("mysql_adapter" => "MySQLAdapter")
    assert_equal "MySQLAdapter", camelize("mysql_adapter")

# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/core_ext/kernel/singleton_class"

module CallbacksTest
  class Record
    include ActiveSupport::Callbacks

    define_callbacks :save

    def self.before_save(*filters, &blk)
      set_callback(:save, :before, *filters, &blk)
    end

    def self.after_save(*filters, &blk)
      set_callback(:save, :after, *filters, &blk)
    end

    class << self
      def callback_symbol(callback_method)
        method_name = :"#{callback_method}_method"
        define_method(method_name) do
          history << [callback_method, :symbol]
        end
        method_name
      end

      def callback_proc(callback_method)
        Proc.new { |model| model.history << [callback_method, :proc] }
      end

      def callback_object(callback_method)
        klass = Class.new
        klass.define_method(callback_method) do |model|
          model.history << [:"#{callback_method}_save", :object]
        end
        klass.new
      end
    end

    def history
      @history ||= []
    end
  end

  class CallbackClass
    def self.before(model)
      model.history << [:before_save, :class]
    end

    def self.after(model)
      model.history << [:after_save, :class]
    end
  end

  class Person < Record
    attr_accessor :save_fails

    [:before_save, :after_save].each do |callback_method|
      callback_method_sym = callback_method.to_sym
      public_send(callback_method, callback_symbol(callback_method_sym))
      public_send(callback_method, callback_proc(callback_method_sym))
      public_send(callback_method, callback_object(callback_method_sym.to_s.gsub(/_save/, "")))
      public_send(callback_method, CallbackClass)
      public_send(callback_method) { |model| model.history << [callback_method_sym, :block] }
    end

    def save
      run_callbacks :save do
        raise "inside save" if save_fails
      end
    end
  end

  class PersonSkipper < Person
    skip_callback :save, :before, :before_save_method, if: :yes
    skip_callback :save, :after,  :after_save_method, unless: :yes
    skip_callback :save, :after,  :after_save_method, if: :no
    skip_callback :save, :before, :before_save_method, unless: :no
    skip_callback :save, :before, CallbackClass, if: :yes
    def yes; true; end
    def no; false; end
  end

  class PersonForProgrammaticSkipping < Person
  end

  class ParentController
    include ActiveSupport::Callbacks

    define_callbacks :dispatch

    set_callback :dispatch, :before, :log, unless: proc { |c| c.action_name == :index || c.action_name == :show }
    set_callback :dispatch, :after, :log2

    attr_reader :action_name, :logger
    def initialize(action_name)
      @action_name, @logger = action_name, []
    end

    def log
      @logger << action_name
    end

    def log2
      @logger << action_name
    end

    def dispatch
      run_callbacks :dispatch do
        @logger << "Done"
      end
      self
    end
  end

  class Child < ParentController
    skip_callback :dispatch, :before, :log, if: proc { |c| c.action_name == :update }
    skip_callback :dispatch, :after, :log2
  end

  class OneTimeCompile < Record
    @@starts_true, @@starts_false = true, false

    def initialize
      super
    end

    before_save Proc.new { |r| r.history << [:before_save, :starts_true, :if] }, if: :starts_true
    before_save Proc.new { |r| r.history << [:before_save, :starts_false, :if] }, if: :starts_false
    before_save Proc.new { |r| r.history << [:before_save, :starts_true, :unless] }, unless: :starts_true
    before_save Proc.new { |r| r.history << [:before_save, :starts_false, :unless] }, unless: :starts_false

    def starts_true
      if @@starts_true
        @@starts_true = false
        return true
      end
      @@starts_true
    end

    def starts_false
      unless @@starts_false
        @@starts_false = true
        return false
      end
      @@starts_false
    end

    def save
      run_callbacks :save
    end
  end

  class OneTimeCompileTest < ActiveSupport::TestCase
    def test_optimized_first_compile
      around = OneTimeCompile.new
      around.save
      assert_equal [
        [:before_save, :starts_true, :if],
        [:before_save, :starts_true, :unless]
      ], around.history
    end
  end

  class AfterSaveConditionalPerson < Record
    after_save Proc.new { |r| r.history << [:after_save, :string1] }
    after_save Proc.new { |r| r.history << [:after_save, :string2] }
    def save
      run_callbacks :save
    end
  end

  class AfterSaveConditionalPersonCallbackTest < ActiveSupport::TestCase
    def test_after_save_runs_in_the_reverse_order
      person = AfterSaveConditionalPerson.new
      person.save
      assert_equal [
        [:after_save, :string2],
        [:after_save, :string1]
      ], person.history
    end
  end

  class ConditionalPerson < Record
    # proc
    before_save Proc.new { |r| r.history << [:before_save, :proc] }, if: Proc.new { |r| true }
    before_save Proc.new { |r| r.history << "b00m" }, if: Proc.new { |r| false }
    before_save Proc.new { |r| r.history << [:before_save, :proc] }, unless: Proc.new { |r| false }
    before_save Proc.new { |r| r.history << "b00m" }, unless: Proc.new { |r| true }
    # symbol
    before_save Proc.new { |r| r.history << [:before_save, :symbol] }, if: :yes
    before_save Proc.new { |r| r.history << "b00m" }, if: :no
    before_save Proc.new { |r| r.history << [:before_save, :symbol] }, unless: :no
    before_save Proc.new { |r| r.history << "b00m" }, unless: :yes
    # Combined if and unless
    before_save Proc.new { |r| r.history << [:before_save, :combined_symbol] }, if: :yes, unless: :no
    before_save Proc.new { |r| r.history << "b00m" }, if: :yes, unless: :yes

    def yes; true; end
    def other_yes; true; end
    def no; false; end
    def other_no; false; end

    def save
      run_callbacks :save
    end
  end

  class CleanPerson < ConditionalPerson
    reset_callbacks :save
  end

  class MySuper
    include ActiveSupport::Callbacks
    define_callbacks :save
  end

  class MySlate < MySuper
    attr_reader :history
    attr_accessor :save_fails

    def initialize
      @history = []
    end

    def save
      run_callbacks :save do
        raise "inside save" if save_fails
        @history << "running"
      end
    end

    def no; false; end
    def yes; true; end

    def method_missing(sym, *)
      case sym
      when /^log_(.*)/
        @history << $1
        nil
      when /^wrap_(.*)/
        @history << "wrap_#$1"
        yield
        @history << "unwrap_#$1"
        nil
      when /^double_(.*)/
        @history << "first_#$1"
        yield
        @history << "second_#$1"
        yield
        @history << "third_#$1"
      else
        super
      end
    end

    def respond_to_missing?(sym)
      sym.match?(/^(log|wrap)_/) || super
    end
  end

  class AroundPerson < MySlate
    set_callback :save, :before, :nope,           if: :no
    set_callback :save, :before, :nope,           unless: :yes
    set_callback :save, :after,  :tweedle
    set_callback :save, :before, proc { |m| m.history << "yup" }
    set_callback :save, :before, :nope,           if: proc { false }
    set_callback :save, :before, :nope,           unless: proc { true }
    set_callback :save, :before, :yup,            if: proc { true }
    set_callback :save, :before, :yup,            unless: proc { false }
    set_callback :save, :around, :tweedle_dum
    set_callback :save, :around, :w0tyes,         if: :yes
    set_callback :save, :around, :w0tno,          if: :no
    set_callback :save, :around, :tweedle_deedle

    def nope
      @history << "boom"
    end

    def yup
      @history << "yup"
    end

    def w0tyes
      @history << "w0tyes before"
      yield
      @history << "w0tyes after"
    end

    def w0tno
      @history << "boom"
      yield
    end

    def tweedle_dum
      @history << "tweedle dum pre"
      yield
      @history << "tweedle dum post"
    end

    def tweedle
      @history << "tweedle"
    end

    def tweedle_deedle
      @history << "tweedle deedle pre"
      yield
      @history << "tweedle deedle post"
    end
  end

  class AroundPersonResult < MySuper
    attr_reader :result

    set_callback :save, :after, :tweedle_1
    set_callback :save, :around, :tweedle_dum
    set_callback :save, :after, :tweedle_2

    def tweedle_dum
      @result = yield
    end

    def tweedle_1
      :tweedle_1
    end

    def tweedle_2
      :tweedle_2
    end

    def save
      run_callbacks :save do
        :running
      end
    end
  end

  class HyphenatedCallbacks
    include ActiveSupport::Callbacks
    define_callbacks :save
    attr_reader :stuff

    set_callback :save, :before, :action, if: :yes

    def yes() true end

    def action
      @stuff = "ACTION"
    end

    def save
      run_callbacks :save do
        @stuff
      end
    end
  end

  module ExtendModule
    def self.extended(base)
      base.class_eval do
        set_callback :save, :before, :record3
      end
    end
    def record3
      @recorder << 3
    end
  end

  module IncludeModule
    def self.included(base)
      base.class_eval do
        set_callback :save, :before, :record2
      end
    end
    def record2
      @recorder << 2
    end
  end

  class ExtendCallbacks
    include ActiveSupport::Callbacks

    define_callbacks :save
    set_callback :save, :before, :record1

    include IncludeModule

    def save
      run_callbacks :save
    end

    attr_reader :recorder

    def initialize
      @recorder = []
    end

    private
      def record1
        @recorder << 1
      end
  end

  class AroundCallbacksTest < ActiveSupport::TestCase
    def test_save_around
      around = AroundPerson.new
      around.save
      assert_equal [
        "yup", "yup",
        "tweedle dum pre",
        "w0tyes before",
        "tweedle deedle pre",
        "running",
        "tweedle deedle post",
        "w0tyes after",
        "tweedle dum post",
        "tweedle"
      ], around.history
    end
  end

  class DoubleYieldTest < ActiveSupport::TestCase
    class DoubleYieldModel < MySlate
      set_callback :save, :around, :wrap_outer
      set_callback :save, :around, :double_trouble
      set_callback :save, :around, :wrap_inner
    end

    def test_double_save
      double = DoubleYieldModel.new
      double.save
      assert_equal [
        "wrap_outer",
        "first_trouble",
        "wrap_inner",
        "running",
        "unwrap_inner",
        "second_trouble",
        "wrap_inner",
        "running",
        "unwrap_inner",
        "third_trouble",
        "unwrap_outer",
      ], double.history
    end
  end

  class CallStackTest < ActiveSupport::TestCase
    def test_tidy_call_stack
      around = AroundPerson.new
      around.save_fails = true

      exception = (around.save rescue $!)

      # Make sure we have the exception we're expecting
      assert_equal "inside save", exception.message

      call_stack = exception.backtrace_locations
      call_stack.pop caller_locations(0).size

      # Yes, this looks like an implementation test, but it's the least
      # obtuse way of asserting that there aren't a load of entries in
      # the call stack for each callback.
      #
      # If you've renamed a method, or squeezed more lines out, go ahead
      # and update this assertion. But if you're here because a
      # refactoring added new lines, please reconsider.

      # As shown here, our current budget is one line for run_callbacks
      # itself, plus N+1 lines where N is the number of :around
      # callbacks that have been invoked, if there are any (plus
      # whatever the callbacks do themselves, of course).

      assert_equal [
        "block in save",
        "block in run_callbacks",
        "tweedle_deedle",
        "block in run_callbacks",
        "w0tyes",
        "block in run_callbacks",
        "tweedle_dum",
        "block in run_callbacks",
        "run_callbacks",
        "save"
      ], call_stack.map(&:label)
    end

    def test_short_call_stack
      person = Person.new
      person.save_fails = true

      exception = (person.save rescue $!)

      # Make sure we have the exception we're expecting
      assert_equal "inside save", exception.message

      call_stack = exception.backtrace_locations
      call_stack.pop caller_locations(0).size

      # This budget much simpler: with no :around callbacks invoked,
      # there should be just one line. run_callbacks yields directly
      # back to its caller.

      assert_equal [
        "block in save",
        "run_callbacks",
        "save"
      ], call_stack.map(&:label)
    end
  end

  class AroundCallbackResultTest < ActiveSupport::TestCase
    def test_save_around
      around = AroundPersonResult.new
      around.save
      assert_equal :running, around.result
    end
  end

  class SkipCallbacksTest < ActiveSupport::TestCase
    def test_skip_person
      person = PersonSkipper.new
      assert_equal [], person.history
      person.save
      assert_equal [
        [:before_save, :proc],
        [:before_save, :object],
        [:before_save, :block],
        [:after_save, :block],
        [:after_save, :class],
        [:after_save, :object],
        [:after_save, :proc],
        [:after_save, :symbol]
      ], person.history
    end

    def test_skip_person_programmatically
      PersonForProgrammaticSkipping._save_callbacks.each do |save_callback|
        if "before" == save_callback.kind.to_s
          PersonForProgrammaticSkipping.skip_callback("save", save_callback.kind, save_callback.filter)
        end
      end
      person = PersonForProgrammaticSkipping.new
      assert_equal [], person.history
      person.save
      assert_equal [
        [:after_save, :block],
        [:after_save, :class],
        [:after_save, :object],
        [:after_save, :proc],
        [:after_save, :symbol]
      ], person.history
    end
  end

  class CallbacksTest < ActiveSupport::TestCase
    def test_save_person
      person = Person.new
      assert_equal [], person.history
      person.save
      assert_equal [
        [:before_save, :symbol],
        [:before_save, :proc],
        [:before_save, :object],
        [:before_save, :class],
        [:before_save, :block],
        [:after_save, :block],
        [:after_save, :class],
        [:after_save, :object],
        [:after_save, :proc],
        [:after_save, :symbol]
      ], person.history
    end
  end

  class ConditionalCallbackTest < ActiveSupport::TestCase
    def test_save_conditional_person
      person = ConditionalPerson.new
      person.save
      assert_equal [
        [:before_save, :proc],
        [:before_save, :proc],
        [:before_save, :symbol],
        [:before_save, :symbol],
        [:before_save, :combined_symbol],
      ], person.history
    end
  end

  class ResetCallbackTest < ActiveSupport::TestCase
    def test_save_conditional_person
      person = CleanPerson.new
      person.save
      assert_equal [], person.history
    end
  end

  class AbstractCallbackTerminator
    include ActiveSupport::Callbacks

    def self.set_save_callbacks
      set_callback :save, :before, :first
      set_callback :save, :before, :second
      set_callback :save, :around, :around_it
      set_callback :save, :before, :third
      set_callback :save, :after, :first
      set_callback :save, :around, :around_it
      set_callback :save, :after, :third
    end

    attr_reader :history, :saved, :halted, :callback_name
    def initialize
      @history = []
    end

    def around_it
      @history << "around1"
      yield
      @history << "around2"
    end

    def first
      @history << "first"
    end

    def second
      @history << "second"
      :halt
    end

    def third
      @history << "third"
    end

    def save
      run_callbacks :save do
        @saved = true
      end
    end

    def halted_callback_hook(filter, name)
      @halted = filter
      @callback_name = name
    end
  end

  class CallbackTerminator < AbstractCallbackTerminator
    define_callbacks :save, terminator: ->(_, result_lambda) { result_lambda.call == :halt }
    set_save_callbacks
  end

  class CallbackTerminatorSkippingAfterCallbacks < AbstractCallbackTerminator
    define_callbacks :save, terminator: ->(_, result_lambda) { result_lambda.call == :halt },
                            skip_after_callbacks_if_terminated: true
    set_save_callbacks
  end

  class CallbackDefaultTerminator < AbstractCallbackTerminator
    define_callbacks :save

    def second
      @history << "second"
      throw(:abort)
    end

    set_save_callbacks
  end

  class CallbackFalseTerminator < AbstractCallbackTerminator
    define_callbacks :save

    def second
      @history << "second"
      false
    end

    set_save_callbacks
  end

  class CallbackObject
    def before(caller)
      caller.record << "before"
    end

    def before_save(caller)
      caller.record << "before save"
    end

    def around(caller)
      caller.record << "around before"
      yield
      caller.record << "around after"
    end
  end

  class UsingObjectBefore
    include ActiveSupport::Callbacks

    define_callbacks :save
    set_callback :save, :before, CallbackObject.new

    attr_accessor :record
    def initialize
      @record = []
    end

    def save
      run_callbacks :save do
        @record << "yielded"
      end
    end
  end

  class UsingObjectAround
    include ActiveSupport::Callbacks

    define_callbacks :save
    set_callback :save, :around, CallbackObject.new

    attr_accessor :record
    def initialize
      @record = []
    end

    def save
      run_callbacks :save do
        @record << "yielded"
      end
    end
  end

  class CustomScopeObject
    include ActiveSupport::Callbacks

    define_callbacks :save, scope: [:kind, :name]
    set_callback :save, :before, CallbackObject.new

    attr_accessor :record
    def initialize
      @record = []
    end

    def save
      run_callbacks :save do
        @record << "yielded"
        "CallbackResult"
      end
    end
  end

  class OneTwoThreeSave
    include ActiveSupport::Callbacks

    define_callbacks :save

    attr_accessor :record

    def initialize
      @record = []
    end

    def save
      run_callbacks :save do
        @record << "yielded"
      end
    end

    def first
      @record << "one"
    end

    def second
      @record << "two"
    end

    def third
      @record << "three"
    end
  end

  class DuplicatingCallbacks < OneTwoThreeSave
    set_callback :save, :before, :first, :second
    set_callback :save, :before, :first, :third
  end

  class DuplicatingCallbacksInSameCall < OneTwoThreeSave
    set_callback :save, :before, :first, :second, :first, :third
  end

  class UsingObjectTest < ActiveSupport::TestCase
    def test_before_object
      u = UsingObjectBefore.new
      u.save
      assert_equal ["before", "yielded"], u.record
    end

    def test_around_object
      u = UsingObjectAround.new
      u.save
      assert_equal ["around before", "yielded", "around after"], u.record
    end

    def test_customized_object
      u = CustomScopeObject.new
      u.save
      assert_equal ["before save", "yielded"], u.record
    end

    def test_block_result_is_returned
      u = CustomScopeObject.new
      assert_equal "CallbackResult", u.save
    end
  end

  class CallbackTerminatorTest < ActiveSupport::TestCase
    def test_termination_skips_following_before_and_around_callbacks
      terminator = CallbackTerminator.new
      terminator.save
      assert_equal ["first", "second", "third", "first"], terminator.history
    end

    def test_termination_invokes_hook
      terminator = CallbackTerminator.new
      terminator.save
      assert_equal :second, terminator.halted
      assert_equal :save, terminator.callback_name
    end

    def test_block_never_called_if_terminated
      obj = CallbackTerminator.new
      obj.save
      assert_not obj.saved
    end
  end

  class CallbackTerminatorSkippingAfterCallbacksTest < ActiveSupport::TestCase
    def test_termination_skips_after_callbacks
      terminator = CallbackTerminatorSkippingAfterCallbacks.new
      terminator.save
      assert_equal ["first", "second"], terminator.history
    end
  end

  class CallbackDefaultTerminatorTest < ActiveSupport::TestCase
    def test_default_termination
      terminator = CallbackDefaultTerminator.new
      terminator.save
      assert_equal ["first", "second", "third", "first"], terminator.history
    end

    def test_default_termination_invokes_hook
      terminator = CallbackDefaultTerminator.new
      terminator.save
      assert_equal :second, terminator.halted
    end

    def test_block_never_called_if_abort_is_thrown
      obj = CallbackDefaultTerminator.new
      obj.save
      assert_not obj.saved
    end
  end

  class CallbackFalseTerminatorTest < ActiveSupport::TestCase
    def test_returning_false_does_not_halt_callback
      obj = CallbackFalseTerminator.new
      obj.save
      assert_nil obj.halted
      assert obj.saved
    end
  end

  class HyphenatedKeyTest < ActiveSupport::TestCase
    def test_save
      obj = HyphenatedCallbacks.new
      obj.save
      assert_equal "ACTION", obj.stuff
    end
  end

  class WriterSkipper < Person
    attr_accessor :age
    skip_callback :save, :before, :before_save_method, if: -> { age > 21 }
  end

  class WriterCallbacksTest < ActiveSupport::TestCase
    def test_skip_writer
      writer = WriterSkipper.new
      writer.age = 18
      assert_equal [], writer.history
      writer.save
      assert_equal [
        [:before_save, :symbol],
        [:before_save, :proc],
        [:before_save, :object],
        [:before_save, :class],
        [:before_save, :block],
        [:after_save, :block],
        [:after_save, :class],
        [:after_save, :object],
        [:after_save, :proc],
        [:after_save, :symbol]
      ], writer.history
    end
  end

  class ExtendCallbacksTest < ActiveSupport::TestCase
    def test_save
      model = ExtendCallbacks.new.extend ExtendModule
      model.save
      assert_equal [1, 2, 3], model.recorder
    end
  end

  class ExcludingDuplicatesCallbackTest < ActiveSupport::TestCase
    def test_excludes_duplicates_in_separate_calls
      model = DuplicatingCallbacks.new
      model.save
      assert_equal ["two", "one", "three", "yielded"], model.record
    end

    def test_excludes_duplicates_in_one_call
      model = DuplicatingCallbacksInSameCall.new
      model.save
      assert_equal ["two", "one", "three", "yielded"], model.record
    end
  end

  class CallbackProcTest < ActiveSupport::TestCase
    def build_class(callback)
      Class.new {
        include ActiveSupport::Callbacks
        define_callbacks :foo
        set_callback :foo, :before, callback
        def run; run_callbacks :foo; end
      }
    end

    def test_proc_arity_0
      calls = []
      klass = build_class(->() { calls << :foo })
      klass.new.run
      assert_equal [:foo], calls
    end

    def test_proc_arity_1
      calls = []
      klass = build_class(->(o) { calls << o })
      instance = klass.new
      instance.run
      assert_equal [instance], calls
    end

    def test_proc_arity_2
      assert_raises(ArgumentError) do
        klass = build_class(->(x, y) { })
        klass.new.run
      end
    end

    def test_proc_negative_called_with_empty_list
      calls = []
      klass = build_class(->(*args) { calls << args })
      klass.new.run
      assert_equal [[]], calls
    end
  end

  class ConditionalTests < ActiveSupport::TestCase
    def build_class(callback)
      Class.new {
        include ActiveSupport::Callbacks
        define_callbacks :foo
        set_callback :foo, :before, :foo, if: callback
        def foo; end
        def run; run_callbacks :foo; end
      }
    end

    # FIXME: do we really want to support classes as conditionals?  There were
    # no tests for it previous to this.
    def test_class_conditional_with_scope
      z = []
      callback = Class.new {
        define_singleton_method(:foo) { |o| z << o }
      }
      klass = Class.new {
        include ActiveSupport::Callbacks
        define_callbacks :foo, scope: [:name]
        set_callback :foo, :before, :foo, if: callback
        def run; run_callbacks :foo; end

        private
          def foo; end
      }
      object = klass.new
      object.run
      assert_equal [object], z
    end

    # FIXME: do we really want to support classes as conditionals?  There were
    # no tests for it previous to this.
    def test_class
      z = []
      klass = build_class Class.new {
        define_singleton_method(:before) { |o| z << o }
      }
      object = klass.new
      object.run
      assert_equal [object], z
    end

    def test_proc_negative_arity # passes an empty list if *args
      z = []
      object = build_class(->(*args) { z << args }).new
      object.run
      assert_equal [], z.flatten
    end

    def test_proc_arity0
      z = []
      object = build_class(->() { z << 0 }).new
      object.run
      assert_equal [0], z
    end

    def test_proc_arity1
      z = []
      object = build_class(->(x) { z << x }).new
      object.run
      assert_equal [object], z
    end

    def test_proc_arity2
      assert_raises(ArgumentError) do
        object = build_class(->(a, b) { }).new
        object.run
      end
    end
  end

  class ResetCallbackTest < ActiveSupport::TestCase
    def build_class(memo)
      klass = Class.new {
        include ActiveSupport::Callbacks
        define_callbacks :foo
        set_callback :foo, :before, :hello
        def run; run_callbacks :foo; end
      }
      klass.class_eval {
        define_method(:hello) { memo << :hi }
      }
      klass
    end

    def test_reset_callbacks
      events = []
      klass = build_class events
      klass.new.run
      assert_equal 1, events.length

      klass.reset_callbacks :foo
      klass.new.run
      assert_equal 1, events.length
    end

    def test_reset_impacts_subclasses
      events = []
      klass = build_class events
      subclass = Class.new(klass) { set_callback :foo, :before, :world }
      subclass.class_eval { define_method(:world) { events << :world } }

      subclass.new.run
      assert_equal 2, events.length

      klass.reset_callbacks :foo
      subclass.new.run
      assert_equal 3, events.length
    end
  end

  class CallbackTypeTest < ActiveSupport::TestCase
    def build_class(callback, n = 10)
      Class.new {
        include ActiveSupport::Callbacks
        define_callbacks :foo
        n.times { set_callback :foo, :before, callback }
        def run; run_callbacks :foo; end
        def self.skip(*things); skip_callback :foo, :before, *things; end
      }
    end

    def test_add_class
      calls = []
      callback = Class.new {
        define_singleton_method(:before) { |o| calls << o }
      }
      build_class(callback).new.run
      assert_equal 10, calls.length
    end

    def test_add_lambda
      calls = []
      build_class(->(o) { calls << o }).new.run
      assert_equal 10, calls.length
    end

    def test_add_symbol
      calls = []
      klass = build_class(:bar)
      klass.class_eval { define_method(:bar) { calls << klass } }
      klass.new.run
      assert_equal 1, calls.length
    end

    def test_skip_class # removes one at a time
      calls = []
      callback = Class.new {
        define_singleton_method(:before) { |o| calls << o }
      }
      klass = build_class(callback)
      9.downto(0) { |i|
        klass.skip callback
        klass.new.run
        assert_equal i, calls.length
        calls.clear
      }
    end

    def test_skip_lambda # raises error
      calls = []
      callback = ->(o) { calls << o }
      klass = build_class(callback)
      assert_raises(ArgumentError) { klass.skip callback }
      klass.new.run
      assert_equal 10, calls.length
    end

    def test_skip_symbol # removes all
      calls = []
      klass = build_class(:bar)
      klass.class_eval { define_method(:bar) { calls << klass } }
      klass.skip :bar
      klass.new.run
      assert_equal 0, calls.length
    end

    def test_skip_string # raises error
      calls = []
      klass = build_class(:bar)
      klass.class_eval { define_method(:bar) { calls << klass } }
      assert_raises(ArgumentError) { klass.skip "bar" }
      klass.new.run
      assert_equal 1, calls.length
    end

    def test_skip_undefined_callback # raises error
      calls = []
      klass = build_class(:bar)
      klass.class_eval { define_method(:bar) { calls << klass } }
      assert_raises(ArgumentError) { klass.skip :qux }
      klass.new.run
      assert_equal 1, calls.length
    end

    def test_skip_without_raise # removes nothing
      calls = []
      klass = build_class(:bar)
      klass.class_eval { define_method(:bar) { calls << klass } }
      klass.skip :qux, raise: false
      klass.new.run
      assert_equal 1, calls.length
    end
  end

  class NotSupportedStringConditionalTest < ActiveSupport::TestCase
    def test_string_conditional_options
      klass = Class.new(Record)

      assert_raises(ArgumentError) { klass.before_save :tweedle, if: ["true"] }
      assert_raises(ArgumentError) { klass.before_save :tweedle, if: "true" }
      assert_raises(ArgumentError) { klass.after_save :tweedle, unless: "false" }
      assert_raises(ArgumentError) { klass.skip_callback :save, :before, :tweedle, if: "true" }
      assert_raises(ArgumentError) { klass.skip_callback :save, :after, :tweedle, unless: "false" }
    end
  end

  class NotPermittedStringCallbackTest < ActiveSupport::TestCase
    def test_passing_string_callback_is_not_permitted
      klass = Class.new(Record)

      assert_raises(ArgumentError) do
        klass.before_save "tweedle"
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/logger_silence"
require "logger"

class LoggerSilenceTest < ActiveSupport::TestCase
  class MyLogger < ::Logger
    include ActiveSupport::LoggerSilence
  end

  setup do
    @io = StringIO.new
    @logger = MyLogger.new(@io)
  end

  test "#silence silences the log" do
    @logger.silence(Logger::ERROR) do
      @logger.info("Foo")
    end
    @io.rewind

    assert_empty @io.read
  end

  test "#debug? is true when setting the temporary level to Logger::DEBUG" do
    @logger.level = Logger::INFO

    @logger.silence(Logger::DEBUG) do
      assert_predicate @logger, :debug?
# frozen_string_literal: true

require_relative "abstract_unit"
require "openssl"

class DigestTest < ActiveSupport::TestCase
  class InvalidDigest; end
  def test_with_default_hash_digest_class
    assert_equal OpenSSL::Digest::MD5.hexdigest("hello friend"), ActiveSupport::Digest.hexdigest("hello friend")
  end

  def test_with_custom_hash_digest_class
    original_hash_digest_class = ActiveSupport::Digest.hash_digest_class

    ActiveSupport::Digest.hash_digest_class = OpenSSL::Digest::SHA1
    digest = ActiveSupport::Digest.hexdigest("hello friend")

    assert_equal 32, digest.length
    assert_equal OpenSSL::Digest::SHA1.hexdigest("hello friend")[0...32], digest
  ensure
    ActiveSupport::Digest.hash_digest_class = original_hash_digest_class
  end

  def test_should_raise_argument_error_if_custom_digest_is_missing_hexdigest_method
    assert_raises(ArgumentError) { ActiveSupport::Digest.hash_digest_class = InvalidDigest }
# frozen_string_literal: true

require_relative "abstract_unit"
require "active_support/json"
require "active_support/core_ext/object/json"
require "active_support/core_ext/hash/indifferent_access"
require "active_support/core_ext/array/extract_options"

class OrderedHashTest < ActiveSupport::TestCase
  def setup
    @keys =   %w( blue   green  red    pink   orange )
    @values = %w( 000099 009900 aa0000 cc0066 cc6633 )
    @hash = Hash.new
    @ordered_hash = ActiveSupport::OrderedHash.new

    @keys.each_with_index do |key, index|
      @hash[key] = @values[index]
      @ordered_hash[key] = @values[index]
    end
  end

  def test_order
    assert_equal @keys,   @ordered_hash.keys
    assert_equal @values, @ordered_hash.values
  end

  def test_access
    assert @hash.all? { |k, v| @ordered_hash[k] == v }
  end

  def test_assignment
    key, value = "purple", "5422a8"

    @ordered_hash[key] = value
    assert_equal @keys.length + 1, @ordered_hash.length
    assert_equal key, @ordered_hash.keys.last
    assert_equal value, @ordered_hash.values.last
    assert_equal value, @ordered_hash[key]
  end

  def test_delete
    key, value = "white", "ffffff"
    bad_key = "black"

    @ordered_hash[key] = value
    assert_equal @keys.length + 1, @ordered_hash.length
    assert_equal @ordered_hash.keys.length, @ordered_hash.length

    assert_equal value, @ordered_hash.delete(key)
    assert_equal @keys.length, @ordered_hash.length
    assert_equal @ordered_hash.keys.length, @ordered_hash.length

    assert_nil @ordered_hash.delete(bad_key)
  end

  def test_to_hash
    assert_same @ordered_hash, @ordered_hash.to_hash
  end

  def test_to_a
    assert_equal @keys.zip(@values), @ordered_hash.to_a
  end

  def test_has_key
    assert_equal true, @ordered_hash.has_key?("blue")
    assert_equal true, @ordered_hash.key?("blue")
    assert_equal true, @ordered_hash.include?("blue")
    assert_equal true, @ordered_hash.member?("blue")

    assert_equal false, @ordered_hash.has_key?("indigo")
    assert_equal false, @ordered_hash.key?("indigo")
    assert_equal false, @ordered_hash.include?("indigo")
    assert_equal false, @ordered_hash.member?("indigo")
  end

  def test_has_value
    assert_equal true, @ordered_hash.has_value?("000099")
    assert_equal true, @ordered_hash.value?("000099")
    assert_equal false, @ordered_hash.has_value?("ABCABC")
    assert_equal false, @ordered_hash.value?("ABCABC")
  end

  def test_each_key
    keys = []
    assert_equal @ordered_hash, @ordered_hash.each_key { |k| keys << k }
    assert_equal @keys, keys
    assert_kind_of Enumerator, @ordered_hash.each_key
  end

  def test_each_value
    values = []
    assert_equal @ordered_hash, @ordered_hash.each_value { |v| values << v }
    assert_equal @values, values
    assert_kind_of Enumerator, @ordered_hash.each_value
  end

  def test_each
    values = []
    assert_equal @ordered_hash, @ordered_hash.each { |key, value| values << value }
    assert_equal @values, values
    assert_kind_of Enumerator, @ordered_hash.each
  end

  def test_each_with_index
    @ordered_hash.each_with_index { |pair, index| assert_equal [@keys[index], @values[index]], pair }
  end

  def test_each_pair
    values = []
    keys = []
    @ordered_hash.each_pair do |key, value|
      keys << key
      values << value
    end
    assert_equal @values, values
    assert_equal @keys, keys
    assert_kind_of Enumerator, @ordered_hash.each_pair
  end

  def test_find_all
    assert_equal @keys, @ordered_hash.find_all { true }.map(&:first)
  end

  def test_select
    new_ordered_hash = @ordered_hash.select { true }
    assert_equal @keys, new_ordered_hash.map(&:first)
    assert_instance_of ActiveSupport::OrderedHash, new_ordered_hash
  end

  def test_delete_if
    copy = @ordered_hash.dup
    copy.delete("pink")
    assert_equal copy, @ordered_hash.delete_if { |k, _| k == "pink" }
    assert_not_includes @ordered_hash.keys, "pink"
  end

  def test_reject!
    (copy = @ordered_hash.dup).delete("pink")
    @ordered_hash.reject! { |k, _| k == "pink" }
    assert_equal copy, @ordered_hash
    assert_not_includes @ordered_hash.keys, "pink"
  end

  def test_reject
    copy = @ordered_hash.dup
    new_ordered_hash = @ordered_hash.reject { |k, _| k == "pink" }
    assert_equal copy, @ordered_hash
    assert_not_includes new_ordered_hash.keys, "pink"
    assert_includes @ordered_hash.keys, "pink"
    assert_instance_of ActiveSupport::OrderedHash, new_ordered_hash
  end

  def test_clear
    @ordered_hash.clear
    assert_equal [], @ordered_hash.keys
  end

  def test_merge
    other_hash = ActiveSupport::OrderedHash.new
    other_hash["purple"] = "800080"
    other_hash["violet"] = "ee82ee"
    merged = @ordered_hash.merge other_hash
    assert_equal merged.length, @ordered_hash.length + other_hash.length
    assert_equal @keys + ["purple", "violet"], merged.keys
  end

  def test_merge_with_block
    hash = ActiveSupport::OrderedHash.new
    hash[:a] = 0
    hash[:b] = 0
    merged = hash.merge(b: 2, c: 7) do |key, old_value, new_value|
      new_value + 1
    end

    assert_equal 0, merged[:a]
    assert_equal 3, merged[:b]
    assert_equal 7, merged[:c]
  end

  def test_merge_bang_with_block
    hash = ActiveSupport::OrderedHash.new
    hash[:a] = 0
    hash[:b] = 0
    hash.merge!(a: 1, c: 7) do |key, old_value, new_value|
      new_value + 3
    end

    assert_equal 4, hash[:a]
    assert_equal 0, hash[:b]
    assert_equal 7, hash[:c]
  end

  def test_shift
    pair = @ordered_hash.shift
    assert_equal [@keys.first, @values.first], pair
    assert_not_includes @ordered_hash.keys, pair.first
  end

  def test_keys
    original = @ordered_hash.keys.dup
    @ordered_hash.keys.pop
    assert_equal original, @ordered_hash.keys
  end

  def test_inspect
    assert_includes @ordered_hash.inspect, @hash.inspect
  end

  def test_json
    ordered_hash = ActiveSupport::OrderedHash[:foo, :bar]
    hash = Hash[:foo, :bar]
    assert_equal ordered_hash.to_json, hash.to_json
  end

  def test_alternate_initialization_with_splat
    alternate = ActiveSupport::OrderedHash[1, 2, 3, 4]
    assert_kind_of ActiveSupport::OrderedHash, alternate
    assert_equal [1, 3], alternate.keys
  end

  def test_alternate_initialization_with_array
    alternate = ActiveSupport::OrderedHash[ [
      [1, 2],
      [3, 4],
      [ "missing value" ]
    ]]

    assert_kind_of ActiveSupport::OrderedHash, alternate
    assert_equal [1, 3, "missing value"], alternate.keys
    assert_equal [2, 4, nil ], alternate.values
  end

  def test_alternate_initialization_raises_exception_on_odd_length_args
    assert_raises ArgumentError do
      ActiveSupport::OrderedHash[1, 2, 3, 4, 5]
    end
  end

  def test_replace_updates_keys
    @other_ordered_hash = ActiveSupport::OrderedHash[:black, "000000", :white, "000000"]
    original = @ordered_hash.replace(@other_ordered_hash)
    assert_same original, @ordered_hash
    assert_equal @other_ordered_hash.keys, @ordered_hash.keys
  end

  def test_nested_under_indifferent_access
    flash = { a: ActiveSupport::OrderedHash[:b, 1, :c, 2] }.with_indifferent_access
    assert_kind_of ActiveSupport::OrderedHash, flash[:a]
  end

  def test_each_after_yaml_serialization
    assert_equal @values, YAML.load(YAML.dump(@ordered_hash)).values
  end

  def test_each_when_yielding_to_block_with_splat
    hash_values         = []
    ordered_hash_values = []

    @hash.each         { |*v| hash_values         << v }
    @ordered_hash.each { |*v| ordered_hash_values << v }

    assert_equal hash_values.sort, ordered_hash_values.sort
  end

  def test_each_pair_when_yielding_to_block_with_splat
    hash_values         = []
    ordered_hash_values = []

    @hash.each_pair         { |*v| hash_values         << v }
    @ordered_hash.each_pair { |*v| ordered_hash_values << v }

    assert_equal hash_values.sort, ordered_hash_values.sort
  end

  def test_order_after_yaml_serialization
    @deserialized_ordered_hash = YAML.load(YAML.dump(@ordered_hash))

    assert_equal @keys,   @deserialized_ordered_hash.keys
    assert_equal @values, @deserialized_ordered_hash.values
  end

  def test_order_after_yaml_serialization_with_nested_arrays
    @ordered_hash[:array] = %w(a b c)

    @deserialized_ordered_hash = YAML.load(YAML.dump(@ordered_hash))

    assert_equal @ordered_hash.keys,   @deserialized_ordered_hash.keys
    assert_equal @ordered_hash.values, @deserialized_ordered_hash.values
  end

  def test_psych_serialize
    @deserialized_ordered_hash = Psych.load(Psych.dump(@ordered_hash))

    values = @deserialized_ordered_hash.map { |_, value| value }
    assert_equal @values, values
  end

  def test_psych_serialize_tag
    yaml = Psych.dump(@ordered_hash)
    assert_match "!omap", yaml
  end

  def test_has_yaml_tag
    @ordered_hash[:array] = %w(a b c)
    assert_match "!omap", YAML.dump(@ordered_hash)
