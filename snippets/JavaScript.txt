'use strict';

const assert = require('assert');
const async = require('async');
const path = require('path');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const helpers = require('./helpers');
const Groups = require('../src/groups');
const User = require('../src/user');
const socketGroups = require('../src/socket.io/groups');
const meta = require('../src/meta');
const navigation = require('../src/navigation/admin');


describe('Groups', () => {
	let adminUid;
	let testUid;
	before(async () => {
		const navData = require('../install/data/navigation.json');
		await navigation.save(navData);

		await Groups.create({
			name: 'Test',
			description: 'Foobar!',
		});

		await Groups.create({
			name: 'PrivateNoJoin',
			description: 'Private group',
			private: 1,
			disableJoinRequests: 1,
		});

		await Groups.create({
			name: 'PrivateCanJoin',
			description: 'Private group',
			private: 1,
			disableJoinRequests: 0,
		});

		await Groups.create({
			name: 'PrivateNoLeave',
			description: 'Private group',
			private: 1,
			disableLeave: 1,
		});

		await Groups.create({
			name: 'Global Moderators',
			userTitle: 'Global Moderator',
			description: 'Forum wide moderators',
			hidden: 0,
			private: 1,
			disableJoinRequests: 1,
		});

		// Also create a hidden group
		await Groups.join('Hidden', 'Test');
		// create another group that starts with test for search/sort
		await Groups.create({	name: 'Test2', description: 'Foobar!' });

		testUid = await User.create({
			username: 'testuser',
			email: 'b@c.com',
		});

		adminUid = await User.create({
			username: 'admin',
			email: 'admin@admin.com',
			password: '123456',
		});
		await Groups.join('administrators', adminUid);
	});

	describe('.list()', () => {
		it('should list the groups present', (done) => {
			Groups.getGroupsFromSet('groups:visible:createtime', 0, -1, (err, groups) => {
				assert.ifError(err);
				assert.equal(groups.length, 5);
				done();
			});
		});
	});

	describe('.get()', () => {
		before((done) => {
			Groups.join('Test', testUid, done);
		});

		it('with no options, should show group information', (done) => {
			Groups.get('Test', {}, (err, groupObj) => {
				assert.ifError(err);
				assert.equal(typeof groupObj, 'object');
				assert(Array.isArray(groupObj.members));
				assert.strictEqual(groupObj.name, 'Test');
				assert.strictEqual(groupObj.description, 'Foobar!');
				assert.strictEqual(groupObj.memberCount, 1);
				assert.equal(typeof groupObj.members[0], 'object');

				done();
			});
		});

		it('should return null if group does not exist', (done) => {
			Groups.get('doesnotexist', {}, (err, groupObj) => {
				assert.ifError(err);
				assert.strictEqual(groupObj, null);
				done();
			});
		});
	});

	describe('.search()', () => {
		const socketGroups = require('../src/socket.io/groups');

		it('should return empty array if query is falsy', (done) => {
			Groups.search(null, {}, (err, groups) => {
				assert.ifError(err);
				assert.equal(0, groups.length);
				done();
			});
		});

		it('should return the groups when search query is empty', (done) => {
			socketGroups.search({ uid: adminUid }, { query: '' }, (err, groups) => {
				assert.ifError(err);
				assert.equal(5, groups.length);
				done();
			});
		});

		it('should return the "Test" group when searched for', (done) => {
			socketGroups.search({ uid: adminUid }, { query: 'test' }, (err, groups) => {
				assert.ifError(err);
				assert.equal(2, groups.length);
				assert.strictEqual('Test', groups[0].name);
				done();
			});
		});

		it('should return the "Test" group when searched for and sort by member count', (done) => {
			Groups.search('test', { filterHidden: true, sort: 'count' }, (err, groups) => {
				assert.ifError(err);
				assert.equal(2, groups.length);
				assert.strictEqual('Test', groups[0].name);
				done();
			});
		});

		it('should return the "Test" group when searched for and sort by creation time', (done) => {
			Groups.search('test', { filterHidden: true, sort: 'date' }, (err, groups) => {
				assert.ifError(err);
				assert.equal(2, groups.length);
				assert.strictEqual('Test', groups[1].name);
				done();
			});
		});

		it('should return all users if no query', (done) => {
			function createAndJoinGroup(username, email, callback) {
				async.waterfall([
					function (next) {
						User.create({ username: username, email: email }, next);
					},
					function (uid, next) {
						Groups.join('Test', uid, next);
					},
				], callback);
			}
			async.series([
				function (next) {
					createAndJoinGroup('newuser', 'newuser@b.com', next);
				},
				function (next) {
					createAndJoinGroup('bob', 'bob@b.com', next);
				},
			], (err) => {
				assert.ifError(err);

				socketGroups.searchMembers({ uid: adminUid }, { groupName: 'Test', query: '' }, (err, data) => {
					assert.ifError(err);
					assert.equal(data.users.length, 3);
					done();
				});
			});
		});

		it('should search group members', (done) => {
			socketGroups.searchMembers({ uid: adminUid }, { groupName: 'Test', query: 'test' }, (err, data) => {
				assert.ifError(err);
				assert.strictEqual('testuser', data.users[0].username);
				done();
			});
		});

		it('should not return hidden groups', async () => {
			await Groups.create({
				name: 'hiddenGroup',
				hidden: '1',
			});
			const result = await socketGroups.search({ uid: testUid }, { query: 'hiddenGroup' });
			assert.equal(result.length, 0);
		});
	});

	describe('.isMember()', () => {
		it('should return boolean true when a user is in a group', (done) => {
			Groups.isMember(1, 'Test', (err, isMember) => {
				assert.ifError(err);
				assert.strictEqual(isMember, true);
				done();
			});
		});

		it('should return boolean false when a user is not in a group', (done) => {
			Groups.isMember(2, 'Test', (err, isMember) => {
				assert.ifError(err);
				assert.strictEqual(isMember, false);
				done();
			});
		});

		it('should return true for uid 0 and guests group', (done) => {
			Groups.isMembers([1, 0], 'guests', (err, isMembers) => {
				assert.ifError(err);
				assert.deepStrictEqual(isMembers, [false, true]);
				done();
			});
		});

		it('should return true for uid 0 and guests group', (done) => {
			Groups.isMemberOfGroups(0, ['guests', 'registered-users'], (err, isMembers) => {
				assert.ifError(err);
				assert.deepStrictEqual(isMembers, [true, false]);
				done();
			});
		});
	});

	describe('.isMemberOfGroupList', () => {
		it('should report that a user is part of a groupList, if they are', (done) => {
			Groups.isMemberOfGroupList(1, 'Hidden', (err, isMember) => {
				assert.ifError(err);
				assert.strictEqual(isMember, true);
				done();
			});
		});

		it('should report that a user is not part of a groupList, if they are not', (done) => {
			Groups.isMemberOfGroupList(2, 'Hidden', (err, isMember) => {
				assert.ifError(err);
				assert.strictEqual(isMember, false);
				done();
			});
		});
	});

	describe('.exists()', () => {
		it('should verify that the test group exists', (done) => {
			Groups.exists('Test', (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(exists, true);
				done();
			});
		});

		it('should verify that a fake group does not exist', (done) => {
			Groups.exists('Derp', (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(exists, false);
				done();
			});
		});

		it('should check if group exists using an array', (done) => {
			Groups.exists(['Test', 'Derp'], (err, groupsExists) => {
				assert.ifError(err);
				assert.strictEqual(groupsExists[0], true);
				assert.strictEqual(groupsExists[1], false);
				done();
			});
		});
	});

	describe('.create()', () => {
		it('should create another group', (done) => {
			Groups.create({
				name: 'foo',
				description: 'bar',
			}, (err) => {
				assert.ifError(err);
				Groups.get('foo', {}, done);
			});
		});

		it('should create a hidden group if hidden is 1', (done) => {
			Groups.create({
				name: 'hidden group',
				hidden: '1',
			}, (err) => {
				assert.ifError(err);
				db.isSortedSetMember('groups:visible:memberCount', 'visible group', (err, isMember) => {
					assert.ifError(err);
					assert(!isMember);
					done();
				});
			});
		});

		it('should create a visible group if hidden is 0', (done) => {
			Groups.create({
				name: 'visible group',
				hidden: '0',
			}, (err) => {
				assert.ifError(err);
				db.isSortedSetMember('groups:visible:memberCount', 'visible group', (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});

		it('should create a visible group if hidden is not passed in', (done) => {
			Groups.create({
				name: 'visible group 2',
			}, (err) => {
				assert.ifError(err);
				db.isSortedSetMember('groups:visible:memberCount', 'visible group 2', (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});

		it('should fail to create group with duplicate group name', (done) => {
			Groups.create({ name: 'foo' }, (err) => {
				assert(err);
				assert.equal(err.message, '[[error:group-already-exists]]');
				done();
			});
		});

		it('should fail to create group if slug is empty', (done) => {
			Groups.create({ name: '>>>>' }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail if group name is invalid', (done) => {
			Groups.create({ name: 'not/valid' }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail if group name is invalid', (done) => {
			Groups.create({ name: ['array/'] }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail if group name is invalid', (done) => {
			socketGroups.create({ uid: adminUid }, { name: ['test', 'administrators'] }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should not create a system group', (done) => {
			socketGroups.create({ uid: adminUid }, { name: 'mysystemgroup', system: true }, (err) => {
				assert.ifError(err);
				Groups.getGroupData('mysystemgroup', (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.system, 0);
					done();
				});
			});
		});

		it('should fail if group name is invalid', (done) => {
			Groups.create({ name: 'not:valid' }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should return falsy for userTitleEnabled', (done) => {
			Groups.create({ name: 'userTitleEnabledGroup' }, (err) => {
				assert.ifError(err);
				Groups.setGroupField('userTitleEnabledGroup', 'userTitleEnabled', 0, (err) => {
					assert.ifError(err);
					Groups.getGroupData('userTitleEnabledGroup', (err, data) => {
						assert.ifError(err);
						assert.strictEqual(data.userTitleEnabled, 0);
						done();
					});
				});
			});
		});
	});

	describe('.hide()', () => {
		it('should mark the group as hidden', (done) => {
			Groups.hide('foo', (err) => {
				assert.ifError(err);

				Groups.get('foo', {}, (err, groupObj) => {
					assert.ifError(err);
					assert.strictEqual(1, groupObj.hidden);
					done();
				});
			});
		});
	});

	describe('.update()', () => {
		before((done) => {
			Groups.create({
				name: 'updateTestGroup',
				description: 'bar',
				system: 0,
				hidden: 0,
			}, done);
		});

		it('should change an aspect of a group', (done) => {
			Groups.update('updateTestGroup', {
				description: 'baz',
			}, (err) => {
				assert.ifError(err);

				Groups.get('updateTestGroup', {}, (err, groupObj) => {
					assert.ifError(err);
					assert.strictEqual('baz', groupObj.description);
					done();
				});
			});
		});

		it('should rename a group and not break navigation routes', async () => {
			await Groups.update('updateTestGroup', {
				name: 'updateTestGroup?',
			});

			const groupObj = await Groups.get('updateTestGroup?', {});
			assert.strictEqual('updateTestGroup?', groupObj.name);
			assert.strictEqual('updatetestgroup', groupObj.slug);

			const navItems = await navigation.get();
			assert.strictEqual(navItems[0].route, '&#x2F;categories');
		});

		it('should fail if system groups is being renamed', (done) => {
			Groups.update('administrators', {
				name: 'administrators_fail',
			}, (err) => {
				assert.equal(err.message, '[[error:not-allowed-to-rename-system-group]]');
				done();
			});
		});

		it('should fail to rename if group name is invalid', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: ['updateTestGroup?'], values: {} }, (err) => {
				assert.strictEqual(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to rename if group name is too short', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: 'updateTestGroup?', values: { name: '' } }, (err) => {
				assert.strictEqual(err.message, '[[error:group-name-too-short]]');
				done();
			});
		});

		it('should fail to rename if group name is invalid', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: 'updateTestGroup?', values: { name: ['invalid'] } }, (err) => {
				assert.strictEqual(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to rename if group name is invalid', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: 'updateTestGroup?', values: { name: 'cid:0:privileges:ban' } }, (err) => {
				assert.strictEqual(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to rename if group name is too long', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: 'updateTestGroup?', values: { name: 'verylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstring' } }, (err) => {
				assert.strictEqual(err.message, '[[error:group-name-too-long]]');
				done();
			});
		});

		it('should fail to rename if group name is invalid', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: 'updateTestGroup?', values: { name: 'test:test' } }, (err) => {
				assert.strictEqual(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to rename if group name is invalid', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: 'updateTestGroup?', values: { name: 'another/test' } }, (err) => {
				assert.strictEqual(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to rename if group name is invalid', (done) => {
			socketGroups.update({ uid: adminUid }, { groupName: 'updateTestGroup?', values: { name: '---' } }, (err) => {
				assert.strictEqual(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to rename group to an existing group', (done) => {
			Groups.create({
				name: 'group2',
				system: 0,
				hidden: 0,
			}, (err) => {
				assert.ifError(err);
				Groups.update('group2', {
					name: 'updateTestGroup?',
				}, (err) => {
					assert.equal(err.message, '[[error:group-already-exists]]');
					done();
				});
			});
		});
	});

	describe('.destroy()', () => {
		before((done) => {
			Groups.join('foobar?', 1, done);
		});

		it('should destroy a group', (done) => {
			Groups.destroy('foobar?', (err) => {
				assert.ifError(err);

				Groups.get('foobar?', {}, (err, groupObj) => {
					assert.ifError(err);
					assert.strictEqual(groupObj, null);
					done();
				});
			});
		});

		it('should also remove the members set', (done) => {
			db.exists('group:foo:members', (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(false, exists);
				done();
			});
		});

		it('should remove group from privilege groups', (done) => {
			const privileges = require('../src/privileges');
			const cid = 1;
			const groupName = '1';
			const uid = 1;
			async.waterfall([
				function (next) {
					Groups.create({ name: groupName }, next);
				},
				function (groupData, next) {
					privileges.categories.give(['groups:topics:create'], cid, groupName, next);
				},
				function (next) {
					Groups.isMember(groupName, 'cid:1:privileges:groups:topics:create', next);
				},
				function (isMember, next) {
					assert(isMember);
					Groups.destroy(groupName, next);
				},
				function (next) {
					Groups.isMember(groupName, 'cid:1:privileges:groups:topics:create', next);
				},
				function (isMember, next) {
					assert(!isMember);
					Groups.isMember(uid, 'registered-users', next);
				},
				function (isMember, next) {
					assert(isMember);
					next();
				},
			], done);
		});
	});

	describe('.join()', () => {
		before((done) => {
			Groups.leave('Test', testUid, done);
		});

		it('should add a user to a group', (done) => {
			Groups.join('Test', testUid, (err) => {
				assert.ifError(err);

				Groups.isMember(testUid, 'Test', (err, isMember) => {
					assert.ifError(err);
					assert.strictEqual(true, isMember);

					done();
				});
			});
		});

		it('should fail to add user to admin group', async () => {
			const oldValue = meta.config.allowPrivateGroups;
			try {
				meta.config.allowPrivateGroups = false;
				const newUid = await User.create({ username: 'newadmin' });
				await socketGroups.join({ uid: newUid }, { groupName: ['test', 'administrators'], uid: newUid }, 1);
				const isMember = await Groups.isMember(newUid, 'administrators');
				assert(!isMember);
			} catch (err) {
				assert.strictEqual(err.message, '[[error:no-group]]');
			}
			meta.config.allowPrivateGroups = oldValue;
		});

		it('should fail to add user to group if group name is invalid', (done) => {
			Groups.join(0, 1, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				Groups.join(null, 1, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					Groups.join(undefined, 1, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should fail to add user to group if uid is invalid', (done) => {
			Groups.join('Test', 0, (err) => {
				assert.equal(err.message, '[[error:invalid-uid]]');
				Groups.join('Test', null, (err) => {
					assert.equal(err.message, '[[error:invalid-uid]]');
					Groups.join('Test', undefined, (err) => {
						assert.equal(err.message, '[[error:invalid-uid]]');
						done();
					});
				});
			});
		});

		it('should add user to Global Moderators group', async () => {
			const uid = await User.create({ username: 'glomod' });
			await socketGroups.join({ uid: adminUid }, { groupName: 'Global Moderators', uid: uid });
			const isGlobalMod = await User.isGlobalModerator(uid);
			assert.strictEqual(isGlobalMod, true);
		});

		it('should add user to multiple groups', (done) => {
			const groupNames = ['test-hidden1', 'Test', 'test-hidden2', 'empty group'];
			Groups.create({ name: 'empty group' }, (err) => {
				assert.ifError(err);
				Groups.join(groupNames, testUid, (err) => {
					assert.ifError(err);
					Groups.isMemberOfGroups(testUid, groupNames, (err, isMembers) => {
						assert.ifError(err);
						assert(isMembers.every(Boolean));
						db.sortedSetScores('groups:visible:memberCount', groupNames, (err, memberCounts) => {
							assert.ifError(err);
							// hidden groups are not in "groups:visible:memberCount" so they are null
							assert.deepEqual(memberCounts, [null, 3, null, 1]);
							done();
						});
					});
				});
			});
		});

		it('should set group title when user joins the group', (done) => {
			const groupName = 'this will be title';
			User.create({ username: 'needstitle' }, (err, uid) => {
				assert.ifError(err);
				Groups.create({ name: groupName }, (err) => {
					assert.ifError(err);
					Groups.join([groupName], uid, (err) => {
						assert.ifError(err);
						User.getUserData(uid, (err, data) => {
							assert.ifError(err);
							assert.equal(data.groupTitle, `["${groupName}"]`);
							assert.deepEqual(data.groupTitleArray, [groupName]);
							done();
						});
					});
				});
			});
		});

		it('should fail to add user to system group', async () => {
			const uid = await User.create({ username: 'eviluser' });
			const oldValue = meta.config.allowPrivateGroups;
			meta.config.allowPrivateGroups = 0;
			async function test(groupName) {
				let err;
				try {
					await socketGroups.join({ uid: uid }, { groupName: groupName });
					const isMember = await Groups.isMember(uid, groupName);
					assert.strictEqual(isMember, false);
				} catch (_err) {
					err = _err;
				}
				assert.strictEqual(err.message, '[[error:not-allowed]]');
			}
			const groups = ['Global Moderators', 'verified-users', 'unverified-users'];
			for (const g of groups) {
				// eslint-disable-next-line no-await-in-loop
				await test(g);
			}
			meta.config.allowPrivateGroups = oldValue;
		});
	});

	describe('.leave()', () => {
		it('should remove a user from a group', (done) => {
			Groups.leave('Test', testUid, (err) => {
				assert.ifError(err);

				Groups.isMember(testUid, 'Test', (err, isMember) => {
					assert.ifError(err);
					assert.strictEqual(false, isMember);

					done();
				});
			});
		});
	});

	describe('.leaveAllGroups()', () => {
		it('should remove a user from all groups', (done) => {
			Groups.leaveAllGroups(testUid, (err) => {
				assert.ifError(err);

				const	groups = ['Test', 'Hidden'];
				async.every(groups, (group, next) => {
					Groups.isMember(testUid, group, (err, isMember) => {
						next(err, !isMember);
					});
				}, (err, result) => {
					assert.ifError(err);
					assert(result);

					done();
				});
			});
		});
	});

	describe('.show()', () => {
		it('should make a group visible', (done) => {
			Groups.show('Test', function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.isSortedSetMember('groups:visible:createtime', 'Test', (err, isMember) => {
					assert.ifError(err);
					assert.strictEqual(isMember, true);
					done();
				});
			});
		});
	});

	describe('.hide()', () => {
		it('should make a group hidden', (done) => {
			Groups.hide('Test', function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.isSortedSetMember('groups:visible:createtime', 'Test', (err, isMember) => {
					assert.ifError(err);
					assert.strictEqual(isMember, false);
					done();
				});
			});
		});
	});

	describe('socket methods', () => {
		it('should error if data is null', (done) => {
			socketGroups.before({ uid: 0 }, 'groups.join', null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should not error if data is valid', (done) => {
			socketGroups.before({ uid: 0 }, 'groups.join', {}, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should return error if not logged in', (done) => {
			socketGroups.join({ uid: 0 }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-uid]]');
				done();
			});
		});

		it('should return error if group name is special', (done) => {
			socketGroups.join({ uid: testUid }, { groupName: 'administrators' }, (err) => {
				assert.equal(err.message, '[[error:not-allowed]]');
				done();
			});
		});

		it('should error if group does not exist', (done) => {
			socketGroups.join({ uid: adminUid }, { groupName: 'doesnotexist' }, (err) => {
				assert.equal(err.message, '[[error:no-group]]');
				done();
			});
		});

		it('should join test group', (done) => {
			meta.config.allowPrivateGroups = 0;
			socketGroups.join({ uid: adminUid }, { groupName: 'Test' }, (err) => {
				assert.ifError(err);
				Groups.isMember(adminUid, 'Test', (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});

		it('should error if not logged in', (done) => {
			socketGroups.leave({ uid: 0 }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-uid]]');
				done();
			});
		});

		it('should return error if group name is special', (done) => {
			socketGroups.leave({ uid: adminUid }, { groupName: 'administrators' }, (err) => {
				assert.equal(err.message, '[[error:cant-remove-self-as-admin]]');
				done();
			});
		});

		it('should leave test group', (done) => {
			socketGroups.leave({ uid: adminUid }, { groupName: 'Test' }, (err) => {
				assert.ifError(err);
				Groups.isMember('Test', adminUid, (err, isMember) => {
					assert.ifError(err);
					assert(!isMember);
					done();
				});
			});
		});

		it('should fail to join if group is private and join requests are disabled', (done) => {
			meta.config.allowPrivateGroups = 1;
			socketGroups.join({ uid: testUid }, { groupName: 'PrivateNoJoin' }, (err) => {
				assert.equal(err.message, '[[error:group-join-disabled]]');
				done();
			});
		});

		it('should fail to leave if group is private and leave is disabled', async () => {
			await socketGroups.join({ uid: testUid }, { groupName: 'PrivateNoLeave' });

			try {
				await socketGroups.leave({ uid: testUid }, { groupName: 'PrivateNoLeave' });
			} catch (err) {
				assert.equal(err.message, '[[error:group-leave-disabled]]');
			}
		});

		it('should join if user is admin', (done) => {
			socketGroups.join({ uid: adminUid }, { groupName: 'PrivateCanJoin' }, (err) => {
				assert.ifError(err);
				Groups.isMember(adminUid, 'PrivateCanJoin', (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});

		it('should request membership for regular user', (done) => {
			socketGroups.join({ uid: testUid }, { groupName: 'PrivateCanJoin' }, (err) => {
				assert.ifError(err);
				Groups.isPending(testUid, 'PrivateCanJoin', (err, isPending) => {
					assert.ifError(err);
					assert(isPending);
					done();
				});
			});
		});

		it('should reject membership of user', (done) => {
			socketGroups.reject({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: testUid }, (err) => {
				assert.ifError(err);
				Groups.isInvited(testUid, 'PrivateCanJoin', (err, invited) => {
					assert.ifError(err);
					assert.equal(invited, false);
					done();
				});
			});
		});

		it('should error if not owner or admin', (done) => {
			socketGroups.accept({ uid: 0 }, { groupName: 'PrivateCanJoin', toUid: testUid }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should accept membership of user', (done) => {
			socketGroups.join({ uid: testUid }, { groupName: 'PrivateCanJoin' }, (err) => {
				assert.ifError(err);
				socketGroups.accept({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: testUid }, (err) => {
					assert.ifError(err);
					Groups.isMember(testUid, 'PrivateCanJoin', (err, isMember) => {
						assert.ifError(err);
						assert(isMember);
						done();
					});
				});
			});
		});

		it('should reject/accept all memberships requests', (done) => {
			function requestMembership(uids, callback) {
				async.series([
					function (next) {
						socketGroups.join({ uid: uids.uid1 }, { groupName: 'PrivateCanJoin' }, next);
					},
					function (next) {
						socketGroups.join({ uid: uids.uid2 }, { groupName: 'PrivateCanJoin' }, next);
					},
				], (err) => {
					callback(err);
				});
			}
			let uids;
			async.waterfall([
				function (next) {
					async.parallel({
						uid1: function (next) {
							User.create({ username: 'groupuser1' }, next);
						},
						uid2: function (next) {
							User.create({ username: 'groupuser2' }, next);
						},
					}, next);
				},
				function (results, next) {
					uids = results;
					requestMembership(results, next);
				},
				function (next) {
					socketGroups.rejectAll({ uid: adminUid }, { groupName: 'PrivateCanJoin' }, next);
				},
				function (next) {
					Groups.getPending('PrivateCanJoin', next);
				},
				function (pending, next) {
					assert.equal(pending.length, 0);
					requestMembership(uids, next);
				},
				function (next) {
					socketGroups.acceptAll({ uid: adminUid }, { groupName: 'PrivateCanJoin' }, next);
				},
				function (next) {
					Groups.isMembers([uids.uid1, uids.uid2], 'PrivateCanJoin', next);
				},
				function (isMembers, next) {
					assert(isMembers[0]);
					assert(isMembers[1]);
					next();
				},
			], (err) => {
				done(err);
			});
		});

		it('should issue invite to user', (done) => {
			User.create({ username: 'invite1' }, (err, uid) => {
				assert.ifError(err);
				socketGroups.issueInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: uid }, (err) => {
					assert.ifError(err);
					Groups.isInvited(uid, 'PrivateCanJoin', (err, isInvited) => {
						assert.ifError(err);
						assert(isInvited);
						done();
					});
				});
			});
		});

		it('should fail with invalid data', (done) => {
			socketGroups.issueMassInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin', usernames: null }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should issue mass invite to users', (done) => {
			User.create({ username: 'invite2' }, (err, uid) => {
				assert.ifError(err);
				socketGroups.issueMassInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin', usernames: 'invite1, invite2' }, (err) => {
					assert.ifError(err);
					Groups.isInvited([adminUid, uid], 'PrivateCanJoin', (err, isInvited) => {
						assert.ifError(err);
						assert.deepStrictEqual(isInvited, [false, true]);
						done();
					});
				});
			});
		});

		it('should rescind invite', (done) => {
			User.create({ username: 'invite3' }, (err, uid) => {
				assert.ifError(err);
				socketGroups.issueInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: uid }, (err) => {
					assert.ifError(err);
					socketGroups.rescindInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: uid }, (err) => {
						assert.ifError(err);
						Groups.isInvited(uid, 'PrivateCanJoin', (err, isInvited) => {
							assert.ifError(err);
							assert(!isInvited);
							done();
						});
					});
				});
			});
		});

		it('should error if user is not invited', (done) => {
			socketGroups.acceptInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin' }, (err) => {
				assert.equal(err.message, '[[error:not-invited]]');
				done();
			});
		});

		it('should accept invite', (done) => {
			User.create({ username: 'invite4' }, (err, uid) => {
				assert.ifError(err);
				socketGroups.issueInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: uid }, (err) => {
					assert.ifError(err);
					socketGroups.acceptInvite({ uid: uid }, { groupName: 'PrivateCanJoin' }, (err) => {
						assert.ifError(err);
						Groups.isMember(uid, 'PrivateCanJoin', (err, isMember) => {
							assert.ifError(err);
							assert(isMember);
							done();
						});
					});
				});
			});
		});

		it('should reject invite', (done) => {
			User.create({ username: 'invite5' }, (err, uid) => {
				assert.ifError(err);
				socketGroups.issueInvite({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: uid }, (err) => {
					assert.ifError(err);
					socketGroups.rejectInvite({ uid: uid }, { groupName: 'PrivateCanJoin' }, (err) => {
						assert.ifError(err);
						Groups.isInvited(uid, 'PrivateCanJoin', (err, isInvited) => {
							assert.ifError(err);
							assert(!isInvited);
							done();
						});
					});
				});
			});
		});

		it('should grant ownership to user', (done) => {
			socketGroups.grant({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: testUid }, (err) => {
				assert.ifError(err);
				Groups.ownership.isOwner(testUid, 'PrivateCanJoin', (err, isOwner) => {
					assert.ifError(err);
					assert(isOwner);
					done();
				});
			});
		});

		it('should rescind ownership from user', (done) => {
			socketGroups.rescind({ uid: adminUid }, { groupName: 'PrivateCanJoin', toUid: testUid }, (err) => {
				assert.ifError(err);
				Groups.ownership.isOwner(testUid, 'PrivateCanJoin', (err, isOwner) => {
					assert.ifError(err);
					assert(!isOwner);
					done();
				});
			});
		});

		it('should fail to kick user with invalid data', (done) => {
			socketGroups.kick({ uid: adminUid }, { groupName: 'PrivateCanJoin', uid: adminUid }, (err) => {
				assert.equal(err.message, '[[error:cant-kick-self]]');
				done();
			});
		});

		it('should kick user from group', (done) => {
			socketGroups.kick({ uid: adminUid }, { groupName: 'PrivateCanJoin', uid: testUid }, (err) => {
				assert.ifError(err);
				Groups.isMember(testUid, 'PrivateCanJoin', (err, isMember) => {
					assert.ifError(err);
					assert(!isMember);
					done();
				});
			});
		});

		it('should fail to create group with invalid data', (done) => {
			socketGroups.create({ uid: 0 }, {}, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail to create group if group creation is disabled', (done) => {
			socketGroups.create({ uid: testUid }, { name: 'avalidname' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail to create group if name is privilege group', (done) => {
			socketGroups.create({ uid: 1 }, { name: 'cid:1:privileges:groups:find' }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should create/update group', (done) => {
			socketGroups.create({ uid: adminUid }, { name: 'createupdategroup' }, (err, groupData) => {
				assert.ifError(err);
				assert(groupData);
				const data = {
					groupName: 'createupdategroup',
					values: {
						name: 'renamedupdategroup',
						description: 'cat group',
						userTitle: 'cats',
						userTitleEnabled: 1,
						disableJoinRequests: 1,
						hidden: 1,
						private: 0,
					},
				};
				socketGroups.update({ uid: adminUid }, data, (err) => {
					assert.ifError(err);
					Groups.get('renamedupdategroup', {}, (err, groupData) => {
						assert.ifError(err);
						assert.equal(groupData.name, 'renamedupdategroup');
						assert.equal(groupData.userTitle, 'cats');
						assert.equal(groupData.description, 'cat group');
						assert.equal(groupData.hidden, true);
						assert.equal(groupData.disableJoinRequests, true);
						assert.equal(groupData.private, false);
						done();
					});
				});
			});
		});

		it('should fail to create a group with name guests', (done) => {
			socketGroups.create({ uid: adminUid }, { name: 'guests' }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to rename guests group', (done) => {
			const data = {
				groupName: 'guests',
				values: {
					name: 'guests2',
				},
			};
			socketGroups.update({ uid: adminUid }, data, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should delete group', (done) => {
			socketGroups.delete({ uid: adminUid }, { groupName: 'renamedupdategroup' }, (err) => {
				assert.ifError(err);
				Groups.exists('renamedupdategroup', (err, exists) => {
					assert.ifError(err);
					assert(!exists);
					done();
				});
			});
		});

		it('should fail to delete group if name is special', (done) => {
			socketGroups.delete({ uid: adminUid }, { groupName: 'administrators' }, (err) => {
				assert.equal(err.message, '[[error:not-allowed]]');
				done();
			});
		});

		it('should fail to delete group if name is special', (done) => {
			socketGroups.delete({ uid: adminUid }, { groupName: 'registered-users' }, (err) => {
				assert.equal(err.message, '[[error:not-allowed]]');
				done();
			});
		});

		it('should fail to delete group if name is special', (done) => {
			socketGroups.delete({ uid: adminUid }, { groupName: 'Global Moderators' }, (err) => {
				assert.equal(err.message, '[[error:not-allowed]]');
				done();
			});
		});

		it('should fail to delete group if name is special', (done) => {
			socketGroups.delete({ uid: adminUid }, { groupName: 'guests' }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should fail to load more groups with invalid data', (done) => {
			socketGroups.loadMore({ uid: adminUid }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should load more groups', (done) => {
			socketGroups.loadMore({ uid: adminUid }, { after: 0, sort: 'count' }, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data.groups));
				done();
			});
		});

		it('should fail to load more members with invalid data', (done) => {
			socketGroups.loadMoreMembers({ uid: adminUid }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should load more members', (done) => {
			socketGroups.loadMoreMembers({ uid: adminUid }, { after: 0, groupName: 'PrivateCanJoin' }, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data.users));
				done();
			});
		});
	});

	describe('admin socket methods', () => {
		const socketGroups = require('../src/socket.io/admin/groups');

		it('should fail to create group with invalid data', (done) => {
			socketGroups.create({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail to create group if group name is privilege group', (done) => {
			socketGroups.create({ uid: adminUid }, { name: 'cid:1:privileges:read' }, (err) => {
				assert.equal(err.message, '[[error:invalid-group-name]]');
				done();
			});
		});

		it('should create a group', (done) => {
			socketGroups.create({ uid: adminUid }, { name: 'newgroup', description: 'group created by admin' }, (err, groupData) => {
				assert.ifError(err);
				assert.equal(groupData.name, 'newgroup');
				assert.equal(groupData.description, 'group created by admin');
				assert.equal(groupData.private, 1);
				assert.equal(groupData.hidden, 0);
				assert.equal(groupData.memberCount, 1);
				done();
			});
		});

		it('should fail to join with invalid data', (done) => {
			socketGroups.join({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should add user to group', (done) => {
			socketGroups.join({ uid: adminUid }, { uid: testUid, groupName: 'newgroup' }, (err) => {
				assert.ifError(err);
				Groups.isMember(testUid, 'newgroup', (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});

		it('should not error if user is already member', (done) => {
			socketGroups.join({ uid: adminUid }, { uid: testUid, groupName: 'newgroup' }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('it should fail with invalid data', (done) => {
			socketGroups.leave({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('it should fail if admin tries to remove self', (done) => {
			socketGroups.leave({ uid: adminUid }, { uid: adminUid, groupName: 'administrators' }, (err) => {
				assert.equal(err.message, '[[error:cant-remove-self-as-admin]]');
				done();
			});
		});

		it('should not error if user is not member', (done) => {
			socketGroups.leave({ uid: adminUid }, { uid: 3, groupName: 'newgroup' }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should fail if trying to remove someone else from group', (done) => {
			socketGroups.leave({ uid: testUid }, { uid: adminUid, groupName: 'newgroup' }, (err) => {
				assert.strictEqual(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should remove user from group', (done) => {
			socketGroups.leave({ uid: adminUid }, { uid: testUid, groupName: 'newgroup' }, (err) => {
				assert.ifError(err);
				Groups.isMember(testUid, 'newgroup', (err, isMember) => {
					assert.ifError(err);
					assert(!isMember);
					done();
				});
			});
		});

		it('should fail with invalid data', (done) => {
			socketGroups.update({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should update group', (done) => {
			const data = {
				groupName: 'newgroup',
				values: {
					name: 'renamedgroup',
					description: 'cat group',
					userTitle: 'cats',
					userTitleEnabled: 1,
					disableJoinRequests: 1,
					hidden: 1,
					private: 0,
				},
			};
			socketGroups.update({ uid: adminUid }, data, (err) => {
				assert.ifError(err);
				Groups.get('renamedgroup', {}, (err, groupData) => {
					assert.ifError(err);
					assert.equal(groupData.name, 'renamedgroup');
					assert.equal(groupData.userTitle, 'cats');
					assert.equal(groupData.description, 'cat group');
					assert.equal(groupData.hidden, true);
					assert.equal(groupData.disableJoinRequests, true);
					assert.equal(groupData.private, false);
					done();
				});
			});
		});
	});

	describe('groups cover', () => {
		const socketGroups = require('../src/socket.io/groups');
		let regularUid;
		const logoPath = path.join(__dirname, '../test/files/test.png');
		const imagePath = path.join(__dirname, '../test/files/groupcover.png');
		before((done) => {
			User.create({ username: 'regularuser', password: '123456' }, (err, uid) => {
				assert.ifError(err);
				regularUid = uid;
				async.series([
					function (next) {
						Groups.join('Test', adminUid, next);
					},
					function (next) {
						Groups.join('Test', regularUid, next);
					},
					function (next) {
						helpers.copyFile(logoPath, imagePath, next);
					},
				], done);
			});
		});

		it('should fail if user is not logged in or not owner', (done) => {
			socketGroups.cover.update({ uid: 0 }, { imageData: 'asd' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				socketGroups.cover.update({ uid: regularUid }, { groupName: 'Test', imageData: 'asd' }, (err) => {
					assert.equal(err.message, '[[error:no-privileges]]');
					done();
				});
			});
		});

		it('should upload group cover image from file', (done) => {
			const data = {
				groupName: 'Test',
				file: {
					path: imagePath,
					type: 'image/png',
				},
			};
			Groups.updateCover({ uid: adminUid }, data, (err, data) => {
				assert.ifError(err);
				Groups.getGroupFields('Test', ['cover:url'], (err, groupData) => {
					assert.ifError(err);
					assert.equal(nconf.get('relative_path') + data.url, groupData['cover:url']);
					if (nconf.get('relative_path')) {
						assert(!data.url.startsWith(nconf.get('relative_path')));
						assert(groupData['cover:url'].startsWith(nconf.get('relative_path')), groupData['cover:url']);
					}
					done();
				});
			});
		});


		it('should upload group cover image from data', (done) => {
			const data = {
				groupName: 'Test',
				imageData: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAgCAYAAAABtRhCAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAACcJJREFUeNqMl9tvnNV6xn/f+s5z8DCeg88Zj+NYdhJH4KShFoJAIkzVphLVJnsDaiV6gUKaC2qQUFVATbnoValAakuQYKMqBKUUJCgI9XBBSmOROMqGoCStHbA9sWM7nrFn/I3n9B17kcwoabfarj9gvet53+d9nmdJAwMDAAgh8DyPtbU1XNfFMAwkScK2bTzPw/M8dF1/SAhxKAiCxxVF2aeqqqTr+q+Af+7o6Ch0d3f/69TU1KwkSRiGwbFjx3jmmWd47rnn+OGHH1BVFYX/5QRBkPQ87xeSJP22YRi/oapqStM0PM/D931kWSYIgnHf98cXFxepVqtomjZt2/Zf2bb990EQ4Pv+PXfeU1CSpGYhfN9/TgjxQTQaJQgCwuEwQRBQKpUwDAPTNPF9n0ajAYDv+8zPzzM+Pr6/Wq2eqdVqfxOJRA6Zpnn57hrivyEC0IQQZ4Mg+MAwDCKRCJIkUa/XEUIQi8XQNI1QKIQkSQghUBQFIQSmaTI7OwtAuVxOTE9Pfzc9Pf27lUqlBUgulUoUi0VKpRKqqg4EQfAfiqLsDIfDAC0E4XCYaDSKEALXdalUKvfM1/d9hBBYlkUul2N4eJi3335bcl33mW+++aaUz+cvSJKE8uKLL6JpGo7j8Omnn/7d+vp6sr+/HyEEjuMgyzKu6yJJEsViEVVV8TyPjY2NVisV5fZkTNMkkUhw8+ZN6vU6Kysr7Nmzh9OnT7/12GOPDS8sLByT7rQR4A9XV1d/+cILLzA9PU0kEmF4eBhFUTh//jyWZaHrOkII0uk0jUaDWq1GJpOhWCyysrLC1tYWnuehqir79+9H13W6urp48803+f7773n++ef/4G7S/H4ikUCSJNbX11trcuvWLcrlMrIs4zgODzzwABMTE/i+T7lcpq2tjUqlwubmJrZts7y8jBCCkZERGo0G2WyWkydPkkql6Onp+eMmwihwc3JyMvrWW2+RTCYBcF0XWZbRdZ3l5WX27NnD008/TSwWQ1VVyuVy63GhUIhEIkEqlcJxHCzLIhaLMTQ0xJkzZ7Btm3379lmS53kIIczZ2dnFsbGxRK1Wo729HQDP8zAMg5WVFXp7e5mcnKSzs5N8Po/rutTrdVzXbQmHrutEo1FM00RVVXp7e0kkEgRBwMWLF9F1vaxUq1UikUjtlVdeuV6pVBJ9fX3Ytn2bwrLMysoKXV1dTE5OkslksCwLTdMwDANVVdnY2CAIApLJJJFIBMdxiMfj7Nq1C1VViUajLQCvvvrqkhKJRJiZmfmdb7/99jeTySSyLLfWodFoEAqFOH78OLt37yaXy2GaJoqisLy8zNTUFFevXiUIAtrb29m5cyePPPJIa+cymQz1eh2A0dFRCoXCsgIwNTW1J5/P093dTbFYRJZlJEmiWq1y4MABxsbGqNVqhEIh6vU6QRBQLpcxDIPh4WE8z2NxcZFTp05x7tw5Xn755ZY6dXZ2tliZzWa/EwD1ev3RsbExxsfHSafTVCoVGo0Gqqqya9cuIpEIQgh832dtbY3FxUUA+vr62LZtG2NjYxw5coTDhw+ztLTEyZMnuXr1KoVC4R4d3bt375R84sQJEY/H/2Jubq7N9326urqwbZt6vY5pmhw5coS+vr4W9YvFIrdu3WJqagohBFeuXOHcuXOtue7evRtN01rtfO+991haWmJkZGQrkUi8JIC9iqL0BkFAIpFACMETTzxBV1cXiUSC7u5uHMfB8zyCIMA0TeLxONlsFlmW8X2fwcFBHMdhfn6eer1Oe3s7Dz30EBMTE1y6dImjR49y6tSppR07dqwrjuM8+OWXXzI0NMTly5e5du0aQ0NDTExMkMvlCIKAIAhaIh2LxQiHw0QiEfL5POl0mlqtRq1Wo6OjA8uykGWZdDrN0tISvb29vPPOOzz++OPk83lELpf7rXfffRfDMOjo6MBxHEqlEocOHWLHjh00Gg0kSULTNIS4bS6qqhKPxxkaGmJ4eJjR0VH279/PwMAA27dvJ5vN4vs+X331FR9//DGzs7OEQiE++eQTlPb29keuX7/OtWvXOH78ONVqlZs3b9LW1kYmk8F13dZeCiGQJAnXdRFCYBgGsiwjhMC2bQqFAkEQoOs6P/74Iw8++CCDg4Pous6xY8f47LPPkIIguDo2Nrbzxo0bfPjhh9i2zczMTHNvcF2XpsZalkWj0cB1Xe4o1O3YoCisra3x008/EY/H6erqAuDAgQNEIhGCIODQoUP/ubCwMCKAjx599FHW19f56KOP6OjooFgsks/niUajKIqCbds4joMQAiFESxxs226xd2Zmhng8Tl9fH67r0mg0sG2bbDZLpVIhl8vd5gHwtysrKy8Dcdd1mZubo6enh1gsRrVabZlrk6VND/R9n3q9TqVSQdd1QqEQi4uLnD9/nlKpxODgIHv37gXAcRyCICiFQiHEzp07i1988cUfKYpCIpHANE22b9/eUhNFUVotDIKghc7zPCzLolKpsLW1RVtbG0EQ4DgOmqbR09NDM1qUSiWAPwdQ7ujjmf7+/kQymfxrSZJQVZWtra2WG+i63iKH53m4rku1WqVcLmNZFu3t7S2x7+/vJ51O89prr7VYfenSpcPAP1UqFeSHH36YeDxOKpW6eP/9988Bv9d09nw+T7VapVKptJjZnE2tVmNtbY1cLke5XGZra4vNzU16enp49tlnGRgYaD7iTxqNxgexWIzDhw+jNEPQHV87NT8/f+PChQtnR0ZGqFarrUVuOsDds2u2b2FhgVQqRSQSYWFhgStXrtDf308ymcwBf3nw4EEOHjx4O5c2lURVVRzHYXp6+t8uX7785IULFz7LZDLous59991HOBy+h31N9xgdHSWTyVCtVhkaGmLfvn1MT08zPz/PzMzM6c8//9xr+uE9QViWZer1OhsbGxiG8fns7OzPc7ncx729vXR3d1OpVNi2bRuhUAhZljEMA9/3sW0bVVVZWlri4sWLjI+P8/rrr/P111/z5JNPXrIs69cn76ZeGoaBpmm0tbX9Q6FQeHhubu7fC4UCkUiE1dVVstks8Xgc0zSRZZlGo9ESAdM02djYoNFo8MYbb2BZ1mYoFOKuZPjr/xZBEHCHred83x/b3Nz8l/X19aRlWWxsbNDZ2cnw8DDhcBjf96lWq/T09HD06FGeeuopXnrpJc6ePUs6nb4hhPi/C959ZFn+TtO0lG3bJ0ql0p85jsPW1haFQoG2tjYkSWpF/Uwmw9raGu+//z7A977vX2+GrP93wSZiTdNOGIbxy3K5/DPHcfYXCoVe27Yzpmm2m6bppVKp/Orqqnv69OmoZVn/mEwm/9TzvP9x138NAMpJ4VFTBr6SAAAAAElFTkSuQmCC',
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err, data) => {
				assert.ifError(err);
				Groups.getGroupFields('Test', ['cover:url'], (err, groupData) => {
					assert.ifError(err);
					assert.equal(nconf.get('relative_path') + data.url, groupData['cover:url']);
					done();
				});
			});
		});

		it('should fail to upload group cover with invalid image', (done) => {
			const data = {
				groupName: 'Test',
				file: {
					path: imagePath,
					type: 'image/png',
				},
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail to upload group cover with invalid image', (done) => {
			const data = {
				groupName: 'Test',
				imageData: 'data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAABwA',
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err, data) => {
				assert.equal(err.message, '[[error:invalid-image]]');
				done();
			});
		});

		it('should update group cover position', (done) => {
			const data = {
				groupName: 'Test',
				position: '50% 50%',
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err) => {
				assert.ifError(err);
				Groups.getGroupFields('Test', ['cover:position'], (err, groupData) => {
					assert.ifError(err);
					assert.equal('50% 50%', groupData['cover:position']);
					done();
				});
			});
		});

		it('should fail to update cover position if group name is missing', (done) => {
			Groups.updateCoverPosition('', '50% 50%', (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail to remove cover if not logged in', (done) => {
			socketGroups.cover.remove({ uid: 0 }, { groupName: 'Test' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail to remove cover if not owner', (done) => {
			socketGroups.cover.remove({ uid: regularUid }, { groupName: 'Test' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should remove cover', (done) => {
			socketGroups.cover.remove({ uid: adminUid }, { groupName: 'Test' }, (err) => {
				assert.ifError(err);
				db.getObjectFields('group:Test', ['cover:url'], (err, groupData) => {
					assert.ifError(err);
					assert(!groupData['cover:url']);
					done();
				});
'use strict';


const assert = require('assert');
const shim = require('../public/src/modules/translator.js');

const { Translator } = shim;
const db = require('./mocks/databasemock');

describe('Translator shim', () => {
	describe('.translate()', () => {
		it('should translate correctly', (done) => {
			shim.translate('[[global:pagination.out_of, (foobar), [[global:home]]]]', (translated) => {
				assert.strictEqual(translated, '(foobar) out of Home');
				done();
			});
		});

		it('should accept a language parameter and adjust accordingly', (done) => {
			shim.translate('[[global:home]]', 'de', (translated) => {
				assert.strictEqual(translated, 'Übersicht');
				done();
			});
		});

		it('should translate empty string properly', (done) => {
			shim.translate('', 'en-GB', (translated) => {
				assert.strictEqual(translated, '');
				done();
			});
		});

		it('should translate empty string properly', async () => {
			const translated = await shim.translate('', 'en-GB');
			assert.strictEqual(translated, '');
		});
	});
});

describe('new Translator(language)', () => {
	it('should throw if not passed a language', (done) => {
		assert.throws(() => {
			new Translator();
		}, /language string/);
		done();
	});

	describe('.translate()', () => {
		it('should handle basic translations', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('[[global:home]]').then((translated) => {
				assert.strictEqual(translated, 'Home');
			});
		});

		it('should handle language keys in regular text', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('Let\'s go [[global:home]]').then((translated) => {
				assert.strictEqual(translated, 'Let\'s go Home');
			});
		});

		it('should handle language keys in regular text with another language specified', () => {
			const translator = Translator.create('de');

			return translator.translate('[[global:home]] test').then((translated) => {
				assert.strictEqual(translated, 'Übersicht test');
			});
		});

		it('should handle language keys with parameters', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('[[global:pagination.out_of, 1, 5]]').then((translated) => {
				assert.strictEqual(translated, '1 out of 5');
			});
		});

		it('should handle language keys inside language keys', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('[[notifications:outgoing_link_message, [[global:guest]]]]').then((translated) => {
				assert.strictEqual(translated, 'You are now leaving Guest');
			});
		});

		it('should handle language keys inside language keys with multiple parameters', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('[[notifications:user_posted_to, [[global:guest]], My Topic]]').then((translated) => {
				assert.strictEqual(translated, '<strong>Guest</strong> has posted a reply to: <strong>My Topic</strong>');
			});
		});

		it('should handle language keys inside language keys with all parameters as language keys', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('[[notifications:user_posted_to, [[global:guest]], [[global:guest]]]]').then((translated) => {
				assert.strictEqual(translated, '<strong>Guest</strong> has posted a reply to: <strong>Guest</strong>');
			});
		});

		it('should properly handle parameters that contain square brackets', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('[[global:pagination.out_of, [guest], [[global:home]]]]').then((translated) => {
				assert.strictEqual(translated, '[guest] out of Home');
			});
		});

		it('should properly handle parameters that contain parentheses', () => {
			const translator = Translator.create('en-GB');

			return translator.translate('[[global:pagination.out_of, (foobar), [[global:home]]]]').then((translated) => {
				assert.strictEqual(translated, '(foobar) out of Home');
			});
		});

		it('should escape language key parameters with HTML in them', () => {
			const translator = Translator.create('en-GB');

			const key = '[[global:403.login, <strong>test</strong>]]';
			return translator.translate(key).then((translated) => {
				assert.strictEqual(translated, 'Perhaps you should <a href=\'&lt;strong&gt;test&lt;/strong&gt;/login\'>try logging in</a>?');
			});
		});

		it('should not unescape html in parameters', () => {
			const translator = Translator.create('en-GB');

			const key = '[[pages:tag, some&amp;tag]]';
			return translator.translate(key).then((translated) => {
				assert.strictEqual(translated, 'Topics tagged under &quot;some&amp;tag&quot;');
			});
		});

		it('should translate escaped translation arguments properly', () => {
			// https://github.com/NodeBB/NodeBB/issues/9206
			const translator = Translator.create('en-GB');

			const key = '[[notifications:upvoted_your_post_in, test1, error: Error: &lsqb;&lsqb;error:group-name-too-long&rsqb;&rsqb; on NodeBB Upgrade]]';
			return translator.translate(key).then((translated) => {
				assert.strictEqual(translated, '<strong>test1</strong> has upvoted your post in <strong>error: Error: &lsqb;&lsqb;error:group-name-too-long&rsqb;&rsqb; on NodeBB Upgrade</strong>.');
			});
		});

		it('should properly escape and ignore % and \\, in arguments', () => {
			const translator = Translator.create('en-GB');

			const title = 'Test 1\\, 2\\, 3 %2 salmon';
			const key = `[[topic:composer.replying_to, ${title}]]`;
			return translator.translate(key).then((translated) => {
				assert.strictEqual(translated, 'Replying to Test 1&#44; 2&#44; 3 &#37;2 salmon');
			});
		});

		it('should not escape regular %', () => {
			const translator = Translator.create('en-GB');

			const title = '3 % salmon';
			const key = `[[topic:composer.replying_to, ${title}]]`;
			return translator.translate(key).then((translated) => {
				assert.strictEqual(translated, 'Replying to 3 % salmon');
			});
		});

		it('should not translate [[derp] some text', () => {
			const translator = Translator.create('en-GB');
			return translator.translate('[[derp] some text').then((translated) => {
				assert.strictEqual('[[derp] some text', translated);
			});
		});

		it('should not translate [[derp]] some text', () => {
			const translator = Translator.create('en-GB');
			return translator.translate('[[derp]] some text').then((translated) => {
				assert.strictEqual('[[derp]] some text', translated);
			});
		});

		it('should not translate [[derp:xyz] some text', () => {
			const translator = Translator.create('en-GB');
			return translator.translate('[[derp:xyz] some text').then((translated) => {
				assert.strictEqual('[[derp:xyz] some text', translated);
			});
		});

		it('should translate keys with slashes properly', () => {
			const translator = Translator.create('en-GB');
			return translator.translate('[[pages:users/latest]]').then((translated) => {
				assert.strictEqual(translated, 'Latest Users');
			});
		});

		it('should use key for unknown keys without arguments', () => {
			const translator = Translator.create('en-GB');
			return translator.translate('[[unknown:key.without.args]]').then((translated) => {
				assert.strictEqual(translated, 'key.without.args');
			});
		});

		it('should use backup for unknown keys with arguments', () => {
			const translator = Translator.create('en-GB');
			return translator.translate('[[unknown:key.with.args, arguments are here, derpity, derp]]').then((translated) => {
				assert.strictEqual(translated, 'unknown:key.with.args, arguments are here, derpity, derp');
			});
		});

		it('should ignore unclosed tokens', () => {
			const translator = Translator.create('en-GB');
			return translator.translate('here is some stuff and other things [[abc:xyz, other random stuff should be fine here [[global:home]] and more things [[pages:users/latest]]').then((translated) => {
				assert.strictEqual(translated, 'here is some stuff and other things abc:xyz, other random stuff should be fine here Home and more things Latest Users');
			});
		});
	});
});

describe('Translator.create()', () => {
	it('should return an instance of Translator', (done) => {
		const translator = Translator.create('en-GB');

		assert(translator instanceof Translator);
		done();
	});
	it('should return the same object for the same language', (done) => {
		const one = Translator.create('de');
		const two = Translator.create('de');

		assert.strictEqual(one, two);
		done();
	});
	it('should default to defaultLang', (done) => {
		const translator = Translator.create();

		assert.strictEqual(translator.lang, 'en-GB');
		done();
	});
});

describe('Translator modules', () => {
	it('should work before registered', () => {
		const translator = Translator.create();

		Translator.registerModule('test-custom-integer-format', lang => function (key, args) {
			const num = parseInt(args[0], 10) || 0;
			if (key === 'binary') {
				return num.toString(2);
			}
			if (key === 'hex') {
				return num.toString(16);
			}
			if (key === 'octal') {
				return num.toString(8);
			}
			return num.toString();
		});

		return translator.translate('[[test-custom-integer-format:octal, 24]]').then((translation) => {
			assert.strictEqual(translation, '30');
		});
	});

	it('should work after registered', () => {
		const translator = Translator.create('de');

		return translator.translate('[[test-custom-integer-format:octal, 23]]').then((translation) => {
			assert.strictEqual(translation, '27');
		});
	});

	it('registerModule be passed the language', (done) => {
		Translator.registerModule('something', (lang) => {
			assert.ok(lang);
		});

		const translator = Translator.create('fr_FR');
		done();
	});
});

describe('Translator static methods', () => {
	describe('.removePatterns', () => {
		it('should remove translator patterns from text', (done) => {
			assert.strictEqual(
				Translator.removePatterns('Lorem ipsum dolor [[sit:amet]], consectetur adipiscing elit. [[sed:vitae, [[semper:dolor]]]] lorem'),
				'Lorem ipsum dolor , consectetur adipiscing elit.  lorem'
			);
			done();
		});
	});
	describe('.escape', () => {
		it('should escape translation patterns within text', (done) => {
			assert.strictEqual(
				Translator.escape('some nice text [[global:home]] here'),
				'some nice text &lsqb;&lsqb;global:home&rsqb;&rsqb; here'
			);
			done();
		});
	});

	describe('.unescape', () => {
		it('should unescape escaped translation patterns within text', (done) => {
			assert.strictEqual(
				Translator.unescape('some nice text \\[\\[global:home\\]\\] here'),
				'some nice text [[global:home]] here'
			);
			assert.strictEqual(
				Translator.unescape('some nice text &lsqb;&lsqb;global:home&rsqb;&rsqb; here'),
				'some nice text [[global:home]] here'
			);
			done();
		});
	});

	describe('.compile', () => {
		it('should create a translator pattern from a key and list of arguments', (done) => {
			assert.strictEqual(
				Translator.compile('amazing:cool', 'awesome', 'great'),
				'[[amazing:cool, awesome, great]]'
			);
			done();
		});

		it('should escape `%` and `,` in arguments', (done) => {
			assert.strictEqual(
				Translator.compile('amazing:cool', '100% awesome!', 'one, two, and three'),
				'[[amazing:cool, 100&#37; awesome!, one&#44; two&#44; and three]]'
			);
			done();
		});
	});

	describe('add translation', () => {
		it('should add custom translations', async () => {
			shim.addTranslation('en-GB', 'my-namespace', { foo: 'a custom translation' });
			const t = await shim.translate('this is best [[my-namespace:foo]]');
			assert.strictEqual(t, 'this is best a custom translation');
		});
	});

	describe('translate nested keys', () => {
		it('should handle nested translations', async () => {
			shim.addTranslation('en-GB', 'my-namespace', {
				key: {
					key1: 'key1 translated',
					key2: {
						key3: 'key3 translated',
					},
				},
			});
			const t1 = await shim.translate('this is best [[my-namespace:key.key1]]');
			const t2 = await shim.translate('this is best [[my-namespace:key.key2.key3]]');
			assert.strictEqual(t1, 'this is best key1 translated');
			assert.strictEqual(t2, 'this is best key3 translated');
		});
		it("should try the defaults if it didn't reach a string in a nested translation", async () => {
			shim.addTranslation('en-GB', 'my-namespace', {
				default1: {
					default1: 'default1 translated',
					'': 'incorrect priority',
				},
				default2: {
					'': 'default2 translated',
				},
			});
			const d1 = await shim.translate('this is best [[my-namespace:default1]]');
			const d2 = await shim.translate('this is best [[my-namespace:default2]]');
			assert.strictEqual(d1, 'this is best default1 translated');
'use strict';

const _ = require('lodash');
const assert = require('assert');
const path = require('path');
const fs = require('fs');
const SwaggerParser = require('@apidevtools/swagger-parser');
const request = require('request-promise-native');
const nconf = require('nconf');
const jwt = require('jsonwebtoken');
const util = require('util');

const wait = util.promisify(setTimeout);

const db = require('./mocks/databasemock');
const helpers = require('./helpers');
const meta = require('../src/meta');
const user = require('../src/user');
const groups = require('../src/groups');
const categories = require('../src/categories');
const topics = require('../src/topics');
const posts = require('../src/posts');
const plugins = require('../src/plugins');
const flags = require('../src/flags');
const messaging = require('../src/messaging');
const utils = require('../src/utils');

describe('API', async () => {
	let readApi = false;
	let writeApi = false;
	const readApiPath = path.resolve(__dirname, '../public/openapi/read.yaml');
	const writeApiPath = path.resolve(__dirname, '../public/openapi/write.yaml');
	let jar;
	let csrfToken;
	let setup = false;
	const unauthenticatedRoutes = ['/api/login', '/api/register'];	// Everything else will be called with the admin user

	const mocks = {
		head: {},
		get: {
			'/api/email/unsubscribe/{token}': [
				{
					in: 'path',
					name: 'token',
					example: (() => jwt.sign({
						template: 'digest',
						uid: 1,
					}, nconf.get('secret')))(),
				},
			],
		},
		post: {},
		put: {},
		delete: {
			'/users/{uid}/tokens/{token}': [
				{
					in: 'path',
					name: 'uid',
					example: 1,
				},
				{
					in: 'path',
					name: 'token',
					example: utils.generateUUID(),
				},
			],
			'/users/{uid}/sessions/{uuid}': [
				{
					in: 'path',
					name: 'uid',
					example: 1,
				},
				{
					in: 'path',
					name: 'uuid',
					example: '',	// to be defined below...
				},
			],
			'/posts/{pid}/diffs/{timestamp}': [
				{
					in: 'path',
					name: 'pid',
					example: '',	// to be defined below...
				},
				{
					in: 'path',
					name: 'timestamp',
					example: '',	// to be defined below...
				},
			],
		},
	};

	async function dummySearchHook(data) {
		return [1];
	}
	async function dummyEmailerHook(data) {
		// pretend to handle sending emails
	}

	after(async () => {
		plugins.hooks.unregister('core', 'filter:search.query', dummySearchHook);
		plugins.hooks.unregister('emailer-test', 'filter:email.send');
	});

	async function setupData() {
		if (setup) {
			return;
		}

		// Create sample users
		const adminUid = await user.create({ username: 'admin', password: '123456', email: 'test@example.org' });
		const unprivUid = await user.create({ username: 'unpriv', password: '123456', email: 'unpriv@example.org' });
		for (let x = 0; x < 4; x++) {
			// eslint-disable-next-line no-await-in-loop
			await user.create({ username: 'deleteme', password: '123456' });	// for testing of DELETE /users (uids 5, 6) and DELETE /user/:uid/account (uid 7)
		}
		await groups.join('administrators', adminUid);

		// Create sample group
		await groups.create({
			name: 'Test Group',
		});

		await meta.settings.set('core.api', {
			tokens: [{
				token: mocks.delete['/users/{uid}/tokens/{token}'][1].example,
				uid: 1,
				description: 'for testing of token deletion route',
				timestamp: Date.now(),
			}],
		});
		meta.config.allowTopicsThumbnail = 1;
		meta.config.termsOfUse = 'I, for one, welcome our new test-driven overlords';

		// Create a category
		const testCategory = await categories.create({ name: 'test' });

		// Post a new topic
		await topics.post({
			uid: adminUid,
			cid: testCategory.cid,
			title: 'Test Topic',
			content: 'Test topic content',
		});
		const unprivTopic = await topics.post({
			uid: unprivUid,
			cid: testCategory.cid,
			title: 'Test Topic 2',
			content: 'Test topic 2 content',
		});
		await topics.post({
			uid: unprivUid,
			cid: testCategory.cid,
			title: 'Test Topic 3',
			content: 'Test topic 3 content',
		});

		// Create a post diff
		await posts.edit({
			uid: adminUid,
			pid: unprivTopic.postData.pid,
			content: 'Test topic 2 edited content',
			req: {},
		});
		mocks.delete['/posts/{pid}/diffs/{timestamp}'][0].example = unprivTopic.postData.pid;
		mocks.delete['/posts/{pid}/diffs/{timestamp}'][1].example = (await posts.diffs.list(unprivTopic.postData.pid))[0];

		// Create a sample flag
		await flags.create('post', 1, unprivUid, 'sample reasons', Date.now());

		// Create a new chat room
		await messaging.newRoom(1, [2]);

		// Create an empty file to test DELETE /files and thumb deletion
		fs.closeSync(fs.openSync(path.resolve(nconf.get('upload_path'), 'files/test.txt'), 'w'));
		fs.closeSync(fs.openSync(path.resolve(nconf.get('upload_path'), 'files/test.png'), 'w'));

		// Associate thumb with topic to test thumb reordering
		await topics.thumbs.associate({
			id: 2,
			path: 'files/test.png',
		});

		const socketUser = require('../src/socket.io/user');
		const socketAdmin = require('../src/socket.io/admin');
		// export data for admin user
		await socketUser.exportProfile({ uid: adminUid }, { uid: adminUid });
		await socketUser.exportPosts({ uid: adminUid }, { uid: adminUid });
		await socketUser.exportUploads({ uid: adminUid }, { uid: adminUid });
		await socketAdmin.user.exportUsersCSV({ uid: adminUid }, {});
		// wait for export child process to complete
		await wait(5000);

		// Attach a search hook so /api/search is enabled
		plugins.hooks.register('core', {
			hook: 'filter:search.query',
			method: dummySearchHook,
		});
		// Attach an emailer hook so related requests do not error
		plugins.hooks.register('emailer-test', {
			hook: 'filter:email.send',
			method: dummyEmailerHook,
		});

		jar = await helpers.loginUser('admin', '123456');

		// Retrieve CSRF token using cookie, to test Write API
		const config = await request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			jar: jar,
		});
		csrfToken = config.csrf_token;

		setup = true;
	}

	it('should pass OpenAPI v3 validation', async () => {
		try {
			await SwaggerParser.validate(readApiPath);
			await SwaggerParser.validate(writeApiPath);
		} catch (e) {
			assert.ifError(e);
		}
	});

	readApi = await SwaggerParser.dereference(readApiPath);
	writeApi = await SwaggerParser.dereference(writeApiPath);

	it('should grab all mounted routes and ensure a schema exists', async () => {
		const webserver = require('../src/webserver');
		const buildPaths = function (stack, prefix) {
			const paths = stack.map((dispatch) => {
				if (dispatch.route && dispatch.route.path && typeof dispatch.route.path === 'string') {
					if (!prefix && !dispatch.route.path.startsWith('/api/')) {
						return null;
					}

					if (prefix === nconf.get('relative_path')) {
						prefix = '';
					}

					return {
						method: Object.keys(dispatch.route.methods)[0],
						path: (prefix || '') + dispatch.route.path,
					};
				} else if (dispatch.name === 'router') {
					const prefix = dispatch.regexp.toString().replace('/^', '').replace('\\/?(?=\\/|$)/i', '').replace(/\\\//g, '/');
					return buildPaths(dispatch.handle.stack, prefix);
				}

				// Drop any that aren't actual routes (middlewares, error handlers, etc.)
				return null;
			});

			return _.flatten(paths);
		};

		let paths = buildPaths(webserver.app._router.stack).filter(Boolean).map((pathObj) => {
			pathObj.path = pathObj.path.replace(/\/:([^\\/]+)/g, '/{$1}');
			return pathObj;
		});
		const exclusionPrefixes = ['/api/admin/plugins', '/api/compose', '/debug'];
		paths = paths.filter(path => path.method !== '_all' && !exclusionPrefixes.some(prefix => path.path.startsWith(prefix)));


		// For each express path, query for existence in read and write api schemas
		paths.forEach((pathObj) => {
			describe(`${pathObj.method.toUpperCase()} ${pathObj.path}`, () => {
				it('should be defined in schema docs', () => {
					let schema = readApi;
					if (pathObj.path.startsWith('/api/v3')) {
						schema = writeApi;
						pathObj.path = pathObj.path.replace('/api/v3', '');
					}

					// Don't check non-GET routes in Read API
					if (schema === readApi && pathObj.method !== 'get') {
						return;
					}

					const normalizedPath = pathObj.path.replace(/\/:([^\\/]+)/g, '/{$1}').replace(/\?/g, '');
					assert(schema.paths.hasOwnProperty(normalizedPath), `${pathObj.path} is not defined in schema docs`);
					assert(schema.paths[normalizedPath].hasOwnProperty(pathObj.method), `${pathObj.path} was found in schema docs, but ${pathObj.method.toUpperCase()} method is not defined`);
				});
			});
		});
	});

	generateTests(readApi, Object.keys(readApi.paths));
	generateTests(writeApi, Object.keys(writeApi.paths), writeApi.servers[0].url);

	function generateTests(api, paths, prefix) {
		// Iterate through all documented paths, make a call to it,
		// and compare the result body with what is defined in the spec
		const pathLib = path;	// for calling path module from inside this forEach
		paths.forEach((path) => {
			const context = api.paths[path];
			let schema;
			let response;
			let url;
			let method;
			const headers = {};
			const qs = {};

			Object.keys(context).forEach((_method) => {
				// Only test GET routes in the Read API
				if (api.info.title === 'NodeBB Read API' && _method !== 'get') {
					return;
				}

				it('should have each path parameter defined in its context', () => {
					method = _method;
					if (!context[method].parameters) {
						return;
					}

					const pathParams = (path.match(/{[\w\-_*]+}?/g) || []).map(match => match.slice(1, -1));
					const schemaParams = context[method].parameters.map(param => (param.in === 'path' ? param.name : null)).filter(Boolean);
					assert(pathParams.every(param => schemaParams.includes(param)), `${method.toUpperCase()} ${path} has path parameters specified but not defined`);
				});

				it('should have examples when parameters are present', () => {
					let { parameters } = context[method];
					let testPath = path;

					if (parameters) {
						// Use mock data if provided
						parameters = mocks[method][path] || parameters;

						parameters.forEach((param) => {
							assert(param.example !== null && param.example !== undefined, `${method.toUpperCase()} ${path} has parameters without examples`);

							switch (param.in) {
								case 'path':
									testPath = testPath.replace(`{${param.name}}`, param.example);
									break;
								case 'header':
									headers[param.name] = param.example;
									break;
								case 'query':
									qs[param.name] = param.example;
									break;
							}
						});
					}

					url = nconf.get('url') + (prefix || '') + testPath;
				});

				it('should contain a valid request body (if present) with application/json or multipart/form-data type if POST/PUT/DELETE', () => {
					if (['post', 'put', 'delete'].includes(method) && context[method].hasOwnProperty('requestBody')) {
						const failMessage = `${method.toUpperCase()} ${path} has a malformed request body`;
						assert(context[method].requestBody, failMessage);
						assert(context[method].requestBody.content, failMessage);

						if (context[method].requestBody.content.hasOwnProperty('application/json')) {
							assert(context[method].requestBody.content['application/json'], failMessage);
							assert(context[method].requestBody.content['application/json'].schema, failMessage);
							assert(context[method].requestBody.content['application/json'].schema.properties, failMessage);
						} else if (context[method].requestBody.content.hasOwnProperty('multipart/form-data')) {
							assert(context[method].requestBody.content['multipart/form-data'], failMessage);
							assert(context[method].requestBody.content['multipart/form-data'].schema, failMessage);
							assert(context[method].requestBody.content['multipart/form-data'].schema.properties, failMessage);
						}
					}
				});

				it('should not error out when called', async () => {
					await setupData();

					if (csrfToken) {
						headers['x-csrf-token'] = csrfToken;
					}

					let body = {};
					let type = 'json';
					if (context[method].hasOwnProperty('requestBody') && context[method].requestBody.content['application/json']) {
						body = buildBody(context[method].requestBody.content['application/json'].schema.properties);
					} else if (context[method].hasOwnProperty('requestBody') && context[method].requestBody.content['multipart/form-data']) {
						type = 'form';
					}

					try {
						if (type === 'json') {
							// console.log(`calling ${method} ${url} with`, body);
							response = await request(url, {
								method: method,
								jar: !unauthenticatedRoutes.includes(path) ? jar : undefined,
								json: true,
								followRedirect: false,	// all responses are significant (e.g. 302)
								simple: false,	// don't throw on non-200 (e.g. 302)
								resolveWithFullResponse: true,	// send full request back (to check statusCode)
								headers: headers,
								qs: qs,
								body: body,
							});
						} else if (type === 'form') {
							response = await new Promise((resolve, reject) => {
								helpers.uploadFile(url, pathLib.join(__dirname, './files/test.png'), {}, jar, csrfToken, (err, res) => {
									if (err) {
										return reject(err);
									}
									resolve(res);
								});
							});
						}
					} catch (e) {
						assert(!e, `${method.toUpperCase()} ${path} errored with: ${e.message}`);
					}
				});

				it('response status code should match one of the schema defined responses', () => {
					// HACK: allow HTTP 418 I am a teapot, for now   👇
					assert(context[method].responses.hasOwnProperty('418') || Object.keys(context[method].responses).includes(String(response.statusCode)), `${method.toUpperCase()} ${path} sent back unexpected HTTP status code: ${response.statusCode}`);
				});

				// Recursively iterate through schema properties, comparing type
				it('response body should match schema definition', () => {
					const http302 = context[method].responses['302'];
					if (http302 && response.statusCode === 302) {
						// Compare headers instead
						const expectedHeaders = Object.keys(http302.headers).reduce((memo, name) => {
							const value = http302.headers[name].schema.example;
							memo[name] = value.startsWith(nconf.get('relative_path')) ? value : nconf.get('relative_path') + value;
							return memo;
						}, {});

						for (const header of Object.keys(expectedHeaders)) {
							assert(response.headers[header.toLowerCase()]);
							assert.strictEqual(response.headers[header.toLowerCase()], expectedHeaders[header]);
						}
						return;
					}

					const http200 = context[method].responses['200'];
					if (!http200) {
						return;
					}

					assert.strictEqual(response.statusCode, 200, `HTTP 200 expected (path: ${method} ${path}`);

					const hasJSON = http200.content && http200.content['application/json'];
					if (hasJSON) {
						schema = context[method].responses['200'].content['application/json'].schema;
						compare(schema, response.body, method.toUpperCase(), path, 'root');
					}

					// TODO someday: text/csv, binary file type checking?
				});

				it('should successfully re-login if needed', async () => {
					const reloginPaths = ['PUT /users/{uid}/password', 'DELETE /users/{uid}/sessions/{uuid}'];
					if (reloginPaths.includes(`${method.toUpperCase()} ${path}`)) {
						jar = await helpers.loginUser('admin', '123456');
						const sessionUUIDs = await db.getObject('uid:1:sessionUUID:sessionId');
						mocks.delete['/users/{uid}/sessions/{uuid}'][1].example = Object.keys(sessionUUIDs).pop();

						// Retrieve CSRF token using cookie, to test Write API
						const config = await request({
							url: `${nconf.get('url')}/api/config`,
							json: true,
							jar: jar,
						});
						csrfToken = config.csrf_token;
					}
				});
			});
		});
	}

	function buildBody(schema) {
		return Object.keys(schema).reduce((memo, cur) => {
			memo[cur] = schema[cur].example;
			return memo;
		}, {});
	}

	function compare(schema, response, method, path, context) {
		let required = [];
		const additionalProperties = schema.hasOwnProperty('additionalProperties');

		function flattenAllOf(obj) {
			return obj.reduce((memo, obj) => {
				if (obj.allOf) {
					obj = { properties: flattenAllOf(obj.allOf) };
				} else {
					try {
						required = required.concat(obj.required ? obj.required : Object.keys(obj.properties));
					} catch (e) {
						assert.fail(`Syntax error re: allOf, perhaps you allOf'd an array? (path: ${method} ${path}, context: ${context})`);
					}
				}

				return { ...memo, ...obj.properties };
			}, {});
		}

		if (schema.allOf) {
			schema = flattenAllOf(schema.allOf);
		} else if (schema.properties) {
			required = schema.required || Object.keys(schema.properties);
			schema = schema.properties;
		} else {
			// If schema contains no properties, check passes
			return;
		}

		// Compare the schema to the response
		required.forEach((prop) => {
			if (schema.hasOwnProperty(prop)) {
				assert(response.hasOwnProperty(prop), `"${prop}" is a required property (path: ${method} ${path}, context: ${context})`);

				// Don't proceed with type-check if the value could possibly be unset (nullable: true, in spec)
				if (response[prop] === null && schema[prop].nullable === true) {
					return;
				}

				// Therefore, if the value is actually null, that's a problem (nullable is probably missing)
				assert(response[prop] !== null, `"${prop}" was null, but schema does not specify it to be a nullable property (path: ${method} ${path}, context: ${context})`);

				switch (schema[prop].type) {
					case 'string':
						assert.strictEqual(typeof response[prop], 'string', `"${prop}" was expected to be a string, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);
						break;
					case 'boolean':
						assert.strictEqual(typeof response[prop], 'boolean', `"${prop}" was expected to be a boolean, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);
						break;
					case 'object':
						assert.strictEqual(typeof response[prop], 'object', `"${prop}" was expected to be an object, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);
						compare(schema[prop], response[prop], method, path, context ? [context, prop].join('.') : prop);
						break;
					case 'array':
						assert.strictEqual(Array.isArray(response[prop]), true, `"${prop}" was expected to be an array, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);

						if (schema[prop].items) {
							// Ensure the array items have a schema defined
							assert(schema[prop].items.type || schema[prop].items.allOf, `"${prop}" is defined to be an array, but its items have no schema defined (path: ${method} ${path}, context: ${context})`);

							// Compare types
							if (schema[prop].items.type === 'object' || Array.isArray(schema[prop].items.allOf)) {
								response[prop].forEach((res) => {
									compare(schema[prop].items, res, method, path, context ? [context, prop].join('.') : prop);
								});
							} else if (response[prop].length) { // for now
								response[prop].forEach((item) => {
									assert.strictEqual(typeof item, schema[prop].items.type, `"${prop}" should have ${schema[prop].items.type} items, but found ${typeof items} instead (path: ${method} ${path}, context: ${context})`);
								});
							}
						}
						break;
				}
			}
		});

		// Compare the response to the schema
		Object.keys(response).forEach((prop) => {
			if (additionalProperties) {	// All bets are off
				return;
			}

			assert(schema[prop], `"${prop}" was found in response, but is not defined in schema (path: ${method} ${path}, context: ${context})`);
		});
	}
'use strict';

const assert = require('assert');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const settings = require('../src/settings');

describe('settings v3', () => {
	let settings1;
	let settings2;

	it('should create a new settings object', (done) => {
		settings1 = new settings('my-plugin', '1.0', { foo: 1, bar: { derp: 2 } }, done);
	});

	it('should get the saved settings ', (done) => {
		assert.equal(settings1.get('foo'), 1);
		assert.equal(settings1.get('bar.derp'), 2);
		done();
	});

	it('should create a new settings instance for same key', (done) => {
		settings2 = new settings('my-plugin', '1.0', { foo: 1, bar: { derp: 2 } }, done);
	});

	it('should pass change between settings object over pubsub', (done) => {
		settings1.set('foo', 3);
		settings1.persist((err) => {
			assert.ifError(err);
			// give pubsub time to complete
			setTimeout(() => {
				assert.equal(settings2.get('foo'), 3);
				done();
			}, 500);
		});
	});

	it('should set a nested value', (done) => {
		settings1.set('bar.derp', 5);
		assert.equal(settings1.get('bar.derp'), 5);
		done();
	});

	it('should reset the settings to default', (done) => {
		settings1.reset((err) => {
			assert.ifError(err);
			assert.equal(settings1.get('foo'), 1);
			assert.equal(settings1.get('bar.derp'), 2);
			done();
		});
	});

	it('should get value from default value', (done) => {
		const newSettings = new settings('some-plugin', '1.0', { default: { value: 1 } });
'use strict';

const assert = require('assert');

const db = require('./mocks/databasemock');

const plugins = require('../src/plugins');
const categories = require('../src/categories');
const topics = require('../src/topics');
const user = require('../src/user');

describe('Topic Events', () => {
	let fooUid;
	let topic;
	before(async () => {
		fooUid = await user.create({ username: 'foo', password: '123456' });

		const categoryObj = await categories.create({
			name: 'Test Category',
			description: 'Test category created by testing script',
		});
		topic = await topics.post({
			title: 'topic events testing',
			content: 'foobar one two three',
			uid: fooUid,
			cid: 1,
		});
	});

	describe('.init()', () => {
		before(() => {
			topics.events._ready = false;
		});

		it('should allow a plugin to expose new event types', async () => {
			await plugins.hooks.register('core', {
				hook: 'filter:topicEvents.init',
				method: async ({ types }) => {
					types.foo = {
						icon: 'bar',
						text: 'baz',
						quux: 'quux',
					};

					return { types };
				},
			});

			await topics.events.init();

			assert(topics.events._types.foo);
			assert.deepStrictEqual(topics.events._types.foo, {
				icon: 'bar',
				text: 'baz',
				quux: 'quux',
			});
		});
	});

	describe('.log()', () => {
		it('should log and return a set of new events in the topic', async () => {
			const events = await topics.events.log(topic.topicData.tid, {
				type: 'foo',
			});

			assert(events);
			assert(Array.isArray(events));
			events.forEach((event) => {
				assert(['id', 'icon', 'text', 'timestamp', 'timestampISO', 'type', 'quux'].every(key => event.hasOwnProperty(key)));
			});
		});
	});

	describe('.get()', () => {
		it('should get a topic\'s events', async () => {
			const events = await topics.events.get(topic.topicData.tid);

			assert(events);
			assert(Array.isArray(events));
			assert.strictEqual(events.length, 1);
			events.forEach((event) => {
				assert(['id', 'icon', 'text', 'timestamp', 'timestampISO', 'type', 'quux'].every(key => event.hasOwnProperty(key)));
			});
		});
	});

	describe('.purge()', () => {
		let eventIds;

		before(async () => {
			const events = await topics.events.get(topic.topicData.tid);
			eventIds = events.map(event => event.id);
		});

		it('should purge topic\'s events from the database', async () => {
			await topics.events.purge(topic.topicData.tid);

			const keys = [`topic:${topic.topicData.tid}:events`];
			keys.push(...eventIds.map(id => `topicEvent:${id}`));

'use strict';

const assert = require('assert');
const fs = require('fs');
const path = require('path');
const nconf = require('nconf');

const utils = require('../src/utils');
const file = require('../src/file');

describe('file', () => {
	const filename = `${utils.generateUUID()}.png`;
	const folder = 'files';
	const uploadPath = path.join(nconf.get('upload_path'), folder, filename);
	const tempPath = path.join(__dirname, './files/test.png');

	afterEach((done) => {
		fs.unlink(uploadPath, () => {
			done();
		});
	});

	describe('copyFile', () => {
		it('should copy a file', (done) => {
			fs.copyFile(tempPath, uploadPath, (err) => {
				assert.ifError(err);

				assert(file.existsSync(uploadPath));

				const srcContent = fs.readFileSync(tempPath, 'utf8');
				const destContent = fs.readFileSync(uploadPath, 'utf8');

				assert.strictEqual(srcContent, destContent);
				done();
			});
		});

		it('should override an existing file', (done) => {
			fs.writeFileSync(uploadPath, 'hsdkjhgkjsfhkgj');

			fs.copyFile(tempPath, uploadPath, (err) => {
				assert.ifError(err);

				assert(file.existsSync(uploadPath));

				const srcContent = fs.readFileSync(tempPath, 'utf8');
				const destContent = fs.readFileSync(uploadPath, 'utf8');

				assert.strictEqual(srcContent, destContent);
				done();
			});
		});

		it('should error if source file does not exist', (done) => {
			fs.copyFile(`${tempPath}0000000000`, uploadPath, (err) => {
				assert(err);
				assert.strictEqual(err.code, 'ENOENT');

				done();
			});
		});

		it('should error if existing file is read only', (done) => {
			fs.writeFileSync(uploadPath, 'hsdkjhgkjsfhkgj');
			fs.chmodSync(uploadPath, '444');

			fs.copyFile(tempPath, uploadPath, (err) => {
				assert(err);
				assert(err.code === 'EPERM' || err.code === 'EACCES');

				done();
			});
		});
	});

	describe('saveFileToLocal', () => {
		it('should work', (done) => {
			file.saveFileToLocal(filename, folder, tempPath, (err) => {
				assert.ifError(err);

				assert(file.existsSync(uploadPath));

				const oldFile = fs.readFileSync(tempPath, 'utf8');
				const newFile = fs.readFileSync(uploadPath, 'utf8');
				assert.strictEqual(oldFile, newFile);

				done();
			});
		});

		it('should error if source does not exist', (done) => {
			file.saveFileToLocal(filename, folder, `${tempPath}000000000`, (err) => {
				assert(err);
				assert.strictEqual(err.code, 'ENOENT');

				done();
			});
		});

		it('should error if folder is relative', (done) => {
			file.saveFileToLocal(filename, '../../text', `${tempPath}000000000`, (err) => {
				assert(err);
				assert.strictEqual(err.message, '[[error:invalid-path]]');
				done();
			});
		});
	});

	it('should walk directory', (done) => {
		file.walk(__dirname, (err, data) => {
			assert.ifError(err);
			assert(Array.isArray(data));
			done();
		});
	});

	it('should convert mime type to extension', (done) => {
		assert.equal(file.typeToExtension('image/png'), '.png');
		assert.equal(file.typeToExtension(''), '');
		done();
'use strict';

const assert = require('assert');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const coverPhoto = require('../src/coverPhoto');
const meta = require('../src/meta');

describe('coverPhoto', () => {
	it('should get default group cover', (done) => {
		meta.config['groups:defaultCovers'] = '/assets/image1.png, /assets/image2.png';
		const result = coverPhoto.getDefaultGroupCover('registered-users');
		assert.equal(result, `${nconf.get('relative_path')}/assets/image2.png`);
		done();
	});

	it('should get default default profile cover', (done) => {
		meta.config['profile:defaultCovers'] = ' /assets/image1.png, /assets/image2.png ';
		const result = coverPhoto.getDefaultProfileCover(1);
'use strict';

// see https://gist.github.com/jfromaniello/4087861#gistcomment-1447029


process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

const util = require('util');

const sleep = util.promisify(setTimeout);
const assert = require('assert');
const async = require('async');
const nconf = require('nconf');
const request = require('request');

const cookies = request.jar();

const db = require('./mocks/databasemock');
const user = require('../src/user');
const groups = require('../src/groups');
const categories = require('../src/categories');
const helpers = require('./helpers');
const meta = require('../src/meta');
const events = require('../src/events');

const socketAdmin = require('../src/socket.io/admin');

describe('socket.io', () => {
	let io;
	let cid;
	let tid;
	let adminUid;
	let regularUid;

	before((done) => {
		async.series([
			async.apply(user.create, { username: 'admin', password: 'adminpwd' }),
			async.apply(user.create, { username: 'regular', password: 'regularpwd', email: 'regular@test.com' }),
			async.apply(categories.create, {
				name: 'Test Category',
				description: 'Test category created by testing script',
			}),
		], (err, data) => {
			if (err) {
				return done(err);
			}
			adminUid = data[0];
			regularUid = data[1];
			cid = data[2].cid;

			groups.join('administrators', data[0], done);
		});
	});


	it('should connect and auth properly', (done) => {
		request.get({
			url: `${nconf.get('url')}/api/config`,
			jar: cookies,
			json: true,
		}, (err, res, body) => {
			assert.ifError(err);

			request.post(`${nconf.get('url')}/login`, {
				jar: cookies,
				form: {
					username: 'admin',
					password: 'adminpwd',
				},
				headers: {
					'x-csrf-token': body.csrf_token,
				},
				json: true,
			}, (err, res) => {
				assert.ifError(err);

				helpers.connectSocketIO(res, (err, _io) => {
					io = _io;
					assert.ifError(err);

					done();
				});
			});
		});
	});

	it('should return error for unknown event', (done) => {
		io.emit('unknown.event', (err) => {
			assert(err);
			assert.equal(err.message, '[[error:invalid-event, unknown.event]]');
			done();
		});
	});

	it('should get installed themes', (done) => {
		const themes = ['nodebb-theme-lavender', 'nodebb-theme-persona', 'nodebb-theme-vanilla'];
		io.emit('admin.themes.getInstalled', (err, data) => {
			assert.ifError(err);
			assert(data);
			const installed = data.map(theme => theme.id);
			themes.forEach((theme) => {
				assert.notEqual(installed.indexOf(theme), -1);
			});
			done();
		});
	});

	it('should post a topic', (done) => {
		io.emit('topics.post', { title: 'test topic title', content: 'test topic main post content', uid: adminUid, cid: cid }, (err, result) => {
			assert.ifError(err);
			assert.equal(result.user.username, 'admin');
			assert.equal(result.category.cid, cid);
			assert.equal(result.mainPost.content, 'test topic main post content');
			tid = result.tid;
			done();
		});
	});

	it('should reply to topic', (done) => {
		io.emit('posts.reply', { tid: tid, uid: adminUid, content: 'test post content' }, (err, result) => {
			assert.ifError(err);
			assert.equal(result.uid, adminUid);
			assert.equal(result.user.username, 'admin');
			assert.equal(result.topic.tid, tid);
			done();
		});
	});

	it('should get more unread topics', (done) => {
		io.emit('topics.loadMoreSortedTopics', { after: 0, count: 10, direction: 1, sort: 'unread' }, (err, result) => {
			assert.ifError(err);
			assert(Array.isArray(result.topics));
			done();
		});
	});

	it('should ban a user', (done) => {
		const socketUser = require('../src/socket.io/user');
		socketUser.banUsers({ uid: adminUid }, { uids: [regularUid], reason: 'spammer' }, (err) => {
			assert.ifError(err);
			user.getLatestBanInfo(regularUid, (err, data) => {
				assert.ifError(err);
				assert(data.uid);
				assert(data.timestamp);
				assert(data.hasOwnProperty('banned_until'));
				assert(data.hasOwnProperty('banned_until_readable'));
				assert.equal(data.reason, 'spammer');
				done();
			});
		});
	});

	it('should return ban reason', (done) => {
		user.bans.getReason(regularUid, (err, reason) => {
			assert.ifError(err);
			assert.equal(reason, 'spammer');
			done();
		});
	});

	it('should unban a user', (done) => {
		const socketUser = require('../src/socket.io/user');
		socketUser.unbanUsers({ uid: adminUid }, [regularUid], (err) => {
			assert.ifError(err);
			user.bans.isBanned(regularUid, (err, isBanned) => {
				assert.ifError(err);
				assert(!isBanned);
				done();
			});
		});
	});

	it('should make user admin', (done) => {
		socketAdmin.user.makeAdmins({ uid: adminUid }, [regularUid], (err) => {
			assert.ifError(err);
			groups.isMember(regularUid, 'administrators', (err, isMember) => {
				assert.ifError(err);
				assert(isMember);
				done();
			});
		});
	});

	it('should make user non-admin', (done) => {
		socketAdmin.user.removeAdmins({ uid: adminUid }, [regularUid], (err) => {
			assert.ifError(err);
			groups.isMember(regularUid, 'administrators', (err, isMember) => {
				assert.ifError(err);
				assert(!isMember);
				done();
			});
		});
	});

	describe('user create/delete', () => {
		let uid;
		it('should create a user', async () => {
			const userData = await socketAdmin.user.createUser({ uid: adminUid }, { username: 'foo1' });
			uid = userData.uid;
			const isMember = await groups.isMember(userData.uid, 'registered-users');
			assert(isMember);
		});

		it('should delete users', async () => {
			await socketAdmin.user.deleteUsers({ uid: adminUid }, [uid]);
			await sleep(500);
			const isMember = await groups.isMember(uid, 'registered-users');
			assert(!isMember);
		});

		it('should error if user does not exist', (done) => {
			socketAdmin.user.deleteUsersAndContent({ uid: adminUid }, [uid], (err) => {
				assert.strictEqual(err.message, '[[error:no-user]]');
				done();
			});
		});

		it('should delete users and their content', async () => {
			const userData = await socketAdmin.user.createUser({ uid: adminUid }, { username: 'foo2' });
			await socketAdmin.user.deleteUsersAndContent({ uid: adminUid }, [userData.uid]);
			await sleep(500);
			const isMember = await groups.isMember(userData.uid, 'registered-users');
			assert(!isMember);
		});
	});

	it('should error with invalid data', (done) => {
		socketAdmin.user.createUser({ uid: adminUid }, null, (err) => {
			assert.equal(err.message, '[[error:invalid-data]]');
			done();
		});
	});

	it('should reset lockouts', (done) => {
		socketAdmin.user.resetLockouts({ uid: adminUid }, [regularUid], (err) => {
			assert.ifError(err);
			done();
		});
	});

	describe('validation emails', () => {
		const meta = require('../src/meta');
		const plugins = require('../src/plugins');

		async function dummyEmailerHook(data) {
			// pretend to handle sending emails
		}
		before(() => {
			// Attach an emailer hook so related requests do not error
			plugins.hooks.register('emailer-test', {
				hook: 'filter:email.send',
				method: dummyEmailerHook,
			});
		});
		after(() => {
			plugins.hooks.unregister('emailer-test', 'filter:email.send');
		});

		it('should validate emails', (done) => {
			socketAdmin.user.validateEmail({ uid: adminUid }, [regularUid], (err) => {
				assert.ifError(err);
				user.getUserField(regularUid, 'email:confirmed', (err, emailConfirmed) => {
					assert.ifError(err);
					assert.equal(parseInt(emailConfirmed, 10), 1);
					done();
				});
			});
		});

		it('should error with invalid uids', (done) => {
			socketAdmin.user.sendValidationEmail({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if email validation is not required', (done) => {
			socketAdmin.user.sendValidationEmail({ uid: adminUid }, [regularUid], (err) => {
				assert.equal(err.message, '[[error:email-confirmations-are-disabled]]');
				done();
			});
		});

		it('should send validation email', (done) => {
			meta.config.requireEmailConfirmation = 1;
			socketAdmin.user.sendValidationEmail({ uid: adminUid }, [regularUid], (err) => {
				assert.ifError(err);
				meta.config.requireEmailConfirmation = 0;
				done();
			});
		});
	});

	it('should push unread notifications on reconnect', (done) => {
		const socketMeta = require('../src/socket.io/meta');
		socketMeta.reconnected({ uid: 1 }, {}, (err) => {
			assert.ifError(err);
			done();
		});
	});


	it('should error if the room is missing', (done) => {
		io.emit('meta.rooms.enter', null, (err) => {
			assert.equal(err.message, '[[error:invalid-data]]');
			done();
		});
	});

	it('should return if uid is 0', (done) => {
		const socketMeta = require('../src/socket.io/meta');
		socketMeta.rooms.enter({ uid: 0 }, null, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should join a room', (done) => {
		io.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should leave current room', (done) => {
		io.emit('meta.rooms.leaveCurrent', {}, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should get server time', (done) => {
		io.emit('admin.getServerTime', null, (err, time) => {
			assert.ifError(err);
			assert(time);
			done();
		});
	});

	it('should error to get daily analytics with invalid data', (done) => {
		io.emit('admin.analytics.get', null, (err) => {
			assert.equal(err.message, '[[error:invalid-data]]');
			done();
		});
	});

	it('should get daily analytics', (done) => {
		io.emit('admin.analytics.get', { graph: 'traffic', units: 'days' }, (err, data) => {
			assert.ifError(err);
			assert(data);
			assert(data.summary);
			done();
		});
	});

	it('should get hourly analytics', (done) => {
		io.emit('admin.analytics.get', { graph: 'traffic', units: 'hours' }, (err, data) => {
			assert.ifError(err);
			assert(data);
			assert(data.summary);
			done();
		});
	});

	it('should allow a custom date range for traffic graph analytics', (done) => {
		io.emit('admin.analytics.get', { graph: 'traffic', units: 'days', amount: '7' }, (err, data) => {
			assert.ifError(err);
			assert(data);
			assert(data.pageviews);
			assert(data.uniqueVisitors);
			assert.strictEqual(7, data.pageviews.length);
			assert.strictEqual(7, data.uniqueVisitors.length);
			done();
		});
	});

	it('should return error', (done) => {
		socketAdmin.before({ uid: 10 }, 'someMethod', {}, (err) => {
			assert.equal(err.message, '[[error:no-privileges]]');
			done();
		});
	});

	it('should get room stats', (done) => {
		io.emit('meta.rooms.enter', { enter: 'topic_1' }, (err) => {
			assert.ifError(err);
			socketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {
				assert.ifError(err);
				setTimeout(() => {
					socketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {
						assert.ifError(err);
						assert(data.hasOwnProperty('onlineGuestCount'));
						assert(data.hasOwnProperty('onlineRegisteredCount'));
						assert(data.hasOwnProperty('socketCount'));
						assert(data.hasOwnProperty('topics'));
						assert(data.hasOwnProperty('users'));
						done();
					});
				}, 1000);
			});
		});
	});

	it('should get room stats', (done) => {
		io.emit('meta.rooms.enter', { enter: 'category_1' }, (err) => {
			assert.ifError(err);
			socketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {
				assert.ifError(err);
				setTimeout(() => {
					socketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {
						assert.ifError(err);
						assert.equal(data.users.category, 1, JSON.stringify(data, null, 4));
						done();
					});
				}, 1000);
			});
		});
	});

	it('should get admin search dictionary', (done) => {
		socketAdmin.getSearchDict({ uid: adminUid }, {}, (err, data) => {
			assert.ifError(err);
			assert(Array.isArray(data));
			assert(data[0].namespace);
			assert(data[0].translations);
			assert(data[0].title);
			done();
		});
	});

	it('should fire event', (done) => {
		io.on('testEvent', (data) => {
			assert.equal(data.foo, 1);
			done();
		});
		socketAdmin.fireEvent({ uid: adminUid }, { name: 'testEvent', payload: { foo: 1 } }, (err) => {
			assert.ifError(err);
		});
	});

	it('should error with invalid data', (done) => {
		socketAdmin.themes.set({ uid: adminUid }, null, (err) => {
			assert.equal(err.message, '[[error:invalid-data]]');
			done();
		});
	});

	it('should set theme to bootswatch', (done) => {
		socketAdmin.themes.set({ uid: adminUid }, {
			type: 'bootswatch',
			src: '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css',
			id: 'darkly',
		}, (err) => {
			assert.ifError(err);
			meta.configs.getFields(['theme:src', 'bootswatchSkin'], (err, fields) => {
				assert.ifError(err);
				assert.equal(fields['theme:src'], '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css');
				assert.equal(fields.bootswatchSkin, 'darkly');
				done();
			});
		});
	});

	it('should set theme to local persona', (done) => {
		socketAdmin.themes.set({ uid: adminUid }, { type: 'local', id: 'nodebb-theme-persona' }, (err) => {
			assert.ifError(err);
			meta.configs.get('theme:id', (err, id) => {
				assert.ifError(err);
				assert.equal(id, 'nodebb-theme-persona');
				done();
			});
		});
	});

	it('should toggle plugin active', (done) => {
		socketAdmin.plugins.toggleActive({ uid: adminUid }, 'nodebb-plugin-location-to-map', (err, data) => {
			assert.ifError(err);
			assert.deepEqual(data, { id: 'nodebb-plugin-location-to-map', active: true });
			done();
		});
	});

	it('should toggle plugin install', function (done) {
		this.timeout(0);
		socketAdmin.plugins.toggleInstall({ uid: adminUid }, { id: 'nodebb-plugin-location-to-map', version: 'latest' }, (err, data) => {
			assert.ifError(err);
			assert.equal(data.name, 'nodebb-plugin-location-to-map');
			done();
		});
	});

	it('should get list of active plugins', (done) => {
		socketAdmin.plugins.getActive({ uid: adminUid }, {}, (err, data) => {
			assert.ifError(err);
			assert(Array.isArray(data));
			done();
		});
	});

	it('should order active plugins', (done) => {
		const data = [
			{ name: 'nodebb-theme-persona', order: 0 },
			{ name: 'nodebb-plugin-dbsearch', order: 1 },
			{ name: 'nodebb-plugin-markdown', order: 2 },
			{ ignoreme: 'wrong data' },
		];
		socketAdmin.plugins.orderActivePlugins({ uid: adminUid }, data, (err) => {
			assert.ifError(err);
			db.sortedSetRank('plugins:active', 'nodebb-plugin-dbsearch', (err, rank) => {
				assert.ifError(err);
				assert.equal(rank, 1);
				done();
			});
		});
	});

	it('should upgrade plugin', function (done) {
		this.timeout(0);
		socketAdmin.plugins.upgrade({ uid: adminUid }, { id: 'nodebb-plugin-location-to-map', version: 'latest' }, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should error with invalid data', (done) => {
		socketAdmin.widgets.set({ uid: adminUid }, null, (err) => {
			assert.equal(err.message, '[[error:invalid-data]]');
			done();
		});
	});

	it('should error with invalid data', (done) => {
		const data = [{ template: 'global', location: 'sidebar', widgets: [{ widget: 'html', data: { html: 'test', title: 'test', container: '' } }] }];
		socketAdmin.widgets.set({ uid: adminUid }, data, (err) => {
			assert.ifError(err);
			db.getObjectField('widgets:global', 'sidebar', (err, widgetData) => {
				assert.ifError(err);

				assert.equal(JSON.parse(widgetData)[0].data.html, 'test');
				done();
			});
		});
	});

	it('should clear sitemap cache', (done) => {
		socketAdmin.settings.clearSitemapCache({ uid: adminUid }, {}, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should send test email', (done) => {
		socketAdmin.email.test({ uid: adminUid }, { template: 'digest.tpl' }, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should get logs', (done) => {
		const fs = require('fs');
		const path = require('path');
		meta.logs.path = path.join(nconf.get('base_dir'), 'test/files', 'output.log');
		fs.appendFile(meta.logs.path, 'some logs', (err) => {
			assert.ifError(err);

			socketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {
				assert.ifError(err);
				assert(data);
				done();
			});
		});
	});

	it('should clear logs', (done) => {
		socketAdmin.logs.clear({ uid: adminUid }, {}, (err) => {
			assert.ifError(err);
			socketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {
				assert.ifError(err);
				assert.equal(data.length, 0);
				done();
			});
		});
	});

	it('should clear errors', (done) => {
		socketAdmin.errors.clear({ uid: adminUid }, {}, (err) => {
			assert.ifError(err);
			db.exists('error:404', (err, exists) => {
				assert.ifError(err);
				assert(!exists);
				done();
			});
		});
	});

	it('should delete a single event', (done) => {
		db.getSortedSetRevRange('events:time', 0, 0, (err, eids) => {
			assert.ifError(err);
			events.deleteEvents(eids, (err) => {
				assert.ifError(err);
				db.isSortedSetMembers('events:time', eids, (err, isMembers) => {
					assert.ifError(err);
					assert(!isMembers.includes(true));
					done();
				});
			});
		});
	});

	it('should delete all events', (done) => {
		events.deleteAll((err) => {
			assert.ifError(err);
			db.sortedSetCard('events:time', (err, count) => {
				assert.ifError(err);
				assert.equal(count, 0);
				done();
			});
		});
	});

	describe('logger', () => {
		const logger = require('../src/logger');
		const index = require('../src/socket.io');
		const fs = require('fs');
		const path = require('path');

		it('should enable logging', (done) => {
			meta.config.loggerStatus = 1;
			meta.config.loggerIOStatus = 1;
			const loggerPath = path.join(__dirname, '..', 'logs', 'logger.log');
			logger.monitorConfig({ io: index.server }, { key: 'loggerPath', value: loggerPath });
			setTimeout(() => {
				io.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {
					assert.ifError(err);
					fs.readFile(loggerPath, 'utf-8', (err, content) => {
						assert.ifError(err);
						assert(content);
						done();
					});
				});
			}, 500);
		});

		after((done) => {
			meta.config.loggerStatus = 0;
			meta.config.loggerIOStatus = 0;
			done();
		});
	});

	describe('password reset', () => {
		const socketUser = require('../src/socket.io/user');

		it('should not error on valid email', (done) => {
			socketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {
				assert.ifError(err);

				async.parallel({
					count: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),
					event: async.apply(events.getEvents, '', 0, 0),
				}, (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.count, 1);

					// Event validity
					assert.strictEqual(data.event.length, 1);
					const event = data.event[0];
					assert.strictEqual(event.type, 'password-reset');
					assert.strictEqual(event.text, '[[success:success]]');

					done();
				});
			});
		});

		it('should not generate code if rate limited', (done) => {
			socketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {
				assert.ifError(err);

				async.parallel({
					count: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),
					event: async.apply(events.getEvents, '', 0, 0),
				}, (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.count, 1);	// should still equal 1

					// Event validity
					assert.strictEqual(data.event.length, 1);
					const event = data.event[0];
					assert.strictEqual(event.type, 'password-reset');
					assert.strictEqual(event.text, '[[error:reset-rate-limited]]');

					done();
				});
			});
		});

		it('should not error on invalid email (but not generate reset code)', (done) => {
			socketUser.reset.send({ uid: 0 }, 'irregular@test.com', (err) => {
				assert.ifError(err);

				db.sortedSetCount('reset:issueDate', 0, Date.now(), (err, count) => {
					assert.ifError(err);
					assert.strictEqual(count, 1);
					done();
				});
			});
		});

		it('should error on no email', (done) => {
			socketUser.reset.send({ uid: 0 }, '', (err) => {
				assert(err instanceof Error);
				assert.strictEqual(err.message, '[[error:invalid-data]]');
				done();
			});
'use strict';

const assert = require('assert');

const db = require('./mocks/databasemock');
const upgrade = require('../src/upgrade');

describe('Upgrade', () => {
	it('should get all upgrade scripts', async () => {
		const files = await upgrade.getAll();
		assert(Array.isArray(files) && files.length > 0);
	});

	it('should throw error', async () => {
		let err;
		try {
			await upgrade.check();
		} catch (_err) {
			err = _err;
		}
		assert.equal(err.message, 'schema-out-of-date');
	});

	it('should run all upgrades', async () => {
		// for upgrade scripts to run
'use strict';


const	assert = require('assert');
const path = require('path');
const nconf = require('nconf');
const request = require('request');
const fs = require('fs');

const db = require('./mocks/databasemock');
const plugins = require('../src/plugins');

describe('Plugins', () => {
	it('should load plugin data', (done) => {
		const pluginId = 'nodebb-plugin-markdown';
		plugins.loadPlugin(path.join(nconf.get('base_dir'), `node_modules/${pluginId}`), (err) => {
			assert.ifError(err);
			assert(plugins.libraries[pluginId]);
			assert(plugins.loadedHooks['static:app.load']);

			done();
		});
	});

	it('should return true if hook has listeners', (done) => {
		assert(plugins.hooks.hasListeners('filter:parse.post'));
		done();
	});

	it('should register and fire a filter hook', (done) => {
		function filterMethod1(data, callback) {
			data.foo += 1;
			callback(null, data);
		}
		function filterMethod2(data, callback) {
			data.foo += 5;
			callback(null, data);
		}

		plugins.hooks.register('test-plugin', { hook: 'filter:test.hook', method: filterMethod1 });
		plugins.hooks.register('test-plugin', { hook: 'filter:test.hook', method: filterMethod2 });

		plugins.hooks.fire('filter:test.hook', { foo: 1 }, (err, data) => {
			assert.ifError(err);
			assert.equal(data.foo, 7);
			done();
		});
	});

	it('should register and fire a filter hook having 2 methods, one returning a promise and the other calling the callback', (done) => {
		function method1(data, callback) {
			data.foo += 1;
			callback(null, data);
		}
		function method2(data) {
			return new Promise((resolve) => {
				data.foo += 5;
				resolve(data);
			});
		}

		plugins.hooks.register('test-plugin', { hook: 'filter:test.hook2', method: method1 });
		plugins.hooks.register('test-plugin', { hook: 'filter:test.hook2', method: method2 });

		plugins.hooks.fire('filter:test.hook2', { foo: 1 }, (err, data) => {
			assert.ifError(err);
			assert.equal(data.foo, 7);
			done();
		});
	});

	it('should register and fire a filter hook that returns a promise that gets rejected', (done) => {
		function method(data) {
			return new Promise((resolve, reject) => {
				data.foo += 5;
				reject(new Error('nope'));
			});
		}
		plugins.hooks.register('test-plugin', { hook: 'filter:test.hook3', method: method });
		plugins.hooks.fire('filter:test.hook3', { foo: 1 }, (err) => {
			assert(err);
			done();
		});
	});

	it('should register and fire an action hook', (done) => {
		function actionMethod(data) {
			assert.equal(data.bar, 'test');
			done();
		}

		plugins.hooks.register('test-plugin', { hook: 'action:test.hook', method: actionMethod });
		plugins.hooks.fire('action:test.hook', { bar: 'test' });
	});

	it('should register and fire a static hook', (done) => {
		function actionMethod(data, callback) {
			assert.equal(data.bar, 'test');
			callback();
		}

		plugins.hooks.register('test-plugin', { hook: 'static:test.hook', method: actionMethod });
		plugins.hooks.fire('static:test.hook', { bar: 'test' }, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should register and fire a static hook returning a promise', (done) => {
		function method(data) {
			assert.equal(data.bar, 'test');
			return new Promise((resolve) => {
				resolve();
			});
		}
		plugins.hooks.register('test-plugin', { hook: 'static:test.hook', method: method });
		plugins.hooks.fire('static:test.hook', { bar: 'test' }, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should register and fire a static hook returning a promise that gets rejected with a error', (done) => {
		function method(data) {
			assert.equal(data.bar, 'test');
			return new Promise((resolve, reject) => {
				reject(new Error('just because'));
			});
		}
		plugins.hooks.register('test-plugin', { hook: 'static:test.hook', method: method });
		plugins.hooks.fire('static:test.hook', { bar: 'test' }, (err) => {
			assert.strictEqual(err.message, 'just because');
			plugins.hooks.unregister('test-plugin', 'static:test.hook', method);
			done();
		});
	});

	it('should register and timeout a static hook returning a promise but takes too long', (done) => {
		function method(data) {
			assert.equal(data.bar, 'test');
			return new Promise((resolve) => {
				setTimeout(resolve, 6000);
			});
		}
		plugins.hooks.register('test-plugin', { hook: 'static:test.hook', method: method });
		plugins.hooks.fire('static:test.hook', { bar: 'test' }, (err) => {
			assert.ifError(err);
			plugins.hooks.unregister('test-plugin', 'static:test.hook', method);
			done();
		});
	});

	it('should get plugin data from nbbpm', (done) => {
		plugins.get('nodebb-plugin-markdown', (err, data) => {
			assert.ifError(err);
			const keys = ['id', 'name', 'url', 'description', 'latest', 'installed', 'active', 'latest'];
			assert.equal(data.name, 'nodebb-plugin-markdown');
			assert.equal(data.id, 'nodebb-plugin-markdown');
			keys.forEach((key) => {
				assert(data.hasOwnProperty(key));
			});
			done();
		});
	});

	it('should get a list of plugins', (done) => {
		plugins.list((err, data) => {
			assert.ifError(err);
			const keys = ['id', 'name', 'url', 'description', 'latest', 'installed', 'active', 'latest'];
			assert(Array.isArray(data));
			keys.forEach((key) => {
				assert(data[0].hasOwnProperty(key));
			});
			done();
		});
	});

	it('should show installed plugins', (done) => {
		const { nodeModulesPath } = plugins;
		plugins.nodeModulesPath = path.join(__dirname, './mocks/plugin_modules');

		plugins.showInstalled((err, pluginsData) => {
			assert.ifError(err);
			const paths = pluginsData.map(plugin => path.relative(plugins.nodeModulesPath, plugin.path).replace(/\\/g, '/'));
			assert(paths.indexOf('nodebb-plugin-xyz') > -1);
			assert(paths.indexOf('@nodebb/nodebb-plugin-abc') > -1);

			plugins.nodeModulesPath = nodeModulesPath;
			done();
		});
	});

	describe('install/activate/uninstall', () => {
		let latest;
		const pluginName = 'nodebb-plugin-imgur';
		it('should install a plugin', function (done) {
			this.timeout(0);
			plugins.toggleInstall(pluginName, '1.0.16', (err, pluginData) => {
				assert.ifError(err);
				latest = pluginData.latest;

				assert.equal(pluginData.name, pluginName);
				assert.equal(pluginData.id, pluginName);
				assert.equal(pluginData.url, 'https://github.com/barisusakli/nodebb-plugin-imgur#readme');
				assert.equal(pluginData.description, 'A Plugin that uploads images to imgur');
				assert.equal(pluginData.active, false);
				assert.equal(pluginData.installed, true);

				const packageFile = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
				assert(packageFile.dependencies[pluginName]);

				done();
			});
		});

		it('should activate plugin', (done) => {
			plugins.toggleActive(pluginName, (err) => {
				assert.ifError(err);
				plugins.isActive(pluginName, (err, isActive) => {
					assert.ifError(err);
					assert(isActive);
					done();
				});
			});
		});

		it('should upgrade plugin', function (done) {
			this.timeout(0);
			plugins.upgrade(pluginName, 'latest', (err, isActive) => {
				assert.ifError(err);
				assert(isActive);
				plugins.loadPluginInfo(path.join(nconf.get('base_dir'), 'node_modules', pluginName), (err, pluginInfo) => {
					assert.ifError(err);
					assert.equal(pluginInfo.version, latest);
					done();
				});
			});
		});

		it('should uninstall a plugin', function (done) {
			this.timeout(0);
			plugins.toggleInstall(pluginName, 'latest', (err, pluginData) => {
				assert.ifError(err);
				assert.equal(pluginData.installed, false);
				assert.equal(pluginData.active, false);

				const packageFile = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
				assert(!packageFile.dependencies[pluginName]);

				done();
			});
		});
	});

	describe('static assets', () => {
		it('should 404 if resource does not exist', (done) => {
			request.get(`${nconf.get('url')}/plugins/doesnotexist/should404.tpl`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				assert(body);
				done();
			});
		});

		it('should 404 if resource does not exist', (done) => {
			request.get(`${nconf.get('url')}/plugins/nodebb-plugin-dbsearch/dbsearch/templates/admin/plugins/should404.tpl`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				assert(body);
				done();
			});
		});

		it('should get resource', (done) => {
			request.get(`${nconf.get('url')}/plugins/nodebb-plugin-dbsearch/dbsearch/templates/admin/plugins/dbsearch.tpl`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
'use strict';

/**
 * Database Mock - wrapper for database.js, makes system use separate test db, instead of production
 * ATTENTION: testing db is flushed before every use!
 */

require('../../require-main');

const path = require('path');
const nconf = require('nconf');
const url = require('url');
const util = require('util');

process.env.NODE_ENV = process.env.TEST_ENV || 'production';
global.env = process.env.NODE_ENV || 'production';


const winston = require('winston');
const packageInfo = require('../../package');

winston.add(new winston.transports.Console({
	format: winston.format.combine(
		winston.format.splat(),
		winston.format.simple()
	),
}));

nconf.file({ file: path.join(__dirname, '../../config.json') });
nconf.defaults({
	base_dir: path.join(__dirname, '../..'),
	themes_path: path.join(__dirname, '../../node_modules'),
	upload_path: 'test/uploads',
	views_dir: path.join(__dirname, '../../build/public/templates'),
	relative_path: '',
});

const urlObject = url.parse(nconf.get('url'));
const relativePath = urlObject.pathname !== '/' ? urlObject.pathname : '';
nconf.set('relative_path', relativePath);
nconf.set('upload_path', path.join(nconf.get('base_dir'), nconf.get('upload_path')));
nconf.set('upload_url', '/assets/uploads');
nconf.set('url_parsed', urlObject);
nconf.set('base_url', `${urlObject.protocol}//${urlObject.host}`);
nconf.set('secure', urlObject.protocol === 'https:');
nconf.set('use_port', !!urlObject.port);
nconf.set('port', urlObject.port || nconf.get('port') || (nconf.get('PORT_ENV_VAR') ? nconf.get(nconf.get('PORT_ENV_VAR')) : false) || 4567);

// cookies don't provide isolation by port: http://stackoverflow.com/a/16328399/122353
const domain = nconf.get('cookieDomain') || urlObject.hostname;
const origins = nconf.get('socket.io:origins') || `${urlObject.protocol}//${domain}:*`;
nconf.set('socket.io:origins', origins);

if (nconf.get('isCluster') === undefined) {
	nconf.set('isPrimary', true);
	nconf.set('isCluster', false);
	nconf.set('singleHostCluster', false);
}

const dbType = nconf.get('database');
const testDbConfig = nconf.get('test_database');
const productionDbConfig = nconf.get(dbType);

if (!testDbConfig) {
	const errorText = 'test_database is not defined';
	winston.info(
		'\n===========================================================\n' +
		'Please, add parameters for test database in config.json\n' +
		'For example (redis):\n' +
		'"test_database": {\n' +
		'    "host": "127.0.0.1",\n' +
		'    "port": "6379",\n' +
		'    "password": "",\n' +
		'    "database": "1"\n' +
		'}\n' +
		' or (mongo):\n' +
		'"test_database": {\n' +
		'    "host": "127.0.0.1",\n' +
		'    "port": "27017",\n' +
		'    "password": "",\n' +
		'    "database": "1"\n' +
		'}\n' +
		' or (mongo) in a replicaset\n' +
		'"test_database": {\n' +
		'    "host": "127.0.0.1,127.0.0.1,127.0.0.1",\n' +
		'    "port": "27017,27018,27019",\n' +
		'    "username": "",\n' +
		'    "password": "",\n' +
		'    "database": "nodebb_test"\n' +
		'}\n' +
		' or (postgres):\n' +
		'"test_database": {\n' +
		'    "host": "127.0.0.1",\n' +
		'    "port": "5432",\n' +
		'    "username": "postgres",\n' +
		'    "password": "",\n' +
		'    "database": "nodebb_test"\n' +
		'}\n' +
		'==========================================================='
	);
	winston.error(errorText);
	throw new Error(errorText);
}

if (testDbConfig.database === productionDbConfig.database &&
	testDbConfig.host === productionDbConfig.host &&
	testDbConfig.port === productionDbConfig.port) {
	const errorText = 'test_database has the same config as production db';
	winston.error(errorText);
	throw new Error(errorText);
}

nconf.set(dbType, testDbConfig);

winston.info('database config %s', dbType, testDbConfig);
winston.info(`environment ${global.env}`);

const db = require('../../src/database');

module.exports = db;

before(async function () {
	this.timeout(30000);

	// Parse out the relative_url and other goodies from the configured URL
	const urlObject = url.parse(nconf.get('url'));

	nconf.set('core_templates_path', path.join(__dirname, '../../src/views'));
	nconf.set('base_templates_path', path.join(nconf.get('themes_path'), 'nodebb-theme-persona/templates'));
	nconf.set('theme_config', path.join(nconf.get('themes_path'), 'nodebb-theme-persona', 'theme.json'));
	nconf.set('bcrypt_rounds', 1);
	nconf.set('socket.io:origins', '*:*');
	nconf.set('version', packageInfo.version);
	nconf.set('runJobs', false);
	nconf.set('jobsDisabled', false);


	await db.init();
	if (db.hasOwnProperty('createIndices')) {
		await db.createIndices();
	}
	await setupMockDefaults();
	await db.initSessionStore();

	const meta = require('../../src/meta');
	nconf.set('theme_templates_path', meta.config['theme:templates'] ? path.join(nconf.get('themes_path'), meta.config['theme:id'], meta.config['theme:templates']) : nconf.get('base_templates_path'));
	// nconf defaults, if not set in config
	if (!nconf.get('sessionKey')) {
		nconf.set('sessionKey', 'express.sid');
	}

	await meta.dependencies.check();

	const webserver = require('../../src/webserver');
	const sockets = require('../../src/socket.io');
	await sockets.init(webserver.server);

	require('../../src/notifications').startJobs();
	require('../../src/user').startJobs();

	await webserver.listen();

	// Iterate over all of the test suites/contexts
	this.test.parent.suites.forEach((suite) => {
		// Attach an afterAll listener that resets the defaults
		suite.afterAll(async () => {
			await setupMockDefaults();
		});
	});
});

async function setupMockDefaults() {
	const meta = require('../../src/meta');
	await db.emptydb();

	require('../../src/groups').cache.reset();
	require('../../src/posts/cache').reset();
	require('../../src/cache').reset();

	winston.info('test_database flushed');
	await setupDefaultConfigs(meta);
	await giveDefaultGlobalPrivileges();
	await meta.configs.init();
	meta.config.postDelay = 0;
	meta.config.initialPostDelay = 0;
	meta.config.newbiePostDelay = 0;
	meta.config.autoDetectLang = 0;

	await enableDefaultPlugins();

	await meta.themes.set({
		type: 'local',
		id: 'nodebb-theme-persona',
	});

	const rimraf = util.promisify(require('rimraf'));
	await rimraf('test/uploads');

	const mkdirp = require('mkdirp');

	const folders = [
		'test/uploads',
		'test/uploads/category',
		'test/uploads/files',
		'test/uploads/system',
		'test/uploads/profile',
	];
	for (const folder of folders) {
		/* eslint-disable no-await-in-loop */
		await mkdirp(folder);
	}
}
db.setupMockDefaults = setupMockDefaults;

async function setupDefaultConfigs(meta) {
	winston.info('Populating database with default configs, if not already set...\n');

	const defaults = require(path.join(nconf.get('base_dir'), 'install/data/defaults.json'));
	defaults.eventLoopCheckEnabled = 0;
	defaults.minimumPasswordStrength = 0;
	await meta.configs.setOnEmpty(defaults);
}

async function giveDefaultGlobalPrivileges() {
	winston.info('Giving default global privileges...\n');
	const privileges = require('../../src/privileges');
	await privileges.global.give([
		'groups:chat', 'groups:upload:post:image', 'groups:signature', 'groups:search:content',
		'groups:search:users', 'groups:search:tags', 'groups:local:login', 'groups:view:users',
		'groups:view:tags', 'groups:view:groups',
	], 'registered-users');
	await privileges.global.give([
		'groups:view:users', 'groups:view:tags', 'groups:view:groups',
	], 'guests');
}

async function enableDefaultPlugins() {
	winston.info('Enabling default plugins\n');
	const testPlugins = Array.isArray(nconf.get('test_plugins')) ? nconf.get('test_plugins') : [];
	const defaultEnabled = [
		'nodebb-plugin-dbsearch',
		'nodebb-widget-essentials',
	].concat(testPlugins);

	winston.info('[install/enableDefaultPlugins] activating default plugins', defaultEnabled);
'use strict';

const nconf = require('nconf');
const assert = require('assert');

const db = require('./mocks/databasemock');
const helpers = require('../public/src/modules/helpers');

describe('helpers', () => {
	it('should return false if item doesn\'t exist', (done) => {
		const flag = helpers.displayMenuItem({ navigation: [] }, 0);
		assert(!flag);
		done();
	});

	it('should return false if route is /users and user does not have view:users privilege', (done) => {
		const flag = helpers.displayMenuItem({
			navigation: [{ route: '/users' }],
			user: {
				privileges: {
					'view:users': false,
				},
			},
		}, 0);
		assert(!flag);
		done();
	});

	it('should return false if route is /tags and user does not have view:tags privilege', (done) => {
		const flag = helpers.displayMenuItem({
			navigation: [{ route: '/tags' }],
			user: {
				privileges: {
					'view:tags': false,
				},
			},
		}, 0);
		assert(!flag);
		done();
	});

	it('should return false if route is /groups and user does not have view:groups privilege', (done) => {
		const flag = helpers.displayMenuItem({
			navigation: [{ route: '/groups' }],
			user: {
				privileges: {
					'view:groups': false,
				},
			},
		}, 0);
		assert(!flag);
		done();
	});

	it('should stringify object', (done) => {
		const str = helpers.stringify({ a: 'herp < derp > and & quote "' });
		assert.equal(str, '{&quot;a&quot;:&quot;herp &lt; derp &gt; and &amp; quote \\&quot;&quot;}');
		done();
	});

	it('should escape html', (done) => {
		const str = helpers.escape('gdkfhgk < some > and &');
		assert.equal(str, 'gdkfhgk &lt; some &gt; and &amp;');
		done();
	});

	it('should return empty string if category is falsy', (done) => {
		assert.equal(helpers.generateCategoryBackground(null), '');
		done();
	});

	it('should generate category background', (done) => {
		const category = {
			bgColor: '#ff0000',
			color: '#00ff00',
			backgroundImage: '/assets/uploads/image.png',
			imageClass: 'auto',
		};
		const bg = helpers.generateCategoryBackground(category);
		assert.equal(bg, 'background-color: #ff0000; color: #00ff00; background-image: url(/assets/uploads/image.png); background-size: auto;');
		done();
	});

	it('should return empty string if category has no children', (done) => {
		const category = {
			children: [],
		};
		const bg = helpers.generateChildrenCategories(category);
		assert.equal(bg, '');
		done();
	});

	it('should generate html for children', (done) => {
		const category = {
			children: [
				{
					link: '',
					bgColor: '#ff0000',
					color: '#00ff00',
					name: 'children',
				},
			],
		};
		const html = helpers.generateChildrenCategories(category);
		assert.equal(html, `<span class="category-children"><span class="category-children-item pull-left"><div role="presentation" class="icon pull-left" style="background-color: #ff0000; color: #00ff00;"><i class="fa fa-fw undefined"></i></div><a href="${nconf.get('relative_path')}/category/undefined"><small>children</small></a></span></span>`);
		done();
	});

	it('should generate topic class', (done) => {
		const className = helpers.generateTopicClass({ locked: true, pinned: true, deleted: true, unread: true });
		assert.equal(className, 'locked pinned deleted unread');
		done();
	});

	it('should show leave button if isMember and group is not administrators', (done) => {
		const btn = helpers.membershipBtn({ displayName: 'some group', name: 'some group', isMember: true });
		assert.equal(btn, '<button class="btn btn-danger" data-action="leave" data-group="some group"><i class="fa fa-times"></i> [[groups:membership.leave-group]]</button>');
		done();
	});

	it('should show pending button if isPending and group is not administrators', (done) => {
		const btn = helpers.membershipBtn({ displayName: 'some group', name: 'some group', isPending: true });
		assert.equal(btn, '<button class="btn btn-warning disabled"><i class="fa fa-clock-o"></i> [[groups:membership.invitation-pending]]</button>');
		done();
	});

	it('should show reject invite button if isInvited', (done) => {
		const btn = helpers.membershipBtn({ displayName: 'some group', name: 'some group', isInvited: true });
		assert.equal(btn, '<button class="btn btn-link" data-action="rejectInvite" data-group="some group">[[groups:membership.reject]]</button><button class="btn btn-success" data-action="acceptInvite" data-group="some group"><i class="fa fa-plus"></i> [[groups:membership.accept-invitation]]</button>');
		done();
	});

	it('should show join button if join requests are not disabled and group is not administrators', (done) => {
		const btn = helpers.membershipBtn({ displayName: 'some group', name: 'some group', disableJoinRequests: false });
		assert.equal(btn, '<button class="btn btn-success" data-action="join" data-group="some group"><i class="fa fa-plus"></i> [[groups:membership.join-group]]</button>');
		done();
	});

	it('should show nothing if group is administrators ', (done) => {
		const btn = helpers.membershipBtn({ displayName: 'administrators', name: 'administrators' });
		assert.equal(btn, '');
		done();
	});

	it('should spawn privilege states', (done) => {
		const privs = {
			find: true,
			read: true,
		};
		const html = helpers.spawnPrivilegeStates('guests', privs);
		assert.equal(html, '<td class="text-center" data-privilege="find" data-value="true"><input autocomplete="off" type="checkbox" checked /></td><td class="text-center" data-privilege="read" data-value="true"><input autocomplete="off" type="checkbox" checked /></td>');
		done();
	});

	it('should render thumb as topic image', (done) => {
		const topicObj = { thumb: '/uploads/1.png', user: { username: 'baris' } };
		const html = helpers.renderTopicImage(topicObj);
		assert.equal(html, `<img src="${topicObj.thumb}" class="img-circle user-img" title="${topicObj.user.username}" />`);
		done();
	});

	it('should render user picture as topic image', (done) => {
		const topicObj = { thumb: '', user: { uid: 1, username: 'baris', picture: '/uploads/2.png' } };
		const html = helpers.renderTopicImage(topicObj);
		assert.equal(html, `<img component="user/picture" data-uid="${topicObj.user.uid}" src="${topicObj.user.picture}" class="user-img" title="${topicObj.user.username}" />`);
		done();
	});

	it('should render digest avatar', (done) => {
		const block = { teaser: { user: { username: 'baris', picture: '/uploads/1.png' } } };
		const html = helpers.renderDigestAvatar(block);
		assert.equal(html, `<img style="vertical-align: middle; width: 32px; height: 32px; border-radius: 50%;" src="${block.teaser.user.picture}" title="${block.teaser.user.username}" />`);
		done();
	});

	it('should render digest avatar', (done) => {
		const block = { teaser: { user: { username: 'baris', 'icon:text': 'B', 'icon:bgColor': '#ff000' } } };
		const html = helpers.renderDigestAvatar(block);
		assert.equal(html, `<div style="vertical-align: middle; width: 32px; height: 32px; line-height: 32px; font-size: 16px; background-color: ${block.teaser.user['icon:bgColor']}; color: white; text-align: center; display: inline-block; border-radius: 50%;">${block.teaser.user['icon:text']}</div>`);
		done();
	});

	it('should render digest avatar', (done) => {
		const block = { user: { username: 'baris', picture: '/uploads/1.png' } };
		const html = helpers.renderDigestAvatar(block);
		assert.equal(html, `<img style="vertical-align: middle; width: 32px; height: 32px; border-radius: 50%;" src="${block.user.picture}" title="${block.user.username}" />`);
		done();
	});

	it('should render digest avatar', (done) => {
		const block = { user: { username: 'baris', 'icon:text': 'B', 'icon:bgColor': '#ff000' } };
		const html = helpers.renderDigestAvatar(block);
		assert.equal(html, `<div style="vertical-align: middle; width: 32px; height: 32px; line-height: 32px; font-size: 16px; background-color: ${block.user['icon:bgColor']}; color: white; text-align: center; display: inline-block; border-radius: 50%;">${block.user['icon:text']}</div>`);
		done();
	});

	it('shoud render user agent/browser icons', (done) => {
		const html = helpers.userAgentIcons({ platform: 'Linux', browser: 'Chrome' });
		assert.equal(html, '<i class="fa fa-fw fa-linux"></i><i class="fa fa-fw fa-chrome"></i>');
		done();
	});

	it('shoud render user agent/browser icons', (done) => {
		const html = helpers.userAgentIcons({ platform: 'Microsoft Windows', browser: 'Firefox' });
		assert.equal(html, '<i class="fa fa-fw fa-windows"></i><i class="fa fa-fw fa-firefox"></i>');
		done();
	});

	it('shoud render user agent/browser icons', (done) => {
		const html = helpers.userAgentIcons({ platform: 'Apple Mac', browser: 'Safari' });
		assert.equal(html, '<i class="fa fa-fw fa-apple"></i><i class="fa fa-fw fa-safari"></i>');
		done();
	});

	it('shoud render user agent/browser icons', (done) => {
		const html = helpers.userAgentIcons({ platform: 'Android', browser: 'IE' });
		assert.equal(html, '<i class="fa fa-fw fa-android"></i><i class="fa fa-fw fa-internet-explorer"></i>');
		done();
	});

	it('shoud render user agent/browser icons', (done) => {
		const html = helpers.userAgentIcons({ platform: 'iPad', browser: 'Edge' });
		assert.equal(html, '<i class="fa fa-fw fa-tablet"></i><i class="fa fa-fw fa-edge"></i>');
		done();
	});

	it('shoud render user agent/browser icons', (done) => {
		const html = helpers.userAgentIcons({ platform: 'iPhone', browser: 'unknow' });
		assert.equal(html, '<i class="fa fa-fw fa-mobile"></i><i class="fa fa-fw fa-question-circle"></i>');
		done();
	});

	it('shoud render user agent/browser icons', (done) => {
		const html = helpers.userAgentIcons({ platform: 'unknow', browser: 'unknown' });
		assert.equal(html, '<i class="fa fa-fw fa-question-circle"></i><i class="fa fa-fw fa-question-circle"></i>');
'use strict';

const winston = require('winston');
const Transport = require('winston-transport');

const winstonLogged = [];

class DeferLogger extends Transport {
	constructor(opts) {
		super(opts);
		this.logged = opts.logged;
	}

	log(info, callback) {
		setImmediate(() => {
			this.emit('logged', info);
		});

		this.logged.push([info.level, info.message]);
		callback();
	}
}

before(() => {
	// defer winston logs until the end
	winston.clear();

	winston.add(new DeferLogger({ logged: winstonLogged }));
});

after(() => {
	console.log('\n\n');

	winstonLogged.forEach((args) => {
		console.log(`${args[0]} ${args[1]}`);
'use strict';

const	assert = require('assert');
const nconf = require('nconf');
const request = require('request');

const db = require('./mocks/databasemock');
const meta = require('../src/meta');

describe('Language detection', () => {
	it('should detect the language for a guest', (done) => {
		meta.configs.set('autoDetectLang', 1, (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/api/config`, {
				headers: {
					'Accept-Language': 'de-DE,de;q=0.5',
				},
				json: true,
			}, (err, res, body) => {
				assert.ifError(err);
				assert.ok(body);

				assert.strictEqual(body.userLang, 'de');
				done();
			});
		});
	});

	it('should do nothing when disabled', (done) => {
		meta.configs.set('autoDetectLang', 0, (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/api/config`, {
				headers: {
					'Accept-Language': 'de-DE,de;q=0.5',
				},
				json: true,
			}, (err, res, body) => {
				assert.ifError(err);
				assert.ok(body);

				assert.strictEqual(body.userLang, 'en-GB');
				done();
			});
		});
	});
'use strict';

const assert = require('assert');
const bcrypt = require('bcryptjs');

const password = require('../src/password');

describe('Password', () => {
	describe('.hash()', () => {
		it('should return a password hash when called', async () => {
			const hash = await password.hash(12, 'test');
			assert(hash.startsWith('$2a$'));
		});
	});

	describe('.compare()', async () => {
		const salt = await bcrypt.genSalt(12);

		it('should correctly compare a password and a hash', async () => {
			const hash = await password.hash(12, 'test');
			const match = await password.compare('test', hash, true);
			assert(match);
		});

		it('should correctly handle comparison with no sha wrapping of the input (backwards compatibility)', async () => {
			const hash = await bcrypt.hash('test', salt);
			const match = await password.compare('test', hash, false);
			assert(match);
		});

		it('should continue to function even with passwords > 73 characters', async () => {
			const arr = [];
			arr.length = 100;
			const hash = await password.hash(12, arr.join('a'));

			arr.length = 150;
			const match = await password.compare(arr.join('a'), hash, true);
			assert.strictEqual(match, false);
		});

		it('should process a million-character long password quickly', async () => {
			// ... because sha512 reduces it to a constant size
			const arr = [];
			const start = Date.now();
			arr.length = 1000000;
			await password.hash(12, arr.join('a'));
			const end = Date.now();

			assert(end - start < 5000);
		});
'use strict';

const async = require('async');
const assert = require('assert');
const nconf = require('nconf');
const request = require('request');
const fs = require('fs');
const path = require('path');

const db = require('./mocks/databasemock');
const categories = require('../src/categories');
const topics = require('../src/topics');
const posts = require('../src/posts');
const user = require('../src/user');
const groups = require('../src/groups');
const meta = require('../src/meta');
const translator = require('../src/translator');
const privileges = require('../src/privileges');
const plugins = require('../src/plugins');
const utils = require('../src/utils');
const helpers = require('./helpers');

describe('Controllers', () => {
	let tid;
	let cid;
	let pid;
	let fooUid;
	let category;

	before((done) => {
		async.series({
			category: function (next) {
				categories.create({
					name: 'Test Category',
					description: 'Test category created by testing script',
				}, next);
			},
			user: function (next) {
				user.create({ username: 'foo', password: 'barbar', email: 'foo@test.com' }, next);
			},
			navigation: function (next) {
				const navigation = require('../src/navigation/admin');
				const data = require('../install/data/navigation.json');

				navigation.save(data, next);
			},
		}, (err, results) => {
			if (err) {
				return done(err);
			}
			category = results.category;
			cid = results.category.cid;
			fooUid = results.user;

			topics.post({ uid: results.user, title: 'test topic title', content: 'test topic content', cid: results.category.cid }, (err, result) => {
				tid = result.topicData.tid;
				pid = result.postData.pid;
				done(err);
			});
		});
	});

	it('should load /config with csrf_token', (done) => {
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
		}, (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 200);
			assert(body.csrf_token);
			done();
		});
	});

	it('should load /config with no csrf_token as spider', (done) => {
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			headers: {
				'user-agent': 'yandex',
			},
		}, (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 200);
			assert.strictEqual(body.csrf_token, false);
			assert.strictEqual(body.uid, -1);
			assert.strictEqual(body.loggedIn, false);
			done();
		});
	});

	describe('homepage', () => {
		function hookMethod(hookData) {
			assert(hookData.req);
			assert(hookData.res);
			assert(hookData.next);

			hookData.res.render('mycustompage', {
				works: true,
			});
		}
		const message = utils.generateUUID();
		const name = 'mycustompage.tpl';
		const tplPath = path.join(nconf.get('views_dir'), name);

		before(async () => {
			plugins.hooks.register('myTestPlugin', {
				hook: 'action:homepage.get:mycustompage',
				method: hookMethod,
			});

			fs.writeFileSync(tplPath, message);
			await meta.templates.compileTemplate(name, message);
		});

		it('should load default', (done) => {
			request(nconf.get('url'), (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load unread', (done) => {
			meta.configs.set('homePageRoute', 'unread', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			});
		});

		it('should load recent', (done) => {
			meta.configs.set('homePageRoute', 'recent', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			});
		});

		it('should load top', (done) => {
			meta.configs.set('homePageRoute', 'top', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			});
		});

		it('should load popular', (done) => {
			meta.configs.set('homePageRoute', 'popular', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			});
		});

		it('should load category', (done) => {
			meta.configs.set('homePageRoute', 'category/1/test-category', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			});
		});

		it('should not load breadcrumbs on home page route', (done) => {
			request(`${nconf.get('url')}/api`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				assert(!body.breadcrumbs);
				done();
			});
		});

		it('should redirect to custom', (done) => {
			meta.configs.set('homePageRoute', 'groups', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			});
		});

		it('should 404 if custom does not exist', (done) => {
			meta.configs.set('homePageRoute', 'this-route-does-not-exist', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 404);
					assert(body);
					done();
				});
			});
		});

		it('api should work with hook', (done) => {
			meta.configs.set('homePageRoute', 'mycustompage', (err) => {
				assert.ifError(err);

				request(`${nconf.get('url')}/api`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert.equal(body.works, true);
					assert.equal(body.template.mycustompage, true);

					done();
				});
			});
		});

		it('should render with hook', (done) => {
			meta.configs.set('homePageRoute', 'mycustompage', (err) => {
				assert.ifError(err);

				request(nconf.get('url'), (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert.ok(body);
					assert.ok(body.indexOf('<main id="panel"'));
					assert.ok(body.includes(message));

					done();
				});
			});
		});

		after(() => {
			plugins.hooks.unregister('myTestPlugin', 'action:homepage.get:custom', hookMethod);
			fs.unlinkSync(tplPath);
			fs.unlinkSync(tplPath.replace(/\.tpl$/, '.js'));
		});
	});

	it('should load /reset without code', (done) => {
		request(`${nconf.get('url')}/reset`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /reset with invalid code', (done) => {
		request(`${nconf.get('url')}/reset/123123`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /login', (done) => {
		request(`${nconf.get('url')}/login`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /register', (done) => {
		request(`${nconf.get('url')}/register`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /register/complete', (done) => {
		function hookMethod(data, next) {
			data.interstitials.push({ template: 'topic.tpl', data: {} });
			next(null, data);
		}

		plugins.hooks.register('myTestPlugin', {
			hook: 'filter:register.interstitial',
			method: hookMethod,
		});

		const data = {
			username: 'interstitial',
			password: '123456',
			'password-confirm': '123456',
			email: 'test@me.com',
		};

		const jar = request.jar();
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			jar: jar,
		}, (err, response, body) => {
			assert.ifError(err);

			request.post(`${nconf.get('url')}/register`, {
				form: data,
				json: true,
				jar: jar,
				headers: {
					'x-csrf-token': body.csrf_token,
				},
			}, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.strictEqual(body.next, `${nconf.get('relative_path')}/register/complete`);
				request(`${nconf.get('url')}/api/register/complete`, {
					jar: jar,
					json: true,
				}, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body.sections);
					assert(body.errors);
					assert(body.title);
					plugins.hooks.unregister('myTestPlugin', 'filter:register.interstitial', hookMethod);
					done();
				});
			});
		});
	});

	it('should load /robots.txt', (done) => {
		request(`${nconf.get('url')}/robots.txt`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /manifest.webmanifest', (done) => {
		request(`${nconf.get('url')}/manifest.webmanifest`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /outgoing?url=<url>', (done) => {
		request(`${nconf.get('url')}/outgoing?url=http://youtube.com`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should 404 on /outgoing with no url', (done) => {
		request(`${nconf.get('url')}/outgoing`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			assert(body);
			done();
		});
	});

	it('should 404 on /outgoing with javascript: protocol', (done) => {
		request(`${nconf.get('url')}/outgoing?url=javascript:alert(1);`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			assert(body);
			done();
		});
	});

	it('should 404 on /outgoing with invalid url', (done) => {
		request(`${nconf.get('url')}/outgoing?url=derp`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			assert(body);
			done();
		});
	});

	it('should load /tos', (done) => {
		meta.config.termsOfUse = 'please accept our tos';
		request(`${nconf.get('url')}/tos`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});


	it('should load 404 if meta.config.termsOfUse is empty', (done) => {
		meta.config.termsOfUse = '';
		request(`${nconf.get('url')}/tos`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			assert(body);
			done();
		});
	});

	it('should load /sping', (done) => {
		request(`${nconf.get('url')}/sping`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert.equal(body, 'healthy');
			done();
		});
	});

	it('should load /ping', (done) => {
		request(`${nconf.get('url')}/ping`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert.equal(body, '200');
			done();
		});
	});

	it('should handle 404', (done) => {
		request(`${nconf.get('url')}/arouteinthevoid`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			assert(body);
			done();
		});
	});

	it('should load topic rss feed', (done) => {
		request(`${nconf.get('url')}/topic/${tid}.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load category rss feed', (done) => {
		request(`${nconf.get('url')}/category/${cid}.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load topics rss feed', (done) => {
		request(`${nconf.get('url')}/topics.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load recent rss feed', (done) => {
		request(`${nconf.get('url')}/recent.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load top rss feed', (done) => {
		request(`${nconf.get('url')}/top.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load popular rss feed', (done) => {
		request(`${nconf.get('url')}/popular.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load popular rss feed with term', (done) => {
		request(`${nconf.get('url')}/popular/day.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load recent posts rss feed', (done) => {
		request(`${nconf.get('url')}/recentposts.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load category recent posts rss feed', (done) => {
		request(`${nconf.get('url')}/category/${cid}/recentposts.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load user topics rss feed', (done) => {
		request(`${nconf.get('url')}/user/foo/topics.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load tag rss feed', (done) => {
		request(`${nconf.get('url')}/tags/nodebb.rss`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load client.css', (done) => {
		request(`${nconf.get('url')}/assets/client.css`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load admin.css', (done) => {
		request(`${nconf.get('url')}/assets/admin.css`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});


	it('should load nodebb.min.js', (done) => {
		request(`${nconf.get('url')}/assets/nodebb.min.js`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load acp.min.js', (done) => {
		request(`${nconf.get('url')}/assets/acp.min.js`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load sitemap.xml', (done) => {
		request(`${nconf.get('url')}/sitemap.xml`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load sitemap/pages.xml', (done) => {
		request(`${nconf.get('url')}/sitemap/pages.xml`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load sitemap/categories.xml', (done) => {
		request(`${nconf.get('url')}/sitemap/categories.xml`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load sitemap/topics/1.xml', (done) => {
		request(`${nconf.get('url')}/sitemap/topics.1.xml`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load robots.txt', (done) => {
		request(`${nconf.get('url')}/robots.txt`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load theme screenshot', (done) => {
		request(`${nconf.get('url')}/css/previews/nodebb-theme-persona`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load users page', (done) => {
		request(`${nconf.get('url')}/users`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load users page', (done) => {
		request(`${nconf.get('url')}/users?section=online`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should error if guests do not have search privilege', (done) => {
		request(`${nconf.get('url')}/api/users?query=bar&section=sort-posts`, { json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 500);
			assert(body);
			assert.equal(body.error, '[[error:no-privileges]]');
			done();
		});
	});

	it('should load users search page', (done) => {
		privileges.global.give(['groups:search:users'], 'guests', (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/users?query=bar&section=sort-posts`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				privileges.global.rescind(['groups:search:users'], 'guests', done);
			});
		});
	});

	it('should load groups page', (done) => {
		request(`${nconf.get('url')}/groups`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load group details page', (done) => {
		groups.create({
			name: 'group-details',
			description: 'Foobar!',
			hidden: 0,
		}, (err) => {
			assert.ifError(err);
			groups.join('group-details', fooUid, (err) => {
				assert.ifError(err);
				topics.post({
					uid: fooUid,
					title: 'topic title',
					content: 'test topic content',
					cid: cid,
				}, (err) => {
					assert.ifError(err);
					request(`${nconf.get('url')}/api/groups/group-details`, { json: true }, (err, res, body) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 200);
						assert(body);
						assert.equal(body.posts[0].content, 'test topic content');
						done();
					});
				});
			});
		});
	});

	it('should load group members page', (done) => {
		request(`${nconf.get('url')}/groups/group-details/members`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should 404 when trying to load group members of hidden group', (done) => {
		const groups = require('../src/groups');
		groups.create({
			name: 'hidden-group',
			description: 'Foobar!',
			hidden: 1,
		}, (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/groups/hidden-group/members`, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});
	});

	it('should get recent posts', (done) => {
		request(`${nconf.get('url')}/api/recent/posts/month`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should get post data', (done) => {
		request(`${nconf.get('url')}/api/v3/posts/${pid}`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should get topic data', (done) => {
		request(`${nconf.get('url')}/api/v3/topics/${tid}`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should get category data', (done) => {
		request(`${nconf.get('url')}/api/v3/categories/${cid}`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});


	describe('revoke session', () => {
		let uid;
		let jar;
		let csrf_token;

		before((done) => {
			user.create({ username: 'revokeme', password: 'barbar' }, (err, _uid) => {
				assert.ifError(err);
				uid = _uid;
				helpers.loginUser('revokeme', 'barbar', (err, _jar, _csrf_token) => {
					assert.ifError(err);
					jar = _jar;
					csrf_token = _csrf_token;
					done();
				});
			});
		});

		it('should fail to revoke session with missing uuid', (done) => {
			request.del(`${nconf.get('url')}/api/user/revokeme/session`, {
				jar: jar,
				headers: {
					'x-csrf-token': csrf_token,
				},
			}, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should fail if user doesn\'t exist', (done) => {
			request.del(`${nconf.get('url')}/api/v3/users/doesnotexist/sessions/1112233`, {
				jar: jar,
				headers: {
					'x-csrf-token': csrf_token,
				},
			}, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 404);
				const parsedResponse = JSON.parse(body);
				assert.deepStrictEqual(parsedResponse.response, {});
				assert.deepStrictEqual(parsedResponse.status, {
					code: 'not-found',
					message: '[[error:no-user]]',
				});
				done();
			});
		});

		it('should revoke user session', (done) => {
			db.getSortedSetRange(`uid:${uid}:sessions`, 0, -1, (err, sids) => {
				assert.ifError(err);
				const sid = sids[0];

				db.sessionStore.get(sid, (err, sessionObj) => {
					assert.ifError(err);
					request.del(`${nconf.get('url')}/api/v3/users/${uid}/sessions/${sessionObj.meta.uuid}`, {
						jar: jar,
						headers: {
							'x-csrf-token': csrf_token,
						},
					}, (err, res, body) => {
						assert.ifError(err);
						assert.strictEqual(res.statusCode, 200);
						assert.deepStrictEqual(JSON.parse(body), {
							status: {
								code: 'ok',
								message: 'OK',
							},
							response: {},
						});
						done();
					});
				});
			});
		});
	});

	describe('widgets', () => {
		const widgets = require('../src/widgets');

		before((done) => {
			async.waterfall([
				function (next) {
					widgets.reset(next);
				},
				function (next) {
					const data = {
						template: 'categories.tpl',
						location: 'sidebar',
						widgets: [
							{
								widget: 'html',
								data: {
									html: 'test',
									title: '',
									container: '',
								},
							},
						],
					};

					widgets.setArea(data, next);
				},
			], done);
		});

		it('should return {} if there are no widgets', (done) => {
			request(`${nconf.get('url')}/api/category/${cid}`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.widgets);
				assert.equal(Object.keys(body.widgets).length, 0);
				done();
			});
		});

		it('should render templates', (done) => {
			const url = `${nconf.get('url')}/api/categories`;
			request(url, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.widgets);
				assert(body.widgets.sidebar);
				assert.equal(body.widgets.sidebar[0].html, 'test');
				done();
			});
		});

		it('should reset templates', (done) => {
			widgets.resetTemplates(['categories', 'category'], (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/categories`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body.widgets);
					assert.equal(Object.keys(body.widgets).length, 0);
					done();
				});
			});
		});
	});

	describe('tags', () => {
		let tid;
		before((done) => {
			topics.post({
				uid: fooUid,
				title: 'topic title',
				content: 'test topic content',
				cid: cid,
				tags: ['nodebb', 'bug', 'test'],
			}, (err, result) => {
				assert.ifError(err);
				tid = result.topicData.tid;
				done();
			});
		});

		it('should render tags page', (done) => {
			request(`${nconf.get('url')}/api/tags`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				assert(Array.isArray(body.tags));
				done();
			});
		});

		it('should render tag page with no topics', (done) => {
			request(`${nconf.get('url')}/api/tags/notag`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				assert(Array.isArray(body.topics));
				assert.equal(body.topics.length, 0);
				done();
			});
		});

		it('should render tag page with 1 topic', (done) => {
			request(`${nconf.get('url')}/api/tags/nodebb`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				assert(Array.isArray(body.topics));
				assert.equal(body.topics.length, 1);
				done();
			});
		});
	});


	describe('maintenance mode', () => {
		before((done) => {
			meta.config.maintenanceMode = 1;
			done();
		});
		after((done) => {
			meta.config.maintenanceMode = 0;
			done();
		});

		it('should return 503 in maintenance mode', (done) => {
			request(`${nconf.get('url')}/recent`, { json: true }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 503);
				done();
			});
		});

		it('should return 503 in maintenance mode', (done) => {
			request(`${nconf.get('url')}/api/recent`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 503);
				assert(body);
				done();
			});
		});

		it('should return 200 in maintenance mode', (done) => {
			request(`${nconf.get('url')}/api/login`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});
	});

	describe('account pages', () => {
		let jar;
		before((done) => {
			helpers.loginUser('foo', 'barbar', (err, _jar) => {
				assert.ifError(err);
				jar = _jar;
				done();
			});
		});

		it('should redirect to account page with logged in user', (done) => {
			request(`${nconf.get('url')}/api/login`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(res.headers['x-redirect'], '/user/foo');
				assert.equal(body, '/user/foo');
				done();
			});
		});

		it('should 404 if uid is not a number', (done) => {
			request(`${nconf.get('url')}/api/uid/test`, { json: true }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should redirect to userslug', (done) => {
			request(`${nconf.get('url')}/api/uid/${fooUid}`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(res.headers['x-redirect'], '/user/foo');
				assert.equal(body, '/user/foo');
				done();
			});
		});

		it('should 404 if user does not exist', (done) => {
			request(`${nconf.get('url')}/api/uid/123123`, { json: true }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		describe('/me/*', () => {
			it('should redirect to user profile', (done) => {
				request(`${nconf.get('url')}/me`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body.includes('"template":{"name":"account/profile","account/profile":true}'));
					assert(body.includes('"username":"foo"'));
					done();
				});
			});
			it('api should redirect to /user/[userslug]/bookmarks', (done) => {
				request(`${nconf.get('url')}/api/me/bookmarks`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert.equal(res.headers['x-redirect'], '/user/foo/bookmarks');
					assert.equal(body, '/user/foo/bookmarks');
					done();
				});
			});
			it('api should redirect to /user/[userslug]/edit/username', (done) => {
				request(`${nconf.get('url')}/api/me/edit/username`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert.equal(res.headers['x-redirect'], '/user/foo/edit/username');
					assert.equal(body, '/user/foo/edit/username');
					done();
				});
			});
			it('should redirect to login if user is not logged in', (done) => {
				request(`${nconf.get('url')}/me/bookmarks`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body.includes('Login to your account'), body.substr(0, 500));
					done();
				});
			});
		});

		it('should 401 if user is not logged in', (done) => {
			request(`${nconf.get('url')}/api/admin`, { json: true }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 401);
				done();
			});
		});

		it('should 403 if user is not admin', (done) => {
			request(`${nconf.get('url')}/api/admin`, { jar: jar, json: true }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 403);
				done();
			});
		});

		it('should load /user/foo/posts', (done) => {
			request(`${nconf.get('url')}/api/user/foo/posts`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should 401 if not logged in', (done) => {
			request(`${nconf.get('url')}/api/user/foo/bookmarks`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 401);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/bookmarks', (done) => {
			request(`${nconf.get('url')}/api/user/foo/bookmarks`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/upvoted', (done) => {
			request(`${nconf.get('url')}/api/user/foo/upvoted`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/downvoted', (done) => {
			request(`${nconf.get('url')}/api/user/foo/downvoted`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/best', (done) => {
			request(`${nconf.get('url')}/api/user/foo/best`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/watched', (done) => {
			request(`${nconf.get('url')}/api/user/foo/watched`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/ignored', (done) => {
			request(`${nconf.get('url')}/api/user/foo/ignored`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/topics', (done) => {
			request(`${nconf.get('url')}/api/user/foo/topics`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/blocks', (done) => {
			request(`${nconf.get('url')}/api/user/foo/blocks`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/consent', (done) => {
			request(`${nconf.get('url')}/api/user/foo/consent`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/sessions', (done) => {
			request(`${nconf.get('url')}/api/user/foo/sessions`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/categories', (done) => {
			request(`${nconf.get('url')}/api/user/foo/categories`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load /user/foo/uploads', (done) => {
			request(`${nconf.get('url')}/api/user/foo/uploads`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should export users posts', (done) => {
			request(`${nconf.get('url')}/api/user/uid/foo/export/posts`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should export users uploads', (done) => {
			request(`${nconf.get('url')}/api/user/uid/foo/export/uploads`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should export users profile', (done) => {
			request(`${nconf.get('url')}/api/user/uid/foo/export/profile`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load notifications page', (done) => {
			const notifications = require('../src/notifications');
			const notifData = {
				bodyShort: '[[notifications:user_posted_to, test1, test2]]',
				bodyLong: 'some post content',
				pid: 1,
				path: `/post/${1}`,
				nid: `new_post:tid:${1}:pid:${1}:uid:${fooUid}`,
				tid: 1,
				from: fooUid,
				mergeId: `notifications:user_posted_to|${1}`,
				topicTitle: 'topic title',
			};
			async.waterfall([
				function (next) {
					notifications.create(notifData, next);
				},
				function (notification, next) {
					notifications.push(notification, fooUid, next);
				},
				function (next) {
					setTimeout(next, 2500);
				},
				function (next) {
					request(`${nconf.get('url')}/api/notifications`, { jar: jar, json: true }, next);
				},
				function (res, body, next) {
					assert.equal(res.statusCode, 200);
					assert(body);
					const notif = body.notifications[0];
					assert.equal(notif.bodyShort, notifData.bodyShort);
					assert.equal(notif.bodyLong, notifData.bodyLong);
					assert.equal(notif.pid, notifData.pid);
					assert.equal(notif.path, nconf.get('relative_path') + notifData.path);
					assert.equal(notif.nid, notifData.nid);
					next();
				},
			], done);
		});

		it('should 404 if user does not exist', (done) => {
			request(`${nconf.get('url')}/api/user/email/doesnotexist`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				assert(body);
				done();
			});
		});

		it('should load user by uid', (done) => {
			request(`${nconf.get('url')}/api/user/uid/${fooUid}`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load user by username', (done) => {
			request(`${nconf.get('url')}/api/user/username/foo`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load user by email', (done) => {
			request(`${nconf.get('url')}/api/user/email/foo@test.com`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should return 401 if user does not have view:users privilege', (done) => {
			privileges.global.rescind(['groups:view:users'], 'guests', (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 401);
					assert.deepEqual(body, {
						response: {},
						status: {
							code: 'not-authorised',
							message: 'A valid login session was not found. Please log in and try again.',
						},
					});
					privileges.global.give(['groups:view:users'], 'guests', done);
				});
			});
		});

		it('should return false if user can not edit user', (done) => {
			user.create({ username: 'regularJoe', password: 'barbar' }, (err) => {
				assert.ifError(err);
				helpers.loginUser('regularJoe', 'barbar', (err, jar) => {
					assert.ifError(err);
					request(`${nconf.get('url')}/api/user/foo/info`, { jar: jar, json: true }, (err, res) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 403);
						request(`${nconf.get('url')}/api/user/foo/edit`, { jar: jar, json: true }, (err, res) => {
							assert.ifError(err);
							assert.equal(res.statusCode, 403);
							done();
						});
					});
				});
			});
		});

		it('should load correct user', (done) => {
			request(`${nconf.get('url')}/api/user/FOO`, { jar: jar, json: true }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				done();
			});
		});

		it('should redirect', (done) => {
			request(`${nconf.get('url')}/user/FOO`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should 404 if user does not exist', (done) => {
			request(`${nconf.get('url')}/api/user/doesnotexist`, { jar: jar }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should not increase profile view if you visit your own profile', (done) => {
			request(`${nconf.get('url')}/api/user/foo`, { jar: jar }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				setTimeout(() => {
					user.getUserField(fooUid, 'profileviews', (err, viewcount) => {
						assert.ifError(err);
						assert(viewcount === 0);
						done();
					});
				}, 500);
			});
		});

		it('should not increase profile view if a guest visits a profile', (done) => {
			request(`${nconf.get('url')}/api/user/foo`, {}, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				setTimeout(() => {
					user.getUserField(fooUid, 'profileviews', (err, viewcount) => {
						assert.ifError(err);
						assert(viewcount === 0);
						done();
					});
				}, 500);
			});
		});

		it('should increase profile view', (done) => {
			helpers.loginUser('regularJoe', 'barbar', (err, jar) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/user/foo`, { jar: jar }, (err, res) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					setTimeout(() => {
						user.getUserField(fooUid, 'profileviews', (err, viewcount) => {
							assert.ifError(err);
							assert(viewcount > 0);
							done();
						});
					}, 500);
				});
			});
		});

		it('should parse about me', (done) => {
			user.setUserFields(fooUid, { picture: '/path/to/picture', aboutme: 'hi i am a bot' }, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert.equal(body.aboutme, 'hi i am a bot');
					assert.equal(body.picture, '/path/to/picture');
					done();
				});
			});
		});

		it('should not return reputation if reputation is disabled', (done) => {
			meta.config['reputation:disabled'] = 1;
			request(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {
				meta.config['reputation:disabled'] = 0;
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(!body.hasOwnProperty('reputation'));
				done();
			});
		});

		it('should only return posts that are not deleted', (done) => {
			let topicData;
			let pidToDelete;
			async.waterfall([
				function (next) {
					topics.post({ uid: fooUid, title: 'visible', content: 'some content', cid: cid }, next);
				},
				function (data, next) {
					topicData = data.topicData;
					topics.reply({ uid: fooUid, content: '1st reply', tid: topicData.tid }, next);
				},
				function (postData, next) {
					pidToDelete = postData.pid;
					topics.reply({ uid: fooUid, content: '2nd reply', tid: topicData.tid }, next);
				},
				function (postData, next) {
					posts.delete(pidToDelete, fooUid, next);
				},
				function (next) {
					request(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 200);
						const contents = body.posts.map(p => p.content);
						assert(!contents.includes('1st reply'));
						done();
					});
				},
			], done);
		});

		it('should return selected group title', (done) => {
			groups.create({
				name: 'selectedGroup',
			}, (err) => {
				assert.ifError(err);
				user.create({ username: 'groupie' }, (err, uid) => {
					assert.ifError(err);
					groups.join('selectedGroup', uid, (err) => {
						assert.ifError(err);
						request(`${nconf.get('url')}/api/user/groupie`, { json: true }, (err, res, body) => {
							assert.ifError(err);
							assert.equal(res.statusCode, 200);
							assert(Array.isArray(body.selectedGroup));
							assert.equal(body.selectedGroup[0].name, 'selectedGroup');
							done();
						});
					});
				});
			});
		});

		it('should 404 if user does not exist', (done) => {
			groups.join('administrators', fooUid, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/user/doesnotexist/edit`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 404);
					groups.leave('administrators', fooUid, done);
				});
			});
		});

		it('should render edit/password', (done) => {
			request(`${nconf.get('url')}/api/user/foo/edit/password`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				done();
			});
		});

		it('should render edit/email', (done) => {
			request(`${nconf.get('url')}/api/user/foo/edit/email`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				done();
			});
		});

		it('should render edit/username', (done) => {
			request(`${nconf.get('url')}/api/user/foo/edit/username`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				done();
			});
		});
	});

	describe('account follow page', () => {
		const socketUser = require('../src/socket.io/user');
		let uid;
		before((done) => {
			user.create({ username: 'follower' }, (err, _uid) => {
				assert.ifError(err);
				uid = _uid;
				socketUser.follow({ uid: uid }, { uid: fooUid }, (err) => {
					assert.ifError(err);
					socketUser.isFollowing({ uid: uid }, { uid: fooUid }, (err, isFollowing) => {
						assert.ifError(err);
						assert(isFollowing);
						done();
					});
				});
			});
		});

		it('should get followers page', (done) => {
			request(`${nconf.get('url')}/api/user/foo/followers`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(body.users[0].username, 'follower');
				done();
			});
		});

		it('should get following page', (done) => {
			request(`${nconf.get('url')}/api/user/follower/following`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(body.users[0].username, 'foo');
				done();
			});
		});

		it('should return empty after unfollow', (done) => {
			socketUser.unfollow({ uid: uid }, { uid: fooUid }, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/user/foo/followers`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert.equal(body.users.length, 0);
					done();
				});
			});
		});
	});

	describe('post redirect', () => {
		let jar;
		before((done) => {
			helpers.loginUser('foo', 'barbar', (err, _jar) => {
				assert.ifError(err);
				jar = _jar;
				done();
			});
		});

		it('should 404 for invalid pid', (done) => {
			request(`${nconf.get('url')}/api/post/fail`, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should 403 if user does not have read privilege', (done) => {
			privileges.categories.rescind(['groups:topics:read'], category.cid, 'registered-users', (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/post/${pid}`, { jar: jar }, (err, res) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 403);
					privileges.categories.give(['groups:topics:read'], category.cid, 'registered-users', done);
				});
			});
		});

		it('should return correct post path', (done) => {
			request(`${nconf.get('url')}/api/post/${pid}`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(res.headers['x-redirect'], '/topic/1/test-topic-title/1');
				assert.equal(body, '/topic/1/test-topic-title/1');
				done();
			});
		});
	});

	describe('cookie consent', () => {
		it('should return relevant data in configs API route', (done) => {
			request(`${nconf.get('url')}/api/config`, (err, res, body) => {
				let parsed;
				assert.ifError(err);
				assert.equal(res.statusCode, 200);

				try {
					parsed = JSON.parse(body);
				} catch (e) {
					assert.ifError(e);
				}

				assert.ok(parsed.cookies);
				assert.equal(translator.escape('[[global:cookies.message]]'), parsed.cookies.message);
				assert.equal(translator.escape('[[global:cookies.accept]]'), parsed.cookies.dismiss);
				assert.equal(translator.escape('[[global:cookies.learn_more]]'), parsed.cookies.link);

				done();
			});
		});

		it('response should be parseable when entries have apostrophes', (done) => {
			meta.configs.set('cookieConsentMessage', 'Julian\'s Message', (err) => {
				assert.ifError(err);

				request(`${nconf.get('url')}/api/config`, (err, res, body) => {
					let parsed;
					assert.ifError(err);
					assert.equal(res.statusCode, 200);

					try {
						parsed = JSON.parse(body);
					} catch (e) {
						assert.ifError(e);
					}

					assert.equal('Julian&#x27;s Message', parsed.cookies.message);
					done();
				});
			});
		});
	});

	it('should return osd data', (done) => {
		request(`${nconf.get('url')}/osd.xml`, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	describe('handle errors', () => {
		const plugins = require('../src/plugins');
		after((done) => {
			plugins.loadedHooks['filter:router.page'] = undefined;
			done();
		});

		it('should handle topic malformed uri', (done) => {
			request(`${nconf.get('url')}/topic/1/a%AFc`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should handle category malformed uri', (done) => {
			request(`${nconf.get('url')}/category/1/a%AFc`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should handle malformed uri ', (done) => {
			request(`${nconf.get('url')}/user/a%AFc`, (err, res, body) => {
				assert.ifError(err);
				assert(body);
				assert.equal(res.statusCode, 400);
				done();
			});
		});

		it('should handle malformed uri in api', (done) => {
			request(`${nconf.get('url')}/api/user/a%AFc`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 400);
				assert.equal(body.error, '[[global:400.title]]');
				done();
			});
		});

		it('should handle CSRF error', (done) => {
			plugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];
			plugins.loadedHooks['filter:router.page'].push({
				method: function (req, res, next) {
					const err = new Error('csrf-error');
					err.code = 'EBADCSRFTOKEN';
					next(err);
				},
			});

			request(`${nconf.get('url')}/users`, {}, (err, res) => {
				plugins.loadedHooks['filter:router.page'] = [];
				assert.ifError(err);
				assert.equal(res.statusCode, 403);
				done();
			});
		});

		it('should handle black-list error', (done) => {
			plugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];
			plugins.loadedHooks['filter:router.page'].push({
				method: function (req, res, next) {
					const err = new Error('blacklist error message');
					err.code = 'blacklisted-ip';
					next(err);
				},
			});

			request(`${nconf.get('url')}/users`, {}, (err, res, body) => {
				plugins.loadedHooks['filter:router.page'] = [];
				assert.ifError(err);
				assert.equal(res.statusCode, 403);
				assert.equal(body, 'blacklist error message');
				done();
			});
		});

		it('should handle page redirect through error', (done) => {
			plugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];
			plugins.loadedHooks['filter:router.page'].push({
				method: function (req, res, next) {
					const err = new Error('redirect');
					err.status = 302;
					err.path = '/popular';
					plugins.loadedHooks['filter:router.page'] = [];
					next(err);
				},
			});

			request(`${nconf.get('url')}/users`, {}, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should handle api page redirect through error', (done) => {
			plugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];
			plugins.loadedHooks['filter:router.page'].push({
				method: function (req, res, next) {
					const err = new Error('redirect');
					err.status = 308;
					err.path = '/api/popular';
					plugins.loadedHooks['filter:router.page'] = [];
					next(err);
				},
			});

			request(`${nconf.get('url')}/api/users`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(res.headers['x-redirect'], '/api/popular');
				assert(body, '/api/popular');
				done();
			});
		});

		it('should handle error page', (done) => {
			plugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];
			plugins.loadedHooks['filter:router.page'].push({
				method: function (req, res, next) {
					const err = new Error('regular error');
					next(err);
				},
			});

			request(`${nconf.get('url')}/users`, (err, res, body) => {
				plugins.loadedHooks['filter:router.page'] = [];
				assert.ifError(err);
				assert.equal(res.statusCode, 500);
				assert(body);
				done();
			});
		});
	});

	describe('timeago locales', () => {
		it('should load timeago locale', (done) => {
			request(`${nconf.get('url')}/assets/src/modules/timeago/locales/jquery.timeago.af.js`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.includes('"gelede"'));
				done();
			});
		});

		it('should return not found if NodeBB language exists but timeago locale does not exist', (done) => {
			request(`${nconf.get('url')}/assets/src/modules/timeago/locales/jquery.timeago.ms.js`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should return not found if NodeBB language does not exist', (done) => {
			request(`${nconf.get('url')}/assets/src/modules/timeago/locales/jquery.timeago.muggle.js`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});
	});

	describe('category', () => {
		let jar;
		before((done) => {
			helpers.loginUser('foo', 'barbar', (err, _jar) => {
				assert.ifError(err);
				jar = _jar;
				done();
			});
		});

		it('should return 404 if cid is not a number', (done) => {
			request(`${nconf.get('url')}/api/category/fail`, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should return 404 if topic index is not a number', (done) => {
			request(`${nconf.get('url')}/api/category/${category.slug}/invalidtopicindex`, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should 404 if category does not exist', (done) => {
			request(`${nconf.get('url')}/api/category/123123`, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should 404 if category is disabled', (done) => {
			categories.create({ name: 'disabled' }, (err, category) => {
				assert.ifError(err);
				categories.setCategoryField(category.cid, 'disabled', 1, (err) => {
					assert.ifError(err);
					request(`${nconf.get('url')}/api/category/${category.slug}`, (err, res) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 404);
						done();
					});
				});
			});
		});

		it('should return 401 if not allowed to read', (done) => {
			categories.create({ name: 'hidden' }, (err, category) => {
				assert.ifError(err);
				privileges.categories.rescind(['groups:read'], category.cid, 'guests', (err) => {
					assert.ifError(err);
					request(`${nconf.get('url')}/api/category/${category.slug}`, (err, res) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 401);
						done();
					});
				});
			});
		});

		it('should redirect if topic index is negative', (done) => {
			request(`${nconf.get('url')}/api/category/${category.slug}/-10`, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.ok(res.headers['x-redirect']);
				done();
			});
		});

		it('should 404 if page is not found', (done) => {
			user.setSetting(fooUid, 'usePagination', 1, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/category/${category.slug}?page=100`, { jar: jar, json: true }, (err, res) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 404);
					done();
				});
			});
		});

		it('should load page 1 if req.query.page is not sent', (done) => {
			request(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(body.pagination.currentPage, 1);
				done();
			});
		});

		it('should sort topics by most posts', (done) => {
			async.waterfall([
				function (next) {
					categories.create({ name: 'most-posts-category' }, next);
				},
				function (category, next) {
					async.waterfall([
						function (next) {
							topics.post({ uid: fooUid, cid: category.cid, title: 'topic 1', content: 'topic 1 OP' }, next);
						},
						function (data, next) {
							topics.post({ uid: fooUid, cid: category.cid, title: 'topic 2', content: 'topic 2 OP' }, next);
						},
						function (data, next) {
							topics.reply({ uid: fooUid, content: 'topic 2 reply', tid: data.topicData.tid }, next);
						},
						function (postData, next) {
							request(`${nconf.get('url')}/api/category/${category.slug}?sort=most_posts`, { jar: jar, json: true }, (err, res, body) => {
								assert.ifError(err);
								assert.equal(res.statusCode, 200);
								assert.equal(body.topics[0].title, 'topic 2');
								assert.equal(body.topics[0].postcount, 2);
								assert.equal(body.topics[1].postcount, 1);
								next();
							});
						},
					], (err) => {
						next(err);
					});
				},
			], done);
		});

		it('should load a specific users topics from a category with tags', (done) => {
			async.waterfall([
				function (next) {
					categories.create({ name: 'filtered-category' }, next);
				},
				function (category, next) {
					async.waterfall([
						function (next) {
							topics.post({ uid: fooUid, cid: category.cid, title: 'topic 1', content: 'topic 1 OP', tags: ['java', 'cpp'] }, next);
						},
						function (data, next) {
							topics.post({ uid: fooUid, cid: category.cid, title: 'topic 2', content: 'topic 2 OP', tags: ['node', 'javascript'] }, next);
						},
						function (data, next) {
							topics.post({ uid: fooUid, cid: category.cid, title: 'topic 3', content: 'topic 3 OP', tags: ['java', 'cpp', 'best'] }, next);
						},
						function (data, next) {
							request(`${nconf.get('url')}/api/category/${category.slug}?tag=node&author=foo`, { jar: jar, json: true }, (err, res, body) => {
								assert.ifError(err);
								assert.equal(res.statusCode, 200);
								assert.equal(body.topics[0].title, 'topic 2');
								next();
							});
						},
						function (next) {
							request(`${nconf.get('url')}/api/category/${category.slug}?tag[]=java&tag[]=cpp`, { jar: jar, json: true }, (err, res, body) => {
								assert.ifError(err);
								assert.equal(res.statusCode, 200);
								assert.equal(body.topics[0].title, 'topic 3');
								assert.equal(body.topics[1].title, 'topic 1');
								next();
							});
						},
					], (err) => {
						next(err);
					});
				},
			], done);
		});

		it('should redirect if category is a link', (done) => {
			let cid;
			let category;
			async.waterfall([
				function (next) {
					categories.create({ name: 'redirect', link: 'https://nodebb.org' }, next);
				},
				function (_category, next) {
					category = _category;
					cid = category.cid;
					request(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 200);
						assert.equal(res.headers['x-redirect'], 'https://nodebb.org');
						assert.equal(body, 'https://nodebb.org');
						next();
					});
				},
				function (next) {
					categories.setCategoryField(cid, 'link', '/recent', next);
				},
				function (next) {
					request(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 200);
						assert.equal(res.headers['x-redirect'], '/recent');
						assert.equal(body, '/recent');
						next();
					});
				},
			], done);
		});

		it('should get recent topic replies from children categories', (done) => {
			let parentCategory;
			let childCategory1;
			let childCategory2;

			async.waterfall([
				function (next) {
					categories.create({ name: 'parent category', backgroundImage: 'path/to/some/image' }, next);
				},
				function (category, next) {
					parentCategory = category;
					async.waterfall([
						function (next) {
							categories.create({ name: 'child category 1', parentCid: category.cid }, next);
						},
						function (category, next) {
							childCategory1 = category;
							categories.create({ name: 'child category 2', parentCid: parentCategory.cid }, next);
						},
						function (category, next) {
							childCategory2 = category;
							topics.post({ uid: fooUid, cid: childCategory2.cid, title: 'topic 1', content: 'topic 1 OP' }, next);
						},
						function (data, next) {
							request(`${nconf.get('url')}/api/category/${parentCategory.slug}`, { jar: jar, json: true }, (err, res, body) => {
								assert.ifError(err);
								assert.equal(res.statusCode, 200);
								assert.equal(body.children[0].posts[0].content, 'topic 1 OP');
								next();
							});
						},
					], (err) => {
						next(err);
					});
				},
			], done);
		});

		it('should create 2 pages of topics', (done) => {
			async.waterfall([
				function (next) {
					categories.create({ name: 'category with 2 pages' }, next);
				},
				function (category, next) {
					const titles = [];
					for (let i = 0; i < 30; i++) {
						titles.push(`topic title ${i}`);
					}

					async.waterfall([
						function (next) {
							async.eachSeries(titles, (title, next) => {
								topics.post({ uid: fooUid, cid: category.cid, title: title, content: 'does not really matter' }, next);
							}, next);
						},
						function (next) {
							user.getSettings(fooUid, next);
						},
						function (settings, next) {
							request(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {
								assert.ifError(err);
								assert.equal(res.statusCode, 200);
								assert.equal(body.topics.length, settings.topicsPerPage);
								assert.equal(body.pagination.pageCount, 2);
								next();
							});
						},
					], (err) => {
						next(err);
					});
				},
			], done);
		});
	});

	describe('unread', () => {
		let jar;
		before((done) => {
			helpers.loginUser('foo', 'barbar', (err, _jar) => {
				assert.ifError(err);
				jar = _jar;
				done();
			});
		});

		it('should load unread page', (done) => {
			request(`${nconf.get('url')}/api/unread`, { jar: jar }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				done();
			});
		});

		it('should 404 if filter is invalid', (done) => {
			request(`${nconf.get('url')}/api/unread/doesnotexist`, { jar: jar }, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				done();
			});
		});

		it('should return total unread count', (done) => {
			request(`${nconf.get('url')}/api/unread/total?filter=new`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(body, 0);
				done();
			});
		});

		it('should redirect if page is out of bounds', (done) => {
			request(`${nconf.get('url')}/api/unread?page=-1`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(res.headers['x-redirect'], '/unread?page=1');
				assert.equal(body, '/unread?page=1');
				done();
			});
		});
	});

	describe('admin middlewares', () => {
		it('should redirect to login', (done) => {
			request(`${nconf.get('url')}//api/admin/advanced/database`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 401);
				done();
			});
		});

		it('should redirect to login', (done) => {
			request(`${nconf.get('url')}//admin/advanced/database`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.includes('Login to your account'));
				done();
			});
		});
	});

	describe('composer', () => {
		let csrf_token;
		let jar;

		before((done) => {
			helpers.loginUser('foo', 'barbar', (err, _jar) => {
				assert.ifError(err);
				jar = _jar;

				request({
					url: `${nconf.get('url')}/api/config`,
					json: true,
					jar: jar,
				}, (err, response, body) => {
					assert.ifError(err);
					csrf_token = body.csrf_token;
					done();
				});
			});
		});

		it('should load the composer route', (done) => {
			request(`${nconf.get('url')}/api/compose`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.title);
				assert(body.template);
				assert.equal(body.url, `${nconf.get('relative_path')}/compose`);
				done();
			});
		});

		it('should load the composer route if disabled by plugin', (done) => {
			function hookMethod(hookData, callback) {
				hookData.templateData.disabled = true;
				callback(null, hookData);
			}

			plugins.hooks.register('myTestPlugin', {
				hook: 'filter:composer.build',
				method: hookMethod,
			});

			request(`${nconf.get('url')}/api/compose`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.title);
				assert.strictEqual(body.template.name, '');
				assert.strictEqual(body.url, `${nconf.get('relative_path')}/compose`);

				plugins.hooks.unregister('myTestPlugin', 'filter:composer.build', hookMethod);
				done();
			});
		});

		it('should 404 if plugin calls next', (done) => {
			function hookMethod(hookData, callback) {
				hookData.next();
			}

			plugins.hooks.register('myTestPlugin', {
				hook: 'filter:composer.build',
				method: hookMethod,
			});

			request(`${nconf.get('url')}/api/compose`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);

				plugins.hooks.unregister('myTestPlugin', 'filter:composer.build', hookMethod);
				done();
			});
		});


		it('should error with invalid data', (done) => {
			request.post(`${nconf.get('url')}/compose`, {
				form: {
					content: 'a new reply',
				},
				jar: jar,
				headers: {
					'x-csrf-token': csrf_token,
				},
			}, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 400);
				request.post(`${nconf.get('url')}/compose`, {
					form: {
						tid: tid,
					},
					jar: jar,
					headers: {
						'x-csrf-token': csrf_token,
					},
				}, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 400);
					done();
				});
			});
		});

		it('should create a new topic and reply by composer route', (done) => {
			const data = {
				cid: cid,
				title: 'no js is good',
				content: 'a topic with noscript',
			};
			request.post(`${nconf.get('url')}/compose`, {
				form: data,
				jar: jar,
				headers: {
					'x-csrf-token': csrf_token,
				},
			}, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 302);
				request.post(`${nconf.get('url')}/compose`, {
					form: {
						tid: tid,
						content: 'a new reply',
					},
					jar: jar,
					headers: {
						'x-csrf-token': csrf_token,
					},
				}, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 302);
					done();
				});
			});
		});
	});

	after((done) => {
		const analytics = require('../src/analytics');
		analytics.writeData(done);
'use strict';


const	assert = require('assert');
const nconf = require('nconf');
const db = require('./mocks/databasemock');


describe('Test database', () => {
	it('should work', () => {
		assert.doesNotThrow(() => {
			require('./mocks/databasemock');
		});
	});

	describe('info', () => {
		it('should return info about database', (done) => {
			db.info(db.client, (err, info) => {
				assert.ifError(err);
				assert(info);
				done();
			});
		});

		it('should not error and return info if client is falsy', (done) => {
			db.info(null, (err, info) => {
				assert.ifError(err);
				assert(info);
				done();
			});
		});
	});

	describe('checkCompatibility', () => {
		it('should not throw', (done) => {
			db.checkCompatibility(done);
		});

		it('should return error with a too low version', (done) => {
			const dbName = nconf.get('database');
			if (dbName === 'redis') {
				db.checkCompatibilityVersion('2.4.0', (err) => {
					assert.equal(err.message, 'Your Redis version is not new enough to support NodeBB, please upgrade Redis to v2.8.9 or higher.');
					done();
				});
			} else if (dbName === 'mongo') {
				db.checkCompatibilityVersion('1.8.0', (err) => {
					assert.equal(err.message, 'The `mongodb` package is out-of-date, please run `./nodebb setup` again.');
					done();
				});
			} else if (dbName === 'postgres') {
				db.checkCompatibilityVersion('6.3.0', (err) => {
					assert.equal(err.message, 'The `pg` package is out-of-date, please run `./nodebb setup` again.');
					done();
				});
			}
		});
	});


	require('./database/keys');
	require('./database/list');
	require('./database/sets');
	require('./database/hash');
	require('./database/sorted');
'use strict';

const async = require('async');
const assert = require('assert');
const validator = require('validator');
const nconf = require('nconf');
const request = require('request');
const util = require('util');

const db = require('./mocks/databasemock');
const topics = require('../src/topics');
const posts = require('../src/posts');
const categories = require('../src/categories');
const privileges = require('../src/privileges');
const meta = require('../src/meta');
const User = require('../src/user');
const groups = require('../src/groups');
const helpers = require('./helpers');
const socketPosts = require('../src/socket.io/posts');
const socketTopics = require('../src/socket.io/topics');


const requestType = util.promisify((type, url, opts, cb) => {
	request[type](url, opts, (err, res, body) => cb(err, { res: res, body: body }));
});

describe('Topic\'s', () => {
	let topic;
	let categoryObj;
	let adminUid;
	let adminJar;
	let fooUid;

	before(async () => {
		adminUid = await User.create({ username: 'admin', password: '123456' });
		fooUid = await User.create({ username: 'foo' });
		await groups.join('administrators', adminUid);
		adminJar = await helpers.loginUser('admin', '123456');

		categoryObj = await categories.create({
			name: 'Test Category',
			description: 'Test category created by testing script',
		});
		topic = {
			userId: adminUid,
			categoryId: categoryObj.cid,
			title: 'Test Topic Title',
			content: 'The content of test topic',
		};
	});

	describe('.post', () => {
		it('should fail to create topic with invalid data', (done) => {
			socketTopics.post({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should create a new topic with proper parameters', (done) => {
			topics.post({
				uid: topic.userId,
				title: topic.title,
				content: topic.content,
				cid: topic.categoryId,
			}, (err, result) => {
				assert.ifError(err);
				assert(result);
				topic.tid = result.topicData.tid;
				done();
			});
		});

		it('should get post count', (done) => {
			socketTopics.postcount({ uid: adminUid }, topic.tid, (err, count) => {
				assert.ifError(err);
				assert.equal(count, 1);
				done();
			});
		});

		it('should load topic', (done) => {
			socketTopics.getTopic({ uid: adminUid }, topic.tid, (err, data) => {
				assert.ifError(err);
				assert.equal(data.tid, topic.tid);
				done();
			});
		});

		it('should fail to create new topic with invalid user id', (done) => {
			topics.post({ uid: null, title: topic.title, content: topic.content, cid: topic.categoryId }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail to create new topic with empty title', (done) => {
			topics.post({ uid: topic.userId, title: '', content: topic.content, cid: topic.categoryId }, (err) => {
				assert.ok(err);
				done();
			});
		});

		it('should fail to create new topic with empty content', (done) => {
			topics.post({ uid: topic.userId, title: topic.title, content: '', cid: topic.categoryId }, (err) => {
				assert.ok(err);
				done();
			});
		});

		it('should fail to create new topic with non-existant category id', (done) => {
			topics.post({ uid: topic.userId, title: topic.title, content: topic.content, cid: 99 }, (err) => {
				assert.equal(err.message, '[[error:no-category]]', 'received no error');
				done();
			});
		});

		it('should return false for falsy uid', (done) => {
			topics.isOwner(topic.tid, 0, (err, isOwner) => {
				assert.ifError(err);
				assert(!isOwner);
				done();
			});
		});

		it('should fail to post a topic as guest if no privileges', async () => {
			const categoryObj = await categories.create({
				name: 'Test Category',
				description: 'Test category created by testing script',
			});
			const result = await requestType('post', `${nconf.get('url')}/api/v3/topics`, {
				form: {
					title: 'just a title',
					cid: categoryObj.cid,
					content: 'content for the main post',
				},
				json: true,
			});
			assert.strictEqual(result.body.status.message, '[[error:no-privileges]]');
		});

		it('should post a topic as guest if guest group has privileges', async () => {
			const categoryObj = await categories.create({
				name: 'Test Category',
				description: 'Test category created by testing script',
			});
			await privileges.categories.give(['groups:topics:create'], categoryObj.cid, 'guests');
			await privileges.categories.give(['groups:topics:reply'], categoryObj.cid, 'guests');

			const result = await requestType('post', `${nconf.get('url')}/api/v3/topics`, {
				form: {
					title: 'just a title',
					cid: categoryObj.cid,
					content: 'content for the main post',
				},
				json: true,
			});

			assert.strictEqual(result.body.status.code, 'ok');
			assert.strictEqual(result.body.response.title, 'just a title');
			assert.strictEqual(result.body.response.user.username, '[[global:guest]]');

			const replyResult = await requestType('post', `${nconf.get('url')}/api/v3/topics/${result.body.response.tid}`, {
				form: {
					content: 'a reply by guest',
				},
				json: true,
			});
			assert.strictEqual(replyResult.body.response.content, 'a reply by guest');
		});
	});

	describe('.reply', () => {
		let newTopic;
		let newPost;

		before((done) => {
			topics.post({
				uid: topic.userId,
				title: topic.title,
				content: topic.content,
				cid: topic.categoryId,
			}, (err, result) => {
				if (err) {
					return done(err);
				}

				newTopic = result.topicData;
				newPost = result.postData;
				done();
			});
		});

		it('should create a new reply with proper parameters', (done) => {
			topics.reply({ uid: topic.userId, content: 'test post', tid: newTopic.tid }, (err, result) => {
				assert.equal(err, null, 'was created with error');
				assert.ok(result);

				done();
			});
		});

		it('should handle direct replies', (done) => {
			topics.reply({ uid: topic.userId, content: 'test reply', tid: newTopic.tid, toPid: newPost.pid }, (err, result) => {
				assert.equal(err, null, 'was created with error');
				assert.ok(result);

				socketPosts.getReplies({ uid: 0 }, newPost.pid, (err, postData) => {
					assert.ifError(err);

					assert.ok(postData);

					assert.equal(postData.length, 1, 'should have 1 result');
					assert.equal(postData[0].pid, result.pid, 'result should be the reply we added');

					done();
				});
			});
		});

		it('should error if pid is not a number', (done) => {
			socketPosts.getReplies({ uid: 0 }, 'abc', (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail to create new reply with invalid user id', (done) => {
			topics.reply({ uid: null, content: 'test post', tid: newTopic.tid }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail to create new reply with empty content', (done) => {
			topics.reply({ uid: topic.userId, content: '', tid: newTopic.tid }, (err) => {
				assert.ok(err);
				done();
			});
		});

		it('should fail to create new reply with invalid topic id', (done) => {
			topics.reply({ uid: null, content: 'test post', tid: 99 }, (err) => {
				assert.equal(err.message, '[[error:no-topic]]');
				done();
			});
		});

		it('should fail to create new reply with invalid toPid', (done) => {
			topics.reply({ uid: topic.userId, content: 'test post', tid: newTopic.tid, toPid: '"onmouseover=alert(1);//' }, (err) => {
				assert.equal(err.message, '[[error:invalid-pid]]');
				done();
			});
		});

		it('should delete nested relies properly', async () => {
			const result = await topics.post({ uid: fooUid, title: 'nested test', content: 'main post', cid: topic.categoryId });
			const reply1 = await topics.reply({ uid: fooUid, content: 'reply post 1', tid: result.topicData.tid });
			const reply2 = await topics.reply({ uid: fooUid, content: 'reply post 2', tid: result.topicData.tid, toPid: reply1.pid });
			let replies = await socketPosts.getReplies({ uid: fooUid }, reply1.pid);
			assert.strictEqual(replies.length, 1);
			assert.strictEqual(replies[0].content, 'reply post 2');
			let toPid = await posts.getPostField(reply2.pid, 'toPid');
			assert.strictEqual(parseInt(toPid, 10), parseInt(reply1.pid, 10));
			await posts.purge(reply1.pid, fooUid);
			replies = await socketPosts.getReplies({ uid: fooUid }, reply1.pid);
			assert.strictEqual(replies.length, 0);
			toPid = await posts.getPostField(reply2.pid, 'toPid');
			assert.strictEqual(toPid, null);
		});
	});

	describe('Get methods', () => {
		let	newTopic;
		let newPost;

		before((done) => {
			topics.post({
				uid: topic.userId,
				title: topic.title,
				content: topic.content,
				cid: topic.categoryId,
			}, (err, result) => {
				if (err) {
					return done(err);
				}

				newTopic = result.topicData;
				newPost = result.postData;
				done();
			});
		});


		it('should not receive errors', (done) => {
			topics.getTopicData(newTopic.tid, (err, topicData) => {
				assert.ifError(err);
				assert(typeof topicData.tid === 'number');
				assert(typeof topicData.uid === 'number');
				assert(typeof topicData.cid === 'number');
				assert(typeof topicData.mainPid === 'number');

				assert(typeof topicData.timestamp === 'number');
				assert.strictEqual(topicData.postcount, 1);
				assert.strictEqual(topicData.viewcount, 0);
				assert.strictEqual(topicData.upvotes, 0);
				assert.strictEqual(topicData.downvotes, 0);
				assert.strictEqual(topicData.votes, 0);
				assert.strictEqual(topicData.deleted, 0);
				assert.strictEqual(topicData.locked, 0);
				assert.strictEqual(topicData.pinned, 0);
				done();
			});
		});

		it('should get a single field', (done) => {
			topics.getTopicFields(newTopic.tid, ['slug'], (err, data) => {
				assert.ifError(err);
				assert(Object.keys(data).length === 1);
				assert(data.hasOwnProperty('slug'));
				done();
			});
		});

		it('should get topic title by pid', (done) => {
			topics.getTitleByPid(newPost.pid, (err, title) => {
				assert.ifError(err);
				assert.equal(title, topic.title);
				done();
			});
		});

		it('should get topic data by pid', (done) => {
			topics.getTopicDataByPid(newPost.pid, (err, data) => {
				assert.ifError(err);
				assert.equal(data.tid, newTopic.tid);
				done();
			});
		});

		describe('.getTopicWithPosts', () => {
			let tid;
			before(async () => {
				const result = await topics.post({ uid: topic.userId, title: 'page test', content: 'main post', cid: topic.categoryId });
				tid = result.topicData.tid;
				for (let i = 0; i < 30; i++) {
					// eslint-disable-next-line no-await-in-loop
					await topics.reply({ uid: adminUid, content: `topic reply ${i + 1}`, tid: tid });
				}
			});

			it('should get a topic with posts and other data', async () => {
				const topicData = await topics.getTopicData(tid);
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, 0, -1, false);
				assert(data);
				assert.equal(data.category.cid, topic.categoryId);
				assert.equal(data.unreplied, false);
				assert.equal(data.deleted, false);
				assert.equal(data.locked, false);
				assert.equal(data.pinned, false);
			});

			it('should return first 3 posts including main post', async () => {
				const topicData = await topics.getTopicData(tid);
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, 0, 2, false);
				assert.strictEqual(data.posts.length, 3);
				assert.strictEqual(data.posts[0].content, 'main post');
				assert.strictEqual(data.posts[1].content, 'topic reply 1');
				assert.strictEqual(data.posts[2].content, 'topic reply 2');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index);
				});
			});

			it('should return 3 posts from 1 to 3 excluding main post', async () => {
				const topicData = await topics.getTopicData(tid);
				const start = 1;
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, start, 3, false);
				assert.strictEqual(data.posts.length, 3);
				assert.strictEqual(data.posts[0].content, 'topic reply 1');
				assert.strictEqual(data.posts[1].content, 'topic reply 2');
				assert.strictEqual(data.posts[2].content, 'topic reply 3');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index + start);
				});
			});

			it('should return main post and last 2 posts', async () => {
				const topicData = await topics.getTopicData(tid);
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, 0, 2, true);
				assert.strictEqual(data.posts.length, 3);
				assert.strictEqual(data.posts[0].content, 'main post');
				assert.strictEqual(data.posts[1].content, 'topic reply 30');
				assert.strictEqual(data.posts[2].content, 'topic reply 29');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index);
				});
			});

			it('should return last 3 posts and not main post', async () => {
				const topicData = await topics.getTopicData(tid);
				const start = 1;
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, start, 3, true);
				assert.strictEqual(data.posts.length, 3);
				assert.strictEqual(data.posts[0].content, 'topic reply 30');
				assert.strictEqual(data.posts[1].content, 'topic reply 29');
				assert.strictEqual(data.posts[2].content, 'topic reply 28');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index + start);
				});
			});

			it('should return posts 29 to 27 posts and not main post', async () => {
				const topicData = await topics.getTopicData(tid);
				const start = 2;
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, start, 4, true);
				assert.strictEqual(data.posts.length, 3);
				assert.strictEqual(data.posts[0].content, 'topic reply 29');
				assert.strictEqual(data.posts[1].content, 'topic reply 28');
				assert.strictEqual(data.posts[2].content, 'topic reply 27');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index + start);
				});
			});

			it('should return 3 posts in reverse', async () => {
				const topicData = await topics.getTopicData(tid);
				const start = 28;
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, start, 30, true);
				assert.strictEqual(data.posts.length, 3);
				assert.strictEqual(data.posts[0].content, 'topic reply 3');
				assert.strictEqual(data.posts[1].content, 'topic reply 2');
				assert.strictEqual(data.posts[2].content, 'topic reply 1');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index + start);
				});
			});

			it('should get all posts with main post at the start', async () => {
				const topicData = await topics.getTopicData(tid);
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, 0, -1, false);
				assert.strictEqual(data.posts.length, 31);
				assert.strictEqual(data.posts[0].content, 'main post');
				assert.strictEqual(data.posts[1].content, 'topic reply 1');
				assert.strictEqual(data.posts[data.posts.length - 1].content, 'topic reply 30');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index);
				});
			});

			it('should get all posts in reverse with main post at the start followed by reply 30', async () => {
				const topicData = await topics.getTopicData(tid);
				const data = await topics.getTopicWithPosts(topicData, `tid:${tid}:posts`, topic.userId, 0, -1, true);
				assert.strictEqual(data.posts.length, 31);
				assert.strictEqual(data.posts[0].content, 'main post');
				assert.strictEqual(data.posts[1].content, 'topic reply 30');
				assert.strictEqual(data.posts[data.posts.length - 1].content, 'topic reply 1');
				data.posts.forEach((post, index) => {
					assert.strictEqual(post.index, index);
				});
			});
		});
	});

	describe('Title escaping', () => {
		it('should properly escape topic title', (done) => {
			const title = '"<script>alert(\'ok1\');</script> new topic test';
			const titleEscaped = validator.escape(title);
			topics.post({ uid: topic.userId, title: title, content: topic.content, cid: topic.categoryId }, (err, result) => {
				assert.ifError(err);
				topics.getTopicData(result.topicData.tid, (err, topicData) => {
					assert.ifError(err);
					assert.strictEqual(topicData.titleRaw, title);
					assert.strictEqual(topicData.title, titleEscaped);
					done();
				});
			});
		});
	});

	describe('tools/delete/restore/purge', () => {
		let newTopic;
		let followerUid;
		let moveCid;

		before((done) => {
			async.waterfall([
				function (next) {
					topics.post({
						uid: topic.userId,
						title: topic.title,
						content: topic.content,
						cid: topic.categoryId,
					}, (err, result) => {
						assert.ifError(err);
						newTopic = result.topicData;
						next();
					});
				},
				function (next) {
					User.create({ username: 'topicFollower', password: '123456' }, next);
				},
				function (_uid, next) {
					followerUid = _uid;
					topics.follow(newTopic.tid, _uid, next);
				},
				function (next) {
					categories.create({
						name: 'Test Category',
						description: 'Test category created by testing script',
					}, (err, category) => {
						if (err) {
							return next(err);
						}
						moveCid = category.cid;
						next();
					});
				},
			], done);
		});

		it('should load topic tools', (done) => {
			socketTopics.loadTopicTools({ uid: adminUid }, { tid: newTopic.tid }, (err, data) => {
				assert.ifError(err);
				assert(data);
				done();
			});
		});

		it('should delete the topic', (done) => {
			socketTopics.delete({ uid: adminUid }, { tids: [newTopic.tid], cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should restore the topic', (done) => {
			socketTopics.restore({ uid: adminUid }, { tids: [newTopic.tid], cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should lock topic', (done) => {
			socketTopics.lock({ uid: adminUid }, { tids: [newTopic.tid], cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				topics.isLocked(newTopic.tid, (err, isLocked) => {
					assert.ifError(err);
					assert(isLocked);
					done();
				});
			});
		});

		it('should unlock topic', (done) => {
			socketTopics.unlock({ uid: adminUid }, { tids: [newTopic.tid], cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				topics.isLocked(newTopic.tid, (err, isLocked) => {
					assert.ifError(err);
					assert(!isLocked);
					done();
				});
			});
		});

		it('should pin topic', (done) => {
			socketTopics.pin({ uid: adminUid }, { tids: [newTopic.tid], cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				topics.getTopicField(newTopic.tid, 'pinned', (err, pinned) => {
					assert.ifError(err);
					assert.strictEqual(pinned, 1);
					done();
				});
			});
		});

		it('should unpin topic', (done) => {
			socketTopics.unpin({ uid: adminUid }, { tids: [newTopic.tid], cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				topics.getTopicField(newTopic.tid, 'pinned', (err, pinned) => {
					assert.ifError(err);
					assert.strictEqual(pinned, 0);
					done();
				});
			});
		});

		it('should move all topics', (done) => {
			socketTopics.moveAll({ uid: adminUid }, { cid: moveCid, currentCid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				topics.getTopicField(newTopic.tid, 'cid', (err, cid) => {
					assert.ifError(err);
					assert.equal(cid, moveCid);
					done();
				});
			});
		});

		it('should move a topic', (done) => {
			socketTopics.move({ uid: adminUid }, { cid: categoryObj.cid, tids: [newTopic.tid] }, (err) => {
				assert.ifError(err);
				topics.getTopicField(newTopic.tid, 'cid', (err, cid) => {
					assert.ifError(err);
					assert.equal(cid, categoryObj.cid);
					done();
				});
			});
		});

		it('should properly update sets when post is moved', (done) => {
			let movedPost;
			let previousPost;
			let topic2LastReply;
			let tid1;
			let tid2;
			const cid1 = topic.categoryId;
			let cid2;
			function checkCidSets(post1, post2, callback) {
				async.waterfall([
					function (next) {
						async.parallel({
							topicData: function (next) {
								topics.getTopicsFields([tid1, tid2], ['lastposttime', 'postcount'], next);
							},
							scores1: function (next) {
								db.sortedSetsScore([
									`cid:${cid1}:tids`,
									`cid:${cid1}:tids:lastposttime`,
									`cid:${cid1}:tids:posts`,
								], tid1, next);
							},
							scores2: function (next) {
								db.sortedSetsScore([
									`cid:${cid2}:tids`,
									`cid:${cid2}:tids:lastposttime`,
									`cid:${cid2}:tids:posts`,
								], tid2, next);
							},
							posts1: function (next) {
								db.getSortedSetRangeWithScores(`tid:${tid1}:posts`, 0, -1, next);
							},
							posts2: function (next) {
								db.getSortedSetRangeWithScores(`tid:${tid2}:posts`, 0, -1, next);
							},
						}, next);
					},
					function (results, next) {
						const assertMsg = `${JSON.stringify(results.posts1)}\n${JSON.stringify(results.posts2)}`;
						assert.equal(results.topicData[0].postcount, results.scores1[2], assertMsg);
						assert.equal(results.topicData[1].postcount, results.scores2[2], assertMsg);
						assert.equal(results.topicData[0].lastposttime, post1.timestamp, assertMsg);
						assert.equal(results.topicData[1].lastposttime, post2.timestamp, assertMsg);
						assert.equal(results.topicData[0].lastposttime, results.scores1[0], assertMsg);
						assert.equal(results.topicData[1].lastposttime, results.scores2[0], assertMsg);
						assert.equal(results.topicData[0].lastposttime, results.scores1[1], assertMsg);
						assert.equal(results.topicData[1].lastposttime, results.scores2[1], assertMsg);

						next();
					},
				], callback);
			}

			async.waterfall([
				function (next) {
					categories.create({
						name: 'move to this category',
						description: 'Test category created by testing script',
					}, next);
				},
				function (category, next) {
					cid2 = category.cid;
					topics.post({ uid: adminUid, title: 'topic1', content: 'topic 1 mainPost', cid: cid1 }, next);
				},
				function (result, next) {
					tid1 = result.topicData.tid;
					topics.reply({ uid: adminUid, content: 'topic 1 reply 1', tid: tid1 }, next);
				},
				function (postData, next) {
					previousPost = postData;
					topics.reply({ uid: adminUid, content: 'topic 1 reply 2', tid: tid1 }, next);
				},
				function (postData, next) {
					movedPost = postData;
					topics.post({ uid: adminUid, title: 'topic2', content: 'topic 2 mainpost', cid: cid2 }, next);
				},
				function (results, next) {
					tid2 = results.topicData.tid;
					topics.reply({ uid: adminUid, content: 'topic 2 reply 1', tid: tid2 }, next);
				},
				function (postData, next) {
					topic2LastReply = postData;
					checkCidSets(movedPost, postData, next);
				},
				function (next) {
					db.isMemberOfSortedSets([`cid:${cid1}:pids`, `cid:${cid2}:pids`], movedPost.pid, next);
				},
				function (isMember, next) {
					assert.deepEqual(isMember, [true, false]);
					categories.getCategoriesFields([cid1, cid2], ['post_count'], next);
				},
				function (categoryData, next) {
					assert.equal(categoryData[0].post_count, 4);
					assert.equal(categoryData[1].post_count, 2);
					topics.movePostToTopic(1, movedPost.pid, tid2, next);
				},
				function (next) {
					checkCidSets(previousPost, topic2LastReply, next);
				},
				function (next) {
					db.isMemberOfSortedSets([`cid:${cid1}:pids`, `cid:${cid2}:pids`], movedPost.pid, next);
				},
				function (isMember, next) {
					assert.deepEqual(isMember, [false, true]);
					categories.getCategoriesFields([cid1, cid2], ['post_count'], next);
				},
				function (categoryData, next) {
					assert.equal(categoryData[0].post_count, 3);
					assert.equal(categoryData[1].post_count, 3);
					next();
				},
			], done);
		});

		it('should fail to purge topic if user does not have privilege', (done) => {
			let globalModUid;
			let tid;
			async.waterfall([
				function (next) {
					topics.post({
						uid: adminUid,
						title: 'topic for purge test',
						content: 'topic content',
						cid: categoryObj.cid,
					}, next);
				},
				function (result, next) {
					tid = result.topicData.tid;
					User.create({ username: 'global mod' }, next);
				},
				function (uid, next) {
					globalModUid = uid;
					groups.join('Global Moderators', uid, next);
				},
				function (next) {
					privileges.categories.rescind(['groups:purge'], categoryObj.cid, 'Global Moderators', next);
				},
				function (next) {
					socketTopics.purge({ uid: globalModUid }, { tids: [tid], cid: categoryObj.cid }, (err) => {
						assert.equal(err.message, '[[error:no-privileges]]');
						privileges.categories.give(['groups:purge'], categoryObj.cid, 'Global Moderators', next);
					});
				},
			], done);
		});

		it('should purge the topic', (done) => {
			socketTopics.purge({ uid: adminUid }, { tids: [newTopic.tid], cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				db.isSortedSetMember(`uid:${followerUid}:followed_tids`, newTopic.tid, (err, isMember) => {
					assert.ifError(err);
					assert.strictEqual(false, isMember);
					done();
				});
			});
		});

		it('should not allow user to restore their topic if it was deleted by an admin', async () => {
			const result = await topics.post({
				uid: fooUid,
				title: 'topic for restore test',
				content: 'topic content',
				cid: categoryObj.cid,
			});
			await socketTopics.delete({ uid: adminUid }, { tids: [result.topicData.tid], cid: categoryObj.cid });
			try {
				await socketTopics.restore({ uid: fooUid }, { tids: [result.topicData.tid], cid: categoryObj.cid });
			} catch (err) {
				assert.strictEqual(err.message, '[[error:no-privileges]]');
			}
		});
	});

	describe('order pinned topics', () => {
		let tid1;
		let tid2;
		let tid3;
		before((done) => {
			function createTopic(callback) {
				topics.post({
					uid: topic.userId,
					title: 'topic for test',
					content: 'topic content',
					cid: topic.categoryId,
				}, callback);
			}
			async.series({
				topic1: function (next) {
					createTopic(next);
				},
				topic2: function (next) {
					createTopic(next);
				},
				topic3: function (next) {
					createTopic(next);
				},
			}, (err, results) => {
				assert.ifError(err);
				tid1 = results.topic1.topicData.tid;
				tid2 = results.topic2.topicData.tid;
				tid3 = results.topic3.topicData.tid;
				async.series([
					function (next) {
						topics.tools.pin(tid1, adminUid, next);
					},
					function (next) {
						// artificial timeout so pin time is different on redis sometimes scores are indentical
						setTimeout(() => {
							topics.tools.pin(tid2, adminUid, next);
						}, 5);
					},
				], done);
			});
		});

		const socketTopics = require('../src/socket.io/topics');
		it('should error with invalid data', (done) => {
			socketTopics.orderPinnedTopics({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error with invalid data', (done) => {
			socketTopics.orderPinnedTopics({ uid: adminUid }, [null, null], (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error with unprivileged user', (done) => {
			socketTopics.orderPinnedTopics({ uid: 0 }, [{ tid: tid1 }, { tid: tid2 }], (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should not do anything if topics are not pinned', (done) => {
			socketTopics.orderPinnedTopics({ uid: adminUid }, [{ tid: tid3 }], (err) => {
				assert.ifError(err);
				db.isSortedSetMember(`cid:${topic.categoryId}:tids:pinned`, tid3, (err, isMember) => {
					assert.ifError(err);
					assert(!isMember);
					done();
				});
			});
		});

		it('should order pinned topics', (done) => {
			db.getSortedSetRevRange(`cid:${topic.categoryId}:tids:pinned`, 0, -1, (err, pinnedTids) => {
				assert.ifError(err);
				assert.equal(pinnedTids[0], tid2);
				assert.equal(pinnedTids[1], tid1);
				socketTopics.orderPinnedTopics({ uid: adminUid }, [{ tid: tid1, order: 1 }, { tid: tid2, order: 0 }], (err) => {
					assert.ifError(err);
					db.getSortedSetRevRange(`cid:${topic.categoryId}:tids:pinned`, 0, -1, (err, pinnedTids) => {
						assert.ifError(err);
						assert.equal(pinnedTids[0], tid1);
						assert.equal(pinnedTids[1], tid2);
						done();
					});
				});
			});
		});
	});


	describe('.ignore', () => {
		let newTid;
		let uid;
		let newTopic;
		before((done) => {
			uid = topic.userId;
			async.waterfall([
				function (done) {
					topics.post({ uid: topic.userId, title: 'Topic to be ignored', content: 'Just ignore me, please!', cid: topic.categoryId }, (err, result) => {
						if (err) {
							return done(err);
						}

						newTopic = result.topicData;
						newTid = newTopic.tid;
						done();
					});
				},
				function (done) {
					topics.markUnread(newTid, uid, done);
				},
			], done);
		});

		it('should not appear in the unread list', (done) => {
			async.waterfall([
				function (done) {
					topics.ignore(newTid, uid, done);
				},
				function (done) {
					topics.getUnreadTopics({ cid: 0, uid: uid, start: 0, stop: -1, filter: '' }, done);
				},
				function (results, done) {
					const { topics } = results;
					const tids = topics.map(topic => topic.tid);
					assert.equal(tids.indexOf(newTid), -1, 'The topic appeared in the unread list.');
					done();
				},
			], done);
		});

		it('should not appear as unread in the recent list', (done) => {
			async.waterfall([
				function (done) {
					topics.ignore(newTid, uid, done);
				},
				function (done) {
					topics.getLatestTopics({
						uid: uid,
						start: 0,
						stop: -1,
						term: 'year',
					}, done);
				},
				function (results, done) {
					const { topics } = results;
					let topic;
					let i;
					for (i = 0; i < topics.length; i += 1) {
						if (topics[i].tid === parseInt(newTid, 10)) {
							assert.equal(false, topics[i].unread, 'ignored topic was marked as unread in recent list');
							return done();
						}
					}
					assert.ok(topic, 'topic didn\'t appear in the recent list');
					done();
				},
			], done);
		});

		it('should appear as unread again when marked as reading', (done) => {
			async.waterfall([
				function (done) {
					topics.ignore(newTid, uid, done);
				},
				function (done) {
					topics.follow(newTid, uid, done);
				},
				function (done) {
					topics.getUnreadTopics({ cid: 0, uid: uid, start: 0, stop: -1, filter: '' }, done);
				},
				function (results, done) {
					const { topics } = results;
					const tids = topics.map(topic => topic.tid);
					assert.notEqual(tids.indexOf(newTid), -1, 'The topic did not appear in the unread list.');
					done();
				},
			], done);
		});

		it('should appear as unread again when marked as following', (done) => {
			async.waterfall([
				function (done) {
					topics.ignore(newTid, uid, done);
				},
				function (done) {
					topics.follow(newTid, uid, done);
				},
				function (done) {
					topics.getUnreadTopics({ cid: 0, uid: uid, start: 0, stop: -1, filter: '' }, done);
				},
				function (results, done) {
					const { topics } = results;
					const tids = topics.map(topic => topic.tid);
					assert.notEqual(tids.indexOf(newTid), -1, 'The topic did not appear in the unread list.');
					done();
				},
			], done);
		});
	});

	describe('.fork', () => {
		let newTopic;
		const replies = [];
		let topicPids;
		const originalBookmark = 6;
		function postReply(next) {
			topics.reply({ uid: topic.userId, content: `test post ${replies.length}`, tid: newTopic.tid }, (err, result) => {
				assert.equal(err, null, 'was created with error');
				assert.ok(result);
				replies.push(result);
				next();
			});
		}

		before((done) => {
			async.waterfall([
				function (next) {
					groups.join('administrators', topic.userId, next);
				},
				function (next) {
					topics.post({
						uid: topic.userId,
						title: topic.title,
						content: topic.content,
						cid: topic.categoryId,
					}, (err, result) => {
						assert.ifError(err);
						newTopic = result.topicData;
						next();
					});
				},
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) { postReply(next); },
				function (next) {
					topicPids = replies.map(reply => reply.pid);
					socketTopics.bookmark({ uid: topic.userId }, { tid: newTopic.tid, index: originalBookmark }, next);
				},
			], done);
		});

		it('should fail with invalid data', (done) => {
			socketTopics.bookmark({ uid: topic.userId }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should have 12 replies', (done) => {
			assert.equal(12, replies.length);
			done();
		});

		it('should fail with invalid data', (done) => {
			socketTopics.createTopicFromPosts({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:not-logged-in]]');
				done();
			});
		});

		it('should fail with invalid data', (done) => {
			socketTopics.createTopicFromPosts({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should not update the user\'s bookmark', (done) => {
			async.waterfall([
				function (next) {
					socketTopics.createTopicFromPosts({ uid: topic.userId }, {
						title: 'Fork test, no bookmark update',
						pids: topicPids.slice(-2),
						fromTid: newTopic.tid,
					}, next);
				},
				function (forkedTopicData, next) {
					topics.getUserBookmark(newTopic.tid, topic.userId, next);
				},
				function (bookmark, next) {
					assert.equal(originalBookmark, bookmark);
					next();
				},
			], done);
		});

		it('should update the user\'s bookmark ', (done) => {
			async.waterfall([
				function (next) {
					topics.createTopicFromPosts(
						topic.userId,
						'Fork test, no bookmark update',
						topicPids.slice(1, 3),
						newTopic.tid,
						next
					);
				},
				function (forkedTopicData, next) {
					topics.getUserBookmark(newTopic.tid, topic.userId, next);
				},
				function (bookmark, next) {
					assert.equal(originalBookmark - 2, bookmark);
					next();
				},
			], done);
		});

		it('should properly update topic vote count after forking', async () => {
			const result = await topics.post({ uid: fooUid, cid: categoryObj.cid, title: 'fork vote test', content: 'main post' });
			const reply1 = await topics.reply({ tid: result.topicData.tid, uid: fooUid, content: 'test reply 1' });
			const reply2 = await topics.reply({ tid: result.topicData.tid, uid: fooUid, content: 'test reply 2' });
			const reply3 = await topics.reply({ tid: result.topicData.tid, uid: fooUid, content: 'test reply 3' });
			await posts.upvote(result.postData.pid, adminUid);
			await posts.upvote(reply1.pid, adminUid);
			assert.strictEqual(await db.sortedSetScore('topics:votes', result.topicData.tid), 1);
			assert.strictEqual(await db.sortedSetScore(`cid:${categoryObj.cid}:tids:votes`, result.topicData.tid), 1);
			const newTopic = await topics.createTopicFromPosts(adminUid, 'Fork test, vote update', [reply1.pid, reply2.pid], result.topicData.tid);

			assert.strictEqual(await db.sortedSetScore('topics:votes', newTopic.tid), 1);
			assert.strictEqual(await db.sortedSetScore(`cid:${categoryObj.cid}:tids:votes`, newTopic.tid), 1);
			assert.strictEqual(await topics.getTopicField(newTopic.tid, 'upvotes'), 1);
		});
	});

	describe('controller', () => {
		let topicData;

		before((done) => {
			topics.post({
				uid: topic.userId,
				title: 'topic for controller test',
				content: 'topic content',
				cid: topic.categoryId,
				thumb: 'http://i.imgur.com/64iBdBD.jpg',
			}, (err, result) => {
				assert.ifError(err);
				assert.ok(result);
				topicData = result.topicData;
				done();
			});
		});

		it('should load topic', (done) => {
			request(`${nconf.get('url')}/topic/${topicData.slug}`, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load topic api data', (done) => {
			request(`${nconf.get('url')}/api/topic/${topicData.slug}`, { json: true }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert.strictEqual(body._header.tags.meta.find(t => t.name === 'description').content, 'topic content');
				assert.strictEqual(body._header.tags.meta.find(t => t.property === 'og:description').content, 'topic content');
				done();
			});
		});

		it('should 404 if post index is invalid', (done) => {
			request(`${nconf.get('url')}/topic/${topicData.slug}/derp`, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});

		it('should 404 if topic does not exist', (done) => {
			request(`${nconf.get('url')}/topic/123123/does-not-exist`, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});

		it('should 401 if not allowed to read as guest', (done) => {
			const privileges = require('../src/privileges');
			privileges.categories.rescind(['groups:topics:read'], topicData.cid, 'guests', (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/topic/${topicData.slug}`, (err, response, body) => {
					assert.ifError(err);
					assert.equal(response.statusCode, 401);
					assert(body);
					privileges.categories.give(['groups:topics:read'], topicData.cid, 'guests', done);
				});
			});
		});

		it('should redirect to correct topic if slug is missing', (done) => {
			request(`${nconf.get('url')}/topic/${topicData.tid}/herpderp/1?page=2`, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should redirect if post index is out of range', (done) => {
			request(`${nconf.get('url')}/api/topic/${topicData.slug}/-1`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(res.headers['x-redirect'], `/topic/${topicData.tid}/topic-for-controller-test`);
				assert.equal(body, `/topic/${topicData.tid}/topic-for-controller-test`);
				done();
			});
		});

		it('should 404 if page is out of bounds', (done) => {
			const meta = require('../src/meta');
			meta.config.usePagination = 1;
			request(`${nconf.get('url')}/topic/${topicData.slug}?page=100`, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});

		it('should mark topic read', (done) => {
			request(`${nconf.get('url')}/topic/${topicData.slug}`, {
				jar: adminJar,
			}, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				topics.hasReadTopics([topicData.tid], adminUid, (err, hasRead) => {
					assert.ifError(err);
					assert.equal(hasRead[0], true);
					done();
				});
			});
		});

		it('should 404 if tid is not a number', (done) => {
			request(`${nconf.get('url')}/api/topic/teaser/nan`, { json: true }, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});

		it('should 403 if cant read', (done) => {
			request(`${nconf.get('url')}/api/topic/teaser/${123123}`, { json: true }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 403);
				assert.equal(body, '[[error:no-privileges]]');

				done();
			});
		});

		it('should load topic teaser', (done) => {
			request(`${nconf.get('url')}/api/topic/teaser/${topicData.tid}`, { json: true }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert(body);
				assert.equal(body.tid, topicData.tid);
				assert.equal(body.content, 'topic content');
				assert(body.user);
				assert(body.topic);
				assert(body.category);
				done();
			});
		});


		it('should 404 if tid is not a number', (done) => {
			request(`${nconf.get('url')}/api/topic/pagination/nan`, { json: true }, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});

		it('should 404 if tid does not exist', (done) => {
			request(`${nconf.get('url')}/api/topic/pagination/1231231`, { json: true }, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});

		it('should load pagination', (done) => {
			request(`${nconf.get('url')}/api/topic/pagination/${topicData.tid}`, { json: true }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert(body);
				assert.deepEqual(body.pagination, {
					prev: { page: 1, active: false },
					next: { page: 1, active: false },
					first: { page: 1, active: true },
					last: { page: 1, active: true },
					rel: [],
					pages: [],
					currentPage: 1,
					pageCount: 1,
				});
				done();
			});
		});
	});


	describe('infinitescroll', () => {
		const socketTopics = require('../src/socket.io/topics');
		let tid;
		before((done) => {
			topics.post({
				uid: topic.userId,
				title: topic.title,
				content: topic.content,
				cid: topic.categoryId,
			}, (err, result) => {
				assert.ifError(err);
				tid = result.topicData.tid;
				done();
			});
		});

		it('should error with invalid data', (done) => {
			socketTopics.loadMore({ uid: adminUid }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should infinite load topic posts', (done) => {
			socketTopics.loadMore({ uid: adminUid }, { tid: tid, after: 0, count: 10 }, (err, data) => {
				assert.ifError(err);
				assert(data.mainPost);
				assert(data.posts);
				assert(data.privileges);
				done();
			});
		});

		it('should error with invalid data', (done) => {
			socketTopics.loadMoreSortedTopics({ uid: adminUid }, { after: 'invalid' }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should load more unread topics', (done) => {
			socketTopics.markUnread({ uid: adminUid }, tid, (err) => {
				assert.ifError(err);
				socketTopics.loadMoreSortedTopics({ uid: adminUid }, { cid: topic.categoryId, after: 0, count: 10, sort: 'unread' }, (err, data) => {
					assert.ifError(err);
					assert(data);
					assert(Array.isArray(data.topics));
					done();
				});
			});
		});

		it('should error with invalid data', (done) => {
			socketTopics.loadMoreSortedTopics({ uid: adminUid }, { after: 'invalid' }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});


		it('should load more recent topics', (done) => {
			socketTopics.loadMoreSortedTopics({ uid: adminUid }, { cid: topic.categoryId, after: 0, count: 10, sort: 'recent' }, (err, data) => {
				assert.ifError(err);
				assert(data);
				assert(Array.isArray(data.topics));
				done();
			});
		});

		it('should error with invalid data', (done) => {
			socketTopics.loadMoreFromSet({ uid: adminUid }, { after: 'invalid' }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should load more from custom set', (done) => {
			socketTopics.loadMoreFromSet({ uid: adminUid }, { set: `uid:${adminUid}:topics`, after: 0, count: 10 }, (err, data) => {
				assert.ifError(err);
				assert(data);
				assert(Array.isArray(data.topics));
				done();
			});
		});
	});

	describe('suggested topics', () => {
		let tid1;
		let tid3;
		before((done) => {
			async.series({
				topic1: function (next) {
					topics.post({ uid: adminUid, tags: ['nodebb'], title: 'topic title 1', content: 'topic 1 content', cid: topic.categoryId }, next);
				},
				topic2: function (next) {
					topics.post({ uid: adminUid, tags: ['nodebb'], title: 'topic title 2', content: 'topic 2 content', cid: topic.categoryId }, next);
				},
				topic3: function (next) {
					topics.post({ uid: adminUid, tags: [], title: 'topic title 3', content: 'topic 3 content', cid: topic.categoryId }, next);
				},
			}, (err, results) => {
				assert.ifError(err);
				tid1 = results.topic1.topicData.tid;
				tid3 = results.topic3.topicData.tid;
				done();
			});
		});

		it('should return suggested topics', (done) => {
			topics.getSuggestedTopics(tid1, adminUid, 0, -1, (err, topics) => {
				assert.ifError(err);
				assert(Array.isArray(topics));
				done();
			});
		});

		it('should return suggested topics', (done) => {
			topics.getSuggestedTopics(tid3, adminUid, 0, 2, (err, topics) => {
				assert.ifError(err);
				assert(Array.isArray(topics));
				done();
			});
		});
	});

	describe('unread', () => {
		const socketTopics = require('../src/socket.io/topics');
		let tid;
		let mainPid;
		let uid;
		before((done) => {
			async.parallel({
				topic: function (next) {
					topics.post({ uid: topic.userId, title: 'unread topic', content: 'unread topic content', cid: topic.categoryId }, next);
				},
				joeUid: function (next) {
					User.create({ username: 'regularJoe' }, next);
				},
			}, (err, results) => {
				assert.ifError(err);
				tid = results.topic.topicData.tid;
				mainPid = results.topic.postData.pid;
				uid = results.joeUid;
				done();
			});
		});

		it('should fail with invalid data', (done) => {
			socketTopics.markUnread({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail if topic does not exist', (done) => {
			socketTopics.markUnread({ uid: adminUid }, 1231082, (err) => {
				assert.equal(err.message, '[[error:no-topic]]');
				done();
			});
		});

		it('should mark topic unread', (done) => {
			socketTopics.markUnread({ uid: adminUid }, tid, (err) => {
				assert.ifError(err);
				topics.hasReadTopic(tid, adminUid, (err, hasRead) => {
					assert.ifError(err);
					assert.equal(hasRead, false);
					done();
				});
			});
		});

		it('should fail with invalid data', (done) => {
			socketTopics.markAsRead({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should mark topic read', (done) => {
			socketTopics.markAsRead({ uid: adminUid }, [tid], (err) => {
				assert.ifError(err);
				topics.hasReadTopic(tid, adminUid, (err, hasRead) => {
					assert.ifError(err);
					assert(hasRead);
					done();
				});
			});
		});

		it('should fail with invalid data', (done) => {
			socketTopics.markTopicNotificationsRead({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should mark topic notifications read', (done) => {
			async.waterfall([
				function (next) {
					socketTopics.follow({ uid: adminUid }, tid, next);
				},
				function (next) {
					topics.reply({ uid: uid, timestamp: Date.now(), content: 'some content', tid: tid }, next);
				},
				function (data, next) {
					setTimeout(next, 2500);
				},
				function (next) {
					User.notifications.getUnreadCount(adminUid, next);
				},
				function (count, next) {
					assert.equal(count, 1);
					socketTopics.markTopicNotificationsRead({ uid: adminUid }, [tid], next);
				},
				function (next) {
					User.notifications.getUnreadCount(adminUid, next);
				},
				function (count, next) {
					assert.equal(count, 0);
					next();
				},
			], (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should fail with invalid data', (done) => {
			socketTopics.markAllRead({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-uid]]');
				done();
			});
		});

		it('should mark all read', (done) => {
			socketTopics.markUnread({ uid: adminUid }, tid, (err) => {
				assert.ifError(err);
				socketTopics.markAllRead({ uid: adminUid }, {}, (err) => {
					assert.ifError(err);
					topics.hasReadTopic(tid, adminUid, (err, hasRead) => {
						assert.ifError(err);
						assert(hasRead);
						done();
					});
				});
			});
		});

		it('should mark category topics read', (done) => {
			socketTopics.markUnread({ uid: adminUid }, tid, (err) => {
				assert.ifError(err);
				socketTopics.markCategoryTopicsRead({ uid: adminUid }, topic.categoryId, (err) => {
					assert.ifError(err);
					topics.hasReadTopic(tid, adminUid, (err, hasRead) => {
						assert.ifError(err);
						assert(hasRead);
						done();
					});
				});
			});
		});

		it('should fail with invalid data', (done) => {
			socketTopics.markAsUnreadForAll({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-tid]]');
				done();
			});
		});

		it('should fail with invalid data', (done) => {
			socketTopics.markAsUnreadForAll({ uid: 0 }, [tid], (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail if user is not admin', (done) => {
			socketTopics.markAsUnreadForAll({ uid: uid }, [tid], (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail if topic does not exist', (done) => {
			socketTopics.markAsUnreadForAll({ uid: uid }, [12312313], (err) => {
				assert.equal(err.message, '[[error:no-topic]]');
				done();
			});
		});

		it('should mark topic unread for everyone', (done) => {
			socketTopics.markAsUnreadForAll({ uid: adminUid }, [tid], (err) => {
				assert.ifError(err);
				async.parallel({
					adminRead: function (next) {
						topics.hasReadTopic(tid, adminUid, next);
					},
					regularRead: function (next) {
						topics.hasReadTopic(tid, uid, next);
					},
				}, (err, results) => {
					assert.ifError(err);
					assert.equal(results.adminRead, false);
					assert.equal(results.regularRead, false);
					done();
				});
			});
		});

		it('should not do anything if tids is empty array', (done) => {
			socketTopics.markAsRead({ uid: adminUid }, [], (err, markedRead) => {
				assert.ifError(err);
				assert(!markedRead);
				done();
			});
		});

		it('should not return topics in category you cant read', (done) => {
			let privateCid;
			let privateTid;
			async.waterfall([
				function (next) {
					categories.create({
						name: 'private category',
						description: 'private category',
					}, next);
				},
				function (category, next) {
					privateCid = category.cid;
					privileges.categories.rescind(['groups:topics:read'], category.cid, 'registered-users', next);
				},
				function (next) {
					topics.post({ uid: adminUid, title: 'topic in private category', content: 'registered-users cant see this', cid: privateCid }, next);
				},
				function (data, next) {
					privateTid = data.topicData.tid;
					topics.getUnreadTids({ uid: uid }, next);
				},
				function (unreadTids, next) {
					unreadTids = unreadTids.map(String);
					assert(!unreadTids.includes(String(privateTid)));
					next();
				},
			], done);
		});

		it('should not return topics in category you ignored/not watching', (done) => {
			let ignoredCid;
			let tid;
			async.waterfall([
				function (next) {
					categories.create({
						name: 'ignored category',
						description: 'ignored category',
					}, next);
				},
				function (category, next) {
					ignoredCid = category.cid;
					privileges.categories.rescind(['groups:topics:read'], category.cid, 'registered-users', next);
				},
				function (next) {
					topics.post({ uid: adminUid, title: 'topic in private category', content: 'registered-users cant see this', cid: ignoredCid }, next);
				},
				function (data, next) {
					tid = data.topicData.tid;
					User.ignoreCategory(uid, ignoredCid, next);
				},
				function (next) {
					topics.getUnreadTids({ uid: uid }, next);
				},
				function (unreadTids, next) {
					unreadTids = unreadTids.map(String);
					assert(!unreadTids.includes(String(tid)));
					next();
				},
			], done);
		});

		it('should not return topic as unread if new post is from blocked user', (done) => {
			let blockedUid;
			let topic;
			async.waterfall([
				function (next) {
					topics.post({ uid: adminUid, title: 'will not get as unread', content: 'not unread', cid: categoryObj.cid }, next);
				},
				function (result, next) {
					topic = result.topicData;
					User.create({ username: 'blockedunread' }, next);
				},
				function (uid, next) {
					blockedUid = uid;
					User.blocks.add(uid, adminUid, next);
				},
				function (next) {
					topics.reply({ uid: blockedUid, content: 'post from blocked user', tid: topic.tid }, next);
				},
				function (result, next) {
					topics.getUnreadTids({ cid: 0, uid: adminUid }, next);
				},
				function (unreadTids, next) {
					assert(!unreadTids.includes(topic.tid));
					User.blocks.remove(blockedUid, adminUid, next);
				},
			], done);
		});

		it('should not return topic as unread if topic is deleted', async () => {
			const uid = await User.create({ username: 'regularJoe' });
			const result = await topics.post({ uid: adminUid, title: 'deleted unread', content: 'not unread', cid: categoryObj.cid });
			await topics.delete(result.topicData.tid, adminUid);
			const unreadTids = await topics.getUnreadTids({ cid: 0, uid: uid });
			assert(!unreadTids.includes(result.topicData.tid));
		});
	});

	describe('tags', () => {
		const socketTopics = require('../src/socket.io/topics');
		const socketAdmin = require('../src/socket.io/admin');

		before((done) => {
			async.series([
				function (next) {
					topics.post({ uid: adminUid, tags: ['php', 'nosql', 'psql', 'nodebb'], title: 'topic title 1', content: 'topic 1 content', cid: topic.categoryId }, next);
				},
				function (next) {
					topics.post({ uid: adminUid, tags: ['javascript', 'mysql', 'python', 'nodejs'], title: 'topic title 2', content: 'topic 2 content', cid: topic.categoryId }, next);
				},
			], (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should return empty array if query is falsy', (done) => {
			socketTopics.autocompleteTags({ uid: adminUid }, { query: '' }, (err, data) => {
				assert.ifError(err);
				assert.deepEqual([], data);
				done();
			});
		});

		it('should autocomplete tags', (done) => {
			socketTopics.autocompleteTags({ uid: adminUid }, { query: 'p' }, (err, data) => {
				assert.ifError(err);
				['php', 'psql', 'python'].forEach((tag) => {
					assert.notEqual(data.indexOf(tag), -1);
				});
				done();
			});
		});

		it('should return empty array if query is falsy', (done) => {
			socketTopics.searchTags({ uid: adminUid }, { query: '' }, (err, data) => {
				assert.ifError(err);
				assert.deepEqual([], data);
				done();
			});
		});

		it('should search tags', (done) => {
			socketTopics.searchTags({ uid: adminUid }, { query: 'no' }, (err, data) => {
				assert.ifError(err);
				['nodebb', 'nodejs', 'nosql'].forEach((tag) => {
					assert.notEqual(data.indexOf(tag), -1);
				});
				done();
			});
		});

		it('should return empty array if query is falsy', (done) => {
			socketTopics.searchAndLoadTags({ uid: adminUid }, { query: '' }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.matchCount, 0);
				assert.equal(data.pageCount, 1);
				assert.deepEqual(data.tags, []);
				done();
			});
		});

		it('should search and load tags', (done) => {
			socketTopics.searchAndLoadTags({ uid: adminUid }, { query: 'no' }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.matchCount, 3);
				assert.equal(data.pageCount, 1);
				const tagData = [
					{ value: 'nodebb', valueEscaped: 'nodebb', color: '', bgColor: '', score: 3 },
					{ value: 'nodejs', valueEscaped: 'nodejs', color: '', bgColor: '', score: 1 },
					{ value: 'nosql', valueEscaped: 'nosql', color: '', bgColor: '', score: 1 },
				];
				assert.deepEqual(data.tags, tagData);

				done();
			});
		});

		it('should return error if data is invalid', (done) => {
			socketTopics.loadMoreTags({ uid: adminUid }, { after: 'asd' }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should load more tags', (done) => {
			socketTopics.loadMoreTags({ uid: adminUid }, { after: 0 }, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data.tags));
				assert.equal(data.nextStart, 100);
				done();
			});
		});

		it('should error if data is invalid', (done) => {
			socketAdmin.tags.create({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if tag is invalid', (done) => {
			socketAdmin.tags.create({ uid: adminUid }, { tag: '' }, (err) => {
				assert.equal(err.message, '[[error:invalid-tag]]');
				done();
			});
		});

		it('should error if tag is too short', (done) => {
			socketAdmin.tags.create({ uid: adminUid }, { tag: 'as' }, (err) => {
				assert.equal(err.message, '[[error:tag-too-short]]');
				done();
			});
		});

		it('should create empty tag', (done) => {
			socketAdmin.tags.create({ uid: adminUid }, { tag: 'emptytag' }, (err) => {
				assert.ifError(err);
				db.sortedSetScore('tags:topic:count', 'emptytag', (err, score) => {
					assert.ifError(err);
					assert.equal(score, 0);
					done();
				});
			});
		});

		it('should do nothing if tag exists', (done) => {
			socketAdmin.tags.create({ uid: adminUid }, { tag: 'emptytag' }, (err) => {
				assert.ifError(err);
				db.sortedSetScore('tags:topic:count', 'emptytag', (err, score) => {
					assert.ifError(err);
					assert.equal(score, 0);
					done();
				});
			});
		});

		it('should error if data is invalid', (done) => {
			socketAdmin.tags.update({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if data is not an array', (done) => {
			socketAdmin.tags.update({ uid: adminUid }, {
				bgColor: '#ff0000',
				color: '#00ff00',
			}, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should update tag', (done) => {
			socketAdmin.tags.update({ uid: adminUid }, [{
				value: 'emptytag',
				bgColor: '#ff0000',
				color: '#00ff00',
			}], (err) => {
				assert.ifError(err);
				db.getObject('tag:emptytag', (err, data) => {
					assert.ifError(err);
					assert.equal(data.bgColor, '#ff0000');
					assert.equal(data.color, '#00ff00');
					done();
				});
			});
		});

		it('should rename tags', (done) => {
			async.series({
				topic1: function (next) {
					topics.post({ uid: adminUid, tags: ['plugins'], title: 'topic tagged with plugins', content: 'topic 1 content', cid: topic.categoryId }, next);
				},
				topic2: function (next) {
					topics.post({ uid: adminUid, tags: ['plugin'], title: 'topic tagged with plugin', content: 'topic 2 content', cid: topic.categoryId }, next);
				},
			}, (err, result) => {
				assert.ifError(err);
				socketAdmin.tags.rename({ uid: adminUid }, [{
					value: 'plugin',
					newName: 'plugins',
				}], (err) => {
					assert.ifError(err);
					topics.getTagTids('plugins', 0, -1, (err, tids) => {
						assert.ifError(err);
						assert.equal(tids.length, 2);
						topics.getTopicTags(result.topic2.topicData.tid, (err, tags) => {
							assert.ifError(err);
							assert.equal(tags.length, 1);
							assert.equal(tags[0], 'plugins');
							done();
						});
					});
				});
			});
		});

		it('should return related topics', (done) => {
			const meta = require('../src/meta');
			meta.config.maximumRelatedTopics = 2;
			const topicData = {
				tags: [{ value: 'javascript' }],
			};
			topics.getRelatedTopics(topicData, 0, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				assert.equal(data[0].title, 'topic title 2');
				meta.config.maximumRelatedTopics = 0;
				done();
			});
		});

		it('should return error with invalid data', (done) => {
			socketAdmin.tags.deleteTags({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should do nothing if arrays is empty', (done) => {
			socketAdmin.tags.deleteTags({ uid: adminUid }, { tags: [] }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should delete tags', (done) => {
			socketAdmin.tags.create({ uid: adminUid }, { tag: 'emptytag2' }, (err) => {
				assert.ifError(err);
				socketAdmin.tags.deleteTags({ uid: adminUid }, { tags: ['emptytag', 'emptytag2', 'nodebb', 'nodejs'] }, (err) => {
					assert.ifError(err);
					db.getObjects(['tag:emptytag', 'tag:emptytag2'], (err, data) => {
						assert.ifError(err);
						assert(!data[0]);
						assert(!data[1]);
						done();
					});
				});
			});
		});

		it('should delete tag', (done) => {
			topics.deleteTag('javascript', (err) => {
				assert.ifError(err);
				db.getObject('tag:javascript', (err, data) => {
					assert.ifError(err);
					assert(!data);
					done();
				});
			});
		});

		it('should delete category tag as well', async () => {
			const category = await categories.create({ name: 'delete category' });
			const { cid } = category;
			await topics.post({ uid: adminUid, tags: ['willbedeleted', 'notthis'], title: 'tag topic', content: 'topic 1 content', cid: cid });
			let categoryTags = await topics.getCategoryTags(cid, 0, -1);
			assert(categoryTags.includes('willbedeleted'));
			assert(categoryTags.includes('notthis'));
			await topics.deleteTags(['willbedeleted']);
			categoryTags = await topics.getCategoryTags(cid, 0, -1);
			assert(!categoryTags.includes('willbedeleted'));
			assert(categoryTags.includes('notthis'));
		});

		it('should add and remove tags from topics properly', async () => {
			const category = await categories.create({ name: 'add/remove category' });
			const { cid } = category;
			const result = await topics.post({ uid: adminUid, tags: ['tag4', 'tag2', 'tag1', 'tag3'], title: 'tag topic', content: 'topic 1 content', cid: cid });
			const { tid } = result.topicData;

			let tags = await topics.getTopicTags(tid);
			let categoryTags = await topics.getCategoryTags(cid, 0, -1);
			assert.deepStrictEqual(tags, ['tag1', 'tag2', 'tag3', 'tag4']);
			assert.deepStrictEqual(categoryTags.sort(), ['tag1', 'tag2', 'tag3', 'tag4']);

			await topics.addTags(['tag7', 'tag6', 'tag5'], [tid]);
			tags = await topics.getTopicTags(tid);
			categoryTags = await topics.getCategoryTags(cid, 0, -1);
			assert.deepStrictEqual(tags, ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7']);
			assert.deepStrictEqual(categoryTags.sort(), ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7']);

			await topics.removeTags(['tag1', 'tag3', 'tag5', 'tag7'], [tid]);
			tags = await topics.getTopicTags(tid);
			categoryTags = await topics.getCategoryTags(cid, 0, -1);
			assert.deepStrictEqual(tags, ['tag2', 'tag4', 'tag6']);
			assert.deepStrictEqual(categoryTags.sort(), ['tag2', 'tag4', 'tag6']);
		});

		it('should respect minTags', async () => {
			const oldValue = meta.config.minimumTagsPerTopic;
			meta.config.minimumTagsPerTopic = 2;
			let err;
			try {
				await topics.post({ uid: adminUid, tags: ['tag4'], title: 'tag topic', content: 'topic 1 content', cid: topic.categoryId });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, `[[error:not-enough-tags, ${meta.config.minimumTagsPerTopic}]]`);
			meta.config.minimumTagsPerTopic = oldValue;
		});

		it('should respect maxTags', async () => {
			const oldValue = meta.config.maximumTagsPerTopic;
			meta.config.maximumTagsPerTopic = 2;
			let err;
			try {
				await topics.post({ uid: adminUid, tags: ['tag1', 'tag2', 'tag3'], title: 'tag topic', content: 'topic 1 content', cid: topic.categoryId });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, `[[error:too-many-tags, ${meta.config.maximumTagsPerTopic}]]`);
			meta.config.maximumTagsPerTopic = oldValue;
		});

		it('should respect minTags per category', async () => {
			const minTags = 2;
			await categories.setCategoryField(topic.categoryId, 'minTags', minTags);
			let err;
			try {
				await topics.post({ uid: adminUid, tags: ['tag4'], title: 'tag topic', content: 'topic 1 content', cid: topic.categoryId });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, `[[error:not-enough-tags, ${minTags}]]`);
			await db.deleteObjectField(`category:${topic.categoryId}`, 'minTags');
		});

		it('should respect maxTags per category', async () => {
			const maxTags = 2;
			await categories.setCategoryField(topic.categoryId, 'maxTags', maxTags);
			let err;
			try {
				await topics.post({ uid: adminUid, tags: ['tag1', 'tag2', 'tag3'], title: 'tag topic', content: 'topic 1 content', cid: topic.categoryId });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, `[[error:too-many-tags, ${maxTags}]]`);
			await db.deleteObjectField(`category:${topic.categoryId}`, 'maxTags');
		});

		it('should create and delete category tags properly', async () => {
			const category = await categories.create({ name: 'tag category 2' });
			const { cid } = category;
			const title = 'test title';
			const postResult = await topics.post({ uid: adminUid, tags: ['cattag1', 'cattag2', 'cattag3'], title: title, content: 'topic 1 content', cid: cid });
			await topics.post({ uid: adminUid, tags: ['cattag1', 'cattag2'], title: title, content: 'topic 1 content', cid: cid });
			await topics.post({ uid: adminUid, tags: ['cattag1'], title: title, content: 'topic 1 content', cid: cid });
			let result = await topics.getCategoryTagsData(cid, 0, -1);
			assert.deepStrictEqual(result, [
				{ value: 'cattag1', score: 3, bgColor: '', color: '', valueEscaped: 'cattag1' },
				{ value: 'cattag2', score: 2, bgColor: '', color: '', valueEscaped: 'cattag2' },
				{ value: 'cattag3', score: 1, bgColor: '', color: '', valueEscaped: 'cattag3' },
			]);

			// after purging values should update properly
			await topics.purge(postResult.topicData.tid, adminUid);
			result = await topics.getCategoryTagsData(cid, 0, -1);

			assert.deepStrictEqual(result, [
				{ value: 'cattag1', score: 2, bgColor: '', color: '', valueEscaped: 'cattag1' },
				{ value: 'cattag2', score: 1, bgColor: '', color: '', valueEscaped: 'cattag2' },
			]);
		});

		it('should update counts correctly if topic is moved between categories', async () => {
			const category1 = await categories.create({ name: 'tag category 2' });
			const category2 = await categories.create({ name: 'tag category 2' });
			const cid1 = category1.cid;
			const cid2 = category2.cid;

			const title = 'test title';
			const postResult = await topics.post({ uid: adminUid, tags: ['movedtag1', 'movedtag2'], title: title, content: 'topic 1 content', cid: cid1 });

			await topics.post({ uid: adminUid, tags: ['movedtag1'], title: title, content: 'topic 1 content', cid: cid1 });
			await topics.post({ uid: adminUid, tags: ['movedtag2'], title: title, content: 'topic 1 content', cid: cid2 });

			let result1 = await topics.getCategoryTagsData(cid1, 0, -1);
			let result2 = await topics.getCategoryTagsData(cid2, 0, -1);
			assert.deepStrictEqual(result1, [
				{ value: 'movedtag1', score: 2, bgColor: '', color: '', valueEscaped: 'movedtag1' },
				{ value: 'movedtag2', score: 1, bgColor: '', color: '', valueEscaped: 'movedtag2' },
			]);
			assert.deepStrictEqual(result2, [
				{ value: 'movedtag2', score: 1, bgColor: '', color: '', valueEscaped: 'movedtag2' },
			]);

			// after moving values should update properly
			await topics.tools.move(postResult.topicData.tid, { cid: cid2, uid: adminUid });

			result1 = await topics.getCategoryTagsData(cid1, 0, -1);
			result2 = await topics.getCategoryTagsData(cid2, 0, -1);
			assert.deepStrictEqual(result1, [
				{ value: 'movedtag1', score: 1, bgColor: '', color: '', valueEscaped: 'movedtag1' },
			]);
			assert.deepStrictEqual(result2, [
				{ value: 'movedtag2', score: 2, bgColor: '', color: '', valueEscaped: 'movedtag2' },
				{ value: 'movedtag1', score: 1, bgColor: '', color: '', valueEscaped: 'movedtag1' },
			]);
		});

		it('should not allow regular user to use system tags', async () => {
			const oldValue = meta.config.systemTags;
			meta.config.systemTags = 'moved,locked';
			let err;
			try {
				await topics.post({
					uid: fooUid,
					tags: ['locked'],
					title: 'i cant use this',
					content: 'topic 1 content',
					cid: categoryObj.cid,
				});
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, '[[error:cant-use-system-tag]]');
			meta.config.systemTags = oldValue;
		});

		it('should allow admin user to use system tags', async () => {
			const oldValue = meta.config.systemTags;
			meta.config.systemTags = 'moved,locked';
			const result = await topics.post({
				uid: adminUid,
				tags: ['locked'],
				title: 'I can use this tag',
				content: 'topic 1 content',
				cid: categoryObj.cid,
			});
			assert.strictEqual(result.topicData.tags[0].value, 'locked');
			meta.config.systemTags = oldValue;
		});
	});

	describe('follow/unfollow', () => {
		const socketTopics = require('../src/socket.io/topics');
		let tid;
		let followerUid;
		before((done) => {
			User.create({ username: 'follower' }, (err, uid) => {
				if (err) {
					return done(err);
				}
				followerUid = uid;
				topics.post({ uid: adminUid, title: 'topic title', content: 'some content', cid: topic.categoryId }, (err, result) => {
					if (err) {
						return done(err);
					}
					tid = result.topicData.tid;
					done();
				});
			});
		});

		it('should error if not logged in', (done) => {
			socketTopics.changeWatching({ uid: 0 }, { tid: tid, type: 'ignore' }, (err) => {
				assert.equal(err.message, '[[error:not-logged-in]]');
				done();
			});
		});

		it('should filter ignoring uids', (done) => {
			socketTopics.changeWatching({ uid: followerUid }, { tid: tid, type: 'ignore' }, (err) => {
				assert.ifError(err);
				topics.filterIgnoringUids(tid, [adminUid, followerUid], (err, uids) => {
					assert.ifError(err);
					assert.equal(uids.length, 1);
					assert.equal(uids[0], adminUid);
					done();
				});
			});
		});

		it('should error with invalid data', (done) => {
			socketTopics.changeWatching({ uid: followerUid }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error with invalid type', (done) => {
			socketTopics.changeWatching({ uid: followerUid }, { tid: tid, type: 'derp' }, (err) => {
				assert.equal(err.message, '[[error:invalid-command]]');
				done();
			});
		});

		it('should follow topic', (done) => {
			topics.toggleFollow(tid, followerUid, (err, isFollowing) => {
				assert.ifError(err);
				assert(isFollowing);
				socketTopics.isFollowed({ uid: followerUid }, tid, (err, isFollowing) => {
					assert.ifError(err);
					assert(isFollowing);
					done();
				});
			});
		});
	});

	describe('topics search', () => {
		it('should error with invalid data', (done) => {
			socketTopics.search({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should return results', (done) => {
			const plugins = require('../src/plugins');
			plugins.hooks.register('myTestPlugin', {
				hook: 'filter:topic.search',
				method: function (data, callback) {
					callback(null, [1, 2, 3]);
				},
			});
			socketTopics.search({ uid: adminUid }, { tid: topic.tid, term: 'test' }, (err, results) => {
				assert.ifError(err);
				assert.deepEqual(results, [1, 2, 3]);
				done();
			});
		});
	});

	it('should check if user is moderator', (done) => {
		socketTopics.isModerator({ uid: adminUid }, topic.tid, (err, isModerator) => {
			assert.ifError(err);
			assert(!isModerator);
			done();
		});
	});

	describe('teasers', () => {
		let topic1;
		let topic2;
		before((done) => {
			async.series([
				function (next) {
					topics.post({ uid: adminUid, title: 'topic 1', content: 'content 1', cid: categoryObj.cid }, next);
				},
				function (next) {
					topics.post({ uid: adminUid, title: 'topic 2', content: 'content 2', cid: categoryObj.cid }, next);
				},
			], (err, results) => {
				assert.ifError(err);
				topic1 = results[0];
				topic2 = results[1];
				done();
			});
		});

		after((done) => {
			meta.config.teaserPost = '';
			done();
		});


		it('should return empty array if first param is empty', (done) => {
			topics.getTeasers([], 1, (err, teasers) => {
				assert.ifError(err);
				assert.equal(0, teasers.length);
				done();
			});
		});

		it('should get teasers with 2 params', (done) => {
			topics.getTeasers([topic1.topicData, topic2.topicData], 1, (err, teasers) => {
				assert.ifError(err);
				assert.deepEqual([undefined, undefined], teasers);
				done();
			});
		});

		it('should get teasers with first posts', (done) => {
			meta.config.teaserPost = 'first';
			topics.getTeasers([topic1.topicData, topic2.topicData], 1, (err, teasers) => {
				assert.ifError(err);
				assert.equal(2, teasers.length);
				assert(teasers[0]);
				assert(teasers[1]);
				assert(teasers[0].tid, topic1.topicData.tid);
				assert(teasers[0].content, 'content 1');
				assert(teasers[0].user.username, 'admin');
				done();
			});
		});

		it('should get teasers even if one topic is falsy', (done) => {
			topics.getTeasers([null, topic2.topicData], 1, (err, teasers) => {
				assert.ifError(err);
				assert.equal(2, teasers.length);
				assert.equal(undefined, teasers[0]);
				assert(teasers[1]);
				assert(teasers[1].tid, topic2.topicData.tid);
				assert(teasers[1].content, 'content 2');
				assert(teasers[1].user.username, 'admin');
				done();
			});
		});

		it('should get teasers with last posts', (done) => {
			meta.config.teaserPost = 'last-post';
			topics.reply({ uid: adminUid, content: 'reply 1 content', tid: topic1.topicData.tid }, (err, result) => {
				assert.ifError(err);
				topic1.topicData.teaserPid = result.pid;
				topics.getTeasers([topic1.topicData, topic2.topicData], 1, (err, teasers) => {
					assert.ifError(err);
					assert(teasers[0]);
					assert(teasers[1]);
					assert(teasers[0].tid, topic1.topicData.tid);
					assert(teasers[0].content, 'reply 1 content');
					done();
				});
			});
		});

		it('should get teasers by tids', (done) => {
			topics.getTeasersByTids([topic2.topicData.tid, topic1.topicData.tid], 1, (err, teasers) => {
				assert.ifError(err);
				assert(2, teasers.length);
				assert.equal(teasers[1].content, 'reply 1 content');
				done();
			});
		});

		it('should return empty array ', (done) => {
			topics.getTeasersByTids([], 1, (err, teasers) => {
				assert.ifError(err);
				assert.equal(0, teasers.length);
				done();
			});
		});

		it('should get teaser by tid', (done) => {
			topics.getTeaser(topic2.topicData.tid, 1, (err, teaser) => {
				assert.ifError(err);
				assert(teaser);
				assert.equal(teaser.content, 'content 2');
				done();
			});
		});

		it('should not return teaser if user is blocked', (done) => {
			let blockedUid;
			async.waterfall([
				function (next) {
					User.create({ username: 'blocked' }, next);
				},
				function (uid, next) {
					blockedUid = uid;
					User.blocks.add(uid, adminUid, next);
				},
				function (next) {
					topics.reply({ uid: blockedUid, content: 'post from blocked user', tid: topic2.topicData.tid }, next);
				},
				function (result, next) {
					topics.getTeaser(topic2.topicData.tid, adminUid, next);
				},
				function (teaser, next) {
					assert.equal(teaser.content, 'content 2');
					User.blocks.remove(blockedUid, adminUid, next);
				},
			], done);
		});
	});

	describe('tag privilege', () => {
		let uid;
		let cid;
		before((done) => {
			async.waterfall([
				function (next) {
					User.create({ username: 'tag_poster' }, next);
				},
				function (_uid, next) {
					uid = _uid;
					categories.create({ name: 'tag category' }, next);
				},
				function (categoryObj, next) {
					cid = categoryObj.cid;
					next();
				},
			], done);
		});

		it('should fail to post if user does not have tag privilege', (done) => {
			privileges.categories.rescind(['groups:topics:tag'], cid, 'registered-users', (err) => {
				assert.ifError(err);
				topics.post({ uid: uid, cid: cid, tags: ['tag1'], title: 'topic with tags', content: 'some content here' }, (err) => {
					assert.equal(err.message, '[[error:no-privileges]]');
					done();
				});
			});
		});

		it('should fail to edit if user does not have tag privilege', (done) => {
			topics.post({ uid: uid, cid: cid, title: 'topic with tags', content: 'some content here' }, (err, result) => {
				assert.ifError(err);
				const { pid } = result.postData;
				posts.edit({ pid: pid, uid: uid, content: 'edited content', tags: ['tag2'] }, (err) => {
					assert.equal(err.message, '[[error:no-privileges]]');
					done();
				});
			});
		});

		it('should be able to edit topic and add tags if allowed', (done) => {
			privileges.categories.give(['groups:topics:tag'], cid, 'registered-users', (err) => {
				assert.ifError(err);
				topics.post({ uid: uid, cid: cid, tags: ['tag1'], title: 'topic with tags', content: 'some content here' }, (err, result) => {
					assert.ifError(err);
					posts.edit({ pid: result.postData.pid, uid: uid, content: 'edited content', tags: ['tag1', 'tag2'] }, (err, result) => {
						assert.ifError(err);
						const tags = result.topic.tags.map(tag => tag.value);
						assert(tags.includes('tag1'));
						assert(tags.includes('tag2'));
						done();
					});
				});
			});
		});
	});

	describe('topic merge', () => {
		let uid;
		let topic1Data;
		let topic2Data;

		async function getTopic(tid) {
			const topicData = await topics.getTopicData(tid);
			return await topics.getTopicWithPosts(topicData, `tid:${topicData.tid}:posts`, adminUid, 0, 19, false);
		}

		before((done) => {
			async.waterfall([
				function (next) {
					User.create({ username: 'mergevictim' }, next);
				},
				function (_uid, next) {
					uid = _uid;
					topics.post({ uid: uid, cid: categoryObj.cid, title: 'topic 1', content: 'topic 1 OP' }, next);
				},
				function (result, next) {
					topic1Data = result.topicData;
					topics.post({ uid: uid, cid: categoryObj.cid, title: 'topic 2', content: 'topic 2 OP' }, next);
				},
				function (result, next) {
					topic2Data = result.topicData;
					topics.reply({ uid: uid, content: 'topic 1 reply', tid: topic1Data.tid }, next);
				},
				function (postData, next) {
					topics.reply({ uid: uid, content: 'topic 2 reply', tid: topic2Data.tid }, next);
				},
			], done);
		});

		it('should error if data is not an array', (done) => {
			socketTopics.merge({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if user does not have privileges', (done) => {
			socketTopics.merge({ uid: 0 }, { tids: [topic2Data.tid, topic1Data.tid] }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should merge 2 topics', async () => {
			await socketTopics.merge({ uid: adminUid }, {
				tids: [topic2Data.tid, topic1Data.tid],
			});

			const [topic1, topic2] = await Promise.all([
				getTopic(topic1Data.tid),
				getTopic(topic2Data.tid),
			]);

			assert.equal(topic1.posts.length, 4);
			assert.equal(topic2.posts.length, 0);
			assert.equal(topic2.deleted, true);

			assert.equal(topic1.posts[0].content, 'topic 1 OP');
			assert.equal(topic1.posts[1].content, 'topic 2 OP');
			assert.equal(topic1.posts[2].content, 'topic 1 reply');
			assert.equal(topic1.posts[3].content, 'topic 2 reply');
			assert.equal(topic1.title, 'topic 1');
		});

		it('should return properly for merged topic', (done) => {
			request(`${nconf.get('url')}/api/topic/${topic2Data.slug}`, { jar: adminJar, json: true }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert(body);
				assert.deepStrictEqual(body.posts, []);
				done();
			});
		});

		it('should merge 2 topics with options mainTid', async () => {
			const topic1Result = await topics.post({ uid: uid, cid: categoryObj.cid, title: 'topic 1', content: 'topic 1 OP' });
			const topic2Result = await topics.post({ uid: uid, cid: categoryObj.cid, title: 'topic 2', content: 'topic 2 OP' });
			await topics.reply({ uid: uid, content: 'topic 1 reply', tid: topic1Result.topicData.tid });
			await topics.reply({ uid: uid, content: 'topic 2 reply', tid: topic2Result.topicData.tid });
			await socketTopics.merge({ uid: adminUid }, {
				tids: [topic2Result.topicData.tid, topic1Result.topicData.tid],
				options: {
					mainTid: topic2Result.topicData.tid,
				},
			});

			const [topic1, topic2] = await Promise.all([
				getTopic(topic1Result.topicData.tid),
				getTopic(topic2Result.topicData.tid),
			]);

			assert.equal(topic1.posts.length, 0);
			assert.equal(topic2.posts.length, 4);
			assert.equal(topic1.deleted, true);

			assert.equal(topic2.posts[0].content, 'topic 2 OP');
			assert.equal(topic2.posts[1].content, 'topic 1 OP');
			assert.equal(topic2.posts[2].content, 'topic 1 reply');
			assert.equal(topic2.posts[3].content, 'topic 2 reply');
			assert.equal(topic2.title, 'topic 2');
		});

		it('should merge 2 topics with options newTopicTitle', async () => {
			const topic1Result = await topics.post({ uid: uid, cid: categoryObj.cid, title: 'topic 1', content: 'topic 1 OP' });
			const topic2Result = await topics.post({ uid: uid, cid: categoryObj.cid, title: 'topic 2', content: 'topic 2 OP' });
			await topics.reply({ uid: uid, content: 'topic 1 reply', tid: topic1Result.topicData.tid });
			await topics.reply({ uid: uid, content: 'topic 2 reply', tid: topic2Result.topicData.tid });
			const mergeTid = await socketTopics.merge({ uid: adminUid }, {
				tids: [topic2Result.topicData.tid, topic1Result.topicData.tid],
				options: {
					newTopicTitle: 'new merge topic',
				},
			});

			const [topic1, topic2, topic3] = await Promise.all([
				getTopic(topic1Result.topicData.tid),
				getTopic(topic2Result.topicData.tid),
				getTopic(mergeTid),
			]);

			assert.equal(topic1.posts.length, 0);
			assert.equal(topic2.posts.length, 0);
			assert.equal(topic3.posts.length, 4);
			assert.equal(topic1.deleted, true);
			assert.equal(topic2.deleted, true);

			assert.equal(topic3.posts[0].content, 'topic 1 OP');
			assert.equal(topic3.posts[1].content, 'topic 2 OP');
			assert.equal(topic3.posts[2].content, 'topic 1 reply');
			assert.equal(topic3.posts[3].content, 'topic 2 reply');
			assert.equal(topic3.title, 'new merge topic');
		});
	});

	describe('sorted topics', () => {
		it('should get sorted topics in category', (done) => {
			const filters = ['', 'watched', 'unreplied', 'new'];
			async.map(filters, (filter, next) => {
				topics.getSortedTopics({
					cids: [topic.categoryId],
					uid: topic.userId,
					start: 0,
					stop: -1,
					filter: filter,
					sort: 'votes',
				}, next);
			}, (err, data) => {
				assert.ifError(err);
				assert(data);
				data.forEach((filterTopics) => {
					assert(Array.isArray(filterTopics.topics));
				});
				done();
'use strict';


const assert = require('assert');
const async = require('async');
const nconf = require('nconf');
const request = require('request');
const util = require('util');

const db = require('./mocks/databasemock');
const user = require('../src/user');
const utils = require('../src/utils');
const meta = require('../src/meta');
const privileges = require('../src/privileges');
const helpers = require('./helpers');

describe('authentication', () => {
	function loginUser(username, password, callback) {
		const jar = request.jar();
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			jar: jar,
		}, (err, response, body) => {
			if (err) {
				return callback(err);
			}

			request.post(`${nconf.get('url')}/login`, {
				form: {
					username: username,
					password: password,
				},
				json: true,
				jar: jar,
				headers: {
					'x-csrf-token': body.csrf_token,
				},
			}, (err, response, body) => {
				callback(err, response, body, jar);
			});
		});
	}
	const loginUserPromisified = util.promisify(loginUser);

	function registerUser(email, username, password, callback) {
		const jar = request.jar();
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			jar: jar,
		}, (err, response, body) => {
			if (err) {
				return callback(err);
			}

			request.post(`${nconf.get('url')}/register`, {
				form: {
					email: email,
					username: username,
					password: password,
					'password-confirm': password,
					gdpr_consent: true,
				},
				json: true,
				jar: jar,
				headers: {
					'x-csrf-token': body.csrf_token,
				},
			}, (err, response, body) => {
				callback(err, response, body, jar);
			});
		});
	}

	const jar = request.jar();
	let regularUid;
	before((done) => {
		user.create({ username: 'regular', password: 'regularpwd', email: 'regular@nodebb.org' }, (err, uid) => {
			assert.ifError(err);
			regularUid = uid;
			done();
		});
	});

	it('should fail to create user if username is too short', (done) => {
		helpers.registerUser({
			username: 'a',
			password: '123456',
			'password-confirm': '123456',
			email: 'should@error1.com',
		}, (err, jar, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:username-too-short]]');
			done();
		});
	});

	it('should fail to create user if userslug is too short', (done) => {
		helpers.registerUser({
			username: '----a-----',
			password: '123456',
			'password-confirm': '123456',
			email: 'should@error2.com',
		}, (err, jar, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:username-too-short]]');
			done();
		});
	});

	it('should fail to create user if userslug is too short', (done) => {
		helpers.registerUser({
			username: '     a',
			password: '123456',
			'password-confirm': '123456',
			email: 'should@error3.com',
		}, (err, jar, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:username-too-short]]');
			done();
		});
	});

	it('should fail to create user if userslug is too short', (done) => {
		helpers.registerUser({
			username: 'a      ',
			password: '123456',
			'password-confirm': '123456',
			email: 'should@error4.com',
		}, (err, jar, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:username-too-short]]');
			done();
		});
	});


	it('should register and login a user', (done) => {
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			jar: jar,
		}, (err, response, body) => {
			assert.ifError(err);

			request.post(`${nconf.get('url')}/register`, {
				form: {
					email: 'admin@nodebb.org',
					username: 'admin',
					password: 'adminpwd',
					'password-confirm': 'adminpwd',
					userLang: 'it',
					gdpr_consent: true,
				},
				json: true,
				jar: jar,
				headers: {
					'x-csrf-token': body.csrf_token,
				},
			}, (err, response, body) => {
				assert.ifError(err);
				assert(body);

				request({
					url: `${nconf.get('url')}/api/self`,
					json: true,
					jar: jar,
				}, (err, response, body) => {
					assert.ifError(err);
					assert(body);
					assert.equal(body.username, 'admin');
					assert.equal(body.email, 'admin@nodebb.org');
					user.getSettings(body.uid, (err, settings) => {
						assert.ifError(err);
						assert.equal(settings.userLang, 'it');
						done();
					});
				});
			});
		});
	});

	it('should logout a user', (done) => {
		helpers.logoutUser(jar, (err) => {
			assert.ifError(err);
			request({
				url: `${nconf.get('url')}/api/me`,
				json: true,
				jar: jar,
			}, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 401);
				assert.strictEqual(body.status.code, 'not-authorised');
				done();
			});
		});
	});

	it('should login a user', (done) => {
		loginUser('regular', 'regularpwd', (err, response, body, jar) => {
			assert.ifError(err);
			assert(body);
			request({
				url: `${nconf.get('url')}/api/self`,
				json: true,
				jar: jar,
			}, (err, response, body) => {
				assert.ifError(err);
				assert(body);
				assert.equal(body.username, 'regular');
				assert.equal(body.email, 'regular@nodebb.org');
				db.getObject(`uid:${regularUid}:sessionUUID:sessionId`, (err, sessions) => {
					assert.ifError(err);
					assert(sessions);
					assert(Object.keys(sessions).length > 0);
					done();
				});
			});
		});
	});

	it('should revoke all sessions', (done) => {
		const socketAdmin = require('../src/socket.io/admin');
		db.sortedSetCard(`uid:${regularUid}:sessions`, (err, count) => {
			assert.ifError(err);
			assert(count);
			socketAdmin.deleteAllSessions({ uid: 1 }, {}, (err) => {
				assert.ifError(err);
				db.sortedSetCard(`uid:${regularUid}:sessions`, (err, count) => {
					assert.ifError(err);
					assert(!count);
					done();
				});
			});
		});
	});

	it('should fail to login if ip address is invalid', (done) => {
		const jar = request.jar();
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			jar: jar,
		}, (err, response, body) => {
			if (err) {
				return done(err);
			}

			request.post(`${nconf.get('url')}/login`, {
				form: {
					username: 'regular',
					password: 'regularpwd',
				},
				json: true,
				jar: jar,
				headers: {
					'x-csrf-token': body.csrf_token,
					'x-forwarded-for': '<script>alert("xss")</script>',
				},
			}, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 500);
				done();
			});
		});
	});

	it('should fail to login if user does not exist', (done) => {
		loginUser('doesnotexist', 'nopassword', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 403);
			assert.equal(body, '[[error:invalid-login-credentials]]');
			done();
		});
	});

	it('should fail to login if username is empty', (done) => {
		loginUser('', 'some password', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 403);
			assert.equal(body, '[[error:invalid-username-or-password]]');
			done();
		});
	});

	it('should fail to login if password is empty', (done) => {
		loginUser('someuser', '', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 403);
			assert.equal(body, '[[error:invalid-username-or-password]]');
			done();
		});
	});

	it('should fail to login if username and password are empty', (done) => {
		loginUser('', '', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 403);
			assert.equal(body, '[[error:invalid-username-or-password]]');
			done();
		});
	});

	it('should fail to login if user does not have password field in db', (done) => {
		user.create({ username: 'hasnopassword', email: 'no@pass.org' }, (err, uid) => {
			assert.ifError(err);
			loginUser('hasnopassword', 'doesntmatter', (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 403);
				assert.equal(body, '[[error:invalid-login-credentials]]');
				done();
			});
		});
	});

	it('should fail to login if password is longer than 4096', (done) => {
		let longPassword;
		for (let i = 0; i < 5000; i++) {
			longPassword += 'a';
		}
		loginUser('someuser', longPassword, (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 403);
			assert.equal(body, '[[error:password-too-long]]');
			done();
		});
	});

	it('should fail to login if local login is disabled', (done) => {
		privileges.global.rescind(['groups:local:login'], 'registered-users', (err) => {
			assert.ifError(err);
			loginUser('regular', 'regularpwd', (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 403);
				assert.equal(body, '[[error:local-login-disabled]]');
				privileges.global.give(['groups:local:login'], 'registered-users', done);
			});
		});
	});

	it('should fail to register if registraton is disabled', (done) => {
		meta.config.registrationType = 'disabled';
		registerUser('some@user.com', 'someuser', 'somepassword', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 403);
			assert.equal(body, 'Forbidden');
			done();
		});
	});

	it('should return error if invitation is not valid', (done) => {
		meta.config.registrationType = 'invite-only';
		registerUser('some@user.com', 'someuser', 'somepassword', (err, response, body) => {
			meta.config.registrationType = 'normal';
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[register:invite.error-invite-only]]');
			done();
		});
	});

	it('should fail to register if email is falsy', (done) => {
		registerUser('', 'someuser', 'somepassword', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:invalid-email]]');
			done();
		});
	});

	it('should fail to register if username is falsy or too short', (done) => {
		registerUser('some@user.com', '', 'somepassword', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:username-too-short]]');
			registerUser('some@user.com', 'a', 'somepassword', (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 400);
				assert.equal(body, '[[error:username-too-short]]');
				done();
			});
		});
	});

	it('should fail to register if username is too long', (done) => {
		registerUser('some@user.com', 'thisisareallylongusername', '123456', (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:username-too-long]]');
			done();
		});
	});

	it('should queue user if ip is used before', (done) => {
		meta.config.registrationApprovalType = 'admin-approval-ip';
		registerUser('another@user.com', 'anotheruser', 'anotherpwd', (err, response, body) => {
			meta.config.registrationApprovalType = 'normal';
			assert.ifError(err);
			assert.equal(response.statusCode, 200);
			assert.equal(body.message, '[[register:registration-added-to-queue]]');
			done();
		});
	});


	it('should be able to login with email', (done) => {
		user.create({ username: 'ginger', password: '123456', email: 'ginger@nodebb.org' }, (err) => {
			assert.ifError(err);
			loginUser('ginger@nodebb.org', '123456', (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				done();
			});
		});
	});

	it('should fail to login if login type is username and an email is sent', (done) => {
		meta.config.allowLoginWith = 'username';
		loginUser('ginger@nodebb.org', '123456', (err, response, body) => {
			meta.config.allowLoginWith = 'username-email';
			assert.ifError(err);
			assert.equal(response.statusCode, 400);
			assert.equal(body, '[[error:wrong-login-type-username]]');
			done();
		});
	});

	it('should send 200 if not logged in', (done) => {
		const jar = request.jar();
		request({
			url: `${nconf.get('url')}/api/config`,
			json: true,
			jar: jar,
		}, (err, response, body) => {
			assert.ifError(err);

			request.post(`${nconf.get('url')}/logout`, {
				form: {},
				json: true,
				jar: jar,
				headers: {
					'x-csrf-token': body.csrf_token,
				},
			}, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(body, 'not-logged-in');
				done();
			});
		});
	});

	describe('banned user authentication', () => {
		const bannedUser = {
			username: 'banme',
			pw: '123456',
			uid: null,
		};

		before(async () => {
			bannedUser.uid = await user.create({ username: 'banme', password: '123456', email: 'ban@me.com' });
		});

		it('should prevent banned user from logging in', (done) => {
			user.bans.ban(bannedUser.uid, 0, 'spammer', (err) => {
				assert.ifError(err);
				loginUser(bannedUser.username, bannedUser.pw, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 403);
					assert.equal(body, '[[error:user-banned-reason, spammer]]');
					user.bans.unban(bannedUser.uid, (err) => {
						assert.ifError(err);
						const expiry = Date.now() + 10000;
						user.bans.ban(bannedUser.uid, expiry, '', (err) => {
							assert.ifError(err);
							loginUser(bannedUser.username, bannedUser.pw, (err, res, body) => {
								assert.ifError(err);
								assert.equal(res.statusCode, 403);
								assert.equal(body, `[[error:user-banned-reason-until, ${utils.toISOString(expiry)}, No reason given.]]`);
								done();
							});
						});
					});
				});
			});
		});

		it('should allow banned user to log in if the "banned-users" group has "local-login" privilege', async () => {
			await privileges.global.give(['groups:local:login'], 'banned-users');
			const res = await loginUserPromisified(bannedUser.username, bannedUser.pw);
			assert.strictEqual(res.statusCode, 200);
		});

		it('should allow banned user to log in if the user herself has "local-login" privilege', async () => {
			await privileges.global.rescind(['groups:local:login'], 'banned-users');
			await privileges.categories.give(['local:login'], 0, bannedUser.uid);
			const res = await loginUserPromisified(bannedUser.username, bannedUser.pw);
			assert.strictEqual(res.statusCode, 200);
		});
	});

	it('should lockout account on 3 failed login attempts', (done) => {
		meta.config.loginAttempts = 3;
		let uid;
		async.waterfall([
			function (next) {
				user.create({ username: 'lockme', password: '123456' }, next);
			},
			function (_uid, next) {
				uid = _uid;
				loginUser('lockme', 'abcdef', next);
			},
			function (res, body, jar, next) {
				loginUser('lockme', 'abcdef', next);
			},
			function (res, body, jar, next) {
				loginUser('lockme', 'abcdef', next);
			},
			function (res, body, jar, next) {
				loginUser('lockme', 'abcdef', next);
			},
			function (res, body, jar, next) {
				meta.config.loginAttempts = 5;
				assert.equal(res.statusCode, 403);
				assert.equal(body, '[[error:account-locked]]');
				loginUser('lockme', 'abcdef', next);
			},
			function (res, body, jar, next) {
				assert.equal(res.statusCode, 403);
				assert.equal(body, '[[error:account-locked]]');
				db.exists(`lockout:${uid}`, next);
			},
			function (locked, next) {
				assert(locked);
				next();
'use strict';


const	async = require('async');
const assert = require('assert');
const db = require('../mocks/databasemock');

describe('Key methods', () => {
	beforeEach((done) => {
		db.set('testKey', 'testValue', done);
	});

	it('should set a key without error', (done) => {
		db.set('testKey', 'testValue', function (err) {
			assert.ifError(err);
			assert(arguments.length < 2);
			done();
		});
	});

	it('should get a key without error', (done) => {
		db.get('testKey', function (err, value) {
			assert.ifError(err);
			assert.equal(arguments.length, 2);
			assert.strictEqual(value, 'testValue');
			done();
		});
	});

	it('should return null if key does not exist', (done) => {
		db.get('doesnotexist', (err, value) => {
			assert.ifError(err);
			assert.equal(value, null);
			done();
		});
	});

	it('should return true if key exist', (done) => {
		db.exists('testKey', function (err, exists) {
			assert.ifError(err);
			assert.equal(arguments.length, 2);
			assert.strictEqual(exists, true);
			done();
		});
	});

	it('should return false if key does not exist', (done) => {
		db.exists('doesnotexist', function (err, exists) {
			assert.ifError(err);
			assert.equal(arguments.length, 2);
			assert.strictEqual(exists, false);
			done();
		});
	});

	it('should work for an array of keys', (done) => {
		db.exists(['testKey', 'doesnotexist'], (err, exists) => {
			assert.ifError(err);
			assert.deepStrictEqual(exists, [true, false]);
			done();
		});
	});

	describe('scan', () => {
		it('should scan keys for pattern', async () => {
			await db.sortedSetAdd('ip:123:uid', 1, 'a');
			await db.sortedSetAdd('ip:123:uid', 2, 'b');
			await db.sortedSetAdd('ip:124:uid', 2, 'b');
			await db.sortedSetAdd('ip:1:uid', 1, 'a');
			await db.sortedSetAdd('ip:23:uid', 1, 'a');
			const data = await db.scan({ match: 'ip:1*' });
			assert.equal(data.length, 3);
			assert(data.includes('ip:123:uid'));
			assert(data.includes('ip:124:uid'));
			assert(data.includes('ip:1:uid'));
		});
	});

	it('should delete a key without error', (done) => {
		db.delete('testKey', function (err) {
			assert.ifError(err);
			assert(arguments.length < 2);

			db.get('testKey', (err, value) => {
				assert.ifError(err);
				assert.equal(false, !!value);
				done();
			});
		});
	});

	it('should return false if key was deleted', (done) => {
		db.delete('testKey', function (err) {
			assert.ifError(err);
			assert(arguments.length < 2);
			db.exists('testKey', (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(exists, false);
				done();
			});
		});
	});

	it('should delete all keys passed in', (done) => {
		async.parallel([
			function (next) {
				db.set('key1', 'value1', next);
			},
			function (next) {
				db.set('key2', 'value2', next);
			},
		], (err) => {
			if (err) {
				return done(err);
			}
			db.deleteAll(['key1', 'key2'], function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				async.parallel({
					key1exists: function (next) {
						db.exists('key1', next);
					},
					key2exists: function (next) {
						db.exists('key2', next);
					},
				}, (err, results) => {
					assert.ifError(err);
					assert.equal(results.key1exists, false);
					assert.equal(results.key2exists, false);
					done();
				});
			});
		});
	});

	it('should delete all sorted set elements', (done) => {
		async.parallel([
			function (next) {
				db.sortedSetAdd('deletezset', 1, 'value1', next);
			},
			function (next) {
				db.sortedSetAdd('deletezset', 2, 'value2', next);
			},
		], (err) => {
			if (err) {
				return done(err);
			}
			db.delete('deletezset', (err) => {
				assert.ifError(err);
				async.parallel({
					key1exists: function (next) {
						db.isSortedSetMember('deletezset', 'value1', next);
					},
					key2exists: function (next) {
						db.isSortedSetMember('deletezset', 'value2', next);
					},
				}, (err, results) => {
					assert.ifError(err);
					assert.equal(results.key1exists, false);
					assert.equal(results.key2exists, false);
					done();
				});
			});
		});
	});

	describe('increment', () => {
		it('should initialize key to 1', (done) => {
			db.increment('keyToIncrement', (err, value) => {
				assert.ifError(err);
				assert.strictEqual(parseInt(value, 10), 1);
				done();
			});
		});

		it('should increment key to 2', (done) => {
			db.increment('keyToIncrement', (err, value) => {
				assert.ifError(err);
				assert.strictEqual(parseInt(value, 10), 2);
				done();
			});
		});

		it('should set then increment a key', (done) => {
			db.set('myIncrement', 1, (err) => {
				assert.ifError(err);
				db.increment('myIncrement', (err, value) => {
					assert.ifError(err);
					assert.equal(value, 2);
					db.get('myIncrement', (err, value) => {
						assert.ifError(err);
						assert.equal(value, 2);
						done();
					});
				});
			});
		});

		it('should return the correct value', (done) => {
			db.increment('testingCache', (err) => {
				assert.ifError(err);
				db.get('testingCache', (err, value) => {
					assert.ifError(err);
					assert.equal(value, 1);
					db.increment('testingCache', (err) => {
						assert.ifError(err);
						db.get('testingCache', (err, value) => {
							assert.ifError(err);
							assert.equal(value, 2);
							done();
						});
					});
				});
			});
		});
	});

	describe('rename', () => {
		it('should rename key to new name', (done) => {
			db.set('keyOldName', 'renamedKeyValue', (err) => {
				if (err) {
					return done(err);
				}
				db.rename('keyOldName', 'keyNewName', function (err) {
					assert.ifError(err);
					assert(arguments.length < 2);

					db.get('keyNewName', (err, value) => {
						assert.ifError(err);
						assert.equal(value, 'renamedKeyValue');
						done();
					});
				});
			});
		});

		it('should rename multiple keys', (done) => {
			db.sortedSetAdd('zsettorename', [1, 2, 3], ['value1', 'value2', 'value3'], (err) => {
				assert.ifError(err);
				db.rename('zsettorename', 'newzsetname', (err) => {
					assert.ifError(err);
					db.exists('zsettorename', (err, exists) => {
						assert.ifError(err);
						assert(!exists);
						db.getSortedSetRange('newzsetname', 0, -1, (err, values) => {
							assert.ifError(err);
							assert.deepEqual(['value1', 'value2', 'value3'], values);
							done();
						});
					});
				});
			});
		});

		it('should not error if old key does not exist', (done) => {
			db.rename('doesnotexist', 'anotherdoesnotexist', (err) => {
				assert.ifError(err);
				db.exists('anotherdoesnotexist', (err, exists) => {
					assert.ifError(err);
					assert(!exists);
					done();
				});
			});
		});
	});

	describe('type', () => {
		it('should return null if key does not exist', (done) => {
			db.type('doesnotexist', (err, type) => {
				assert.ifError(err);
				assert.strictEqual(type, null);
				done();
			});
		});

		it('should return hash as type', (done) => {
			db.setObject('typeHash', { foo: 1 }, (err) => {
				assert.ifError(err);
				db.type('typeHash', (err, type) => {
					assert.ifError(err);
					assert.equal(type, 'hash');
					done();
				});
			});
		});

		it('should return zset as type', (done) => {
			db.sortedSetAdd('typeZset', 123, 'value1', (err) => {
				assert.ifError(err);
				db.type('typeZset', (err, type) => {
					assert.ifError(err);
					assert.equal(type, 'zset');
					done();
				});
			});
		});

		it('should return set as type', (done) => {
			db.setAdd('typeSet', 'value1', (err) => {
				assert.ifError(err);
				db.type('typeSet', (err, type) => {
					assert.ifError(err);
					assert.equal(type, 'set');
					done();
				});
			});
		});

		it('should return list as type', (done) => {
			db.listAppend('typeList', 'value1', (err) => {
				assert.ifError(err);
				db.type('typeList', (err, type) => {
					assert.ifError(err);
					assert.equal(type, 'list');
					done();
				});
			});
		});

		it('should return string as type', (done) => {
			db.set('typeString', 'value1', (err) => {
				assert.ifError(err);
				db.type('typeString', (err, type) => {
					assert.ifError(err);
					assert.equal(type, 'string');
					done();
				});
			});
		});

		it('should expire a key using seconds', (done) => {
			db.expire('testKey', 86400, (err) => {
				assert.ifError(err);
				db.ttl('testKey', (err, ttl) => {
					assert.ifError(err);
					assert.equal(Math.round(86400 / 1000), Math.round(ttl / 1000));
					done();
				});
			});
		});

		it('should expire a key using milliseconds', (done) => {
			db.pexpire('testKey', 86400000, (err) => {
				assert.ifError(err);
				db.pttl('testKey', (err, pttl) => {
					assert.ifError(err);
					assert.equal(Math.round(86400000 / 1000000), Math.round(pttl / 1000000));
					done();
				});
			});
'use strict';


const	async = require('async');
const assert = require('assert');
const db = require('../mocks/databasemock');

describe('Set methods', () => {
	describe('setAdd()', () => {
		it('should add to a set', (done) => {
			db.setAdd('testSet1', 5, function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should add an array to a set', (done) => {
			db.setAdd('testSet1', [1, 2, 3, 4], function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should not do anything if values array is empty', async () => {
			await db.setAdd('emptyArraySet', []);
			const members = await db.getSetMembers('emptyArraySet');
			const exists = await db.exists('emptyArraySet');
			assert.deepStrictEqual(members, []);
			assert(!exists);
		});
	});

	describe('getSetMembers()', () => {
		before((done) => {
			db.setAdd('testSet2', [1, 2, 3, 4, 5], done);
		});

		it('should return an empty set', (done) => {
			db.getSetMembers('doesnotexist', function (err, set) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(set), true);
				assert.equal(set.length, 0);
				done();
			});
		});

		it('should return a set with all elements', (done) => {
			db.getSetMembers('testSet2', (err, set) => {
				assert.equal(err, null);
				assert.equal(set.length, 5);
				set.forEach((value) => {
					assert.notEqual(['1', '2', '3', '4', '5'].indexOf(value), -1);
				});

				done();
			});
		});
	});

	describe('setsAdd()', () => {
		it('should add to multiple sets', (done) => {
			db.setsAdd(['set1', 'set2'], 'value', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should not error if keys is empty array', (done) => {
			db.setsAdd([], 'value', (err) => {
				assert.ifError(err);
				done();
			});
		});
	});

	describe('getSetsMembers()', () => {
		before((done) => {
			db.setsAdd(['set3', 'set4'], 'value', done);
		});

		it('should return members of two sets', (done) => {
			db.getSetsMembers(['set3', 'set4'], function (err, sets) {
				assert.equal(err, null);
				assert.equal(Array.isArray(sets), true);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(sets[0]) && Array.isArray(sets[1]), true);
				assert.strictEqual(sets[0][0], 'value');
				assert.strictEqual(sets[1][0], 'value');
				done();
			});
		});
	});

	describe('isSetMember()', () => {
		before((done) => {
			db.setAdd('testSet3', 5, done);
		});

		it('should return false if element is not member of set', (done) => {
			db.isSetMember('testSet3', 10, function (err, isMember) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(isMember, false);
				done();
			});
		});

		it('should return true if element is a member of set', (done) => {
			db.isSetMember('testSet3', 5, function (err, isMember) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(isMember, true);
				done();
			});
		});
	});

	describe('isSetMembers()', () => {
		before((done) => {
			db.setAdd('testSet4', [1, 2, 3, 4, 5], done);
		});

		it('should return an array of booleans', (done) => {
			db.isSetMembers('testSet4', ['1', '2', '10', '3'], function (err, members) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(members), true);
				assert.deepEqual(members, [true, true, false, true]);
				done();
			});
		});
	});

	describe('isMemberOfSets()', () => {
		before((done) => {
			db.setsAdd(['set1', 'set2'], 'value', done);
		});

		it('should return an array of booleans', (done) => {
			db.isMemberOfSets(['set1', 'testSet1', 'set2', 'doesnotexist'], 'value', function (err, members) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(members), true);
				assert.deepEqual(members, [true, false, true, false]);
				done();
			});
		});
	});

	describe('setCount()', () => {
		before((done) => {
			db.setAdd('testSet5', [1, 2, 3, 4, 5], done);
		});

		it('should return the element count of set', (done) => {
			db.setCount('testSet5', function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(count, 5);
				done();
			});
		});

		it('should return 0 if set does not exist', (done) => {
			db.setCount('doesnotexist', (err, count) => {
				assert.ifError(err);
				assert.strictEqual(count, 0);
				done();
			});
		});
	});

	describe('setsCount()', () => {
		before((done) => {
			async.parallel([
				async.apply(db.setAdd, 'set5', [1, 2, 3, 4, 5]),
				async.apply(db.setAdd, 'set6', 1),
				async.apply(db.setAdd, 'set7', 2),
			], done);
		});

		it('should return the element count of sets', (done) => {
			db.setsCount(['set5', 'set6', 'set7', 'doesnotexist'], function (err, counts) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(counts), true);
				assert.deepEqual(counts, [5, 1, 1, 0]);
				done();
			});
		});
	});

	describe('setRemove()', () => {
		before((done) => {
			db.setAdd('testSet6', [1, 2], done);
		});

		it('should remove a element from set', (done) => {
			db.setRemove('testSet6', '2', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);

				db.isSetMember('testSet6', '2', (err, isMember) => {
					assert.equal(err, null);
					assert.equal(isMember, false);
					done();
				});
			});
		});

		it('should remove multiple elements from set', (done) => {
			db.setAdd('multiRemoveSet', [1, 2, 3, 4, 5], (err) => {
				assert.ifError(err);
				db.setRemove('multiRemoveSet', [1, 3, 5], (err) => {
					assert.ifError(err);
					db.getSetMembers('multiRemoveSet', (err, members) => {
						assert.ifError(err);
						assert(members.includes('2'));
						assert(members.includes('4'));
						done();
					});
				});
			});
		});

		it('should remove multiple values from multiple keys', (done) => {
			db.setAdd('multiSetTest1', ['one', 'two', 'three', 'four'], (err) => {
				assert.ifError(err);
				db.setAdd('multiSetTest2', ['three', 'four', 'five', 'six'], (err) => {
					assert.ifError(err);
					db.setRemove(['multiSetTest1', 'multiSetTest2'], ['three', 'four', 'five', 'doesnt exist'], (err) => {
						assert.ifError(err);
						db.getSetsMembers(['multiSetTest1', 'multiSetTest2'], (err, members) => {
							assert.ifError(err);
							assert.equal(members[0].length, 2);
							assert.equal(members[1].length, 1);
							assert(members[0].includes('one'));
							assert(members[0].includes('two'));
							assert(members[1].includes('six'));
							done();
						});
					});
				});
			});
		});
	});

	describe('setsRemove()', () => {
		before((done) => {
			db.setsAdd(['set1', 'set2'], 'value', done);
		});

		it('should remove a element from multiple sets', (done) => {
			db.setsRemove(['set1', 'set2'], 'value', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				db.isMemberOfSets(['set1', 'set2'], 'value', (err, members) => {
					assert.equal(err, null);
					assert.deepEqual(members, [false, false]);
					done();
				});
			});
		});
	});

	describe('setRemoveRandom()', () => {
		before((done) => {
			db.setAdd('testSet7', [1, 2, 3, 4, 5], done);
		});

		it('should remove a random element from set', (done) => {
			db.setRemoveRandom('testSet7', function (err, element) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);

				db.isSetMember('testSet', element, (err, ismember) => {
					assert.equal(err, null);
					assert.equal(ismember, false);
					done();
				});
			});
'use strict';


const	async = require('async');
const assert = require('assert');
const db = require('../mocks/databasemock');

describe('List methods', () => {
	describe('listAppend()', () => {
		it('should append to a list', (done) => {
			db.listAppend('testList1', 5, function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should not add anyhing if key is falsy', (done) => {
			db.listAppend(null, 3, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should append each element to list', async () => {
			await db.listAppend('arrayListAppend', ['a', 'b', 'c']);
			let values = await db.getListRange('arrayListAppend', 0, -1);
			assert.deepStrictEqual(values, ['a', 'b', 'c']);

			await db.listAppend('arrayListAppend', ['d', 'e']);
			values = await db.getListRange('arrayListAppend', 0, -1);
			assert.deepStrictEqual(values, ['a', 'b', 'c', 'd', 'e']);
		});
	});

	describe('listPrepend()', () => {
		it('should prepend to a list', (done) => {
			db.listPrepend('testList2', 3, function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should prepend 2 more elements to a list', (done) => {
			async.series([
				function (next) {
					db.listPrepend('testList2', 2, next);
				},
				function (next) {
					db.listPrepend('testList2', 1, next);
				},
			], (err) => {
				assert.equal(err, null);
				done();
			});
		});

		it('should not add anyhing if key is falsy', (done) => {
			db.listPrepend(null, 3, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should prepend each element to list', async () => {
			await db.listPrepend('arrayListPrepend', ['a', 'b', 'c']);
			let values = await db.getListRange('arrayListPrepend', 0, -1);
			assert.deepStrictEqual(values, ['c', 'b', 'a']);

			await db.listPrepend('arrayListPrepend', ['d', 'e']);
			values = await db.getListRange('arrayListPrepend', 0, -1);
			assert.deepStrictEqual(values, ['e', 'd', 'c', 'b', 'a']);
		});
	});

	describe('getListRange()', () => {
		before((done) => {
			async.series([
				function (next) {
					db.listAppend('testList3', 7, next);
				},
				function (next) {
					db.listPrepend('testList3', 3, next);
				},
				function (next) {
					db.listAppend('testList4', 5, next);
				},
			], done);
		});

		it('should return an empty list', (done) => {
			db.getListRange('doesnotexist', 0, -1, function (err, list) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(list), true);
				assert.equal(list.length, 0);
				done();
			});
		});

		it('should return a list with one element', (done) => {
			db.getListRange('testList4', 0, 0, (err, list) => {
				assert.equal(err, null);
				assert.equal(Array.isArray(list), true);
				assert.equal(list[0], 5);
				done();
			});
		});

		it('should return a list with 2 elements 3, 7', (done) => {
			db.getListRange('testList3', 0, -1, (err, list) => {
				assert.equal(err, null);
				assert.equal(Array.isArray(list), true);
				assert.equal(list.length, 2);
				assert.deepEqual(list, ['3', '7']);
				done();
			});
		});

		it('should not get anything if key is falsy', (done) => {
			db.getListRange(null, 0, -1, (err, data) => {
				assert.ifError(err);
				assert.equal(data, undefined);
				done();
			});
		});
	});

	describe('listRemoveLast()', () => {
		before((done) => {
			async.series([
				function (next) {
					db.listAppend('testList7', 12, next);
				},
				function (next) {
					db.listPrepend('testList7', 9, next);
				},
			], done);
		});

		it('should remove the last element of list and return it', (done) => {
			db.listRemoveLast('testList7', function (err, lastElement) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(lastElement, '12');
				done();
			});
		});

		it('should not remove anyhing if key is falsy', (done) => {
			db.listRemoveLast(null, (err) => {
				assert.ifError(err);
				done();
			});
		});
	});

	describe('listRemoveAll()', () => {
		before((done) => {
			async.series([
				async.apply(db.listAppend, 'testList5', 1),
				async.apply(db.listAppend, 'testList5', 1),
				async.apply(db.listAppend, 'testList5', 1),
				async.apply(db.listAppend, 'testList5', 2),
				async.apply(db.listAppend, 'testList5', 5),
			], done);
		});

		it('should remove all the matching elements of list', (done) => {
			db.listRemoveAll('testList5', '1', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);

				db.getListRange('testList5', 0, -1, (err, list) => {
					assert.equal(err, null);
					assert.equal(Array.isArray(list), true);
					assert.equal(list.length, 2);
					assert.equal(list.indexOf('1'), -1);
					done();
				});
			});
		});

		it('should not remove anyhing if key is falsy', (done) => {
			db.listRemoveAll(null, 3, (err) => {
				assert.ifError(err);
				done();
			});
		});
	});

	describe('listTrim()', () => {
		it('should trim list to a certain range', (done) => {
			const list = ['1', '2', '3', '4', '5'];
			async.eachSeries(list, (value, next) => {
				db.listAppend('testList6', value, next);
			}, (err) => {
				if (err) {
					return done(err);
				}

				db.listTrim('testList6', 0, 2, function (err) {
					assert.equal(err, null);
					assert.equal(arguments.length, 1);
					db.getListRange('testList6', 0, -1, (err, list) => {
						assert.equal(err, null);
						assert.equal(list.length, 3);
						assert.deepEqual(list, ['1', '2', '3']);
						done();
					});
				});
			});
		});

		it('should not add anyhing if key is falsy', (done) => {
			db.listTrim(null, 0, 3, (err) => {
				assert.ifError(err);
				done();
			});
		});
	});

	describe('listLength', () => {
		it('should get the length of a list', (done) => {
			db.listAppend('getLengthList', 1, (err) => {
				assert.ifError(err);
				db.listAppend('getLengthList', 2, (err) => {
					assert.ifError(err);
					db.listLength('getLengthList', (err, length) => {
						assert.ifError(err);
						assert.equal(length, 2);
						done();
					});
				});
			});
		});

		it('should return 0 if list does not have any elements', (done) => {
			db.listLength('doesnotexist', (err, length) => {
				assert.ifError(err);
				assert.strictEqual(length, 0);
				done();
			});
		});
'use strict';


const	async = require('async');
const assert = require('assert');
const db = require('../mocks/databasemock');

describe('Sorted Set methods', () => {
	before((done) => {
		async.parallel([
			function (next) {
				db.sortedSetAdd('sortedSetTest1', [1.1, 1.2, 1.3], ['value1', 'value2', 'value3'], next);
			},
			function (next) {
				db.sortedSetAdd('sortedSetTest2', [1, 4], ['value1', 'value4'], next);
			},
			function (next) {
				db.sortedSetAdd('sortedSetTest3', [2, 4], ['value2', 'value4'], next);
			},
			function (next) {
				db.sortedSetAdd('sortedSetTest4', [1, 1, 2, 3, 5], ['b', 'a', 'd', 'e', 'c'], next);
			},
			function (next) {
				db.sortedSetAdd('sortedSetLex', [0, 0, 0, 0], ['a', 'b', 'c', 'd'], next);
			},
		], done);
	});

	describe('sortedSetScan', () => {
		it('should find matches in sorted set containing substring', async () => {
			await db.sortedSetAdd('scanzset', [1, 2, 3, 4, 5, 6], ['aaaa', 'bbbb', 'bbcc', 'ddd', 'dddd', 'fghbc']);
			const data = await db.getSortedSetScan({
				key: 'scanzset',
				match: '*bc*',
			});
			assert(data.includes('bbcc'));
			assert(data.includes('fghbc'));
		});

		it('should find matches in sorted set with scores', async () => {
			const data = await db.getSortedSetScan({
				key: 'scanzset',
				match: '*bc*',
				withScores: true,
			});
			data.sort((a, b) => a.score - b.score);
			assert.deepStrictEqual(data, [{ value: 'bbcc', score: 3 }, { value: 'fghbc', score: 6 }]);
		});

		it('should find matches in sorted set with a limit', async () => {
			await db.sortedSetAdd('scanzset2', [1, 2, 3, 4, 5, 6], ['aaab', 'bbbb', 'bbcb', 'ddb', 'dddd', 'fghbc']);
			const data = await db.getSortedSetScan({
				key: 'scanzset2',
				match: '*b*',
				limit: 2,
			});
			assert.equal(data.length, 2);
		});

		it('should work for special characters', async () => {
			await db.sortedSetAdd('scanzset3', [1, 2, 3, 4, 5], ['aaab{', 'bbbb', 'bbcb{', 'ddb', 'dddd']);
			const data = await db.getSortedSetScan({
				key: 'scanzset3',
				match: '*b{',
				limit: 2,
			});
			assert(data.includes('aaab{'));
			assert(data.includes('bbcb{'));
		});

		it('should find everything starting with string', async () => {
			await db.sortedSetAdd('scanzset4', [1, 2, 3, 4, 5], ['aaab{', 'bbbb', 'bbcb', 'ddb', 'dddd']);
			const data = await db.getSortedSetScan({
				key: 'scanzset4',
				match: 'b*',
				limit: 2,
			});
			assert(data.includes('bbbb'));
			assert(data.includes('bbcb'));
		});

		it('should find everything ending with string', async () => {
			await db.sortedSetAdd('scanzset5', [1, 2, 3, 4, 5, 6], ['aaab{', 'bbbb', 'bbcb', 'ddb', 'dddd', 'adb']);
			const data = await db.getSortedSetScan({
				key: 'scanzset5',
				match: '*db',
			});
			assert.equal(data.length, 2);
			assert(data.includes('ddb'));
			assert(data.includes('adb'));
		});
	});

	describe('sortedSetAdd()', () => {
		it('should add an element to a sorted set', (done) => {
			db.sortedSetAdd('sorted1', 1, 'value1', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should add two elements to a sorted set', (done) => {
			db.sortedSetAdd('sorted2', [1, 2], ['value1', 'value2'], function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should gracefully handle adding the same element twice', (done) => {
			db.sortedSetAdd('sorted2', [1, 2], ['value1', 'value1'], function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);

				db.sortedSetScore('sorted2', 'value1', function (err, score) {
					assert.equal(err, null);
					assert.equal(score, 2);
					assert.equal(arguments.length, 2);

					done();
				});
			});
		});

		it('should error if score is null', (done) => {
			db.sortedSetAdd('errorScore', null, 'value1', (err) => {
				assert.equal(err.message, '[[error:invalid-score, null]]');
				done();
			});
		});

		it('should error if any score is undefined', (done) => {
			db.sortedSetAdd('errorScore', [1, undefined], ['value1', 'value2'], (err) => {
				assert.equal(err.message, '[[error:invalid-score, undefined]]');
				done();
			});
		});

		it('should add null value as `null` string', (done) => {
			db.sortedSetAdd('nullValueZSet', 1, null, (err) => {
				assert.ifError(err);
				db.getSortedSetRange('nullValueZSet', 0, -1, (err, values) => {
					assert.ifError(err);
					assert.strictEqual(values[0], 'null');
					done();
				});
			});
		});
	});

	describe('sortedSetsAdd()', () => {
		it('should add an element to two sorted sets', (done) => {
			db.sortedSetsAdd(['sorted1', 'sorted2'], 3, 'value3', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it('should add an element to two sorted sets with different scores', (done) => {
			db.sortedSetsAdd(['sorted1', 'sorted2'], [4, 5], 'value4', (err) => {
				assert.ifError(err);
				db.sortedSetsScore(['sorted1', 'sorted2'], 'value4', (err, scores) => {
					assert.ifError(err);
					assert.deepStrictEqual(scores, [4, 5]);
					done();
				});
			});
		});


		it('should error if keys.length is different than scores.length', (done) => {
			db.sortedSetsAdd(['sorted1', 'sorted2'], [4], 'value4', (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if score is null', (done) => {
			db.sortedSetsAdd(['sorted1', 'sorted2'], null, 'value1', (err) => {
				assert.equal(err.message, '[[error:invalid-score, null]]');
				done();
			});
		});

		it('should error if scores has null', async () => {
			let err;
			try {
				await db.sortedSetsAdd(['sorted1', 'sorted2'], [1, null], 'dontadd');
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, '[[error:invalid-score, 1,]]');
			assert.strictEqual(await db.isSortedSetMember('sorted1', 'dontadd'), false);
			assert.strictEqual(await db.isSortedSetMember('sorted2', 'dontadd'), false);
		});
	});

	describe('sortedSetAddMulti()', () => {
		it('should add elements into multiple sorted sets with different scores', (done) => {
			db.sortedSetAddBulk([
				['bulk1', 1, 'item1'],
				['bulk2', 2, 'item1'],
				['bulk2', 3, 'item2'],
				['bulk3', 4, 'item3'],
			], function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRevRangeWithScores(['bulk1', 'bulk2', 'bulk3'], 0, -1, (err, data) => {
					assert.ifError(err);
					assert.deepStrictEqual(data, [{ value: 'item3', score: 4 },
						{ value: 'item2', score: 3 },
						{ value: 'item1', score: 2 },
						{ value: 'item1', score: 1 }]);
					done();
				});
			});
		});
		it('should not error if data is undefined', (done) => {
			db.sortedSetAddBulk(undefined, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should error if score is null', async () => {
			let err;
			try {
				await db.sortedSetAddBulk([
					['bulk4', 0, 'dontadd'],
					['bulk5', null, 'dontadd'],
				]);
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, '[[error:invalid-score, null]]');
			assert.strictEqual(await db.isSortedSetMember('bulk4', 'dontadd'), false);
			assert.strictEqual(await db.isSortedSetMember('bulk5', 'dontadd'), false);
		});
	});

	describe('getSortedSetRange()', () => {
		it('should return the lowest scored element', (done) => {
			db.getSortedSetRange('sortedSetTest1', 0, 0, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(value, ['value1']);
				done();
			});
		});

		it('should return elements sorted by score lowest to highest', (done) => {
			db.getSortedSetRange('sortedSetTest1', 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, ['value1', 'value2', 'value3']);
				done();
			});
		});

		it('should return empty array if set does not exist', (done) => {
			db.getSortedSetRange('doesnotexist', 0, -1, (err, values) => {
				assert.ifError(err);
				assert(Array.isArray(values));
				assert.equal(values.length, 0);
				done();
			});
		});

		it('should handle negative start/stop', (done) => {
			db.sortedSetAdd('negatives', [1, 2, 3, 4, 5], ['1', '2', '3', '4', '5'], (err) => {
				assert.ifError(err);
				db.getSortedSetRange('negatives', -2, -4, (err, data) => {
					assert.ifError(err);
					assert.deepEqual(data, []);
					done();
				});
			});
		});

		it('should handle negative start/stop', (done) => {
			db.getSortedSetRange('negatives', -4, -2, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['2', '3', '4']);
				done();
			});
		});

		it('should handle negative start/stop', (done) => {
			db.getSortedSetRevRange('negatives', -4, -2, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['4', '3', '2']);
				done();
			});
		});

		it('should handle negative start/stop', (done) => {
			db.getSortedSetRange('negatives', -5, -1, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['1', '2', '3', '4', '5']);
				done();
			});
		});

		it('should handle negative start/stop', (done) => {
			db.getSortedSetRange('negatives', 0, -2, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['1', '2', '3', '4']);
				done();
			});
		});

		it('should return empty array if keys is empty array', (done) => {
			db.getSortedSetRange([], 0, -1, (err, data) => {
				assert.ifError(err);
				assert.deepStrictEqual(data, []);
				done();
			});
		});

		it('should return duplicates if two sets have same elements', async () => {
			await db.sortedSetAdd('dupezset1', [1, 2], ['value 1', 'value 2']);
			await db.sortedSetAdd('dupezset2', [2, 3], ['value 2', 'value 3']);
			const data = await db.getSortedSetRange(['dupezset1', 'dupezset2'], 0, -1);
			assert.deepStrictEqual(data, ['value 1', 'value 2', 'value 2', 'value 3']);
		});

		it('should return correct number of elements', async () => {
			await db.sortedSetAdd('dupezset3', [1, 2, 3], ['value 1', 'value 2', 'value3']);
			await db.sortedSetAdd('dupezset4', [0, 5], ['value 0', 'value5']);
			const data = await db.getSortedSetRevRange(['dupezset3', 'dupezset4'], 0, 1);
			assert.deepStrictEqual(data, ['value5', 'value3']);
		});

		it('should work with big arrays (length > 100) ', async function () {
			this.timeout(50000);
			const keys = [];
			for (let i = 0; i < 400; i++) {
				/* eslint-disable no-await-in-loop */
				const bulkAdd = [];
				keys.push(`testzset${i}`);
				for (let k = 0; k < 100; k++) {
					bulkAdd.push([`testzset${i}`, 1000000 + k + (i * 100), k + (i * 100)]);
				}
				await db.sortedSetAddBulk(bulkAdd);
			}

			let data = await db.getSortedSetRevRange(keys, 0, 3);
			assert.deepStrictEqual(data, ['39999', '39998', '39997', '39996']);

			data = await db.getSortedSetRevRangeWithScores(keys, 0, 3);
			assert.deepStrictEqual(data, [
				{ value: '39999', score: 1039999 },
				{ value: '39998', score: 1039998 },
				{ value: '39997', score: 1039997 },
				{ value: '39996', score: 1039996 },
			]);

			data = await db.getSortedSetRevRange(keys, 0, -1);
			assert.equal(data.length, 40000);

			data = await db.getSortedSetRange(keys, 9998, 10002);
			assert.deepStrictEqual(data, ['9998', '9999', '10000', '10001', '10002']);
		});
	});

	describe('getSortedSetRevRange()', () => {
		it('should return the highest scored element', (done) => {
			db.getSortedSetRevRange('sortedSetTest1', 0, 0, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(value, ['value3']);
				done();
			});
		});

		it('should return elements sorted by score highest to lowest', (done) => {
			db.getSortedSetRevRange('sortedSetTest1', 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, ['value3', 'value2', 'value1']);
				done();
			});
		});
	});

	describe('getSortedSetRangeWithScores()', () => {
		it('should return array of elements sorted by score lowest to highest with scores', (done) => {
			db.getSortedSetRangeWithScores('sortedSetTest1', 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: 'value1', score: 1.1 }, { value: 'value2', score: 1.2 }, { value: 'value3', score: 1.3 }]);
				done();
			});
		});
	});

	describe('getSortedSetRevRangeWithScores()', () => {
		it('should return array of elements sorted by score highest to lowest with scores', (done) => {
			db.getSortedSetRevRangeWithScores('sortedSetTest1', 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: 'value3', score: 1.3 }, { value: 'value2', score: 1.2 }, { value: 'value1', score: 1.1 }]);
				done();
			});
		});
	});

	describe('getSortedSetRangeByScore()', () => {
		it('should get count elements with score between min max sorted by score lowest to highest', (done) => {
			db.getSortedSetRangeByScore('sortedSetTest1', 0, -1, '-inf', 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, ['value1', 'value2']);
				done();
			});
		});

		it('should return empty array if set does not exist', (done) => {
			db.getSortedSetRangeByScore('doesnotexist', 0, -1, '-inf', 0, (err, values) => {
				assert.ifError(err);
				assert(Array.isArray(values));
				assert.equal(values.length, 0);
				done();
			});
		});

		it('should return empty array if count is 0', (done) => {
			db.getSortedSetRevRangeByScore('sortedSetTest1', 0, 0, '+inf', '-inf', (err, values) => {
				assert.ifError(err);
				assert.deepEqual(values, []);
				done();
			});
		});

		it('should return elements from 1 to end', (done) => {
			db.getSortedSetRevRangeByScore('sortedSetTest1', 1, -1, '+inf', '-inf', (err, values) => {
				assert.ifError(err);
				assert.deepEqual(values, ['value2', 'value1']);
				done();
			});
		});

		it('should return elements from 3 to last', (done) => {
			db.sortedSetAdd('partialZset', [1, 2, 3, 4, 5], ['value1', 'value2', 'value3', 'value4', 'value5'], (err) => {
				assert.ifError(err);
				db.getSortedSetRangeByScore('partialZset', 3, 10, '-inf', '+inf', (err, data) => {
					assert.ifError(err);
					assert.deepStrictEqual(data, ['value4', 'value5']);
					done();
				});
			});
		});
	});

	describe('getSortedSetRevRangeByScore()', () => {
		it('should get count elements with score between max min sorted by score highest to lowest', (done) => {
			db.getSortedSetRevRangeByScore('sortedSetTest1', 0, -1, '+inf', 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, ['value3', 'value2']);
				done();
			});
		});
	});

	describe('getSortedSetRangeByScoreWithScores()', () => {
		it('should get count elements with score between min max sorted by score lowest to highest with scores', (done) => {
			db.getSortedSetRangeByScoreWithScores('sortedSetTest1', 0, -1, '-inf', 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: 'value1', score: 1.1 }, { value: 'value2', score: 1.2 }]);
				done();
			});
		});
	});

	describe('getSortedSetRevRangeByScoreWithScores()', () => {
		it('should get count elements with score between max min sorted by score highest to lowest', (done) => {
			db.getSortedSetRevRangeByScoreWithScores('sortedSetTest1', 0, -1, '+inf', 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: 'value3', score: 1.3 }, { value: 'value2', score: 1.2 }]);
				done();
			});
		});

		it('should work with an array of keys', async () => {
			await db.sortedSetAddBulk([
				['byScoreWithScoresKeys1', 1, 'value1'],
				['byScoreWithScoresKeys2', 2, 'value2'],
			]);
			const data = await db.getSortedSetRevRangeByScoreWithScores(['byScoreWithScoresKeys1', 'byScoreWithScoresKeys2'], 0, -1, 5, -5);
			assert.deepStrictEqual(data, [{ value: 'value2', score: 2 }, { value: 'value1', score: 1 }]);
		});
	});

	describe('sortedSetCount()', () => {
		it('should return 0 for a sorted set that does not exist', (done) => {
			db.sortedSetCount('doesnotexist', 0, 10, function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 0);
				done();
			});
		});

		it('should return number of elements between scores min max inclusive', (done) => {
			db.sortedSetCount('sortedSetTest1', '-inf', 1.2, function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 2);
				done();
			});
		});

		it('should return number of elements between scores -inf +inf inclusive', (done) => {
			db.sortedSetCount('sortedSetTest1', '-inf', '+inf', function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 3);
				done();
			});
		});
	});

	describe('sortedSetCard()', () => {
		it('should return 0 for a sorted set that does not exist', (done) => {
			db.sortedSetCard('doesnotexist', function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 0);
				done();
			});
		});

		it('should return number of elements in a sorted set', (done) => {
			db.sortedSetCard('sortedSetTest1', function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 3);
				done();
			});
		});
	});

	describe('sortedSetsCard()', () => {
		it('should return the number of elements in sorted sets', (done) => {
			db.sortedSetsCard(['sortedSetTest1', 'sortedSetTest2', 'doesnotexist'], function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, [3, 2, 0]);
				done();
			});
		});

		it('should return empty array if keys is falsy', (done) => {
			db.sortedSetsCard(undefined, function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, []);
				done();
			});
		});

		it('should return empty array if keys is empty array', (done) => {
			db.sortedSetsCard([], function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, []);
				done();
			});
		});
	});

	describe('sortedSetsCardSum()', () => {
		it('should return the total number of elements in sorted sets', (done) => {
			db.sortedSetsCardSum(['sortedSetTest1', 'sortedSetTest2', 'doesnotexist'], function (err, sum) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(sum, 5);
				done();
			});
		});

		it('should return 0 if keys is falsy', (done) => {
			db.sortedSetsCardSum(undefined, function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, 0);
				done();
			});
		});

		it('should return 0 if keys is empty array', (done) => {
			db.sortedSetsCardSum([], function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, 0);
				done();
			});
		});

		it('should return the total number of elements in sorted set', (done) => {
			db.sortedSetsCardSum('sortedSetTest1', function (err, sum) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(sum, 3);
				done();
			});
		});
	});

	describe('sortedSetRank()', () => {
		it('should return falsy if sorted set does not exist', (done) => {
			db.sortedSetRank('doesnotexist', 'value1', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it('should return falsy if element isnt in sorted set', (done) => {
			db.sortedSetRank('sortedSetTest1', 'value5', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it('should return the rank of the element in the sorted set sorted by lowest to highest score', (done) => {
			db.sortedSetRank('sortedSetTest1', 'value1', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 0);
				done();
			});
		});

		it('should return the rank sorted by the score and then the value (a)', (done) => {
			db.sortedSetRank('sortedSetTest4', 'a', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 0);
				done();
			});
		});

		it('should return the rank sorted by the score and then the value (b)', (done) => {
			db.sortedSetRank('sortedSetTest4', 'b', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 1);
				done();
			});
		});

		it('should return the rank sorted by the score and then the value (c)', (done) => {
			db.sortedSetRank('sortedSetTest4', 'c', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 4);
				done();
			});
		});
	});

	describe('sortedSetRevRank()', () => {
		it('should return falsy if sorted set doesnot exist', (done) => {
			db.sortedSetRevRank('doesnotexist', 'value1', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it('should return falsy if element isnt in sorted set', (done) => {
			db.sortedSetRevRank('sortedSetTest1', 'value5', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it('should return the rank of the element in the sorted set sorted by highest to lowest score', (done) => {
			db.sortedSetRevRank('sortedSetTest1', 'value1', function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 2);
				done();
			});
		});
	});

	describe('sortedSetsRanks()', () => {
		it('should return the ranks of values in sorted sets', (done) => {
			db.sortedSetsRanks(['sortedSetTest1', 'sortedSetTest2'], ['value1', 'value4'], function (err, ranks) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(ranks, [0, 1]);
				done();
			});
		});
	});

	describe('sortedSetRanks()', () => {
		it('should return the ranks of values in a sorted set', (done) => {
			db.sortedSetRanks('sortedSetTest1', ['value2', 'value1', 'value3', 'value4'], function (err, ranks) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(ranks, [1, 0, 2, null]);
				done();
			});
		});

		it('should return the ranks of values in a sorted set in reverse', (done) => {
			db.sortedSetRevRanks('sortedSetTest1', ['value2', 'value1', 'value3', 'value4'], function (err, ranks) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(ranks, [1, 2, 0, null]);
				done();
			});
		});
	});

	describe('sortedSetScore()', () => {
		it('should return falsy if sorted set does not exist', (done) => {
			db.sortedSetScore('doesnotexist', 'value1', function (err, score) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!score, false);
				assert.strictEqual(score, null);
				done();
			});
		});

		it('should return falsy if element is not in sorted set', (done) => {
			db.sortedSetScore('sortedSetTest1', 'value5', function (err, score) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!score, false);
				assert.strictEqual(score, null);
				done();
			});
		});

		it('should return the score of an element', (done) => {
			db.sortedSetScore('sortedSetTest1', 'value2', function (err, score) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(score, 1.2);
				done();
			});
		});

		it('should not error if key is undefined', (done) => {
			db.sortedSetScore(undefined, 1, (err, score) => {
				assert.ifError(err);
				assert.strictEqual(score, null);
				done();
			});
		});

		it('should not error if value is undefined', (done) => {
			db.sortedSetScore('sortedSetTest1', undefined, (err, score) => {
				assert.ifError(err);
				assert.strictEqual(score, null);
				done();
			});
		});
	});

	describe('sortedSetsScore()', () => {
		it('should return the scores of value in sorted sets', (done) => {
			db.sortedSetsScore(['sortedSetTest1', 'sortedSetTest2', 'doesnotexist'], 'value1', function (err, scores) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(scores, [1.1, 1, null]);
				done();
			});
		});

		it('should return scores even if some keys are undefined', (done) => {
			db.sortedSetsScore(['sortedSetTest1', undefined, 'doesnotexist'], 'value1', function (err, scores) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(scores, [1.1, null, null]);
				done();
			});
		});

		it('should return empty array if keys is empty array', (done) => {
			db.sortedSetsScore([], 'value1', function (err, scores) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(scores, []);
				done();
			});
		});
	});

	describe('sortedSetScores()', () => {
		before((done) => {
			db.sortedSetAdd('zeroScore', 0, 'value1', done);
		});

		it('should return 0 if score is 0', (done) => {
			db.sortedSetScores('zeroScore', ['value1'], (err, scores) => {
				assert.ifError(err);
				assert.strictEqual(scores[0], 0);
				done();
			});
		});

		it('should return the scores of value in sorted sets', (done) => {
			db.sortedSetScores('sortedSetTest1', ['value2', 'value1', 'doesnotexist'], function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, [1.2, 1.1, null]);
				done();
			});
		});

		it('should return scores even if some values are undefined', (done) => {
			db.sortedSetScores('sortedSetTest1', ['value2', undefined, 'doesnotexist'], function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, [1.2, null, null]);
				done();
			});
		});

		it('should return empty array if values is an empty array', (done) => {
			db.sortedSetScores('sortedSetTest1', [], function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, []);
				done();
			});
		});

		it('should return scores properly', (done) => {
			db.sortedSetsScore(['zeroScore', 'sortedSetTest1', 'doesnotexist'], 'value1', function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, [0, 1.1, null]);
				done();
			});
		});
	});

	describe('isSortedSetMember()', () => {
		before((done) => {
			db.sortedSetAdd('zeroscore', 0, 'itemwithzeroscore', done);
		});

		it('should return false if sorted set does not exist', (done) => {
			db.isSortedSetMember('doesnotexist', 'value1', function (err, isMember) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(isMember, false);
				done();
			});
		});

		it('should return false if element is not in sorted set', (done) => {
			db.isSortedSetMember('sorted2', 'value5', function (err, isMember) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(isMember, false);
				done();
			});
		});

		it('should return true if element is in sorted set', (done) => {
			db.isSortedSetMember('sortedSetTest1', 'value2', function (err, isMember) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.strictEqual(isMember, true);
				done();
			});
		});

		it('should return true if element is in sorted set with score 0', (done) => {
			db.isSortedSetMember('zeroscore', 'itemwithzeroscore', (err, isMember) => {
				assert.ifError(err);
				assert.strictEqual(isMember, true);
				done();
			});
		});
	});

	describe('isSortedSetMembers()', () => {
		it('should return an array of booleans indicating membership', (done) => {
			db.isSortedSetMembers('sortedSetTest1', ['value1', 'value2', 'value5'], function (err, isMembers) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, [true, true, false]);
				done();
			});
		});

		it('should return true if element is in sorted set with score 0', (done) => {
			db.isSortedSetMembers('zeroscore', ['itemwithzeroscore'], function (err, isMembers) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, [true]);
				done();
			});
		});
	});

	describe('isMemberOfSortedSets', () => {
		it('should return true for members false for non members', (done) => {
			db.isMemberOfSortedSets(['doesnotexist', 'sortedSetTest1', 'sortedSetTest2'], 'value2', function (err, isMembers) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, [false, true, false]);
				done();
			});
		});

		it('should return empty array if keys is empty array', (done) => {
			db.isMemberOfSortedSets([], 'value2', function (err, isMembers) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, []);
				done();
			});
		});
	});

	describe('getSortedSetsMembers', () => {
		it('should return members of a sorted set', async () => {
			const result = await db.getSortedSetMembers('sortedSetTest1');
			result.forEach((element) => {
				assert(['value1', 'value2', 'value3'].includes(element));
			});
		});

		it('should return members of multiple sorted sets', (done) => {
			db.getSortedSetsMembers(['doesnotexist', 'sortedSetTest1'], function (err, sortedSets) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(sortedSets[0], []);
				sortedSets[0].forEach((element) => {
					assert.notEqual(['value1', 'value2', 'value3'].indexOf(element), -1);
				});

				done();
			});
		});
	});

	describe('sortedSetUnionCard', () => {
		it('should return the number of elements in the union', (done) => {
			db.sortedSetUnionCard(['sortedSetTest2', 'sortedSetTest3'], (err, count) => {
				assert.ifError(err);
				assert.equal(count, 3);
				done();
			});
		});
	});

	describe('getSortedSetUnion()', () => {
		it('should return an array of values from both sorted sets sorted by scores lowest to highest', (done) => {
			db.getSortedSetUnion({ sets: ['sortedSetTest2', 'sortedSetTest3'], start: 0, stop: -1 }, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, ['value1', 'value2', 'value4']);
				done();
			});
		});

		it('should return an array of values and scores from both sorted sets sorted by scores lowest to highest', (done) => {
			db.getSortedSetUnion({ sets: ['sortedSetTest2', 'sortedSetTest3'], start: 0, stop: -1, withScores: true }, function (err, data) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(data, [{ value: 'value1', score: 1 }, { value: 'value2', score: 2 }, { value: 'value4', score: 8 }]);
				done();
			});
		});
	});

	describe('getSortedSetRevUnion()', () => {
		it('should return an array of values from both sorted sets sorted by scores highest to lowest', (done) => {
			db.getSortedSetRevUnion({ sets: ['sortedSetTest2', 'sortedSetTest3'], start: 0, stop: -1 }, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, ['value4', 'value2', 'value1']);
				done();
			});
		});
	});

	describe('sortedSetIncrBy()', () => {
		it('should create a sorted set with a field set to 1', (done) => {
			db.sortedSetIncrBy('sortedIncr', 1, 'field1', function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 1);
				db.sortedSetScore('sortedIncr', 'field1', (err, score) => {
					assert.equal(err, null);
					assert.strictEqual(score, 1);
					done();
				});
			});
		});

		it('should increment a field of a sorted set by 5', (done) => {
			db.sortedSetIncrBy('sortedIncr', 5, 'field1', function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 6);
				db.sortedSetScore('sortedIncr', 'field1', (err, score) => {
					assert.equal(err, null);
					assert.strictEqual(score, 6);
					done();
				});
			});
		});
	});


	describe('sortedSetRemove()', () => {
		before((done) => {
			db.sortedSetAdd('sorted3', [1, 2], ['value1', 'value2'], done);
		});

		it('should remove an element from a sorted set', (done) => {
			db.sortedSetRemove('sorted3', 'value2', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				db.isSortedSetMember('sorted3', 'value2', (err, isMember) => {
					assert.equal(err, null);
					assert.equal(isMember, false);
					done();
				});
			});
		});

		it('should remove multiple values from multiple keys', (done) => {
			db.sortedSetAdd('multiTest1', [1, 2, 3, 4], ['one', 'two', 'three', 'four'], (err) => {
				assert.ifError(err);
				db.sortedSetAdd('multiTest2', [3, 4, 5, 6], ['three', 'four', 'five', 'six'], (err) => {
					assert.ifError(err);
					db.sortedSetRemove(['multiTest1', 'multiTest2'], ['two', 'three', 'four', 'five', 'doesnt exist'], (err) => {
						assert.ifError(err);
						db.getSortedSetsMembers(['multiTest1', 'multiTest2'], (err, members) => {
							assert.ifError(err);
							assert.equal(members[0].length, 1);
							assert.equal(members[1].length, 1);
							assert.deepEqual(members, [['one'], ['six']]);
							done();
						});
					});
				});
			});
		});

		it('should remove value from multiple keys', async () => {
			await db.sortedSetAdd('multiTest3', [1, 2, 3, 4], ['one', 'two', 'three', 'four']);
			await db.sortedSetAdd('multiTest4', [3, 4, 5, 6], ['three', 'four', 'five', 'six']);
			await db.sortedSetRemove(['multiTest3', 'multiTest4'], 'three');
			assert.deepStrictEqual(await db.getSortedSetRange('multiTest3', 0, -1), ['one', 'two', 'four']);
			assert.deepStrictEqual(await db.getSortedSetRange('multiTest4', 0, -1), ['four', 'five', 'six']);
		});

		it('should remove multiple values from multiple keys', (done) => {
			db.sortedSetAdd('multiTest5', [1], ['one'], (err) => {
				assert.ifError(err);
				db.sortedSetAdd('multiTest6', [2], ['two'], (err) => {
					assert.ifError(err);
					db.sortedSetAdd('multiTest7', [3], [333], (err) => {
						assert.ifError(err);
						db.sortedSetRemove(['multiTest5', 'multiTest6', 'multiTest7'], ['one', 'two', 333], (err) => {
							assert.ifError(err);
							db.getSortedSetsMembers(['multiTest5', 'multiTest6', 'multiTest7'], (err, members) => {
								assert.ifError(err);
								assert.deepEqual(members, [[], [], []]);
								done();
							});
						});
					});
				});
			});
		});

		it('should not remove anything if values is empty array', (done) => {
			db.sortedSetAdd('removeNothing', [1, 2, 3], ['val1', 'val2', 'val3'], (err) => {
				assert.ifError(err);
				db.sortedSetRemove('removeNothing', [], (err) => {
					assert.ifError(err);
					db.getSortedSetRange('removeNothing', 0, -1, (err, data) => {
						assert.ifError(err);
						assert.deepStrictEqual(data, ['val1', 'val2', 'val3']);
						done();
					});
				});
			});
		});

		it('should do a bulk remove', async () => {
			await db.sortedSetAddBulk([
				['bulkRemove1', 1, 'value1'],
				['bulkRemove1', 2, 'value2'],
				['bulkRemove2', 3, 'value2'],
			]);
			await db.sortedSetRemoveBulk([
				['bulkRemove1', 'value1'],
				['bulkRemove1', 'value2'],
				['bulkRemove2', 'value2'],
			]);
			const members = await db.getSortedSetsMembers(['bulkRemove1', 'bulkRemove2']);
			assert.deepStrictEqual(members, [[], []]);
		});
	});

	describe('sortedSetsRemove()', () => {
		before((done) => {
			async.parallel([
				async.apply(db.sortedSetAdd, 'sorted4', [1, 2], ['value1', 'value2']),
				async.apply(db.sortedSetAdd, 'sorted5', [1, 2], ['value1', 'value3']),
			], done);
		});

		it('should remove element from multiple sorted sets', (done) => {
			db.sortedSetsRemove(['sorted4', 'sorted5'], 'value1', function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				db.sortedSetsScore(['sorted4', 'sorted5'], 'value1', (err, scores) => {
					assert.equal(err, null);
					assert.deepStrictEqual(scores, [null, null]);
					done();
				});
			});
		});
	});

	describe('sortedSetsRemoveRangeByScore()', () => {
		before((done) => {
			db.sortedSetAdd('sorted6', [1, 2, 3, 4, 5], ['value1', 'value2', 'value3', 'value4', 'value5'], done);
		});

		it('should remove elements with scores between min max inclusive', (done) => {
			db.sortedSetsRemoveRangeByScore(['sorted6'], 4, 5, function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRange('sorted6', 0, -1, (err, values) => {
					assert.ifError(err);
					assert.deepEqual(values, ['value1', 'value2', 'value3']);
					done();
				});
			});
		});

		it('should remove elements with if strin score is passed in', (done) => {
			db.sortedSetAdd('sortedForRemove', [11, 22, 33], ['value1', 'value2', 'value3'], (err) => {
				assert.ifError(err);
				db.sortedSetsRemoveRangeByScore(['sortedForRemove'], '22', '22', (err) => {
					assert.ifError(err);
					db.getSortedSetRange('sortedForRemove', 0, -1, (err, values) => {
						assert.ifError(err);
						assert.deepEqual(values, ['value1', 'value3']);
						done();
					});
				});
			});
		});
	});

	describe('getSortedSetIntersect', () => {
		before((done) => {
			async.parallel([
				function (next) {
					db.sortedSetAdd('interSet1', [1, 2, 3], ['value1', 'value2', 'value3'], next);
				},
				function (next) {
					db.sortedSetAdd('interSet2', [4, 5, 6], ['value2', 'value3', 'value5'], next);
				},
			], done);
		});

		it('should return the intersection of two sets', (done) => {
			db.getSortedSetIntersect({
				sets: ['interSet1', 'interSet2'],
				start: 0,
				stop: -1,
			}, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(['value2', 'value3'], data);
				done();
			});
		});

		it('should return the intersection of two sets with scores', (done) => {
			db.getSortedSetIntersect({
				sets: ['interSet1', 'interSet2'],
				start: 0,
				stop: -1,
				withScores: true,
			}, (err, data) => {
				assert.ifError(err);
				assert.deepEqual([{ value: 'value2', score: 6 }, { value: 'value3', score: 8 }], data);
				done();
			});
		});

		it('should return the reverse intersection of two sets', (done) => {
			db.getSortedSetRevIntersect({
				sets: ['interSet1', 'interSet2'],
				start: 0,
				stop: 2,
			}, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(['value3', 'value2'], data);
				done();
			});
		});

		it('should return the intersection of two sets with scores aggregate MIN', (done) => {
			db.getSortedSetIntersect({
				sets: ['interSet1', 'interSet2'],
				start: 0,
				stop: -1,
				withScores: true,
				aggregate: 'MIN',
			}, (err, data) => {
				assert.ifError(err);
				assert.deepEqual([{ value: 'value2', score: 2 }, { value: 'value3', score: 3 }], data);
				done();
			});
		});

		it('should return the intersection of two sets with scores aggregate MAX', (done) => {
			db.getSortedSetIntersect({
				sets: ['interSet1', 'interSet2'],
				start: 0,
				stop: -1,
				withScores: true,
				aggregate: 'MAX',
			}, (err, data) => {
				assert.ifError(err);
				assert.deepEqual([{ value: 'value2', score: 4 }, { value: 'value3', score: 5 }], data);
				done();
			});
		});

		it('should return the intersection with scores modified by weights', (done) => {
			db.getSortedSetIntersect({
				sets: ['interSet1', 'interSet2'],
				start: 0,
				stop: -1,
				withScores: true,
				weights: [1, 0.5],
			}, (err, data) => {
				assert.ifError(err);
				assert.deepEqual([{ value: 'value2', score: 4 }, { value: 'value3', score: 5.5 }], data);
				done();
			});
		});

		it('should return empty array if sets do not exist', (done) => {
			db.getSortedSetIntersect({
				sets: ['interSet10', 'interSet12'],
				start: 0,
				stop: -1,
			}, (err, data) => {
				assert.ifError(err);
				assert.equal(data.length, 0);
				done();
			});
		});

		it('should return empty array if one set does not exist', (done) => {
			db.getSortedSetIntersect({
				sets: ['interSet1', 'interSet12'],
				start: 0,
				stop: -1,
			}, (err, data) => {
				assert.ifError(err);
				assert.equal(data.length, 0);
				done();
			});
		});

		it('should return correct results if sorting by different zset', async () => {
			await db.sortedSetAdd('bigzset', [1, 2, 3, 4, 5, 6], ['a', 'b', 'c', 'd', 'e', 'f']);
			await db.sortedSetAdd('smallzset', [3, 2, 1], ['b', 'e', 'g']);
			const data = await db.getSortedSetRevIntersect({
				sets: ['bigzset', 'smallzset'],
				start: 0,
				stop: 19,
				weights: [1, 0],
				withScores: true,
			});
			assert.deepStrictEqual(data, [{ value: 'e', score: 5 }, { value: 'b', score: 2 }]);
			const data2 = await db.getSortedSetRevIntersect({
				sets: ['bigzset', 'smallzset'],
				start: 0,
				stop: 19,
				weights: [0, 1],
				withScores: true,
			});
			assert.deepStrictEqual(data2, [{ value: 'b', score: 3 }, { value: 'e', score: 2 }]);
		});

		it('should return correct results when intersecting big zsets', async () => {
			const scores = [];
			const values = [];
			for (let i = 0; i < 30000; i++) {
				scores.push((i + 1) * 1000);
				values.push(String(i + 1));
			}
			await db.sortedSetAdd('verybigzset', scores, values);

			scores.length = 0;
			values.length = 0;
			for (let i = 15000; i < 45000; i++) {
				scores.push((i + 1) * 1000);
				values.push(String(i + 1));
			}
			await db.sortedSetAdd('anotherbigzset', scores, values);
			const data = await db.getSortedSetRevIntersect({
				sets: ['verybigzset', 'anotherbigzset'],
				start: 0,
				stop: 3,
				weights: [1, 0],
				withScores: true,
			});
			assert.deepStrictEqual(data, [
				{ value: '30000', score: 30000000 },
				{ value: '29999', score: 29999000 },
				{ value: '29998', score: 29998000 },
				{ value: '29997', score: 29997000 },
			]);
		});
	});

	describe('sortedSetIntersectCard', () => {
		before((done) => {
			async.parallel([
				function (next) {
					db.sortedSetAdd('interCard1', [0, 0, 0], ['value1', 'value2', 'value3'], next);
				},
				function (next) {
					db.sortedSetAdd('interCard2', [0, 0, 0], ['value2', 'value3', 'value4'], next);
				},
				function (next) {
					db.sortedSetAdd('interCard3', [0, 0, 0], ['value3', 'value4', 'value5'], next);
				},
				function (next) {
					db.sortedSetAdd('interCard4', [0, 0, 0], ['value4', 'value5', 'value6'], next);
				},
			], done);
		});

		it('should return # of elements in intersection', (done) => {
			db.sortedSetIntersectCard(['interCard1', 'interCard2', 'interCard3'], (err, count) => {
				assert.ifError(err);
				assert.strictEqual(count, 1);
				done();
			});
		});

		it('should return 0 if intersection is empty', (done) => {
			db.sortedSetIntersectCard(['interCard1', 'interCard4'], (err, count) => {
				assert.ifError(err);
				assert.strictEqual(count, 0);
				done();
			});
		});
	});

	describe('getSortedSetRangeByLex', () => {
		it('should return an array of all values', (done) => {
			db.getSortedSetRangeByLex('sortedSetLex', '-', '+', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['a', 'b', 'c', 'd']);
				done();
			});
		});

		it('should return an array with an inclusive range by default', (done) => {
			db.getSortedSetRangeByLex('sortedSetLex', 'a', 'd', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['a', 'b', 'c', 'd']);
				done();
			});
		});

		it('should return an array with an inclusive range', (done) => {
			db.getSortedSetRangeByLex('sortedSetLex', '[a', '[d', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['a', 'b', 'c', 'd']);
				done();
			});
		});

		it('should return an array with an exclusive range', (done) => {
			db.getSortedSetRangeByLex('sortedSetLex', '(a', '(d', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['b', 'c']);
				done();
			});
		});

		it('should return an array limited to the first two values', (done) => {
			db.getSortedSetRangeByLex('sortedSetLex', '-', '+', 0, 2, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['a', 'b']);
				done();
			});
		});

		it('should return correct result', async () => {
			await db.sortedSetAdd('sortedSetLexSearch', [0, 0, 0], ['baris:usakli:1', 'baris usakli:2', 'baris soner:3']);
			const query = 'baris:';
			const min = query;
			const max = query.substr(0, query.length - 1) + String.fromCharCode(query.charCodeAt(query.length - 1) + 1);
			const result = await db.getSortedSetRangeByLex('sortedSetLexSearch', min, max, 0, -1);
			assert.deepStrictEqual(result, ['baris:usakli:1']);
		});
	});

	describe('getSortedSetRevRangeByLex', () => {
		it('should return an array of all values reversed', (done) => {
			db.getSortedSetRevRangeByLex('sortedSetLex', '+', '-', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['d', 'c', 'b', 'a']);
				done();
			});
		});

		it('should return an array with an inclusive range by default reversed', (done) => {
			db.getSortedSetRevRangeByLex('sortedSetLex', 'd', 'a', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['d', 'c', 'b', 'a']);
				done();
			});
		});

		it('should return an array with an inclusive range reversed', (done) => {
			db.getSortedSetRevRangeByLex('sortedSetLex', '[d', '[a', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['d', 'c', 'b', 'a']);
				done();
			});
		});

		it('should return an array with an exclusive range reversed', (done) => {
			db.getSortedSetRevRangeByLex('sortedSetLex', '(d', '(a', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['c', 'b']);
				done();
			});
		});

		it('should return an array limited to the first two values reversed', (done) => {
			db.getSortedSetRevRangeByLex('sortedSetLex', '+', '-', 0, 2, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, ['d', 'c']);
				done();
			});
		});
	});

	describe('sortedSetLexCount', () => {
		it('should return the count of all values', (done) => {
			db.sortedSetLexCount('sortedSetLex', '-', '+', (err, data) => {
				assert.ifError(err);
				assert.strictEqual(data, 4);
				done();
			});
		});

		it('should return the count with an inclusive range by default', (done) => {
			db.sortedSetLexCount('sortedSetLex', 'a', 'd', (err, data) => {
				assert.ifError(err);
				assert.strictEqual(data, 4);
				done();
			});
		});

		it('should return the count with an inclusive range', (done) => {
			db.sortedSetLexCount('sortedSetLex', '[a', '[d', (err, data) => {
				assert.ifError(err);
				assert.strictEqual(data, 4);
				done();
			});
		});

		it('should return the count with an exclusive range', (done) => {
			db.sortedSetLexCount('sortedSetLex', '(a', '(d', (err, data) => {
				assert.ifError(err);
				assert.strictEqual(data, 2);
				done();
			});
		});
	});

	describe('sortedSetRemoveRangeByLex', () => {
		before((done) => {
			db.sortedSetAdd('sortedSetLex2', [0, 0, 0, 0, 0, 0, 0], ['a', 'b', 'c', 'd', 'e', 'f', 'g'], done);
		});

		it('should remove an inclusive range by default', (done) => {
			db.sortedSetRemoveRangeByLex('sortedSetLex2', 'a', 'b', function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex('sortedSetLex2', '-', '+', (err, data) => {
					assert.ifError(err);
					assert.deepEqual(data, ['c', 'd', 'e', 'f', 'g']);
					done();
				});
			});
		});

		it('should remove an inclusive range', (done) => {
			db.sortedSetRemoveRangeByLex('sortedSetLex2', '[c', '[d', function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex('sortedSetLex2', '-', '+', (err, data) => {
					assert.ifError(err);
					assert.deepEqual(data, ['e', 'f', 'g']);
					done();
				});
			});
		});

		it('should remove an exclusive range', (done) => {
			db.sortedSetRemoveRangeByLex('sortedSetLex2', '(e', '(g', function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex('sortedSetLex2', '-', '+', (err, data) => {
					assert.ifError(err);
					assert.deepEqual(data, ['e', 'g']);
					done();
				});
			});
		});

		it('should remove all values', (done) => {
			db.sortedSetRemoveRangeByLex('sortedSetLex2', '-', '+', function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex('sortedSetLex2', '-', '+', (err, data) => {
					assert.ifError(err);
					assert.deepEqual(data, []);
					done();
'use strict';


const async = require('async');
const assert = require('assert');
const db = require('../mocks/databasemock');

describe('Hash methods', () => {
	const testData = {
		name: 'baris',
		lastname: 'usakli',
		age: 99,
	};

	beforeEach((done) => {
		db.setObject('hashTestObject', testData, done);
	});

	describe('setObject()', () => {
		it('should create a object', (done) => {
			db.setObject('testObject1', { foo: 'baris', bar: 99 }, function (err) {
				assert.ifError(err);
				assert(arguments.length < 2);
				done();
			});
		});

		it('should set two objects to same data', async () => {
			const data = { foo: 'baz', test: '1' };
			await db.setObject(['multiObject1', 'multiObject2'], data);
			const result = await db.getObjects(['multiObject1', 'multiObject2']);
			assert.deepStrictEqual(result[0], data);
			assert.deepStrictEqual(result[1], data);
		});

		it('should do nothing if key is falsy', (done) => {
			db.setObject('', { foo: 1, derp: 2 }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should do nothing if data is falsy', (done) => {
			db.setObject('falsy', null, (err) => {
				assert.ifError(err);
				db.exists('falsy', (err, exists) => {
					assert.ifError(err);
					assert.equal(exists, false);
					done();
				});
			});
		});

		it('should not error if a key is empty string', (done) => {
			db.setObject('emptyField', { '': '', b: 1 }, (err) => {
				assert.ifError(err);
				db.getObject('emptyField', (err, data) => {
					assert.ifError(err);
					done();
				});
			});
		});

		it('should work for field names with "." in them', (done) => {
			db.setObject('dotObject', { 'my.dot.field': 'foo' }, (err) => {
				assert.ifError(err);
				db.getObject('dotObject', (err, data) => {
					assert.ifError(err);
					assert.equal(data['my.dot.field'], 'foo');
					done();
				});
			});
		});

		it('should set multiple keys to different okjects', async () => {
			const keys = ['bulkKey1', 'bulkKey2'];
			const data = [{ foo: '1' }, { baz: 'baz' }];

			await db.setObjectBulk(keys, data);
			const result = await db.getObjects(keys);
			assert.deepStrictEqual(result, data);
		});
	});

	describe('setObjectField()', () => {
		it('should create a new object with field', (done) => {
			db.setObjectField('testObject2', 'name', 'ginger', function (err) {
				assert.ifError(err);
				assert(arguments.length < 2);
				done();
			});
		});

		it('should add a new field to an object', (done) => {
			db.setObjectField('testObject2', 'type', 'cat', function (err) {
				assert.ifError(err, null);
				assert(arguments.length < 2);
				done();
			});
		});

		it('should set two objects fields to same data', async () => {
			const data = { foo: 'baz', test: '1' };
			await db.setObjectField(['multiObject1', 'multiObject2'], 'myField', '2');
			const result = await db.getObjects(['multiObject1', 'multiObject2']);
			assert.deepStrictEqual(result[0].myField, '2');
			assert.deepStrictEqual(result[1].myField, '2');
		});

		it('should work for field names with "." in them', (done) => {
			db.setObjectField('dotObject2', 'my.dot.field', 'foo2', (err) => {
				assert.ifError(err);
				db.getObjectField('dotObject2', 'my.dot.field', (err, value) => {
					assert.ifError(err);
					assert.equal(value, 'foo2');
					done();
				});
			});
		});

		it('should work for field names with "." in them when they are cached', (done) => {
			db.setObjectField('dotObject3', 'my.dot.field', 'foo2', (err) => {
				assert.ifError(err);
				db.getObject('dotObject3', (err, data) => {
					assert.ifError(err);
					db.getObjectField('dotObject3', 'my.dot.field', (err, value) => {
						assert.ifError(err);
						assert.equal(value, 'foo2');
						done();
					});
				});
			});
		});
	});

	describe('getObject()', () => {
		it('should return falsy if object does not exist', (done) => {
			db.getObject('doesnotexist', function (err, data) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!data, false);
				done();
			});
		});

		it('should retrieve an object', (done) => {
			db.getObject('hashTestObject', (err, data) => {
				assert.equal(err, null);
				assert.equal(data.name, testData.name);
				assert.equal(data.age, testData.age);
				assert.equal(data.lastname, 'usakli');
				done();
			});
		});

		it('should return null if key is falsy', (done) => {
			db.getObject(null, function (err, data) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(data, null);
				done();
			});
		});
	});

	describe('getObjects()', () => {
		before((done) => {
			async.parallel([
				async.apply(db.setObject, 'testObject4', { name: 'baris' }),
				async.apply(db.setObjectField, 'testObject5', 'name', 'ginger'),
			], done);
		});

		it('should return 3 objects with correct data', (done) => {
			db.getObjects(['testObject4', 'testObject5', 'doesnotexist'], function (err, objects) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(objects) && objects.length === 3, true);
				assert.equal(objects[0].name, 'baris');
				assert.equal(objects[1].name, 'ginger');
				assert.equal(!!objects[2], false);
				done();
			});
		});
	});

	describe('getObjectField()', () => {
		it('should return falsy if object does not exist', (done) => {
			db.getObjectField('doesnotexist', 'fieldName', function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!value, false);
				done();
			});
		});

		it('should return falsy if field does not exist', (done) => {
			db.getObjectField('hashTestObject', 'fieldName', function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!value, false);
				done();
			});
		});

		it('should get an objects field', (done) => {
			db.getObjectField('hashTestObject', 'lastname', function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, 'usakli');
				done();
			});
		});

		it('should return null if key is falsy', (done) => {
			db.getObjectField(null, 'test', function (err, data) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(data, null);
				done();
			});
		});

		it('should return null and not error', async () => {
			const data = await db.getObjectField('hashTestObject', ['field1', 'field2']);
			assert.strictEqual(data, null);
		});
	});

	describe('getObjectFields()', () => {
		it('should return an object with falsy values', (done) => {
			db.getObjectFields('doesnotexist', ['field1', 'field2'], function (err, object) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(typeof object, 'object');
				assert.equal(!!object.field1, false);
				assert.equal(!!object.field2, false);
				done();
			});
		});

		it('should return an object with correct fields', (done) => {
			db.getObjectFields('hashTestObject', ['lastname', 'age', 'field1'], function (err, object) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(typeof object, 'object');
				assert.equal(object.lastname, 'usakli');
				assert.equal(object.age, 99);
				assert.equal(!!object.field1, false);
				done();
			});
		});

		it('should return null if key is falsy', (done) => {
			db.getObjectFields(null, ['test', 'foo'], function (err, data) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(data, null);
				done();
			});
		});
	});

	describe('getObjectsFields()', () => {
		before((done) => {
			async.parallel([
				async.apply(db.setObject, 'testObject8', { name: 'baris', age: 99 }),
				async.apply(db.setObject, 'testObject9', { name: 'ginger', age: 3 }),
			], done);
		});

		it('should return an array of objects with correct values', (done) => {
			db.getObjectsFields(['testObject8', 'testObject9', 'doesnotexist'], ['name', 'age'], function (err, objects) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(objects), true);
				assert.equal(objects.length, 3);
				assert.equal(objects[0].name, 'baris');
				assert.equal(objects[0].age, 99);
				assert.equal(objects[1].name, 'ginger');
				assert.equal(objects[1].age, 3);
				assert.equal(!!objects[2].name, false);
				done();
			});
		});

		it('should return undefined for all fields if object does not exist', (done) => {
			db.getObjectsFields(['doesnotexist1', 'doesnotexist2'], ['name', 'age'], (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				assert.equal(data[0].name, null);
				assert.equal(data[0].age, null);
				assert.equal(data[1].name, null);
				assert.equal(data[1].age, null);
				done();
			});
		});
	});

	describe('getObjectKeys()', () => {
		it('should return an empty array for a object that does not exist', (done) => {
			db.getObjectKeys('doesnotexist', function (err, keys) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(keys) && keys.length === 0, true);
				done();
			});
		});

		it('should return an array of keys for the object\'s fields', (done) => {
			db.getObjectKeys('hashTestObject', function (err, keys) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(keys) && keys.length === 3, true);
				keys.forEach((key) => {
					assert.notEqual(['name', 'lastname', 'age'].indexOf(key), -1);
				});
				done();
			});
		});
	});

	describe('getObjectValues()', () => {
		it('should return an empty array for a object that does not exist', (done) => {
			db.getObjectValues('doesnotexist', function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(values) && values.length === 0, true);
				done();
			});
		});

		it('should return an array of values for the object\'s fields', (done) => {
			db.getObjectValues('hashTestObject', function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(values) && values.length === 3, true);
				assert.deepEqual(['baris', 'usakli', 99].sort(), values.sort());
				done();
			});
		});
	});

	describe('isObjectField()', () => {
		it('should return false if object does not exist', (done) => {
			db.isObjectField('doesnotexist', 'field1', function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, false);
				done();
			});
		});

		it('should return false if field does not exist', (done) => {
			db.isObjectField('hashTestObject', 'field1', function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, false);
				done();
			});
		});

		it('should return true if field exists', (done) => {
			db.isObjectField('hashTestObject', 'name', function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, true);
				done();
			});
		});
	});


	describe('isObjectFields()', () => {
		it('should return an array of false if object does not exist', (done) => {
			db.isObjectFields('doesnotexist', ['field1', 'field2'], function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [false, false]);
				done();
			});
		});

		it('should return false if field does not exist', (done) => {
			db.isObjectFields('hashTestObject', ['name', 'age', 'field1'], function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [true, true, false]);
				done();
			});
		});
	});

	describe('deleteObjectField()', () => {
		before((done) => {
			db.setObject('testObject10', { foo: 'bar', delete: 'this', delete1: 'this', delete2: 'this' }, done);
		});

		it('should delete an objects field', (done) => {
			db.deleteObjectField('testObject10', 'delete', function (err) {
				assert.ifError(err);
				assert(arguments.length < 2);
				db.isObjectField('testObject10', 'delete', (err, isField) => {
					assert.ifError(err);
					assert.equal(isField, false);
					done();
				});
			});
		});

		it('should delete multiple fields of the object', (done) => {
			db.deleteObjectFields('testObject10', ['delete1', 'delete2'], function (err) {
				assert.ifError(err);
				assert(arguments.length < 2);
				async.parallel({
					delete1: async.apply(db.isObjectField, 'testObject10', 'delete1'),
					delete2: async.apply(db.isObjectField, 'testObject10', 'delete2'),
				}, (err, results) => {
					assert.ifError(err);
					assert.equal(results.delete1, false);
					assert.equal(results.delete2, false);
					done();
				});
			});
		});

		it('should delete multiple fields of multiple objects', async () => {
			await db.setObject('deleteFields1', { foo: 'foo1', baz: '2' });
			await db.setObject('deleteFields2', { foo: 'foo2', baz: '3' });
			await db.deleteObjectFields(['deleteFields1', 'deleteFields2'], ['baz']);
			const obj1 = await db.getObject('deleteFields1');
			const obj2 = await db.getObject('deleteFields2');
			assert.deepStrictEqual(obj1, { foo: 'foo1' });
			assert.deepStrictEqual(obj2, { foo: 'foo2' });
		});

		it('should not error if fields is empty array', async () => {
			await db.deleteObjectFields('someKey', []);
		});

		it('should not error if key is undefined', (done) => {
			db.deleteObjectField(undefined, 'someField', (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should not error if key is null', (done) => {
			db.deleteObjectField(null, 'someField', (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should not error if field is undefined', (done) => {
			db.deleteObjectField('someKey', undefined, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should not error if one of the fields is undefined', async () => {
			await db.deleteObjectFields('someKey', ['best', undefined]);
		});

		it('should not error if field is null', (done) => {
			db.deleteObjectField('someKey', null, (err) => {
				assert.ifError(err);
				done();
			});
		});
	});

	describe('incrObjectField()', () => {
		before((done) => {
			db.setObject('testObject11', { age: 99 }, done);
		});

		it('should set an objects field to 1 if object does not exist', (done) => {
			db.incrObjectField('testObject12', 'field1', function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 1);
				done();
			});
		});

		it('should increment an object fields by 1 and return it', (done) => {
			db.incrObjectField('testObject11', 'age', function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 100);
				done();
			});
		});
	});

	describe('decrObjectField()', () => {
		before((done) => {
			db.setObject('testObject13', { age: 99 }, done);
		});

		it('should set an objects field to -1 if object does not exist', (done) => {
			db.decrObjectField('testObject14', 'field1', function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, -1);
				done();
			});
		});

		it('should decrement an object fields by 1 and return it', (done) => {
			db.decrObjectField('testObject13', 'age', function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, 98);
				done();
			});
		});

		it('should decrement multiple objects field by 1 and return an array of new values', (done) => {
			db.decrObjectField(['testObject13', 'testObject14', 'decrTestObject'], 'age', (err, data) => {
				assert.ifError(err);
				assert.equal(data[0], 97);
				assert.equal(data[1], -1);
				assert.equal(data[2], -1);
				done();
			});
		});
	});

	describe('incrObjectFieldBy()', () => {
		before((done) => {
			db.setObject('testObject15', { age: 100 }, done);
		});

		it('should set an objects field to 5 if object does not exist', (done) => {
			db.incrObjectFieldBy('testObject16', 'field1', 5, function (err, newValue) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, 5);
				done();
			});
		});

		it('should increment an object fields by passed in value and return it', (done) => {
			db.incrObjectFieldBy('testObject15', 'age', 11, function (err, newValue) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, 111);
				done();
			});
		});

		it('should increment an object fields by passed in value and return it', (done) => {
			db.incrObjectFieldBy('testObject15', 'age', '11', (err, newValue) => {
				assert.ifError(err);
				assert.equal(newValue, 122);
				done();
			});
		});

		it('should return null if value is NaN', (done) => {
			db.incrObjectFieldBy('testObject15', 'lastonline', 'notanumber', (err, newValue) => {
				assert.ifError(err);
				assert.strictEqual(newValue, null);
				db.isObjectField('testObject15', 'lastonline', (err, isField) => {
					assert.ifError(err);
					assert(!isField);
					done();
'use strict';

const assert = require('assert');
const path = require('path');

const db = require('./mocks/databasemock');
const image = require('../src/image');
const file = require('../src/file');

describe('image', () => {
	it('should normalise image', (done) => {
		image.normalise(path.join(__dirname, 'files/normalise.jpg'), '.jpg', (err) => {
			assert.ifError(err);
			file.exists(path.join(__dirname, 'files/normalise.jpg.png'), (err, exists) => {
				assert.ifError(err);
				assert(exists);
				done();
			});
		});
	});

	it('should resize an image', (done) => {
		image.resizeImage({
			path: path.join(__dirname, 'files/normalise.jpg'),
			target: path.join(__dirname, 'files/normalise-resized.jpg'),
			width: 50,
			height: 40,
		}, (err) => {
			assert.ifError(err);
			image.size(path.join(__dirname, 'files/normalise-resized.jpg'), (err, bitmap) => {
				assert.ifError(err);
				assert.equal(bitmap.width, 50);
				assert.equal(bitmap.height, 40);
				done();
			});
'use strict';

const async = require('async');
const assert = require('assert');

const db = require('./mocks/databasemock');
const groups = require('../src/groups');
const user = require('../src/user');
const blacklist = require('../src/meta/blacklist');

describe('blacklist', () => {
	let adminUid;

	before((done) => {
		user.create({ username: 'admin' }, (err, uid) => {
			assert.ifError(err);
			adminUid = uid;
			groups.join('administrators', adminUid, done);
		});
	});

	const socketBlacklist = require('../src/socket.io/blacklist');
	const rules = '1.1.1.1\n2.2.2.2\n::ffff:0:2.2.2.2\n127.0.0.1\n192.168.100.0/22';

	it('should validate blacklist', (done) => {
		socketBlacklist.validate({ uid: adminUid }, {
			rules: rules,
		}, (err, data) => {
			assert.ifError(err);
			done();
		});
	});

	it('should error if not admin', (done) => {
		socketBlacklist.save({ uid: 0 }, rules, (err) => {
			assert.equal(err.message, '[[error:no-privileges]]');
			done();
		});
	});

	it('should save blacklist', (done) => {
		socketBlacklist.save({ uid: adminUid }, rules, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should pass ip test against blacklist', (done) => {
		blacklist.test('3.3.3.3', (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should fail ip test against blacklist', (done) => {
		blacklist.test('1.1.1.1', (err) => {
			assert.equal(err.message, '[[error:blacklisted-ip]]');
			done();
		});
	});

	it('should pass ip test and not crash with ipv6 address', (done) => {
		blacklist.test('2001:db8:85a3:0:0:8a2e:370:7334', (err) => {
			assert.ifError(err);
			done();
'use strict';

const request = require('request');
const requestAsync = require('request-promise-native');
const nconf = require('nconf');
const fs = require('fs');
const winston = require('winston');

const utils = require('../../public/src/utils');

const helpers = module.exports;

helpers.loginUser = function (username, password, callback) {
	const jar = request.jar();

	request({
		url: `${nconf.get('url')}/api/config`,
		json: true,
		jar: jar,
	}, (err, res, body) => {
		if (err || res.statusCode !== 200) {
			return callback(err || new Error('[[error:invalid-response]]'));
		}

		request.post(`${nconf.get('url')}/login`, {
			form: {
				username: username,
				password: password,
			},
			json: true,
			jar: jar,
			headers: {
				'x-csrf-token': body.csrf_token,
			},
		}, (err, res) => {
			if (err || res.statusCode !== 200) {
				return callback(err || new Error('[[error:invalid-response]]'));
			}
			callback(null, jar, body.csrf_token);
		});
	});
};


helpers.logoutUser = function (jar, callback) {
	request({
		url: `${nconf.get('url')}/api/config`,
		json: true,
		jar: jar,
	}, (err, response, body) => {
		if (err) {
			return callback(err, response, body);
		}

		request.post(`${nconf.get('url')}/logout`, {
			form: {},
			json: true,
			jar: jar,
			headers: {
				'x-csrf-token': body.csrf_token,
			},
		}, (err, response, body) => {
			callback(err, response, body);
		});
	});
};

helpers.connectSocketIO = function (res, callback) {
	const io = require('socket.io-client');
	let cookies = res.headers['set-cookie'];
	cookies = cookies.filter(c => /express.sid=[^;]+;/.test(c));
	const cookie = cookies[0];
	const socket = io(nconf.get('base_url'), {
		path: `${nconf.get('relative_path')}/socket.io`,
		extraHeaders: {
			Origin: nconf.get('url'),
			Cookie: cookie,
		},
	});

	socket.on('connect', () => {
		callback(null, socket);
	});

	socket.on('error', (err) => {
		callback(err);
	});
};

helpers.uploadFile = function (uploadEndPoint, filePath, body, jar, csrf_token, callback) {
	let formData = {
		files: [
			fs.createReadStream(filePath),
			fs.createReadStream(filePath), // see https://github.com/request/request/issues/2445
		],
	};
	formData = utils.merge(formData, body);
	request.post({
		url: uploadEndPoint,
		formData: formData,
		json: true,
		jar: jar,
		headers: {
			'x-csrf-token': csrf_token,
		},
	}, (err, res, body) => {
		if (err) {
			return callback(err);
		}
		if (res.statusCode !== 200) {
			winston.error(JSON.stringify(body));
		}
		callback(null, res, body);
	});
};

helpers.registerUser = function (data, callback) {
	const jar = request.jar();
	request({
		url: `${nconf.get('url')}/api/config`,
		json: true,
		jar: jar,
	}, (err, response, body) => {
		if (err) {
			return callback(err);
		}

		request.post(`${nconf.get('url')}/register`, {
			form: data,
			json: true,
			jar: jar,
			headers: {
				'x-csrf-token': body.csrf_token,
			},
		}, (err, response, body) => {
			callback(err, jar, response, body);
		});
	});
};

// http://stackoverflow.com/a/14387791/583363
helpers.copyFile = function (source, target, callback) {
	let cbCalled = false;

	const rd = fs.createReadStream(source);
	rd.on('error', (err) => {
		done(err);
	});
	const wr = fs.createWriteStream(target);
	wr.on('error', (err) => {
		done(err);
	});
	wr.on('close', () => {
		done();
	});
	rd.pipe(wr);

	function done(err) {
		if (!cbCalled) {
			callback(err);
			cbCalled = true;
		}
	}
};

helpers.invite = async function (body, uid, jar, csrf_token) {
	const res = await requestAsync.post(`${nconf.get('url')}/api/v3/users/${uid}/invites`, {
		jar: jar,
		// using "form" since client "api" module make requests with "application/x-www-form-urlencoded" content-type
		form: body,
		headers: {
			'x-csrf-token': csrf_token,
		},
		simple: false,
		resolveWithFullResponse: true,
	});

	res.body = JSON.parse(res.body);
	return { res, body };
};
'use strict';


const	assert = require('assert');
const async = require('async');
const request = require('request');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const topics = require('../src/topics');
const categories = require('../src/categories');
const user = require('../src/user');
const search = require('../src/search');
const privileges = require('../src/privileges');

describe('Search', () => {
	let phoebeUid;
	let gingerUid;

	let topic1Data;
	let topic2Data;
	let post1Data;
	let post2Data;
	let post3Data;
	let cid1;
	let cid2;
	let cid3;

	before((done) => {
		async.waterfall([
			function (next) {
				async.series({
					phoebe: function (next) {
						user.create({ username: 'phoebe' }, next);
					},
					ginger: function (next) {
						user.create({ username: 'ginger' }, next);
					},
					category1: function (next) {
						categories.create({
							name: 'Test Category',
							description: 'Test category created by testing script',
						}, next);
					},
					category2: function (next) {
						categories.create({
							name: 'Test Category',
							description: 'Test category created by testing script',
						}, next);
					},
				}, next);
			},
			function (results, next) {
				phoebeUid = results.phoebe;
				gingerUid = results.ginger;
				cid1 = results.category1.cid;
				cid2 = results.category2.cid;

				async.waterfall([
					function (next) {
						categories.create({
							name: 'Child Test Category',
							description: 'Test category created by testing script',
							parentCid: cid2,
						}, next);
					},
					function (category, next) {
						cid3 = category.cid;
						topics.post({
							uid: phoebeUid,
							cid: cid1,
							title: 'nodebb mongodb bugs',
							content: 'avocado cucumber apple orange fox',
							tags: ['nodebb', 'bug', 'plugin', 'nodebb-plugin', 'jquery'],
						}, next);
					},
					function (results, next) {
						topic1Data = results.topicData;
						post1Data = results.postData;

						topics.post({
							uid: gingerUid,
							cid: cid2,
							title: 'java mongodb redis',
							content: 'avocado cucumber carrot armadillo',
							tags: ['nodebb', 'bug', 'plugin', 'nodebb-plugin', 'javascript'],
						}, next);
					},
					function (results, next) {
						topic2Data = results.topicData;
						post2Data = results.postData;
						topics.reply({
							uid: phoebeUid,
							content: 'reply post apple',
							tid: topic2Data.tid,
						}, next);
					},
					function (_post3Data, next) {
						post3Data = _post3Data;
						setTimeout(next, 500);
					},
				], next);
			},
		], done);
	});

	it('should search term in titles and posts', (done) => {
		const meta = require('../src/meta');
		const qs = `/api/search?term=cucumber&in=titlesposts&categories[]=${cid1}&by=phoebe&replies=1&repliesFilter=atleast&sortBy=timestamp&sortDirection=desc&showAs=posts`;
		privileges.global.give(['groups:search:content'], 'guests', (err) => {
			assert.ifError(err);
			request({
				url: nconf.get('url') + qs,
				json: true,
			}, (err, response, body) => {
				assert.ifError(err);
				assert(body);
				assert.equal(body.matchCount, 1);
				assert.equal(body.posts.length, 1);
				assert.equal(body.posts[0].pid, post1Data.pid);
				assert.equal(body.posts[0].uid, phoebeUid);

				privileges.global.rescind(['groups:search:content'], 'guests', done);
			});
		});
	});

	it('should search for a user', (done) => {
		search.search({
			query: 'gin',
			searchIn: 'users',
		}, (err, data) => {
			assert.ifError(err);
			assert(data);
			assert.equal(data.matchCount, 1);
			assert.equal(data.users.length, 1);
			assert.equal(data.users[0].uid, gingerUid);
			assert.equal(data.users[0].username, 'ginger');
			done();
		});
	});

	it('should search for a tag', (done) => {
		search.search({
			query: 'plug',
			searchIn: 'tags',
		}, (err, data) => {
			assert.ifError(err);
			assert(data);
			assert.equal(data.matchCount, 1);
			assert.equal(data.tags.length, 1);
			assert.equal(data.tags[0].value, 'plugin');
			assert.equal(data.tags[0].score, 2);
			done();
		});
	});

	it('should search for a category', async () => {
		await categories.create({
			name: 'foo category',
			description: 'Test category created by testing script',
		});
		await categories.create({
			name: 'baz category',
			description: 'Test category created by testing script',
		});
		const result = await search.search({
			query: 'baz',
			searchIn: 'categories',
		});
		assert.strictEqual(result.matchCount, 1);
		assert.strictEqual(result.categories[0].name, 'baz category');
	});

	it('should search for categories', async () => {
		const socketCategories = require('../src/socket.io/categories');
		let data = await socketCategories.categorySearch({ uid: phoebeUid }, { query: 'baz', parentCid: 0 });
		assert.strictEqual(data[0].name, 'baz category');
		data = await socketCategories.categorySearch({ uid: phoebeUid }, { query: '', parentCid: 0 });
		assert.strictEqual(data.length, 5);
	});

	it('should fail if searchIn is wrong', (done) => {
		search.search({
			query: 'plug',
			searchIn: 'invalidfilter',
		}, (err) => {
			assert.equal(err.message, '[[error:unknown-search-filter]]');
			done();
		});
	});

	it('should search with tags filter', (done) => {
		search.search({
			query: 'mongodb',
			searchIn: 'titles',
			hasTags: ['nodebb', 'javascript'],
		}, (err, data) => {
			assert.ifError(err);
			assert.equal(data.posts[0].tid, topic2Data.tid);
			done();
		});
	});

	it('should not crash if tags is not an array', (done) => {
		search.search({
			query: 'mongodb',
			searchIn: 'titles',
			hasTags: 'nodebb,javascript',
		}, (err, data) => {
			assert.ifError(err);
			done();
		});
	});

	it('should not find anything', (done) => {
		search.search({
			query: 'xxxxxxxxxxxxxx',
		}, (err, data) => {
			assert.ifError(err);
			assert(Array.isArray(data.posts));
			assert(!data.matchCount);
			done();
		});
	});

	it('should search child categories', (done) => {
		async.waterfall([
			function (next) {
				topics.post({
					uid: gingerUid,
					cid: cid3,
					title: 'child category topic',
					content: 'avocado cucumber carrot armadillo',
				}, next);
			},
			function (result, next) {
				search.search({
					query: 'avocado',
					searchIn: 'titlesposts',
					categories: [cid2],
					searchChildren: true,
					sortBy: 'topic.timestamp',
					sortDirection: 'desc',
				}, next);
			},
			function (result, next) {
				assert(result.posts.length, 2);
				assert(result.posts[0].topic.title === 'child category topic');
				assert(result.posts[1].topic.title === 'java mongodb redis');
				next();
			},
		], done);
	});

	it('should return json search data with no categories', (done) => {
		const qs = '/api/search?term=cucumber&in=titlesposts&searchOnly=1';
		privileges.global.give(['groups:search:content'], 'guests', (err) => {
			assert.ifError(err);
			request({
				url: nconf.get('url') + qs,
				json: true,
			}, (err, response, body) => {
				assert.ifError(err);
				assert(body);
				assert(body.hasOwnProperty('matchCount'));
				assert(body.hasOwnProperty('pagination'));
				assert(body.hasOwnProperty('pageCount'));
				assert(body.hasOwnProperty('posts'));
				assert(!body.hasOwnProperty('categories'));

				privileges.global.rescind(['groups:search:content'], 'guests', done);
			});
		});
	});
'use strict';

const fs = require('fs');
const path = require('path');
const assert = require('assert');
const nconf = require('nconf');
const request = require('request-promise-native');

const db = require('./mocks/databasemock');

const meta = require('../src/meta');
const user = require('../src/user');
const groups = require('../src/groups');
const topics = require('../src/topics');
const posts = require('../src/posts');
const categories = require('../src/categories');
const plugins = require('../src/plugins');
const file = require('../src/file');
const utils = require('../src/utils');

const helpers = require('./helpers');

describe('Topic thumbs', () => {
	let topicObj;
	let categoryObj;
	let adminUid;
	let adminJar;
	let adminCSRF;
	let fooJar;
	let fooCSRF;
	let fooUid;
	const thumbPaths = [
		`${nconf.get('upload_path')}/files/test.png`,
		`${nconf.get('upload_path')}/files/test2.png`,
		'https://example.org',
	];
	const relativeThumbPaths = thumbPaths.map(path => path.replace(nconf.get('upload_path'), ''));
	const uuid = utils.generateUUID();

	function createFiles() {
		fs.closeSync(fs.openSync(path.resolve(__dirname, './uploads', thumbPaths[0]), 'w'));
		fs.closeSync(fs.openSync(path.resolve(__dirname, './uploads', thumbPaths[1]), 'w'));
	}

	before(async () => {
		meta.config.allowTopicsThumbnail = 1;

		adminUid = await user.create({ username: 'admin', password: '123456' });
		fooUid = await user.create({ username: 'foo', password: '123456' });
		await groups.join('administrators', adminUid);
		({ adminJar, adminCSRF } = await new Promise((resolve, reject) => {
			helpers.loginUser('admin', '123456', (err, adminJar, adminCSRF) => {
				if (err) {
					return reject(err);
				}

				resolve({ adminJar, adminCSRF });
			});
		}));
		({ fooJar, fooCSRF } = await new Promise((resolve, reject) => {
			helpers.loginUser('foo', '123456', (err, fooJar, fooCSRF) => {
				if (err) {
					return reject(err);
				}

				resolve({ fooJar, fooCSRF });
			});
		}));

		categoryObj = await categories.create({
			name: 'Test Category',
			description: 'Test category created by testing script',
		});
		topicObj = await topics.post({
			uid: adminUid,
			cid: categoryObj.cid,
			title: 'Test Topic Title',
			content: 'The content of test topic',
		});

		// Touch a couple files and associate it to a topic
		createFiles();
		await db.sortedSetAdd(`topic:${topicObj.topicData.tid}:thumbs`, 0, `${relativeThumbPaths[0]}`);
	});

	it('should return bool for whether a thumb exists', async () => {
		const exists = await topics.thumbs.exists(topicObj.topicData.tid, `${relativeThumbPaths[0]}`);
		assert.strictEqual(exists, true);
	});

	describe('.get()', () => {
		it('should return an array of thumbs', async () => {
			require('../src/cache').del(`topic:${topicObj.topicData.tid}:thumbs`);
			const thumbs = await topics.thumbs.get(topicObj.topicData.tid);
			assert.deepStrictEqual(thumbs, [{
				id: 1,
				name: 'test.png',
				url: `${nconf.get('relative_path')}${nconf.get('upload_url')}${relativeThumbPaths[0]}`,
			}]);
		});

		it('should return an array of an array of thumbs if multiple tids are passed in', async () => {
			const thumbs = await topics.thumbs.get([topicObj.topicData.tid, topicObj.topicData.tid + 1]);
			assert.deepStrictEqual(thumbs, [
				[{
					id: 1,
					name: 'test.png',
					url: `${nconf.get('relative_path')}${nconf.get('upload_url')}${relativeThumbPaths[0]}`,
				}],
				[],
			]);
		});
	});

	describe('.associate()', () => {
		let tid;
		let mainPid;

		before(async () => {
			topicObj = await topics.post({
				uid: adminUid,
				cid: categoryObj.cid,
				title: 'Test Topic Title',
				content: 'The content of test topic',
			});
			tid = topicObj.topicData.tid;
			mainPid = topicObj.postData.pid;
		});

		it('should add an uploaded file to a zset', async () => {
			await topics.thumbs.associate({
				id: tid,
				path: relativeThumbPaths[0],
			});

			const exists = await db.isSortedSetMember(`topic:2:thumbs`, relativeThumbPaths[0]);
			assert(exists);
		});

		it('should also work with UUIDs', async () => {
			await topics.thumbs.associate({
				id: uuid,
				path: relativeThumbPaths[1],
				score: 5,
			});

			const exists = await db.isSortedSetMember(`draft:${uuid}:thumbs`, relativeThumbPaths[1]);
			assert(exists);
		});

		it('should also work with a URL', async () => {
			await topics.thumbs.associate({
				id: tid,
				path: relativeThumbPaths[2],
			});

			const exists = await db.isSortedSetMember(`topic:2:thumbs`, relativeThumbPaths[2]);
			assert(exists);
		});

		it('should have a score equal to the number of thumbs prior to addition', async () => {
			const scores = await db.sortedSetScores('topic:2:thumbs', [relativeThumbPaths[0], relativeThumbPaths[2]]);
			assert.deepStrictEqual(scores, [0, 1]);
		});

		it('should update the relevant topic hash with the number of thumbnails', async () => {
			const numThumbs = await topics.getTopicField(2, 'numThumbs');
			assert.strictEqual(parseInt(numThumbs, 10), 2);
		});

		it('should successfully associate a thumb with a topic even if it already contains that thumbnail (updates score)', async () => {
			await topics.thumbs.associate({
				id: tid,
				path: relativeThumbPaths[0],
			});

			const score = await db.sortedSetScore(`topic:2:thumbs`, relativeThumbPaths[0]);

			assert(isFinite(score));	// exists in set
			assert.strictEqual(score, 2);
		});

		it('should update the score to be passed in as the third argument', async () => {
			await topics.thumbs.associate({
				id: tid,
				path: relativeThumbPaths[0],
				score: 0,
			});

			const score = await db.sortedSetScore(`topic:2:thumbs`, relativeThumbPaths[0]);

			assert(isFinite(score));	// exists in set
			assert.strictEqual(score, 0);
		});

		it('should associate the thumbnail with that topic\'s main pid\'s uploads', async () => {
			const uploads = await posts.uploads.list(mainPid);
			assert(uploads.includes(path.basename(relativeThumbPaths[0])));
		});

		it('should maintain state in the topic\'s main pid\'s uploads if posts.uploads.sync() is called', async () => {
			await posts.uploads.sync(mainPid);
			const uploads = await posts.uploads.list(mainPid);
			assert(uploads.includes(path.basename(relativeThumbPaths[0])));
		});
	});

	describe('.migrate()', () => {
		it('should combine the thumbs uploaded to a UUID zset and combine it with a topic\'s thumb zset', async () => {
			await topics.thumbs.migrate(uuid, 2);

			const thumbs = await topics.thumbs.get(2);
			assert.strictEqual(thumbs.length, 3);
			assert.deepStrictEqual(thumbs, [
				{
					id: 2,
					name: 'test.png',
					url: `${nconf.get('relative_path')}${nconf.get('upload_url')}${relativeThumbPaths[0]}`,
				},
				{
					id: 2,
					name: 'example.org',
					url: 'https://example.org',
				},
				{
					id: 2,
					name: 'test2.png',
					url: `${nconf.get('relative_path')}${nconf.get('upload_url')}${relativeThumbPaths[1]}`,
				},
			]);
		});
	});

	describe(`.delete()`, () => {
		it('should remove a file from sorted set AND disk', async () => {
			await topics.thumbs.associate({
				id: 1,
				path: thumbPaths[0],
			});
			await topics.thumbs.delete(1, relativeThumbPaths[0]);

			assert.strictEqual(await db.isSortedSetMember('topic:1:thumbs', relativeThumbPaths[0]), false);
			assert.strictEqual(await file.exists(thumbPaths[0]), false);
		});

		it('should no longer be associated with that topic\'s main pid\'s uploads', async () => {
			const mainPid = (await topics.getMainPids([1]))[0];
			const uploads = await posts.uploads.list(mainPid);
			assert(!uploads.includes(path.basename(relativeThumbPaths[0])));
		});

		it('should also work with UUIDs', async () => {
			await topics.thumbs.associate({
				id: uuid,
				path: thumbPaths[1],
			});
			await topics.thumbs.delete(uuid, relativeThumbPaths[1]);

			assert.strictEqual(await db.isSortedSetMember(`draft:${uuid}:thumbs`, relativeThumbPaths[1]), false);
			assert.strictEqual(await file.exists(thumbPaths[1]), false);
		});

		it('should also work with URLs', async () => {
			await topics.thumbs.associate({
				id: uuid,
				path: thumbPaths[2],
			});
			await topics.thumbs.delete(uuid, relativeThumbPaths[2]);

			assert.strictEqual(await db.isSortedSetMember(`draft:${uuid}:thumbs`, relativeThumbPaths[2]), false);
		});

		it('should not delete the file from disk if not associated with the tid', async () => {
			createFiles();
			await topics.thumbs.delete(uuid, thumbPaths[0]);
			assert.strictEqual(await file.exists(thumbPaths[0]), true);
		});
	});

	describe('HTTP calls to topic thumb routes', () => {
		before(() => {
			createFiles();
		});

		it('should succeed with a valid tid', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/1/thumbs`, path.join(__dirname, './files/test.png'), {}, adminJar, adminCSRF, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 200);
				done();
			});
		});

		it('should succeed with a uuid', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/${uuid}/thumbs`, path.join(__dirname, './files/test.png'), {}, adminJar, adminCSRF, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 200);
				done();
			});
		});

		it('should succeed with uploader plugins', async () => {
			const hookMethod = async () => ({
				name: 'test.png',
				url: 'https://example.org',
			});
			await plugins.hooks.register('test', {
				hook: 'filter:uploadFile',
				method: hookMethod,
			});

			await new Promise((resolve) => {
				helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/${uuid}/thumbs`, path.join(__dirname, './files/test.png'), {}, adminJar, adminCSRF, (err, res, body) => {
					assert.ifError(err);
					assert.strictEqual(res.statusCode, 200);
					resolve();
				});
			});

			await plugins.hooks.unregister('test', 'filter:uploadFile', hookMethod);
		});

		it('should fail with a non-existant tid', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/3/thumbs`, path.join(__dirname, './files/test.png'), {}, adminJar, adminCSRF, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 404);
				done();
			});
		});

		it('should fail when garbage is passed in', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/abracadabra/thumbs`, path.join(__dirname, './files/test.png'), {}, adminJar, adminCSRF, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 404);
				done();
			});
		});

		it('should fail when calling user cannot edit the tid', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/1/thumbs`, path.join(__dirname, './files/test.png'), {}, fooJar, fooCSRF, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 403);
				done();
			});
		});

		it('should fail if thumbnails are not enabled', (done) => {
			meta.config.allowTopicsThumbnail = 0;

			helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/${uuid}/thumbs`, path.join(__dirname, './files/test.png'), {}, adminJar, adminCSRF, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 503);
				assert(body && body.status);
				assert.strictEqual(body.status.message, '[[error:topic-thumbnails-are-disabled]]');
				done();
			});
		});

		it('should fail if file is not image', (done) => {
			meta.config.allowTopicsThumbnail = 1;

			helpers.uploadFile(`${nconf.get('url')}/api/v3/topics/${uuid}/thumbs`, path.join(__dirname, './files/503.html'), {}, adminJar, adminCSRF, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 500);
				assert(body && body.status);
				assert.strictEqual(body.status.message, '[[error:invalid-file]]');
'use strict';


const { execSync } = require('child_process');
const path = require('path');
const { readFileSync } = require('fs');

const assert = require('assert');

describe('Package install', () => {
	it('should remove non-`nodebb-` modules not specified in `install/package.json`', () => {
		const packageFilePath = path.join(__dirname, '../package.json');

		// install an extra package
		// chose dotenv because it's a popular package
		// and we use nconf instead
		execSync('npm install dotenv --save --production');

		// assert it saves in package.json
		const packageWithExtras = JSON.parse(readFileSync(packageFilePath, 'utf8'));
		assert(packageWithExtras.dependencies.dotenv, 'dependency did not save');

		// update the package file
		require('../src/cli/package-install').updatePackageFile();

'use strict';

const assert = require('assert');
const async = require('async');
const path = require('path');
const nconf = require('nconf');
const request = require('request');
const requestAsync = require('request-promise-native');
const jwt = require('jsonwebtoken');

const db = require('./mocks/databasemock');
const User = require('../src/user');
const Topics = require('../src/topics');
const Categories = require('../src/categories');
const Posts = require('../src/posts');
const Password = require('../src/password');
const groups = require('../src/groups');
const helpers = require('./helpers');
const meta = require('../src/meta');
const plugins = require('../src/plugins');
const socketUser = require('../src/socket.io/user');

describe('User', () => {
	let userData;
	let testUid;
	let testCid;

	const plugins = require('../src/plugins');

	async function dummyEmailerHook(data) {
		// pretend to handle sending emails
	}
	before((done) => {
		// Attach an emailer hook so related requests do not error
		plugins.hooks.register('emailer-test', {
			hook: 'filter:email.send',
			method: dummyEmailerHook,
		});

		Categories.create({
			name: 'Test Category',
			description: 'A test',
			order: 1,
		}, (err, categoryObj) => {
			if (err) {
				return done(err);
			}

			testCid = categoryObj.cid;
			done();
		});
	});
	after(() => {
		plugins.hooks.unregister('emailer-test', 'filter:email.send');
	});

	beforeEach(() => {
		userData = {
			username: 'John Smith',
			fullname: 'John Smith McNamara',
			password: 'swordfish',
			email: 'john@example.com',
			callback: undefined,
		};
	});


	describe('.create(), when created', () => {
		it('should be created properly', async () => {
			testUid = await User.create({ username: userData.username, password: userData.password, email: userData.email });
			assert.ok(testUid);
		});

		it('should be created properly', async () => {
			const uid = await User.create({ username: 'weirdemail', email: '<h1>test</h1>@gmail.com' });
			const data = await User.getUserData(uid);
			assert.equal(data.email, '&lt;h1&gt;test&lt;&#x2F;h1&gt;@gmail.com');
			assert.strictEqual(data.profileviews, 0);
			assert.strictEqual(data.reputation, 0);
			assert.strictEqual(data.postcount, 0);
			assert.strictEqual(data.topiccount, 0);
			assert.strictEqual(data.lastposttime, 0);
			assert.strictEqual(data.banned, false);
		});

		it('should have a valid email, if using an email', (done) => {
			User.create({ username: userData.username, password: userData.password, email: 'fakeMail' }, (err) => {
				assert(err);
				assert.equal(err.message, '[[error:invalid-email]]');
				done();
			});
		});

		it('should error with invalid password', (done) => {
			User.create({ username: 'test', password: '1' }, (err) => {
				assert.equal(err.message, '[[reset_password:password_too_short]]');
				done();
			});
		});

		it('should error with invalid password', (done) => {
			User.create({ username: 'test', password: {} }, (err) => {
				assert.equal(err.message, '[[error:invalid-password]]');
				done();
			});
		});

		it('should error with a too long password', (done) => {
			let toolong = '';
			for (let i = 0; i < 5000; i++) {
				toolong += 'a';
			}
			User.create({ username: 'test', password: toolong }, (err) => {
				assert.equal(err.message, '[[error:password-too-long]]');
				done();
			});
		});

		it('should error if username is already taken or rename user', async () => {
			let err;
			async function tryCreate(data) {
				try {
					return await User.create(data);
				} catch (_err) {
					err = _err;
				}
			}

			const [uid1, uid2] = await Promise.all([
				tryCreate({ username: 'dupe1' }),
				tryCreate({ username: 'dupe1' }),
			]);
			if (err) {
				assert.strictEqual(err.message, '[[error:username-taken]]');
			} else {
				const userData = await User.getUsersFields([uid1, uid2], ['username']);
				const userNames = userData.map(u => u.username);
				// make sure only 1 dupe1 is created
				assert.equal(userNames.filter(username => username === 'dupe1').length, 1);
				assert.equal(userNames.filter(username => username === 'dupe1 0').length, 1);
			}
		});

		it('should error if email is already taken', async () => {
			let err;
			async function tryCreate(data) {
				try {
					return await User.create(data);
				} catch (_err) {
					err = _err;
				}
			}

			await Promise.all([
				tryCreate({ username: 'notdupe1', email: 'dupe@dupe.com' }),
				tryCreate({ username: 'notdupe2', email: 'dupe@dupe.com' }),
			]);
			assert.strictEqual(err.message, '[[error:email-taken]]');
		});
	});

	describe('.uniqueUsername()', () => {
		it('should deal with collisions', (done) => {
			const users = [];
			for (let i = 0; i < 10; i += 1) {
				users.push({
					username: 'Jane Doe',
					email: `jane.doe${i}@example.com`,
				});
			}

			async.series([
				function (next) {
					async.eachSeries(users, (user, next) => {
						User.create(user, next);
					}, next);
				},
				function (next) {
					User.uniqueUsername({
						username: 'Jane Doe',
						userslug: 'jane-doe',
					}, (err, username) => {
						assert.ifError(err);

						assert.strictEqual(username, 'Jane Doe 9');
						next();
					});
				},
			], done);
		});
	});

	describe('.isModerator()', () => {
		it('should return false', (done) => {
			User.isModerator(testUid, testCid, (err, isModerator) => {
				assert.equal(err, null);
				assert.equal(isModerator, false);
				done();
			});
		});

		it('should return two false results', (done) => {
			User.isModerator([testUid, testUid], testCid, (err, isModerator) => {
				assert.equal(err, null);
				assert.equal(isModerator[0], false);
				assert.equal(isModerator[1], false);
				done();
			});
		});

		it('should return two false results', (done) => {
			User.isModerator(testUid, [testCid, testCid], (err, isModerator) => {
				assert.equal(err, null);
				assert.equal(isModerator[0], false);
				assert.equal(isModerator[1], false);
				done();
			});
		});
	});

	describe('.getModeratorUids()', () => {
		before((done) => {
			groups.join('cid:1:privileges:moderate', 1, done);
		});

		it('should retrieve all users with moderator bit in category privilege', (done) => {
			User.getModeratorUids((err, uids) => {
				assert.ifError(err);
				assert.strictEqual(1, uids.length);
				assert.strictEqual(1, parseInt(uids[0], 10));
				done();
			});
		});

		after((done) => {
			groups.leave('cid:1:privileges:moderate', 1, done);
		});
	});

	describe('.getModeratorUids()', () => {
		before((done) => {
			async.series([
				async.apply(groups.create, { name: 'testGroup' }),
				async.apply(groups.join, 'cid:1:privileges:groups:moderate', 'testGroup'),
				async.apply(groups.join, 'testGroup', 1),
			], done);
		});

		it('should retrieve all users with moderator bit in category privilege', (done) => {
			User.getModeratorUids((err, uids) => {
				assert.ifError(err);
				assert.strictEqual(1, uids.length);
				assert.strictEqual(1, parseInt(uids[0], 10));
				done();
			});
		});

		after((done) => {
			async.series([
				async.apply(groups.leave, 'cid:1:privileges:groups:moderate', 'testGroup'),
				async.apply(groups.destroy, 'testGroup'),
			], done);
		});
	});

	describe('.isReadyToPost()', () => {
		it('should error when a user makes two posts in quick succession', (done) => {
			meta.config = meta.config || {};
			meta.config.postDelay = '10';

			async.series([
				async.apply(Topics.post, {
					uid: testUid,
					title: 'Topic 1',
					content: 'lorem ipsum',
					cid: testCid,
				}),
				async.apply(Topics.post, {
					uid: testUid,
					title: 'Topic 2',
					content: 'lorem ipsum',
					cid: testCid,
				}),
			], (err) => {
				assert(err);
				done();
			});
		});

		it('should allow a post if the last post time is > 10 seconds', (done) => {
			User.setUserField(testUid, 'lastposttime', +new Date() - (11 * 1000), () => {
				Topics.post({
					uid: testUid,
					title: 'Topic 3',
					content: 'lorem ipsum',
					cid: testCid,
				}, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});

		it('should error when a new user posts if the last post time is 10 < 30 seconds', (done) => {
			meta.config.newbiePostDelay = 30;
			meta.config.newbiePostDelayThreshold = 3;

			User.setUserField(testUid, 'lastposttime', +new Date() - (20 * 1000), () => {
				Topics.post({
					uid: testUid,
					title: 'Topic 4',
					content: 'lorem ipsum',
					cid: testCid,
				}, (err) => {
					assert(err);
					done();
				});
			});
		});

		it('should not error if a non-newbie user posts if the last post time is 10 < 30 seconds', (done) => {
			User.setUserFields(testUid, {
				lastposttime: +new Date() - (20 * 1000),
				reputation: 10,
			}, () => {
				Topics.post({
					uid: testUid,
					title: 'Topic 5',
					content: 'lorem ipsum',
					cid: testCid,
				}, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});
	});

	describe('.search()', () => {
		let adminUid;
		let uid;
		before(async () => {
			adminUid = await User.create({ username: 'noteadmin' });
			await groups.join('administrators', adminUid);
		});

		it('should return an object containing an array of matching users', (done) => {
			User.search({ query: 'john' }, (err, searchData) => {
				assert.ifError(err);
				uid = searchData.users[0].uid;
				assert.equal(Array.isArray(searchData.users) && searchData.users.length > 0, true);
				assert.equal(searchData.users[0].username, 'John Smith');
				done();
			});
		});

		it('should search user', (done) => {
			socketUser.search({ uid: testUid }, { query: 'john' }, (err, searchData) => {
				assert.ifError(err);
				assert.equal(searchData.users[0].username, 'John Smith');
				done();
			});
		});

		it('should error for guest', (done) => {
			socketUser.search({ uid: 0 }, { query: 'john' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should error with invalid data', (done) => {
			socketUser.search({ uid: testUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error for unprivileged user', (done) => {
			socketUser.search({ uid: testUid }, { searchBy: 'ip', query: '123' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should error for unprivileged user', (done) => {
			socketUser.search({ uid: testUid }, { filters: ['banned'], query: '123' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should error for unprivileged user', (done) => {
			socketUser.search({ uid: testUid }, { filters: ['flagged'], query: '123' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should search users by ip', async () => {
			const uid = await User.create({ username: 'ipsearch' });
			await db.sortedSetAdd('ip:1.1.1.1:uid', [1, 1], [testUid, uid]);
			const data = await socketUser.search({ uid: adminUid }, { query: '1.1.1.1', searchBy: 'ip' });
			assert(Array.isArray(data.users));
			assert.equal(data.users.length, 2);
		});

		it('should search users by uid', (done) => {
			socketUser.search({ uid: testUid }, { query: uid, searchBy: 'uid' }, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data.users));
				assert.equal(data.users[0].uid, uid);
				done();
			});
		});

		it('should search users by fullname', async () => {
			const uid = await User.create({ username: 'fullnamesearch1', fullname: 'Mr. Fullname' });
			const data = await socketUser.search({ uid: adminUid }, { query: 'mr', searchBy: 'fullname' });
			assert(Array.isArray(data.users));
			assert.equal(data.users.length, 1);
			assert.equal(uid, data.users[0].uid);
		});

		it('should search users by fullname', async () => {
			const uid = await User.create({ username: 'fullnamesearch2', fullname: 'Baris:Usakli' });
			const data = await socketUser.search({ uid: adminUid }, { query: 'baris:', searchBy: 'fullname' });
			assert(Array.isArray(data.users));
			assert.equal(data.users.length, 1);
			assert.equal(uid, data.users[0].uid);
		});

		it('should return empty array if query is empty', (done) => {
			socketUser.search({ uid: testUid }, { query: '' }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.users.length, 0);
				done();
			});
		});

		it('should filter users', (done) => {
			User.create({ username: 'ipsearch_filter' }, (err, uid) => {
				assert.ifError(err);
				User.bans.ban(uid, 0, '', (err) => {
					assert.ifError(err);
					User.setUserFields(uid, { flags: 10 }, (err) => {
						assert.ifError(err);
						socketUser.search({ uid: adminUid }, {
							query: 'ipsearch',
							filters: ['online', 'banned', 'flagged'],
						}, (err, data) => {
							assert.ifError(err);
							assert.equal(data.users[0].username, 'ipsearch_filter');
							done();
						});
					});
				});
			});
		});

		it('should sort results by username', (done) => {
			async.waterfall([
				function (next) {
					User.create({ username: 'brian' }, next);
				},
				function (uid, next) {
					User.create({ username: 'baris' }, next);
				},
				function (uid, next) {
					User.create({ username: 'bzari' }, next);
				},
				function (uid, next) {
					User.search({
						uid: testUid,
						query: 'b',
						sortBy: 'username',
						paginate: false,
					}, next);
				},
			], (err, data) => {
				assert.ifError(err);
				assert.equal(data.users[0].username, 'baris');
				assert.equal(data.users[1].username, 'brian');
				assert.equal(data.users[2].username, 'bzari');
				done();
			});
		});
	});

	describe('.delete()', () => {
		let uid;
		before((done) => {
			User.create({ username: 'usertodelete', password: '123456', email: 'delete@me.com' }, (err, newUid) => {
				assert.ifError(err);
				uid = newUid;
				done();
			});
		});

		it('should delete a user account', (done) => {
			User.delete(1, uid, (err) => {
				assert.ifError(err);
				User.existsBySlug('usertodelete', (err, exists) => {
					assert.ifError(err);
					assert.equal(exists, false);
					done();
				});
			});
		});

		it('should not re-add user to users:postcount if post is deleted after user deletion', async () => {
			const uid = await User.create({ username: 'olduserwithposts' });
			assert(await db.isSortedSetMember('users:postcount', uid));

			const result = await Topics.post({
				uid: uid,
				title: 'old user topic',
				content: 'old user topic post content',
				cid: testCid,
			});
			assert.equal(await db.sortedSetScore('users:postcount', uid), 1);
			await User.deleteAccount(uid);
			assert(!await db.isSortedSetMember('users:postcount', uid));
			await Posts.purge(result.postData.pid, 1);
			assert(!await db.isSortedSetMember('users:postcount', uid));
		});

		it('should not re-add user to users:reputation if post is upvoted after user deletion', async () => {
			const uid = await User.create({ username: 'olduserwithpostsupvote' });
			assert(await db.isSortedSetMember('users:reputation', uid));

			const result = await Topics.post({
				uid: uid,
				title: 'old user topic',
				content: 'old user topic post content',
				cid: testCid,
			});
			assert.equal(await db.sortedSetScore('users:reputation', uid), 0);
			await User.deleteAccount(uid);
			assert(!await db.isSortedSetMember('users:reputation', uid));
			await Posts.upvote(result.postData.pid, 1);
			assert(!await db.isSortedSetMember('users:reputation', uid));
		});
	});

	describe('passwordReset', () => {
		let uid;
		let code;
		before((done) => {
			User.create({ username: 'resetuser', password: '123456', email: 'reset@me.com' }, (err, newUid) => {
				assert.ifError(err);
				uid = newUid;
				done();
			});
		});

		it('.generate() should generate a new reset code', (done) => {
			User.reset.generate(uid, (err, _code) => {
				assert.ifError(err);
				assert(_code);

				code = _code;
				done();
			});
		});

		it('.validate() should ensure that this new code is valid', (done) => {
			User.reset.validate(code, (err, valid) => {
				assert.ifError(err);
				assert.strictEqual(valid, true);
				done();
			});
		});

		it('.validate() should correctly identify an invalid code', (done) => {
			User.reset.validate(`${code}abcdef`, (err, valid) => {
				assert.ifError(err);
				assert.strictEqual(valid, false);
				done();
			});
		});

		it('.send() should create a new reset code and reset password', (done) => {
			User.reset.send('reset@me.com', (err) => {
				if (err) {
					console.log(err);
				}
				done();
			});
		});

		it('.commit() should update the user\'s password and confirm their email', (done) => {
			User.reset.commit(code, 'newpassword', (err) => {
				assert.ifError(err);

				async.parallel({
					userData: function (next) {
						User.getUserData(uid, next);
					},
					password: function (next) {
						db.getObjectField(`user:${uid}`, 'password', next);
					},
				}, (err, results) => {
					assert.ifError(err);
					Password.compare('newpassword', results.password, true, (err, match) => {
						assert.ifError(err);
						assert(match);
						assert.strictEqual(results.userData['email:confirmed'], 1);
						done();
					});
				});
			});
		});

		it('.commit() should invalidate old codes', (done) => {
			let code1;
			let code2;
			let uid;
			async.waterfall([
				function (next) {
					User.create({ username: 'doublereseter', email: 'sorry@forgot.com', password: '123456' }, next);
				},
				function (_uid, next) {
					uid = _uid;
					User.reset.generate(uid, next);
				},
				function (code, next) {
					code1 = code;
					User.reset.generate(uid, next);
				},
				function (code, next) {
					code2 = code;
					User.reset.validate(code1, next);
				},
				function (isValid, next) {
					assert(isValid);
					User.reset.commit(code2, 'newPwd123', next);
				},
				function (next) {
					User.reset.validate(code1, next);
				},
				function (isValid, next) {
					assert(!isValid);
					next();
				},
			], done);
		});

		it('.should error if same password is used for reset', async () => {
			const uid = await User.create({ username: 'badmemory', email: 'bad@memory.com', password: '123456' });
			const code = await User.reset.generate(uid);
			let err;
			try {
				await User.reset.commit(code, '123456');
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, '[[error:reset-same-password]]');
		});

		it('should not validate email if password reset is due to expiry', async () => {
			const uid = await User.create({ username: 'resetexpiry', email: 'reset@expiry.com', password: '123456' });
			let confirmed = await User.getUserField(uid, 'email:confirmed');
			let [verified, unverified] = await groups.isMemberOfGroups(uid, ['verified-users', 'unverified-users']);
			assert.strictEqual(confirmed, 0);
			assert.strictEqual(verified, false);
			assert.strictEqual(unverified, true);
			await User.setUserField(uid, 'passwordExpiry', Date.now());
			const code = await User.reset.generate(uid);
			await User.reset.commit(code, '654321');
			confirmed = await User.getUserField(uid, 'email:confirmed');
			[verified, unverified] = await groups.isMemberOfGroups(uid, ['verified-users', 'unverified-users']);
			assert.strictEqual(confirmed, 0);
			assert.strictEqual(verified, false);
			assert.strictEqual(unverified, true);
		});
	});

	describe('hash methods', () => {
		it('should return uid from email', (done) => {
			User.getUidByEmail('john@example.com', (err, uid) => {
				assert.ifError(err);
				assert.equal(parseInt(uid, 10), parseInt(testUid, 10));
				done();
			});
		});

		it('should return uid from username', (done) => {
			User.getUidByUsername('John Smith', (err, uid) => {
				assert.ifError(err);
				assert.equal(parseInt(uid, 10), parseInt(testUid, 10));
				done();
			});
		});

		it('should return uid from userslug', (done) => {
			User.getUidByUserslug('john-smith', (err, uid) => {
				assert.ifError(err);
				assert.equal(parseInt(uid, 10), parseInt(testUid, 10));
				done();
			});
		});

		it('should get user data even if one uid is NaN', (done) => {
			User.getUsersData([NaN, testUid], (err, data) => {
				assert.ifError(err);
				assert(data[0]);
				assert.equal(data[0].username, '[[global:guest]]');
				assert(data[1]);
				assert.equal(data[1].username, userData.username);
				done();
			});
		});

		it('should not return private user data', (done) => {
			User.setUserFields(testUid, {
				fb_token: '123123123',
				another_secret: 'abcde',
				postcount: '123',
			}, (err) => {
				assert.ifError(err);
				User.getUserData(testUid, (err, userData) => {
					assert.ifError(err);
					assert(!userData.hasOwnProperty('fb_token'));
					assert(!userData.hasOwnProperty('another_secret'));
					assert(!userData.hasOwnProperty('password'));
					assert(!userData.hasOwnProperty('rss_token'));
					assert.strictEqual(userData.postcount, 123);
					assert.strictEqual(userData.uid, testUid);
					done();
				});
			});
		});

		it('should not return password even if explicitly requested', (done) => {
			User.getUserFields(testUid, ['password'], (err, payload) => {
				assert.ifError(err);
				assert(!payload.hasOwnProperty('password'));
				done();
			});
		});

		it('should return an icon text and valid background if username and picture is explicitly requested', async () => {
			const payload = await User.getUserFields(testUid, ['username', 'picture']);
			const validBackgrounds = await User.getIconBackgrounds(testUid);
			assert.strictEqual(payload['icon:text'], userData.username.slice(0, 1).toUpperCase());
			assert(payload['icon:bgColor']);
			assert(validBackgrounds.includes(payload['icon:bgColor']));
		});

		it('should return a valid background, even if an invalid background colour is set', async () => {
			await User.setUserField(testUid, 'icon:bgColor', 'teal');
			const payload = await User.getUserFields(testUid, ['username', 'picture']);
			const validBackgrounds = await User.getIconBackgrounds(testUid);

			assert(payload['icon:bgColor']);
			assert(validBackgrounds.includes(payload['icon:bgColor']));
		});

		it('should return private data if field is whitelisted', (done) => {
			function filterMethod(data, callback) {
				data.whitelist.push('another_secret');
				callback(null, data);
			}

			plugins.hooks.register('test-plugin', { hook: 'filter:user.whitelistFields', method: filterMethod });
			User.getUserData(testUid, (err, userData) => {
				assert.ifError(err);
				assert(!userData.hasOwnProperty('fb_token'));
				assert.equal(userData.another_secret, 'abcde');
				plugins.hooks.unregister('test-plugin', 'filter:user.whitelistFields', filterMethod);
				done();
			});
		});

		it('should return 0 as uid if username is falsy', (done) => {
			User.getUidByUsername('', (err, uid) => {
				assert.ifError(err);
				assert.strictEqual(uid, 0);
				done();
			});
		});

		it('should get username by userslug', (done) => {
			User.getUsernameByUserslug('john-smith', (err, username) => {
				assert.ifError(err);
				assert.strictEqual('John Smith', username);
				done();
			});
		});

		it('should get uids by emails', (done) => {
			User.getUidsByEmails(['john@example.com'], (err, uids) => {
				assert.ifError(err);
				assert.equal(uids[0], testUid);
				done();
			});
		});

		it('should not get groupTitle for guests', (done) => {
			User.getUserData(0, (err, userData) => {
				assert.ifError(err);
				assert.strictEqual(userData.groupTitle, '');
				assert.deepStrictEqual(userData.groupTitleArray, []);
				done();
			});
		});

		it('should load guest data', (done) => {
			User.getUsersData([1, 0], (err, data) => {
				assert.ifError(err);
				assert.strictEqual(data[1].username, '[[global:guest]]');
				assert.strictEqual(data[1].userslug, '');
				assert.strictEqual(data[1].uid, 0);
				done();
			});
		});
	});

	describe('not logged in', () => {
		it('should return error if not logged in', (done) => {
			socketUser.updateProfile({ uid: 0 }, { uid: 1 }, (err) => {
				assert.equal(err.message, '[[error:invalid-uid]]');
				done();
			});
		});
	});

	describe('profile methods', () => {
		let uid;
		let jar;

		before((done) => {
			User.create({ username: 'updateprofile', email: 'update@me.com', password: '123456' }, (err, newUid) => {
				assert.ifError(err);
				uid = newUid;
				helpers.loginUser('updateprofile', '123456', (err, _jar) => {
					assert.ifError(err);
					jar = _jar;
					done();
				});
			});
		});

		it('should return error if data is invalid', (done) => {
			socketUser.updateProfile({ uid: uid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should return error if data is missing uid', (done) => {
			socketUser.updateProfile({ uid: uid }, { username: 'bip', email: 'bop' }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should update a user\'s profile', (done) => {
			User.create({ username: 'justforupdate', email: 'just@for.updated', password: '123456' }, (err, uid) => {
				assert.ifError(err);
				const data = {
					uid: uid,
					username: 'updatedUserName',
					email: 'updatedEmail@me.com',
					fullname: 'updatedFullname',
					website: 'http://nodebb.org',
					location: 'izmir',
					groupTitle: 'testGroup',
					birthday: '01/01/1980',
					signature: 'nodebb is good',
					password: '123456',
				};
				socketUser.updateProfile({ uid: uid }, { ...data, password: '123456' }, (err, result) => {
					assert.ifError(err);

					assert.equal(result.username, 'updatedUserName');
					assert.equal(result.userslug, 'updatedusername');
					assert.equal(result.email, 'updatedEmail@me.com');

					db.getObject(`user:${uid}`, (err, userData) => {
						assert.ifError(err);
						Object.keys(data).forEach((key) => {
							if (key !== 'password') {
								assert.equal(data[key], userData[key]);
							} else {
								assert(userData[key].startsWith('$2a$'));
							}
						});
						done();
					});
				});
			});
		});

		it('should change a user\'s password', (done) => {
			User.create({ username: 'changepassword', password: '123456' }, (err, uid) => {
				assert.ifError(err);
				socketUser.changePassword({ uid: uid }, { uid: uid, newPassword: '654321', currentPassword: '123456' }, (err) => {
					assert.ifError(err);
					User.isPasswordCorrect(uid, '654321', '127.0.0.1', (err, correct) => {
						assert.ifError(err);
						assert(correct);
						done();
					});
				});
			});
		});

		it('should not let user change another user\'s password', async () => {
			const regularUserUid = await User.create({ username: 'regularuserpwdchange', password: 'regularuser1234' });
			const uid = await User.create({ username: 'changeadminpwd1', password: '123456' });
			let err;
			try {
				await socketUser.changePassword({ uid: uid }, { uid: regularUserUid, newPassword: '654321', currentPassword: '123456' });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, '[[user:change_password_error_privileges]]');
		});

		it('should not let user change admin\'s password', async () => {
			const adminUid = await User.create({ username: 'adminpwdchange', password: 'admin1234' });
			await groups.join('administrators', adminUid);
			const uid = await User.create({ username: 'changeadminpwd2', password: '123456' });

			let err;
			try {
				await socketUser.changePassword({ uid: uid }, { uid: adminUid, newPassword: '654321', currentPassword: '123456' });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, '[[user:change_password_error_privileges]]');
		});

		it('should let admin change another users password', async () => {
			const adminUid = await User.create({ username: 'adminpwdchange2', password: 'admin1234' });
			await groups.join('administrators', adminUid);
			const uid = await User.create({ username: 'forgotmypassword', password: '123456' });

			await socketUser.changePassword({ uid: adminUid }, { uid: uid, newPassword: '654321' });
			const correct = await User.isPasswordCorrect(uid, '654321', '127.0.0.1');
			assert(correct);
		});

		it('should not let admin change their password if current password is incorrect', async () => {
			const adminUid = await User.create({ username: 'adminforgotpwd', password: 'admin1234' });
			await groups.join('administrators', adminUid);

			let err;
			try {
				await socketUser.changePassword({ uid: adminUid }, { uid: adminUid, newPassword: '654321', currentPassword: 'wrongpwd' });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, '[[user:change_password_error_wrong_current]]');
		});

		it('should change username', (done) => {
			socketUser.changeUsernameEmail({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '123456' }, (err) => {
				assert.ifError(err);
				db.getObjectField(`user:${uid}`, 'username', (err, username) => {
					assert.ifError(err);
					assert.equal(username, 'updatedAgain');
					done();
				});
			});
		});

		it('should not let setting an empty username', async () => {
			await socketUser.changeUsernameEmail({ uid: uid }, { uid: uid, username: '', password: '123456' });
			const username = await db.getObjectField(`user:${uid}`, 'username');
			assert.strictEqual(username, 'updatedAgain');
		});

		it('should let updating profile if current username is above max length and it is not being changed', async () => {
			const maxLength = meta.config.maximumUsernameLength + 1;
			const longName = new Array(maxLength).fill('a').join('');
			const uid = await User.create({ username: longName });
			await socketUser.changeUsernameEmail({ uid: uid }, { uid: uid, username: longName, email: 'verylong@name.com' });
			const userData = await db.getObject(`user:${uid}`);
			assert.strictEqual(userData.username, longName);
			assert.strictEqual(userData.email, 'verylong@name.com');
		});

		it('should not update a user\'s username if it did not change', (done) => {
			socketUser.changeUsernameEmail({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '123456' }, (err) => {
				assert.ifError(err);
				db.getSortedSetRevRange(`user:${uid}:usernames`, 0, -1, (err, data) => {
					assert.ifError(err);
					assert.equal(data.length, 2);
					assert(data[0].startsWith('updatedAgain'));
					done();
				});
			});
		});

		it('should not update a user\'s username if a password is not supplied', async () => {
			let _err;
			try {
				await socketUser.updateProfile({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '' });
			} catch (err) {
				_err = err;
			}

			assert(_err);
			assert.strictEqual(_err.message, '[[error:invalid-password]]');
		});

		it('should change email', (done) => {
			User.create({ username: 'pooremailupdate', email: 'poor@update.me', password: '123456' }, (err, uid) => {
				assert.ifError(err);
				socketUser.changeUsernameEmail({ uid: uid }, { uid: uid, email: 'updatedAgain@me.com', password: '123456' }, (err) => {
					assert.ifError(err);
					db.getObjectField(`user:${uid}`, 'email', (err, email) => {
						assert.ifError(err);
						assert.equal(email, 'updatedAgain@me.com');
						done();
					});
				});
			});
		});

		it('should error if email is identical', async () => {
			await User.create({
				username: 'trimtest1',
				email: 'trim1@trim.com',
			});
			const uid2 = await User.create({
				username: 'trimtest2',
				email: 'trim2@trim.com',
			});
			let err;
			try {
				await socketUser.changeUsernameEmail({ uid: uid2 }, {
					uid: uid2,
					email: '  trim1@trim.com',
				});
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, '[[error:email-taken]]');
		});

		it('should update cover image', (done) => {
			const imageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAgCAYAAAABtRhCAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAACcJJREFUeNqMl9tvnNV6xn/f+s5z8DCeg88Zj+NYdhJH4KShFoJAIkzVphLVJnsDaiV6gUKaC2qQUFVATbnoValAakuQYKMqBKUUJCgI9XBBSmOROMqGoCStHbA9sWM7nrFn/I3n9B17kcwoabfarj9gvet53+d9nmdJAwMDAAgh8DyPtbU1XNfFMAwkScK2bTzPw/M8dF1/SAhxKAiCxxVF2aeqqqTr+q+Af+7o6Ch0d3f/69TU1KwkSRiGwbFjx3jmmWd47rnn+OGHH1BVFYX/5QRBkPQ87xeSJP22YRi/oapqStM0PM/D931kWSYIgnHf98cXFxepVqtomjZt2/Zf2bb990EQ4Pv+PXfeU1CSpGYhfN9/TgjxQTQaJQgCwuEwQRBQKpUwDAPTNPF9n0ajAYDv+8zPzzM+Pr6/Wq2eqdVqfxOJRA6Zpnn57hrivyEC0IQQZ4Mg+MAwDCKRCJIkUa/XEUIQi8XQNI1QKIQkSQghUBQFIQSmaTI7OwtAuVxOTE9Pfzc9Pf27lUqlBUgulUoUi0VKpRKqqg4EQfAfiqLsDIfDAC0E4XCYaDSKEALXdalUKvfM1/d9hBBYlkUul2N4eJi3335bcl33mW+++aaUz+cvSJKE8uKLL6JpGo7j8Omnn/7d+vp6sr+/HyEEjuMgyzKu6yJJEsViEVVV8TyPjY2NVisV5fZkTNMkkUhw8+ZN6vU6Kysr7Nmzh9OnT7/12GOPDS8sLByT7rQR4A9XV1d/+cILLzA9PU0kEmF4eBhFUTh//jyWZaHrOkII0uk0jUaDWq1GJpOhWCyysrLC1tYWnuehqir79+9H13W6urp48803+f7773n++ef/4G7S/H4ikUCSJNbX11trcuvWLcrlMrIs4zgODzzwABMTE/i+T7lcpq2tjUqlwubmJrZts7y8jBCCkZERGo0G2WyWkydPkkql6Onp+eMmwihwc3JyMvrWW2+RTCYBcF0XWZbRdZ3l5WX27NnD008/TSwWQ1VVyuVy63GhUIhEIkEqlcJxHCzLIhaLMTQ0xJkzZ7Btm3379lmS53kIIczZ2dnFsbGxRK1Wo729HQDP8zAMg5WVFXp7e5mcnKSzs5N8Po/rutTrdVzXbQmHrutEo1FM00RVVXp7e0kkEgRBwMWLF9F1vaxUq1UikUjtlVdeuV6pVBJ9fX3Ytn2bwrLMysoKXV1dTE5OkslksCwLTdMwDANVVdnY2CAIApLJJJFIBMdxiMfj7Nq1C1VViUajLQCvvvrqkhKJRJiZmfmdb7/99jeTySSyLLfWodFoEAqFOH78OLt37yaXy2GaJoqisLy8zNTUFFevXiUIAtrb29m5cyePPPJIa+cymQz1eh2A0dFRCoXCsgIwNTW1J5/P093dTbFYRJZlJEmiWq1y4MABxsbGqNVqhEIh6vU6QRBQLpcxDIPh4WE8z2NxcZFTp05x7tw5Xn755ZY6dXZ2tliZzWa/EwD1ev3RsbExxsfHSafTVCoVGo0Gqqqya9cuIpEIQgh832dtbY3FxUUA+vr62LZtG2NjYxw5coTDhw+ztLTEyZMnuXr1KoVC4R4d3bt375R84sQJEY/H/2Jubq7N9326urqwbZt6vY5pmhw5coS+vr4W9YvFIrdu3WJqagohBFeuXOHcuXOtue7evRtN01rtfO+991haWmJkZGQrkUi8JIC9iqL0BkFAIpFACMETTzxBV1cXiUSC7u5uHMfB8zyCIMA0TeLxONlsFlmW8X2fwcFBHMdhfn6eer1Oe3s7Dz30EBMTE1y6dImjR49y6tSppR07dqwrjuM8+OWXXzI0NMTly5e5du0aQ0NDTExMkMvlCIKAIAhaIh2LxQiHw0QiEfL5POl0mlqtRq1Wo6OjA8uykGWZdDrN0tISvb29vPPOOzz++OPk83lELpf7rXfffRfDMOjo6MBxHEqlEocOHWLHjh00Gg0kSULTNIS4bS6qqhKPxxkaGmJ4eJjR0VH279/PwMAA27dvJ5vN4vs+X331FR9//DGzs7OEQiE++eQTlPb29keuX7/OtWvXOH78ONVqlZs3b9LW1kYmk8F13dZeCiGQJAnXdRFCYBgGsiwjhMC2bQqFAkEQoOs6P/74Iw8++CCDg4Pous6xY8f47LPPkIIguDo2Nrbzxo0bfPjhh9i2zczMTHNvcF2XpsZalkWj0cB1Xe4o1O3YoCisra3x008/EY/H6erqAuDAgQNEIhGCIODQoUP/ubCwMCKAjx599FHW19f56KOP6OjooFgsks/niUajKIqCbds4joMQAiFESxxs226xd2Zmhng8Tl9fH67r0mg0sG2bbDZLpVIhl8vd5gHwtysrKy8Dcdd1mZubo6enh1gsRrVabZlrk6VND/R9n3q9TqVSQdd1QqEQi4uLnD9/nlKpxODgIHv37gXAcRyCICiFQiHEzp07i1988cUfKYpCIpHANE22b9/eUhNFUVotDIKghc7zPCzLolKpsLW1RVtbG0EQ4DgOmqbR09NDM1qUSiWAPwdQ7ujjmf7+/kQymfxrSZJQVZWtra2WG+i63iKH53m4rku1WqVcLmNZFu3t7S2x7+/vJ51O89prr7VYfenSpcPAP1UqFeSHH36YeDxOKpW6eP/9988Bv9d09nw+T7VapVKptJjZnE2tVmNtbY1cLke5XGZra4vNzU16enp49tlnGRgYaD7iTxqNxgexWIzDhw+jNEPQHV87NT8/f+PChQtnR0ZGqFarrUVuOsDds2u2b2FhgVQqRSQSYWFhgStXrtDf308ymcwBf3nw4EEOHjx4O5c2lURVVRzHYXp6+t8uX7785IULFz7LZDLous59991HOBy+h31N9xgdHSWTyVCtVhkaGmLfvn1MT08zPz/PzMzM6c8//9xr+uE9QViWZer1OhsbGxiG8fns7OzPc7ncx729vXR3d1OpVNi2bRuhUAhZljEMA9/3sW0bVVVZWlri4sWLjI+P8/rrr/P111/z5JNPXrIs69cn76ZeGoaBpmm0tbX9Q6FQeHhubu7fC4UCkUiE1dVVstks8Xgc0zSRZZlGo9ESAdM02djYoNFo8MYbb2BZ1mYoFOKuZPjr/xZBEHCHred83x/b3Nz8l/X19aRlWWxsbNDZ2cnw8DDhcBjf96lWq/T09HD06FGeeuopXnrpJc6ePUs6nb4hhPi/C959ZFn+TtO0lG3bJ0ql0p85jsPW1haFQoG2tjYkSWpF/Uwmw9raGu+//z7A977vX2+GrP93wSZiTdNOGIbxy3K5/DPHcfYXCoVe27Yzpmm2m6bppVKp/Orqqnv69OmoZVn/mEwm/9TzvP9x138NAMpJ4VFTBr6SAAAAAElFTkSuQmCC';
			const position = '50.0301% 19.2464%';
			socketUser.updateCover({ uid: uid }, { uid: uid, imageData: imageData, position: position }, (err, result) => {
				assert.ifError(err);
				assert(result.url);
				db.getObjectFields(`user:${uid}`, ['cover:url', 'cover:position'], (err, data) => {
					assert.ifError(err);
					assert.equal(data['cover:url'], result.url);
					assert.equal(data['cover:position'], position);
					done();
				});
			});
		});

		it('should upload cropped profile picture', (done) => {
			const imageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAgCAYAAAABtRhCAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAACcJJREFUeNqMl9tvnNV6xn/f+s5z8DCeg88Zj+NYdhJH4KShFoJAIkzVphLVJnsDaiV6gUKaC2qQUFVATbnoValAakuQYKMqBKUUJCgI9XBBSmOROMqGoCStHbA9sWM7nrFn/I3n9B17kcwoabfarj9gvet53+d9nmdJAwMDAAgh8DyPtbU1XNfFMAwkScK2bTzPw/M8dF1/SAhxKAiCxxVF2aeqqqTr+q+Af+7o6Ch0d3f/69TU1KwkSRiGwbFjx3jmmWd47rnn+OGHH1BVFYX/5QRBkPQ87xeSJP22YRi/oapqStM0PM/D931kWSYIgnHf98cXFxepVqtomjZt2/Zf2bb990EQ4Pv+PXfeU1CSpGYhfN9/TgjxQTQaJQgCwuEwQRBQKpUwDAPTNPF9n0ajAYDv+8zPzzM+Pr6/Wq2eqdVqfxOJRA6Zpnn57hrivyEC0IQQZ4Mg+MAwDCKRCJIkUa/XEUIQi8XQNI1QKIQkSQghUBQFIQSmaTI7OwtAuVxOTE9Pfzc9Pf27lUqlBUgulUoUi0VKpRKqqg4EQfAfiqLsDIfDAC0E4XCYaDSKEALXdalUKvfM1/d9hBBYlkUul2N4eJi3335bcl33mW+++aaUz+cvSJKE8uKLL6JpGo7j8Omnn/7d+vp6sr+/HyEEjuMgyzKu6yJJEsViEVVV8TyPjY2NVisV5fZkTNMkkUhw8+ZN6vU6Kysr7Nmzh9OnT7/12GOPDS8sLByT7rQR4A9XV1d/+cILLzA9PU0kEmF4eBhFUTh//jyWZaHrOkII0uk0jUaDWq1GJpOhWCyysrLC1tYWnuehqir79+9H13W6urp48803+f7773n++ef/4G7S/H4ikUCSJNbX11trcuvWLcrlMrIs4zgODzzwABMTE/i+T7lcpq2tjUqlwubmJrZts7y8jBCCkZERGo0G2WyWkydPkkql6Onp+eMmwihwc3JyMvrWW2+RTCYBcF0XWZbRdZ3l5WX27NnD008/TSwWQ1VVyuVy63GhUIhEIkEqlcJxHCzLIhaLMTQ0xJkzZ7Btm3379lmS53kIIczZ2dnFsbGxRK1Wo729HQDP8zAMg5WVFXp7e5mcnKSzs5N8Po/rutTrdVzXbQmHrutEo1FM00RVVXp7e0kkEgRBwMWLF9F1vaxUq1UikUjtlVdeuV6pVBJ9fX3Ytn2bwrLMysoKXV1dTE5OkslksCwLTdMwDANVVdnY2CAIApLJJJFIBMdxiMfj7Nq1C1VViUajLQCvvvrqkhKJRJiZmfmdb7/99jeTySSyLLfWodFoEAqFOH78OLt37yaXy2GaJoqisLy8zNTUFFevXiUIAtrb29m5cyePPPJIa+cymQz1eh2A0dFRCoXCsgIwNTW1J5/P093dTbFYRJZlJEmiWq1y4MABxsbGqNVqhEIh6vU6QRBQLpcxDIPh4WE8z2NxcZFTp05x7tw5Xn755ZY6dXZ2tliZzWa/EwD1ev3RsbExxsfHSafTVCoVGo0Gqqqya9cuIpEIQgh832dtbY3FxUUA+vr62LZtG2NjYxw5coTDhw+ztLTEyZMnuXr1KoVC4R4d3bt375R84sQJEY/H/2Jubq7N9326urqwbZt6vY5pmhw5coS+vr4W9YvFIrdu3WJqagohBFeuXOHcuXOtue7evRtN01rtfO+991haWmJkZGQrkUi8JIC9iqL0BkFAIpFACMETTzxBV1cXiUSC7u5uHMfB8zyCIMA0TeLxONlsFlmW8X2fwcFBHMdhfn6eer1Oe3s7Dz30EBMTE1y6dImjR49y6tSppR07dqwrjuM8+OWXXzI0NMTly5e5du0aQ0NDTExMkMvlCIKAIAhaIh2LxQiHw0QiEfL5POl0mlqtRq1Wo6OjA8uykGWZdDrN0tISvb29vPPOOzz++OPk83lELpf7rXfffRfDMOjo6MBxHEqlEocOHWLHjh00Gg0kSULTNIS4bS6qqhKPxxkaGmJ4eJjR0VH279/PwMAA27dvJ5vN4vs+X331FR9//DGzs7OEQiE++eQTlPb29keuX7/OtWvXOH78ONVqlZs3b9LW1kYmk8F13dZeCiGQJAnXdRFCYBgGsiwjhMC2bQqFAkEQoOs6P/74Iw8++CCDg4Pous6xY8f47LPPkIIguDo2Nrbzxo0bfPjhh9i2zczMTHNvcF2XpsZalkWj0cB1Xe4o1O3YoCisra3x008/EY/H6erqAuDAgQNEIhGCIODQoUP/ubCwMCKAjx599FHW19f56KOP6OjooFgsks/niUajKIqCbds4joMQAiFESxxs226xd2Zmhng8Tl9fH67r0mg0sG2bbDZLpVIhl8vd5gHwtysrKy8Dcdd1mZubo6enh1gsRrVabZlrk6VND/R9n3q9TqVSQdd1QqEQi4uLnD9/nlKpxODgIHv37gXAcRyCICiFQiHEzp07i1988cUfKYpCIpHANE22b9/eUhNFUVotDIKghc7zPCzLolKpsLW1RVtbG0EQ4DgOmqbR09NDM1qUSiWAPwdQ7ujjmf7+/kQymfxrSZJQVZWtra2WG+i63iKH53m4rku1WqVcLmNZFu3t7S2x7+/vJ51O89prr7VYfenSpcPAP1UqFeSHH36YeDxOKpW6eP/9988Bv9d09nw+T7VapVKptJjZnE2tVmNtbY1cLke5XGZra4vNzU16enp49tlnGRgYaD7iTxqNxgexWIzDhw+jNEPQHV87NT8/f+PChQtnR0ZGqFarrUVuOsDds2u2b2FhgVQqRSQSYWFhgStXrtDf308ymcwBf3nw4EEOHjx4O5c2lURVVRzHYXp6+t8uX7785IULFz7LZDLous59991HOBy+h31N9xgdHSWTyVCtVhkaGmLfvn1MT08zPz/PzMzM6c8//9xr+uE9QViWZer1OhsbGxiG8fns7OzPc7ncx729vXR3d1OpVNi2bRuhUAhZljEMA9/3sW0bVVVZWlri4sWLjI+P8/rrr/P111/z5JNPXrIs69cn76ZeGoaBpmm0tbX9Q6FQeHhubu7fC4UCkUiE1dVVstks8Xgc0zSRZZlGo9ESAdM02djYoNFo8MYbb2BZ1mYoFOKuZPjr/xZBEHCHred83x/b3Nz8l/X19aRlWWxsbNDZ2cnw8DDhcBjf96lWq/T09HD06FGeeuopXnrpJc6ePUs6nb4hhPi/C959ZFn+TtO0lG3bJ0ql0p85jsPW1haFQoG2tjYkSWpF/Uwmw9raGu+//z7A977vX2+GrP93wSZiTdNOGIbxy3K5/DPHcfYXCoVe27Yzpmm2m6bppVKp/Orqqnv69OmoZVn/mEwm/9TzvP9x138NAMpJ4VFTBr6SAAAAAElFTkSuQmCC';
			socketUser.uploadCroppedPicture({ uid: uid }, { uid: uid, imageData: imageData }, (err, result) => {
				assert.ifError(err);
				assert(result.url);
				db.getObjectFields(`user:${uid}`, ['uploadedpicture', 'picture'], (err, data) => {
					assert.ifError(err);
					assert.equal(result.url, data.uploadedpicture);
					assert.equal(result.url, data.picture);
					done();
				});
			});
		});

		it('should remove cover image', (done) => {
			socketUser.removeCover({ uid: uid }, { uid: uid }, (err) => {
				assert.ifError(err);
				db.getObjectField(`user:${uid}`, 'cover:url', (err, url) => {
					assert.ifError(err);
					assert.equal(url, null);
					done();
				});
			});
		});

		it('should set user status', (done) => {
			socketUser.setStatus({ uid: uid }, 'away', (err, data) => {
				assert.ifError(err);
				assert.equal(data.uid, uid);
				assert.equal(data.status, 'away');
				done();
			});
		});

		it('should fail for invalid status', (done) => {
			socketUser.setStatus({ uid: uid }, '12345', (err) => {
				assert.equal(err.message, '[[error:invalid-user-status]]');
				done();
			});
		});

		it('should get user status', (done) => {
			socketUser.checkStatus({ uid: uid }, uid, (err, status) => {
				assert.ifError(err);
				assert.equal(status, 'away');
				done();
			});
		});

		it('should change user picture', (done) => {
			socketUser.changePicture({ uid: uid }, { type: 'default', uid: uid }, (err) => {
				assert.ifError(err);
				User.getUserField(uid, 'picture', (err, picture) => {
					assert.ifError(err);
					assert.equal(picture, '');
					done();
				});
			});
		});

		it('should fail to change user picture with invalid data', (done) => {
			socketUser.changePicture({ uid: uid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail to change user picture with invalid uid', (done) => {
			socketUser.changePicture({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-uid]]');
				done();
			});
		});

		it('should set user picture to uploaded', (done) => {
			User.setUserField(uid, 'uploadedpicture', '/test', (err) => {
				assert.ifError(err);
				socketUser.changePicture({ uid: uid }, { type: 'uploaded', uid: uid }, (err) => {
					assert.ifError(err);
					User.getUserField(uid, 'picture', (err, picture) => {
						assert.ifError(err);
						assert.equal(picture, `${nconf.get('relative_path')}/test`);
						done();
					});
				});
			});
		});

		it('should return error if profile image uploads disabled', (done) => {
			meta.config.allowProfileImageUploads = 0;
			const picture = {
				path: path.join(nconf.get('base_dir'), 'test/files/test_copy.png'),
				size: 7189,
				name: 'test.png',
				type: 'image/png',
			};
			User.uploadCroppedPicture({
				uid: uid,
				file: picture,
			}, (err) => {
				assert.equal(err.message, '[[error:profile-image-uploads-disabled]]');
				meta.config.allowProfileImageUploads = 1;
				done();
			});
		});

		it('should return error if profile image has no mime type', (done) => {
			User.uploadCroppedPicture({
				uid: uid,
				imageData: 'data:image/invalid;base64,R0lGODlhPQBEAPeoAJosM/',
			}, (err) => {
				assert.equal(err.message, '[[error:invalid-image]]');
				done();
			});
		});

		describe('user.uploadCroppedPicture', () => {
			const goodImage = 'data:image/gif;base64,R0lGODlhPQBEAPeoAJosM//AwO/AwHVYZ/z595kzAP/s7P+goOXMv8+fhw/v739/f+8PD98fH/8mJl+fn/9ZWb8/PzWlwv///6wWGbImAPgTEMImIN9gUFCEm/gDALULDN8PAD6atYdCTX9gUNKlj8wZAKUsAOzZz+UMAOsJAP/Z2ccMDA8PD/95eX5NWvsJCOVNQPtfX/8zM8+QePLl38MGBr8JCP+zs9myn/8GBqwpAP/GxgwJCPny78lzYLgjAJ8vAP9fX/+MjMUcAN8zM/9wcM8ZGcATEL+QePdZWf/29uc/P9cmJu9MTDImIN+/r7+/vz8/P8VNQGNugV8AAF9fX8swMNgTAFlDOICAgPNSUnNWSMQ5MBAQEJE3QPIGAM9AQMqGcG9vb6MhJsEdGM8vLx8fH98AANIWAMuQeL8fABkTEPPQ0OM5OSYdGFl5jo+Pj/+pqcsTE78wMFNGQLYmID4dGPvd3UBAQJmTkP+8vH9QUK+vr8ZWSHpzcJMmILdwcLOGcHRQUHxwcK9PT9DQ0O/v70w5MLypoG8wKOuwsP/g4P/Q0IcwKEswKMl8aJ9fX2xjdOtGRs/Pz+Dg4GImIP8gIH0sKEAwKKmTiKZ8aB/f39Wsl+LFt8dgUE9PT5x5aHBwcP+AgP+WltdgYMyZfyywz78AAAAAAAD///8AAP9mZv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKgALAAAAAA9AEQAAAj/AFEJHEiwoMGDCBMqXMiwocAbBww4nEhxoYkUpzJGrMixogkfGUNqlNixJEIDB0SqHGmyJSojM1bKZOmyop0gM3Oe2liTISKMOoPy7GnwY9CjIYcSRYm0aVKSLmE6nfq05QycVLPuhDrxBlCtYJUqNAq2bNWEBj6ZXRuyxZyDRtqwnXvkhACDV+euTeJm1Ki7A73qNWtFiF+/gA95Gly2CJLDhwEHMOUAAuOpLYDEgBxZ4GRTlC1fDnpkM+fOqD6DDj1aZpITp0dtGCDhr+fVuCu3zlg49ijaokTZTo27uG7Gjn2P+hI8+PDPERoUB318bWbfAJ5sUNFcuGRTYUqV/3ogfXp1rWlMc6awJjiAAd2fm4ogXjz56aypOoIde4OE5u/F9x199dlXnnGiHZWEYbGpsAEA3QXYnHwEFliKAgswgJ8LPeiUXGwedCAKABACCN+EA1pYIIYaFlcDhytd51sGAJbo3onOpajiihlO92KHGaUXGwWjUBChjSPiWJuOO/LYIm4v1tXfE6J4gCSJEZ7YgRYUNrkji9P55sF/ogxw5ZkSqIDaZBV6aSGYq/lGZplndkckZ98xoICbTcIJGQAZcNmdmUc210hs35nCyJ58fgmIKX5RQGOZowxaZwYA+JaoKQwswGijBV4C6SiTUmpphMspJx9unX4KaimjDv9aaXOEBteBqmuuxgEHoLX6Kqx+yXqqBANsgCtit4FWQAEkrNbpq7HSOmtwag5w57GrmlJBASEU18ADjUYb3ADTinIttsgSB1oJFfA63bduimuqKB1keqwUhoCSK374wbujvOSu4QG6UvxBRydcpKsav++Ca6G8A6Pr1x2kVMyHwsVxUALDq/krnrhPSOzXG1lUTIoffqGR7Goi2MAxbv6O2kEG56I7CSlRsEFKFVyovDJoIRTg7sugNRDGqCJzJgcKE0ywc0ELm6KBCCJo8DIPFeCWNGcyqNFE06ToAfV0HBRgxsvLThHn1oddQMrXj5DyAQgjEHSAJMWZwS3HPxT/QMbabI/iBCliMLEJKX2EEkomBAUCxRi42VDADxyTYDVogV+wSChqmKxEKCDAYFDFj4OmwbY7bDGdBhtrnTQYOigeChUmc1K3QTnAUfEgGFgAWt88hKA6aCRIXhxnQ1yg3BCayK44EWdkUQcBByEQChFXfCB776aQsG0BIlQgQgE8qO26X1h8cEUep8ngRBnOy74E9QgRgEAC8SvOfQkh7FDBDmS43PmGoIiKUUEGkMEC/PJHgxw0xH74yx/3XnaYRJgMB8obxQW6kL9QYEJ0FIFgByfIL7/IQAlvQwEpnAC7DtLNJCKUoO/w45c44GwCXiAFB/OXAATQryUxdN4LfFiwgjCNYg+kYMIEFkCKDs6PKAIJouyGWMS1FSKJOMRB/BoIxYJIUXFUxNwoIkEKPAgCBZSQHQ1A2EWDfDEUVLyADj5AChSIQW6gu10bE/JG2VnCZGfo4R4d0sdQoBAHhPjhIB94v/wRoRKQWGRHgrhGSQJxCS+0pCZbEhAAOw==';
			const badImage = 'data:audio/mp3;base64,R0lGODlhPQBEAPeoAJosM//AwO/AwHVYZ/z595kzAP/s7P+goOXMv8+fhw/v739/f+8PD98fH/8mJl+fn/9ZWb8/PzWlwv///6wWGbImAPgTEMImIN9gUFCEm/gDALULDN8PAD6atYdCTX9gUNKlj8wZAKUsAOzZz+UMAOsJAP/Z2ccMDA8PD/95eX5NWvsJCOVNQPtfX/8zM8+QePLl38MGBr8JCP+zs9myn/8GBqwpAP/GxgwJCPny78lzYLgjAJ8vAP9fX/+MjMUcAN8zM/9wcM8ZGcATEL+QePdZWf/29uc/P9cmJu9MTDImIN+/r7+/vz8/P8VNQGNugV8AAF9fX8swMNgTAFlDOICAgPNSUnNWSMQ5MBAQEJE3QPIGAM9AQMqGcG9vb6MhJsEdGM8vLx8fH98AANIWAMuQeL8fABkTEPPQ0OM5OSYdGFl5jo+Pj/+pqcsTE78wMFNGQLYmID4dGPvd3UBAQJmTkP+8vH9QUK+vr8ZWSHpzcJMmILdwcLOGcHRQUHxwcK9PT9DQ0O/v70w5MLypoG8wKOuwsP/g4P/Q0IcwKEswKMl8aJ9fX2xjdOtGRs/Pz+Dg4GImIP8gIH0sKEAwKKmTiKZ8aB/f39Wsl+LFt8dgUE9PT5x5aHBwcP+AgP+WltdgYMyZfyywz78AAAAAAAD///8AAP9mZv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKgALAAAAAA9AEQAAAj/AFEJHEiwoMGDCBMqXMiwocAbBww4nEhxoYkUpzJGrMixogkfGUNqlNixJEIDB0SqHGmyJSojM1bKZOmyop0gM3Oe2liTISKMOoPy7GnwY9CjIYcSRYm0aVKSLmE6nfq05QycVLPuhDrxBlCtYJUqNAq2bNWEBj6ZXRuyxZyDRtqwnXvkhACDV+euTeJm1Ki7A73qNWtFiF+/gA95Gly2CJLDhwEHMOUAAuOpLYDEgBxZ4GRTlC1fDnpkM+fOqD6DDj1aZpITp0dtGCDhr+fVuCu3zlg49ijaokTZTo27uG7Gjn2P+hI8+PDPERoUB318bWbfAJ5sUNFcuGRTYUqV/3ogfXp1rWlMc6awJjiAAd2fm4ogXjz56aypOoIde4OE5u/F9x199dlXnnGiHZWEYbGpsAEA3QXYnHwEFliKAgswgJ8LPeiUXGwedCAKABACCN+EA1pYIIYaFlcDhytd51sGAJbo3onOpajiihlO92KHGaUXGwWjUBChjSPiWJuOO/LYIm4v1tXfE6J4gCSJEZ7YgRYUNrkji9P55sF/ogxw5ZkSqIDaZBV6aSGYq/lGZplndkckZ98xoICbTcIJGQAZcNmdmUc210hs35nCyJ58fgmIKX5RQGOZowxaZwYA+JaoKQwswGijBV4C6SiTUmpphMspJx9unX4KaimjDv9aaXOEBteBqmuuxgEHoLX6Kqx+yXqqBANsgCtit4FWQAEkrNbpq7HSOmtwag5w57GrmlJBASEU18ADjUYb3ADTinIttsgSB1oJFfA63bduimuqKB1keqwUhoCSK374wbujvOSu4QG6UvxBRydcpKsav++Ca6G8A6Pr1x2kVMyHwsVxUALDq/krnrhPSOzXG1lUTIoffqGR7Goi2MAxbv6O2kEG56I7CSlRsEFKFVyovDJoIRTg7sugNRDGqCJzJgcKE0ywc0ELm6KBCCJo8DIPFeCWNGcyqNFE06ToAfV0HBRgxsvLThHn1oddQMrXj5DyAQgjEHSAJMWZwS3HPxT/QMbabI/iBCliMLEJKX2EEkomBAUCxRi42VDADxyTYDVogV+wSChqmKxEKCDAYFDFj4OmwbY7bDGdBhtrnTQYOigeChUmc1K3QTnAUfEgGFgAWt88hKA6aCRIXhxnQ1yg3BCayK44EWdkUQcBByEQChFXfCB776aQsG0BIlQgQgE8qO26X1h8cEUep8ngRBnOy74E9QgRgEAC8SvOfQkh7FDBDmS43PmGoIiKUUEGkMEC/PJHgxw0xH74yx/3XnaYRJgMB8obxQW6kL9QYEJ0FIFgByfIL7/IQAlvQwEpnAC7DtLNJCKUoO/w45c44GwCXiAFB/OXAATQryUxdN4LfFiwgjCNYg+kYMIEFkCKDs6PKAIJouyGWMS1FSKJOMRB/BoIxYJIUXFUxNwoIkEKPAgCBZSQHQ1A2EWDfDEUVLyADj5AChSIQW6gu10bE/JG2VnCZGfo4R4d0sdQoBAHhPjhIB94v/wRoRKQWGRHgrhGSQJxCS+0pCZbEhAAOw==';
			it('should error if both file and imageData are missing', (done) => {
				User.uploadCroppedPicture({}, (err) => {
					assert.equal('[[error:invalid-data]]', err.message);
					done();
				});
			});

			it('should error if file size is too big', (done) => {
				const temp = meta.config.maximumProfileImageSize;
				meta.config.maximumProfileImageSize = 1;
				User.uploadCroppedPicture({
					uid: 1,
					imageData: goodImage,
				}, (err) => {
					assert.equal('[[error:file-too-big, 1]]', err.message);

					// Restore old value
					meta.config.maximumProfileImageSize = temp;
					done();
				});
			});

			it('should not allow image data with bad MIME type to be passed in', (done) => {
				User.uploadCroppedPicture({
					uid: 1,
					imageData: badImage,
				}, (err) => {
					assert.equal('[[error:invalid-image]]', err.message);
					done();
				});
			});
		});

		it('should get profile pictures', (done) => {
			socketUser.getProfilePictures({ uid: uid }, { uid: uid }, (err, data) => {
				assert.ifError(err);
				assert(data);
				assert(Array.isArray(data));
				assert.equal(data[0].type, 'uploaded');
				assert.equal(data[0].text, '[[user:uploaded_picture]]');
				done();
			});
		});

		it('should get default profile avatar', (done) => {
			assert.strictEqual(User.getDefaultAvatar(), '');
			meta.config.defaultAvatar = 'https://path/to/default/avatar';
			assert.strictEqual(User.getDefaultAvatar(), meta.config.defaultAvatar);
			meta.config.defaultAvatar = '/path/to/default/avatar';
			assert.strictEqual(User.getDefaultAvatar(), nconf.get('relative_path') + meta.config.defaultAvatar);
			meta.config.defaultAvatar = '';
			done();
		});

		it('should fail to get profile pictures with invalid data', (done) => {
			socketUser.getProfilePictures({ uid: uid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketUser.getProfilePictures({ uid: uid }, { uid: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					done();
				});
			});
		});

		it('should remove uploaded picture', (done) => {
			socketUser.removeUploadedPicture({ uid: uid }, { uid: uid }, (err) => {
				assert.ifError(err);
				User.getUserField(uid, 'uploadedpicture', (err, uploadedpicture) => {
					assert.ifError(err);
					assert.equal(uploadedpicture, '');
					done();
				});
			});
		});

		it('should fail to remove uploaded picture with invalid-data', (done) => {
			socketUser.removeUploadedPicture({ uid: uid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketUser.removeUploadedPicture({ uid: uid }, { }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketUser.removeUploadedPicture({ uid: null }, { }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should load profile page', (done) => {
			request(`${nconf.get('url')}/api/user/updatedagain`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load settings page', (done) => {
			request(`${nconf.get('url')}/api/user/updatedagain/settings`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.settings);
				assert(body.languages);
				assert(body.homePageRoutes);
				done();
			});
		});

		it('should load edit page', (done) => {
			request(`${nconf.get('url')}/api/user/updatedagain/edit`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load edit/email page', (done) => {
			request(`${nconf.get('url')}/api/user/updatedagain/edit/email`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});

		it('should load user\'s groups page', (done) => {
			groups.create({
				name: 'Test',
				description: 'Foobar!',
			}, (err) => {
				assert.ifError(err);
				groups.join('Test', uid, (err) => {
					assert.ifError(err);
					request(`${nconf.get('url')}/api/user/updatedagain/groups`, { jar: jar, json: true }, (err, res, body) => {
						assert.ifError(err);
						assert.equal(res.statusCode, 200);
						assert(Array.isArray(body.groups));
						assert.equal(body.groups[0].name, 'Test');
						done();
					});
				});
			});
		});
	});

	describe('user info', () => {
		let testUserUid;
		let verifiedTestUserUid;

		before(async () => {
			// Might be the first user thus a verified one if this test part is ran alone
			verifiedTestUserUid = await User.create({ username: 'bannedUser', password: '123456', email: 'banneduser@example.com' });
			await User.setUserField(verifiedTestUserUid, 'email:confirmed', 1);
			testUserUid = await User.create({ username: 'bannedUser2', password: '123456', email: 'banneduser2@example.com' });
		});

		it('should return error if there is no ban reason', (done) => {
			User.getLatestBanInfo(123, (err) => {
				assert.equal(err.message, 'no-ban-info');
				done();
			});
		});

		it('should get history from set', async () => {
			const now = Date.now();
			await db.sortedSetAdd(`user:${testUserUid}:usernames`, now, `derp:${now}`);
			const data = await User.getHistory(`user:${testUserUid}:usernames`);
			assert.equal(data[0].value, 'derp');
			assert.equal(data[0].timestamp, now);
		});

		it('should return the correct ban reason', (done) => {
			async.series([
				function (next) {
					User.bans.ban(testUserUid, 0, '', (err) => {
						assert.ifError(err);
						next(err);
					});
				},
				function (next) {
					User.getModerationHistory(testUserUid, (err, data) => {
						assert.ifError(err);
						assert.equal(data.bans.length, 1, 'one ban');
						assert.equal(data.bans[0].reason, '[[user:info.banned-no-reason]]', 'no ban reason');

						next(err);
					});
				},
			], (err) => {
				assert.ifError(err);
				User.bans.unban(testUserUid, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});

		it('should ban user permanently', (done) => {
			User.bans.ban(testUserUid, (err) => {
				assert.ifError(err);
				User.bans.isBanned(testUserUid, (err, isBanned) => {
					assert.ifError(err);
					assert.equal(isBanned, true);
					User.bans.unban(testUserUid, done);
				});
			});
		});

		it('should ban user temporarily', (done) => {
			User.bans.ban(testUserUid, Date.now() + 2000, (err) => {
				assert.ifError(err);

				User.bans.isBanned(testUserUid, (err, isBanned) => {
					assert.ifError(err);
					assert.equal(isBanned, true);
					setTimeout(() => {
						User.bans.isBanned(testUserUid, (err, isBanned) => {
							assert.ifError(err);
							assert.equal(isBanned, false);
							User.bans.unban(testUserUid, done);
						});
					}, 3000);
				});
			});
		});

		it('should error if until is NaN', (done) => {
			User.bans.ban(testUserUid, 'asd', (err) => {
				assert.equal(err.message, '[[error:ban-expiry-missing]]');
				done();
			});
		});

		it('should be member of "banned-users" system group only after a ban', async () => {
			await User.bans.ban(testUserUid);

			const systemGroups = groups.systemGroups.filter(group => group !== groups.BANNED_USERS);
			const isMember = await groups.isMember(testUserUid, groups.BANNED_USERS);
			const isMemberOfAny = await groups.isMemberOfAny(testUserUid, systemGroups);

			assert.strictEqual(isMember, true);
			assert.strictEqual(isMemberOfAny, false);
		});

		it('should restore system group memberships after an unban (for an unverified user)', async () => {
			await User.bans.unban(testUserUid);

			const isMemberOfGroups = await groups.isMemberOfGroups(testUserUid, groups.systemGroups);
			const membership = new Map(groups.systemGroups.map((item, index) => [item, isMemberOfGroups[index]]));

			assert.strictEqual(membership.get('registered-users'), true);
			assert.strictEqual(membership.get('verified-users'), false);
			assert.strictEqual(membership.get('unverified-users'), true);
			assert.strictEqual(membership.get(groups.BANNED_USERS), false);
			// administrators cannot be banned
			assert.strictEqual(membership.get('administrators'), false);
			// This will not restored
			assert.strictEqual(membership.get('Global Moderators'), false);
		});

		it('should restore system group memberships after an unban (for a verified user)', async () => {
			await User.bans.ban(verifiedTestUserUid);
			await User.bans.unban(verifiedTestUserUid);

			const isMemberOfGroups = await groups.isMemberOfGroups(verifiedTestUserUid, groups.systemGroups);
			const membership = new Map(groups.systemGroups.map((item, index) => [item, isMemberOfGroups[index]]));

			assert.strictEqual(membership.get('verified-users'), true);
			assert.strictEqual(membership.get('unverified-users'), false);
		});
	});

	describe('Digest.getSubscribers', (done) => {
		const uidIndex = {};

		before((done) => {
			const testUsers = ['daysub', 'offsub', 'nullsub', 'weeksub'];
			async.each(testUsers, (username, next) => {
				async.waterfall([
					async.apply(User.create, { username: username, email: `${username}@example.com` }),
					function (uid, next) {
						if (username === 'nullsub') {
							return setImmediate(next);
						}

						uidIndex[username] = uid;

						const sub = username.slice(0, -3);
						async.parallel([
							async.apply(User.updateDigestSetting, uid, sub),
							async.apply(User.setSetting, uid, 'dailyDigestFreq', sub),
						], next);
					},
				], next);
			}, done);
		});

		it('should accurately build digest list given ACP default "null" (not set)', (done) => {
			User.digest.getSubscribers('day', (err, subs) => {
				assert.ifError(err);
				assert.strictEqual(subs.length, 1);

				done();
			});
		});

		it('should accurately build digest list given ACP default "day"', (done) => {
			async.series([
				async.apply(meta.configs.set, 'dailyDigestFreq', 'day'),
				function (next) {
					User.digest.getSubscribers('day', (err, subs) => {
						assert.ifError(err);
						assert.strictEqual(subs.includes(uidIndex.daysub.toString()), true);	// daysub does get emailed
						assert.strictEqual(subs.includes(uidIndex.weeksub.toString()), false);	// weeksub does not get emailed
						assert.strictEqual(subs.includes(uidIndex.offsub.toString()), false);	// offsub doesn't get emailed

						next();
					});
				},
			], done);
		});

		it('should accurately build digest list given ACP default "week"', (done) => {
			async.series([
				async.apply(meta.configs.set, 'dailyDigestFreq', 'week'),
				function (next) {
					User.digest.getSubscribers('week', (err, subs) => {
						assert.ifError(err);
						assert.strictEqual(subs.includes(uidIndex.weeksub.toString()), true);	// weeksub gets emailed
						assert.strictEqual(subs.includes(uidIndex.daysub.toString()), false);	// daysub gets emailed
						assert.strictEqual(subs.includes(uidIndex.offsub.toString()), false);	// offsub does not get emailed

						next();
					});
				},
			], done);
		});

		it('should accurately build digest list given ACP default "off"', (done) => {
			async.series([
				async.apply(meta.configs.set, 'dailyDigestFreq', 'off'),
				function (next) {
					User.digest.getSubscribers('day', (err, subs) => {
						assert.ifError(err);
						assert.strictEqual(subs.length, 1);

						next();
					});
				},
			], done);
		});
	});

	describe('digests', () => {
		let uid;
		before((done) => {
			async.waterfall([
				function (next) {
					User.create({ username: 'digestuser', email: 'test@example.com' }, next);
				},
				function (_uid, next) {
					uid = _uid;
					User.updateDigestSetting(uid, 'day', next);
				},
				function (next) {
					User.setSetting(uid, 'dailyDigestFreq', 'day', next);
				},
				function (next) {
					User.setSetting(uid, 'notificationType_test', 'notificationemail', next);
				},
			], done);
		});

		it('should send digests', (done) => {
			User.digest.execute({ interval: 'day' }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should not send digests', (done) => {
			User.digest.execute({ interval: 'month' }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		describe('unsubscribe via POST', () => {
			it('should unsubscribe from digest if one-click unsubscribe is POSTed', (done) => {
				const token = jwt.sign({
					template: 'digest',
					uid: uid,
				}, nconf.get('secret'));

				request({
					method: 'post',
					url: `${nconf.get('url')}/email/unsubscribe/${token}`,
				}, (err, res) => {
					assert.ifError(err);
					assert.strictEqual(res.statusCode, 200);

					db.getObjectField(`user:${uid}:settings`, 'dailyDigestFreq', (err, value) => {
						assert.ifError(err);
						assert.strictEqual(value, 'off');
						done();
					});
				});
			});

			it('should unsubscribe from notifications if one-click unsubscribe is POSTed', (done) => {
				const token = jwt.sign({
					template: 'notification',
					type: 'test',
					uid: uid,
				}, nconf.get('secret'));

				request({
					method: 'post',
					url: `${nconf.get('url')}/email/unsubscribe/${token}`,
				}, (err, res) => {
					assert.ifError(err);
					assert.strictEqual(res.statusCode, 200);

					db.getObjectField(`user:${uid}:settings`, 'notificationType_test', (err, value) => {
						assert.ifError(err);
						assert.strictEqual(value, 'notification');
						done();
					});
				});
			});

			it('should return errors on missing template in token', (done) => {
				const token = jwt.sign({
					uid: uid,
				}, nconf.get('secret'));

				request({
					method: 'post',
					url: `${nconf.get('url')}/email/unsubscribe/${token}`,
				}, (err, res) => {
					assert.ifError(err);
					assert.strictEqual(res.statusCode, 404);
					done();
				});
			});

			it('should return errors on wrong template in token', (done) => {
				const token = jwt.sign({
					template: 'user',
					uid: uid,
				}, nconf.get('secret'));

				request({
					method: 'post',
					url: `${nconf.get('url')}/email/unsubscribe/${token}`,
				}, (err, res) => {
					assert.ifError(err);
					assert.strictEqual(res.statusCode, 404);
					done();
				});
			});

			it('should return errors on missing token', (done) => {
				request({
					method: 'post',
					url: `${nconf.get('url')}/email/unsubscribe/`,
				}, (err, res) => {
					assert.ifError(err);
					assert.strictEqual(res.statusCode, 404);
					done();
				});
			});

			it('should return errors on token signed with wrong secret (verify-failure)', (done) => {
				const token = jwt.sign({
					template: 'notification',
					type: 'test',
					uid: uid,
				}, `${nconf.get('secret')}aababacaba`);

				request({
					method: 'post',
					url: `${nconf.get('url')}/email/unsubscribe/${token}`,
				}, (err, res) => {
					assert.ifError(err);
					assert.strictEqual(res.statusCode, 403);
					done();
				});
			});
		});
	});

	describe('socket methods', () => {
		const socketUser = require('../src/socket.io/user');

		it('should fail with invalid data', (done) => {
			socketUser.exists({ uid: testUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should return true if user/group exists', (done) => {
			socketUser.exists({ uid: testUid }, { username: 'registered-users' }, (err, exists) => {
				assert.ifError(err);
				assert(exists);
				done();
			});
		});

		it('should return true if user/group exists', (done) => {
			socketUser.exists({ uid: testUid }, { username: 'John Smith' }, (err, exists) => {
				assert.ifError(err);
				assert(exists);
				done();
			});
		});

		it('should return false if user/group does not exists', (done) => {
			socketUser.exists({ uid: testUid }, { username: 'doesnot exist' }, (err, exists) => {
				assert.ifError(err);
				assert(!exists);
				done();
			});
		});

		it('should delete user', async () => {
			const uid = await User.create({ username: 'willbedeleted' });
			await socketUser.deleteAccount({ uid: uid }, {});
			const exists = await socketUser.exists({ uid: testUid }, { username: 'willbedeleted' });
			assert(!exists);
		});

		it('should fail to delete user with wrong password', async () => {
			const uid = await User.create({ username: 'willbedeletedpwd', password: '123456' });
			let err;
			try {
				await socketUser.deleteAccount({ uid: uid }, { password: '654321' });
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, '[[error:invalid-password]]');
		});

		it('should delete user with correct password', async () => {
			const uid = await User.create({ username: 'willbedeletedcorrectpwd', password: '123456' });
			await socketUser.deleteAccount({ uid: uid }, { password: '123456' });
			const exists = await User.exists(uid);
			assert(!exists);
		});

		it('should fail to delete user if account deletion is not allowed', async () => {
			const oldValue = meta.config.allowAccountDeletion;
			meta.config.allowAccountDeletion = 0;
			const uid = await User.create({ username: 'tobedeleted' });
			try {
				await socketUser.deleteAccount({ uid: uid }, {});
			} catch (err) {
				assert.equal(err.message, '[[error:no-privileges]]');
			}
			meta.config.allowAccountDeletion = oldValue;
		});

		it('should fail if data is invalid', (done) => {
			socketUser.emailExists({ uid: testUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should return true if email exists', (done) => {
			socketUser.emailExists({ uid: testUid }, { email: 'john@example.com' }, (err, exists) => {
				assert.ifError(err);
				assert(exists);
				done();
			});
		});

		it('should return false if email does not exist', (done) => {
			socketUser.emailExists({ uid: testUid }, { email: 'does@not.exist' }, (err, exists) => {
				assert.ifError(err);
				assert(!exists);
				done();
			});
		});

		it('should error if requireEmailConfirmation is disabled', (done) => {
			socketUser.emailConfirm({ uid: testUid }, {}, (err) => {
				assert.equal(err.message, '[[error:email-confirmations-are-disabled]]');
				done();
			});
		});

		it('should send email confirm', (done) => {
			meta.config.requireEmailConfirmation = 1;
			socketUser.emailConfirm({ uid: testUid }, {}, (err) => {
				assert.ifError(err);
				meta.config.requireEmailConfirmation = 0;
				done();
			});
		});

		it('should send reset email', (done) => {
			socketUser.reset.send({ uid: 0 }, 'john@example.com', (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should return invalid-data error', (done) => {
			socketUser.reset.send({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should not error', (done) => {
			socketUser.reset.send({ uid: 0 }, 'doestnot@exist.com', (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should commit reset', (done) => {
			db.getObject('reset:uid', (err, data) => {
				assert.ifError(err);
				const code = Object.keys(data).find(code => parseInt(data[code], 10) === parseInt(testUid, 10));
				socketUser.reset.commit({ uid: 0 }, { code: code, password: 'pwdchange' }, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});

		it('should save user settings', (done) => {
			const data = {
				uid: testUid,
				settings: {
					bootswatchSkin: 'default',
					homePageRoute: 'none',
					homePageCustom: '',
					openOutgoingLinksInNewTab: 0,
					scrollToMyPost: 1,
					userLang: 'en-GB',
					usePagination: 1,
					topicsPerPage: '10',
					postsPerPage: '5',
					showemail: 1,
					showfullname: 1,
					restrictChat: 0,
					followTopicsOnCreate: 1,
					followTopicsOnReply: 1,
				},
			};
			socketUser.saveSettings({ uid: testUid }, data, (err) => {
				assert.ifError(err);
				User.getSettings(testUid, (err, data) => {
					assert.ifError(err);
					assert.equal(data.usePagination, true);
					done();
				});
			});
		});

		it('should properly escape homePageRoute', (done) => {
			const data = {
				uid: testUid,
				settings: {
					bootswatchSkin: 'default',
					homePageRoute: 'category/6/testing-ground',
					homePageCustom: '',
					openOutgoingLinksInNewTab: 0,
					scrollToMyPost: 1,
					userLang: 'en-GB',
					usePagination: 1,
					topicsPerPage: '10',
					postsPerPage: '5',
					showemail: 1,
					showfullname: 1,
					restrictChat: 0,
					followTopicsOnCreate: 1,
					followTopicsOnReply: 1,
				},
			};
			socketUser.saveSettings({ uid: testUid }, data, (err) => {
				assert.ifError(err);
				User.getSettings(testUid, (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.homePageRoute, 'category/6/testing-ground');
					done();
				});
			});
		});


		it('should error if language is invalid', (done) => {
			const data = {
				uid: testUid,
				settings: {
					userLang: '<invalid-string>',
					topicsPerPage: '10',
					postsPerPage: '5',
				},
			};
			socketUser.saveSettings({ uid: testUid }, data, (err) => {
				assert.equal(err.message, '[[error:invalid-language]]');
				done();
			});
		});

		it('should set moderation note', (done) => {
			let adminUid;
			async.waterfall([
				function (next) {
					User.create({ username: 'noteadmin' }, next);
				},
				function (_adminUid, next) {
					adminUid = _adminUid;
					groups.join('administrators', adminUid, next);
				},
				function (next) {
					socketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: 'this is a test user' }, next);
				},
				function (next) {
					setTimeout(next, 50);
				},
				function (next) {
					socketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: '<svg/onload=alert(document.location);//' }, next);
				},
				function (next) {
					User.getModerationNotes(testUid, 0, -1, next);
				},
			], (err, notes) => {
				assert.ifError(err);
				assert.equal(notes[0].note, '&lt;svg&#x2F;onload=alert(document.location);&#x2F;&#x2F;');
				assert.equal(notes[0].uid, adminUid);
				assert.equal(notes[1].note, 'this is a test user');
				assert(notes[0].timestamp);
				done();
			});
		});
	});

	describe('approval queue', () => {
		let oldRegistrationApprovalType;
		let adminUid;
		before((done) => {
			oldRegistrationApprovalType = meta.config.registrationApprovalType;
			meta.config.registrationApprovalType = 'admin-approval';
			User.create({ username: 'admin', password: '123456' }, (err, uid) => {
				assert.ifError(err);
				adminUid = uid;
				groups.join('administrators', uid, done);
			});
		});

		after((done) => {
			meta.config.registrationApprovalType = oldRegistrationApprovalType;
			done();
		});

		it('should add user to approval queue', (done) => {
			helpers.registerUser({
				username: 'rejectme',
				password: '123456',
				'password-confirm': '123456',
				email: '<script>alert("ok")<script>reject@me.com',
				gdpr_consent: true,
			}, (err) => {
				assert.ifError(err);
				helpers.loginUser('admin', '123456', (err, jar) => {
					assert.ifError(err);
					request(`${nconf.get('url')}/api/admin/manage/registration`, { jar: jar, json: true }, (err, res, body) => {
						assert.ifError(err);
						assert.equal(body.users[0].username, 'rejectme');
						assert.equal(body.users[0].email, '&lt;script&gt;alert(&quot;ok&quot;)&lt;script&gt;reject@me.com');
						done();
					});
				});
			});
		});

		it('should fail to add user to queue if username is taken', (done) => {
			helpers.registerUser({
				username: 'rejectme',
				password: '123456',
				'password-confirm': '123456',
				email: '<script>alert("ok")<script>reject@me.com',
				gdpr_consent: true,
			}, (err, jar, res, body) => {
				assert.ifError(err);
				assert.equal(body, '[[error:username-taken]]');
				done();
			});
		});

		it('should fail to add user to queue if email is taken', (done) => {
			helpers.registerUser({
				username: 'rejectmenew',
				password: '123456',
				'password-confirm': '123456',
				email: '<script>alert("ok")<script>reject@me.com',
				gdpr_consent: true,
			}, (err, jar, res, body) => {
				assert.ifError(err);
				assert.equal(body, '[[error:email-taken]]');
				done();
			});
		});

		it('should reject user registration', (done) => {
			socketUser.rejectRegistration({ uid: adminUid }, { username: 'rejectme' }, (err) => {
				assert.ifError(err);
				User.getRegistrationQueue(0, -1, (err, users) => {
					assert.ifError(err);
					assert.equal(users.length, 0);
					done();
				});
			});
		});

		it('should accept user registration', (done) => {
			helpers.registerUser({
				username: 'acceptme',
				password: '123456',
				'password-confirm': '123456',
				email: 'accept@me.com',
				gdpr_consent: true,
			}, (err) => {
				assert.ifError(err);
				socketUser.acceptRegistration({ uid: adminUid }, { username: 'acceptme' }, (err, uid) => {
					assert.ifError(err);
					User.exists(uid, (err, exists) => {
						assert.ifError(err);
						assert(exists);
						User.getRegistrationQueue(0, -1, (err, users) => {
							assert.ifError(err);
							assert.equal(users.length, 0);
							done();
						});
					});
				});
			});
		});

		it('should trim username and add user to registration queue', (done) => {
			helpers.registerUser({
				username: 'invalidname\r\n',
				password: '123456',
				'password-confirm': '123456',
				email: 'invalidtest@test.com',
				gdpr_consent: true,
			}, (err) => {
				assert.ifError(err);
				db.getSortedSetRange('registration:queue', 0, -1, (err, data) => {
					assert.ifError(err);
					assert.equal(data[0], 'invalidname');
					done();
				});
			});
		});
	});

	describe('invites', () => {
		let notAnInviterUid;
		let inviterUid;
		let adminUid;

		const PUBLIC_GROUP = 'publicGroup';
		const PRIVATE_GROUP = 'privateGroup';
		const OWN_PRIVATE_GROUP = 'ownPrivateGroup';
		const HIDDEN_GROUP = 'hiddenGroup';

		const COMMON_PW = '123456';

		before((done) => {
			async.parallel({
				publicGroup: async.apply(groups.create, { name: PUBLIC_GROUP, private: 0 }),
				privateGroup: async.apply(groups.create, { name: PRIVATE_GROUP, private: 1 }),
				hiddenGroup: async.apply(groups.create, { name: HIDDEN_GROUP, hidden: 1 }),
				notAnInviter: async.apply(User.create, { username: 'notAnInviter', password: COMMON_PW, email: 'notaninviter@nodebb.org' }),
				inviter: async.apply(User.create, { username: 'inviter', password: COMMON_PW, email: 'inviter@nodebb.org' }),
				admin: async.apply(User.create, { username: 'adminInvite', password: COMMON_PW }),
			}, (err, results) => {
				assert.ifError(err);
				notAnInviterUid = results.notAnInviter;
				inviterUid = results.inviter;
				adminUid = results.admin;
				async.parallel([
					async.apply(groups.create, { name: OWN_PRIVATE_GROUP, ownerUid: inviterUid, private: 1 }),
					async.apply(groups.join, 'administrators', adminUid),
					async.apply(groups.join, 'cid:0:privileges:invite', inviterUid),
				], done);
			});
		});

		describe('when inviter is not an admin and does not have invite privilege', () => {
			let csrf_token;
			let jar;

			before((done) => {
				helpers.loginUser('notAnInviter', COMMON_PW, (err, _jar) => {
					assert.ifError(err);
					jar = _jar;

					request({
						url: `${nconf.get('url')}/api/config`,
						json: true,
						jar: jar,
					}, (err, response, body) => {
						assert.ifError(err);
						csrf_token = body.csrf_token;
						done();
					});
				});
			});

			it('should error if user does not have invite privilege', async () => {
				const { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, notAnInviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 403);
				assert.strictEqual(res.body.status.message, '[[error:no-privileges]]');
			});

			it('should error out if user tries to use an inviter\'s uid via the API', async () => {
				const { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);
				const numInvites = await User.getInvitesNumber(inviterUid);
				assert.strictEqual(res.statusCode, 403);
				assert.strictEqual(res.body.status.message, '[[error:no-privileges]]');
				assert.strictEqual(numInvites, 0);
			});
		});

		describe('when inviter has invite privilege', () => {
			let csrf_token;
			let jar;

			before((done) => {
				helpers.loginUser('inviter', COMMON_PW, (err, _jar) => {
					assert.ifError(err);
					jar = _jar;

					request({
						url: `${nconf.get('url')}/api/config`,
						json: true,
						jar: jar,
					}, (err, response, body) => {
						assert.ifError(err);
						csrf_token = body.csrf_token;
						done();
					});
				});
			});

			it('should error with invalid data', async () => {
				const { res } = await helpers.invite({}, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 400);
				assert.strictEqual(res.body.status.message, '[[error:invalid-data]]');
			});

			it('should error if user is not admin and type is admin-invite-only', async () => {
				meta.config.registrationType = 'admin-invite-only';
				const { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 403);
				assert.strictEqual(res.body.status.message, '[[error:no-privileges]]');
			});

			it('should send invitation email (without groups to be joined)', async () => {
				meta.config.registrationType = 'normal';
				const { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 200);
			});

			it('should send multiple invitation emails (with a public group to be joined)', async () => {
				const { res } = await helpers.invite({ emails: 'invite2@test.com,invite3@test.com', groupsToJoin: [PUBLIC_GROUP] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 200);
			});

			it('should error if the user has not permission to invite to the group', async () => {
				const { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: [PRIVATE_GROUP] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 403);
				assert.strictEqual(res.body.status.message, '[[error:no-privileges]]');
			});

			it('should error if a non-admin tries to invite to the administrators group', async () => {
				const { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: ['administrators'] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 403);
				assert.strictEqual(res.body.status.message, '[[error:no-privileges]]');
			});

			it('should to invite to own private group', async () => {
				const { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: [OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 200);
			});

			it('should to invite to multiple groups', async () => {
				const { res } = await helpers.invite({ emails: 'invite5@test.com', groupsToJoin: [PUBLIC_GROUP, OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 200);
			});

			it('should error if tries to invite to hidden group', async () => {
				const { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [HIDDEN_GROUP] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 403);
			});

			it('should error if ouf of invitations', async () => {
				meta.config.maximumInvites = 1;
				const { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 403);
				assert.strictEqual(res.body.status.message, `[[error:invite-maximum-met, ${5}, ${1}]]`);
				meta.config.maximumInvites = 10;
			});

			it('should send invitation email after maximumInvites increased', async () => {
				const { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 200);
			});

			it('should error if invite is sent via API with a different UID', async () => {
				const { res } = await helpers.invite({ emails: 'inviter@nodebb.org', groupsToJoin: [] }, adminUid, jar, csrf_token);
				const numInvites = await User.getInvitesNumber(adminUid);
				assert.strictEqual(res.statusCode, 403);
				assert.strictEqual(res.body.status.message, '[[error:no-privileges]]');
				assert.strictEqual(numInvites, 0);
			});

			it('should error if email exists', async () => {
				const { res } = await helpers.invite({ emails: 'inviter@nodebb.org', groupsToJoin: [] }, inviterUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 400);
				assert.strictEqual(res.body.status.message, '[[error:email-taken]]');
			});
		});

		describe('when inviter is an admin', () => {
			let csrf_token;
			let jar;

			before((done) => {
				helpers.loginUser('adminInvite', COMMON_PW, (err, _jar) => {
					assert.ifError(err);
					jar = _jar;

					request({
						url: `${nconf.get('url')}/api/config`,
						json: true,
						jar: jar,
					}, (err, response, body) => {
						assert.ifError(err);
						csrf_token = body.csrf_token;
						done();
					});
				});
			});

			it('should escape email', async () => {
				await helpers.invite({ emails: '<script>alert("ok");</script>', groupsToJoin: [] }, adminUid, jar, csrf_token);
				const data = await User.getInvites(adminUid);
				assert.strictEqual(data[0], '&lt;script&gt;alert(&quot;ok&quot;);&lt;&#x2F;script&gt;');
				await User.deleteInvitationKey('<script>alert("ok");</script>');
			});

			it('should invite to the administrators group if inviter is an admin', async () => {
				const { res } = await helpers.invite({ emails: 'invite99@test.com', groupsToJoin: ['administrators'] }, adminUid, jar, csrf_token);
				assert.strictEqual(res.statusCode, 200);
			});
		});

		describe('after invites checks', () => {
			it('should get user\'s invites', (done) => {
				User.getInvites(inviterUid, (err, data) => {
					assert.ifError(err);
					Array.from(Array(6)).forEach((_, i) => {
						assert.notEqual(data.indexOf(`invite${i + 1}@test.com`), -1);
					});
					done();
				});
			});

			it('should get all invites', (done) => {
				User.getAllInvites((err, data) => {
					assert.ifError(err);

					const adminData = data.filter(d => parseInt(d.uid, 10) === adminUid)[0];
					assert.notEqual(adminData.invitations.indexOf('invite99@test.com'), -1);

					const inviterData = data.filter(d => parseInt(d.uid, 10) === inviterUid)[0];
					Array.from(Array(6)).forEach((_, i) => {
						assert.notEqual(inviterData.invitations.indexOf(`invite${i + 1}@test.com`), -1);
					});

					done();
				});
			});

			it('should fail to verify invitation with invalid data', (done) => {
				User.verifyInvitation({ token: '', email: '' }, (err) => {
					assert.strictEqual(err.message, '[[register:invite.error-invite-only]]');
					done();
				});
			});

			it('should fail to verify invitation with invalid email', (done) => {
				User.verifyInvitation({ token: 'test', email: 'doesnotexist@test.com' }, (err) => {
					assert.strictEqual(err.message, '[[register:invite.error-invalid-data]]');
					done();
				});
			});

			it('should verify installation with no errors', (done) => {
				const email = 'invite1@test.com';
				db.getObjectField(`invitation:email:${email}`, 'token', (err, token) => {
					assert.ifError(err);
					User.verifyInvitation({ token: token, email: 'invite1@test.com' }, (err) => {
						assert.ifError(err);
						done();
					});
				});
			});

			it('should error with invalid username', (done) => {
				User.deleteInvitation('doesnotexist', 'test@test.com', (err) => {
					assert.equal(err.message, '[[error:invalid-username]]');
					done();
				});
			});

			it('should delete invitation', (done) => {
				const socketUser = require('../src/socket.io/user');
				socketUser.deleteInvitation({ uid: adminUid }, { invitedBy: 'inviter', email: 'invite1@test.com' }, (err) => {
					assert.ifError(err);
					db.isSetMember(`invitation:uid:${inviterUid}`, 'invite1@test.com', (err, isMember) => {
						assert.ifError(err);
						assert.equal(isMember, false);
						done();
					});
				});
			});

			it('should delete invitation key', (done) => {
				User.deleteInvitationKey('invite99@test.com', (err) => {
					assert.ifError(err);
					db.isSetMember(`invitation:uid:${adminUid}`, 'invite99@test.com', (err, isMember) => {
						assert.ifError(err);
						assert.equal(isMember, false);
						db.isSetMember('invitation:uids', adminUid, (err, isMember) => {
							assert.ifError(err);
							assert.equal(isMember, false);
							done();
						});
					});
				});
			});

			it('should joined the groups from invitation after registration', async () => {
				const email = 'invite5@test.com';
				const groupsToJoin = [PUBLIC_GROUP, OWN_PRIVATE_GROUP];
				const token = await db.getObjectField(`invitation:email:${email}`, 'token');

				await new Promise((resolve, reject) => {
					helpers.registerUser({
						username: 'invite5',
						password: '123456',
						'password-confirm': '123456',
						email: email,
						gdpr_consent: true,
						token: token,
					}, async (err, jar, response, body) => {
						if (err) {
							reject(err);
						}

						const memberships = await groups.isMemberOfGroups(body.uid, groupsToJoin);
						const joinedToAll = memberships.filter(Boolean);

						if (joinedToAll.length !== groupsToJoin.length) {
							reject(new Error('Not joined to the groups'));
						}

						resolve();
					});
				});
			});
		});

		describe('invite groups', () => {
			let csrf_token;
			let jar;

			before((done) => {
				helpers.loginUser('inviter', COMMON_PW, (err, _jar) => {
					assert.ifError(err);
					jar = _jar;

					request({
						url: `${nconf.get('url')}/api/config`,
						json: true,
						jar: jar,
					}, (err, response, body) => {
						assert.ifError(err);
						csrf_token = body.csrf_token;
						done();
					});
				});
			});

			it('should show a list of groups for adding to an invite', async () => {
				const body = await requestAsync({
					url: `${nconf.get('url')}/api/v3/users/${inviterUid}/invites/groups`,
					json: true,
					jar,
				});

				assert(Array.isArray(body.response));
				assert.strictEqual(2, body.response.length);
				assert.deepStrictEqual(body.response, ['ownPrivateGroup', 'publicGroup']);
			});

			it('should error out if you request invite groups for another uid', async () => {
				const res = await requestAsync({
					url: `${nconf.get('url')}/api/v3/users/${adminUid}/invites/groups`,
					json: true,
					jar,
					simple: false,
					resolveWithFullResponse: true,
				});

				assert.strictEqual(res.statusCode, 401);
				assert.deepStrictEqual(res.body, {
					status: {
						code: 'not-authorised',
						message: 'A valid login session was not found. Please log in and try again.',
					},
					response: {},
				});
			});
		});
	});

	describe('email confirm', () => {
		it('should error with invalid code', (done) => {
			User.email.confirmByCode('asdasda', (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should confirm email of user', async () => {
			const email = 'confirm@me.com';
			const uid = await User.create({
				username: 'confirme',
				email: email,
			});

			const code = await User.email.sendValidationEmail(uid, email);
			const unverified = await groups.isMember(uid, 'unverified-users');
			assert.strictEqual(unverified, true);
			await User.email.confirmByCode(code);
			const [confirmed, isVerified] = await Promise.all([
				db.getObjectField(`user:${uid}`, 'email:confirmed'),
				groups.isMember(uid, 'verified-users', uid),
			]);
			assert.strictEqual(parseInt(confirmed, 10), 1);
			assert.strictEqual(isVerified, true);
		});

		it('should confirm email of user by uid', async () => {
			const email = 'confirm2@me.com';
			const uid = await User.create({
				username: 'confirme2',
				email: email,
			});

			const unverified = await groups.isMember(uid, 'unverified-users');
			assert.strictEqual(unverified, true);
			await User.email.confirmByUid(uid);
			const [confirmed, isVerified] = await Promise.all([
				db.getObjectField(`user:${uid}`, 'email:confirmed'),
				groups.isMember(uid, 'verified-users', uid),
			]);
			assert.strictEqual(parseInt(confirmed, 10), 1);
			assert.strictEqual(isVerified, true);
		});
	});

	describe('user jobs', () => {
		it('should start user jobs', (done) => {
			User.startJobs();
			done();
		});

		it('should stop user jobs', (done) => {
			User.stopJobs();
			done();
		});

		it('should send digest', (done) => {
			db.sortedSetAdd('digest:day:uids', [Date.now(), Date.now()], [1, 2], (err) => {
				assert.ifError(err);
				User.digest.execute({ interval: 'day' }, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});
	});

	describe('hideEmail/hideFullname', () => {
		let uid;
		after((done) => {
			meta.config.hideEmail = 0;
			meta.config.hideFullname = 0;
			done();
		});

		it('should hide email and fullname', (done) => {
			meta.config.hideEmail = 1;
			meta.config.hideFullname = 1;

			User.create({
				username: 'hiddenemail',
				email: 'should@be.hidden',
				fullname: 'baris soner usakli',
			}, (err, _uid) => {
				uid = _uid;
				assert.ifError(err);
				request(`${nconf.get('url')}/api/user/hiddenemail`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(body.fullname, '');
					assert.equal(body.email, '');

					done();
				});
			});
		});

		it('should hide fullname in topic list and topic', (done) => {
			Topics.post({
				uid: uid,
				title: 'Topic hidden',
				content: 'lorem ipsum',
				cid: testCid,
			}, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/recent`, { json: true }, (err, res, body) => {
					assert.ifError(err);
					assert(!body.topics[0].user.hasOwnProperty('fullname'));
					request(`${nconf.get('url')}/api/topic/${body.topics[0].slug}`, { json: true }, (err, res, body) => {
						assert.ifError(err);
						assert(!body.posts[0].user.hasOwnProperty('fullname'));
						done();
					});
				});
			});
		});
	});

	describe('user blocking methods', (done) => {
		let blockeeUid;
		before((done) => {
			User.create({
				username: 'blockee',
				email: 'blockee@example.org',
				fullname: 'Block me',
			}, (err, uid) => {
				blockeeUid = uid;
				done(err);
			});
		});

		describe('.toggle()', () => {
			it('should toggle block', (done) => {
				socketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) => {
					assert.ifError(err);
					User.blocks.is(blockeeUid, 1, (err, blocked) => {
						assert.ifError(err);
						assert(blocked);
						done();
					});
				});
			});

			it('should toggle block', (done) => {
				socketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) => {
					assert.ifError(err);
					User.blocks.is(blockeeUid, 1, (err, blocked) => {
						assert.ifError(err);
						assert(!blocked);
						done();
					});
				});
			});
		});

		describe('.add()', () => {
			it('should block a uid', (done) => {
				User.blocks.add(blockeeUid, 1, (err) => {
					assert.ifError(err);
					User.blocks.list(1, (err, blocked_uids) => {
						assert.ifError(err);
						assert.strictEqual(Array.isArray(blocked_uids), true);
						assert.strictEqual(blocked_uids.length, 1);
						assert.strictEqual(blocked_uids.includes(blockeeUid), true);
						done();
					});
				});
			});

			it('should automatically increment corresponding user field', (done) => {
				db.getObjectField('user:1', 'blocksCount', (err, count) => {
					assert.ifError(err);
					assert.strictEqual(parseInt(count, 10), 1);
					done();
				});
			});

			it('should error if you try to block the same uid again', (done) => {
				User.blocks.add(blockeeUid, 1, (err) => {
					assert.equal(err.message, '[[error:already-blocked]]');
					done();
				});
			});
		});

		describe('.remove()', () => {
			it('should unblock a uid', (done) => {
				User.blocks.remove(blockeeUid, 1, (err) => {
					assert.ifError(err);
					User.blocks.list(1, (err, blocked_uids) => {
						assert.ifError(err);
						assert.strictEqual(Array.isArray(blocked_uids), true);
						assert.strictEqual(blocked_uids.length, 0);
						done();
					});
				});
			});

			it('should automatically decrement corresponding user field', (done) => {
				db.getObjectField('user:1', 'blocksCount', (err, count) => {
					assert.ifError(err);
					assert.strictEqual(parseInt(count, 10), 0);
					done();
				});
			});

			it('should error if you try to unblock the same uid again', (done) => {
				User.blocks.remove(blockeeUid, 1, (err) => {
					assert.equal(err.message, '[[error:already-unblocked]]');
					done();
				});
			});
		});

		describe('.is()', () => {
			before((done) => {
				User.blocks.add(blockeeUid, 1, done);
			});

			it('should return a Boolean with blocked status for the queried uid', (done) => {
				User.blocks.is(blockeeUid, 1, (err, blocked) => {
					assert.ifError(err);
					assert.strictEqual(blocked, true);
					done();
				});
			});
		});

		describe('.list()', () => {
			it('should return a list of blocked uids', (done) => {
				User.blocks.list(1, (err, blocked_uids) => {
					assert.ifError(err);
					assert.strictEqual(Array.isArray(blocked_uids), true);
					assert.strictEqual(blocked_uids.length, 1);
					assert.strictEqual(blocked_uids.includes(blockeeUid), true);
					done();
				});
			});
		});

		describe('.filter()', () => {
			it('should remove entries by blocked uids and return filtered set', (done) => {
				User.blocks.filter(1, [{
					foo: 'foo',
					uid: blockeeUid,
				}, {
					foo: 'bar',
					uid: 1,
				}, {
					foo: 'baz',
					uid: blockeeUid,
				}], (err, filtered) => {
					assert.ifError(err);
					assert.strictEqual(Array.isArray(filtered), true);
					assert.strictEqual(filtered.length, 1);
					assert.equal(filtered[0].uid, 1);
					done();
				});
			});

			it('should allow property argument to be passed in to customise checked property', (done) => {
				User.blocks.filter(1, 'fromuid', [{
					foo: 'foo',
					fromuid: blockeeUid,
				}, {
					foo: 'bar',
					fromuid: 1,
				}, {
					foo: 'baz',
					fromuid: blockeeUid,
				}], (err, filtered) => {
					assert.ifError(err);
					assert.strictEqual(Array.isArray(filtered), true);
					assert.strictEqual(filtered.length, 1);
					assert.equal(filtered[0].fromuid, 1);
					done();
				});
			});

			it('should not process invalid sets', (done) => {
				User.blocks.filter(1, [{ foo: 'foo' }, { foo: 'bar' }, { foo: 'baz' }], (err, filtered) => {
					assert.ifError(err);
					assert.strictEqual(Array.isArray(filtered), true);
					assert.strictEqual(filtered.length, 3);
					filtered.forEach((obj) => {
						assert.strictEqual(obj.hasOwnProperty('foo'), true);
					});
					done();
				});
			});

			it('should process plain sets that just contain uids', (done) => {
				User.blocks.filter(1, [1, blockeeUid], (err, filtered) => {
					assert.ifError(err);
					assert.strictEqual(filtered.length, 1);
					assert.strictEqual(filtered[0], 1);
					done();
				});
			});

			it('should filter uids that are blocking targetUid', (done) => {
				User.blocks.filterUids(blockeeUid, [1, 2], (err, filtered) => {
					assert.ifError(err);
					assert.deepEqual(filtered, [2]);
					done();
				});
			});
		});
	});

	describe('status/online', () => {
		it('should return offline if user is guest', (done) => {
			const status = User.getStatus({ uid: 0 });
			assert.strictEqual(status, 'offline');
			done();
		});

		it('should return offline if user is guest', async () => {
			assert.strictEqual(await User.isOnline(0), false);
		});

		it('should return true', async () => {
			assert.strictEqual(await User.isOnline(testUid), true);
		});
	});

	describe('isPrivilegedOrSelf', () => {
		it('should return not error if self', (done) => {
			User.isPrivilegedOrSelf(1, 1, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should not error if privileged', (done) => {
			User.create({ username: 'theadmin' }, (err, uid) => {
				assert.ifError(err);
				groups.join('administrators', uid, (err) => {
					assert.ifError(err);
					User.isPrivilegedOrSelf(uid, 2, (err) => {
						assert.ifError(err);
						done();
					});
				});
			});
		});

		it('should error if not privileged', (done) => {
			User.isPrivilegedOrSelf(0, 1, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});
	});

	it('should get admins and mods', (done) => {
		User.getAdminsandGlobalMods((err, data) => {
			assert.ifError(err);
			assert(Array.isArray(data));
			done();
		});
	});

	it('should allow user to login even if password is weak', (done) => {
		User.create({ username: 'weakpwd', password: '123456' }, (err) => {
			assert.ifError(err);
			const oldValue = meta.config.minimumPasswordStrength;
			meta.config.minimumPasswordStrength = 3;
			helpers.loginUser('weakpwd', '123456', (err, jar, csrfs_token) => {
				assert.ifError(err);
				meta.config.minimumPasswordStrength = oldValue;
				done();
			});
		});
'use strict';

const assert = require('assert');
const async = require('async');
const request = require('request');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const meta = require('../src/meta');
const User = require('../src/user');
const Groups = require('../src/groups');

describe('meta', () => {
	let fooUid;
	let bazUid;
	let herpUid;

	before((done) => {
		Groups.cache.reset();
		// Create 3 users: 1 admin, 2 regular
		async.series([
			async.apply(User.create, { username: 'foo', password: 'barbar' }),	// admin
			async.apply(User.create, { username: 'baz', password: 'quuxquux' }),	// restricted user
			async.apply(User.create, { username: 'herp', password: 'derpderp' }),	// regular user
		], (err, uids) => {
			if (err) {
				return done(err);
			}

			fooUid = uids[0];
			bazUid = uids[1];
			herpUid = uids[2];

			Groups.join('administrators', fooUid, done);
		});
	});

	describe('settings', () => {
		const socketAdmin = require('../src/socket.io/admin');
		it('it should set setting', (done) => {
			socketAdmin.settings.set({ uid: fooUid }, { hash: 'some:hash', values: { foo: '1', derp: 'value' } }, (err) => {
				assert.ifError(err);
				db.getObject('settings:some:hash', (err, data) => {
					assert.ifError(err);
					assert.equal(data.foo, '1');
					assert.equal(data.derp, 'value');
					done();
				});
			});
		});

		it('it should get setting', (done) => {
			socketAdmin.settings.get({ uid: fooUid }, { hash: 'some:hash' }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.foo, '1');
				assert.equal(data.derp, 'value');
				done();
			});
		});

		it('should not set setting if not empty', (done) => {
			meta.settings.setOnEmpty('some:hash', { foo: 2 }, (err) => {
				assert.ifError(err);
				db.getObject('settings:some:hash', (err, data) => {
					assert.ifError(err);
					assert.equal(data.foo, '1');
					assert.equal(data.derp, 'value');
					done();
				});
			});
		});

		it('should set setting if empty', (done) => {
			meta.settings.setOnEmpty('some:hash', { empty: '2' }, (err) => {
				assert.ifError(err);
				db.getObject('settings:some:hash', (err, data) => {
					assert.ifError(err);
					assert.equal(data.foo, '1');
					assert.equal(data.derp, 'value');
					assert.equal(data.empty, '2');
					done();
				});
			});
		});

		it('should set one and get one', (done) => {
			meta.settings.setOne('some:hash', 'myField', 'myValue', (err) => {
				assert.ifError(err);
				meta.settings.getOne('some:hash', 'myField', (err, myValue) => {
					assert.ifError(err);
					assert.equal(myValue, 'myValue');
					done();
				});
			});
		});

		it('should return null if setting field does not exist', async () => {
			const val = await meta.settings.getOne('some:hash', 'does not exist');
			assert.strictEqual(val, null);
		});

		const someList = [
			{ name: 'andrew', status: 'best' },
			{ name: 'baris', status: 'wurst' },
		];
		const anotherList = [];

		it('should set setting with sorted list', (done) => {
			socketAdmin.settings.set({ uid: fooUid }, { hash: 'another:hash', values: { foo: '1', derp: 'value', someList: someList, anotherList: anotherList } }, (err) => {
				if (err) {
					return done(err);
				}

				db.getObject('settings:another:hash', (err, data) => {
					if (err) {
						return done(err);
					}

					assert.equal(data.foo, '1');
					assert.equal(data.derp, 'value');
					assert.equal(data.someList, undefined);
					assert.equal(data.anotherList, undefined);
					done();
				});
			});
		});

		it('should get setting with sorted list', (done) => {
			socketAdmin.settings.get({ uid: fooUid }, { hash: 'another:hash' }, (err, data) => {
				assert.ifError(err);
				assert.strictEqual(data.foo, '1');
				assert.strictEqual(data.derp, 'value');
				assert.deepStrictEqual(data.someList, someList);
				assert.deepStrictEqual(data.anotherList, anotherList);
				done();
			});
		});

		it('should not set setting if not empty', (done) => {
			meta.settings.setOnEmpty('some:hash', { foo: 2 }, (err) => {
				assert.ifError(err);
				db.getObject('settings:some:hash', (err, data) => {
					assert.ifError(err);
					assert.equal(data.foo, '1');
					assert.equal(data.derp, 'value');
					done();
				});
			});
		});

		it('should not set setting with sorted list if not empty', (done) => {
			meta.settings.setOnEmpty('another:hash', { foo: anotherList }, (err) => {
				assert.ifError(err);
				socketAdmin.settings.get({ uid: fooUid }, { hash: 'another:hash' }, (err, data) => {
					assert.ifError(err);
					assert.equal(data.foo, '1');
					assert.equal(data.derp, 'value');
					done();
				});
			});
		});

		it('should set setting with sorted list if empty', (done) => {
			meta.settings.setOnEmpty('another:hash', { empty: someList }, (err) => {
				assert.ifError(err);
				socketAdmin.settings.get({ uid: fooUid }, { hash: 'another:hash' }, (err, data) => {
					assert.ifError(err);
					assert.equal(data.foo, '1');
					assert.equal(data.derp, 'value');
					assert.deepEqual(data.empty, someList);
					done();
				});
			});
		});

		it('should set one and get one sorted list', (done) => {
			meta.settings.setOne('another:hash', 'someList', someList, (err) => {
				assert.ifError(err);
				meta.settings.getOne('another:hash', 'someList', (err, _someList) => {
					assert.ifError(err);
					assert.deepEqual(_someList, someList);
					done();
				});
			});
		});
	});


	describe('config', () => {
		const socketAdmin = require('../src/socket.io/admin');
		before((done) => {
			db.setObject('config', { minimumTagLength: 3, maximumTagLength: 15 }, done);
		});

		it('should get config fields', (done) => {
			meta.configs.getFields(['minimumTagLength', 'maximumTagLength'], (err, data) => {
				assert.ifError(err);
				assert.strictEqual(data.minimumTagLength, 3);
				assert.strictEqual(data.maximumTagLength, 15);
				done();
			});
		});

		it('should get the correct type and default value', (done) => {
			meta.configs.set('loginAttempts', '', (err) => {
				assert.ifError(err);
				meta.configs.get('loginAttempts', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(value, 5);
					done();
				});
			});
		});

		it('should get the correct type and correct value', (done) => {
			meta.configs.set('loginAttempts', '0', (err) => {
				assert.ifError(err);
				meta.configs.get('loginAttempts', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(value, 0);
					done();
				});
			});
		});

		it('should get the correct value', (done) => {
			meta.configs.set('title', 123, (err) => {
				assert.ifError(err);
				meta.configs.get('title', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(value, '123');
					done();
				});
			});
		});

		it('should get the correct value', (done) => {
			meta.configs.set('title', 0, (err) => {
				assert.ifError(err);
				meta.configs.get('title', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(value, '0');
					done();
				});
			});
		});

		it('should get the correct value', (done) => {
			meta.configs.set('title', '', (err) => {
				assert.ifError(err);
				meta.configs.get('title', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(value, '');
					done();
				});
			});
		});

		it('should use default value if value is null', (done) => {
			meta.configs.set('teaserPost', null, (err) => {
				assert.ifError(err);
				meta.configs.get('teaserPost', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(value, 'last-reply');
					done();
				});
			});
		});

		it('should fail if field is invalid', (done) => {
			meta.configs.set('', 'someValue', (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail if data is invalid', (done) => {
			socketAdmin.config.set({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should set multiple config values', (done) => {
			socketAdmin.config.set({ uid: fooUid }, { key: 'someKey', value: 'someValue' }, (err) => {
				assert.ifError(err);
				meta.configs.getFields(['someKey'], (err, data) => {
					assert.ifError(err);
					assert.equal(data.someKey, 'someValue');
					done();
				});
			});
		});

		it('should set config value', (done) => {
			meta.configs.set('someField', 'someValue', (err) => {
				assert.ifError(err);
				meta.configs.getFields(['someField'], (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.someField, 'someValue');
					done();
				});
			});
		});

		it('should get back string if field is not in defaults', (done) => {
			meta.configs.set('numericField', 123, (err) => {
				assert.ifError(err);
				meta.configs.getFields(['numericField'], (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.numericField, 123);
					done();
				});
			});
		});

		it('should set boolean config value', (done) => {
			meta.configs.set('booleanField', true, (err) => {
				assert.ifError(err);
				meta.configs.getFields(['booleanField'], (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.booleanField, true);
					done();
				});
			});
		});

		it('should set boolean config value', (done) => {
			meta.configs.set('booleanField', 'false', (err) => {
				assert.ifError(err);
				meta.configs.getFields(['booleanField'], (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.booleanField, false);
					done();
				});
			});
		});

		it('should set string config value', (done) => {
			meta.configs.set('stringField', '123', (err) => {
				assert.ifError(err);
				meta.configs.getFields(['stringField'], (err, data) => {
					assert.ifError(err);
					assert.strictEqual(data.stringField, 123);
					done();
				});
			});
		});

		it('should fail if data is invalid', (done) => {
			socketAdmin.config.setMultiple({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should set multiple values', (done) => {
			socketAdmin.config.setMultiple({ uid: fooUid }, {
				someField1: 'someValue1',
				someField2: 'someValue2',
				customCSS: '.derp{color:#00ff00;}',
			}, (err) => {
				assert.ifError(err);
				meta.configs.getFields(['someField1', 'someField2'], (err, data) => {
					assert.ifError(err);
					assert.equal(data.someField1, 'someValue1');
					assert.equal(data.someField2, 'someValue2');
					done();
				});
			});
		});

		it('should not set config if not empty', (done) => {
			meta.configs.setOnEmpty({ someField1: 'foo' }, (err) => {
				assert.ifError(err);
				meta.configs.get('someField1', (err, value) => {
					assert.ifError(err);
					assert.equal(value, 'someValue1');
					done();
				});
			});
		});

		it('should remove config field', (done) => {
			socketAdmin.config.remove({ uid: fooUid }, 'someField1', (err) => {
				assert.ifError(err);
				db.isObjectField('config', 'someField1', (err, isObjectField) => {
					assert.ifError(err);
					assert(!isObjectField);
					done();
				});
			});
		});
	});


	describe('session TTL', () => {
		it('should return 14 days in seconds', (done) => {
			assert(meta.getSessionTTLSeconds(), 1209600);
			done();
		});

		it('should return 7 days in seconds', (done) => {
			meta.config.loginDays = 7;
			assert(meta.getSessionTTLSeconds(), 604800);
			done();
		});

		it('should return 2 days in seconds', (done) => {
			meta.config.loginSeconds = 172800;
			assert(meta.getSessionTTLSeconds(), 172800);
			done();
		});
	});

	describe('dependencies', () => {
		it('should return ENOENT if module is not found', (done) => {
			meta.dependencies.checkModule('some-module-that-does-not-exist', (err) => {
				assert.equal(err.code, 'ENOENT');
				done();
			});
		});

		it('should not error if module is a nodebb-plugin-*', (done) => {
			meta.dependencies.checkModule('nodebb-plugin-somePlugin', (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should not error if module is nodebb-theme-*', (done) => {
			meta.dependencies.checkModule('nodebb-theme-someTheme', (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should parse json package data', (done) => {
			const pkgData = meta.dependencies.parseModuleData('nodebb-plugin-test', '{"a": 1}');
			assert.equal(pkgData.a, 1);
			done();
		});

		it('should return null data with invalid json', (done) => {
			const pkgData = meta.dependencies.parseModuleData('nodebb-plugin-test', 'asdasd');
			assert.strictEqual(pkgData, null);
			done();
		});

		it('should return false if moduleData is falsy', (done) => {
			assert(!meta.dependencies.doesSatisfy(null, '1.0.0'));
			done();
		});

		it('should return false if moduleData doesnt not satisfy package.json', (done) => {
			assert(!meta.dependencies.doesSatisfy({ name: 'nodebb-plugin-test', version: '0.9.0' }, '1.0.0'));
			done();
		});

		it('should return true if _resolved is from github', (done) => {
			assert(meta.dependencies.doesSatisfy({ name: 'nodebb-plugin-test', _resolved: 'https://github.com/some/repo', version: '0.9.0' }, '1.0.0'));
			done();
		});
	});

	describe('debugFork', () => {
		let oldArgv;
		before(() => {
			oldArgv = process.execArgv;
			process.execArgv = ['--debug=5858', '--foo=1'];
		});

		it('should detect debugging', (done) => {
			let debugFork = require('../src/meta/debugFork');
			assert(!debugFork.debugging);

			const debugForkPath = require.resolve('../src/meta/debugFork');
			delete require.cache[debugForkPath];

			debugFork = require('../src/meta/debugFork');
			assert(debugFork.debugging);

			done();
		});

		after(() => {
			process.execArgv = oldArgv;
		});
	});

	describe('Access-Control-Allow-Origin', () => {
		it('Access-Control-Allow-Origin header should be empty', (done) => {
			const jar = request.jar();
			request.get(`${nconf.get('url')}/api/search?term=bug`, {
				form: {},
				json: true,
				jar: jar,
			}, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.headers['access-control-allow-origin'], undefined);
				done();
			});
		});

		it('should set proper Access-Control-Allow-Origin header', (done) => {
			const jar = request.jar();
			const oldValue = meta.config['access-control-allow-origin'];
			meta.config['access-control-allow-origin'] = 'test.com, mydomain.com';
			request.get(`${nconf.get('url')}/api/search?term=bug`, {
				form: {
				},
				json: true,
				jar: jar,
				headers: {
					origin: 'mydomain.com',
				},
			}, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.headers['access-control-allow-origin'], 'mydomain.com');
				meta.config['access-control-allow-origin'] = oldValue;
				done(err);
			});
		});

		it('Access-Control-Allow-Origin header should be empty if origin does not match', (done) => {
			const jar = request.jar();
			const oldValue = meta.config['access-control-allow-origin'];
			meta.config['access-control-allow-origin'] = 'test.com, mydomain.com';
			request.get(`${nconf.get('url')}/api/search?term=bug`, {
				form: {
				},
				json: true,
				jar: jar,
				headers: {
					origin: 'notallowed.com',
				},
			}, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.headers['access-control-allow-origin'], undefined);
				meta.config['access-control-allow-origin'] = oldValue;
				done(err);
			});
		});

		it('should set proper Access-Control-Allow-Origin header', (done) => {
			const jar = request.jar();
			const oldValue = meta.config['access-control-allow-origin-regex'];
			meta.config['access-control-allow-origin-regex'] = 'match\\.this\\..+\\.domain.com, mydomain\\.com';
			request.get(`${nconf.get('url')}/api/search?term=bug`, {
				form: {
				},
				json: true,
				jar: jar,
				headers: {
					origin: 'match.this.anything123.domain.com',
				},
			}, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.headers['access-control-allow-origin'], 'match.this.anything123.domain.com');
				meta.config['access-control-allow-origin-regex'] = oldValue;
				done(err);
			});
		});

		it('Access-Control-Allow-Origin header should be empty if origin does not match', (done) => {
			const jar = request.jar();
			const oldValue = meta.config['access-control-allow-origin-regex'];
			meta.config['access-control-allow-origin-regex'] = 'match\\.this\\..+\\.domain.com, mydomain\\.com';
			request.get(`${nconf.get('url')}/api/search?term=bug`, {
				form: {
				},
				json: true,
				jar: jar,
				headers: {
					origin: 'notallowed.com',
				},
			}, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.headers['access-control-allow-origin'], undefined);
				meta.config['access-control-allow-origin-regex'] = oldValue;
				done(err);
			});
		});

		it('should not error with invalid regexp', (done) => {
			const jar = request.jar();
			const oldValue = meta.config['access-control-allow-origin-regex'];
			meta.config['access-control-allow-origin-regex'] = '[match\\.this\\..+\\.domain.com, mydomain\\.com';
			request.get(`${nconf.get('url')}/api/search?term=bug`, {
				form: {
				},
				json: true,
				jar: jar,
				headers: {
					origin: 'mydomain.com',
				},
			}, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.headers['access-control-allow-origin'], 'mydomain.com');
				meta.config['access-control-allow-origin-regex'] = oldValue;
'use strict';

const assert = require('assert');
const async = require('async');
const request = require('request');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const topics = require('../src/topics');
const categories = require('../src/categories');
const groups = require('../src/groups');
const user = require('../src/user');
const meta = require('../src/meta');
const privileges = require('../src/privileges');
const helpers = require('./helpers');

describe('feeds', () => {
	let tid;
	let pid;
	let fooUid;
	let cid;
	before((done) => {
		meta.config['feeds:disableRSS'] = 1;
		async.series({
			category: function (next) {
				categories.create({
					name: 'Test Category',
					description: 'Test category created by testing script',
				}, next);
			},
			user: function (next) {
				user.create({ username: 'foo', password: 'barbar', email: 'foo@test.com' }, next);
			},
		}, (err, results) => {
			if (err) {
				return done(err);
			}
			cid = results.category.cid;
			fooUid = results.user;

			topics.post({ uid: results.user, title: 'test topic title', content: 'test topic content', cid: results.category.cid }, (err, result) => {
				tid = result.topicData.tid;
				pid = result.postData.pid;
				done(err);
			});
		});
	});


	it('should 404', (done) => {
		const feedUrls = [
			`${nconf.get('url')}/topic/${tid}.rss`,
			`${nconf.get('url')}/category/${cid}.rss`,
			`${nconf.get('url')}/topics.rss`,
			`${nconf.get('url')}/recent.rss`,
			`${nconf.get('url')}/top.rss`,
			`${nconf.get('url')}/popular.rss`,
			`${nconf.get('url')}/popular/day.rss`,
			`${nconf.get('url')}/recentposts.rss`,
			`${nconf.get('url')}/category/${cid}/recentposts.rss`,
			`${nconf.get('url')}/user/foo/topics.rss`,
			`${nconf.get('url')}/tags/nodebb.rss`,
		];
		async.eachSeries(feedUrls, (url, next) => {
			request(url, (err, res) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 404);
				next();
			});
		}, (err) => {
			assert.ifError(err);
			meta.config['feeds:disableRSS'] = 0;
			done();
		});
	});

	it('should 404 if topic does not exist', (done) => {
		request(`${nconf.get('url')}/topic/${1000}.rss`, (err, res) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			done();
		});
	});

	it('should 404 if category id is not a number', (done) => {
		request(`${nconf.get('url')}/category/invalid.rss`, (err, res) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			done();
		});
	});

	it('should redirect if we do not have read privilege', (done) => {
		privileges.categories.rescind(['groups:topics:read'], cid, 'guests', (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/topic/${tid}.rss`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				assert(body.includes('Login to your account'));
				privileges.categories.give(['groups:topics:read'], cid, 'guests', done);
			});
		});
	});

	it('should 404 if user is not found', (done) => {
		request(`${nconf.get('url')}/user/doesnotexist/topics.rss`, (err, res) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			done();
		});
	});

	it('should redirect if we do not have read privilege', (done) => {
		privileges.categories.rescind(['groups:read'], cid, 'guests', (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/category/${cid}.rss`, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				assert(body.includes('Login to your account'));
				privileges.categories.give(['groups:read'], cid, 'guests', done);
			});
		});
	});

	describe('private feeds and tokens', () => {
		let jar;
		let rssToken;
		before((done) => {
			helpers.loginUser('foo', 'barbar', (err, _jar) => {
				assert.ifError(err);
				jar = _jar;
				done();
			});
		});

		it('should load feed if its not private', (done) => {
			request(`${nconf.get('url')}/category/${cid}.rss`, { }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});


		it('should not allow access if uid or token is missing', (done) => {
			privileges.categories.rescind(['groups:read'], cid, 'guests', (err) => {
				assert.ifError(err);
				async.parallel({
					test1: function (next) {
						request(`${nconf.get('url')}/category/${cid}.rss?uid=${fooUid}`, { }, next);
					},
					test2: function (next) {
						request(`${nconf.get('url')}/category/${cid}.rss?token=sometoken`, { }, next);
					},
				}, (err, results) => {
					assert.ifError(err);
					assert.equal(results.test1[0].statusCode, 200);
					assert.equal(results.test2[0].statusCode, 200);
					assert(results.test1[0].body.includes('Login to your account'));
					assert(results.test2[0].body.includes('Login to your account'));
					done();
				});
			});
		});

		it('should not allow access if token is wrong', (done) => {
			request(`${nconf.get('url')}/category/${cid}.rss?uid=${fooUid}&token=sometoken`, { }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body.includes('Login to your account'));
				done();
			});
		});

		it('should allow access if token is correct', (done) => {
			request(`${nconf.get('url')}/api/category/${cid}`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				rssToken = body.rssFeedUrl.split('token')[1].slice(1);
				request(`${nconf.get('url')}/category/${cid}.rss?uid=${fooUid}&token=${rssToken}`, { }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body.startsWith('<?xml version="1.0"'));
					done();
				});
			});
		});

		it('should not allow access if token is correct but has no privilege', (done) => {
			privileges.categories.rescind(['groups:read'], cid, 'registered-users', (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/category/${cid}.rss?uid=${fooUid}&token=${rssToken}`, { }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body.includes('Login to your account'));
					done();
				});
			});
'use strict';


const async = require('async');
const assert = require('assert');
const nconf = require('nconf');
const request = require('request');

const db = require('./mocks/databasemock');
const Categories = require('../src/categories');
const Topics = require('../src/topics');
const User = require('../src/user');
const groups = require('../src/groups');
const privileges = require('../src/privileges');

describe('Categories', () => {
	let categoryObj;
	let posterUid;
	let adminUid;

	before((done) => {
		async.series({
			posterUid: function (next) {
				User.create({ username: 'poster' }, next);
			},
			adminUid: function (next) {
				User.create({ username: 'admin' }, next);
			},
		}, (err, results) => {
			assert.ifError(err);
			posterUid = results.posterUid;
			adminUid = results.adminUid;
			groups.join('administrators', adminUid, done);
		});
	});


	it('should create a new category', (done) => {
		Categories.create({
			name: 'Test Category & NodeBB',
			description: 'Test category created by testing script',
			icon: 'fa-check',
			blockclass: 'category-blue',
			order: '5',
		}, (err, category) => {
			assert.ifError(err);

			categoryObj = category;
			done();
		});
	});

	it('should retrieve a newly created category by its ID', (done) => {
		Categories.getCategoryById({
			cid: categoryObj.cid,
			start: 0,
			stop: -1,
			uid: 0,
		}, (err, categoryData) => {
			assert.ifError(err);

			assert(categoryData);
			assert.equal('Test Category &amp; NodeBB', categoryData.name);
			assert.equal(categoryObj.description, categoryData.description);
			assert.strictEqual(categoryObj.disabled, 0);
			done();
		});
	});

	it('should return null if category does not exist', (done) => {
		Categories.getCategoryById({
			cid: 123123123,
			start: 0,
			stop: -1,
		}, (err, categoryData) => {
			assert.ifError(err);
			assert.strictEqual(categoryData, null);
			done();
		});
	});

	it('should get all categories', (done) => {
		Categories.getAllCategories(1, (err, data) => {
			assert.ifError(err);
			assert(Array.isArray(data));
			assert.equal(data[0].cid, categoryObj.cid);
			done();
		});
	});

	it('should load a category route', (done) => {
		request(`${nconf.get('url')}/api/category/${categoryObj.cid}/test-category`, { json: true }, (err, response, body) => {
			assert.ifError(err);
			assert.equal(response.statusCode, 200);
			assert.equal(body.name, 'Test Category &amp; NodeBB');
			assert(body);
			done();
		});
	});

	describe('Categories.getRecentTopicReplies', () => {
		it('should not throw', (done) => {
			Categories.getCategoryById({
				cid: categoryObj.cid,
				set: `cid:${categoryObj.cid}:tids`,
				reverse: true,
				start: 0,
				stop: -1,
				uid: 0,
			}, (err, categoryData) => {
				assert.ifError(err);
				Categories.getRecentTopicReplies(categoryData, 0, {}, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});
	});

	describe('.getCategoryTopics', () => {
		it('should return a list of topics', (done) => {
			Categories.getCategoryTopics({
				cid: categoryObj.cid,
				start: 0,
				stop: 10,
				uid: 0,
				sort: 'oldest_to_newest',
			}, (err, result) => {
				assert.equal(err, null);

				assert(Array.isArray(result.topics));
				assert(result.topics.every(topic => topic instanceof Object));

				done();
			});
		});

		it('should return a list of topics by a specific user', (done) => {
			Categories.getCategoryTopics({
				cid: categoryObj.cid,
				start: 0,
				stop: 10,
				uid: 0,
				targetUid: 1,
				sort: 'oldest_to_newest',
			}, (err, result) => {
				assert.equal(err, null);
				assert(Array.isArray(result.topics));
				assert(result.topics.every(topic => topic instanceof Object && topic.uid === '1'));

				done();
			});
		});
	});

	describe('Categories.moveRecentReplies', () => {
		let moveCid;
		let moveTid;
		before((done) => {
			async.parallel({
				category: function (next) {
					Categories.create({
						name: 'Test Category 2',
						description: 'Test category created by testing script',
					}, next);
				},
				topic: function (next) {
					Topics.post({
						uid: posterUid,
						cid: categoryObj.cid,
						title: 'Test Topic Title',
						content: 'The content of test topic',
					}, next);
				},
			}, (err, results) => {
				if (err) {
					return done(err);
				}
				moveCid = results.category.cid;
				moveTid = results.topic.topicData.tid;
				Topics.reply({ uid: posterUid, content: 'test post', tid: moveTid }, (err) => {
					done(err);
				});
			});
		});

		it('should move posts from one category to another', (done) => {
			Categories.moveRecentReplies(moveTid, categoryObj.cid, moveCid, (err) => {
				assert.ifError(err);
				db.getSortedSetRange(`cid:${categoryObj.cid}:pids`, 0, -1, (err, pids) => {
					assert.ifError(err);
					assert.equal(pids.length, 0);
					db.getSortedSetRange(`cid:${moveCid}:pids`, 0, -1, (err, pids) => {
						assert.ifError(err);
						assert.equal(pids.length, 2);
						done();
					});
				});
			});
		});
	});

	describe('socket methods', () => {
		const socketCategories = require('../src/socket.io/categories');

		before((done) => {
			Topics.post({
				uid: posterUid,
				cid: categoryObj.cid,
				title: 'Test Topic Title',
				content: 'The content of test topic',
				tags: ['nodebb'],
			}, done);
		});

		it('should get recent replies in category', (done) => {
			socketCategories.getRecentReplies({ uid: posterUid }, categoryObj.cid, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it('should get categories', (done) => {
			socketCategories.get({ uid: posterUid }, {}, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it('should get watched categories', (done) => {
			socketCategories.getWatchedCategories({ uid: posterUid }, {}, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it('should load more topics', (done) => {
			socketCategories.loadMore({ uid: posterUid }, {
				cid: categoryObj.cid,
				after: 0,
				query: {
					author: 'poster',
					tag: 'nodebb',
				},
			}, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data.topics));
				assert.equal(data.topics[0].user.username, 'poster');
				assert.equal(data.topics[0].tags[0].value, 'nodebb');
				assert.equal(data.topics[0].category.cid, categoryObj.cid);
				done();
			});
		});

		it('should load topic count', (done) => {
			socketCategories.getTopicCount({ uid: posterUid }, categoryObj.cid, (err, topicCount) => {
				assert.ifError(err);
				assert.equal(topicCount, 2);
				done();
			});
		});

		it('should load category by privilege', (done) => {
			socketCategories.getCategoriesByPrivilege({ uid: posterUid }, 'find', (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it('should get move categories', (done) => {
			socketCategories.getMoveCategories({ uid: posterUid }, {}, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it('should ignore category', (done) => {
			socketCategories.ignore({ uid: posterUid }, { cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				Categories.isIgnored([categoryObj.cid], posterUid, (err, isIgnored) => {
					assert.ifError(err);
					assert.equal(isIgnored[0], true);
					Categories.getIgnorers(categoryObj.cid, 0, -1, (err, ignorers) => {
						assert.ifError(err);
						assert.deepEqual(ignorers, [posterUid]);
						done();
					});
				});
			});
		});

		it('should watch category', (done) => {
			socketCategories.watch({ uid: posterUid }, { cid: categoryObj.cid }, (err) => {
				assert.ifError(err);
				Categories.isIgnored([categoryObj.cid], posterUid, (err, isIgnored) => {
					assert.ifError(err);
					assert.equal(isIgnored[0], false);
					done();
				});
			});
		});

		it('should error if watch state does not exist', (done) => {
			socketCategories.setWatchState({ uid: posterUid }, { cid: categoryObj.cid, state: 'invalid-state' }, (err) => {
				assert.equal(err.message, '[[error:invalid-watch-state]]');
				done();
			});
		});

		it('should check if user is moderator', (done) => {
			socketCategories.isModerator({ uid: posterUid }, {}, (err, isModerator) => {
				assert.ifError(err);
				assert(!isModerator);
				done();
			});
		});

		it('should get category data', (done) => {
			socketCategories.getCategory({ uid: posterUid }, categoryObj.cid, (err, data) => {
				assert.ifError(err);
				assert.equal(categoryObj.cid, data.cid);
				done();
			});
		});
	});

	describe('admin socket methods', () => {
		const socketCategories = require('../src/socket.io/admin/categories');
		let cid;
		before((done) => {
			socketCategories.create({ uid: adminUid }, {
				name: 'update name',
				description: 'update description',
				parentCid: categoryObj.cid,
				icon: 'fa-check',
				order: '5',
			}, (err, category) => {
				assert.ifError(err);

				cid = category.cid;
				done();
			});
		});

		it('should return error with invalid data', (done) => {
			socketCategories.update({ uid: adminUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if you try to set parent as self', (done) => {
			const updateData = {};
			updateData[cid] = {
				parentCid: cid,
			};
			socketCategories.update({ uid: adminUid }, updateData, (err) => {
				assert.equal(err.message, '[[error:cant-set-self-as-parent]]');
				done();
			});
		});

		it('should error if you try to set child as parent', (done) => {
			let child1Cid;
			let parentCid;
			async.waterfall([
				function (next) {
					Categories.create({ name: 'parent 1', description: 'poor parent' }, next);
				},
				function (category, next) {
					parentCid = category.cid;
					Categories.create({ name: 'child1', description: 'wanna be parent', parentCid: parentCid }, next);
				},
				function (category, next) {
					child1Cid = category.cid;
					const updateData = {};
					updateData[parentCid] = {
						parentCid: child1Cid,
					};
					socketCategories.update({ uid: adminUid }, updateData, (err) => {
						assert.equal(err.message, '[[error:cant-set-child-as-parent]]');
						next();
					});
				},
			], done);
		});

		it('should update category data', (done) => {
			const updateData = {};
			updateData[cid] = {
				name: 'new name',
				description: 'new description',
				parentCid: 0,
				order: 3,
				icon: 'fa-hammer',
			};
			socketCategories.update({ uid: adminUid }, updateData, (err) => {
				assert.ifError(err);
				Categories.getCategoryData(cid, (err, data) => {
					assert.ifError(err);
					assert.equal(data.name, updateData[cid].name);
					assert.equal(data.description, updateData[cid].description);
					assert.equal(data.parentCid, updateData[cid].parentCid);
					assert.equal(data.order, updateData[cid].order);
					assert.equal(data.icon, updateData[cid].icon);
					done();
				});
			});
		});

		it('should purge category', (done) => {
			Categories.create({
				name: 'purge me',
				description: 'update description',
			}, (err, category) => {
				assert.ifError(err);
				Topics.post({
					uid: posterUid,
					cid: category.cid,
					title: 'Test Topic Title',
					content: 'The content of test topic',
				}, (err) => {
					assert.ifError(err);
					socketCategories.purge({ uid: adminUid }, category.cid, (err) => {
						assert.ifError(err);
						done();
					});
				});
			});
		});

		it('should get all categories', (done) => {
			socketCategories.getAll({ uid: adminUid }, {}, (err, data) => {
				assert.ifError(err);
				assert(data);
				done();
			});
		});

		it('should get all category names', (done) => {
			socketCategories.getNames({ uid: adminUid }, {}, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it('should give privilege', (done) => {
			socketCategories.setPrivilege({ uid: adminUid }, { cid: categoryObj.cid, privilege: ['groups:topics:delete'], set: true, member: 'registered-users' }, (err) => {
				assert.ifError(err);
				privileges.categories.can('topics:delete', categoryObj.cid, posterUid, (err, canDeleteTopcis) => {
					assert.ifError(err);
					assert(canDeleteTopcis);
					done();
				});
			});
		});

		it('should remove privilege', (done) => {
			socketCategories.setPrivilege({ uid: adminUid }, { cid: categoryObj.cid, privilege: 'groups:topics:delete', set: false, member: 'registered-users' }, (err) => {
				assert.ifError(err);
				privileges.categories.can('topics:delete', categoryObj.cid, posterUid, (err, canDeleteTopcis) => {
					assert.ifError(err);
					assert(!canDeleteTopcis);
					done();
				});
			});
		});

		it('should get privilege settings', (done) => {
			socketCategories.getPrivilegeSettings({ uid: adminUid }, categoryObj.cid, (err, data) => {
				assert.ifError(err);
				assert(data);
				done();
			});
		});

		it('should copy privileges to children', (done) => {
			let parentCid;
			let child1Cid;
			let child2Cid;
			async.waterfall([
				function (next) {
					Categories.create({ name: 'parent' }, next);
				},
				function (category, next) {
					parentCid = category.cid;
					Categories.create({ name: 'child1', parentCid: parentCid }, next);
				},
				function (category, next) {
					child1Cid = category.cid;
					Categories.create({ name: 'child2', parentCid: child1Cid }, next);
				},
				function (category, next) {
					child2Cid = category.cid;
					socketCategories.setPrivilege({ uid: adminUid }, { cid: parentCid, privilege: 'groups:topics:delete', set: true, member: 'registered-users' }, next);
				},
				function (next) {
					socketCategories.copyPrivilegesToChildren({ uid: adminUid }, { cid: parentCid, group: '' }, next);
				},
				function (next) {
					privileges.categories.can('topics:delete', child2Cid, posterUid, next);
				},
				function (canDelete, next) {
					assert(canDelete);
					next();
				},
			], done);
		});

		it('should create category with settings from', (done) => {
			let child1Cid;
			let parentCid;
			async.waterfall([
				function (next) {
					Categories.create({ name: 'copy from', description: 'copy me' }, next);
				},
				function (category, next) {
					parentCid = category.cid;
					Categories.create({ name: 'child1', description: 'will be gone', cloneFromCid: parentCid }, next);
				},
				function (category, next) {
					child1Cid = category.cid;
					assert.equal(category.description, 'copy me');
					next();
				},
			], done);
		});

		it('should copy settings from', (done) => {
			let child1Cid;
			let parentCid;
			async.waterfall([
				function (next) {
					Categories.create({ name: 'parent', description: 'copy me' }, next);
				},
				function (category, next) {
					parentCid = category.cid;
					Categories.create({ name: 'child1' }, next);
				},
				function (category, next) {
					child1Cid = category.cid;
					socketCategories.copySettingsFrom(
						{ uid: adminUid },
						{ fromCid: parentCid, toCid: child1Cid, copyParent: true },
						next
					);
				},
				function (destinationCategory, next) {
					Categories.getCategoryField(child1Cid, 'description', next);
				},
				function (description, next) {
					assert.equal(description, 'copy me');
					next();
				},
			], done);
		});

		it('should copy privileges from another category', (done) => {
			let child1Cid;
			let parentCid;
			async.waterfall([
				function (next) {
					Categories.create({ name: 'parent', description: 'copy me' }, next);
				},
				function (category, next) {
					parentCid = category.cid;
					Categories.create({ name: 'child1' }, next);
				},
				function (category, next) {
					child1Cid = category.cid;
					socketCategories.setPrivilege({ uid: adminUid }, { cid: parentCid, privilege: 'groups:topics:delete', set: true, member: 'registered-users' }, next);
				},
				function (next) {
					socketCategories.copyPrivilegesFrom({ uid: adminUid }, { fromCid: parentCid, toCid: child1Cid }, next);
				},
				function (next) {
					privileges.categories.can('topics:delete', child1Cid, posterUid, next);
				},
				function (canDelete, next) {
					assert(canDelete);
					next();
				},
			], done);
		});

		it('should copy privileges from another category for a single group', (done) => {
			let child1Cid;
			let parentCid;
			async.waterfall([
				function (next) {
					Categories.create({ name: 'parent', description: 'copy me' }, next);
				},
				function (category, next) {
					parentCid = category.cid;
					Categories.create({ name: 'child1' }, next);
				},
				function (category, next) {
					child1Cid = category.cid;
					socketCategories.setPrivilege({ uid: adminUid }, { cid: parentCid, privilege: 'groups:topics:delete', set: true, member: 'registered-users' }, next);
				},
				function (next) {
					socketCategories.copyPrivilegesFrom({ uid: adminUid }, { fromCid: parentCid, toCid: child1Cid, group: 'registered-users' }, next);
				},
				function (next) {
					privileges.categories.can('topics:delete', child1Cid, 0, next);
				},
				function (canDelete, next) {
					assert(!canDelete);
					next();
				},
			], done);
		});
	});

	it('should get active users', (done) => {
		Categories.create({
			name: 'test',
		}, (err, category) => {
			assert.ifError(err);
			Topics.post({
				uid: posterUid,
				cid: category.cid,
				title: 'Test Topic Title',
				content: 'The content of test topic',
			}, (err) => {
				assert.ifError(err);
				Categories.getActiveUsers(category.cid, (err, uids) => {
					assert.ifError(err);
					assert.equal(uids[0], posterUid);
					done();
				});
			});
		});
	});

	describe('tag whitelist', () => {
		let cid;
		const socketTopics = require('../src/socket.io/topics');
		before((done) => {
			Categories.create({
				name: 'test',
			}, (err, category) => {
				assert.ifError(err);
				cid = category.cid;
				done();
			});
		});

		it('should error if data is invalid', (done) => {
			socketTopics.isTagAllowed({ uid: posterUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should return true if category whitelist is empty', (done) => {
			socketTopics.isTagAllowed({ uid: posterUid }, { tag: 'notallowed', cid: cid }, (err, allowed) => {
				assert.ifError(err);
				assert(allowed);
				done();
			});
		});

		it('should add tags to category whitelist', (done) => {
			const data = {};
			data[cid] = {
				tagWhitelist: 'nodebb,jquery,javascript',
			};
			Categories.update(data, (err) => {
				assert.ifError(err);
				db.getSortedSetRange(`cid:${cid}:tag:whitelist`, 0, -1, (err, tagWhitelist) => {
					assert.ifError(err);
					assert.deepEqual(['nodebb', 'jquery', 'javascript'], tagWhitelist);
					done();
				});
			});
		});

		it('should return false if category whitelist does not have tag', (done) => {
			socketTopics.isTagAllowed({ uid: posterUid }, { tag: 'notallowed', cid: cid }, (err, allowed) => {
				assert.ifError(err);
				assert(!allowed);
				done();
			});
		});

		it('should return true if category whitelist has tag', (done) => {
			socketTopics.isTagAllowed({ uid: posterUid }, { tag: 'nodebb', cid: cid }, (err, allowed) => {
				assert.ifError(err);
				assert(allowed);
				done();
			});
		});

		it('should post a topic with only allowed tags', (done) => {
			Topics.post({
				uid: posterUid,
				cid: cid,
				title: 'Test Topic Title',
				content: 'The content of test topic',
				tags: ['nodebb', 'jquery', 'notallowed'],
			}, (err, data) => {
				assert.ifError(err);
				assert.equal(data.topicData.tags.length, 2);
				done();
			});
		});
	});


	describe('privileges', () => {
		const privileges = require('../src/privileges');

		it('should return empty array if uids is empty array', (done) => {
			privileges.categories.filterUids('find', categoryObj.cid, [], (err, uids) => {
				assert.ifError(err);
				assert.equal(uids.length, 0);
				done();
			});
		});

		it('should filter uids by privilege', (done) => {
			privileges.categories.filterUids('find', categoryObj.cid, [1, 2, 3, 4], (err, uids) => {
				assert.ifError(err);
				assert.deepEqual(uids, [1, 2]);
				done();
			});
		});

		it('should load category user privileges', (done) => {
			privileges.categories.userPrivileges(categoryObj.cid, 1, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, {
					find: false,
					'posts:delete': false,
					read: false,
					'topics:reply': false,
					'topics:read': false,
					'topics:create': false,
					'topics:tag': false,
					'topics:delete': false,
					'posts:edit': false,
					'posts:history': false,
					'posts:upvote': false,
					'posts:downvote': false,
					purge: false,
					'posts:view_deleted': false,
					moderate: false,
				});

				done();
			});
		});

		it('should load global user privileges', (done) => {
			privileges.global.userPrivileges(1, (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, {
					ban: false,
					invite: false,
					chat: false,
					'search:content': false,
					'search:users': false,
					'search:tags': false,
					'view:users:info': false,
					'upload:post:image': false,
					'upload:post:file': false,
					signature: false,
					'local:login': false,
					'group:create': false,
					'view:users': false,
					'view:tags': false,
					'view:groups': false,
				});

				done();
			});
		});

		it('should load category group privileges', (done) => {
			privileges.categories.groupPrivileges(categoryObj.cid, 'registered-users', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, {
					'groups:find': true,
					'groups:posts:edit': true,
					'groups:posts:history': true,
					'groups:posts:upvote': true,
					'groups:posts:downvote': true,
					'groups:topics:delete': false,
					'groups:topics:create': true,
					'groups:topics:reply': true,
					'groups:topics:tag': true,
					'groups:posts:delete': true,
					'groups:read': true,
					'groups:topics:read': true,
					'groups:purge': false,
					'groups:posts:view_deleted': false,
					'groups:moderate': false,
				});

				done();
			});
		});

		it('should load global group privileges', (done) => {
			privileges.global.groupPrivileges('registered-users', (err, data) => {
				assert.ifError(err);
				assert.deepEqual(data, {
					'groups:ban': false,
					'groups:invite': false,
					'groups:chat': true,
					'groups:search:content': true,
					'groups:search:users': true,
					'groups:search:tags': true,
					'groups:view:users': true,
					'groups:view:users:info': false,
					'groups:view:tags': true,
					'groups:view:groups': true,
					'groups:upload:post:image': true,
					'groups:upload:post:file': false,
					'groups:signature': true,
					'groups:local:login': true,
					'groups:group:create': false,
				});

				done();
			});
		});

		it('should return false if cid is falsy', (done) => {
			privileges.categories.isUserAllowedTo('find', null, adminUid, (err, isAllowed) => {
				assert.ifError(err);
				assert.equal(isAllowed, false);
				done();
			});
		});

		describe('Categories.getModeratorUids', () => {
			before((done) => {
				async.series([
					async.apply(groups.create, { name: 'testGroup' }),
					async.apply(groups.join, 'cid:1:privileges:groups:moderate', 'testGroup'),
					async.apply(groups.join, 'testGroup', 1),
				], done);
			});

			it('should retrieve all users with moderator bit in category privilege', (done) => {
				Categories.getModeratorUids([1, 2], (err, uids) => {
					assert.ifError(err);
					assert.strictEqual(uids.length, 2);
					assert(uids[0].includes('1'));
					assert.strictEqual(uids[1].length, 0);
					done();
				});
			});

			it('should not fail when there are multiple groups', (done) => {
				async.series([
					async.apply(groups.create, { name: 'testGroup2' }),
					async.apply(groups.join, 'cid:1:privileges:groups:moderate', 'testGroup2'),
					async.apply(groups.join, 'testGroup2', 1),
					function (next) {
						Categories.getModeratorUids([1, 2], (err, uids) => {
							assert.ifError(err);
							assert(uids[0].includes('1'));
							next();
						});
					},
				], done);
			});

			after((done) => {
				async.series([
					async.apply(groups.leave, 'cid:1:privileges:groups:moderate', 'testGroup'),
					async.apply(groups.leave, 'cid:1:privileges:groups:moderate', 'testGroup2'),
					async.apply(groups.destroy, 'testGroup'),
					async.apply(groups.destroy, 'testGroup2'),
				], done);
			});
		});
	});


	describe('getTopicIds', () => {
		const plugins = require('../src/plugins');
		it('should get topic ids with filter', (done) => {
			function method(data, callback) {
				data.tids = [1, 2, 3];
				callback(null, data);
			}

			plugins.hooks.register('my-test-plugin', {
				hook: 'filter:categories.getTopicIds',
				method: method,
			});

			Categories.getTopicIds({
				cid: categoryObj.cid,
				start: 0,
				stop: 19,
			}, (err, tids) => {
				assert.ifError(err);
				assert.deepEqual(tids, [1, 2, 3]);
				plugins.hooks.unregister('my-test-plugin', 'filter:categories.getTopicIds', method);
				done();
			});
		});
	});

	it('should return nested children categories', async () => {
		const rootCategory = await Categories.create({ name: 'root' });
		const child1 = await Categories.create({ name: 'child1', parentCid: rootCategory.cid });
		const child2 = await Categories.create({ name: 'child2', parentCid: child1.cid });
		const data = await Categories.getCategoryById({
			uid: 1,
			cid: rootCategory.cid,
			start: 0,
			stop: 19,
		});
'use strict';


const assert = require('assert');
const search = require('../src/admin/search');

describe('admin search', () => {
	describe('filterDirectories', () => {
		it('should resolve all paths to relative paths', (done) => {
			assert.deepEqual(search.filterDirectories([
				'hfjksfd/fdsgagag/admin/gdhgfsdg/sggag.tpl',
			]), [
				'admin/gdhgfsdg/sggag',
			]);
			done();
		});
		it('should exclude .js files', (done) => {
			assert.deepEqual(search.filterDirectories([
				'hfjksfd/fdsgagag/admin/gdhgfsdg/sggag.tpl',
				'dfahdfsgf/admin/hgkfds/fdhsdfh.js',
			]), [
				'admin/gdhgfsdg/sggag',
			]);
			done();
		});
		it('should exclude partials', (done) => {
			assert.deepEqual(search.filterDirectories([
				'hfjksfd/fdsgagag/admin/gdhgfsdg/sggag.tpl',
				'dfahdfsgf/admin/partials/hgkfds/fdhsdfh.tpl',
			]), [
				'admin/gdhgfsdg/sggag',
			]);
			done();
		});
		it('should exclude files in the admin directory', (done) => {
			assert.deepEqual(search.filterDirectories([
				'hfjksfd/fdsgagag/admin/gdhgfsdg/sggag.tpl',
				'dfdasg/admin/hjkdfsk.tpl',
			]), [
				'admin/gdhgfsdg/sggag',
			]);
			done();
		});
	});

	describe('sanitize', () => {
		it('should strip out scripts', (done) => {
			assert.equal(
				search.sanitize('Pellentesque tristique senectus' +
					'<script>alert("nope");</script> habitant morbi'),
				'Pellentesque tristique senectus' +
					' habitant morbi'
			);
			done();
		});
		it('should remove all tags', (done) => {
			assert.equal(
				search.sanitize('<p>Pellentesque <b>habitant morbi</b> tristique senectus' +
					'Aenean <i>vitae</i> est.Mauris <a href="placerat">eleifend</a> leo.</p>'),
				'Pellentesque habitant morbi tristique senectus' +
					'Aenean vitae est.Mauris eleifend leo.'
			);
			done();
		});
	});

	describe('simplify', () => {
		it('should remove all mustaches', (done) => {
			assert.equal(
				search.simplify('Pellentesque tristique {{senectus}}habitant morbi' +
					'liquam tincidunt {mauris.eu}risus'),
				'Pellentesque tristique habitant morbi' +
					'liquam tincidunt risus'
			);
			done();
		});
		it('should collapse all whitespace', (done) => {
			assert.equal(
				search.simplify('Pellentesque tristique   habitant morbi' +
					'  \n\n    liquam tincidunt mauris eu risus.'),
				'Pellentesque tristique habitant morbi' +
					'\nliquam tincidunt mauris eu risus.'
			);
			done();
		});
'use strict';

const async = require('async');
const	assert = require('assert');
const nconf = require('nconf');
const request = require('request');

const db = require('./mocks/databasemock');
const categories = require('../src/categories');
const topics = require('../src/topics');
const user = require('../src/user');
const groups = require('../src/groups');
const helpers = require('./helpers');
const meta = require('../src/meta');

describe('Admin Controllers', () => {
	let tid;
	let cid;
	let pid;
	let regularPid;
	let adminUid;
	let regularUid;
	let regular2Uid;
	let moderatorUid;
	let jar;

	before((done) => {
		async.series({
			category: function (next) {
				categories.create({
					name: 'Test Category',
					description: 'Test category created by testing script',
				}, next);
			},
			adminUid: function (next) {
				user.create({ username: 'admin', password: 'barbar' }, next);
			},
			regularUid: function (next) {
				user.create({ username: 'regular' }, next);
			},
			regular2Uid: function (next) {
				user.create({ username: 'regular2' }, next);
			},
			moderatorUid: function (next) {
				user.create({ username: 'moderator', password: 'modmod' }, next);
			},
		}, async (err, results) => {
			if (err) {
				return done(err);
			}
			adminUid = results.adminUid;
			regularUid = results.regularUid;
			regular2Uid = results.regular2Uid;
			moderatorUid = results.moderatorUid;
			cid = results.category.cid;

			const adminPost = await topics.post({ uid: adminUid, title: 'test topic title', content: 'test topic content', cid: results.category.cid });
			assert.ifError(err);
			tid = adminPost.topicData.tid;
			pid = adminPost.postData.pid;

			const regularPost = await topics.post({ uid: regular2Uid, title: 'regular user\'s test topic title', content: 'test topic content', cid: results.category.cid });
			regularPid = regularPost.postData.pid;
			done();
		});
	});

	it('should 403 if user is not admin', (done) => {
		helpers.loginUser('admin', 'barbar', (err, _jar) => {
			assert.ifError(err);
			jar = _jar;
			request(`${nconf.get('url')}/admin`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 403);
				assert(body);
				done();
			});
		});
	});

	it('should load admin dashboard', (done) => {
		groups.join('administrators', adminUid, (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/admin`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});
	});

	it('should load groups page', (done) => {
		request(`${nconf.get('url')}/admin/manage/groups`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load groups detail page', (done) => {
		request(`${nconf.get('url')}/admin/manage/groups/administrators`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load global privileges page', (done) => {
		request(`${nconf.get('url')}/admin/manage/privileges`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load privileges page for category 1', (done) => {
		request(`${nconf.get('url')}/admin/manage/privileges/1`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load manage uploads', (done) => {
		request(`${nconf.get('url')}/admin/manage/uploads`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load general settings page', (done) => {
		request(`${nconf.get('url')}/admin/settings`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load email settings page', (done) => {
		request(`${nconf.get('url')}/admin/settings/email`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load user settings page', (done) => {
		request(`${nconf.get('url')}/admin/settings/user`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load info page for a user', (done) => {
		request(`${nconf.get('url')}/api/user/regular/info`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body.history);
			assert(Array.isArray(body.history.flags));
			assert(Array.isArray(body.history.bans));
			assert(Array.isArray(body.sessions));
			done();
		});
	});

	it('should 404 for edit/email page if user does not exist', (done) => {
		request(`${nconf.get('url')}/api/user/doesnotexist/edit/email`, { jar: jar, json: true }, (err, res) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			done();
		});
	});

	it('should load /admin/settings/homepage', (done) => {
		request(`${nconf.get('url')}/api/admin/settings/homepage`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body.routes);
			done();
		});
	});

	it('should load /admin/advanced/database', (done) => {
		request(`${nconf.get('url')}/api/admin/advanced/database`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);

			if (nconf.get('redis')) {
				assert(body.redis);
			} else if (nconf.get('mongo')) {
				assert(body.mongo);
			} else if (nconf.get('postgres')) {
				assert(body.postgres);
			}
			done();
		});
	});

	it('should load /admin/extend/plugins', (done) => {
		request(`${nconf.get('url')}/api/admin/extend/plugins`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert(body.hasOwnProperty('installed'));
			assert(body.hasOwnProperty('upgradeCount'));
			assert(body.hasOwnProperty('download'));
			assert(body.hasOwnProperty('incompatible'));
			done();
		});
	});

	it('should load /admin/manage/users', (done) => {
		request(`${nconf.get('url')}/api/admin/manage/users`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/manage/registration', (done) => {
		request(`${nconf.get('url')}/api/admin/manage/registration`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should 404 if users is not privileged', (done) => {
		request(`${nconf.get('url')}/api/registration-queue`, { json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 404);
			assert(body);
			done();
		});
	});

	it('should load /api/registration-queue', (done) => {
		request(`${nconf.get('url')}/api/registration-queue`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/manage/admins-mods', (done) => {
		request(`${nconf.get('url')}/api/admin/manage/admins-mods`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/users/csv', (done) => {
		const socketAdmin = require('../src/socket.io/admin');
		socketAdmin.user.exportUsersCSV({ uid: adminUid }, {}, (err) => {
			assert.ifError(err);
			setTimeout(() => {
				request(`${nconf.get('url')}/api/admin/users/csv`, {
					jar: jar,
					headers: {
						referer: `${nconf.get('url')}/admin/manage/users`,
					},
				}, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			}, 2000);
		});
	});

	it('should return 403 if no referer', (done) => {
		request(`${nconf.get('url')}/api/admin/groups/administrators/csv`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 403);
			assert.equal(body, '[[error:invalid-origin]]');
			done();
		});
	});

	it('should return 403 if referer is not /api/admin/groups/administrators/csv', (done) => {
		request(`${nconf.get('url')}/api/admin/groups/administrators/csv`, {
			jar: jar,
			headers: {
				referer: '/topic/1/test',
			},
		}, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 403);
			assert.equal(body, '[[error:invalid-origin]]');
			done();
		});
	});

	it('should load /api/admin/groups/administrators/csv', (done) => {
		request(`${nconf.get('url')}/api/admin/groups/administrators/csv`, {
			jar: jar,
			headers: {
				referer: `${nconf.get('url')}/admin/manage/groups`,
			},
		}, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/advanced/hooks', (done) => {
		request(`${nconf.get('url')}/api/admin/advanced/hooks`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/advanced/cache', (done) => {
		request(`${nconf.get('url')}/api/admin/advanced/cache`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/advanced/errors', (done) => {
		request(`${nconf.get('url')}/api/admin/advanced/errors`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/advanced/errors/export', (done) => {
		meta.errors.clear((err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/api/admin/advanced/errors/export`, { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.strictEqual(body, '');
				done();
			});
		});
	});

	it('should load /admin/advanced/logs', (done) => {
		const fs = require('fs');
		fs.appendFile(meta.logs.path, 'dummy log', (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/api/admin/advanced/logs`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				done();
			});
		});
	});

	it('should load /admin/settings/navigation', (done) => {
		const navigation = require('../src/navigation/admin');
		const data = require('../install/data/navigation.json');

		navigation.save(data, (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/api/admin/settings/navigation`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert(body);
				assert(body.available);
				assert(body.enabled);
				done();
			});
		});
	});

	it('should load /admin/development/info', (done) => {
		request(`${nconf.get('url')}/api/admin/development/info`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/development/logger', (done) => {
		request(`${nconf.get('url')}/api/admin/development/logger`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/advanced/events', (done) => {
		request(`${nconf.get('url')}/api/admin/advanced/events`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/manage/categories', (done) => {
		request(`${nconf.get('url')}/api/admin/manage/categories`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/manage/categories/1', (done) => {
		request(`${nconf.get('url')}/api/admin/manage/categories/1`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/manage/categories/1/analytics', (done) => {
		request(`${nconf.get('url')}/api/admin/manage/categories/1/analytics`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/extend/rewards', (done) => {
		request(`${nconf.get('url')}/api/admin/extend/rewards`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/extend/widgets', (done) => {
		request(`${nconf.get('url')}/api/admin/extend/widgets`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/settings/languages', (done) => {
		request(`${nconf.get('url')}/api/admin/settings/languages`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/settings/social', (done) => {
		const socketAdmin = require('../src/socket.io/admin');
		socketAdmin.social.savePostSharingNetworks({ uid: adminUid }, ['facebook', 'twitter'], (err) => {
			assert.ifError(err);
			request(`${nconf.get('url')}/api/admin/settings/social`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert(body);
				body = body.posts.map(network => network && network.id);
				assert(body.includes('facebook'));
				assert(body.includes('twitter'));
				done();
			});
		});
	});

	it('should load /admin/manage/tags', (done) => {
		request(`${nconf.get('url')}/api/admin/manage/tags`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('/post-queue should 404 for regular user', (done) => {
		request(`${nconf.get('url')}/api/post-queue`, { json: true }, (err, res, body) => {
			assert.ifError(err);
			assert(body);
			assert.equal(res.statusCode, 404);
			done();
		});
	});

	it('should load /post-queue', (done) => {
		request(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('/ip-blacklist should 404 for regular user', (done) => {
		request(`${nconf.get('url')}/api/ip-blacklist`, { json: true }, (err, res, body) => {
			assert.ifError(err);
			assert(body);
			assert.equal(res.statusCode, 404);
			done();
		});
	});

	it('should load /ip-blacklist', (done) => {
		request(`${nconf.get('url')}/api/ip-blacklist`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/appearance/themes', (done) => {
		request(`${nconf.get('url')}/api/admin/appearance/themes`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /admin/appearance/customise', (done) => {
		request(`${nconf.get('url')}/api/admin/appearance/customise`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			done();
		});
	});

	it('should load /recent in maintenance mode', (done) => {
		meta.config.maintenanceMode = 1;
		request(`${nconf.get('url')}/api/recent`, { jar: jar, json: true }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			meta.config.maintenanceMode = 0;
			done();
		});
	});

	describe('mods page', () => {
		let moderatorJar;

		before((done) => {
			helpers.loginUser('moderator', 'modmod', (err, _jar) => {
				assert.ifError(err);
				moderatorJar = _jar;

				groups.join(`cid:${cid}:privileges:moderate`, moderatorUid, done);
			});
		});

		it('should error with no privileges', (done) => {
			request(`${nconf.get('url')}/api/flags`, { json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(body.error, '[[error:no-privileges]]');
				done();
			});
		});

		it('should load flags page data', (done) => {
			request(`${nconf.get('url')}/api/flags`, { jar: moderatorJar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert(body);
				assert(body.flags);
				assert(body.filters);
				assert.equal(body.filters.cid.indexOf(cid), -1);
				done();
			});
		});

		it('should return invalid data if flag does not exist', (done) => {
			request(`${nconf.get('url')}/api/flags/123123123`, { jar: moderatorJar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(body.error, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error when you attempt to flag a privileged user\'s post', async () => {
			const socketFlags = require('../src/socket.io/flags');
			const oldValue = meta.config['min:rep:flag'];
			try {
				await socketFlags.create({ uid: regularUid }, { id: pid, type: 'post', reason: 'spam' });
			} catch (err) {
				assert.strictEqual(err.message, '[[error:cant-flag-privileged]]');
			}
		});

		it('should error with not enough reputation to flag', (done) => {
			const socketFlags = require('../src/socket.io/flags');
			const oldValue = meta.config['min:rep:flag'];
			meta.config['min:rep:flag'] = 1000;
			socketFlags.create({ uid: regularUid }, { id: regularPid, type: 'post', reason: 'spam' }, (err) => {
				assert.strictEqual(err.message, '[[error:not-enough-reputation-to-flag]]');
				meta.config['min:rep:flag'] = oldValue;
				done();
			});
		});

		it('should return flag details', (done) => {
			const socketFlags = require('../src/socket.io/flags');
			const oldValue = meta.config['min:rep:flag'];
			meta.config['min:rep:flag'] = 0;
			socketFlags.create({ uid: regularUid }, { id: regularPid, type: 'post', reason: 'spam' }, (err, flagId) => {
				meta.config['min:rep:flag'] = oldValue;
				assert.ifError(err);
				request(`${nconf.get('url')}/api/flags/${flagId}`, { jar: moderatorJar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert(body);
					assert(body.reports);
					assert(Array.isArray(body.reports));
					assert.strictEqual(body.reports[0].reporter.username, 'regular');
					done();
				});
			});
		});
	});

	it('should escape special characters in config', (done) => {
		const plugins = require('../src/plugins');
		function onConfigGet(config, callback) {
			config.someValue = '"foo"';
			config.otherValue = "'123'";
			config.script = '</script>';
			callback(null, config);
		}
		plugins.hooks.register('somePlugin', { hook: 'filter:config.get', method: onConfigGet });
		request(`${nconf.get('url')}/admin`, { jar: jar }, (err, res, body) => {
			assert.ifError(err);
			assert.equal(res.statusCode, 200);
			assert(body);
			assert(body.includes('"someValue":"\\\\"foo\\\\""'));
			assert(body.includes('"otherValue":"\\\'123\\\'"'));
			assert(body.includes('"script":"<\\/script>"'));
			request(nconf.get('url'), { jar: jar }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body);
				assert(body.includes('"someValue":"\\\\"foo\\\\""'));
				assert(body.includes('"otherValue":"\\\'123\\\'"'));
				assert(body.includes('"script":"<\\/script>"'));
				plugins.hooks.unregister('somePlugin', 'filter:config.get', onConfigGet);
				done();
			});
'use strict';

const path = require('path');
const fs = require('fs');
const db = require('./mocks/databasemock');

const installedPlugins = fs.readdirSync(path.join(__dirname, '../node_modules'))
	.filter(p => p.startsWith('nodebb-'));

describe('Installed Plugins', () => {
	installedPlugins.forEach((plugin) => {
		const pathToTests = path.join(__dirname, '../node_modules', plugin, 'test');
		try {
			require(pathToTests);
		} catch (err) {
			if (err.code !== 'MODULE_NOT_FOUND') {
				console.log(err.stack);
			}
		}
	});
'use strict';


const assert = require('assert');
const { JSDOM } = require('jsdom');
const utils = require('../public/src/utils.js');
const slugify = require('../src/slugify');
const db = require('./mocks/databasemock');

describe('Utility Methods', () => {
	// https://gist.github.com/robballou/9ee108758dc5e0e2d028
	// create some jsdom magic to allow jQuery to work
	const dom = new JSDOM('<html><body></body></html>');
	const { window } = dom;
	global.window = window;
	global.jQuery = require('jquery');
	global.$ = global.jQuery;
	const { $ } = global;
	require('jquery-deserialize');
	require('jquery-serializeobject');

	it('should serialize/deserialize form data properly', () => {
		const formSerialize = $(`
			<form id="form-serialize">
				<input name="a" value="1">
				<input name="a" value="2">
				<input name="bar" value="test">
				<input name="check1" type="checkbox" checked>
				<input name="check2" type="checkbox">
			</form>
		`);
		const sampleData = {
			a: ['1', '2'],
			bar: 'test',
			check1: 'on',
		};
		const data = formSerialize.serializeObject();
		assert.deepStrictEqual(data, sampleData);

		const formDeserialize = $(`
			<form>
				<input id="input1" name="a"/>
				<input id="input2" name="a"/>
				<input id="input3" name="bar"/>
				<input id="input4" name="check1" type="checkbox">
				<input id="input5" name="check2" type="checkbox">
			</form>
		`);

		formDeserialize.deserialize(sampleData);
		assert.strictEqual(formDeserialize.find('#input1').val(), sampleData.a[0]);
		assert.strictEqual(formDeserialize.find('#input2').val(), sampleData.a[1]);
		assert.strictEqual(formDeserialize.find('#input3').val(), sampleData.bar);
		assert.strictEqual(formDeserialize.find('#input4').prop('checked'), true);
		assert.strictEqual(formDeserialize.find('#input5').prop('checked'), false);
	});

	// https://github.com/jprichardson/string.js/blob/master/test/string.test.js
	it('should decode HTML entities', (done) => {
		assert.strictEqual(
			utils.decodeHTMLEntities('Ken Thompson &amp; Dennis Ritchie'),
			'Ken Thompson & Dennis Ritchie'
		);
		assert.strictEqual(
			utils.decodeHTMLEntities('3 &lt; 4'),
			'3 < 4'
		);
		assert.strictEqual(
			utils.decodeHTMLEntities('http:&#47;&#47;'),
			'http://'
		);
		done();
	});
	it('should strip HTML tags', (done) => {
		assert.strictEqual(utils.stripHTMLTags('<p>just <b>some</b> text</p>'), 'just some text');
		assert.strictEqual(utils.stripHTMLTags('<p>just <b>some</b> text</p>', ['p']), 'just <b>some</b> text');
		assert.strictEqual(utils.stripHTMLTags('<i>just</i> some <image/> text', ['i']), 'just some <image/> text');
		assert.strictEqual(utils.stripHTMLTags('<i>just</i> some <image/> <div>text</div>', ['i', 'div']), 'just some <image/> text');
		done();
	});

	it('should preserve case if requested', (done) => {
		assert.strictEqual(slugify('UPPER CASE', true), 'UPPER-CASE');
		done();
	});

	it('should work if a number is passed in', (done) => {
		assert.strictEqual(slugify(12345), '12345');
		done();
	});

	describe('username validation', () => {
		it('accepts latin-1 characters', () => {
			const username = "John\"'-. Doeäâèéë1234";
			assert(utils.isUserNameValid(username), 'invalid username');
		});

		it('rejects empty string', () => {
			const username = '';
			assert.equal(utils.isUserNameValid(username), false, 'accepted as valid username');
		});

		it('should reject new lines', () => {
			assert.equal(utils.isUserNameValid('myusername\r\n'), false);
		});

		it('should reject new lines', () => {
			assert.equal(utils.isUserNameValid('myusername\n'), false);
		});

		it('should reject tabs', () => {
			assert.equal(utils.isUserNameValid('myusername\t'), false);
		});

		it('accepts square brackets', () => {
			const username = '[best clan] julian';
			assert(utils.isUserNameValid(username), 'invalid username');
		});

		it('accepts regular username', () => {
			assert(utils.isUserNameValid('myusername'), 'invalid username');
		});

		it('accepts quotes', () => {
			assert(utils.isUserNameValid('baris "the best" usakli'), 'invalid username');
		});
	});

	describe('email validation', () => {
		it('accepts sample address', () => {
			const email = 'sample@example.com';
			assert(utils.isEmailValid(email), 'invalid email');
		});
		it('rejects empty address', () => {
			const email = '';
			assert.equal(utils.isEmailValid(email), false, 'accepted as valid email');
		});
	});

	describe('UUID generation', () => {
		it('return unique random value every time', () => {
			const uuid1 = utils.generateUUID();
			const uuid2 = utils.generateUUID();
			assert.notEqual(uuid1, uuid2, 'matches');
		});
	});

	describe('cleanUpTag', () => {
		it('should cleanUp a tag', (done) => {
			const cleanedTag = utils.cleanUpTag(',/#!$%^*;TaG1:{}=_`<>\'"~()?|');
			assert.equal(cleanedTag, 'tag1');
			done();
		});

		it('should return empty string for invalid tags', (done) => {
			assert.strictEqual(utils.cleanUpTag(undefined), '');
			assert.strictEqual(utils.cleanUpTag(null), '');
			assert.strictEqual(utils.cleanUpTag(false), '');
			assert.strictEqual(utils.cleanUpTag(1), '');
			assert.strictEqual(utils.cleanUpTag(0), '');
			done();
		});
	});

	it('should remove punctuation', (done) => {
		const removed = utils.removePunctuation('some text with , ! punctuation inside "');
		assert.equal(removed, 'some text with   punctuation inside ');
		done();
	});

	it('should return true if string has language key', (done) => {
		assert.equal(utils.hasLanguageKey('some text [[topic:title]] and [[user:reputaiton]]'), true);
		done();
	});

	it('should return false if string does not have language key', (done) => {
		assert.equal(utils.hasLanguageKey('some text with no language keys'), false);
		done();
	});

	it('should shallow merge two objects', (done) => {
		const a = { foo: 1, cat1: 'ginger' };
		const b = { baz: 2, cat2: 'phoebe' };
		const obj = utils.merge(a, b);
		assert.strictEqual(obj.foo, 1);
		assert.strictEqual(obj.baz, 2);
		assert.strictEqual(obj.cat1, 'ginger');
		assert.strictEqual(obj.cat2, 'phoebe');
		done();
	});

	it('should return the file extesion', (done) => {
		assert.equal(utils.fileExtension('/path/to/some/file.png'), 'png');
		done();
	});

	it('should return file mime type', (done) => {
		assert.equal(utils.fileMimeType('/path/to/some/file.png'), 'image/png');
		done();
	});

	it('should check if url is relative', (done) => {
		assert.equal(utils.isRelativeUrl('/topic/1/slug'), true);
		done();
	});

	it('should check if url is relative', (done) => {
		assert.equal(utils.isRelativeUrl('https://nodebb.org'), false);
		done();
	});

	it('should make number human readable', (done) => {
		assert.equal(utils.makeNumberHumanReadable('1000'), '1.0k');
		done();
	});

	it('should make number human readable', (done) => {
		assert.equal(utils.makeNumberHumanReadable('1100000'), '1.1m');
		done();
	});

	it('should make number human readable', (done) => {
		assert.equal(utils.makeNumberHumanReadable('100'), '100');
		done();
	});

	it('should make number human readable', (done) => {
		assert.equal(utils.makeNumberHumanReadable(null), null);
		done();
	});

	it('should make numbers human readable on elements', (done) => {
		const el = $('<div title="100000"></div>');
		utils.makeNumbersHumanReadable(el);
		assert.equal(el.html(), '100.0k');
		done();
	});

	it('should add commas to numbers', (done) => {
		assert.equal(utils.addCommas('100'), '100');
		done();
	});

	it('should add commas to numbers', (done) => {
		assert.equal(utils.addCommas('1000'), '1,000');
		done();
	});

	it('should add commas to numbers', (done) => {
		assert.equal(utils.addCommas('1000000'), '1,000,000');
		done();
	});

	it('should add commas to elements', (done) => {
		const el = $('<div>1000000</div>');
		utils.addCommasToNumbers(el);
		assert.equal(el.html(), '1,000,000');
		done();
	});

	it('should return passed in value if invalid', (done) => {
		const bigInt = -111111111111111111;
		const result = utils.toISOString(bigInt);
		assert.equal(bigInt, result);
		done();
	});

	it('should return false if browser is not android', (done) => {
		global.navigator = {
			userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36',
		};
		assert.equal(utils.isAndroidBrowser(), false);
		done();
	});

	it('should return true if browser is android', (done) => {
		global.navigator = {
			userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Android /58.0.3029.96 Safari/537.36',
		};
		assert.equal(utils.isAndroidBrowser(), true);
		done();
	});

	it('should return false if not touch device', (done) => {
		global.document = global.document || {};
		global.document.documentElement = {};
		assert(!utils.isTouchDevice());
		done();
	});

	it('should return true if touch device', (done) => {
		global.document.documentElement = {
			ontouchstart: 1,
		};
		assert(utils.isTouchDevice());
		done();
	});

	it('should check if element is in viewport', (done) => {
		const el = $('<div>some text</div>');
		assert(utils.isElementInViewport(el));
		done();
	});

	it('should get empty object for url params', (done) => {
		global.document = window.document;
		const params = utils.params();
		assert.equal(Object.keys(params), 0);
		done();
	});

	it('should get url params', (done) => {
		const params = utils.params({ url: 'http://nodebb.org?foo=1&bar=test&herp=2' });
		assert.equal(params.foo, 1);
		assert.equal(params.bar, 'test');
		assert.equal(params.herp, 2);
		done();
	});

	it('should get a single param', (done) => {
		assert.equal(utils.param('somekey'), undefined);
		done();
	});


	describe('toType', () => {
		it('should return param as is if not string', (done) => {
			assert.equal(123, utils.toType(123));
			done();
		});

		it('should convert return string numbers as numbers', (done) => {
			assert.equal(123, utils.toType('123'));
			done();
		});

		it('should convert string "false" to boolean false', (done) => {
			assert.strictEqual(false, utils.toType('false'));
			done();
		});

		it('should convert string "true" to boolean true', (done) => {
			assert.strictEqual(true, utils.toType('true'));
			done();
		});

		it('should parse json', (done) => {
			const data = utils.toType('{"a":"1"}');
			assert.equal(data.a, '1');
			done();
		});

		it('should return string as is if its not json,true,false or number', (done) => {
			const regularStr = 'this is a regular string';
			assert.equal(regularStr, utils.toType(regularStr));
			done();
		});
	});

	describe('utils.props', () => {
		const data = {};

		it('should set nested data', (done) => {
			assert.equal(10, utils.props(data, 'a.b.c.d', 10));
			done();
		});

		it('should return nested object', (done) => {
			const obj = utils.props(data, 'a.b.c');
			assert.equal(obj.d, 10);
			done();
		});

		it('should returned undefined without throwing', (done) => {
			assert.equal(utils.props(data, 'a.b.c.foo.bar'), undefined);
			done();
		});

		it('should return undefined if second param is null', (done) => {
			assert.equal(utils.props(undefined, null), undefined);
			done();
		});
	});

	describe('isInternalURI', () => {
		const target = { host: '', protocol: 'https' };
		const reference = { host: '', protocol: 'https' };

		it('should return true if they match', (done) => {
			assert(utils.isInternalURI(target, reference, ''));
			done();
		});

		it('should return true if they match', (done) => {
			target.host = 'nodebb.org';
			reference.host = 'nodebb.org';
			assert(utils.isInternalURI(target, reference, ''));
			done();
		});

		it('should handle relative path', (done) => {
			target.pathname = '/forum';
			assert(utils.isInternalURI(target, reference, '/forum'));
			done();
		});

		it('should return false if they do not match', (done) => {
			target.pathname = '';
			reference.host = 'designcreateplay.com';
			assert(!utils.isInternalURI(target, reference));
			done();
		});
	});

	it('escape html', (done) => {
		const escaped = utils.escapeHTML('&<>');
		assert.equal(escaped, '&amp;&lt;&gt;');
		done();
	});

	it('should escape regex chars', (done) => {
		const escaped = utils.escapeRegexChars('some text {}');
		assert.equal(escaped, 'some\\ text\\ \\{\\}');
		done();
	});

	it('should get hours array', (done) => {
		const currentHour = new Date().getHours();
		const hours = utils.getHoursArray();
		let index = hours.length - 1;
		for (let i = currentHour, ii = currentHour - 24; i > ii; i -= 1) {
			const hour = i < 0 ? 24 + i : i;
			assert.equal(hours[index], `${hour}:00`);
			index -= 1;
		}
		done();
	});

	it('should get days array', (done) => {
		const currentDay = new Date(Date.now()).getTime();
		const days = utils.getDaysArray();
		const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
		let index = 0;
		for (let x = 29; x >= 0; x -= 1) {
			const tmpDate = new Date(currentDay - (1000 * 60 * 60 * 24 * x));
			assert.equal(`${months[tmpDate.getMonth()]} ${tmpDate.getDate()}`, days[index]);
			index += 1;
		}
		done();
	});

	it('`utils.rtrim` should remove trailing space', (done) => {
		assert.strictEqual(utils.rtrim('  thing   '), '  thing');
		assert.strictEqual(utils.rtrim('\tthing\t\t'), '\tthing');
		assert.strictEqual(utils.rtrim('\t thing \t'), '\t thing');
		done();
	});

	it('should profile function', (done) => {
		const st = process.hrtime();
		setTimeout(() => {
			process.profile('it took', st);
			done();
		}, 500);
	});

	it('should return object with data', async () => {
		const user = require('../src/user');
		const uid1 = await user.create({ username: 'promise1' });
		const uid2 = await user.create({ username: 'promise2' });
		const result = await utils.promiseParallel({
			user1: user.getUserData(uid1),
			user2: user.getUserData(uid2),
		});
		assert(result.hasOwnProperty('user1') && result.hasOwnProperty('user2'));
'use strict';

const assert = require('assert');
const async = require('async');
const request = require('request');
const nconf = require('nconf');
const util = require('util');

const sleep = util.promisify(setTimeout);

const db = require('./mocks/databasemock');
const meta = require('../src/meta');
const User = require('../src/user');
const Groups = require('../src/groups');
const Messaging = require('../src/messaging');
const helpers = require('./helpers');
const socketModules = require('../src/socket.io/modules');

describe('Messaging Library', () => {
	let fooUid;	// the admin
	let bazUid;	// the user with chat restriction enabled
	let herpUid;
	let roomId;

	before((done) => {
		// Create 3 users: 1 admin, 2 regular
		async.series([
			async.apply(User.create, { username: 'foo', password: 'barbar' }),	// admin
			async.apply(User.create, { username: 'baz', password: 'quuxquux' }),	// restricted user
			async.apply(User.create, { username: 'herp', password: 'derpderp' }),	// regular user
		], (err, uids) => {
			if (err) {
				return done(err);
			}

			fooUid = uids[0];
			bazUid = uids[1];
			herpUid = uids[2];

			async.parallel([
				async.apply(Groups.join, 'administrators', fooUid),
				async.apply(User.setSetting, bazUid, 'restrictChat', '1'),
			], done);
		});
	});

	describe('.canMessage()', () => {
		it('should allow messages to be sent to an unrestricted user', (done) => {
			Messaging.canMessageUser(bazUid, herpUid, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should NOT allow messages to be sent to a restricted user', (done) => {
			User.setSetting(bazUid, 'restrictChat', '1', (err) => {
				assert.ifError(err);
				Messaging.canMessageUser(herpUid, bazUid, (err) => {
					assert.strictEqual(err.message, '[[error:chat-restricted]]');
					socketModules.chats.addUserToRoom({ uid: herpUid }, { roomId: 1, username: 'baz' }, (err) => {
						assert.equal(err.message, '[[error:chat-restricted]]');
						done();
					});
				});
			});
		});

		it('should always allow admins through', (done) => {
			Messaging.canMessageUser(fooUid, bazUid, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should allow messages to be sent to a restricted user if restricted user follows sender', (done) => {
			User.follow(bazUid, herpUid, () => {
				Messaging.canMessageUser(herpUid, bazUid, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});
	});

	describe('rooms', () => {
		it('should fail to create a new chat room with invalid data', (done) => {
			socketModules.chats.newRoom({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should return rate limit error on second try', (done) => {
			const socketMock = { uid: fooUid };
			const oldValue = meta.config.chatMessageDelay;
			meta.config.chatMessageDelay = 1000;
			socketModules.chats.newRoom(socketMock, { touid: bazUid }, (err) => {
				assert.ifError(err);
				socketModules.chats.newRoom(socketMock, { touid: bazUid }, (err) => {
					assert.equal(err.message, '[[error:too-many-messages]]');
					meta.configs.chatMessageDelay = oldValue;
					done();
				});
			});
		});

		it('should create a new chat room', (done) => {
			socketModules.chats.newRoom({ uid: fooUid }, { touid: bazUid }, (err, _roomId) => {
				roomId = _roomId;
				assert.ifError(err);
				assert(roomId);
				socketModules.chats.canMessage({ uid: fooUid }, _roomId, (err) => {
					assert.ifError(err);
					done();
				});
			});
		});

		it('should send a user-join system message when a chat room is created', (done) => {
			socketModules.chats.getMessages({ uid: fooUid }, { uid: fooUid, roomId: roomId, start: 0 }, (err, messages) => {
				assert.ifError(err);
				assert.equal(messages.length, 2);
				assert.strictEqual(messages[0].system, true);
				assert.strictEqual(messages[0].content, 'user-join');
				socketModules.chats.edit({ uid: fooUid }, { roomId: roomId, mid: messages[0].messageId, message: 'test' }, (err) => {
					assert.equal(err.message, '[[error:cant-edit-chat-message]]');
					done();
				});
			});
		});

		it('should fail to add user to room with invalid data', (done) => {
			socketModules.chats.addUserToRoom({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: null }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should add a user to room', (done) => {
			socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: 'herp' }, (err) => {
				assert.ifError(err);
				Messaging.isUserInRoom(herpUid, roomId, (err, isInRoom) => {
					assert.ifError(err);
					assert(isInRoom);
					done();
				});
			});
		});

		it('should get users in room', async () => {
			const data = await socketModules.chats.getUsersInRoom({ uid: fooUid }, { roomId: roomId });
			assert(Array.isArray(data) && data.length === 3);
		});

		it('should throw error if user is not in room', async () => {
			try {
				const data = await socketModules.chats.getUsersInRoom({ uid: 123123123 }, { roomId: roomId });
			} catch (err) {
				assert.equal(err.message, '[[error:no-privileges]]');
			}
		});

		it('should fail to add users to room if max is reached', (done) => {
			meta.config.maximumUsersInChatRoom = 2;
			socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: 'test' }, (err) => {
				assert.equal(err.message, '[[error:cant-add-more-users-to-chat-room]]');
				meta.config.maximumUsersInChatRoom = 0;
				done();
			});
		});

		it('should fail to add users to room if user does not exist', (done) => {
			socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: 'doesnotexist' }, (err) => {
				assert.equal(err.message, '[[error:no-user]]');
				done();
			});
		});

		it('should fail to add self to room', (done) => {
			socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: 'foo' }, (err) => {
				assert.equal(err.message, '[[error:cant-chat-with-yourself]]');
				done();
			});
		});

		it('should fail to leave room with invalid data', (done) => {
			socketModules.chats.leave({ uid: null }, roomId, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.leave({ uid: fooUid }, null, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					done();
				});
			});
		});

		it('should leave the chat room', (done) => {
			socketModules.chats.leave({ uid: bazUid }, roomId, (err) => {
				assert.ifError(err);
				Messaging.isUserInRoom(bazUid, roomId, (err, isUserInRoom) => {
					assert.ifError(err);
					assert.equal(isUserInRoom, false);
					Messaging.getRoomData(roomId, (err, data) => {
						assert.ifError(err);
						assert.equal(data.owner, fooUid);
						done();
					});
				});
			});
		});

		it('should send a user-leave system message when a user leaves the chat room', (done) => {
			socketModules.chats.getMessages({ uid: fooUid }, { uid: fooUid, roomId: roomId, start: 0 }, (err, messages) => {
				assert.ifError(err);
				assert.equal(messages.length, 4);
				const message = messages.pop();
				assert.strictEqual(message.system, true);
				assert.strictEqual(message.content, 'user-leave');
				done();
			});
		});

		it('should send not a user-leave system message when a user tries to leave a room they are not in', async () => {
			await socketModules.chats.leave({ uid: bazUid }, roomId);
			const messages = await socketModules.chats.getMessages(
				{ uid: fooUid },
				{ uid: fooUid, roomId: roomId, start: 0 }
			);
			assert.equal(messages.length, 4);
			const message = messages.pop();
			assert.strictEqual(message.system, true);
			assert.strictEqual(message.content, 'user-leave');
		});

		it('should change owner when owner leaves room', (done) => {
			socketModules.chats.newRoom({ uid: herpUid }, { touid: fooUid }, (err, roomId) => {
				assert.ifError(err);
				socketModules.chats.addUserToRoom({ uid: herpUid }, { roomId: roomId, username: 'baz' }, (err) => {
					assert.ifError(err);
					socketModules.chats.leave({ uid: herpUid }, roomId, (err) => {
						assert.ifError(err);
						Messaging.getRoomData(roomId, (err, data) => {
							assert.ifError(err);
							assert.equal(data.owner, fooUid);
							done();
						});
					});
				});
			});
		});

		it('should change owner if owner is deleted', (done) => {
			User.create({ username: 'deleted_chat_user' }, (err, sender) => {
				assert.ifError(err);
				User.create({ username: 'receiver' }, (err, receiver) => {
					assert.ifError(err);
					socketModules.chats.newRoom({ uid: sender }, { touid: receiver }, (err, roomId) => {
						assert.ifError(err);
						User.deleteAccount(sender, (err) => {
							assert.ifError(err);
							Messaging.getRoomData(roomId, (err, data) => {
								assert.ifError(err);
								assert.equal(data.owner, receiver);
								done();
							});
						});
					});
				});
			});
		});

		it('should fail to remove user from room', (done) => {
			socketModules.chats.removeUserFromRoom({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.removeUserFromRoom({ uid: fooUid }, {}, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					done();
				});
			});
		});

		it('should fail to remove user from room if user does not exist', (done) => {
			socketModules.chats.removeUserFromRoom({ uid: fooUid }, { roomId: roomId, uid: 99 }, (err) => {
				assert.equal('[[error:no-user]]', err.message);
				done();
			});
		});

		it('should remove user from room', (done) => {
			socketModules.chats.newRoom({ uid: fooUid }, { touid: herpUid }, (err, roomId) => {
				assert.ifError(err);
				Messaging.isUserInRoom(herpUid, roomId, (err, isInRoom) => {
					assert.ifError(err);
					assert(isInRoom);
					socketModules.chats.removeUserFromRoom({ uid: fooUid }, { roomId: roomId, uid: herpUid }, (err) => {
						assert.equal(err.message, '[[error:cant-remove-last-user]]');
						socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: 'baz' }, (err) => {
							assert.ifError(err);
							socketModules.chats.removeUserFromRoom({ uid: fooUid }, { roomId: roomId, uid: herpUid }, (err) => {
								assert.ifError(err);
								Messaging.isUserInRoom(herpUid, roomId, (err, isInRoom) => {
									assert.ifError(err);
									assert(!isInRoom);
									done();
								});
							});
						});
					});
				});
			});
		});

		it('should fail to send a message to room with invalid data', (done) => {
			socketModules.chats.send({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.send({ uid: fooUid }, { roomId: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketModules.chats.send({ uid: null }, { roomId: 1 }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should fail to send chat if content is empty', (done) => {
			socketModules.chats.send({ uid: fooUid }, { roomId: roomId, message: ' ' }, (err) => {
				assert.equal(err.message, '[[error:invalid-chat-message]]');
				done();
			});
		});

		it('should send a message to a room', (done) => {
			socketModules.chats.send({ uid: fooUid }, { roomId: roomId, message: 'first chat message' }, (err, messageData) => {
				assert.ifError(err);
				assert(messageData);
				assert.equal(messageData.content, 'first chat message');
				assert(messageData.fromUser);
				assert(messageData.roomId, roomId);
				socketModules.chats.getRaw({ uid: fooUid }, { mid: messageData.mid }, (err, raw) => {
					assert.ifError(err);
					assert.equal(raw, 'first chat message');
					setTimeout(done, 300);
				});
			});
		});

		it('should fail to send second message due to rate limit', (done) => {
			const socketMock = { uid: fooUid };
			const oldValue = meta.config.chatMessageDelay;
			meta.config.chatMessageDelay = 1000;
			socketModules.chats.send(socketMock, { roomId: roomId, message: 'first chat message' }, (err) => {
				assert.ifError(err);
				socketModules.chats.send(socketMock, { roomId: roomId, message: 'first chat message' }, (err) => {
					assert.equal(err.message, '[[error:too-many-messages]]');
					meta.config.chatMessageDelay = oldValue;
					done();
				});
			});
		});

		it('should return invalid-data error', (done) => {
			socketModules.chats.getRaw({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.getRaw({ uid: fooUid }, {}, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					done();
				});
			});
		});

		it('should return not allowed error if mid is not in room', (done) => {
			let myRoomId;
			User.create({ username: 'dummy' }, (err, uid) => {
				assert.ifError(err);
				socketModules.chats.newRoom({ uid: bazUid }, { touid: uid }, (err, _roomId) => {
					myRoomId = _roomId;
					assert.ifError(err);
					assert(myRoomId);
					socketModules.chats.getRaw({ uid: bazUid }, { mid: 200 }, (err) => {
						assert(err);
						assert.equal(err.message, '[[error:not-allowed]]');
						socketModules.chats.send({ uid: bazUid }, { roomId: myRoomId, message: 'admin will see this' }, (err, message) => {
							assert.ifError(err);
							socketModules.chats.getRaw({ uid: fooUid }, { mid: message.mid }, (err, raw) => {
								assert.ifError(err);
								assert.equal(raw, 'admin will see this');
								done();
							});
						});
					});
				});
			});
		});


		it('should notify offline users of message', async () => {
			meta.config.notificationSendDelay = 0.1;

			const roomId = await socketModules.chats.newRoom({ uid: fooUid }, { touid: bazUid });
			assert(roomId);
			await socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: 'herp' });
			await db.sortedSetAdd('users:online', Date.now() - ((meta.config.onlineCutoff * 60000) + 50000), herpUid);
			await socketModules.chats.send({ uid: fooUid }, { roomId: roomId, message: 'second chat message **bold** text' });

			await sleep(1500);
			const data = await User.notifications.get(herpUid);
			assert(data.unread[0]);
			const notification = data.unread[0];
			assert.strictEqual(notification.bodyShort, '[[notifications:new_message_from, foo]]');
			assert.strictEqual(notification.nid, `chat_${fooUid}_${roomId}`);
			assert.strictEqual(notification.path, `${nconf.get('relative_path')}/chats/${roomId}`);
		});

		it('should fail to get messages from room with invalid data', (done) => {
			socketModules.chats.getMessages({ uid: null }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.getMessages({ uid: fooUid }, null, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketModules.chats.getMessages({ uid: fooUid }, { uid: null }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						socketModules.chats.getMessages({ uid: fooUid }, { uid: 1, roomId: null }, (err) => {
							assert.equal(err.message, '[[error:invalid-data]]');
							done();
						});
					});
				});
			});
		});

		it('should get messages from room', (done) => {
			socketModules.chats.getMessages({ uid: fooUid }, {
				uid: fooUid,
				roomId: roomId,
				start: 0,
			}, (err, messages) => {
				assert.ifError(err);
				assert(Array.isArray(messages));
				assert.equal(messages[4].roomId, roomId);
				assert.equal(messages[4].fromuid, fooUid);
				done();
			});
		});

		it('should fail to mark read with invalid data', (done) => {
			socketModules.chats.markRead({ uid: null }, roomId, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.markRead({ uid: fooUid }, null, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					done();
				});
			});
		});

		it('should not error if user is not in room', (done) => {
			socketModules.chats.markRead({ uid: herpUid }, 10, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should mark room read', (done) => {
			socketModules.chats.markRead({ uid: fooUid }, roomId, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should mark all rooms read', (done) => {
			socketModules.chats.markAllRead({ uid: fooUid }, {}, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should fail to rename room with invalid data', (done) => {
			socketModules.chats.renameRoom({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.renameRoom({ uid: fooUid }, { roomId: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketModules.chats.renameRoom({ uid: fooUid }, { roomId: roomId, newName: null }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should rename room', (done) => {
			socketModules.chats.renameRoom({ uid: fooUid }, { roomId: roomId, newName: 'new room name' }, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should send a room-rename system message when a room is renamed', (done) => {
			socketModules.chats.getMessages({ uid: fooUid }, { uid: fooUid, roomId: roomId, start: 0 }, (err, messages) => {
				assert.ifError(err);
				const message = messages.pop();
				assert.strictEqual(message.system, true);
				assert.strictEqual(message.content, 'room-rename, new room name');
				done();
			});
		});

		it('should fail to load room with invalid-data', (done) => {
			socketModules.chats.loadRoom({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.loadRoom({ uid: fooUid }, { roomId: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					done();
				});
			});
		});

		it('should fail to load room if user is not in', (done) => {
			socketModules.chats.loadRoom({ uid: 0 }, { roomId: roomId }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should load chat room', (done) => {
			socketModules.chats.loadRoom({ uid: fooUid }, { roomId: roomId }, (err, data) => {
				assert.ifError(err);
				assert(data);
				assert.equal(data.roomName, 'new room name');
				done();
			});
		});

		it('should return true if user is dnd', (done) => {
			db.setObjectField(`user:${herpUid}`, 'status', 'dnd', (err) => {
				assert.ifError(err);
				socketModules.chats.isDnD({ uid: fooUid }, herpUid, (err, isDnD) => {
					assert.ifError(err);
					assert(isDnD);
					done();
				});
			});
		});

		it('should fail to load recent chats with invalid data', (done) => {
			socketModules.chats.getRecentChats({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.getRecentChats({ uid: fooUid }, { after: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketModules.chats.getRecentChats({ uid: fooUid }, { after: 0, uid: null }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should load recent chats of user', (done) => {
			socketModules.chats.getRecentChats({ uid: fooUid }, { after: 0, uid: fooUid }, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data.rooms));
				done();
			});
		});

		it('should escape teaser', (done) => {
			socketModules.chats.send({ uid: fooUid }, { roomId: roomId, message: '<svg/onload=alert(document.location);' }, (err) => {
				assert.ifError(err);
				socketModules.chats.getRecentChats({ uid: fooUid }, { after: 0, uid: fooUid }, (err, data) => {
					assert.ifError(err);
					assert.equal(data.rooms[0].teaser.content, '&lt;svg&#x2F;onload=alert(document.location);');
					done();
				});
			});
		});

		it('should fail to check if user has private chat with invalid data', (done) => {
			socketModules.chats.hasPrivateChat({ uid: null }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.hasPrivateChat({ uid: fooUid }, null, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					done();
				});
			});
		});

		it('should check if user has private chat with another uid', (done) => {
			socketModules.chats.hasPrivateChat({ uid: fooUid }, herpUid, (err, roomId) => {
				assert.ifError(err);
				assert(roomId);
				done();
			});
		});
	});

	describe('edit/delete', () => {
		const socketModules = require('../src/socket.io/modules');
		let mid;
		let mid2;
		before(async () => {
			await socketModules.chats.addUserToRoom({ uid: fooUid }, { roomId: roomId, username: 'baz' });
			mid = (await socketModules.chats.send({ uid: fooUid }, { roomId: roomId, message: 'first chat message' })).mid;
			mid2 = (await socketModules.chats.send({ uid: bazUid }, { roomId: roomId, message: 'second chat message' })).mid;
		});

		after(async () => {
			await socketModules.chats.leave({ uid: bazUid }, roomId);
		});

		it('should fail to edit message with invalid data', (done) => {
			socketModules.chats.edit({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.edit({ uid: fooUid }, { roomId: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketModules.chats.edit({ uid: fooUid }, { roomId: 1, message: null }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should fail to edit message if new content is empty string', (done) => {
			socketModules.chats.edit({ uid: fooUid }, { mid: mid, roomId: roomId, message: ' ' }, (err) => {
				assert.equal(err.message, '[[error:invalid-chat-message]]');
				done();
			});
		});

		it('should fail to edit message if not own message', (done) => {
			socketModules.chats.edit({ uid: herpUid }, { mid: mid, roomId: roomId, message: 'message edited' }, (err) => {
				assert.equal(err.message, '[[error:cant-edit-chat-message]]');
				done();
			});
		});

		it('should edit message', (done) => {
			socketModules.chats.edit({ uid: fooUid }, { mid: mid, roomId: roomId, message: 'message edited' }, (err) => {
				assert.ifError(err);
				socketModules.chats.getRaw({ uid: fooUid }, { mid: mid }, (err, raw) => {
					assert.ifError(err);
					assert.equal(raw, 'message edited');
					done();
				});
			});
		});

		it('should fail to delete message with invalid data', (done) => {
			socketModules.chats.delete({ uid: fooUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				socketModules.chats.delete({ uid: fooUid }, { roomId: null }, (err) => {
					assert.equal(err.message, '[[error:invalid-data]]');
					socketModules.chats.delete({ uid: fooUid }, { roomId: 1, messageId: null }, (err) => {
						assert.equal(err.message, '[[error:invalid-data]]');
						done();
					});
				});
			});
		});

		it('should fail to delete message if not owner', (done) => {
			socketModules.chats.delete({ uid: herpUid }, { messageId: mid, roomId: roomId }, (err) => {
				assert.equal(err.message, '[[error:cant-delete-chat-message]]');
				done();
			});
		});

		it('should mark the message as deleted', (done) => {
			socketModules.chats.delete({ uid: fooUid }, { messageId: mid, roomId: roomId }, (err) => {
				assert.ifError(err);
				db.getObjectField(`message:${mid}`, 'deleted', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(1, parseInt(value, 10));
					done();
				});
			});
		});

		it('should show deleted message to original users', (done) => {
			socketModules.chats.getMessages({ uid: fooUid }, { uid: fooUid, roomId: roomId, start: 0 }, (err, messages) => {
				assert.ifError(err);

				// Reduce messages to their mids
				const mids = messages.reduce((mids, cur) => {
					mids.push(cur.messageId);
					return mids;
				}, []);

				assert(mids.includes(mid));
				done();
			});
		});

		it('should not show deleted message to other users', (done) => {
			socketModules.chats.getMessages({ uid: herpUid }, { uid: herpUid, roomId: roomId, start: 0 }, (err, messages) => {
				assert.ifError(err);
				messages.forEach((msg) => {
					assert(!msg.deleted || msg.content === '[[modules:chat.message-deleted]]', msg.content);
				});
				done();
			});
		});

		it('should error out if a message is deleted again', (done) => {
			socketModules.chats.delete({ uid: fooUid }, { messageId: mid, roomId: roomId }, (err) => {
				assert.strictEqual('[[error:chat-deleted-already]]', err.message);
				done();
			});
		});

		it('should restore the message', (done) => {
			socketModules.chats.restore({ uid: fooUid }, { messageId: mid, roomId: roomId }, (err) => {
				assert.ifError(err);
				db.getObjectField(`message:${mid}`, 'deleted', (err, value) => {
					assert.ifError(err);
					assert.strictEqual(0, parseInt(value, 10));
					done();
				});
			});
		});

		it('should error out if a message is restored again', (done) => {
			socketModules.chats.restore({ uid: fooUid }, { messageId: mid, roomId: roomId }, (err) => {
				assert.strictEqual('[[error:chat-restored-already]]', err.message);
				done();
			});
		});

		describe('disabled via ACP', () => {
			before(async () => {
				meta.config.disableChatMessageEditing = true;
			});

			after(async () => {
				meta.config.disableChatMessageEditing = false;
			});

			it('should error out for regular users', async () => {
				try {
					await socketModules.chats.delete({ uid: bazUid }, { messageId: mid2, roomId: roomId });
				} catch (err) {
					assert.strictEqual('[[error:chat-message-editing-disabled]]', err.message);
				}
			});

			it('should succeed for administrators', async () => {
				await socketModules.chats.delete({ uid: fooUid }, { messageId: mid2, roomId: roomId });
				await socketModules.chats.restore({ uid: fooUid }, { messageId: mid2, roomId: roomId });
			});

			it('should succeed for global moderators', async () => {
				await Groups.join(['Global Moderators'], bazUid);

				await socketModules.chats.delete({ uid: fooUid }, { messageId: mid2, roomId: roomId });
				await socketModules.chats.restore({ uid: fooUid }, { messageId: mid2, roomId: roomId });

				await Groups.leave(['Global Moderators'], bazUid);
			});
		});
	});

	describe('controller', () => {
		it('should 404 if chat is disabled', (done) => {
			meta.config.disableChat = 1;
			request(`${nconf.get('url')}/user/baz/chats`, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});

		it('should 500 for guest with no privilege error', (done) => {
			meta.config.disableChat = 0;
			request(`${nconf.get('url')}/api/user/baz/chats`, { json: true }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 500);
				assert.equal(body.error, '[[error:no-privileges]]');
				done();
			});
		});

		it('should 404 for non-existent user', (done) => {
			request(`${nconf.get('url')}/user/doesntexist/chats`, (err, response) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 404);
				done();
			});
		});
	});

	describe('logged in chat controller', () => {
		let jar;
		before((done) => {
			helpers.loginUser('herp', 'derpderp', (err, _jar) => {
				assert.ifError(err);
				jar = _jar;
				done();
			});
		});

		it('should return chats page data', (done) => {
			request(`${nconf.get('url')}/api/user/herp/chats`, { json: true, jar: jar }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert(Array.isArray(body.rooms));
				assert.equal(body.rooms.length, 2);
				assert.equal(body.title, '[[pages:chats]]');
				done();
			});
		});

		it('should return room data', (done) => {
			request(`${nconf.get('url')}/api/user/herp/chats/${roomId}`, { json: true, jar: jar }, (err, response, body) => {
				assert.ifError(err);
				assert.equal(response.statusCode, 200);
				assert.equal(body.roomId, roomId);
				assert.equal(body.isOwner, false);
				done();
			});
		});

		it('should redirect to chats page', (done) => {
			request(`${nconf.get('url')}/api/chats`, { jar: jar, json: true }, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(res.headers['x-redirect'], '/user/herp/chats');
				assert.equal(body, '/user/herp/chats');
				done();
			});
		});

		it('should return 404 if user is not in room', (done) => {
			helpers.loginUser('baz', 'quuxquux', (err, jar) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/user/baz/chats/${roomId}`, { json: true, jar: jar }, (err, response) => {
					assert.ifError(err);
					assert.equal(response.statusCode, 404);
					done();
				});
			});
		});
	});
'use strict';

const assert = require('assert');
const async = require('async');
const util = require('util');

const sleep = util.promisify(setTimeout);

const db = require('./mocks/databasemock');
const Flags = require('../src/flags');
const Categories = require('../src/categories');
const Topics = require('../src/topics');
const Posts = require('../src/posts');
const User = require('../src/user');
const Groups = require('../src/groups');
const Meta = require('../src/meta');
const Privileges = require('../src/privileges');

describe('Flags', () => {
	let uid1;
	let adminUid;
	let uid3;
	let category;
	before(async () => {
		// Create some stuff to flag
		uid1 = await User.create({ username: 'testUser', password: 'abcdef', email: 'b@c.com' });

		adminUid = await User.create({ username: 'testUser2', password: 'abcdef', email: 'c@d.com' });
		await Groups.join('administrators', adminUid);

		category = await Categories.create({
			name: 'test category',
		});
		await Topics.post({
			cid: category.cid,
			uid: uid1,
			title: 'Topic to flag',
			content: 'This is flaggable content',
		});

		uid3 = await User.create({
			username: 'unprivileged', password: 'abcdef', email: 'd@e.com',
		});
	});

	describe('.create()', () => {
		it('should create a flag and return its data', (done) => {
			Flags.create('post', 1, 1, 'Test flag', (err, flagData) => {
				assert.ifError(err);
				const compare = {
					flagId: 1,
					targetId: 1,
					type: 'post',
					state: 'open',
					target_readable: 'Post 1',
				};
				assert(flagData);
				for (const key of Object.keys(compare)) {
					assert.ok(flagData[key], `undefined key ${key}`);
					assert.equal(flagData[key], compare[key]);
				}

				done();
			});
		});

		it('should add the flag to the byCid zset for category 1 if it is of type post', (done) => {
			db.isSortedSetMember(`flags:byCid:${1}`, 1, (err, isMember) => {
				assert.ifError(err);
				assert.ok(isMember);
				done();
			});
		});

		it('should add the flag to the byPid zset for pid 1 if it is of type post', (done) => {
			db.isSortedSetMember(`flags:byPid:${1}`, 1, (err, isMember) => {
				assert.ifError(err);
				assert.ok(isMember);
				done();
			});
		});
	});

	describe('.exists()', () => {
		it('should return Boolean True if a flag matching the flag hash already exists', (done) => {
			Flags.exists('post', 1, 1, (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(true, exists);
				done();
			});
		});

		it('should return Boolean False if a flag matching the flag hash does not already exists', (done) => {
			Flags.exists('post', 1, 2, (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(false, exists);
				done();
			});
		});
	});

	describe('.targetExists()', () => {
		it('should return Boolean True if the targeted element exists', (done) => {
			Flags.targetExists('post', 1, (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(true, exists);
				done();
			});
		});

		it('should return Boolean False if the targeted element does not exist', (done) => {
			Flags.targetExists('post', 15, (err, exists) => {
				assert.ifError(err);
				assert.strictEqual(false, exists);
				done();
			});
		});
	});

	describe('.get()', () => {
		it('should retrieve and display a flag\'s data', (done) => {
			Flags.get(1, (err, flagData) => {
				assert.ifError(err);
				const compare = {
					flagId: 1,
					targetId: 1,
					type: 'post',
					state: 'open',
					target_readable: 'Post 1',
				};
				assert(flagData);
				for (const key of Object.keys(compare)) {
					assert.ok(flagData[key], `undefined key ${key}`);
					assert.equal(flagData[key], compare[key]);
				}

				done();
			});
		});
	});

	describe('.list()', () => {
		it('should show a list of flags (with one item)', (done) => {
			Flags.list({
				filters: {},
				uid: 1,
			}, (err, payload) => {
				assert.ifError(err);
				assert.ok(payload.hasOwnProperty('flags'));
				assert.ok(payload.hasOwnProperty('page'));
				assert.ok(payload.hasOwnProperty('pageCount'));
				assert.ok(Array.isArray(payload.flags));
				assert.equal(payload.flags.length, 1);

				Flags.get(payload.flags[0].flagId, (err, flagData) => {
					assert.ifError(err);
					assert.equal(payload.flags[0].flagId, flagData.flagId);
					assert.equal(payload.flags[0].description, flagData.description);
					done();
				});
			});
		});

		describe('(with filters)', () => {
			it('should return a filtered list of flags if said filters are passed in', (done) => {
				Flags.list({
					filters: {
						state: 'open',
					},
					uid: 1,
				}, (err, payload) => {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty('flags'));
					assert.ok(payload.hasOwnProperty('page'));
					assert.ok(payload.hasOwnProperty('pageCount'));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, parseInt(payload.flags[0].flagId, 10));
					done();
				});
			});

			it('should return no flags if a filter with no matching flags is used', (done) => {
				Flags.list({
					filters: {
						state: 'rejected',
					},
					uid: 1,
				}, (err, payload) => {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty('flags'));
					assert.ok(payload.hasOwnProperty('page'));
					assert.ok(payload.hasOwnProperty('pageCount'));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(0, payload.flags.length);
					done();
				});
			});

			it('should return a flag when filtered by cid 1', (done) => {
				Flags.list({
					filters: {
						cid: 1,
					},
					uid: 1,
				}, (err, payload) => {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty('flags'));
					assert.ok(payload.hasOwnProperty('page'));
					assert.ok(payload.hasOwnProperty('pageCount'));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, payload.flags.length);
					done();
				});
			});

			it('shouldn\'t return a flag when filtered by cid 2', (done) => {
				Flags.list({
					filters: {
						cid: 2,
					},
					uid: 1,
				}, (err, payload) => {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty('flags'));
					assert.ok(payload.hasOwnProperty('page'));
					assert.ok(payload.hasOwnProperty('pageCount'));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(0, payload.flags.length);
					done();
				});
			});

			it('should return a flag when filtered by both cid 1 and 2', (done) => {
				Flags.list({
					filters: {
						cid: [1, 2],
					},
					uid: 1,
				}, (err, payload) => {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty('flags'));
					assert.ok(payload.hasOwnProperty('page'));
					assert.ok(payload.hasOwnProperty('pageCount'));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, payload.flags.length);
					done();
				});
			});

			it('should return one flag if filtered by both cid 1 and 2 and open state', (done) => {
				Flags.list({
					filters: {
						cid: [1, 2],
						state: 'open',
					},
					uid: 1,
				}, (err, payload) => {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty('flags'));
					assert.ok(payload.hasOwnProperty('page'));
					assert.ok(payload.hasOwnProperty('pageCount'));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, payload.flags.length);
					done();
				});
			});

			it('should return no flag if filtered by both cid 1 and 2 and non-open state', (done) => {
				Flags.list({
					filters: {
						cid: [1, 2],
						state: 'resolved',
					},
					uid: 1,
				}, (err, payload) => {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty('flags'));
					assert.ok(payload.hasOwnProperty('page'));
					assert.ok(payload.hasOwnProperty('pageCount'));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(0, payload.flags.length);
					done();
				});
			});
		});

		describe('(with sort)', () => {
			before(async () => {
				// Create a second flag to test sorting
				const post = await Topics.reply({
					tid: 1,
					uid: uid1,
					content: 'this is a reply -- flag me',
				});
				await Flags.create('post', post.pid, adminUid, 'another flag');
				await Flags.create('post', 1, uid3, 'additional flag report');
			});

			it('should return sorted flags latest first if no sort is passed in', async () => {
				const payload = await Flags.list({
					uid: adminUid,
				});

				assert(payload.flags.every((cur, idx) => {
					if (idx === payload.flags.length - 1) {
						return true;
					}

					const next = payload.flags[idx + 1];
					return parseInt(cur.datetime, 10) > parseInt(next.datetime, 10);
				}));
			});

			it('should return sorted flags oldest first if "oldest" sort is passed in', async () => {
				const payload = await Flags.list({
					uid: adminUid,
					sort: 'oldest',
				});

				assert(payload.flags.every((cur, idx) => {
					if (idx === payload.flags.length - 1) {
						return true;
					}

					const next = payload.flags[idx + 1];
					return parseInt(cur.datetime, 10) < parseInt(next.datetime, 10);
				}));
			});

			it('should return flags with more reports first if "reports" sort is passed in', async () => {
				const payload = await Flags.list({
					uid: adminUid,
					sort: 'reports',
				});

				assert(payload.flags.every((cur, idx) => {
					if (idx === payload.flags.length - 1) {
						return true;
					}

					const next = payload.flags[idx + 1];
					return parseInt(cur.heat, 10) >= parseInt(next.heat, 10);
				}));
			});
		});
	});

	describe('.update()', () => {
		it('should alter a flag\'s various attributes and persist them to the database', (done) => {
			Flags.update(1, adminUid, {
				state: 'wip',
				assignee: adminUid,
			}, (err) => {
				assert.ifError(err);
				db.getObjectFields('flag:1', ['state', 'assignee'], (err, data) => {
					if (err) {
						throw err;
					}

					assert.strictEqual('wip', data.state);
					assert.ok(!isNaN(parseInt(data.assignee, 10)));
					assert.strictEqual(adminUid, parseInt(data.assignee, 10));
					done();
				});
			});
		});

		it('should persist to the flag\'s history', (done) => {
			Flags.getHistory(1, (err, history) => {
				if (err) {
					throw err;
				}

				history.forEach((change) => {
					switch (change.attribute) {
						case 'state':
							assert.strictEqual('[[flags:state-wip]]', change.value);
							break;

						case 'assignee':
							assert.strictEqual(1, change.value);
							break;
					}
				});

				done();
			});
		});

		it('should allow assignment if user is an admin and do nothing otherwise', async () => {
			await Flags.update(1, adminUid, {
				assignee: adminUid,
			});
			let assignee = await db.getObjectField('flag:1', 'assignee');
			assert.strictEqual(adminUid, parseInt(assignee, 10));

			await Flags.update(1, adminUid, {
				assignee: uid3,
			});
			assignee = await db.getObjectField('flag:1', 'assignee');
			assert.strictEqual(adminUid, parseInt(assignee, 10));
		});

		it('should allow assignment if user is a global mod and do nothing otherwise', async () => {
			await Groups.join('Global Moderators', uid3);

			await Flags.update(1, uid3, {
				assignee: uid3,
			});
			let assignee = await db.getObjectField('flag:1', 'assignee');
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Flags.update(1, uid3, {
				assignee: uid1,
			});
			assignee = await db.getObjectField('flag:1', 'assignee');
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Groups.leave('Global Moderators', uid3);
		});

		it('should allow assignment if user is a mod of the category, do nothing otherwise', async () => {
			await Groups.join(`cid:${category.cid}:privileges:moderate`, uid3);

			await Flags.update(1, uid3, {
				assignee: uid3,
			});
			let assignee = await db.getObjectField('flag:1', 'assignee');
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Flags.update(1, uid3, {
				assignee: uid1,
			});
			assignee = await db.getObjectField('flag:1', 'assignee');
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Groups.leave(`cid:${category.cid}:privileges:moderate`, uid3);
		});

		it('should do nothing when you attempt to set a bogus state', async () => {
			await Flags.update(1, adminUid, {
				state: 'hocus pocus',
			});

			const state = await db.getObjectField('flag:1', 'state');
			assert.strictEqual('wip', state);
		});

		it('should rescind notification if flag is resolved', async () => {
			const SocketFlags = require('../src/socket.io/flags.js');
			const result = await Topics.post({
				cid: category.cid,
				uid: uid3,
				title: 'Topic to flag',
				content: 'This is flaggable content',
			});
			const flagId = await SocketFlags.create({ uid: uid1 }, { type: 'post', id: result.postData.pid, reason: 'spam' });
			await sleep(2000);

			let userNotifs = await User.notifications.getAll(adminUid);
			assert(userNotifs.includes(`flag:post:${result.postData.pid}`));

			await Flags.update(flagId, adminUid, {
				state: 'resolved',
			});

			userNotifs = await User.notifications.getAll(adminUid);
			assert(!userNotifs.includes(`flag:post:${result.postData.pid}`));
		});
	});

	describe('.getTarget()', () => {
		it('should return a post\'s data if queried with type "post"', (done) => {
			Flags.getTarget('post', 1, 1, (err, data) => {
				assert.ifError(err);
				const compare = {
					uid: 1,
					pid: 1,
					content: 'This is flaggable content',
				};

				for (const key of Object.keys(compare)) {
					assert.ok(data[key]);
					assert.equal(data[key], compare[key]);
				}

				done();
			});
		});

		it('should return a user\'s data if queried with type "user"', (done) => {
			Flags.getTarget('user', 1, 1, (err, data) => {
				assert.ifError(err);
				const compare = {
					uid: 1,
					username: 'testUser',
					email: 'b@c.com',
				};

				for (const key of Object.keys(compare)) {
					assert.ok(data[key]);
					assert.equal(data[key], compare[key]);
				}

				done();
			});
		});

		it('should return a plain object with no properties if the target no longer exists', (done) => {
			Flags.getTarget('user', 15, 1, (err, data) => {
				assert.ifError(err);
				assert.strictEqual(0, Object.keys(data).length);
				done();
			});
		});
	});

	describe('.validate()', () => {
		it('should error out if type is post and post is deleted', (done) => {
			Posts.delete(1, 1, (err) => {
				if (err) {
					throw err;
				}

				Flags.validate({
					type: 'post',
					id: 1,
					uid: 1,
				}, (err) => {
					assert.ok(err);
					assert.strictEqual('[[error:post-deleted]]', err.message);
					Posts.restore(1, 1, done);
				});
			});
		});

		it('should not pass validation if flag threshold is set and user rep does not meet it', (done) => {
			Meta.configs.set('min:rep:flag', '50', (err) => {
				assert.ifError(err);

				Flags.validate({
					type: 'post',
					id: 1,
					uid: 3,
				}, (err) => {
					assert.ok(err);
					assert.strictEqual('[[error:not-enough-reputation-to-flag]]', err.message);
					Meta.configs.set('min:rep:flag', 0, done);
				});
			});
		});

		it('should not error if user blocked target', (done) => {
			const SocketFlags = require('../src/socket.io/flags.js');
			let reporterUid;
			let reporteeUid;
			async.waterfall([
				function (next) {
					User.create({ username: 'reporter' }, next);
				},
				function (uid, next) {
					reporterUid = uid;
					User.create({ username: 'reportee' }, next);
				},
				function (uid, next) {
					reporteeUid = uid;
					User.blocks.add(reporteeUid, reporterUid, next);
				},
				function (next) {
					Topics.post({
						cid: 1,
						uid: reporteeUid,
						title: 'Another topic',
						content: 'This is flaggable content',
					}, next);
				},
				function (data, next) {
					SocketFlags.create({ uid: reporterUid }, { type: 'post', id: data.postData.pid, reason: 'spam' }, next);
				},
			], done);
		});

		it('should send back error if reporter does not exist', (done) => {
			Flags.validate({ uid: 123123123, id: 1, type: 'post' }, (err) => {
				assert.equal(err.message, '[[error:no-user]]');
				done();
			});
		});
	});

	describe('.appendNote()', () => {
		it('should add a note to a flag', (done) => {
			Flags.appendNote(1, 1, 'this is my note', (err) => {
				assert.ifError(err);

				db.getSortedSetRange('flag:1:notes', 0, -1, (err, notes) => {
					if (err) {
						throw err;
					}

					assert.strictEqual('[1,"this is my note"]', notes[0]);
					setTimeout(done, 10);
				});
			});
		});

		it('should be a JSON string', (done) => {
			db.getSortedSetRange('flag:1:notes', 0, -1, (err, notes) => {
				if (err) {
					throw err;
				}

				try {
					JSON.parse(notes[0]);
				} catch (e) {
					assert.ifError(e);
				}

				done();
			});
		});
	});

	describe('.getNotes()', () => {
		before((done) => {
			// Add a second note
			Flags.appendNote(1, 1, 'this is the second note', done);
		});

		it('return should match a predefined spec', (done) => {
			Flags.getNotes(1, (err, notes) => {
				assert.ifError(err);
				const compare = {
					uid: 1,
					content: 'this is my note',
				};

				const data = notes[1];
				for (const key of Object.keys(compare)) {
					assert.ok(data[key]);
					assert.strictEqual(data[key], compare[key]);
				}

				done();
			});
		});

		it('should retrieve a list of notes, from newest to oldest', (done) => {
			Flags.getNotes(1, (err, notes) => {
				assert.ifError(err);
				assert(notes[0].datetime > notes[1].datetime, `${notes[0].datetime}-${notes[1].datetime}`);
				assert.strictEqual('this is the second note', notes[0].content);
				done();
			});
		});
	});

	describe('.appendHistory()', () => {
		let entries;
		before((done) => {
			db.sortedSetCard('flag:1:history', (err, count) => {
				entries = count;
				done(err);
			});
		});

		it('should add a new entry into a flag\'s history', (done) => {
			Flags.appendHistory(1, 1, {
				state: 'rejected',
			}, (err) => {
				assert.ifError(err);

				Flags.getHistory(1, (err, history) => {
					if (err) {
						throw err;
					}

					// 1 for the new event appended, 2 for username and email change
					assert.strictEqual(entries + 3, history.length);
					done();
				});
			});
		});
	});

	describe('.getHistory()', () => {
		it('should retrieve a flag\'s history', (done) => {
			Flags.getHistory(1, (err, history) => {
				assert.ifError(err);
				assert.strictEqual(history[0].fields.state, '[[flags:state-rejected]]');
				done();
			});
		});
	});

	describe('(websockets)', () => {
		const SocketFlags = require('../src/socket.io/flags.js');
		let pid;

		before((done) => {
			Topics.post({
				cid: 1,
				uid: 1,
				title: 'Another topic',
				content: 'This is flaggable content',
			}, (err, topic) => {
				pid = topic.postData.pid;

				done(err);
			});
		});

		describe('.create()', () => {
			it('should create a flag with no errors', (done) => {
				SocketFlags.create({ uid: 2 }, {
					type: 'post',
					id: pid,
					reason: 'foobar',
				}, (err) => {
					assert.ifError(err);

					Flags.exists('post', pid, 1, (err, exists) => {
						assert.ifError(err);
						assert(true);
						done();
					});
				});
			});

			it('should not allow flagging post in private category', async () => {
				const category = await Categories.create({ name: 'private category' });

				await Privileges.categories.rescind(['groups:topics:read'], category.cid, 'registered-users');
				await Groups.join('private category', uid3);
				const result = await Topics.post({
					cid: category.cid,
					uid: uid3,
					title: 'private topic',
					content: 'private post',
				});
				try {
					await SocketFlags.create({ uid: uid3 }, { type: 'post', id: result.postData.pid, reason: 'foobar' });
				} catch (err) {
					assert.equal(err.message, '[[error:no-privileges]]');
				}
			});
		});

		describe('.update()', () => {
			it('should update a flag\'s properties', (done) => {
				SocketFlags.update({ uid: 2 }, {
					flagId: 2,
					data: [{
						name: 'state',
						value: 'wip',
					}],
				}, (err, history) => {
					assert.ifError(err);
					assert(Array.isArray(history));
					assert(history[0].fields.hasOwnProperty('state'));
					assert.strictEqual('[[flags:state-wip]]', history[0].fields.state);
					done();
				});
			});
		});

		describe('.appendNote()', () => {
			it('should append a note to the flag', (done) => {
				SocketFlags.appendNote({ uid: 2 }, {
					flagId: 2,
					note: 'lorem ipsum dolor sit amet',
				}, (err, data) => {
					assert.ifError(err);
					assert(data.hasOwnProperty('notes'));
					assert(Array.isArray(data.notes));
					assert.strictEqual('lorem ipsum dolor sit amet', data.notes[0].content);
					assert.strictEqual(2, data.notes[0].uid);

					assert(data.hasOwnProperty('history'));
					assert(Array.isArray(data.history));
					assert.strictEqual(1, Object.keys(data.history[0].fields).length);
					assert(data.history[0].fields.hasOwnProperty('notes'));
					done();
				});
			});
'use strict';

const { SMTPServer } = require('smtp-server');
const assert = require('assert');
const fs = require('fs');
const path = require('path');

const db = require('./mocks/databasemock');
const Plugins = require('../src/plugins');
const Emailer = require('../src/emailer');
const Meta = require('../src/meta');

describe('emailer', () => {
	let onMail = function (address, session, callback) { callback(); };
	let onTo = function (address, session, callback) { callback(); };

	const template = 'test';
	const email = 'test@example.org';
	const language = 'en-GB';
	const params = {
		subject: 'Welcome to NodeBB',
	};

	before((done) => {
		const server = new SMTPServer({
			allowInsecureAuth: true,
			onAuth: function (auth, session, callback) {
				callback(null, {
					user: auth.username,
				});
			},
			onMailFrom: function (address, session, callback) {
				onMail(address, session, callback);
			},
			onRcptTo: function (address, session, callback) {
				onTo(address, session, callback);
			},
		});

		server.on('error', (err) => {
			throw err;
		});
		server.listen(4000, done);
	});

	// TODO: test sendmail here at some point

	it('plugin hook should work', (done) => {
		const error = new Error();

		Plugins.hooks.register('emailer-test', {
			hook: 'filter:email.send',
			method: function (data, next) {
				assert(data);
				assert.equal(data.to, email);
				assert.equal(data.subject, `[NodeBB] ${params.subject}`);

				next(error);
			},
		});

		Emailer.sendToEmail(template, email, language, params, (err) => {
			assert.equal(err, error);

			Plugins.hooks.unregister('emailer-test', 'filter:email.send');
			done();
		});
	});

	it('should build custom template on config change', (done) => {
		const text = 'a random string of text';

		// make sure it's not already set
		Emailer.renderAndTranslate('test', {}, 'en-GB', (err, output) => {
			assert.ifError(err);

			assert.notEqual(output, text);

			Meta.configs.set('email:custom:test', text, (err) => {
				assert.ifError(err);

				// wait for pubsub stuff
				setTimeout(() => {
					Emailer.renderAndTranslate('test', {}, 'en-GB', (err, output) => {
						assert.ifError(err);

						assert.equal(output, text);
						done();
					});
				}, 500);
			});
		});
	});

	it('should send via SMTP', (done) => {
		const from = 'admin@example.org';
		const username = 'another@example.com';

		onMail = function (address, session, callback) {
			assert.equal(address.address, from);
			assert.equal(session.user, username);

			callback();
		};

		onTo = function (address, session, callback) {
			assert.equal(address.address, email);

			callback();
			done();
		};

		Meta.configs.setMultiple({
			'email:smtpTransport:enabled': '1',
			'email:smtpTransport:user': username,
			'email:smtpTransport:pass': 'anything',
			'email:smtpTransport:service': 'nodebb-custom-smtp',
			'email:smtpTransport:port': 4000,
			'email:smtpTransport:host': 'localhost',
			'email:smtpTransport:security': 'NONE',
			'email:from': from,
		}, (err) => {
			assert.ifError(err);

			// delay so emailer has a chance to update after config changes
			setTimeout(() => {
				assert.equal(Emailer.fallbackTransport, Emailer.transports.smtp);

				Emailer.sendToEmail(template, email, language, params, (err) => {
					assert.ifError(err);
				});
			}, 200);
		});
	});

	after((done) => {
		fs.unlinkSync(path.join(__dirname, '../build/public/templates/emails/test.js'));
		Meta.configs.setMultiple({
			'email:smtpTransport:enabled': '0',
			'email:custom:test': '',
'use strict';


const	assert = require('assert');
const async = require('async');
const request = require('request');
const nconf = require('nconf');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

const db = require('./mocks/databasemock');
const topics = require('../src/topics');
const posts = require('../src/posts');
const categories = require('../src/categories');
const privileges = require('../src/privileges');
const user = require('../src/user');
const groups = require('../src/groups');
const socketPosts = require('../src/socket.io/posts');
const socketTopics = require('../src/socket.io/topics');
const meta = require('../src/meta');
const helpers = require('./helpers');

describe('Post\'s', () => {
	let voterUid;
	let voteeUid;
	let globalModUid;
	let postData;
	let topicData;
	let cid;

	before((done) => {
		async.series({
			voterUid: function (next) {
				user.create({ username: 'upvoter' }, next);
			},
			voteeUid: function (next) {
				user.create({ username: 'upvotee' }, next);
			},
			globalModUid: function (next) {
				user.create({ username: 'globalmod', password: 'globalmodpwd' }, next);
			},
			category: function (next) {
				categories.create({
					name: 'Test Category',
					description: 'Test category created by testing script',
				}, next);
			},
		}, (err, results) => {
			if (err) {
				return done(err);
			}

			voterUid = results.voterUid;
			voteeUid = results.voteeUid;
			globalModUid = results.globalModUid;
			cid = results.category.cid;

			topics.post({
				uid: results.voteeUid,
				cid: results.category.cid,
				title: 'Test Topic Title',
				content: 'The content of test topic',
			}, (err, data) => {
				if (err) {
					return done(err);
				}
				postData = data.postData;
				topicData = data.topicData;

				groups.join('Global Moderators', globalModUid, done);
			});
		});
	});

	it('should update category teaser properly', async () => {
		const util = require('util');
		const getCategoriesAsync = util.promisify(async (callback) => {
			request(`${nconf.get('url')}/api/categories`, { json: true }, (err, res, body) => {
				callback(err, body);
			});
		});

		const postResult = await topics.post({ uid: globalModUid, cid: cid, title: 'topic title', content: '123456789' });

		let data = await getCategoriesAsync();
		assert.equal(data.categories[0].teaser.pid, postResult.postData.pid);
		assert.equal(data.categories[0].posts[0].content, '123456789');
		assert.equal(data.categories[0].posts[0].pid, postResult.postData.pid);

		const newUid = await user.create({ username: 'teaserdelete' });
		const newPostResult = await topics.post({ uid: newUid, cid: cid, title: 'topic title', content: 'xxxxxxxx' });

		data = await getCategoriesAsync();
		assert.equal(data.categories[0].teaser.pid, newPostResult.postData.pid);
		assert.equal(data.categories[0].posts[0].content, 'xxxxxxxx');
		assert.equal(data.categories[0].posts[0].pid, newPostResult.postData.pid);

		await user.delete(1, newUid);

		data = await getCategoriesAsync();
		assert.equal(data.categories[0].teaser.pid, postResult.postData.pid);
		assert.equal(data.categories[0].posts[0].content, '123456789');
		assert.equal(data.categories[0].posts[0].pid, postResult.postData.pid);
	});

	it('should change owner of post and topic properly', async () => {
		const oldUid = await user.create({ username: 'olduser' });
		const newUid = await user.create({ username: 'newuser' });
		const postResult = await topics.post({ uid: oldUid, cid: cid, title: 'change owner', content: 'original post' });
		const postData = await topics.reply({ uid: oldUid, tid: postResult.topicData.tid, content: 'firstReply' });
		const pid1 = postResult.postData.pid;
		const pid2 = postData.pid;

		assert.deepStrictEqual(await db.sortedSetScores(`tid:${postResult.topicData.tid}:posters`, [oldUid, newUid]), [2, null]);

		await posts.changeOwner([pid1, pid2], newUid);

		assert.deepStrictEqual(await db.sortedSetScores(`tid:${postResult.topicData.tid}:posters`, [oldUid, newUid]), [0, 2]);

		assert.deepStrictEqual(await posts.isOwner([pid1, pid2], oldUid), [false, false]);
		assert.deepStrictEqual(await posts.isOwner([pid1, pid2], newUid), [true, true]);

		assert.strictEqual(await user.getUserField(oldUid, 'postcount'), 0);
		assert.strictEqual(await user.getUserField(newUid, 'postcount'), 2);

		assert.strictEqual(await user.getUserField(oldUid, 'topiccount'), 0);
		assert.strictEqual(await user.getUserField(newUid, 'topiccount'), 1);

		assert.strictEqual(await db.sortedSetScore('users:postcount', oldUid), 0);
		assert.strictEqual(await db.sortedSetScore('users:postcount', newUid), 2);

		assert.strictEqual(await topics.isOwner(postResult.topicData.tid, oldUid), false);
		assert.strictEqual(await topics.isOwner(postResult.topicData.tid, newUid), true);
	});

	it('should fail to change owner if new owner does not exist', async () => {
		try {
			await posts.changeOwner([1], '9999999');
		} catch (err) {
			assert.strictEqual(err.message, '[[error:no-user]]');
		}
	});

	it('should fail to change owner if user is not authorized', async () => {
		try {
			await socketPosts.changeOwner({ uid: voterUid }, { pids: [1, 2], toUid: voterUid });
		} catch (err) {
			assert.strictEqual(err.message, '[[error:no-privileges]]');
		}
	});

	it('should return falsy if post does not exist', (done) => {
		posts.getPostData(9999, (err, postData) => {
			assert.ifError(err);
			assert.equal(postData, null);
			done();
		});
	});

	describe('voting', () => {
		it('should fail to upvote post if group does not have upvote permission', (done) => {
			privileges.categories.rescind(['groups:posts:upvote', 'groups:posts:downvote'], cid, 'registered-users', (err) => {
				assert.ifError(err);
				socketPosts.upvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err) => {
					assert.equal(err.message, '[[error:no-privileges]]');
					socketPosts.downvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err) => {
						assert.equal(err.message, '[[error:no-privileges]]');
						privileges.categories.give(['groups:posts:upvote', 'groups:posts:downvote'], cid, 'registered-users', (err) => {
							assert.ifError(err);
							done();
						});
					});
				});
			});
		});

		it('should upvote a post', (done) => {
			socketPosts.upvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {
				assert.ifError(err);
				assert.equal(result.post.upvotes, 1);
				assert.equal(result.post.downvotes, 0);
				assert.equal(result.post.votes, 1);
				assert.equal(result.user.reputation, 1);
				posts.hasVoted(postData.pid, voterUid, (err, data) => {
					assert.ifError(err);
					assert.equal(data.upvoted, true);
					assert.equal(data.downvoted, false);
					done();
				});
			});
		});

		it('should get voters', (done) => {
			socketPosts.getVoters({ uid: globalModUid }, { pid: postData.pid, cid: cid }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.upvoteCount, 1);
				assert.equal(data.downvoteCount, 0);
				assert(Array.isArray(data.upvoters));
				assert.equal(data.upvoters[0].username, 'upvoter');
				done();
			});
		});

		it('should get upvoters', (done) => {
			socketPosts.getUpvoters({ uid: globalModUid }, [postData.pid], (err, data) => {
				assert.ifError(err);
				assert.equal(data[0].otherCount, 0);
				assert.equal(data[0].usernames, 'upvoter');
				done();
			});
		});

		it('should unvote a post', (done) => {
			socketPosts.unvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {
				assert.ifError(err);
				assert.equal(result.post.upvotes, 0);
				assert.equal(result.post.downvotes, 0);
				assert.equal(result.post.votes, 0);
				assert.equal(result.user.reputation, 0);
				posts.hasVoted(postData.pid, voterUid, (err, data) => {
					assert.ifError(err);
					assert.equal(data.upvoted, false);
					assert.equal(data.downvoted, false);
					done();
				});
			});
		});

		it('should downvote a post', (done) => {
			socketPosts.downvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {
				assert.ifError(err);
				assert.equal(result.post.upvotes, 0);
				assert.equal(result.post.downvotes, 1);
				assert.equal(result.post.votes, -1);
				assert.equal(result.user.reputation, -1);
				posts.hasVoted(postData.pid, voterUid, (err, data) => {
					assert.ifError(err);
					assert.equal(data.upvoted, false);
					assert.equal(data.downvoted, true);
					done();
				});
			});
		});

		it('should prevent downvoting more than total daily limit', async () => {
			const oldValue = meta.config.downvotesPerDay;
			meta.config.downvotesPerDay = 1;
			let err;
			const p1 = await topics.reply({
				uid: voteeUid,
				tid: topicData.tid,
				content: 'raw content',
			});
			try {
				await socketPosts.downvote({ uid: voterUid }, { pid: p1.pid, room_id: 'topic_1' });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, '[[error:too-many-downvotes-today, 1]]');
			meta.config.downvotesPerDay = oldValue;
		});

		it('should prevent downvoting target user more than total daily limit', async () => {
			const oldValue = meta.config.downvotesPerUserPerDay;
			meta.config.downvotesPerUserPerDay = 1;
			let err;
			const p1 = await topics.reply({
				uid: voteeUid,
				tid: topicData.tid,
				content: 'raw content',
			});
			try {
				await socketPosts.downvote({ uid: voterUid }, { pid: p1.pid, room_id: 'topic_1' });
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, '[[error:too-many-downvotes-today-user, 1]]');
			meta.config.downvotesPerUserPerDay = oldValue;
		});
	});

	describe('bookmarking', () => {
		it('should bookmark a post', (done) => {
			socketPosts.bookmark({ uid: voterUid }, { pid: postData.pid, room_id: `topic_${postData.tid}` }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.isBookmarked, true);
				posts.hasBookmarked(postData.pid, voterUid, (err, hasBookmarked) => {
					assert.ifError(err);
					assert.equal(hasBookmarked, true);
					done();
				});
			});
		});

		it('should unbookmark a post', (done) => {
			socketPosts.unbookmark({ uid: voterUid }, { pid: postData.pid, room_id: `topic_${postData.tid}` }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.isBookmarked, false);
				posts.hasBookmarked([postData.pid], voterUid, (err, hasBookmarked) => {
					assert.ifError(err);
					assert.equal(hasBookmarked[0], false);
					done();
				});
			});
		});
	});

	describe('post tools', () => {
		it('should error if data is invalid', (done) => {
			socketPosts.loadPostTools({ uid: globalModUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should load post tools', (done) => {
			socketPosts.loadPostTools({ uid: globalModUid }, { pid: postData.pid, cid: cid }, (err, data) => {
				assert.ifError(err);
				assert(data.posts.display_edit_tools);
				assert(data.posts.display_delete_tools);
				assert(data.posts.display_moderator_tools);
				assert(data.posts.display_move_tools);
				done();
			});
		});
	});

	describe('delete/restore/purge', () => {
		function createTopicWithReply(callback) {
			topics.post({
				uid: voterUid,
				cid: cid,
				title: 'topic to delete/restore/purge',
				content: 'A post to delete/restore/purge',
			}, (err, topicPostData) => {
				assert.ifError(err);
				topics.reply({
					uid: voterUid,
					tid: topicPostData.topicData.tid,
					timestamp: Date.now(),
					content: 'A post to delete/restore and purge',
				}, (err, replyData) => {
					assert.ifError(err);
					callback(topicPostData, replyData);
				});
			});
		}

		let tid;
		let mainPid;
		let replyPid;

		before((done) => {
			createTopicWithReply((topicPostData, replyData) => {
				tid = topicPostData.topicData.tid;
				mainPid = topicPostData.postData.pid;
				replyPid = replyData.pid;
				privileges.categories.give(['groups:purge'], cid, 'registered-users', done);
			});
		});

		it('should error with invalid data', (done) => {
			socketPosts.delete({ uid: voterUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should delete a post', (done) => {
			socketPosts.delete({ uid: voterUid }, { pid: replyPid, tid: tid }, (err) => {
				assert.ifError(err);
				posts.getPostField(replyPid, 'deleted', (err, isDeleted) => {
					assert.ifError(err);
					assert.strictEqual(isDeleted, 1);
					done();
				});
			});
		});

		it('should not see post content if global mod does not have posts:view_deleted privilege', (done) => {
			async.waterfall([
				function (next) {
					user.create({ username: 'global mod', password: '123456' }, next);
				},
				function (uid, next) {
					groups.join('Global Moderators', uid, next);
				},
				function (next) {
					privileges.categories.rescind(['groups:posts:view_deleted'], cid, 'Global Moderators', next);
				},
				function (next) {
					helpers.loginUser('global mod', '123456', (err, _jar) => {
						assert.ifError(err);
						const jar = _jar;

						request(`${nconf.get('url')}/api/topic/${tid}`, { jar: jar, json: true }, (err, res, body) => {
							assert.ifError(err);
							assert.equal(body.posts[1].content, '[[topic:post_is_deleted]]');
							privileges.categories.give(['groups:posts:view_deleted'], cid, 'Global Moderators', next);
						});
					});
				},
			], done);
		});

		it('should restore a post', (done) => {
			socketPosts.restore({ uid: voterUid }, { pid: replyPid, tid: tid }, (err) => {
				assert.ifError(err);
				posts.getPostField(replyPid, 'deleted', (err, isDeleted) => {
					assert.ifError(err);
					assert.strictEqual(isDeleted, 0);
					done();
				});
			});
		});

		it('should delete posts', (done) => {
			socketPosts.deletePosts({ uid: globalModUid }, { pids: [replyPid, mainPid] }, (err) => {
				assert.ifError(err);
				posts.getPostField(replyPid, 'deleted', (err, deleted) => {
					assert.ifError(err);
					assert.strictEqual(deleted, 1);
					posts.getPostField(mainPid, 'deleted', (err, deleted) => {
						assert.ifError(err);
						assert.strictEqual(deleted, 1);
						done();
					});
				});
			});
		});

		it('should delete topic if last main post is deleted', (done) => {
			topics.post({ uid: voterUid, cid: cid, title: 'test topic', content: 'test topic' }, (err, data) => {
				assert.ifError(err);
				socketPosts.deletePosts({ uid: globalModUid }, { pids: [data.postData.pid] }, (err) => {
					assert.ifError(err);
					topics.getTopicField(data.topicData.tid, 'deleted', (err, deleted) => {
						assert.ifError(err);
						assert.strictEqual(deleted, 1);
						done();
					});
				});
			});
		});

		it('should purge posts and purge topic', (done) => {
			createTopicWithReply((topicPostData, replyData) => {
				socketPosts.purgePosts({ uid: voterUid }, {
					pids: [replyData.pid, topicPostData.postData.pid],
					tid: topicPostData.topicData.tid,
				}, (err) => {
					assert.ifError(err);
					posts.exists(`post:${replyData.pid}`, (err, exists) => {
						assert.ifError(err);
						assert.equal(exists, false);
						topics.exists(topicPostData.topicData.tid, (err, exists) => {
							assert.ifError(err);
							assert(!exists);
							done();
						});
					});
				});
			});
		});
	});

	describe('edit', () => {
		let pid;
		let replyPid;
		let tid;
		before((done) => {
			topics.post({
				uid: voterUid,
				cid: cid,
				title: 'topic to edit',
				content: 'A post to edit',
			}, (err, data) => {
				assert.ifError(err);
				pid = data.postData.pid;
				tid = data.topicData.tid;
				topics.reply({
					uid: voterUid,
					tid: tid,
					timestamp: Date.now(),
					content: 'A reply to edit',
				}, (err, data) => {
					assert.ifError(err);
					replyPid = data.pid;
					privileges.categories.give(['groups:posts:edit'], cid, 'registered-users', done);
				});
			});
		});

		it('should error if user is not logged in', (done) => {
			socketPosts.edit({ uid: 0 }, {}, (err) => {
				assert.equal(err.message, '[[error:not-logged-in]]');
				done();
			});
		});

		it('should error if data is invalid or missing', (done) => {
			socketPosts.edit({ uid: voterUid }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if title is too short', (done) => {
			socketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', title: 'a' }, (err) => {
				assert.equal(err.message, `[[error:title-too-short, ${meta.config.minimumTitleLength}]]`);
				done();
			});
		});

		it('should error if title is too long', (done) => {
			const longTitle = new Array(meta.config.maximumTitleLength + 2).join('a');
			socketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', title: longTitle }, (err) => {
				assert.equal(err.message, `[[error:title-too-long, ${meta.config.maximumTitleLength}]]`);
				done();
			});
		});

		it('should error with too few tags', (done) => {
			const oldValue = meta.config.minimumTagsPerTopic;
			meta.config.minimumTagsPerTopic = 1;
			socketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', tags: [] }, (err) => {
				assert.equal(err.message, `[[error:not-enough-tags, ${meta.config.minimumTagsPerTopic}]]`);
				meta.config.minimumTagsPerTopic = oldValue;
				done();
			});
		});

		it('should error with too many tags', (done) => {
			const tags = [];
			for (let i = 0; i < meta.config.maximumTagsPerTopic + 1; i += 1) {
				tags.push(`tag${i}`);
			}
			socketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', tags: tags }, (err) => {
				assert.equal(err.message, `[[error:too-many-tags, ${meta.config.maximumTagsPerTopic}]]`);
				done();
			});
		});

		it('should error if content is too short', (done) => {
			socketPosts.edit({ uid: voterUid }, { pid: pid, content: 'e' }, (err) => {
				assert.equal(err.message, `[[error:content-too-short, ${meta.config.minimumPostLength}]]`);
				done();
			});
		});

		it('should error if content is too long', (done) => {
			const longContent = new Array(meta.config.maximumPostLength + 2).join('a');
			socketPosts.edit({ uid: voterUid }, { pid: pid, content: longContent }, (err) => {
				assert.equal(err.message, `[[error:content-too-long, ${meta.config.maximumPostLength}]]`);
				done();
			});
		});

		it('should edit post', async () => {
			const data = await socketPosts.edit({ uid: voterUid }, {
				pid: pid,
				content: 'edited post content',
				title: 'edited title',
				tags: ['edited'],
			});

			assert.strictEqual(data.content, 'edited post content');
			assert.strictEqual(data.editor, voterUid);
			assert.strictEqual(data.topic.title, 'edited title');
			assert.strictEqual(data.topic.tags[0].value, 'edited');
			const res = await db.getObject(`post:${pid}`);
			assert(!res.hasOwnProperty('bookmarks'));
		});

		it('should disallow post editing for new users if post was made past the threshold for editing', (done) => {
			meta.config.newbiePostEditDuration = 1;
			setTimeout(() => {
				socketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content again', title: 'edited title again', tags: ['edited-twice'] }, (err, data) => {
					assert.equal(err.message, '[[error:post-edit-duration-expired, 1]]');
					meta.config.newbiePostEditDuration = 3600;
					done();
				});
			}, 1000);
		});

		it('should edit a deleted post', (done) => {
			socketPosts.delete({ uid: voterUid }, { pid: pid, tid: tid }, (err) => {
				assert.ifError(err);
				socketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited deleted content', title: 'edited deleted title', tags: ['deleted'] }, (err, data) => {
					assert.ifError(err);
					assert.equal(data.content, 'edited deleted content');
					assert.equal(data.editor, voterUid);
					assert.equal(data.topic.title, 'edited deleted title');
					assert.equal(data.topic.tags[0].value, 'deleted');
					done();
				});
			});
		});

		it('should edit a reply post', (done) => {
			socketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'edited reply' }, (err, data) => {
				assert.ifError(err);
				assert.equal(data.content, 'edited reply');
				assert.equal(data.editor, voterUid);
				assert.equal(data.topic.isMainPost, false);
				assert.equal(data.topic.renamed, false);
				done();
			});
		});

		it('should return diffs', (done) => {
			posts.diffs.get(replyPid, 0, (err, data) => {
				assert.ifError(err);
				assert(Array.isArray(data));
				assert(data[0].pid, replyPid);
				assert(data[0].patch);
				done();
			});
		});

		it('should load diffs and reconstruct post', (done) => {
			posts.diffs.load(replyPid, 0, voterUid, (err, data) => {
				assert.ifError(err);
				assert.equal(data.content, 'A reply to edit');
				done();
			});
		});

		it('should not allow guests to view diffs', (done) => {
			socketPosts.getDiffs({ uid: 0 }, { pid: 1 }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should allow registered-users group to view diffs', (done) => {
			socketPosts.getDiffs({ uid: 1 }, { pid: 1 }, (err, data) => {
				assert.ifError(err);

				assert.strictEqual('boolean', typeof data.editable);
				assert.strictEqual(false, data.editable);

				assert.equal(true, Array.isArray(data.timestamps));
				assert.strictEqual(1, data.timestamps.length);

				assert.equal(true, Array.isArray(data.revisions));
				assert.strictEqual(data.timestamps.length, data.revisions.length);
				['timestamp', 'username'].every(prop => Object.keys(data.revisions[0]).includes(prop));
				done();
			});
		});

		it('should not delete first diff of a post', async () => {
			const timestamps = await posts.diffs.list(replyPid);
			await assert.rejects(async () => {
				await posts.diffs.delete(replyPid, timestamps[0], voterUid);
			}, {
				message: '[[error:invalid-data]]',
			});
		});

		it('should delete a post diff', async () => {
			await socketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'another edit has been made' });
			await socketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'most recent edit' });
			const timestamp = (await posts.diffs.list(replyPid)).pop();
			await posts.diffs.delete(replyPid, timestamp, voterUid);
			const differentTimestamp = (await posts.diffs.list(replyPid)).pop();
			assert.notStrictEqual(timestamp, differentTimestamp);
		});

		it('should load (oldest) diff and reconstruct post correctly after a diff deletion', async () => {
			const data = await posts.diffs.load(replyPid, 0, voterUid);
			assert.strictEqual(data.content, 'A reply to edit');
		});
	});

	describe('move', () => {
		let replyPid;
		let tid;
		let moveTid;

		before((done) => {
			async.waterfall([
				function (next) {
					topics.post({
						uid: voterUid,
						cid: cid,
						title: 'topic 1',
						content: 'some content',
					}, next);
				},
				function (data, next) {
					tid = data.topicData.tid;
					topics.post({
						uid: voterUid,
						cid: cid,
						title: 'topic 2',
						content: 'some content',
					}, next);
				},
				function (data, next) {
					moveTid = data.topicData.tid;
					topics.reply({
						uid: voterUid,
						tid: tid,
						timestamp: Date.now(),
						content: 'A reply to move',
					}, (err, data) => {
						assert.ifError(err);
						replyPid = data.pid;
						next();
					});
				},
			], done);
		});

		it('should error if uid is not logged in', (done) => {
			socketPosts.movePost({ uid: 0 }, {}, (err) => {
				assert.equal(err.message, '[[error:not-logged-in]]');
				done();
			});
		});

		it('should error if data is invalid', (done) => {
			socketPosts.movePost({ uid: globalModUid }, {}, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error if user does not have move privilege', (done) => {
			socketPosts.movePost({ uid: voterUid }, { pid: replyPid, tid: moveTid }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});


		it('should move a post', (done) => {
			socketPosts.movePost({ uid: globalModUid }, { pid: replyPid, tid: moveTid }, (err) => {
				assert.ifError(err);
				posts.getPostField(replyPid, 'tid', (err, tid) => {
					assert.ifError(err);
					assert(tid, moveTid);
					done();
				});
			});
		});

		it('should fail to move post if not moderator of target category', async () => {
			const cat1 = await categories.create({ name: 'Test Category', description: 'Test category created by testing script' });
			const cat2 = await categories.create({ name: 'Test Category', description: 'Test category created by testing script' });
			const result = await socketTopics.post({ uid: globalModUid }, { title: 'target topic', content: 'queued topic', cid: cat2.cid });
			const modUid = await user.create({ username: 'modofcat1' });
			await privileges.categories.give(privileges.categories.userPrivilegeList, cat1.cid, modUid);
			let err;
			try {
				await socketPosts.movePost({ uid: modUid }, { pid: replyPid, tid: result.tid });
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, '[[error:no-privileges]]');
		});
	});

	describe('getPostSummaryByPids', () => {
		it('should return empty array for empty pids', (done) => {
			posts.getPostSummaryByPids([], 0, {}, (err, data) => {
				assert.ifError(err);
				assert.equal(data.length, 0);
				done();
			});
		});

		it('should get post summaries', (done) => {
			posts.getPostSummaryByPids([postData.pid], 0, {}, (err, data) => {
				assert.ifError(err);
				assert(data[0].user);
				assert(data[0].topic);
				assert(data[0].category);
				done();
			});
		});
	});

	it('should get recent poster uids', (done) => {
		topics.reply({
			uid: voterUid,
			tid: topicData.tid,
			timestamp: Date.now(),
			content: 'some content',
		}, (err) => {
			assert.ifError(err);
			posts.getRecentPosterUids(0, 1, (err, uids) => {
				assert.ifError(err);
				assert(Array.isArray(uids));
				assert.equal(uids.length, 2);
				assert.equal(uids[0], voterUid);
				done();
			});
		});
	});

	describe('parse', () => {
		it('should not crash and return falsy if post data is falsy', (done) => {
			posts.parsePost(null, (err, postData) => {
				assert.ifError(err);
				assert.strictEqual(postData, null);
				done();
			});
		});

		it('should store post content in cache', (done) => {
			const oldValue = global.env;
			global.env = 'production';
			const postData = {
				pid: 9999,
				content: 'some post content',
			};
			posts.parsePost(postData, (err) => {
				assert.ifError(err);
				posts.parsePost(postData, (err) => {
					assert.ifError(err);
					global.env = oldValue;
					done();
				});
			});
		});

		it('should parse signature and remove links and images', (done) => {
			meta.config['signatures:disableLinks'] = 1;
			meta.config['signatures:disableImages'] = 1;
			const userData = {
				signature: '<img src="boop"/><a href="link">test</a> derp',
			};

			posts.parseSignature(userData, 1, (err, data) => {
				assert.ifError(err);
				assert.equal(data.userData.signature, 'test derp');
				meta.config['signatures:disableLinks'] = 0;
				meta.config['signatures:disableImages'] = 0;
				done();
			});
		});

		it('should turn relative links in post body to absolute urls', (done) => {
			const nconf = require('nconf');
			const content = '<a href="/users">test</a> <a href="youtube.com">youtube</a>';
			const parsedContent = posts.relativeToAbsolute(content, posts.urlRegex);
			assert.equal(parsedContent, `<a href="${nconf.get('base_url')}/users">test</a> <a href="//youtube.com">youtube</a>`);
			done();
		});

		it('should turn relative links in post body to absolute urls', (done) => {
			const nconf = require('nconf');
			const content = '<a href="/users">test</a> <a href="youtube.com">youtube</a> some test <img src="/path/to/img"/>';
			let parsedContent = posts.relativeToAbsolute(content, posts.urlRegex);
			parsedContent = posts.relativeToAbsolute(parsedContent, posts.imgRegex);
			assert.equal(parsedContent, `<a href="${nconf.get('base_url')}/users">test</a> <a href="//youtube.com">youtube</a> some test <img src="${nconf.get('base_url')}/path/to/img"/>`);
			done();
		});
	});

	describe('socket methods', () => {
		let pid;
		before((done) => {
			topics.reply({
				uid: voterUid,
				tid: topicData.tid,
				timestamp: Date.now(),
				content: 'raw content',
			}, (err, postData) => {
				assert.ifError(err);
				pid = postData.pid;
				privileges.categories.rescind(['groups:topics:read'], cid, 'guests', done);
			});
		});

		it('should error with invalid data', (done) => {
			socketPosts.reply({ uid: 0 }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should error with invalid tid', (done) => {
			socketPosts.reply({ uid: 0 }, { tid: 0, content: 'derp' }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should fail to get raw post because of privilege', (done) => {
			socketPosts.getRawPost({ uid: 0 }, pid, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should fail to get raw post because post is deleted', (done) => {
			posts.setPostField(pid, 'deleted', 1, (err) => {
				assert.ifError(err);
				socketPosts.getRawPost({ uid: voterUid }, pid, (err) => {
					assert.equal(err.message, '[[error:no-post]]');
					done();
				});
			});
		});

		it('should get raw post content', (done) => {
			posts.setPostField(pid, 'deleted', 0, (err) => {
				assert.ifError(err);
				socketPosts.getRawPost({ uid: voterUid }, pid, (err, postContent) => {
					assert.ifError(err);
					assert.equal(postContent, 'raw content');
					done();
				});
			});
		});

		it('should get post', (done) => {
			socketPosts.getPost({ uid: voterUid }, pid, (err, postData) => {
				assert.ifError(err);
				assert(postData);
				done();
			});
		});

		it('should get post category', (done) => {
			socketPosts.getCategory({ uid: voterUid }, pid, (err, postCid) => {
				assert.ifError(err);
				assert.equal(cid, postCid);
				done();
			});
		});

		it('should error with invalid data', (done) => {
			socketPosts.getPidIndex({ uid: voterUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should get pid index', (done) => {
			socketPosts.getPidIndex({ uid: voterUid }, { pid: pid, tid: topicData.tid, topicPostSort: 'oldest_to_newest' }, (err, index) => {
				assert.ifError(err);
				assert.equal(index, 4);
				done();
			});
		});

		it('should get pid index in reverse', (done) => {
			topics.reply({
				uid: voterUid,
				tid: topicData.tid,
				content: 'raw content',
			}, (err, postData) => {
				assert.ifError(err);

				socketPosts.getPidIndex({ uid: voterUid }, { pid: postData.pid, tid: topicData.tid, topicPostSort: 'newest_to_oldest' }, (err, index) => {
					assert.ifError(err);
					assert.equal(index, 1);
					done();
				});
			});
		});
	});

	describe('filterPidsByCid', () => {
		it('should return pids as is if cid is falsy', (done) => {
			posts.filterPidsByCid([1, 2, 3], null, (err, pids) => {
				assert.ifError(err);
				assert.deepEqual([1, 2, 3], pids);
				done();
			});
		});

		it('should filter pids by single cid', (done) => {
			posts.filterPidsByCid([postData.pid, 100, 101], cid, (err, pids) => {
				assert.ifError(err);
				assert.deepEqual([postData.pid], pids);
				done();
			});
		});

		it('should filter pids by multiple cids', (done) => {
			posts.filterPidsByCid([postData.pid, 100, 101], [cid, 2, 3], (err, pids) => {
				assert.ifError(err);
				assert.deepEqual([postData.pid], pids);
				done();
			});
		});

		it('should filter pids by multiple cids', (done) => {
			posts.filterPidsByCid([postData.pid, 100, 101], [cid], (err, pids) => {
				assert.ifError(err);
				assert.deepEqual([postData.pid], pids);
				done();
			});
		});
	});

	it('should error if user does not exist', (done) => {
		user.isReadyToPost(21123123, 1, (err) => {
			assert.equal(err.message, '[[error:no-user]]');
			done();
		});
	});

	describe('post queue', () => {
		let uid;
		let queueId;
		let topicQueueId;
		let jar;
		before((done) => {
			meta.config.postQueue = 1;
			user.create({ username: 'newuser' }, (err, _uid) => {
				assert.ifError(err);
				uid = _uid;
				done();
			});
		});

		after((done) => {
			meta.config.postQueue = 0;
			meta.config.groupsExemptFromPostQueue = [];
			done();
		});

		it('should add topic to post queue', (done) => {
			socketTopics.post({ uid: uid }, { title: 'should be queued', content: 'queued topic content', cid: cid }, (err, result) => {
				assert.ifError(err);
				assert.strictEqual(result.queued, true);
				assert.equal(result.message, '[[success:post-queued]]');
				topicQueueId = result.id;

				done();
			});
		});

		it('should add reply to post queue', (done) => {
			socketPosts.reply({ uid: uid }, { content: 'this is a queued reply', tid: topicData.tid }, (err, result) => {
				assert.ifError(err);
				assert.strictEqual(result.queued, true);
				assert.equal(result.message, '[[success:post-queued]]');
				queueId = result.id;
				done();
			});
		});

		it('should load queued posts', (done) => {
			helpers.loginUser('globalmod', 'globalmodpwd', (err, _jar) => {
				jar = _jar;
				assert.ifError(err);
				request(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(body.posts[0].type, 'topic');
					assert.equal(body.posts[0].data.content, 'queued topic content');
					assert.equal(body.posts[1].type, 'reply');
					assert.equal(body.posts[1].data.content, 'this is a queued reply');
					done();
				});
			});
		});

		it('should error if data is invalid', (done) => {
			socketPosts.editQueuedContent({ uid: globalModUid }, null, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should edit post in queue', (done) => {
			socketPosts.editQueuedContent({ uid: globalModUid }, { id: queueId, content: 'newContent' }, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(body.posts[1].type, 'reply');
					assert.equal(body.posts[1].data.content, 'newContent');
					done();
				});
			});
		});

		it('should edit topic title in queue', (done) => {
			socketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, title: 'new topic title' }, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(body.posts[0].type, 'topic');
					assert.equal(body.posts[0].data.title, 'new topic title');
					done();
				});
			});
		});

		it('should edit topic category in queue', (done) => {
			socketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, cid: 2 }, (err) => {
				assert.ifError(err);
				request(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {
					assert.ifError(err);
					assert.equal(body.posts[0].type, 'topic');
					assert.equal(body.posts[0].data.cid, 2);
					socketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, cid: cid }, (err) => {
						assert.ifError(err);
						done();
					});
				});
			});
		});

		it('should prevent regular users from approving posts', (done) => {
			socketPosts.accept({ uid: uid }, { id: queueId }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should prevent regular users from approving non existing posts', (done) => {
			socketPosts.accept({ uid: uid }, { id: 123123 }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should accept queued posts and submit', (done) => {
			let ids;
			async.waterfall([
				function (next) {
					db.getSortedSetRange('post:queue', 0, -1, next);
				},
				function (_ids, next) {
					ids = _ids;
					socketPosts.accept({ uid: globalModUid }, { id: ids[0] }, next);
				},
				function (next) {
					socketPosts.accept({ uid: globalModUid }, { id: ids[1] }, next);
				},
			], done);
		});

		it('should not crash if id does not exist', (done) => {
			socketPosts.reject({ uid: globalModUid }, { id: '123123123' }, (err) => {
				assert.equal(err.message, '[[error:no-privileges]]');
				done();
			});
		});

		it('should bypass post queue if user is in exempt group', (done) => {
			meta.config.groupsExemptFromPostQueue = ['registered-users'];
			socketTopics.post({ uid: uid, emit: () => {} }, { title: 'should not be queued', content: 'topic content', cid: cid }, (err, result) => {
				assert.ifError(err);
				assert.strictEqual(result.title, 'should not be queued');
				done();
			});
		});
	});

	describe('upload methods', () => {
		let pid;
		let purgePid;

		before(async () => {
			// Create stub files for testing
			['abracadabra.png', 'shazam.jpg', 'whoa.gif', 'amazeballs.jpg', 'wut.txt', 'test.bmp']
				.forEach(filename => fs.closeSync(fs.openSync(path.join(nconf.get('upload_path'), 'files', filename), 'w')));

			const topicPostData = await topics.post({
				uid: 1,
				cid: 1,
				title: 'topic with some images',
				content: 'here is an image [alt text](/assets/uploads/files/abracadabra.png) and another [alt text](/assets/uploads/files/shazam.jpg)',
			});
			pid = topicPostData.postData.pid;

			const purgePostData = await topics.post({
				uid: 1,
				cid: 1,
				title: 'topic with some images, to be purged',
				content: 'here is an image [alt text](/assets/uploads/files/whoa.gif) and another [alt text](/assets/uploads/files/amazeballs.jpg)',
			});
			purgePid = purgePostData.postData.pid;
		});

		describe('.sync()', () => {
			it('should properly add new images to the post\'s zset', (done) => {
				posts.uploads.sync(pid, (err) => {
					assert.ifError(err);

					db.sortedSetCard(`post:${pid}:uploads`, (err, length) => {
						assert.ifError(err);
						assert.strictEqual(length, 2);
						done();
					});
				});
			});

			it('should remove an image if it is edited out of the post', (done) => {
				async.series([
					function (next) {
						posts.edit({
							pid: pid,
							uid: 1,
							content: 'here is an image [alt text](/assets/uploads/files/abracadabra.png)... AND NO MORE!',
						}, next);
					},
					async.apply(posts.uploads.sync, pid),
				], (err) => {
					assert.ifError(err);
					db.sortedSetCard(`post:${pid}:uploads`, (err, length) => {
						assert.ifError(err);
						assert.strictEqual(1, length);
						done();
					});
				});
			});
		});

		describe('.list()', () => {
			it('should display the uploaded files for a specific post', (done) => {
				posts.uploads.list(pid, (err, uploads) => {
					assert.ifError(err);
					assert.equal(true, Array.isArray(uploads));
					assert.strictEqual(1, uploads.length);
					assert.equal('string', typeof uploads[0]);
					done();
				});
			});
		});

		describe('.isOrphan()', () => {
			it('should return false if upload is not an orphan', (done) => {
				posts.uploads.isOrphan('abracadabra.png', (err, isOrphan) => {
					assert.ifError(err);
					assert.equal(false, isOrphan);
					done();
				});
			});

			it('should return true if upload is an orphan', (done) => {
				posts.uploads.isOrphan('shazam.jpg', (err, isOrphan) => {
					assert.ifError(err);
					assert.equal(true, isOrphan);
					done();
				});
			});
		});

		describe('.associate()', () => {
			it('should add an image to the post\'s maintained list of uploads', (done) => {
				async.waterfall([
					async.apply(posts.uploads.associate, pid, 'whoa.gif'),
					async.apply(posts.uploads.list, pid),
				], (err, uploads) => {
					assert.ifError(err);
					assert.strictEqual(2, uploads.length);
					assert.strictEqual(true, uploads.includes('whoa.gif'));
					done();
				});
			});

			it('should allow arrays to be passed in', (done) => {
				async.waterfall([
					async.apply(posts.uploads.associate, pid, ['amazeballs.jpg', 'wut.txt']),
					async.apply(posts.uploads.list, pid),
				], (err, uploads) => {
					assert.ifError(err);
					assert.strictEqual(4, uploads.length);
					assert.strictEqual(true, uploads.includes('amazeballs.jpg'));
					assert.strictEqual(true, uploads.includes('wut.txt'));
					done();
				});
			});

			it('should save a reverse association of md5sum to pid', (done) => {
				const md5 = filename => crypto.createHash('md5').update(filename).digest('hex');

				async.waterfall([
					async.apply(posts.uploads.associate, pid, ['test.bmp']),
					function (next) {
						db.getSortedSetRange(`upload:${md5('test.bmp')}:pids`, 0, -1, next);
					},
				], (err, pids) => {
					assert.ifError(err);
					assert.strictEqual(true, Array.isArray(pids));
					assert.strictEqual(true, pids.length > 0);
					assert.equal(pid, pids[0]);
					done();
				});
			});

			it('should not associate a file that does not exist on the local disk', (done) => {
				async.waterfall([
					async.apply(posts.uploads.associate, pid, ['nonexistant.xls']),
					async.apply(posts.uploads.list, pid),
				], (err, uploads) => {
					assert.ifError(err);
					assert.strictEqual(uploads.length, 5);
					assert.strictEqual(false, uploads.includes('nonexistant.xls'));
					done();
				});
			});
		});

		describe('.dissociate()', () => {
			it('should remove an image from the post\'s maintained list of uploads', (done) => {
				async.waterfall([
					async.apply(posts.uploads.dissociate, pid, 'whoa.gif'),
					async.apply(posts.uploads.list, pid),
				], (err, uploads) => {
					assert.ifError(err);
					assert.strictEqual(4, uploads.length);
					assert.strictEqual(false, uploads.includes('whoa.gif'));
					done();
				});
			});

			it('should allow arrays to be passed in', (done) => {
				async.waterfall([
					async.apply(posts.uploads.dissociate, pid, ['amazeballs.jpg', 'wut.txt']),
					async.apply(posts.uploads.list, pid),
				], (err, uploads) => {
					assert.ifError(err);
					assert.strictEqual(2, uploads.length);
					assert.strictEqual(false, uploads.includes('amazeballs.jpg'));
					assert.strictEqual(false, uploads.includes('wut.txt'));
					done();
				});
			});
		});

		describe('.dissociateAll()', () => {
			it('should remove all images from a post\'s maintained list of uploads', async () => {
				await posts.uploads.dissociateAll(pid);
				const uploads = await posts.uploads.list(pid);

				assert.equal(uploads.length, 0);
			});
		});

		describe('Dissociation on purge', () => {
			it('should not dissociate images on post deletion', async () => {
				await posts.delete(purgePid, 1);
				const uploads = await posts.uploads.list(purgePid);

				assert.equal(uploads.length, 2);
			});

			it('should dissociate images on post purge', async () => {
				await posts.purge(purgePid, 1);
				const uploads = await posts.uploads.list(purgePid);

				assert.equal(uploads.length, 0);
			});
		});
	});

	describe('post uploads management', () => {
		let topic;
		let reply;
		before((done) => {
			topics.post({
				uid: 1,
				cid: cid,
				title: 'topic to test uploads with',
				content: '[abcdef](/assets/uploads/files/abracadabra.png)',
			}, (err, topicPostData) => {
				assert.ifError(err);
				topics.reply({
					uid: 1,
					tid: topicPostData.topicData.tid,
					timestamp: Date.now(),
					content: '[abcdef](/assets/uploads/files/shazam.jpg)',
				}, (err, replyData) => {
					assert.ifError(err);
					topic = topicPostData;
					reply = replyData;
					done();
				});
			});
		});

		it('should automatically sync uploads on topic create and reply', (done) => {
			db.sortedSetsCard([`post:${topic.topicData.mainPid}:uploads`, `post:${reply.pid}:uploads`], (err, lengths) => {
				assert.ifError(err);
				assert.strictEqual(1, lengths[0]);
				assert.strictEqual(1, lengths[1]);
				done();
			});
		});

		it('should automatically sync uploads on post edit', (done) => {
			async.waterfall([
				async.apply(posts.edit, {
					pid: reply.pid,
					uid: 1,
					content: 'no uploads',
				}),
				function (postData, next) {
					posts.uploads.list(reply.pid, next);
				},
			], (err, uploads) => {
				assert.ifError(err);
				assert.strictEqual(true, Array.isArray(uploads));
				assert.strictEqual(0, uploads.length);
				done();
			});
		});
	});
'use strict';

const assert = require('assert');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const pubsub = require('../src/pubsub');

describe('pubsub', () => {
	it('should use the plain event emitter', (done) => {
		nconf.set('isCluster', false);
		pubsub.reset();
		pubsub.on('testEvent', (message) => {
			assert.equal(message.foo, 1);
			pubsub.removeAllListeners('testEvent');
			done();
		});
		pubsub.publish('testEvent', { foo: 1 });
	});

	it('should use same event emitter', (done) => {
		pubsub.on('dummyEvent', (message) => {
			assert.equal(message.foo, 2);
			pubsub.removeAllListeners('dummyEvent');
			pubsub.reset();
			done();
		});
		pubsub.publish('dummyEvent', { foo: 2 });
	});

	it('should use singleHostCluster', (done) => {
		const oldValue = nconf.get('singleHostCluster');
		nconf.set('singleHostCluster', true);
		pubsub.on('testEvent', (message) => {
			assert.equal(message.foo, 3);
			nconf.set('singleHostCluster', oldValue);
			pubsub.removeAllListeners('testEvent');
			done();
		});
		pubsub.publish('testEvent', { foo: 3 });
	});

	it('should use same event emitter', (done) => {
		const oldValue = nconf.get('singleHostCluster');
		pubsub.on('dummyEvent', (message) => {
			assert.equal(message.foo, 4);
			nconf.set('singleHostCluster', oldValue);
			pubsub.removeAllListeners('dummyEvent');
			pubsub.reset();
			done();
'use strict';

const path = require('path');
const fs = require('fs');
const assert = require('assert');
const mkdirp = require('mkdirp');
const rimraf = require('rimraf');
const async = require('async');

const db = require('./mocks/databasemock');
const file = require('../src/file');

describe('minifier', () => {
	before(async () => {
		await mkdirp(path.join(__dirname, '../build/test'));
	});

	const minifier = require('../src/meta/minifier');
	const scripts = [
		path.resolve(__dirname, './files/1.js'),
		path.resolve(__dirname, './files/2.js'),
	].map(script => ({
		srcPath: script,
		destPath: path.resolve(__dirname, '../build/test', path.basename(script)),
		filename: path.basename(script),
	}));

	it('.js.bundle() should concat scripts', (done) => {
		const destPath = path.resolve(__dirname, '../build/test/concatenated.js');

		minifier.js.bundle({
			files: scripts,
			destPath: destPath,
			filename: 'concatenated.js',
		}, false, false, (err) => {
			assert.ifError(err);

			assert(file.existsSync(destPath));

			assert.strictEqual(
				fs.readFileSync(destPath).toString().replace(/\r\n/g, '\n'),
				'(function (window, document) {' +
				'\n\twindow.doStuff = function () {' +
				'\n\t\tdocument.body.innerHTML = \'Stuff has been done\';' +
				'\n\t};' +
				'\n})(window, document);' +
				'\n' +
				'\n;function foo(name, age) {' +
				'\n\treturn \'The person known as "\' + name + \'" is \' + age + \' years old\';' +
				'\n}' +
				'\n'
			);
			done();
		});
	});
	it('.js.bundle() should minify scripts', (done) => {
		const destPath = path.resolve(__dirname, '../build/test/minified.js');

		minifier.js.bundle({
			files: scripts,
			destPath: destPath,
			filename: 'minified.js',
		}, true, false, (err) => {
			assert.ifError(err);

			assert(file.existsSync(destPath));

			assert.strictEqual(
				fs.readFileSync(destPath).toString(),
				'(function(n,o){n.doStuff=function(){o.body.innerHTML="Stuff has been done"}})(window,document);function foo(n,o){return\'The person known as "\'+n+\'" is \'+o+" years old"}' +
				'\n//# sourceMappingURL=minified.js.map'
			);
			done();
		});
	});

	it('.js.minifyBatch() should minify each script', (done) => {
		minifier.js.minifyBatch(scripts, false, (err) => {
			assert.ifError(err);

			assert(file.existsSync(scripts[0].destPath));
			assert(file.existsSync(scripts[1].destPath));

			fs.readFile(scripts[0].destPath, (err, buffer) => {
				assert.ifError(err);
				assert.strictEqual(
					buffer.toString(),
					'(function(n,o){n.doStuff=function(){o.body.innerHTML="Stuff has been done"}})(window,document);' +
					'\n//# sourceMappingURL=1.js.map'
				);
				done();
			});
		});
	});

	const styles = [
		'@import (inline) "./1.css";',
		'@import "./2.less";',
	].join('\n');
	const paths = [
		path.resolve(__dirname, './files'),
	];
	it('.css.bundle() should concat styles', (done) => {
		minifier.css.bundle(styles, paths, false, false, (err, bundle) => {
			assert.ifError(err);
			assert.strictEqual(bundle.code, '.help { margin: 10px; } .yellow { background: yellow; }\n.help {\n  display: block;\n}\n.help .blue {\n  background: blue;\n}\n');
			done();
		});
	});

	it('.css.bundle() should minify styles', (done) => {
		minifier.css.bundle(styles, paths, true, false, (err, bundle) => {
			assert.ifError(err);
			assert.strictEqual(bundle.code, '.help{margin:10px}.yellow{background:#ff0}.help{display:block}.help .blue{background:#00f}');
			done();
		});
	});
});

describe('Build', (done) => {
	const build = require('../src/meta/build');

	before((done) => {
		async.parallel([
			async.apply(rimraf, path.join(__dirname, '../build/public')),
			async.apply(db.sortedSetAdd, 'plugins:active', Date.now(), 'nodebb-plugin-markdown'),
		], done);
	});

	it('should build plugin static dirs', (done) => {
		build.build(['plugin static dirs'], (err) => {
			assert.ifError(err);
			assert(file.existsSync(path.join(__dirname, '../build/public/plugins/nodebb-plugin-dbsearch/dbsearch')));
			done();
		});
	});

	it('should build requirejs modules', (done) => {
		build.build(['requirejs modules'], (err) => {
			assert.ifError(err);
			const filename = path.join(__dirname, '../build/public/src/modules/Chart.js');
			assert(file.existsSync(filename));
			assert(fs.readFileSync(filename).toString().startsWith('/*!\n * Chart.js'));
			done();
		});
	});

	it('should build client js bundle', (done) => {
		build.build(['client js bundle'], (err) => {
			assert.ifError(err);
			const filename = path.join(__dirname, '../build/public/nodebb.min.js');
			assert(file.existsSync(filename));
			assert(fs.readFileSync(filename).length > 1000);
			done();
		});
	});

	it('should build admin js bundle', (done) => {
		build.build(['admin js bundle'], (err) => {
			assert.ifError(err);
			const filename = path.join(__dirname, '../build/public/acp.min.js');
			assert(file.existsSync(filename));
			assert(fs.readFileSync(filename).length > 1000);
			done();
		});
	});

	it('should build client side styles', (done) => {
		build.build(['client side styles'], (err) => {
			assert.ifError(err);
			const filename = path.join(__dirname, '../build/public/client.css');
			assert(file.existsSync(filename));
			assert(fs.readFileSync(filename).toString().startsWith('/*! normalize.css'));
			done();
		});
	});

	it('should build admin control panel styles', (done) => {
		build.build(['admin control panel styles'], (err) => {
			assert.ifError(err);
			const filename = path.join(__dirname, '../build/public/admin.css');
			assert(file.existsSync(filename));
			const adminCSS = fs.readFileSync(filename).toString();
			if (global.env === 'production') {
				assert(adminCSS.startsWith('@charset "UTF-8";') || adminCSS.startsWith('@import url'));
			} else {
				assert(adminCSS.startsWith('.recent-replies'));
			}
			done();
		});
	});

	it('should build templates', function (done) {
		this.timeout(0);
		build.build(['templates'], (err) => {
			assert.ifError(err);
			const filename = path.join(__dirname, '../build/public/templates/admin/header.tpl');
			assert(file.existsSync(filename));
			assert(fs.readFileSync(filename).toString().startsWith('<!DOCTYPE html>'));
			done();
		});
	});

	it('should build languages', (done) => {
		build.build(['languages'], (err) => {
			assert.ifError(err);

			const globalFile = path.join(__dirname, '../build/public/language/en-GB/global.json');
			assert(file.existsSync(globalFile), 'global.json exists');
			const global = fs.readFileSync(globalFile).toString();
			assert.strictEqual(JSON.parse(global).home, 'Home', 'global.json contains correct translations');

			const mdFile = path.join(__dirname, '../build/public/language/en-GB/markdown.json');
			assert(file.existsSync(mdFile), 'markdown.json exists');
			const md = fs.readFileSync(mdFile).toString();
			assert.strictEqual(JSON.parse(md).bold, 'bolded text', 'markdown.json contains correct translations');

			done();
		});
	});
'use strict';

const assert = require('assert');
const async = require('async');

const db = require('./mocks/databasemock');
const meta = require('../src/meta');
const User = require('../src/user');
const Groups = require('../src/groups');

describe('rewards', () => {
	let adminUid;
	let bazUid;
	let herpUid;

	before((done) => {
		// Create 3 users: 1 admin, 2 regular
		async.series([
			async.apply(User.create, { username: 'foo' }),
			async.apply(User.create, { username: 'baz' }),
			async.apply(User.create, { username: 'herp' }),
		], (err, uids) => {
			if (err) {
				return done(err);
			}

			adminUid = uids[0];
			bazUid = uids[1];
			herpUid = uids[2];

			async.series([
				function (next) {
					Groups.join('administrators', adminUid, next);
				},
				function (next) {
					Groups.join('rewardGroup', adminUid, next);
				},
			], done);
		});
	});

	describe('rewards create', () => {
		const socketAdmin = require('../src/socket.io/admin');
		const rewards = require('../src/rewards');
		it('it should save a reward', (done) => {
			const data = [
				{
					rewards: { groupname: 'Gamers' },
					condition: 'essentials/user.postcount',
					conditional: 'greaterthan',
					value: '10',
					rid: 'essentials/add-to-group',
					claimable: '1',
					id: '',
					disabled: false,
				},
			];

			socketAdmin.rewards.save({ uid: adminUid }, data, (err) => {
				assert.ifError(err);
				done();
			});
		});

		it('should check condition', (done) => {
			function method(next) {
				next(null, 1);
			}
			rewards.checkConditionAndRewardUser({
				uid: adminUid,
				condition: 'essentials/user.postcount',
				method: method,
			}, (err, data) => {
				assert.ifError(err);
				done();
'use strict';


const assert = require('assert');
const async = require('async');
const nconf = require('nconf');

const db = require('./mocks/databasemock');
const meta = require('../src/meta');
const user = require('../src/user');
const topics = require('../src/topics');
const categories = require('../src/categories');
const groups = require('../src/groups');
const notifications = require('../src/notifications');
const socketNotifications = require('../src/socket.io/notifications');

describe('Notifications', () => {
	let uid;
	let notification;

	before((done) => {
		user.create({ username: 'poster' }, (err, _uid) => {
			if (err) {
				return done(err);
			}

			uid = _uid;
			done();
		});
	});

	it('should fail to create notification without a nid', (done) => {
		notifications.create({}, (err) => {
			assert.equal(err.message, '[[error:no-notification-id]]');
			done();
		});
	});

	it('should create a notification', (done) => {
		notifications.create({
			bodyShort: 'bodyShort',
			nid: 'notification_id',
			path: '/notification/path',
			pid: 1,
		}, (err, _notification) => {
			notification = _notification;
			assert.ifError(err);
			assert(notification);
			db.exists(`notifications:${notification.nid}`, (err, exists) => {
				assert.ifError(err);
				assert(exists);
				db.isSortedSetMember('notifications', notification.nid, (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});
	});

	it('should return null if pid is same and importance is lower', (done) => {
		notifications.create({
			bodyShort: 'bodyShort',
			nid: 'notification_id',
			path: '/notification/path',
			pid: 1,
			importance: 1,
		}, (err, notification) => {
			assert.ifError(err);
			assert.strictEqual(notification, null);
			done();
		});
	});

	it('should get empty array', (done) => {
		notifications.getMultiple(null, (err, data) => {
			assert.ifError(err);
			assert(Array.isArray(data));
			assert.equal(data.length, 0);
			done();
		});
	});

	it('should get notifications', (done) => {
		notifications.getMultiple([notification.nid], (err, notificationsData) => {
			assert.ifError(err);
			assert(Array.isArray(notificationsData));
			assert(notificationsData[0]);
			assert.equal(notification.nid, notificationsData[0].nid);
			done();
		});
	});

	it('should do nothing', (done) => {
		notifications.push(null, [], (err) => {
			assert.ifError(err);
			notifications.push({ nid: null }, [], (err) => {
				assert.ifError(err);
				notifications.push(notification, [], (err) => {
					assert.ifError(err);
					done();
				});
			});
		});
	});

	it('should push a notification to uid', (done) => {
		notifications.push(notification, [uid], (err) => {
			assert.ifError(err);
			setTimeout(() => {
				db.isSortedSetMember(`uid:${uid}:notifications:unread`, notification.nid, (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			}, 2000);
		});
	});

	it('should push a notification to a group', (done) => {
		notifications.pushGroup(notification, 'registered-users', (err) => {
			assert.ifError(err);
			setTimeout(() => {
				db.isSortedSetMember(`uid:${uid}:notifications:unread`, notification.nid, (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			}, 2000);
		});
	});

	it('should push a notification to groups', (done) => {
		notifications.pushGroups(notification, ['registered-users', 'administrators'], (err) => {
			assert.ifError(err);
			setTimeout(() => {
				db.isSortedSetMember(`uid:${uid}:notifications:unread`, notification.nid, (err, isMember) => {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			}, 2000);
		});
	});

	it('should not mark anything with invalid uid or nid', (done) => {
		socketNotifications.markRead({ uid: null }, null, (err) => {
			assert.ifError(err);
			socketNotifications.markRead({ uid: uid }, null, (err) => {
				assert.ifError(err);
				done();
			});
		});
	});

	it('should mark a notification read', (done) => {
		socketNotifications.markRead({ uid: uid }, notification.nid, (err) => {
			assert.ifError(err);
			db.isSortedSetMember(`uid:${uid}:notifications:unread`, notification.nid, (err, isMember) => {
				assert.ifError(err);
				assert.equal(isMember, false);
				db.isSortedSetMember(`uid:${uid}:notifications:read`, notification.nid, (err, isMember) => {
					assert.ifError(err);
					assert.equal(isMember, true);
					done();
				});
			});
		});
	});

	it('should not mark anything with invalid uid or nid', (done) => {
		socketNotifications.markUnread({ uid: null }, null, (err) => {
			assert.ifError(err);
			socketNotifications.markUnread({ uid: uid }, null, (err) => {
				assert.ifError(err);
				done();
			});
		});
	});

	it('should error if notification does not exist', (done) => {
		socketNotifications.markUnread({ uid: uid }, 123123, (err) => {
			assert.equal(err.message, '[[error:no-notification]]');
			done();
		});
	});

	it('should mark a notification unread', (done) => {
		socketNotifications.markUnread({ uid: uid }, notification.nid, (err) => {
			assert.ifError(err);
			db.isSortedSetMember(`uid:${uid}:notifications:unread`, notification.nid, (err, isMember) => {
				assert.ifError(err);
				assert.equal(isMember, true);
				db.isSortedSetMember(`uid:${uid}:notifications:read`, notification.nid, (err, isMember) => {
					assert.ifError(err);
					assert.equal(isMember, false);
					socketNotifications.getCount({ uid: uid }, null, (err, count) => {
						assert.ifError(err);
						assert.equal(count, 1);
						done();
					});
				});
			});
		});
	});

	it('should mark all notifications read', (done) => {
		socketNotifications.markAllRead({ uid: uid }, null, (err) => {
			assert.ifError(err);
			db.isSortedSetMember(`uid:${uid}:notifications:unread`, notification.nid, (err, isMember) => {
				assert.ifError(err);
				assert.equal(isMember, false);
				db.isSortedSetMember(`uid:${uid}:notifications:read`, notification.nid, (err, isMember) => {
					assert.ifError(err);
					assert.equal(isMember, true);
					done();
				});
			});
		});
	});

	it('should not do anything', (done) => {
		socketNotifications.markAllRead({ uid: 1000 }, null, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should link to the first unread post in a watched topic', (done) => {
		const categories = require('../src/categories');
		const topics = require('../src/topics');
		let watcherUid;
		let cid;
		let tid;
		let pid;

		async.waterfall([
			function (next) {
				user.create({ username: 'watcher' }, next);
			},
			function (_watcherUid, next) {
				watcherUid = _watcherUid;

				categories.create({
					name: 'Test Category',
					description: 'Test category created by testing script',
				}, next);
			},
			function (category, next) {
				cid = category.cid;

				topics.post({
					uid: watcherUid,
					cid: cid,
					title: 'Test Topic Title',
					content: 'The content of test topic',
				}, next);
			},
			function (topic, next) {
				tid = topic.topicData.tid;

				topics.follow(tid, watcherUid, next);
			},
			function (next) {
				topics.reply({
					uid: uid,
					content: 'This is the first reply.',
					tid: tid,
				}, next);
			},
			function (post, next) {
				pid = post.pid;

				topics.reply({
					uid: uid,
					content: 'This is the second reply.',
					tid: tid,
				}, next);
			},
			function (post, next) {
				// notifications are sent asynchronously with a 1 second delay.
				setTimeout(next, 3000);
			},
			function (next) {
				user.notifications.get(watcherUid, next);
			},
			function (notifications, next) {
				assert.equal(notifications.unread.length, 1, 'there should be 1 unread notification');
				assert.equal(`${nconf.get('relative_path')}/post/${pid}`, notifications.unread[0].path, 'the notification should link to the first unread post');
				next();
			},
		], (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should get notification by nid', (done) => {
		socketNotifications.get({ uid: uid }, { nids: [notification.nid] }, (err, data) => {
			assert.ifError(err);
			assert.equal(data[0].bodyShort, 'bodyShort');
			assert.equal(data[0].nid, 'notification_id');
			assert.equal(data[0].path, `${nconf.get('relative_path')}/notification/path`);
			done();
		});
	});

	it('should get user\'s notifications', (done) => {
		socketNotifications.get({ uid: uid }, {}, (err, data) => {
			assert.ifError(err);
			assert.equal(data.unread.length, 0);
			assert.equal(data.read[0].nid, 'notification_id');
			done();
		});
	});

	it('should error if not logged in', (done) => {
		socketNotifications.deleteAll({ uid: 0 }, null, (err) => {
			assert.equal(err.message, '[[error:no-privileges]]');
			done();
		});
	});

	it('should delete all user notifications', (done) => {
		socketNotifications.deleteAll({ uid: uid }, null, (err) => {
			assert.ifError(err);
			socketNotifications.get({ uid: uid }, {}, (err, data) => {
				assert.ifError(err);
				assert.equal(data.unread.length, 0);
				assert.equal(data.read.length, 0);
				done();
			});
		});
	});

	it('should return empty with falsy uid', (done) => {
		user.notifications.get(0, (err, data) => {
			assert.ifError(err);
			assert.equal(data.read.length, 0);
			assert.equal(data.unread.length, 0);
			done();
		});
	});

	it('should get all notifications and filter', (done) => {
		const nid = 'willbefiltered';
		notifications.create({
			bodyShort: 'bodyShort',
			nid: nid,
			path: '/notification/path',
			type: 'post',
		}, (err, notification) => {
			assert.ifError(err);
			notifications.push(notification, [uid], (err) => {
				assert.ifError(err);
				setTimeout(() => {
					user.notifications.getAll(uid, 'post', (err, nids) => {
						assert.ifError(err);
						assert(nids.includes(nid));
						done();
					});
				}, 1500);
			});
		});
	});

	it('should not get anything if notifications does not exist', (done) => {
		user.notifications.getNotifications(['doesnotexistnid1', 'doesnotexistnid2'], uid, (err, data) => {
			assert.ifError(err);
			assert.deepEqual(data, []);
			done();
		});
	});

	it('should get daily notifications', (done) => {
		user.notifications.getDailyUnread(uid, (err, data) => {
			assert.ifError(err);
			assert.equal(data[0].nid, 'willbefiltered');
			done();
		});
	});

	it('should return empty array for invalid interval', (done) => {
		user.notifications.getUnreadInterval(uid, '2 aeons', (err, data) => {
			assert.ifError(err);
			assert.deepEqual(data, []);
			done();
		});
	});

	it('should return 0 for falsy uid', (done) => {
		user.notifications.getUnreadCount(0, (err, count) => {
			assert.ifError(err);
			assert.equal(count, 0);
			done();
		});
	});

	it('should not do anything if uid is falsy', (done) => {
		user.notifications.deleteAll(0, (err) => {
			assert.ifError(err);
			done();
		});
	});

	it('should send notification to followers of user when he posts', (done) => {
		let followerUid;
		async.waterfall([
			function (next) {
				user.create({ username: 'follower' }, next);
			},
			function (_followerUid, next) {
				followerUid = _followerUid;
				user.follow(followerUid, uid, next);
			},
			function (next) {
				categories.create({
					name: 'Test Category',
					description: 'Test category created by testing script',
				}, next);
			},
			function (category, next) {
				topics.post({
					uid: uid,
					cid: category.cid,
					title: 'Test Topic Title',
					content: 'The content of test topic',
				}, next);
			},
			function (data, next) {
				setTimeout(next, 1100);
			},
			function (next) {
				user.notifications.getAll(followerUid, '', next);
			},
		], (err, data) => {
			assert.ifError(err);
			assert(data);
			done();
		});
	});

	it('should send welcome notification', (done) => {
		meta.config.welcomeNotification = 'welcome to the forums';
		user.notifications.sendWelcomeNotification(uid, (err) => {
			assert.ifError(err);
			user.notifications.sendWelcomeNotification(uid, (err) => {
				assert.ifError(err);
				setTimeout(() => {
					user.notifications.getAll(uid, '', (err, data) => {
						meta.config.welcomeNotification = '';
						assert.ifError(err);
						assert(data.includes(`welcome_${uid}`), data);
						done();
					});
				}, 2000);
			});
		});
	});

	it('should prune notifications', (done) => {
		notifications.create({
			bodyShort: 'bodyShort',
			nid: 'tobedeleted',
			path: '/notification/path',
		}, (err, notification) => {
			assert.ifError(err);
			notifications.prune((err) => {
				assert.ifError(err);
				const week = 604800000;
				db.sortedSetAdd('notifications', Date.now() - (2 * week), notification.nid, (err) => {
					assert.ifError(err);
					notifications.prune((err) => {
						assert.ifError(err);
						notifications.get(notification.nid, (err, data) => {
							assert.ifError(err);
							assert(!data);
							done();
						});
					});
'use strict';


const	assert = require('assert');
const pagination = require('../src/pagination');

describe('Pagination', () => {
	it('should create empty pagination for 1 page', (done) => {
		const data = pagination.create(1, 1);
		assert.equal(data.pages.length, 0);
		assert.equal(data.rel.length, 0);
		assert.equal(data.pageCount, 1);
		assert.equal(data.prev.page, 1);
		assert.equal(data.next.page, 1);
		done();
	});

	it('should create pagination for 10 pages', (done) => {
		const data = pagination.create(2, 10);
		// [1, (2), 3, 4, 5, separator, 9, 10]
		assert.equal(data.pages.length, 8);
		assert.equal(data.rel.length, 2);
		assert.equal(data.pageCount, 10);
		assert.equal(data.prev.page, 1);
		assert.equal(data.next.page, 3);
		done();
	});

	it('should create pagination for 3 pages with query params', (done) => {
		const data = pagination.create(1, 3, { key: 'value' });
		assert.equal(data.pages.length, 3);
		assert.equal(data.rel.length, 1);
		assert.equal(data.pageCount, 3);
		assert.equal(data.prev.page, 1);
		assert.equal(data.next.page, 2);
'use strict';

const async = require('async');
const	assert = require('assert');
const nconf = require('nconf');
const path = require('path');
const request = require('request');

const db = require('./mocks/databasemock');
const categories = require('../src/categories');
const topics = require('../src/topics');
const user = require('../src/user');
const groups = require('../src/groups');
const privileges = require('../src/privileges');
const meta = require('../src/meta');
const socketUser = require('../src/socket.io/user');
const helpers = require('./helpers');
const file = require('../src/file');
const image = require('../src/image');

describe('Upload Controllers', () => {
	let tid;
	let cid;
	let pid;
	let adminUid;
	let regularUid;

	before((done) => {
		async.series({
			category: function (next) {
				categories.create({
					name: 'Test Category',
					description: 'Test category created by testing script',
				}, next);
			},
			adminUid: function (next) {
				user.create({ username: 'admin', password: 'barbar' }, next);
			},
			regularUid: function (next) {
				user.create({ username: 'regular', password: 'zugzug' }, next);
			},
		}, (err, results) => {
			if (err) {
				return done(err);
			}
			adminUid = results.adminUid;
			regularUid = results.regularUid;
			cid = results.category.cid;

			topics.post({ uid: adminUid, title: 'test topic title', content: 'test topic content', cid: results.category.cid }, (err, result) => {
				if (err) {
					return done(err);
				}
				tid = result.topicData.tid;
				pid = result.postData.pid;
				groups.join('administrators', adminUid, done);
			});
		});
	});

	describe('regular user uploads', () => {
		let jar;
		let csrf_token;

		before((done) => {
			helpers.loginUser('regular', 'zugzug', (err, _jar, _csrf_token) => {
				assert.ifError(err);
				jar = _jar;
				csrf_token = _csrf_token;
				privileges.global.give(['groups:upload:post:file'], 'registered-users', done);
			});
		});

		it('should upload an image to a post', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/post/upload`, path.join(__dirname, '../test/files/test.png'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body && body.status && body.response && body.response.images);
				assert(Array.isArray(body.response.images));
				assert(body.response.images[0].url);
				done();
			});
		});

		it('should upload an image to a post and then delete the upload', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/post/upload`, path.join(__dirname, '../test/files/test.png'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 200);
				assert(body && body.status && body.response && body.response.images);
				assert(Array.isArray(body.response.images));
				assert(body.response.images[0].url);
				const name = body.response.images[0].url.replace(nconf.get('relative_path') + nconf.get('upload_url'), '');
				socketUser.deleteUpload({ uid: regularUid }, { uid: regularUid, name: name }, (err) => {
					assert.ifError(err);
					db.getSortedSetRange(`uid:${regularUid}:uploads`, 0, -1, (err, uploads) => {
						assert.ifError(err);
						assert.equal(uploads.includes(name), false);
						done();
					});
				});
			});
		});

		it('should not allow deleting if path is not correct', (done) => {
			socketUser.deleteUpload({ uid: adminUid }, { uid: regularUid, name: '../../bkconfig.json' }, (err) => {
				assert.equal(err.message, '[[error:invalid-path]]');
				done();
			});
		});

		it('should not allow deleting if path is not correct', (done) => {
			socketUser.deleteUpload({ uid: adminUid }, { uid: regularUid, name: '/files/../../bkconfig.json' }, (err) => {
				assert.equal(err.message, '[[error:invalid-path]]');
				done();
			});
		});

		it('should resize and upload an image to a post', (done) => {
			const oldValue = meta.config.resizeImageWidth;
			meta.config.resizeImageWidth = 10;
			meta.config.resizeImageWidthThreshold = 10;
			helpers.uploadFile(`${nconf.get('url')}/api/post/upload`, path.join(__dirname, '../test/files/test.png'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(body && body.status && body.response && body.response.images);
				assert(Array.isArray(body.response.images));
				assert(body.response.images[0].url);
				assert(body.response.images[0].url.match(/\/assets\/uploads\/files\/\d+-test-resized\.png/));
				meta.config.resizeImageWidth = oldValue;
				meta.config.resizeImageWidthThreshold = 1520;
				done();
			});
		});


		it('should upload a file to a post', (done) => {
			const oldValue = meta.config.allowedFileExtensions;
			meta.config.allowedFileExtensions = 'png,jpg,bmp,html';
			helpers.uploadFile(`${nconf.get('url')}/api/post/upload`, path.join(__dirname, '../test/files/503.html'), {}, jar, csrf_token, (err, res, body) => {
				meta.config.allowedFileExtensions = oldValue;
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 200);
				assert(body && body.status && body.response && body.response.images);
				assert(Array.isArray(body.response.images));
				assert(body.response.images[0].url);
				done();
			});
		});

		it('should fail to upload image to post if image dimensions are too big', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/post/upload`, path.join(__dirname, '../test/files/toobig.jpg'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 500);
				assert(body && body.status && body.status.message);
				assert.strictEqual(body.status.message, 'Input image exceeds pixel limit');
				done();
			});
		});

		it('should fail to upload image to post if image is broken', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/post/upload`, path.join(__dirname, '../test/files/brokenimage.png'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.strictEqual(res.statusCode, 500);
				assert(body && body.status && body.status.message);
				assert(body.status.message.startsWith('pngload_buffer: non-recoverable state'));
				done();
			});
		});

		it('should fail if file is not an image', (done) => {
			image.isFileTypeAllowed(path.join(__dirname, '../test/files/notanimage.png'), (err) => {
				assert.strictEqual(err.message, 'Input file contains unsupported image format');
				done();
			});
		});

		it('should fail if file is not an image', (done) => {
			image.isFileTypeAllowed(path.join(__dirname, '../test/files/notanimage.png'), (err) => {
				assert.strictEqual(err.message, 'Input file contains unsupported image format');
				done();
			});
		});

		it('should fail if file is not an image', (done) => {
			image.size(path.join(__dirname, '../test/files/notanimage.png'), (err) => {
				assert.strictEqual(err.message, 'Input file contains unsupported image format');
				done();
			});
		});

		it('should fail if file is missing', (done) => {
			image.size(path.join(__dirname, '../test/files/doesnotexist.png'), (err) => {
				assert.strictEqual(err.message, 'Input file is missing');
				done();
			});
		});

		// it('should fail if topic thumbs are disabled', function (done) {
		// 	helpers.uploadFile(
		// 		nconf.get('url') + '/api/topic/thumb/upload',
		// 		path.join(__dirname, '../test/files/test.png'),
		// 		{}, jar, csrf_token,
		// 		function (err, res, body) {
		// 			assert.ifError(err);
		// 			assert.strictEqual(res.statusCode, 404);
		// 			console.log(body);
		// 			assert(body && body.status && body.status.code);
		// 			assert.strictEqual(body.status.code, '[[error:topic-thumbnails-are-disabled]]');
		// 			done();
		// 		}
		// 	);
		// });

		// it('should fail if file is not image', function (done) {
		// 	meta.config.allowTopicsThumbnail = 1;
		// 	helpers.uploadFile(
		// 		nconf.get('url') + '/api/topic/thumb/upload',
		// 		path.join(__dirname, '../test/files/503.html'),
		// 		{}, jar, csrf_token,
		// 		function (err, res, body) {
		// 			assert.ifError(err);
		// 			assert.equal(res.statusCode, 500);
		// 			assert.equal(body.error, '[[error:invalid-file]]');
		// 			done();
		// 		}
		// 	);
		// });

		// it('should upload topic thumb', function (done) {
		// 	meta.config.allowTopicsThumbnail = 1;
		// 	helpers.uploadFile(
		// 		nconf.get('url') + '/api/topic/thumb/upload',
		// 		path.join(__dirname, '../test/files/test.png'),
		// 		{}, jar, csrf_token,
		// 		function (err, res, body) {
		// 			assert.ifError(err);
		// 			assert.equal(res.statusCode, 200);
		// 			assert(Array.isArray(body));
		// 			assert(body[0].path);
		// 			assert(body[0].url);
		// 			done();
		// 		}
		// 	);
		// });

		it('should not allow non image uploads', (done) => {
			socketUser.updateCover({ uid: 1 }, { uid: 1, file: { path: '../../text.txt' } }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should not allow non image uploads', (done) => {
			socketUser.updateCover({ uid: 1 }, { uid: 1, imageData: 'data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+' }, (err) => {
				assert.equal(err.message, '[[error:invalid-image]]');
				done();
			});
		});

		it('should not allow svg uploads', (done) => {
			socketUser.updateCover({ uid: 1 }, { uid: 1, imageData: 'data:image/svg;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+' }, (err) => {
				assert.equal(err.message, '[[error:invalid-image]]');
				done();
			});
		});

		it('should not allow non image uploads', (done) => {
			socketUser.uploadCroppedPicture({ uid: 1 }, { uid: 1, file: { path: '../../text.txt' } }, (err) => {
				assert.equal(err.message, '[[error:invalid-data]]');
				done();
			});
		});

		it('should not allow non image uploads', (done) => {
			socketUser.uploadCroppedPicture({ uid: 1 }, { uid: 1, imageData: 'data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+' }, (err) => {
				assert.equal(err.message, '[[error:invalid-image]]');
				done();
			});
		});

		it('should not allow svg uploads', (done) => {
			socketUser.uploadCroppedPicture({ uid: 1 }, { uid: 1, imageData: 'data:image/svg;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+' }, (err) => {
				assert.equal(err.message, '[[error:invalid-image]]');
				done();
			});
		});

		it('should delete users uploads if account is deleted', (done) => {
			let jar;
			let uid;
			let url;
			const file = require('../src/file');

			async.waterfall([
				function (next) {
					user.create({ username: 'uploader', password: 'barbar' }, next);
				},
				function (_uid, next) {
					uid = _uid;
					helpers.loginUser('uploader', 'barbar', next);
				},
				function (jar, csrf_token, next) {
					helpers.uploadFile(`${nconf.get('url')}/api/post/upload`, path.join(__dirname, '../test/files/test.png'), {}, jar, csrf_token, next);
				},
				function (res, body, next) {
					assert(body && body.status && body.response && body.response.images);
					assert(Array.isArray(body.response.images));
					assert(body.response.images[0].url);
					url = body.response.images[0].url;

					user.delete(1, uid, next);
				},
				function (userData, next) {
					const filePath = path.join(nconf.get('upload_path'), url.replace('/assets/uploads', ''));
					file.exists(filePath, next);
				},
				function (exists, next) {
					assert(!exists);
					done();
				},
			], done);
		});
	});

	describe('admin uploads', () => {
		let jar;
		let csrf_token;

		before((done) => {
			helpers.loginUser('admin', 'barbar', (err, _jar, _csrf_token) => {
				assert.ifError(err);
				jar = _jar;
				csrf_token = _csrf_token;
				done();
			});
		});

		it('should upload site logo', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/uploadlogo`, path.join(__dirname, '../test/files/test.png'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(Array.isArray(body));
				assert.equal(body[0].url, `${nconf.get('relative_path')}/assets/uploads/system/site-logo.png`);
				done();
			});
		});

		it('should fail to upload invalid file type', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/category/uploadpicture`, path.join(__dirname, '../test/files/503.html'), { params: JSON.stringify({ cid: cid }) }, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(body.error, '[[error:invalid-image-type, image/png&#44; image/jpeg&#44; image/pjpeg&#44; image/jpg&#44; image/gif&#44; image/svg+xml]]');
				done();
			});
		});

		it('should fail to upload category image with invalid json params', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/category/uploadpicture`, path.join(__dirname, '../test/files/test.png'), { params: 'invalid json' }, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(body.error, '[[error:invalid-json]]');
				done();
			});
		});

		it('should upload category image', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/category/uploadpicture`, path.join(__dirname, '../test/files/test.png'), { params: JSON.stringify({ cid: cid }) }, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(Array.isArray(body));
				assert.equal(body[0].url, `${nconf.get('relative_path')}/assets/uploads/category/category-1.png`);
				done();
			});
		});

		it('should upload default avatar', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/uploadDefaultAvatar`, path.join(__dirname, '../test/files/test.png'), { }, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(body[0].url, `${nconf.get('relative_path')}/assets/uploads/system/avatar-default.png`);
				done();
			});
		});

		it('should upload og image', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/uploadOgImage`, path.join(__dirname, '../test/files/test.png'), { }, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert.equal(body[0].url, `${nconf.get('relative_path')}/assets/uploads/system/og-image.png`);
				done();
			});
		});

		it('should upload favicon', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/uploadfavicon`, path.join(__dirname, '../test/files/favicon.ico'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(Array.isArray(body));
				assert.equal(body[0].url, '/assets/uploads/system/favicon.ico');
				done();
			});
		});

		it('should upload touch icon', (done) => {
			const touchiconAssetPath = '/assets/uploads/system/touchicon-orig.png';
			helpers.uploadFile(`${nconf.get('url')}/api/admin/uploadTouchIcon`, path.join(__dirname, '../test/files/test.png'), {}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(Array.isArray(body));
				assert.equal(body[0].url, touchiconAssetPath);
				meta.config['brand:touchIcon'] = touchiconAssetPath;
				request(`${nconf.get('url')}/apple-touch-icon`, (err, res, body) => {
					assert.ifError(err);
					assert.equal(res.statusCode, 200);
					assert(body);
					done();
				});
			});
		});

		it('should upload regular file', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/upload/file`, path.join(__dirname, '../test/files/test.png'), {
				params: JSON.stringify({
					folder: 'system',
				}),
			}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 200);
				assert(Array.isArray(body));
				assert.equal(body[0].url, '/assets/uploads/system/test.png');
				assert(file.existsSync(path.join(nconf.get('upload_path'), 'system', 'test.png')));
				done();
			});
		});

		it('should fail to upload regular file in wrong directory', (done) => {
			helpers.uploadFile(`${nconf.get('url')}/api/admin/upload/file`, path.join(__dirname, '../test/files/test.png'), {
				params: JSON.stringify({
					folder: '../../system',
				}),
			}, jar, csrf_token, (err, res, body) => {
				assert.ifError(err);
				assert.equal(res.statusCode, 500);
				assert.strictEqual(body.error, '[[error:invalid-path]]');
				done();
			});
		});
'use strict';

const async = require('async');
const assert = require('assert');

const db = require('./mocks/databasemock');

const batch = require('../src/batch');

describe('batch', () => {
	const scores = [];
	const values = [];
	before((done) => {
		for (let i = 0; i < 100; i++) {
			scores.push(i);
			values.push(`val${i}`);
		}
		db.sortedSetAdd('processMe', scores, values, done);
	});

	it('should process sorted set with callbacks', (done) => {
		let total = 0;
		batch.processSortedSet('processMe', (items, next) => {
			items.forEach((item) => {
				total += item.score;
			});

			setImmediate(next);
		}, {
			withScores: true,
			interval: 50,
			batch: 10,
		}, (err) => {
			assert.ifError(err);
			assert.strictEqual(total, 4950);
			done();
		});
	});

	it('should process sorted set with callbacks', (done) => {
		let total = 0;
		batch.processSortedSet('processMe', (values, next) => {
			values.forEach((val) => {
				total += val.length;
			});

			setImmediate(next);
		}, (err) => {
			assert.ifError(err);
			assert.strictEqual(total, 490);
			done();
		});
	});

	it('should process sorted set with async/await', async () => {
		let total = 0;
		await batch.processSortedSet('processMe', (values, next) => {
			values.forEach((val) => {
				total += val.length;
			});

			setImmediate(next);
		}, {});

		assert.strictEqual(total, 490);
	});

	it('should process sorted set with async/await', async () => {
		let total = 0;
		await batch.processSortedSet('processMe', async (values) => {
			values.forEach((val) => {
				total += val.length;
			});
			await db.getObject('doesnotexist');
		}, {});

		assert.strictEqual(total, 490);
	});

	it('should process array with callbacks', (done) => {
		let total = 0;
		batch.processArray(scores, (nums, next) => {
			nums.forEach((n) => {
				total += n;
			});

			setImmediate(next);
		}, {
			withScores: true,
			interval: 50,
			batch: 10,
		}, (err) => {
			assert.ifError(err);
			assert.strictEqual(total, 4950);
			done();
		});
	});

	it('should process array with async/await', async () => {
		let total = 0;
		await batch.processArray(scores, (nums, next) => {
			nums.forEach((n) => {
				total += n;
			});

			setImmediate(next);
		}, {
			withScores: true,
			interval: 50,
			batch: 10,
'use strict';

const path = require('path');
const nconf = require('nconf');

nconf.argv().env({
	separator: '__',
});
const winston = require('winston');
const { fork } = require('child_process');

const { env } = process;
let worker;

env.NODE_ENV = env.NODE_ENV || 'development';

const configFile = path.resolve(__dirname, nconf.any(['config', 'CONFIG']) || 'config.json');
const prestart = require('./src/prestart');

prestart.loadConfig(configFile);

const db = require('./src/database');

module.exports = function (grunt) {
	const args = [];

	if (!grunt.option('verbose')) {
		args.push('--log-level=info');
		nconf.set('log-level', 'info');
	}
	prestart.setupWinston();

	grunt.initConfig({
		watch: {},
	});

	grunt.loadNpmTasks('grunt-contrib-watch');

	grunt.registerTask('default', ['watch']);

	grunt.registerTask('init', async function () {
		const done = this.async();
		let plugins = [];
		if (!process.argv.includes('--core')) {
			await db.init();
			plugins = await db.getSortedSetRange('plugins:active', 0, -1);
			addBaseThemes(plugins);
			if (!plugins.includes('nodebb-plugin-composer-default')) {
				plugins.push('nodebb-plugin-composer-default');
			}
			if (!plugins.includes('nodebb-theme-persona')) {
				plugins.push('nodebb-theme-persona');
			}
		}

		const styleUpdated_Client = plugins.map(p => `node_modules/${p}/*.less`)
			.concat(plugins.map(p => `node_modules/${p}/*.css`))
			.concat(plugins.map(p => `node_modules/${p}/+(public|static|less)/**/*.less`))
			.concat(plugins.map(p => `node_modules/${p}/+(public|static)/**/*.css`));

		const styleUpdated_Admin = plugins.map(p => `node_modules/${p}/*.less`)
			.concat(plugins.map(p => `node_modules/${p}/*.css`))
			.concat(plugins.map(p => `node_modules/${p}/+(public|static|less)/**/*.less`))
			.concat(plugins.map(p => `node_modules/${p}/+(public|static)/**/*.css`));

		const clientUpdated = plugins.map(p => `node_modules/${p}/+(public|static)/**/*.js`);
		const serverUpdated = plugins.map(p => `node_modules/${p}/*.js`)
			.concat(plugins.map(p => `node_modules/${p}/+(lib|src)/**/*.js`));

		const templatesUpdated = plugins.map(p => `node_modules/${p}/+(public|static|templates)/**/*.tpl`);
		const langUpdated = plugins.map(p => `node_modules/${p}/+(public|static|languages)/**/*.json`);

		grunt.config(['watch'], {
			styleUpdated_Client: {
				files: [
					'public/less/**/*.less',
					...styleUpdated_Client,
				],
				options: {
					interval: 1000,
				},
			},
			styleUpdated_Admin: {
				files: [
					'public/less/**/*.less',
					...styleUpdated_Admin,
				],
				options: {
					interval: 1000,
				},
			},
			clientUpdated: {
				files: [
					'public/src/**/*.js',
					'public/vendor/**/*.js',
					...clientUpdated,
					'node_modules/benchpressjs/build/benchpress.js',
				],
				options: {
					interval: 1000,
				},
			},
			serverUpdated: {
				files: [
					'app.js',
					'install/*.js',
					'src/**/*.js',
					'public/src/modules/translator.js',
					'public/src/modules/helpers.js',
					'public/src/utils.js',
					serverUpdated,
					'!src/upgrades/**',
				],
				options: {
					interval: 1000,
				},
			},
			templatesUpdated: {
				files: [
					'src/views/**/*.tpl',
					...templatesUpdated,
				],
				options: {
					interval: 1000,
				},
			},
			langUpdated: {
				files: [
					'public/language/en-GB/*.json',
					'public/language/en-GB/**/*.json',
					...langUpdated,
				],
				options: {
					interval: 1000,
				},
			},
		});
		const build = require('./src/meta/build');
		if (!grunt.option('skip')) {
			await build.build(true);
		}
		run();
		done();
	});

	function run() {
		if (worker) {
			worker.kill();
		}

		const execArgv = [];
		const inspect = process.argv.find(a => a.startsWith('--inspect'));

		if (inspect) {
			execArgv.push(inspect);
		}

		worker = fork('app.js', args, {
			env,
			execArgv,
		});
	}

	grunt.task.run('init');

	grunt.event.removeAllListeners('watch');
	grunt.event.on('watch', (action, filepath, target) => {
		let compiling;
		if (target === 'styleUpdated_Client') {
			compiling = 'clientCSS';
		} else if (target === 'styleUpdated_Admin') {
			compiling = 'acpCSS';
		} else if (target === 'clientUpdated') {
			compiling = 'js';
		} else if (target === 'templatesUpdated') {
			compiling = 'tpl';
		} else if (target === 'langUpdated') {
			compiling = 'lang';
		} else if (target === 'serverUpdated') {
			// empty require cache
			const paths = ['./src/meta/build.js', './src/meta/index.js'];
			paths.forEach(p => delete require.cache[require.resolve(p)]);
			return run();
		}

		require('./src/meta/build').build([compiling], (err) => {
			if (err) {
				winston.error(err.stack);
			}
			if (worker) {
				worker.send({ compiling: compiling });
			}
		});
	});
};

function addBaseThemes(plugins) {
	let themeId = plugins.find(p => p.includes('nodebb-theme-'));
	if (!themeId) {
		return plugins;
	}
	let baseTheme;
	do {
		try {
			baseTheme = require(`${themeId}/theme`).baseTheme;
		} catch (err) {
			console.log(err);
		}

		if (baseTheme) {
			plugins.push(baseTheme);
			themeId = baseTheme;
		}
	} while (baseTheme);
	return plugins;
'use strict';

// this forces `require.main.require` to always be relative to this directory
// this allows plugins to use `require.main.require` to reference NodeBB modules
// without worrying about multiple parent modules

'use strict';

const _ = require('lodash');

const user = require('../user');
const groups = require('../groups');
const helpers = require('./helpers');
const plugins = require('../plugins');
const utils = require('../utils');

const privsAdmin = module.exports;

privsAdmin.privilegeLabels = [
	{ name: '[[admin/manage/privileges:admin-dashboard]]' },
	{ name: '[[admin/manage/privileges:admin-categories]]' },
	{ name: '[[admin/manage/privileges:admin-privileges]]' },
	{ name: '[[admin/manage/privileges:admin-admins-mods]]' },
	{ name: '[[admin/manage/privileges:admin-users]]' },
	{ name: '[[admin/manage/privileges:admin-groups]]' },
	{ name: '[[admin/manage/privileges:admin-tags]]' },
	{ name: '[[admin/manage/privileges:admin-settings]]' },
];

privsAdmin.userPrivilegeList = [
	'admin:dashboard',
	'admin:categories',
	'admin:privileges',
	'admin:admins-mods',
	'admin:users',
	'admin:groups',
	'admin:tags',
	'admin:settings',
];

privsAdmin.groupPrivilegeList = privsAdmin.userPrivilegeList.map(privilege => `groups:${privilege}`);

// Mapping for a page route (via direct match or regexp) to a privilege
privsAdmin.routeMap = {
	dashboard: 'admin:dashboard',
	'manage/categories': 'admin:categories',
	'manage/privileges': 'admin:privileges',
	'manage/admins-mods': 'admin:admins-mods',
	'manage/users': 'admin:users',
	'manage/groups': 'admin:groups',
	'manage/tags': 'admin:tags',
	'settings/tags': 'admin:tags',
	'extend/plugins': 'admin:settings',
	'extend/widgets': 'admin:settings',
	'extend/rewards': 'admin:settings',
};
privsAdmin.routeRegexpMap = {
	'^manage/categories/\\d+': 'admin:categories',
	'^manage/privileges/(\\d+|admin)': 'admin:privileges',
	'^manage/groups/.+$': 'admin:groups',
	'^settings/[\\w\\-]+$': 'admin:settings',
	'^appearance/[\\w]+$': 'admin:settings',
	'^plugins/[\\w\\-]+$': 'admin:settings',
};

// Mapping for socket call methods to a privilege
// In NodeBB v2, these socket calls will be removed in favour of xhr calls
privsAdmin.socketMap = {
	'admin.rooms.getAll': 'admin:dashboard',
	'admin.analytics.get': 'admin:dashboard',

	'admin.categories.getAll': 'admin:categories',
	'admin.categories.create': 'admin:categories',
	'admin.categories.update': 'admin:categories',
	'admin.categories.purge': 'admin:categories',
	'admin.categories.copySettingsFrom': 'admin:categories',

	'admin.categories.getPrivilegeSettings': 'admin:privileges',
	'admin.categories.setPrivilege': 'admin:privileges;admin:admins-mods',
	'admin.categories.copyPrivilegesToChildren': 'admin:privileges',
	'admin.categories.copyPrivilegesFrom': 'admin:privileges',
	'admin.categories.copyPrivilegesToAllCategories': 'admin:privileges',

	'admin.user.makeAdmins': 'admin:admins-mods',
	'admin.user.removeAdmins': 'admin:admins-mods',

	'admin.user.loadGroups': 'admin:users',
	'admin.groups.join': 'admin:users',
	'admin.groups.leave': 'admin:users',
	'admin.user.resetLockouts': 'admin:users',
	'admin.user.validateEmail': 'admin:users',
	'admin.user.sendValidationEmail': 'admin:users',
	'admin.user.sendPasswordResetEmail': 'admin:users',
	'admin.user.forcePasswordReset': 'admin:users',
	'admin.user.deleteUsers': 'admin:users',
	'admin.user.deleteUsersAndContent': 'admin:users',
	'admin.user.createUser': 'admin:users',
	'admin.user.invite': 'admin:users',

	'admin.tags.create': 'admin:tags',
	'admin.tags.update': 'admin:tags',
	'admin.tags.rename': 'admin:tags',
	'admin.tags.deleteTags': 'admin:tags',

	'admin.getSearchDict': 'admin:settings',
	'admin.config.setMultiple': 'admin:settings',
	'admin.config.remove': 'admin:settings',
	'admin.themes.getInstalled': 'admin:settings',
	'admin.themes.set': 'admin:settings',
	'admin.reloadAllSessions': 'admin:settings',
	'admin.settings.get': 'admin:settings',
	'admin.settings.set': 'admin:settings',
};

privsAdmin.resolve = (path) => {
	if (privsAdmin.routeMap[path]) {
		return privsAdmin.routeMap[path];
	}

	let privilege;
	Object.keys(privsAdmin.routeRegexpMap).forEach((regexp) => {
		if (!privilege) {
			if (new RegExp(regexp).test(path)) {
				privilege = privsAdmin.routeRegexpMap[regexp];
			}
		}
	});

	return privilege;
};

privsAdmin.list = async function (uid) {
	const privilegeLabels = privsAdmin.privilegeLabels.slice();
	const userPrivilegeList = privsAdmin.userPrivilegeList.slice();
	const groupPrivilegeList = privsAdmin.groupPrivilegeList.slice();

	// Restrict privileges column to superadmins
	if (!(await user.isAdministrator(uid))) {
		const idx = privsAdmin.userPrivilegeList.indexOf('admin:privileges');
		privilegeLabels.splice(idx, 1);
		userPrivilegeList.splice(idx, 1);
		groupPrivilegeList.splice(idx, 1);
	}

	async function getLabels() {
		return await utils.promiseParallel({
			users: plugins.hooks.fire('filter:privileges.admin.list_human', privilegeLabels.slice()),
			groups: plugins.hooks.fire('filter:privileges.admin.groups.list_human', privilegeLabels.slice()),
		});
	}

	const keys = await utils.promiseParallel({
		users: plugins.hooks.fire('filter:privileges.admin.list', userPrivilegeList.slice()),
		groups: plugins.hooks.fire('filter:privileges.admin.groups.list', groupPrivilegeList.slice()),
	});

	const payload = await utils.promiseParallel({
		labels: getLabels(),
		users: helpers.getUserPrivileges(0, keys.users),
		groups: helpers.getGroupPrivileges(0, keys.groups),
	});
	payload.keys = keys;

	// This is a hack because I can't do {labels.users.length} to echo the count in templates.js
	payload.columnCount = payload.labels.users.length + 3;
	return payload;
};

privsAdmin.get = async function (uid) {
	const [userPrivileges, isAdministrator] = await Promise.all([
		helpers.isAllowedTo(privsAdmin.userPrivilegeList, uid, 0),
		user.isAdministrator(uid),
	]);

	const combined = userPrivileges.map(allowed => allowed || isAdministrator);
	const privData = _.zipObject(privsAdmin.userPrivilegeList, combined);

	privData.superadmin = isAdministrator;
	return await plugins.hooks.fire('filter:privileges.admin.get', privData);
};

privsAdmin.can = async function (privilege, uid) {
	const [isUserAllowedTo, isAdministrator] = await Promise.all([
		helpers.isAllowedTo(privilege, uid, [0]),
		user.isAdministrator(uid),
	]);
	return isAdministrator || isUserAllowedTo[0];
};

privsAdmin.canGroup = async function (privilege, groupName) {
	return await groups.isMember(groupName, `cid:0:privileges:groups:${privilege}`);
};

privsAdmin.give = async function (privileges, groupName) {
	await helpers.giveOrRescind(groups.join, privileges, 0, groupName);
	plugins.hooks.fire('action:privileges.admin.give', {
		privileges: privileges,
		groupNames: Array.isArray(groupName) ? groupName : [groupName],
	});
};

privsAdmin.rescind = async function (privileges, groupName) {
	await helpers.giveOrRescind(groups.leave, privileges, 0, groupName);
	plugins.hooks.fire('action:privileges.admin.rescind', {
		privileges: privileges,
		groupNames: Array.isArray(groupName) ? groupName : [groupName],
	});
};

privsAdmin.userPrivileges = async function (uid) {
	return await helpers.userOrGroupPrivileges(0, uid, privsAdmin.userPrivilegeList);
};

privsAdmin.groupPrivileges = async function (groupName) {
	return await helpers.userOrGroupPrivileges(0, groupName, privsAdmin.groupPrivilegeList);

'use strict';

const _ = require('lodash');

const user = require('../user');
const groups = require('../groups');
const helpers = require('./helpers');
const plugins = require('../plugins');
const utils = require('../utils');

const privsGlobal = module.exports;

privsGlobal.privilegeLabels = [
	{ name: '[[admin/manage/privileges:chat]]' },
	{ name: '[[admin/manage/privileges:upload-images]]' },
	{ name: '[[admin/manage/privileges:upload-files]]' },
	{ name: '[[admin/manage/privileges:signature]]' },
	{ name: '[[admin/manage/privileges:ban]]' },
	{ name: '[[admin/manage/privileges:invite]]' },
	{ name: '[[admin/manage/privileges:search-content]]' },
	{ name: '[[admin/manage/privileges:search-users]]' },
	{ name: '[[admin/manage/privileges:search-tags]]' },
	{ name: '[[admin/manage/privileges:view-users]]' },
	{ name: '[[admin/manage/privileges:view-tags]]' },
	{ name: '[[admin/manage/privileges:view-groups]]' },
	{ name: '[[admin/manage/privileges:allow-local-login]]' },
	{ name: '[[admin/manage/privileges:allow-group-creation]]' },
	{ name: '[[admin/manage/privileges:view-users-info]]' },
];

privsGlobal.userPrivilegeList = [
	'chat',
	'upload:post:image',
	'upload:post:file',
	'signature',
	'ban',
	'invite',
	'search:content',
	'search:users',
	'search:tags',
	'view:users',
	'view:tags',
	'view:groups',
	'local:login',
	'group:create',
	'view:users:info',
];

privsGlobal.groupPrivilegeList = privsGlobal.userPrivilegeList.map(privilege => `groups:${privilege}`);

privsGlobal.list = async function () {
	async function getLabels() {
		return await utils.promiseParallel({
			users: plugins.hooks.fire('filter:privileges.global.list_human', privsGlobal.privilegeLabels.slice()),
			groups: plugins.hooks.fire('filter:privileges.global.groups.list_human', privsGlobal.privilegeLabels.slice()),
		});
	}

	const keys = await utils.promiseParallel({
		users: plugins.hooks.fire('filter:privileges.global.list', privsGlobal.userPrivilegeList.slice()),
		groups: plugins.hooks.fire('filter:privileges.global.groups.list', privsGlobal.groupPrivilegeList.slice()),
	});

	const payload = await utils.promiseParallel({
		labels: getLabels(),
		users: helpers.getUserPrivileges(0, keys.users),
		groups: helpers.getGroupPrivileges(0, keys.groups),
	});
	payload.keys = keys;

	// This is a hack because I can't do {labels.users.length} to echo the count in templates.js
	payload.columnCount = payload.labels.users.length + 3;
	return payload;
};

privsGlobal.get = async function (uid) {
	const [userPrivileges, isAdministrator] = await Promise.all([
		helpers.isAllowedTo(privsGlobal.userPrivilegeList, uid, 0),
		user.isAdministrator(uid),
	]);

	const combined = userPrivileges.map(allowed => allowed || isAdministrator);
	const privData = _.zipObject(privsGlobal.userPrivilegeList, combined);

	return await plugins.hooks.fire('filter:privileges.global.get', privData);
};

privsGlobal.can = async function (privilege, uid) {
	const [isAdministrator, isUserAllowedTo] = await Promise.all([
		user.isAdministrator(uid),
		helpers.isAllowedTo(privilege, uid, [0]),
	]);
	return isAdministrator || isUserAllowedTo[0];
};

privsGlobal.canGroup = async function (privilege, groupName) {
	return await groups.isMember(groupName, `cid:0:privileges:groups:${privilege}`);
};

privsGlobal.give = async function (privileges, groupName) {
	await helpers.giveOrRescind(groups.join, privileges, 0, groupName);
	plugins.hooks.fire('action:privileges.global.give', {
		privileges: privileges,
		groupNames: Array.isArray(groupName) ? groupName : [groupName],
	});
};

privsGlobal.rescind = async function (privileges, groupName) {
	await helpers.giveOrRescind(groups.leave, privileges, 0, groupName);
	plugins.hooks.fire('action:privileges.global.rescind', {
		privileges: privileges,
		groupNames: Array.isArray(groupName) ? groupName : [groupName],
	});
};

privsGlobal.userPrivileges = async function (uid) {
	return await helpers.userOrGroupPrivileges(0, uid, privsGlobal.userPrivilegeList);
};


'use strict';

const _ = require('lodash');

const meta = require('../meta');
const topics = require('../topics');
const user = require('../user');
const helpers = require('./helpers');
const categories = require('../categories');
const plugins = require('../plugins');
const privsCategories = require('./categories');

const privsTopics = module.exports;

privsTopics.get = async function (tid, uid) {
	uid = parseInt(uid, 10);

	const privs = [
		'topics:reply', 'topics:read', 'topics:tag',
		'topics:delete', 'posts:edit', 'posts:history',
		'posts:delete', 'posts:view_deleted', 'read', 'purge',
	];
	const topicData = await topics.getTopicFields(tid, ['cid', 'uid', 'locked', 'deleted']);
	const [userPrivileges, isAdministrator, isModerator, disabled] = await Promise.all([
		helpers.isAllowedTo(privs, uid, topicData.cid),
		user.isAdministrator(uid),
		user.isModerator(uid, topicData.cid),
		categories.getCategoryField(topicData.cid, 'disabled'),
	]);
	const privData = _.zipObject(privs, userPrivileges);
	const isOwner = uid > 0 && uid === topicData.uid;
	const isAdminOrMod = isAdministrator || isModerator;
	const editable = isAdminOrMod;
	const deletable = (privData['topics:delete'] && (isOwner || isModerator)) || isAdministrator;

	return await plugins.hooks.fire('filter:privileges.topics.get', {
		'topics:reply': (privData['topics:reply'] && ((!topicData.locked && !topicData.deleted) || isModerator)) || isAdministrator,
		'topics:read': privData['topics:read'] || isAdministrator,
		'topics:tag': privData['topics:tag'] || isAdministrator,
		'topics:delete': (privData['topics:delete'] && (isOwner || isModerator)) || isAdministrator,
		'posts:edit': (privData['posts:edit'] && (!topicData.locked || isModerator)) || isAdministrator,
		'posts:history': privData['posts:history'] || isAdministrator,
		'posts:delete': (privData['posts:delete'] && (!topicData.locked || isModerator)) || isAdministrator,
		'posts:view_deleted': privData['posts:view_deleted'] || isAdministrator,
		read: privData.read || isAdministrator,
		purge: (privData.purge && (isOwner || isModerator)) || isAdministrator,

		view_thread_tools: editable || deletable,
		editable: editable,
		deletable: deletable,
		view_deleted: isAdminOrMod || isOwner,
		isAdminOrMod: isAdminOrMod,
		disabled: disabled,
		tid: tid,
		uid: uid,
	});
};

privsTopics.can = async function (privilege, tid, uid) {
	const cid = await topics.getTopicField(tid, 'cid');
	return await privsCategories.can(privilege, cid, uid);
};

privsTopics.filterTids = async function (privilege, tids, uid) {
	if (!Array.isArray(tids) || !tids.length) {
		return [];
	}

	const topicsData = await topics.getTopicsFields(tids, ['tid', 'cid', 'deleted']);
	const cids = _.uniq(topicsData.map(topic => topic.cid));
	const results = await privsCategories.getBase(privilege, cids, uid);

	const allowedCids = cids.filter((cid, index) => (
		!results.categories[index].disabled &&
		(results.allowedTo[index] || results.isAdmin)
	));

	const cidsSet = new Set(allowedCids);
	const canViewDeleted = _.zipObject(cids, results.view_deleted);

	tids = topicsData.filter(t => (
		cidsSet.has(t.cid) &&
		(!t.deleted || canViewDeleted[t.cid] || results.isAdmin)
	)).map(t => t.tid);

	const data = await plugins.hooks.fire('filter:privileges.topics.filter', {
		privilege: privilege,
		uid: uid,
		tids: tids,
	});
	return data ? data.tids : [];
};

privsTopics.filterUids = async function (privilege, tid, uids) {
	if (!Array.isArray(uids) || !uids.length) {
		return [];
	}

	uids = _.uniq(uids);
	const topicData = await topics.getTopicFields(tid, ['tid', 'cid', 'deleted']);
	const [disabled, allowedTo, isAdmins] = await Promise.all([
		categories.getCategoryField(topicData.cid, 'disabled'),
		helpers.isUsersAllowedTo(privilege, uids, topicData.cid),
		user.isAdministrator(uids),
	]);
	return uids.filter((uid, index) => !disabled &&
			((allowedTo[index] && !topicData.deleted) || isAdmins[index]));
};

privsTopics.canPurge = async function (tid, uid) {
	const cid = await topics.getTopicField(tid, 'cid');
	const [purge, owner, isAdmin, isModerator] = await Promise.all([
		privsCategories.isUserAllowedTo('purge', cid, uid),
		topics.isOwner(tid, uid),
		user.isAdministrator(uid),
		user.isModerator(uid, cid),
	]);
	return (purge && (owner || isModerator)) || isAdmin;
};

privsTopics.canDelete = async function (tid, uid) {
	const topicData = await topics.getTopicFields(tid, ['uid', 'cid', 'postcount', 'deleterUid']);
	const [isModerator, isAdministrator, isOwner, allowedTo] = await Promise.all([
		user.isModerator(uid, topicData.cid),
		user.isAdministrator(uid),
		topics.isOwner(tid, uid),
		helpers.isAllowedTo('topics:delete', uid, [topicData.cid]),
	]);

	if (isAdministrator) {
		return true;
	}

	const { preventTopicDeleteAfterReplies } = meta.config;
	if (!isModerator && preventTopicDeleteAfterReplies && (topicData.postcount - 1) >= preventTopicDeleteAfterReplies) {
		const langKey = preventTopicDeleteAfterReplies > 1 ?
			`[[error:cant-delete-topic-has-replies, ${meta.config.preventTopicDeleteAfterReplies}]]` :
			'[[error:cant-delete-topic-has-reply]]';
		throw new Error(langKey);
	}

	const { deleterUid } = topicData;
	return allowedTo[0] && ((isOwner && (deleterUid === 0 || deleterUid === topicData.uid)) || isModerator);
};

privsTopics.canEdit = async function (tid, uid) {
	return await privsTopics.isOwnerOrAdminOrMod(tid, uid);
};

privsTopics.isOwnerOrAdminOrMod = async function (tid, uid) {
	const [isOwner, isAdminOrMod] = await Promise.all([
		topics.isOwner(tid, uid),
		privsTopics.isAdminOrMod(tid, uid),
	]);
	return isOwner || isAdminOrMod;
};

privsTopics.isAdminOrMod = async function (tid, uid) {
	if (parseInt(uid, 10) <= 0) {

'use strict';

const _ = require('lodash');
const validator = require('validator');

const groups = require('../groups');
const user = require('../user');
const plugins = require('../plugins');
const translator = require('../translator');
const utils = require('../utils');

const helpers = module.exports;

const uidToSystemGroup = {
	0: 'guests',
	'-1': 'spiders',
};

helpers.isUsersAllowedTo = async function (privilege, uids, cid) {
	const [hasUserPrivilege, hasGroupPrivilege] = await Promise.all([
		groups.isMembers(uids, `cid:${cid}:privileges:${privilege}`),
		groups.isMembersOfGroupList(uids, `cid:${cid}:privileges:groups:${privilege}`),
	]);
	const allowed = uids.map((uid, index) => hasUserPrivilege[index] || hasGroupPrivilege[index]);
	const result = await plugins.hooks.fire('filter:privileges:isUsersAllowedTo', { allowed: allowed, privilege: privilege, uids: uids, cid: cid });
	return result.allowed;
};

helpers.isAllowedTo = async function (privilege, uidOrGroupName, cid) {
	let allowed;
	if (Array.isArray(privilege) && !Array.isArray(cid)) {
		allowed = await isAllowedToPrivileges(privilege, uidOrGroupName, cid);
	} else if (Array.isArray(cid) && !Array.isArray(privilege)) {
		allowed = await isAllowedToCids(privilege, uidOrGroupName, cid);
	}
	if (allowed) {
		({ allowed } = await plugins.hooks.fire('filter:privileges:isAllowedTo', { allowed: allowed, privilege: privilege, uid: uidOrGroupName, cid: cid }));
		return allowed;
	}
	throw new Error('[[error:invalid-data]]');
};

async function isAllowedToCids(privilege, uidOrGroupName, cids) {
	if (!privilege) {
		return cids.map(() => false);
	}

	const groupKeys = cids.map(cid => `cid:${cid}:privileges:groups:${privilege}`);

	// Group handling
	if (isNaN(parseInt(uidOrGroupName, 10)) && (uidOrGroupName || '').length) {
		return await checkIfAllowedGroup(uidOrGroupName, groupKeys);
	}

	// User handling
	if (parseInt(uidOrGroupName, 10) <= 0) {
		return await isSystemGroupAllowedToCids(privilege, uidOrGroupName, cids);
	}

	const userKeys = cids.map(cid => `cid:${cid}:privileges:${privilege}`);
	return await checkIfAllowedUser(uidOrGroupName, userKeys, groupKeys);
}

async function isAllowedToPrivileges(privileges, uidOrGroupName, cid) {
	const groupKeys = privileges.map(privilege => `cid:${cid}:privileges:groups:${privilege}`);
	// Group handling
	if (isNaN(parseInt(uidOrGroupName, 10)) && (uidOrGroupName || '').length) {
		return await checkIfAllowedGroup(uidOrGroupName, groupKeys);
	}

	// User handling
	if (parseInt(uidOrGroupName, 10) <= 0) {
		return await isSystemGroupAllowedToPrivileges(privileges, uidOrGroupName, cid);
	}

	const userKeys = privileges.map(privilege => `cid:${cid}:privileges:${privilege}`);
	return await checkIfAllowedUser(uidOrGroupName, userKeys, groupKeys);
}

async function checkIfAllowedUser(uid, userKeys, groupKeys) {
	const [hasUserPrivilege, hasGroupPrivilege] = await Promise.all([
		groups.isMemberOfGroups(uid, userKeys),
		groups.isMemberOfGroupsList(uid, groupKeys),
	]);
	return userKeys.map((key, index) => hasUserPrivilege[index] || hasGroupPrivilege[index]);
}

async function checkIfAllowedGroup(groupName, groupKeys) {
	const sets = await Promise.all([
		groups.isMemberOfGroups(groupName, groupKeys),
		groups.isMemberOfGroups('registered-users', groupKeys),
	]);
	return groupKeys.map((key, index) => sets[0][index] || sets[1][index]);
}

async function isSystemGroupAllowedToCids(privilege, uid, cids) {
	const groupKeys = cids.map(cid => `cid:${cid}:privileges:groups:${privilege}`);
	return await groups.isMemberOfGroups(uidToSystemGroup[uid], groupKeys);
}

async function isSystemGroupAllowedToPrivileges(privileges, uid, cid) {
	const groupKeys = privileges.map(privilege => `cid:${cid}:privileges:groups:${privilege}`);
	return await groups.isMemberOfGroups(uidToSystemGroup[uid], groupKeys);
}

helpers.getUserPrivileges = async function (cid, userPrivileges) {
	let memberSets = await groups.getMembersOfGroups(userPrivileges.map(privilege => `cid:${cid}:privileges:${privilege}`));
	memberSets = memberSets.map(set => set.map(uid => parseInt(uid, 10)));

	const members = _.uniq(_.flatten(memberSets));
	const memberData = await user.getUsersFields(members, ['picture', 'username', 'banned']);

	memberData.forEach((member) => {
		member.privileges = {};
		for (let x = 0, numPrivs = userPrivileges.length; x < numPrivs; x += 1) {
			member.privileges[userPrivileges[x]] = memberSets[x].includes(parseInt(member.uid, 10));
		}
	});

	return memberData;
};

helpers.getGroupPrivileges = async function (cid, groupPrivileges) {
	const [memberSets, allGroupNames] = await Promise.all([
		groups.getMembersOfGroups(groupPrivileges.map(privilege => `cid:${cid}:privileges:${privilege}`)),
		groups.getGroups('groups:createtime', 0, -1),
	]);

	const uniqueGroups = _.uniq(_.flatten(memberSets));

	let groupNames = allGroupNames.filter(groupName => !groupName.includes(':privileges:') && uniqueGroups.includes(groupName));

	groupNames = groups.ephemeralGroups.concat(groupNames);
	moveToFront(groupNames, groups.BANNED_USERS);
	moveToFront(groupNames, 'Global Moderators');
	moveToFront(groupNames, 'unverified-users');
	moveToFront(groupNames, 'verified-users');
	moveToFront(groupNames, 'registered-users');

	const adminIndex = groupNames.indexOf('administrators');
	if (adminIndex !== -1) {
		groupNames.splice(adminIndex, 1);
	}
	const groupData = await groups.getGroupsFields(groupNames, ['private', 'system']);
	const memberData = groupNames.map((member, index) => {
		const memberPrivs = {};

		for (let x = 0, numPrivs = groupPrivileges.length; x < numPrivs; x += 1) {
			memberPrivs[groupPrivileges[x]] = memberSets[x].includes(member);
		}
		return {
			name: validator.escape(member),
			nameEscaped: translator.escape(validator.escape(member)),
			privileges: memberPrivs,
			isPrivate: groupData[index] && !!groupData[index].private,
			isSystem: groupData[index] && !!groupData[index].system,
		};
	});
	return memberData;
};

function moveToFront(groupNames, groupToMove) {
	const index = groupNames.indexOf(groupToMove);
	if (index !== -1) {
		groupNames.splice(0, 0, groupNames.splice(index, 1)[0]);
	} else {
		groupNames.unshift(groupToMove);
	}
}

helpers.giveOrRescind = async function (method, privileges, cids, members) {
	members = Array.isArray(members) ? members : [members];
	cids = Array.isArray(cids) ? cids : [cids];
	for (const member of members) {
		const groupKeys = [];
		cids.forEach((cid) => {
			privileges.forEach((privilege) => {
				groupKeys.push(`cid:${cid}:privileges:${privilege}`);
			});
		});
		/* eslint-disable no-await-in-loop */
		await method(groupKeys, member);
	}
};

helpers.userOrGroupPrivileges = async function (cid, uidOrGroup, privilegeList) {
	const tasks = {};
	privilegeList.forEach((privilege) => {
		tasks[privilege] = groups.isMember(uidOrGroup, `cid:${cid}:privileges:${privilege}`);
'use strict';

const privileges = module.exports;
privileges.global = require('./global');
privileges.admin = require('./admin');
privileges.categories = require('./categories');
privileges.topics = require('./topics');
privileges.posts = require('./posts');
privileges.users = require('./users');

require('../promisify')(privileges);

// TODO: backwards compatibility remove in 1.18.0
[
	'privilegeLabels',
	'userPrivilegeList',
	'groupPrivilegeList',
	'privilegeList',
].forEach((fieldName) => {
	Object.defineProperty(privileges, fieldName, {
		configurable: true,
		enumerable: true,
		get: function () {
			console.warn(`[deprecated] privileges.${fieldName} is deprecated. Use privileges.categories.${fieldName}`);
			return privileges.categories[fieldName];

'use strict';

const _ = require('lodash');

const categories = require('../categories');
const user = require('../user');
const groups = require('../groups');
const helpers = require('./helpers');
const plugins = require('../plugins');
const utils = require('../utils');

const privsCategories = module.exports;

privsCategories.privilegeLabels = [
	{ name: '[[admin/manage/privileges:find-category]]' },
	{ name: '[[admin/manage/privileges:access-category]]' },
	{ name: '[[admin/manage/privileges:access-topics]]' },
	{ name: '[[admin/manage/privileges:create-topics]]' },
	{ name: '[[admin/manage/privileges:reply-to-topics]]' },
	{ name: '[[admin/manage/privileges:tag-topics]]' },
	{ name: '[[admin/manage/privileges:edit-posts]]' },
	{ name: '[[admin/manage/privileges:view-edit-history]]' },
	{ name: '[[admin/manage/privileges:delete-posts]]' },
	{ name: '[[admin/manage/privileges:upvote-posts]]' },
	{ name: '[[admin/manage/privileges:downvote-posts]]' },
	{ name: '[[admin/manage/privileges:delete-topics]]' },
	{ name: '[[admin/manage/privileges:view_deleted]]' },
	{ name: '[[admin/manage/privileges:purge]]' },
	{ name: '[[admin/manage/privileges:moderate]]' },
];

privsCategories.userPrivilegeList = [
	'find',
	'read',
	'topics:read',
	'topics:create',
	'topics:reply',
	'topics:tag',
	'posts:edit',
	'posts:history',
	'posts:delete',
	'posts:upvote',
	'posts:downvote',
	'topics:delete',
	'posts:view_deleted',
	'purge',
	'moderate',
];

privsCategories.groupPrivilegeList = privsCategories.userPrivilegeList.map(privilege => `groups:${privilege}`);

privsCategories.privilegeList = privsCategories.userPrivilegeList.concat(privsCategories.groupPrivilegeList);

// Method used in admin/category controller to show all users/groups with privs in that given cid
privsCategories.list = async function (cid) {
	async function getLabels() {
		return await utils.promiseParallel({
			users: plugins.hooks.fire('filter:privileges.list_human', privsCategories.privilegeLabels.slice()),
			groups: plugins.hooks.fire('filter:privileges.groups.list_human', privsCategories.privilegeLabels.slice()),
		});
	}

	const keys = await utils.promiseParallel({
		users: plugins.hooks.fire('filter:privileges.list', privsCategories.userPrivilegeList.slice()),
		groups: plugins.hooks.fire('filter:privileges.groups.list', privsCategories.groupPrivilegeList.slice()),
	});

	const payload = await utils.promiseParallel({
		labels: getLabels(),
		users: helpers.getUserPrivileges(cid, keys.users),
		groups: helpers.getGroupPrivileges(cid, keys.groups),
	});
	payload.keys = keys;

	// This is a hack because I can't do {labels.users.length} to echo the count in templates.js
	payload.columnCountUser = payload.labels.users.length + 3;
	payload.columnCountUserOther = payload.labels.users.length - privsCategories.privilegeLabels.length;
	payload.columnCountGroup = payload.labels.groups.length + 3;
	payload.columnCountGroupOther = payload.labels.groups.length - privsCategories.privilegeLabels.length;
	return payload;
};

privsCategories.get = async function (cid, uid) {
	const privs = ['topics:create', 'topics:read', 'topics:tag', 'read'];

	const [userPrivileges, isAdministrator, isModerator] = await Promise.all([
		helpers.isAllowedTo(privs, uid, cid),
		user.isAdministrator(uid),
		user.isModerator(uid, cid),
	]);

	const combined = userPrivileges.map(allowed => allowed || isAdministrator);
	const privData = _.zipObject(privs, combined);
	const isAdminOrMod = isAdministrator || isModerator;

	return await plugins.hooks.fire('filter:privileges.categories.get', {
		...privData,
		cid: cid,
		uid: uid,
		editable: isAdminOrMod,
		view_deleted: isAdminOrMod,
		isAdminOrMod: isAdminOrMod,
	});
};

privsCategories.isAdminOrMod = async function (cid, uid) {
	if (parseInt(uid, 10) <= 0) {
		return false;
	}
	const [isAdmin, isMod] = await Promise.all([
		user.isAdministrator(uid),
		user.isModerator(uid, cid),
	]);
	return isAdmin || isMod;
};

privsCategories.isUserAllowedTo = async function (privilege, cid, uid) {
	if ((Array.isArray(privilege) && !privilege.length) || (Array.isArray(cid) && !cid.length)) {
		return [];
	}
	if (!cid) {
		return false;
	}
	const results = await helpers.isAllowedTo(privilege, uid, Array.isArray(cid) ? cid : [cid]);

	if (Array.isArray(results) && results.length) {
		return Array.isArray(cid) ? results : results[0];
	}
	return false;
};

privsCategories.can = async function (privilege, cid, uid) {
	if (!cid) {
		return false;
	}
	const [disabled, isAdmin, isAllowed] = await Promise.all([
		categories.getCategoryField(cid, 'disabled'),
		user.isAdministrator(uid),
		privsCategories.isUserAllowedTo(privilege, cid, uid),
	]);
	return !disabled && (isAllowed || isAdmin);
};

privsCategories.filterCids = async function (privilege, cids, uid) {
	if (!Array.isArray(cids) || !cids.length) {
		return [];
	}

	cids = _.uniq(cids);
	const [categoryData, allowedTo, isAdmin] = await Promise.all([
		categories.getCategoriesFields(cids, ['disabled']),
		helpers.isAllowedTo(privilege, uid, cids),
		user.isAdministrator(uid),
	]);
	return cids.filter(
		(cid, index) => !!cid && !categoryData[index].disabled && (allowedTo[index] || isAdmin)
	);
};

privsCategories.getBase = async function (privilege, cids, uid) {
	return await utils.promiseParallel({
		categories: categories.getCategoriesFields(cids, ['disabled']),
		allowedTo: helpers.isAllowedTo(privilege, uid, cids),
		view_deleted: helpers.isAllowedTo('posts:view_deleted', uid, cids),
		isAdmin: user.isAdministrator(uid),
	});
};

privsCategories.filterUids = async function (privilege, cid, uids) {
	if (!uids.length) {
		return [];
	}

	uids = _.uniq(uids);

	const [allowedTo, isAdmins] = await Promise.all([
		helpers.isUsersAllowedTo(privilege, uids, cid),
		user.isAdministrator(uids),
	]);
	return uids.filter((uid, index) => allowedTo[index] || isAdmins[index]);
};

privsCategories.give = async function (privileges, cid, members) {
	await helpers.giveOrRescind(groups.join, privileges, cid, members);
	plugins.hooks.fire('action:privileges.categories.give', {
		privileges: privileges,
		cids: Array.isArray(cid) ? cid : [cid],
		members: Array.isArray(members) ? members : [members],
	});
};

privsCategories.rescind = async function (privileges, cid, members) {
	await helpers.giveOrRescind(groups.leave, privileges, cid, members);
	plugins.hooks.fire('action:privileges.categories.rescind', {
		privileges: privileges,
		cids: Array.isArray(cid) ? cid : [cid],
		members: Array.isArray(members) ? members : [members],
	});
};

privsCategories.canMoveAllTopics = async function (currentCid, targetCid, uid) {
	const [isAdmin, isModerators] = await Promise.all([
		user.isAdministrator(uid),
		user.isModerator(uid, [currentCid, targetCid]),
	]);
	return isAdmin || !isModerators.includes(false);
};

privsCategories.userPrivileges = async function (cid, uid) {
	return await helpers.userOrGroupPrivileges(cid, uid, privsCategories.userPrivilegeList);
};

privsCategories.groupPrivileges = async function (cid, groupName) {
	return await helpers.userOrGroupPrivileges(cid, groupName, privsCategories.groupPrivilegeList);

'use strict';

const _ = require('lodash');

const meta = require('../meta');
const posts = require('../posts');
const topics = require('../topics');
const user = require('../user');
const helpers = require('./helpers');
const plugins = require('../plugins');
const utils = require('../utils');
const privsCategories = require('./categories');

const privsPosts = module.exports;

privsPosts.get = async function (pids, uid) {
	if (!Array.isArray(pids) || !pids.length) {
		return [];
	}
	const cids = await posts.getCidsByPids(pids);
	const uniqueCids = _.uniq(cids);

	const results = await utils.promiseParallel({
		isAdmin: user.isAdministrator(uid),
		isModerator: user.isModerator(uid, uniqueCids),
		isOwner: posts.isOwner(pids, uid),
		'topics:read': helpers.isAllowedTo('topics:read', uid, uniqueCids),
		read: helpers.isAllowedTo('read', uid, uniqueCids),
		'posts:edit': helpers.isAllowedTo('posts:edit', uid, uniqueCids),
		'posts:history': helpers.isAllowedTo('posts:history', uid, uniqueCids),
		'posts:view_deleted': helpers.isAllowedTo('posts:view_deleted', uid, uniqueCids),
	});

	const isModerator = _.zipObject(uniqueCids, results.isModerator);
	const privData = {};
	privData['topics:read'] = _.zipObject(uniqueCids, results['topics:read']);
	privData.read = _.zipObject(uniqueCids, results.read);
	privData['posts:edit'] = _.zipObject(uniqueCids, results['posts:edit']);
	privData['posts:history'] = _.zipObject(uniqueCids, results['posts:history']);
	privData['posts:view_deleted'] = _.zipObject(uniqueCids, results['posts:view_deleted']);

	const privileges = cids.map((cid, i) => {
		const isAdminOrMod = results.isAdmin || isModerator[cid];
		const editable = (privData['posts:edit'][cid] && (results.isOwner[i] || results.isModerator)) || results.isAdmin;
		const viewDeletedPosts = results.isOwner[i] || privData['posts:view_deleted'][cid] || results.isAdmin;
		const viewHistory = results.isOwner[i] || privData['posts:history'][cid] || results.isAdmin;

		return {
			editable: editable,
			move: isAdminOrMod,
			isAdminOrMod: isAdminOrMod,
			'topics:read': privData['topics:read'][cid] || results.isAdmin,
			read: privData.read[cid] || results.isAdmin,
			'posts:history': viewHistory,
			'posts:view_deleted': viewDeletedPosts,
		};
	});

	return privileges;
};

privsPosts.can = async function (privilege, pid, uid) {
	const cid = await posts.getCidByPid(pid);
	return await privsCategories.can(privilege, cid, uid);
};

privsPosts.filter = async function (privilege, pids, uid) {
	if (!Array.isArray(pids) || !pids.length) {
		return [];
	}

	pids = _.uniq(pids);
	const postData = await posts.getPostsFields(pids, ['uid', 'tid', 'deleted']);
	const tids = _.uniq(postData.map(post => post && post.tid).filter(Boolean));
	const topicData = await topics.getTopicsFields(tids, ['deleted', 'cid']);

	const tidToTopic = _.zipObject(tids, topicData);

	let cids = postData.map((post, index) => {
		if (post) {
			post.pid = pids[index];
			post.topic = tidToTopic[post.tid];
		}
		return tidToTopic[post.tid] && tidToTopic[post.tid].cid;
	}).filter(cid => parseInt(cid, 10));

	cids = _.uniq(cids);

	const results = await privsCategories.getBase(privilege, cids, uid);
	const allowedCids = cids.filter((cid, index) => !results.categories[index].disabled &&
			(results.allowedTo[index] || results.isAdmin));

	const cidsSet = new Set(allowedCids);
	const canViewDeleted = _.zipObject(cids, results.view_deleted);

	pids = postData.filter(post => (
		post.topic &&
		cidsSet.has(post.topic.cid) &&
		((!post.topic.deleted && !post.deleted) || canViewDeleted[post.topic.cid] || results.isAdmin)
	)).map(post => post.pid);

	const data = await plugins.hooks.fire('filter:privileges.posts.filter', {
		privilege: privilege,
		uid: uid,
		pids: pids,
	});

	return data ? data.pids : null;
};

privsPosts.canEdit = async function (pid, uid) {
	const results = await utils.promiseParallel({
		isAdmin: user.isAdministrator(uid),
		isMod: posts.isModerator([pid], uid),
		owner: posts.isOwner(pid, uid),
		edit: privsPosts.can('posts:edit', pid, uid),
		postData: posts.getPostFields(pid, ['tid', 'timestamp', 'deleted', 'deleterUid']),
		userData: user.getUserFields(uid, ['reputation']),
	});

	results.isMod = results.isMod[0];
	if (results.isAdmin) {
		return { flag: true };
	}

	if (
		!results.isMod &&
		meta.config.postEditDuration &&
		(Date.now() - results.postData.timestamp > meta.config.postEditDuration * 1000)
	) {
		return { flag: false, message: `[[error:post-edit-duration-expired, ${meta.config.postEditDuration}]]` };
	}
	if (
		!results.isMod &&
		meta.config.newbiePostEditDuration > 0 &&
		meta.config.newbiePostDelayThreshold > results.userData.reputation &&
		Date.now() - results.postData.timestamp > meta.config.newbiePostEditDuration * 1000
	) {
		return { flag: false, message: `[[error:post-edit-duration-expired, ${meta.config.newbiePostEditDuration}]]` };
	}

	const isLocked = await topics.isLocked(results.postData.tid);
	if (!results.isMod && isLocked) {
		return { flag: false, message: '[[error:topic-locked]]' };
	}

	if (!results.isMod && results.postData.deleted && parseInt(uid, 10) !== parseInt(results.postData.deleterUid, 10)) {
		return { flag: false, message: '[[error:post-deleted]]' };
	}

	results.pid = parseInt(pid, 10);
	results.uid = uid;

	const result = await plugins.hooks.fire('filter:privileges.posts.edit', results);
	return { flag: result.edit && (result.owner || result.isMod), message: '[[error:no-privileges]]' };
};

privsPosts.canDelete = async function (pid, uid) {
	const postData = await posts.getPostFields(pid, ['uid', 'tid', 'timestamp', 'deleterUid']);
	const results = await utils.promiseParallel({
		isAdmin: user.isAdministrator(uid),
		isMod: posts.isModerator([pid], uid),
		isLocked: topics.isLocked(postData.tid),
		isOwner: posts.isOwner(pid, uid),
		'posts:delete': privsPosts.can('posts:delete', pid, uid),
	});
	results.isMod = results.isMod[0];
	if (results.isAdmin) {
		return { flag: true };
	}

	if (!results.isMod && results.isLocked) {
		return { flag: false, message: '[[error:topic-locked]]' };
	}

	const { postDeleteDuration } = meta.config;
	if (!results.isMod && postDeleteDuration && (Date.now() - postData.timestamp > postDeleteDuration * 1000)) {
		return { flag: false, message: `[[error:post-delete-duration-expired, ${meta.config.postDeleteDuration}]]` };
	}
	const { deleterUid } = postData;
	const flag = results['posts:delete'] && ((results.isOwner && (deleterUid === 0 || deleterUid === postData.uid)) || results.isMod);
	return { flag: flag, message: '[[error:no-privileges]]' };
};

privsPosts.canFlag = async function (pid, uid) {
	const targetUid = await posts.getPostField(pid, 'uid');
	const [userReputation, isAdminOrModerator, targetPrivileged, reporterPrivileged] = await Promise.all([
		user.getUserField(uid, 'reputation'),
		isAdminOrMod(pid, uid),
		user.isPrivileged(targetUid),
		user.isPrivileged(uid),
	]);
	const minimumReputation = meta.config['min:rep:flag'];
	let canFlag = isAdminOrModerator || (userReputation >= minimumReputation);

	if (targetPrivileged && !reporterPrivileged) {
		canFlag = false;
	}

	return { flag: canFlag };
};

privsPosts.canMove = async function (pid, uid) {
	const isMain = await posts.isMain(pid);
	if (isMain) {
		throw new Error('[[error:cant-move-mainpost]]');
	}
	return await isAdminOrMod(pid, uid);
};

privsPosts.canPurge = async function (pid, uid) {
	const cid = await posts.getCidByPid(pid);
	const results = await utils.promiseParallel({
		purge: privsCategories.isUserAllowedTo('purge', cid, uid),
		owner: posts.isOwner(pid, uid),
		isAdmin: user.isAdministrator(uid),
		isModerator: user.isModerator(uid, cid),
	});
	return (results.purge && (results.owner || results.isModerator)) || results.isAdmin;
};

async function isAdminOrMod(pid, uid) {
	if (parseInt(uid, 10) <= 0) {
		return false;

'use strict';

const _ = require('lodash');

const user = require('../user');
const meta = require('../meta');
const groups = require('../groups');
const plugins = require('../plugins');
const helpers = require('./helpers');

const privsUsers = module.exports;

privsUsers.isAdministrator = async function (uid) {
	return await isGroupMember(uid, 'administrators');
};

privsUsers.isGlobalModerator = async function (uid) {
	return await isGroupMember(uid, 'Global Moderators');
};

async function isGroupMember(uid, groupName) {
	return await groups[Array.isArray(uid) ? 'isMembers' : 'isMember'](uid, groupName);
}

privsUsers.isModerator = async function (uid, cid) {
	if (Array.isArray(cid)) {
		return await isModeratorOfCategories(cid, uid);
	} else if (Array.isArray(uid)) {
		return await isModeratorsOfCategory(cid, uid);
	}
	return await isModeratorOfCategory(cid, uid);
};

async function isModeratorOfCategories(cids, uid) {
	if (parseInt(uid, 10) <= 0) {
		return await filterIsModerator(cids, uid, cids.map(() => false));
	}

	const isGlobalModerator = await privsUsers.isGlobalModerator(uid);
	if (isGlobalModerator) {
		return await filterIsModerator(cids, uid, cids.map(() => true));
	}
	const uniqueCids = _.uniq(cids);
	const isAllowed = await helpers.isAllowedTo('moderate', uid, uniqueCids);

	const cidToIsAllowed = _.zipObject(uniqueCids, isAllowed);
	const isModerator = cids.map(cid => cidToIsAllowed[cid]);
	return await filterIsModerator(cids, uid, isModerator);
}

async function isModeratorsOfCategory(cid, uids) {
	const [check1, check2, check3] = await Promise.all([
		privsUsers.isGlobalModerator(uids),
		groups.isMembers(uids, `cid:${cid}:privileges:moderate`),
		groups.isMembersOfGroupList(uids, `cid:${cid}:privileges:groups:moderate`),
	]);
	const isModerator = uids.map((uid, idx) => check1[idx] || check2[idx] || check3[idx]);
	return await filterIsModerator(cid, uids, isModerator);
}

async function isModeratorOfCategory(cid, uid) {
	const result = await isModeratorOfCategories([cid], uid);
	return result ? result[0] : false;
}

async function filterIsModerator(cid, uid, isModerator) {
	const data = await plugins.hooks.fire('filter:user.isModerator', { uid: uid, cid: cid, isModerator: isModerator });
	if ((Array.isArray(uid) || Array.isArray(cid)) && !Array.isArray(data.isModerator)) {
		throw new Error('filter:user.isModerator - i/o mismatch');
	}

	return data.isModerator;
}

privsUsers.canEdit = async function (callerUid, uid) {
	if (parseInt(callerUid, 10) === parseInt(uid, 10)) {
		return true;
	}
	const [isAdmin, isGlobalMod, isTargetAdmin] = await Promise.all([
		privsUsers.isAdministrator(callerUid),
		privsUsers.isGlobalModerator(callerUid),
		privsUsers.isAdministrator(uid),
	]);

	const data = await plugins.hooks.fire('filter:user.canEdit', {
		isAdmin: isAdmin,
		isGlobalMod: isGlobalMod,
		isTargetAdmin: isTargetAdmin,
		canEdit: isAdmin || (isGlobalMod && !isTargetAdmin),
		callerUid: callerUid,
		uid: uid,
	});
	return data.canEdit;
};

privsUsers.canBanUser = async function (callerUid, uid) {
	const privsGlobal = require('./global');
	const [canBan, isTargetAdmin] = await Promise.all([
		privsGlobal.can('ban', callerUid),
		privsUsers.isAdministrator(uid),
	]);

	const data = await plugins.hooks.fire('filter:user.canBanUser', {
		canBan: canBan && !isTargetAdmin,
		callerUid: callerUid,
		uid: uid,
	});
	return data.canBan;
};

privsUsers.canFlag = async function (callerUid, uid) {
	const [userReputation, targetPrivileged, reporterPrivileged] = await Promise.all([
		user.getUserField(callerUid, 'reputation'),
		user.isPrivileged(uid),
		user.isPrivileged(callerUid),
	]);
	const minimumReputation = meta.config['min:rep:flag'];
	let canFlag = reporterPrivileged || (userReputation >= minimumReputation);

	if (targetPrivileged && !reporterPrivileged) {
		canFlag = false;
	}

	return { flag: canFlag };
};

privsUsers.hasBanPrivilege = async uid => await hasGlobalPrivilege('ban', uid);
privsUsers.hasInvitePrivilege = async uid => await hasGlobalPrivilege('invite', uid);

async function hasGlobalPrivilege(privilege, uid) {
	const privsGlobal = require('./global');
	const privilegeName = privilege.split('-').map(word => word.slice(0, 1).toUpperCase() + word.slice(1)).join('');
	let payload = { uid };
	payload[`can${privilegeName}`] = await privsGlobal.can(privilege, uid);
'use strict';

const meta = require('../meta');
const plugins = require('../plugins');
const db = require('../database');
const user = require('../user');

module.exports = function (Messaging) {
	Messaging.sendMessage = async (data) => {
		await Messaging.checkContent(data.content);
		const inRoom = await Messaging.isUserInRoom(data.uid, data.roomId);
		if (!inRoom) {
			throw new Error('[[error:not-allowed]]');
		}

		return await Messaging.addMessage(data);
	};

	Messaging.checkContent = async (content) => {
		if (!content) {
			throw new Error('[[error:invalid-chat-message]]');
		}

		const maximumChatMessageLength = meta.config.maximumChatMessageLength || 1000;
		content = String(content).trim();
		let length = String(content.length).trim();
		({ content, length } = await plugins.hooks.fire('filter:messaging.checkContent', { content, length }));
		if (!content) {
			throw new Error('[[error:invalid-chat-message]]');
		}
		if (length > maximumChatMessageLength) {
			throw new Error(`[[error:chat-message-too-long, ${maximumChatMessageLength}]]`);
		}
	};

	Messaging.addMessage = async (data) => {
		const mid = await db.incrObjectField('global', 'nextMid');
		const timestamp = data.timestamp || Date.now();
		let message = {
			content: String(data.content),
			timestamp: timestamp,
			fromuid: data.uid,
			roomId: data.roomId,
			deleted: 0,
			system: data.system || 0,
		};

		if (data.ip) {
			message.ip = data.ip;
		}

		message = await plugins.hooks.fire('filter:messaging.save', message);
		await db.setObject(`message:${mid}`, message);
		const isNewSet = await Messaging.isNewSet(data.uid, data.roomId, timestamp);
		let uids = await db.getSortedSetRange(`chat:room:${data.roomId}:uids`, 0, -1);
		uids = await user.blocks.filterUids(data.uid, uids);

		await Promise.all([
			Messaging.addRoomToUsers(data.roomId, uids, timestamp),
			Messaging.addMessageToUsers(data.roomId, uids, mid, timestamp),
			Messaging.markUnread(uids.filter(uid => uid !== String(data.uid)), data.roomId),
		]);

		const messages = await Messaging.getMessagesData([mid], data.uid, data.roomId, true);
		if (!messages || !messages[0]) {
			return null;
		}

		messages[0].newSet = isNewSet;
		messages[0].mid = mid;
		messages[0].roomId = data.roomId;
		plugins.hooks.fire('action:messaging.save', { message: messages[0], data: data });
		return messages[0];
	};

	Messaging.addSystemMessage = async (content, uid, roomId) => {
		const message = await Messaging.addMessage({
			content: content,
			uid: uid,
			roomId: roomId,
			system: 1,
		});
		Messaging.notifyUsersInRoom(uid, roomId, message);
	};

	Messaging.addRoomToUsers = async (roomId, uids, timestamp) => {
		if (!uids.length) {
			return;
		}

		const keys = uids.map(uid => `uid:${uid}:chat:rooms`);
		await db.sortedSetsAdd(keys, timestamp, roomId);
	};

	Messaging.addMessageToUsers = async (roomId, uids, mid, timestamp) => {
		if (!uids.length) {
			return;
		}
		const keys = uids.map(uid => `uid:${uid}:chat:room:${roomId}:mids`);
		await db.sortedSetsAdd(keys, timestamp, mid);
'use strict';

const validator = require('validator');

const db = require('../database');
const user = require('../user');
const utils = require('../utils');
const plugins = require('../plugins');

const intFields = ['timestamp', 'edited', 'fromuid', 'roomId', 'deleted', 'system'];

module.exports = function (Messaging) {
	Messaging.newMessageCutoff = 1000 * 60 * 3;

	Messaging.getMessagesFields = async (mids, fields) => {
		if (!Array.isArray(mids) || !mids.length) {
			return [];
		}

		const keys = mids.map(mid => `message:${mid}`);
		const messages = await (fields.length ? db.getObjectsFields(keys, fields) : db.getObjects(keys));

		return await Promise.all(messages.map(
			async (message, idx) => modifyMessage(message, fields, parseInt(mids[idx], 10))
		));
	};

	Messaging.getMessageField = async (mid, field) => {
		const fields = await Messaging.getMessageFields(mid, [field]);
		return fields ? fields[field] : null;
	};

	Messaging.getMessageFields = async (mid, fields) => {
		const messages = await Messaging.getMessagesFields([mid], fields);
		return messages ? messages[0] : null;
	};

	Messaging.setMessageField = async (mid, field, content) => {
		await db.setObjectField(`message:${mid}`, field, content);
	};

	Messaging.setMessageFields = async (mid, data) => {
		await db.setObject(`message:${mid}`, data);
	};

	Messaging.getMessagesData = async (mids, uid, roomId, isNew) => {
		let messages = await Messaging.getMessagesFields(mids, []);
		messages = await user.blocks.filter(uid, 'fromuid', messages);
		messages = messages
			.map((msg, idx) => {
				if (msg) {
					msg.messageId = parseInt(mids[idx], 10);
					msg.ip = undefined;
				}
				return msg;
			})
			.filter(Boolean);

		const users = await user.getUsersFields(
			messages.map(msg => msg && msg.fromuid),
			['uid', 'username', 'userslug', 'picture', 'status', 'banned']
		);

		messages.forEach((message, index) => {
			message.fromUser = users[index];
			message.fromUser.banned = !!message.fromUser.banned;
			message.fromUser.deleted = message.fromuid !== message.fromUser.uid && message.fromUser.uid === 0;

			const self = message.fromuid === parseInt(uid, 10);
			message.self = self ? 1 : 0;

			message.newSet = false;
			message.roomId = String(message.roomId || roomId);
			message.deleted = !!message.deleted;
			message.system = !!message.system;
		});

		messages = await Promise.all(messages.map(async (message) => {
			if (message.system) {
				message.content = validator.escape(String(message.content));
				message.cleanedContent = utils.stripHTMLTags(utils.decodeHTMLEntities(message.content));
				return message;
			}

			const result = await Messaging.parse(message.content, message.fromuid, uid, roomId, isNew);
			message.content = result;
			message.cleanedContent = utils.stripHTMLTags(utils.decodeHTMLEntities(result));
			return message;
		}));

		if (messages.length > 1) {
			// Add a spacer in between messages with time gaps between them
			messages = messages.map((message, index) => {
				// Compare timestamps with the previous message, and check if a spacer needs to be added
				if (index > 0 && message.timestamp > messages[index - 1].timestamp + Messaging.newMessageCutoff) {
					// If it's been 5 minutes, this is a new set of messages
					message.newSet = true;
				} else if (index > 0 && message.fromuid !== messages[index - 1].fromuid) {
					// If the previous message was from the other person, this is also a new set
					message.newSet = true;
				} else if (index === 0) {
					message.newSet = true;
				}

				return message;
			});
		} else if (messages.length === 1) {
			// For single messages, we don't know the context, so look up the previous message and compare
			const key = `uid:${uid}:chat:room:${roomId}:mids`;
			const index = await db.sortedSetRank(key, messages[0].messageId);
			if (index > 0) {
				const mid = await db.getSortedSetRange(key, index - 1, index - 1);
				const fields = await Messaging.getMessageFields(mid, ['fromuid', 'timestamp']);
				if ((messages[0].timestamp > fields.timestamp + Messaging.newMessageCutoff) ||
					(messages[0].fromuid !== fields.fromuid)) {
					// If it's been 5 minutes, this is a new set of messages
					messages[0].newSet = true;
				}
			} else {
				messages[0].newSet = true;
			}
		} else {
			messages = [];
		}

		const data = await plugins.hooks.fire('filter:messaging.getMessages', {
			messages: messages,
			uid: uid,
			roomId: roomId,
			isNew: isNew,
			mids: mids,
		});

		return data && data.messages;
	};
};

async function modifyMessage(message, fields, mid) {
	if (message) {
		db.parseIntFields(message, intFields, fields);
		if (message.hasOwnProperty('timestamp')) {
			message.timestampISO = utils.toISOString(message.timestamp);
		}
		if (message.hasOwnProperty('edited')) {
			message.editedISO = utils.toISOString(message.edited);
		}
	}

	const payload = await plugins.hooks.fire('filter:messaging.getFields', {
		mid: mid,
		message: message,
		fields: fields,
	});

	return payload.message;
'use strict';

const sockets = require('../socket.io');

module.exports = function (Messaging) {
	Messaging.deleteMessage = async (mid, uid) => await doDeleteRestore(mid, 1, uid);
	Messaging.restoreMessage = async (mid, uid) => await doDeleteRestore(mid, 0, uid);

	async function doDeleteRestore(mid, state, uid) {
		const field = state ? 'deleted' : 'restored';
		const { deleted, roomId } = await Messaging.getMessageFields(mid, ['deleted', 'roomId']);
		if (deleted === state) {
			throw new Error(`[[error:chat-${field}-already]]`);
		}

		await Messaging.setMessageField(mid, 'deleted', state);

		const [uids, messages] = await Promise.all([
			Messaging.getUidsInRoom(roomId, 0, -1),
			Messaging.getMessagesData([mid], uid, roomId, true),
		]);

		uids.forEach((_uid) => {
			if (parseInt(_uid, 10) !== parseInt(uid, 10)) {
				if (state === 1) {
					sockets.in(`uid_${_uid}`).emit('event:chats.delete', mid);
				} else if (state === 0) {
					sockets.in(`uid_${_uid}`).emit('event:chats.restore', messages[0]);
				}
			}
'use strict';

const db = require('../database');
const sockets = require('../socket.io');

module.exports = function (Messaging) {
	Messaging.getUnreadCount = async (uid) => {
		if (parseInt(uid, 10) <= 0) {
			return 0;
		}

		return await db.sortedSetCard(`uid:${uid}:chat:rooms:unread`);
	};

	Messaging.pushUnreadCount = async (uid) => {
		if (parseInt(uid, 10) <= 0) {
			return;
		}
		const unreadCount = await Messaging.getUnreadCount(uid);
		sockets.in(`uid_${uid}`).emit('event:unread.updateChatCount', unreadCount);
	};

	Messaging.markRead = async (uid, roomId) => {
		await db.sortedSetRemove(`uid:${uid}:chat:rooms:unread`, roomId);
	};

	Messaging.markAllRead = async (uid) => {
		await db.delete(`uid:${uid}:chat:rooms:unread`);
	};

	Messaging.markUnread = async (uids, roomId) => {
		const exists = await Messaging.roomExists(roomId);
		if (!exists) {
			throw new Error('[[error:chat-room-does-not-exist]]');
		}
'use strict';

const meta = require('../meta');
const user = require('../user');
const plugins = require('../plugins');
const privileges = require('../privileges');

const sockets = require('../socket.io');


module.exports = function (Messaging) {
	Messaging.editMessage = async (uid, mid, roomId, content) => {
		await Messaging.checkContent(content);
		const raw = await Messaging.getMessageField(mid, 'content');
		if (raw === content) {
			return;
		}

		const payload = await plugins.hooks.fire('filter:messaging.edit', {
			content: content,
			edited: Date.now(),
		});

		if (!String(payload.content).trim()) {
			throw new Error('[[error:invalid-chat-message]]');
		}
		await Messaging.setMessageFields(mid, payload);

		// Propagate this change to users in the room
		const [uids, messages] = await Promise.all([
			Messaging.getUidsInRoom(roomId, 0, -1),
			Messaging.getMessagesData([mid], uid, roomId, true),
		]);

		uids.forEach((uid) => {
			sockets.in(`uid_${uid}`).emit('event:chats.edit', {
				messages: messages,
			});
		});
	};

	const canEditDelete = async (messageId, uid, type) => {
		let durationConfig = '';
		if (type === 'edit') {
			durationConfig = 'chatEditDuration';
		} else if (type === 'delete') {
			durationConfig = 'chatDeleteDuration';
		}

		const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(uid);

		if (meta.config.disableChat) {
			throw new Error('[[error:chat-disabled]]');
		} else if (!isAdminOrGlobalMod && meta.config.disableChatMessageEditing) {
			throw new Error('[[error:chat-message-editing-disabled]]');
		}

		const userData = await user.getUserFields(uid, ['banned']);
		if (userData.banned) {
			throw new Error('[[error:user-banned]]');
		}

		const canChat = await privileges.global.can('chat', uid);
		if (!canChat) {
			throw new Error('[[error:no-privileges]]');
		}

		const messageData = await Messaging.getMessageFields(messageId, ['fromuid', 'timestamp', 'system']);
		if (isAdminOrGlobalMod && !messageData.system) {
			return;
		}

		const chatConfigDuration = meta.config[durationConfig];
		if (chatConfigDuration && Date.now() - messageData.timestamp > chatConfigDuration * 1000) {
			throw new Error(`[[error:chat-${type}-duration-expired, ${meta.config[durationConfig]}]]`);
		}

		if (messageData.fromuid === parseInt(uid, 10) && !messageData.system) {
			return;
		}

		throw new Error(`[[error:cant-${type}-chat-message]]`);
	};

	Messaging.canEdit = async (messageId, uid) => await canEditDelete(messageId, uid, 'edit');
'use strict';


const validator = require('validator');

const db = require('../database');
const user = require('../user');
const privileges = require('../privileges');
const plugins = require('../plugins');
const meta = require('../meta');
const utils = require('../utils');

const Messaging = module.exports;

require('./data')(Messaging);
require('./create')(Messaging);
require('./delete')(Messaging);
require('./edit')(Messaging);
require('./rooms')(Messaging);
require('./unread')(Messaging);
require('./notifications')(Messaging);


Messaging.getMessages = async (params) => {
	const isNew = params.isNew || false;
	const start = params.hasOwnProperty('start') ? params.start : 0;
	const stop = parseInt(start, 10) + ((params.count || 50) - 1);

	const indices = {};
	const ok = await canGet('filter:messaging.canGetMessages', params.callerUid, params.uid);
	if (!ok) {
		return;
	}

	const mids = await db.getSortedSetRevRange(`uid:${params.uid}:chat:room:${params.roomId}:mids`, start, stop);
	if (!mids.length) {
		return [];
	}
	mids.forEach((mid, index) => {
		indices[mid] = start + index;
	});
	mids.reverse();

	const messageData = await Messaging.getMessagesData(mids, params.uid, params.roomId, isNew);
	messageData.forEach((messageData) => {
		messageData.index = indices[messageData.messageId.toString()];
		messageData.isOwner = messageData.fromuid === parseInt(params.uid, 10);
		if (messageData.deleted && !messageData.isOwner) {
			messageData.content = '[[modules:chat.message-deleted]]';
		}
	});

	return messageData;
};

async function canGet(hook, callerUid, uid) {
	const data = await plugins.hooks.fire(hook, {
		callerUid: callerUid,
		uid: uid,
		canGet: parseInt(callerUid, 10) === parseInt(uid, 10),
	});

	return data ? data.canGet : false;
}

Messaging.parse = async (message, fromuid, uid, roomId, isNew) => {
	const parsed = await plugins.hooks.fire('filter:parse.raw', message);
	let messageData = {
		message: message,
		parsed: parsed,
		fromuid: fromuid,
		uid: uid,
		roomId: roomId,
		isNew: isNew,
		parsedMessage: parsed,
	};

	messageData = await plugins.hooks.fire('filter:messaging.parse', messageData);
	return messageData ? messageData.parsedMessage : '';
};

Messaging.isNewSet = async (uid, roomId, timestamp) => {
	const setKey = `uid:${uid}:chat:room:${roomId}:mids`;
	const messages = await db.getSortedSetRevRangeWithScores(setKey, 0, 0);
	if (messages && messages.length) {
		return parseInt(timestamp, 10) > parseInt(messages[0].score, 10) + Messaging.newMessageCutoff;
	}
	return true;
};

Messaging.getRecentChats = async (callerUid, uid, start, stop) => {
	const ok = await canGet('filter:messaging.canGetRecentChats', callerUid, uid);
	if (!ok) {
		return null;
	}

	const roomIds = await db.getSortedSetRevRange(`uid:${uid}:chat:rooms`, start, stop);
	const results = await utils.promiseParallel({
		roomData: Messaging.getRoomsData(roomIds),
		unread: db.isSortedSetMembers(`uid:${uid}:chat:rooms:unread`, roomIds),
		users: Promise.all(roomIds.map(async (roomId) => {
			let uids = await db.getSortedSetRevRange(`chat:room:${roomId}:uids`, 0, 9);
			uids = uids.filter(_uid => _uid && parseInt(_uid, 10) !== parseInt(uid, 10));
			return await user.getUsersFields(uids, ['uid', 'username', 'userslug', 'picture', 'status', 'lastonline']);
		})),
		teasers: Promise.all(roomIds.map(async roomId => Messaging.getTeaser(uid, roomId))),
	});

	results.roomData.forEach((room, index) => {
		if (room) {
			room.users = results.users[index];
			room.groupChat = room.hasOwnProperty('groupChat') ? room.groupChat : room.users.length > 2;
			room.unread = results.unread[index];
			room.teaser = results.teasers[index];

			room.users.forEach((userData) => {
				if (userData && parseInt(userData.uid, 10)) {
					userData.status = user.getStatus(userData);
				}
			});
			room.users = room.users.filter(user => user && parseInt(user.uid, 10));
			room.lastUser = room.users[0];

			room.usernames = Messaging.generateUsernames(room.users, uid);
		}
	});

	results.roomData = results.roomData.filter(Boolean);
	const ref = { rooms: results.roomData, nextStart: stop + 1 };
	return await plugins.hooks.fire('filter:messaging.getRecentChats', {
		rooms: ref.rooms,
		nextStart: ref.nextStart,
		uid: uid,
		callerUid: callerUid,
	});
};

Messaging.generateUsernames = (users, excludeUid) => users.filter(user => user && parseInt(user.uid, 10) !== excludeUid)
	.map(user => user.username).join(', ');

Messaging.getTeaser = async (uid, roomId) => {
	const mid = await Messaging.getLatestUndeletedMessage(uid, roomId);
	if (!mid) {
		return null;
	}
	const teaser = await Messaging.getMessageFields(mid, ['fromuid', 'content', 'timestamp']);
	if (!teaser.fromuid) {
		return null;
	}
	const blocked = await user.blocks.is(teaser.fromuid, uid);
	if (blocked) {
		return null;
	}

	teaser.user = await user.getUserFields(teaser.fromuid, ['uid', 'username', 'userslug', 'picture', 'status', 'lastonline']);
	if (teaser.content) {
		teaser.content = utils.stripHTMLTags(utils.decodeHTMLEntities(teaser.content));
		teaser.content = validator.escape(String(teaser.content));
	}

	const payload = await plugins.hooks.fire('filter:messaging.getTeaser', { teaser: teaser });
	return payload.teaser;
};

Messaging.getLatestUndeletedMessage = async (uid, roomId) => {
	let done = false;
	let latestMid = null;
	let index = 0;
	let mids;

	while (!done) {
		/* eslint-disable no-await-in-loop */
		mids = await db.getSortedSetRevRange(`uid:${uid}:chat:room:${roomId}:mids`, index, index);
		if (mids.length) {
			const states = await Messaging.getMessageFields(mids[0], ['deleted', 'system']);
			done = !states.deleted && !states.system;
			if (done) {
				latestMid = mids[0];
			}
			index += 1;
		} else {
			done = true;
		}
	}

	return latestMid;
};

Messaging.canMessageUser = async (uid, toUid) => {
	if (meta.config.disableChat || uid <= 0 || uid === toUid) {
		throw new Error('[[error:chat-disabled]]');
	}

	if (parseInt(uid, 10) === parseInt(toUid, 10)) {
		throw new Error('[[error:cant-chat-with-yourself');
	}

	const exists = await user.exists(toUid);
	if (!exists) {
		throw new Error('[[error:no-user]]');
	}

	const canChat = await privileges.global.can('chat', uid);
	if (!canChat) {
		throw new Error('[[error:no-privileges]]');
	}

	const results = await utils.promiseParallel({
		settings: user.getSettings(toUid),
		isAdmin: user.isAdministrator(uid),
		isModerator: user.isModeratorOfAnyCategory(uid),
		isFollowing: user.isFollowing(toUid, uid),
	});

	if (results.settings.restrictChat && !results.isAdmin && !results.isModerator && !results.isFollowing) {
		throw new Error('[[error:chat-restricted]]');
	}

	await plugins.hooks.fire('static:messaging.canMessageUser', {
		uid: uid,
		toUid: toUid,
	});
};

Messaging.canMessageRoom = async (uid, roomId) => {
	if (meta.config.disableChat || uid <= 0) {
		throw new Error('[[error:chat-disabled]]');
	}

	const inRoom = await Messaging.isUserInRoom(uid, roomId);
	if (!inRoom) {
		throw new Error('[[error:not-in-room]]');
	}

	const canChat = await privileges.global.can('chat', uid);
	if (!canChat) {
		throw new Error('[[error:no-privileges]]');
	}

	await plugins.hooks.fire('static:messaging.canMessageRoom', {
		uid: uid,
		roomId: roomId,
	});
};

Messaging.hasPrivateChat = async (uid, withUid) => {
	if (parseInt(uid, 10) === parseInt(withUid, 10)) {
		return 0;
	}

	const results = await utils.promiseParallel({
		myRooms: db.getSortedSetRevRange(`uid:${uid}:chat:rooms`, 0, -1),
		theirRooms: db.getSortedSetRevRange(`uid:${withUid}:chat:rooms`, 0, -1),
	});
	const roomIds = results.myRooms.filter(roomId => roomId && results.theirRooms.includes(roomId));

	if (!roomIds.length) {
		return 0;
	}

	let index = 0;
	let roomId = 0;
	while (index < roomIds.length && !roomId) {
		/* eslint-disable no-await-in-loop */
		const count = await Messaging.getUserCountInRoom(roomIds[index]);
		if (count === 2) {
			roomId = roomIds[index];
		} else {
			index += 1;
		}
	}

	return roomId;
};

'use strict';

const validator = require('validator');

const db = require('../database');
const user = require('../user');
const plugins = require('../plugins');
const privileges = require('../privileges');
const meta = require('../meta');

module.exports = function (Messaging) {
	Messaging.getRoomData = async (roomId) => {
		const data = await db.getObject(`chat:room:${roomId}`);
		if (!data) {
			throw new Error('[[error:no-chat-room]]');
		}

		modifyRoomData([data]);
		return data;
	};

	Messaging.getRoomsData = async (roomIds) => {
		const roomData = await db.getObjects(roomIds.map(roomId => `chat:room:${roomId}`));
		modifyRoomData(roomData);
		return roomData;
	};

	function modifyRoomData(rooms) {
		rooms.forEach((data) => {
			if (data) {
				data.roomName = data.roomName || '';
				data.roomName = validator.escape(String(data.roomName));
				if (data.hasOwnProperty('groupChat')) {
					data.groupChat = parseInt(data.groupChat, 10) === 1;
				}
			}
		});
	}

	Messaging.newRoom = async (uid, toUids) => {
		const now = Date.now();
		const roomId = await db.incrObjectField('global', 'nextChatRoomId');
		const room = {
			owner: uid,
			roomId: roomId,
		};

		await Promise.all([
			db.setObject(`chat:room:${roomId}`, room),
			db.sortedSetAdd(`chat:room:${roomId}:uids`, now, uid),
		]);
		await Promise.all([
			Messaging.addUsersToRoom(uid, toUids, roomId),
			Messaging.addRoomToUsers(roomId, [uid].concat(toUids), now),
		]);
		// chat owner should also get the user-join system message
		await Messaging.addSystemMessage('user-join', uid, roomId);

		return roomId;
	};

	Messaging.isUserInRoom = async (uid, roomId) => {
		const inRoom = await db.isSortedSetMember(`chat:room:${roomId}:uids`, uid);
		const data = await plugins.hooks.fire('filter:messaging.isUserInRoom', { uid: uid, roomId: roomId, inRoom: inRoom });
		return data.inRoom;
	};

	Messaging.roomExists = async roomId => db.exists(`chat:room:${roomId}:uids`);

	Messaging.getUserCountInRoom = async roomId => db.sortedSetCard(`chat:room:${roomId}:uids`);

	Messaging.isRoomOwner = async (uid, roomId) => {
		const owner = await db.getObjectField(`chat:room:${roomId}`, 'owner');
		return parseInt(uid, 10) === parseInt(owner, 10);
	};

	Messaging.addUsersToRoom = async function (uid, uids, roomId) {
		const now = Date.now();
		const timestamps = uids.map(() => now);
		const inRoom = await Messaging.isUserInRoom(uid, roomId);
		if (!inRoom) {
			throw new Error('[[error:cant-add-users-to-chat-room]]');
		}

		await db.sortedSetAdd(`chat:room:${roomId}:uids`, timestamps, uids);
		await updateGroupChatField([roomId]);
		await Promise.all(uids.map(uid => Messaging.addSystemMessage('user-join', uid, roomId)));
	};

	Messaging.removeUsersFromRoom = async (uid, uids, roomId) => {
		const [isOwner, userCount] = await Promise.all([
			Messaging.isRoomOwner(uid, roomId),
			Messaging.getUserCountInRoom(roomId),
		]);

		if (!isOwner) {
			throw new Error('[[error:cant-remove-users-from-chat-room]]');
		}
		if (userCount === 2) {
			throw new Error('[[error:cant-remove-last-user]]');
		}

		await Messaging.leaveRoom(uids, roomId);
	};

	Messaging.isGroupChat = async function (roomId) {
		return (await Messaging.getRoomData(roomId)).groupChat;
	};

	async function updateGroupChatField(roomIds) {
		const userCounts = await db.sortedSetsCard(roomIds.map(roomId => `chat:room:${roomId}:uids`));
		const groupChats = roomIds.filter((roomId, index) => userCounts[index] > 2);
		const privateChats = roomIds.filter((roomId, index) => userCounts[index] <= 2);
		await Promise.all([
			db.setObjectField(groupChats.map(id => `chat:room:${id}`, 'groupChat', 1)),
			db.setObjectField(privateChats.map(id => `chat:room:${id}`, 'groupChat', 0)),
		]);
	}

	Messaging.leaveRoom = async (uids, roomId) => {
		const isInRoom = await Promise.all(uids.map(uid => Messaging.isUserInRoom(uid, roomId)));
		uids = uids.filter((uid, index) => isInRoom[index]);

		const keys = uids
			.map(uid => `uid:${uid}:chat:rooms`)
			.concat(uids.map(uid => `uid:${uid}:chat:rooms:unread`));

		await Promise.all([
			db.sortedSetRemove(`chat:room:${roomId}:uids`, uids),
			db.sortedSetsRemove(keys, roomId),
		]);

		await Promise.all(uids.map(uid => Messaging.addSystemMessage('user-leave', uid, roomId)));
		await updateOwner(roomId);
		await updateGroupChatField([roomId]);
	};

	Messaging.leaveRooms = async (uid, roomIds) => {
		const isInRoom = await Promise.all(roomIds.map(roomId => Messaging.isUserInRoom(uid, roomId)));
		roomIds = roomIds.filter((roomId, index) => isInRoom[index]);

		const roomKeys = roomIds.map(roomId => `chat:room:${roomId}:uids`);
		await Promise.all([
			db.sortedSetsRemove(roomKeys, uid),
			db.sortedSetRemove([
				`uid:${uid}:chat:rooms`,
				`uid:${uid}:chat:rooms:unread`,
			], roomIds),
		]);

		await Promise.all(
			roomIds.map(roomId => updateOwner(roomId))
				.concat(roomIds.map(roomId => Messaging.addSystemMessage('user-leave', uid, roomId)))
		);
		await updateGroupChatField(roomIds);
	};

	async function updateOwner(roomId) {
		const uids = await db.getSortedSetRange(`chat:room:${roomId}:uids`, 0, 0);
		const newOwner = uids[0] || 0;
		await db.setObjectField(`chat:room:${roomId}`, 'owner', newOwner);
	}

	Messaging.getUidsInRoom = async (roomId, start, stop) => db.getSortedSetRevRange(`chat:room:${roomId}:uids`, start, stop);

	Messaging.getUsersInRoom = async (roomId, start, stop) => {
		const uids = await Messaging.getUidsInRoom(roomId, start, stop);
		const [users, ownerId] = await Promise.all([
			user.getUsersFields(uids, ['uid', 'username', 'picture', 'status']),
			db.getObjectField(`chat:room:${roomId}`, 'owner'),
		]);

		return users.map((user) => {
			user.isOwner = parseInt(user.uid, 10) === parseInt(ownerId, 10);
			return user;
		});
	};

	Messaging.renameRoom = async function (uid, roomId, newName) {
		if (!newName) {
			throw new Error('[[error:invalid-name]]');
		}
		newName = newName.trim();
		if (newName.length > 75) {
			throw new Error('[[error:chat-room-name-too-long]]');
		}

		const payload = await plugins.hooks.fire('filter:chat.renameRoom', {
			uid: uid,
			roomId: roomId,
			newName: newName,
		});
		const isOwner = await Messaging.isRoomOwner(payload.uid, payload.roomId);
		if (!isOwner) {
			throw new Error('[[error:no-privileges]]');
		}

		await db.setObjectField(`chat:room:${payload.roomId}`, 'roomName', payload.newName);
		await Messaging.addSystemMessage(`room-rename, ${payload.newName.replace(',', '&#44;')}`, payload.uid, payload.roomId);

		plugins.hooks.fire('action:chat.renameRoom', {
			roomId: payload.roomId,
			newName: payload.newName,
		});
	};

	Messaging.canReply = async (roomId, uid) => {
		const inRoom = await db.isSortedSetMember(`chat:room:${roomId}:uids`, uid);
		const data = await plugins.hooks.fire('filter:messaging.canReply', { uid: uid, roomId: roomId, inRoom: inRoom, canReply: inRoom });
		return data.canReply;
	};

	Messaging.loadRoom = async (uid, data) => {
		const canChat = await privileges.global.can('chat', uid);
		if (!canChat) {
			throw new Error('[[error:no-privileges]]');
		}
		const inRoom = await Messaging.isUserInRoom(uid, data.roomId);
		if (!inRoom) {
			return null;
		}

		const [roomData, canReply, users, messages, isAdminOrGlobalMod] = await Promise.all([
			Messaging.getRoomData(data.roomId),
			Messaging.canReply(data.roomId, uid),
			Messaging.getUsersInRoom(data.roomId, 0, -1),
			Messaging.getMessages({
				callerUid: uid,
				uid: data.uid || uid,
				roomId: data.roomId,
				isNew: false,
			}),
			user.isAdminOrGlobalMod(uid),
		]);

		const room = roomData;
		room.messages = messages;
		room.isOwner = parseInt(room.owner, 10) === parseInt(uid, 10);
		room.users = users.filter(user => user && parseInt(user.uid, 10) && parseInt(user.uid, 10) !== parseInt(uid, 10));
		room.canReply = canReply;
		room.groupChat = room.hasOwnProperty('groupChat') ? room.groupChat : users.length > 2;
		room.usernames = Messaging.generateUsernames(users, uid);
		room.maximumUsersInChatRoom = meta.config.maximumUsersInChatRoom;
		room.maximumChatMessageLength = meta.config.maximumChatMessageLength;
		room.showUserInput = !room.maximumUsersInChatRoom || room.maximumUsersInChatRoom > 2;
'use strict';

const user = require('../user');
const notifications = require('../notifications');
const sockets = require('../socket.io');
const plugins = require('../plugins');
const meta = require('../meta');

module.exports = function (Messaging) {
	Messaging.notifyQueue = {};	// Only used to notify a user of a new chat message, see Messaging.notifyUser

	Messaging.notifyUsersInRoom = async (fromUid, roomId, messageObj) => {
		let uids = await Messaging.getUidsInRoom(roomId, 0, -1);
		uids = await user.blocks.filterUids(fromUid, uids);

		let data = {
			roomId: roomId,
			fromUid: fromUid,
			message: messageObj,
			uids: uids,
		};
		data = await plugins.hooks.fire('filter:messaging.notify', data);
		if (!data || !data.uids || !data.uids.length) {
			return;
		}

		uids = data.uids;
		uids.forEach((uid) => {
			data.self = parseInt(uid, 10) === parseInt(fromUid, 10) ? 1 : 0;
			Messaging.pushUnreadCount(uid);
			sockets.in(`uid_${uid}`).emit('event:chats.receive', data);
		});
		if (messageObj.system) {
			return;
		}
		// Delayed notifications
		let queueObj = Messaging.notifyQueue[`${fromUid}:${roomId}`];
		if (queueObj) {
			queueObj.message.content += `\n${messageObj.content}`;
			clearTimeout(queueObj.timeout);
		} else {
			queueObj = {
				message: messageObj,
			};
			Messaging.notifyQueue[`${fromUid}:${roomId}`] = queueObj;
		}

		queueObj.timeout = setTimeout(() => {
			sendNotifications(fromUid, uids, roomId, queueObj.message);
		}, (parseFloat(meta.config.notificationSendDelay) || 60) * 1000);
	};

	async function sendNotifications(fromuid, uids, roomId, messageObj) {
		const isOnline = await user.isOnline(uids);
		uids = uids.filter((uid, index) => !isOnline[index] && parseInt(fromuid, 10) !== parseInt(uid, 10));
		if (!uids.length) {
			return;
		}

		const isGroupChat = await Messaging.isGroupChat(roomId);
		const notification = await notifications.create({
			type: isGroupChat ? 'new-group-chat' : 'new-chat',
			subject: `[[email:notif.chat.subject, ${messageObj.fromUser.username}]]`,
			bodyShort: `[[notifications:new_message_from, ${messageObj.fromUser.username}]]`,
			bodyLong: messageObj.content,
			nid: `chat_${fromuid}_${roomId}`,
			from: fromuid,
			path: `/chats/${messageObj.roomId}`,
		});

'use strict';

const util = require('util');

module.exports = function (theModule, ignoreKeys) {
	ignoreKeys = ignoreKeys || [];
	function isCallbackedFunction(func) {
		if (typeof func !== 'function') {
			return false;
		}
		const str = func.toString().split('\n')[0];
		return str.includes('callback)');
	}

	function isAsyncFunction(fn) {
		return fn && fn.constructor && fn.constructor.name === 'AsyncFunction';
	}

	function promisifyRecursive(module) {
		if (!module) {
			return;
		}

		const keys = Object.keys(module);
		keys.forEach((key) => {
			if (ignoreKeys.includes(key)) {
				return;
			}
			if (isAsyncFunction(module[key])) {
				module[key] = wrapCallback(module[key], util.callbackify(module[key]));
			} else if (isCallbackedFunction(module[key])) {
				module[key] = wrapPromise(module[key], util.promisify(module[key]));
			} else if (typeof module[key] === 'object') {
				promisifyRecursive(module[key]);
			}
		});
	}

	function wrapCallback(origFn, callbackFn) {
		return async function wrapperCallback(...args) {
			if (args.length && typeof args[args.length - 1] === 'function') {
				const cb = args.pop();
				args.push((err, res) => (res !== undefined ? cb(err, res) : cb(err)));
				return callbackFn(...args);
			}
			return origFn(...args);
		};
	}

	function wrapPromise(origFn, promiseFn) {
		return function wrapperPromise(...args) {
			if (args.length && typeof args[args.length - 1] === 'function') {
				return origFn(...args);
			}

			return promiseFn(...args);
		};
	}

	promisifyRecursive(theModule);
'use strict';

const meta = require('./meta');
const pubsub = require('./pubsub');

function expandObjBy(obj1, obj2) {
	let changed = false;
	for (const [key, val2] of Object.entries(obj2)) {
		const val1 = obj1[key];
		const xorIsArray = Array.isArray(val1) !== Array.isArray(val2);
		if (xorIsArray || !obj1.hasOwnProperty(key) || typeof val2 !== typeof val1) {
			obj1[key] = val2;
			changed = true;
		} else if (typeof val2 === 'object' && !Array.isArray(val2)) {
			if (expandObjBy(val1, val2)) {
				changed = true;
			}
		}
	}
	return changed;
}

function trim(obj1, obj2) {
	for (const [key, val1] of Object.entries(obj1)) {
		if (!obj2.hasOwnProperty(key)) {
			delete obj1[key];
		} else if (typeof val1 === 'object' && !Array.isArray(val1)) {
			trim(val1, obj2[key]);
		}
	}
}

function mergeSettings(cfg, defCfg) {
	if (typeof defCfg !== 'object') {
		return;
	}
	if (typeof cfg._ !== 'object') {
		cfg._ = defCfg;
	} else {
		expandObjBy(cfg._, defCfg);
		trim(cfg._, defCfg);
	}
}

/**
 A class to manage Objects saved in {@link meta.settings} within property "_".
 Constructor, synchronizes the settings and repairs them if version differs.
 @param hash The hash to use for {@link meta.settings}.
 @param version The version of the settings, used to determine whether the saved settings may be corrupt.
 @param defCfg The default settings.
 @param callback Gets called once the Settings-object is ready.
 @param forceUpdate Whether to trigger structure-update even if the version doesn't differ from saved one.
 Should be true while plugin-development to ensure structure-changes within settings persist.
 @param reset Whether to reset the settings.
 */
function Settings(hash, version, defCfg, callback, forceUpdate, reset) {
	this.hash = hash;
	this.version = version || this.version;
	this.defCfg = defCfg;
	const self = this;

	if (reset) {
		this.reset(callback);
	} else {
		this.sync(function () {
			this.checkStructure(callback, forceUpdate);
		});
	}
	pubsub.on(`action:settings.set.${hash}`, (data) => {
		try {
			self.cfg._ = JSON.parse(data._);
		} catch (err) {}
	});
}

Settings.prototype.hash = '';
Settings.prototype.defCfg = {};
Settings.prototype.cfg = {};
Settings.prototype.version = '0.0.0';

/**
 Synchronizes the local object with the saved object (reverts changes).
 @param callback Gets called when done.
 */
Settings.prototype.sync = function (callback) {
	const _this = this;
	meta.settings.get(this.hash, (err, settings) => {
		try {
			if (settings._) {
				settings._ = JSON.parse(settings._);
			}
		} catch (_error) {}
		_this.cfg = settings;
		if (typeof _this.cfg._ !== 'object') {
			_this.cfg._ = _this.defCfg;
			_this.persist(callback);
		} else if (expandObjBy(_this.cfg._, _this.defCfg)) {
			_this.persist(callback);
		} else if (typeof callback === 'function') {
			callback.apply(_this, err);
		}
	});
};

/**
 Persists the local object.
 @param callback Gets called when done.
 */
Settings.prototype.persist = function (callback) {
	let conf = this.cfg._;
	const _this = this;
	if (typeof conf === 'object') {
		conf = JSON.stringify(conf);
	}
	meta.settings.set(this.hash, this.createWrapper(this.cfg.v, conf), (...args) => {
		if (typeof callback === 'function') {
			callback.apply(_this, args || []);
		}
	});
	return this;
};

/**
 Returns the setting of given key or default value if not set.
 @param key The key of the setting to return.
 @param def The default value, if not set global default value gets used.
 @returns Object The setting to be used.
 */
Settings.prototype.get = function (key, def) {
	let obj = this.cfg._;
	const parts = (key || '').split('.');
	let part;
	for (let i = 0; i < parts.length; i += 1) {
		part = parts[i];
		if (part && obj != null) {
			obj = obj[part];
		}
	}
	if (obj === undefined) {
		if (def === undefined) {
			def = this.defCfg;
			for (let j = 0; j < parts.length; j += 1) {
				part = parts[j];
				if (part && def != null) {
					def = def[part];
				}
			}
		}
		return def;
	}
	return obj;
};

/**
 Returns the settings-wrapper object.
 @returns Object The settings-wrapper.
 */
Settings.prototype.getWrapper = function () {
	return this.cfg;
};

/**
 Creates a new wrapper for the given settings with the given version.
 @returns Object The new settings-wrapper.
 */
Settings.prototype.createWrapper = function (version, settings) {
	return {
		v: version,
		_: settings,
	};
};

/**
 Creates a new wrapper for the default settings.
 @returns Object The new settings-wrapper.
 */
Settings.prototype.createDefaultWrapper = function () {
	return this.createWrapper(this.version, this.defCfg);
};

/**
 Sets the setting of given key to given value.
 @param key The key of the setting to set.
 @param val The value to set.
 */
Settings.prototype.set = function (key, val) {
	let part;
	let obj;
	let parts;
	this.cfg.v = this.version;
	if (val == null || !key) {
		this.cfg._ = val || key;
	} else {
		obj = this.cfg._;
		parts = key.split('.');
		for (let i = 0, _len = parts.length - 1; i < _len; i += 1) {
			part = parts[i];
			if (part) {
				if (!obj.hasOwnProperty(part)) {
					obj[part] = {};
				}
				obj = obj[part];
			}
		}
		obj[parts[parts.length - 1]] = val;
	}
	return this;
};

/**
 Resets the saved settings to default settings.
 @param callback Gets called when done.
 */
Settings.prototype.reset = function (callback) {
	this.set(this.defCfg).persist(callback);
	return this;
};

/**
 If the version differs the settings get updated and persisted.
 @param callback Gets called when done.
 @param force Whether to update and persist the settings even if the versions ara equal.
 */
Settings.prototype.checkStructure = function (callback, force) {
	if (!force && this.cfg.v === this.version) {
		if (typeof callback === 'function') {
			callback();
		}
	} else {
		mergeSettings(this.cfg, this.defCfg);
		this.cfg.v = this.version;
		this.persist(callback);
	}
	return this;
};
'use strict';

const fs = require('fs');
const path = require('path');
const utils = require('./utils');
const { paths } = require('./constants');

const Languages = module.exports;
const languagesPath = path.join(__dirname, '../build/public/language');

const files = fs.readdirSync(path.join(paths.nodeModules, '/timeago/locales'));
Languages.timeagoCodes = files.filter(f => f.startsWith('jquery.timeago')).map(f => f.split('.')[2]);

Languages.get = async function (language, namespace) {
	const data = await fs.promises.readFile(path.join(languagesPath, language, `${namespace}.json`), 'utf8');
	return JSON.parse(data) || {};
};

let codeCache = null;
Languages.listCodes = async function () {
	if (codeCache && codeCache.length) {
		return codeCache;
	}
	try {
		const file = await fs.promises.readFile(path.join(languagesPath, 'metadata.json'), 'utf8');
		const parsed = JSON.parse(file);

		codeCache = parsed.languages;
		return parsed.languages;
	} catch (err) {
		if (err.code === 'ENOENT') {
			return [];
		}
		throw err;
	}
};

let listCache = null;
Languages.list = async function () {
	if (listCache && listCache.length) {
		return listCache;
	}

	const codes = await Languages.listCodes();

	let languages = await Promise.all(codes.map(async (folder) => {
		try {
			const configPath = path.join(languagesPath, folder, 'language.json');
			const file = await fs.promises.readFile(configPath, 'utf8');
			const lang = JSON.parse(file);
			return lang;
		} catch (err) {
			if (err.code === 'ENOENT') {
				return;
			}
			throw err;
		}
	}));

	// filter out invalid ones
	languages = languages.filter(lang => lang && lang.code && lang.name && lang.dir);

	listCache = languages;
	return languages;
};

Languages.userTimeagoCode = async function (userLang) {
	const languageCodes = await Languages.listCodes();
	const timeagoCode = utils.userLangToTimeagoCode(userLang);
	if (languageCodes.includes(userLang) && Languages.timeagoCodes.includes(timeagoCode)) {
		return timeagoCode;
	}
	return '';
};

'use strict';

const fs = require('fs');
const nconf = require('nconf');
const path = require('path');
const winston = require('winston');
const mkdirp = require('mkdirp');
const mime = require('mime');
const graceful = require('graceful-fs');

const slugify = require('./slugify');

graceful.gracefulify(fs);

const file = module.exports;

file.saveFileToLocal = async function (filename, folder, tempPath) {
	/*
	 * remarkable doesn't allow spaces in hyperlinks, once that's fixed, remove this.
	 */
	filename = filename.split('.').map(name => slugify(name)).join('.');

	const uploadPath = path.join(nconf.get('upload_path'), folder, filename);
	if (!uploadPath.startsWith(nconf.get('upload_path'))) {
		throw new Error('[[error:invalid-path]]');
	}

	winston.verbose(`Saving file ${filename} to : ${uploadPath}`);
	await mkdirp(path.dirname(uploadPath));
	await fs.promises.copyFile(tempPath, uploadPath);
	return {
		url: `/assets/uploads/${folder ? `${folder}/` : ''}${filename}`,
		path: uploadPath,
	};
};

file.base64ToLocal = async function (imageData, uploadPath) {
	const buffer = Buffer.from(imageData.slice(imageData.indexOf('base64') + 7), 'base64');
	uploadPath = path.join(nconf.get('upload_path'), uploadPath);

	await fs.promises.writeFile(uploadPath, buffer, {
		encoding: 'base64',
	});
	return uploadPath;
};

// https://stackoverflow.com/a/31205878/583363
file.appendToFileName = function (filename, string) {
	const dotIndex = filename.lastIndexOf('.');
	if (dotIndex === -1) {
		return filename + string;
	}
	return filename.substring(0, dotIndex) + string + filename.substring(dotIndex);
};

file.allowedExtensions = function () {
	const meta = require('./meta');
	let allowedExtensions = (meta.config.allowedFileExtensions || '').trim();
	if (!allowedExtensions) {
		return [];
	}
	allowedExtensions = allowedExtensions.split(',');
	allowedExtensions = allowedExtensions.filter(Boolean).map((extension) => {
		extension = extension.trim();
		if (!extension.startsWith('.')) {
			extension = `.${extension}`;
		}
		return extension.toLowerCase();
	});

	if (allowedExtensions.includes('.jpg') && !allowedExtensions.includes('.jpeg')) {
		allowedExtensions.push('.jpeg');
	}

	return allowedExtensions;
};

file.exists = async function (path) {
	try {
		await fs.promises.stat(path);
	} catch (err) {
		if (err.code === 'ENOENT') {
			return false;
		}
		throw err;
	}
	return true;
};

file.existsSync = function (path) {
	try {
		fs.statSync(path);
	} catch (err) {
		if (err.code === 'ENOENT') {
			return false;
		}
		throw err;
	}

	return true;
};

file.delete = async function (path) {
	if (!path) {
		return;
	}
	try {
		await fs.promises.unlink(path);
	} catch (err) {
		winston.warn(err);
	}
};

file.link = async function link(filePath, destPath, relative) {
	if (relative && process.platform !== 'win32') {
		filePath = path.relative(path.dirname(destPath), filePath);
	}

	if (process.platform === 'win32') {
		await fs.promises.link(filePath, destPath);
	} else {
		await fs.promises.symlink(filePath, destPath, 'file');
	}
};

file.linkDirs = async function linkDirs(sourceDir, destDir, relative) {
	if (relative && process.platform !== 'win32') {
		sourceDir = path.relative(path.dirname(destDir), sourceDir);
	}

	const type = (process.platform === 'win32') ? 'junction' : 'dir';
	await fs.promises.symlink(sourceDir, destDir, type);
};

file.typeToExtension = function (type) {
	let extension = '';
	if (type) {
		extension = `.${mime.getExtension(type)}`;
	}
	return extension;
};

// Adapted from http://stackoverflow.com/questions/5827612/node-js-fs-readdir-recursive-directory-search
file.walk = async function (dir) {
	const subdirs = await fs.promises.readdir(dir);
	const files = await Promise.all(subdirs.map(async (subdir) => {
		const res = path.resolve(dir, subdir);
		return (await fs.promises.stat(res)).isDirectory() ? file.walk(res) : res;
	}));
	return files.reduce((a, f) => a.concat(f), []);
'use strict';


const nconf = require('nconf');
const meta = require('./meta');

const relative_path = nconf.get('relative_path');

const coverPhoto = module.exports;

coverPhoto.getDefaultGroupCover = function (groupName) {
	return getCover('groups', groupName);
};

coverPhoto.getDefaultProfileCover = function (uid) {
	return getCover('profile', parseInt(uid, 10));
};

function getCover(type, id) {
	const defaultCover = `${relative_path}/assets/images/cover-default.png`;
	if (meta.config[`${type}:defaultCovers`]) {
		const covers = String(meta.config[`${type}:defaultCovers`]).trim().split(/[\s,]+/g);
		let coverPhoto = defaultCover;
		if (!covers.length) {
			return coverPhoto;
		}

		if (typeof id === 'string') {
			id = (id.charCodeAt(0) + id.charCodeAt(1)) % covers.length;
		} else {
			id %= covers.length;
		}
		if (covers[id]) {
			coverPhoto = covers[id].startsWith('http') ? covers[id] : (relative_path + covers[id]);
		}
'use strict';


const async = require('async');
const crypto = require('crypto');
const meta = require('../../meta');

module.exports = {
	name: 'Clearing stale digest templates that were accidentally saved as custom',
	timestamp: Date.UTC(2017, 8, 6),
	method: function (callback) {
		const matches = [
			'112e541b40023d6530dd44df4b0d9c5d',		// digest @ 75917e25b3b5ad7bed8ed0c36433fb35c9ab33eb
			'110b8805f70395b0282fd10555059e9f',		// digest @ 9b02bb8f51f0e47c6e335578f776ffc17bc03537
			'9538e7249edb369b2a25b03f2bd3282b',		// digest @ 3314ab4b83138c7ae579ac1f1f463098b8c2d414
		];

		async.waterfall([
			async.apply(meta.configs.getFields, ['email:custom:digest']),
			function (fieldset, next) {
				const hash = fieldset['email:custom:digest'] ? crypto.createHash('md5').update(fieldset['email:custom:digest']).digest('hex') : null;

				if (matches.includes(hash)) {
					meta.configs.remove('email:custom:digest', next);
				} else {
					setImmediate(next);
				}
			},
		], callback);
	},
'use strict';

const async = require('async');

const db = require('../../database');

module.exports = {
	name: 'Changing ip blacklist storage to object',
	timestamp: Date.UTC(2017, 8, 7),
	method: function (callback) {
		let rules;
		async.waterfall([
			function (next) {
				db.get('ip-blacklist-rules', next);
			},
			function (_rules, next) {
				rules = _rules;
				db.delete('ip-blacklist-rules', rules ? next : callback);
			},
			function (next) {
'use strict';


const async = require('async');
const path = require('path');
const nconf = require('nconf');
const fs = require('fs');
const meta = require('../../meta');
const image = require('../../image');

module.exports = {
	name: 'Generate email logo for use in email header',
	timestamp: Date.UTC(2017, 6, 17),
	method: function (callback) {
		let skip = false;

		async.series([
			function (next) {
				// Resize existing logo (if present) to email header size
				const uploadPath = path.join(nconf.get('upload_path'), 'system', 'site-logo-x50.png');
				const sourcePath = meta.config['brand:logo'] ? path.join(nconf.get('upload_path'), 'system', path.basename(meta.config['brand:logo'])) : null;

				if (!sourcePath) {
					skip = true;
					return setImmediate(next);
				}

				fs.access(sourcePath, (err) => {
					if (err || path.extname(sourcePath) === '.svg') {
						skip = true;
						return setImmediate(next);
					}

					image.resizeImage({
						path: sourcePath,
						target: uploadPath,
						height: 50,
					}, next);
				});
			},
			function (next) {
				if (skip) {
					return setImmediate(next);
				}

				meta.configs.setMultiple({
					'brand:logo': path.join('/assets/uploads/system', path.basename(meta.config['brand:logo'])),
					'brand:emailLogo': '/assets/uploads/system/site-logo-x50.png',
				}, next);
			},
'use strict';

const async = require('async');
const db = require('../../database');

module.exports = {
	name: 'Fix incorrect robots.txt schema',
	timestamp: Date.UTC(2017, 6, 10),
	method: function (callback) {
		async.waterfall([
			function (next) {
				db.getObject('config', next);
			},
			function (config, next) {
				if (!config) {
					return callback();
				}
				// fix mongo nested data
				if (config.robots && config.robots.txt) {
					db.setObjectField('config', 'robots:txt', config.robots.txt, next);
				} else if (typeof config['robots.txt'] === 'string' && config['robots.txt']) {
					db.setObjectField('config', 'robots:txt', config['robots.txt'], next);
				} else {
					next();
				}
			},
			function (next) {
				db.deleteObjectField('config', 'robots', next);
			},
			function (next) {
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Fix category colors that are 3 digit hex colors',
	timestamp: Date.UTC(2020, 9, 11),
	method: async () => {
		const batch = require('../../batch');
		await batch.processSortedSet('categories:cid', async (cids) => {
			let categoryData = await db.getObjects(cids.map(c => `category:${c}`));
			categoryData = categoryData.filter(c => c && (c.color === '#fff' || c.color === '#333' || String(c.color).length !== 7));
			if (categoryData.length) {
				await Promise.all(categoryData.map(async (data) => {
					const color = `#${new Array(6).fill((data.color && data.color[1]) || 'f').join('')}`;
					await db.setObjectField(`category:${data.cid}`, 'color', color);
				}));
			}
		}, { batch: 500 });
	},
'use strict';

const db = require('../../database');

const batch = require('../../batch');
const user = require('../../user');

module.exports = {
	name: 'Create fullname search set',
	timestamp: Date.UTC(2020, 8, 11),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('users:joindate', async (uids) => {
			progress.incr(uids.length);
			const userData = await user.getUsersFields(uids, ['uid', 'fullname']);
			const bulkAdd = userData
				.filter(u => u.uid && u.fullname)
				.map(u => ['fullname:sorted', 0, `${String(u.fullname).substr(0, 255).toLowerCase()}:${u.uid}`]);
			await db.sortedSetAddBulk(bulkAdd);
		}, {
			batch: 500,
			progress: this.progress,
		});
	},
'use strict';

const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Remove flag reporters sorted set',
	timestamp: Date.UTC(2020, 6, 31),
	method: async function () {
		const { progress } = this;
		progress.total = await db.sortedSetCard('flags:datetime');

		await batch.processSortedSet('flags:datetime', async (flagIds) => {
			await Promise.all(flagIds.map(async (flagId) => {
				const [reports, reporterUids] = await Promise.all([
					db.getSortedSetRevRangeWithScores(`flag:${flagId}:reports`, 0, -1),
					db.getSortedSetRevRange(`flag:${flagId}:reporters`, 0, -1),
				]);

				const values = reports.reduce((memo, cur, idx) => {
					memo.push([`flag:${flagId}:reports`, cur.score, [(reporterUids[idx] || 0), cur.value].join(';')]);
					return memo;
				}, []);

				await db.delete(`flag:${flagId}:reports`);
				await db.sortedSetAddBulk(values);
			}));
		}, {
			batch: 500,
			progress: progress,
'use strict';

const db = require('../../database');

module.exports = {
	name: 'New sorted set for tracking flags by target',
	timestamp: Date.UTC(2020, 6, 15),
	method: async () => {
		const flags = await db.getSortedSetRange('flags:hash', 0, -1);
		await Promise.all(flags.map(async (flag) => {
'use strict';

const db = require('../../database');
const batch = require('../../batch');
const posts = require('../../posts');

module.exports = {
	name: 'Add target uid to flag objects',
	timestamp: Date.UTC(2020, 7, 22),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('flags:datetime', async (flagIds) => {
			progress.incr(flagIds.length);
			const flagData = await db.getObjects(flagIds.map(id => `flag:${id}`));
			for (const flagObj of flagData) {
				/* eslint-disable no-await-in-loop */
				if (flagObj) {
					const { targetId } = flagObj;
					if (targetId) {
						if (flagObj.type === 'post') {
							const targetUid = await posts.getPostField(targetId, 'uid');
							if (targetUid) {
								await db.setObjectField(`flag:${flagObj.flagId}`, 'targetUid', targetUid);
							}
						} else if (flagObj.type === 'user') {
							await db.setObjectField(`flag:${flagObj.flagId}`, 'targetUid', targetId);
						}
					}
				}
			}
		}, {
			progress: progress,
			batch: 500,
		});
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Disable nodebb-plugin-soundpack-default',
	timestamp: Date.UTC(2020, 8, 6),
	method: async function () {
		await db.sortedSetRemove('plugins:active', 'nodebb-plugin-soundpack-default');
	},
'use strict';

const db = require('../../database');
const batch = require('../../batch');
const posts = require('../../posts');
const user = require('../../user');

module.exports = {
	name: 'Consolidate multiple flags reports, going forward',
	timestamp: Date.UTC(2020, 6, 16),
	method: async function () {
		const { progress } = this;

		let flags = await db.getSortedSetRange('flags:datetime', 0, -1);
		flags = flags.map(flagId => `flag:${flagId}`);
		flags = await db.getObjectsFields(flags, ['flagId', 'type', 'targetId', 'uid', 'description', 'datetime']);
		progress.total = flags.length;

		await batch.processArray(flags, async (subset) => {
			progress.incr(subset.length);

			await Promise.all(subset.map(async (flagObj) => {
				const methods = [];
				switch (flagObj.type) {
					case 'post':
						methods.push(posts.setPostField.bind(posts, flagObj.targetId, 'flagId', flagObj.flagId));
						break;

					case 'user':
						methods.push(user.setUserField.bind(user, flagObj.targetId, 'flagId', flagObj.flagId));
						break;
				}

				methods.push(
					db.sortedSetAdd.bind(db, `flag:${flagObj.flagId}:reports`, flagObj.datetime, String(flagObj.description).substr(0, 250)),
					db.sortedSetAdd.bind(db, `flag:${flagObj.flagId}:reporters`, flagObj.datetime, flagObj.uid)
				);

				await Promise.all(methods.map(async method => method()));
			}));
		}, {
			progress: progress,
			batch: 500,
		});
	},
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Remove allow from uri setting',
	timestamp: Date.UTC(2020, 8, 6),
	method: async function () {
		const meta = require('../../meta');
		if (meta.config['allow-from-uri']) {
'use strict';

const db = require('../../database');

const batch = require('../../batch');
const user = require('../../user');
const groups = require('../../groups');
const meta = require('../../meta');
const privileges = require('../../privileges');

const now = Date.now();
module.exports = {
	name: 'Create verified/unverified user groups',
	timestamp: Date.UTC(2020, 9, 13),
	method: async function () {
		const { progress } = this;

		const maxGroupLength = meta.config.maximumGroupNameLength;
		meta.config.maximumGroupNameLength = 30;
		const timestamp = await db.getObjectField('group:administrators', 'timestamp');
		const verifiedExists = await groups.exists('verified-users');
		if (!verifiedExists) {
			await groups.create({
				name: 'verified-users',
				hidden: 1,
				private: 1,
				system: 1,
				disableLeave: 1,
				disableJoinRequests: 1,
				timestamp: timestamp + 1,
			});
		}
		const unverifiedExists = await groups.exists('unverified-users');
		if (!unverifiedExists) {
			await groups.create({
				name: 'unverified-users',
				hidden: 1,
				private: 1,
				system: 1,
				disableLeave: 1,
				disableJoinRequests: 1,
				timestamp: timestamp + 1,
			});
		}
		// restore setting
		meta.config.maximumGroupNameLength = maxGroupLength;
		await batch.processSortedSet('users:joindate', async (uids) => {
			progress.incr(uids.length);
			const userData = await user.getUsersFields(uids, ['uid', 'email:confirmed']);

			const verified = userData.filter(u => parseInt(u['email:confirmed'], 10) === 1);
			const unverified = userData.filter(u => parseInt(u['email:confirmed'], 10) !== 1);

			await db.sortedSetAdd(
				'group:verified-users:members',
				verified.map(() => now),
				verified.map(u => u.uid)
			);

			await db.sortedSetAdd(
				'group:unverified-users:members',
				unverified.map(() => now),
				unverified.map(u => u.uid)
			);
		}, {
			batch: 500,
			progress: this.progress,
		});

		await db.delete('users:notvalidated');
		await updatePrivilges();

		const verifiedCount = await db.sortedSetCard('group:verified-users:members');
		const unverifiedCount = await db.sortedSetCard('group:unverified-users:members');
		await db.setObjectField('group:verified-users', 'memberCount', verifiedCount);
		await db.setObjectField('group:unverified-users', 'memberCount', unverifiedCount);
	},
};

async function updatePrivilges() {
	// if email confirmation is required
	//   give chat, posting privs to "verified-users" group
	//   remove chat, posting privs from "registered-users" group
	if (meta.config.requireEmailConfirmation) {
		const cids = await db.getSortedSetRevRange('categories:cid', 0, -1);
		const canChat = await privileges.global.canGroup('chat', 'registered-users');
		if (canChat) {
			await privileges.global.give(['groups:chat'], 'verified-users');
			await privileges.global.rescind(['groups:chat'], 'registered-users');
		}
		for (const cid of cids) {
			/* eslint-disable no-await-in-loop */
			const data = await privileges.categories.list(cid);

			const registeredUsersPrivs = data.groups.find(d => d.name === 'registered-users').privileges;

			if (registeredUsersPrivs['groups:topics:create']) {
				await privileges.categories.give(['groups:topics:create'], cid, 'verified-users');
				await privileges.categories.rescind(['groups:topics:create'], cid, 'registered-users');
			}

			if (registeredUsersPrivs['groups:topics:reply']) {
				await privileges.categories.give(['groups:topics:reply'], cid, 'verified-users');
				await privileges.categories.rescind(['groups:topics:reply'], cid, 'registered-users');
			}
'use strict';

const db = require('../../database');

const batch = require('../../batch');

module.exports = {
	name: 'Store poster count in topic hash',
	timestamp: Date.UTC(2020, 9, 24),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('topics:tid', async (tids) => {
			progress.incr(tids.length);
			const keys = tids.map(tid => `tid:${tid}:posters`);
			await db.sortedSetsRemoveRangeByScore(keys, '-inf', 0);
			const counts = await db.sortedSetsCard(keys);
			const setKeys = [];
			const data = [];
			for (let i = 0; i < tids.length; i++) {
				if (counts[i] > 0) {
					setKeys.push(`topic:${tids[i]}`);
					data.push({ postercount: counts[i] });
				}
			}
			await db.setObjectBulk(setKeys, data);
		}, {
			progress: progress,
			batchSize: 500,
		});
'use strict';

const async = require('async');
const batch = require('../../batch');
const db = require('../../database');

module.exports = {
	name: 'Convert old notification digest settings',
	timestamp: Date.UTC(2017, 10, 15),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (uids, next) => {
			async.eachLimit(uids, 500, (uid, next) => {
				progress.incr();
				async.waterfall([
					function (next) {
						db.getObjectFields(`user:${uid}:settings`, ['sendChatNotifications', 'sendPostNotifications'], next);
					},
					function (userSettings, _next) {
						if (!userSettings) {
							return next();
						}
						const tasks = [];
						if (parseInt(userSettings.sendChatNotifications, 10) === 1) {
							tasks.push(async.apply(db.setObjectField, `user:${uid}:settings`, 'notificationType_new-chat', 'notificationemail'));
						}
						if (parseInt(userSettings.sendPostNotifications, 10) === 1) {
							tasks.push(async.apply(db.setObjectField, `user:${uid}:settings`, 'notificationType_new-reply', 'notificationemail'));
						}
						if (!tasks.length) {
							return next();
						}

						async.series(tasks, (err) => {
							_next(err);
						});
					},
					function (next) {
						db.deleteObjectFields(`user:${uid}:settings`, ['sendChatNotifications', 'sendPostNotifications'], next);
					},
				], next);
			}, next);
		}, {
			progress: progress,
'use strict';


const async = require('async');
const groups = require('../../groups');
const privileges = require('../../privileges');
const db = require('../../database');

module.exports = {
	name: 'Give category access privileges to spiders system group',
	timestamp: Date.UTC(2018, 0, 31),
	method: function (callback) {
		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}
			async.eachSeries(cids, (cid, next) => {
				getGroupPrivileges(cid, (err, groupPrivileges) => {
					if (err) {
						return next(err);
					}

					const privs = [];
					if (groupPrivileges['groups:find']) {
						privs.push('groups:find');
					}
					if (groupPrivileges['groups:read']) {
						privs.push('groups:read');
					}
					if (groupPrivileges['groups:topics:read']) {
						privs.push('groups:topics:read');
					}

					privileges.categories.give(privs, cid, 'spiders', next);
				});
			}, callback);
		});
	},
};

function getGroupPrivileges(cid, callback) {
	const tasks = {};

	['groups:find', 'groups:read', 'groups:topics:read'].forEach((privilege) => {
		tasks[privilege] = async.apply(groups.isMember, 'guests', `cid:${cid}:privileges:${privilege}`);
'use strict';

const privileges = require('../../privileges');

module.exports = {
	name: 'Give registered users signature privilege',
	timestamp: Date.UTC(2018, 1, 28),
	method: function (callback) {
		privileges.global.give(['groups:signature'], 'registered-users', callback);
	},
'use strict';

const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Fix user sorted sets',
	timestamp: Date.UTC(2020, 4, 2),
	method: async function () {
		const { progress } = this;
		const nextUid = await db.getObjectField('global', 'nextUid');
		const allUids = [];
		for (let i = 1; i <= nextUid; i++) {
			allUids.push(i);
		}

		progress.total = nextUid;
		let totalUserCount = 0;

		await db.delete('user:null');
		await db.sortedSetsRemove([
			'users:joindate',
			'users:reputation',
			'users:postcount',
			'users:flags',
		], 'null');

		await batch.processArray(allUids, async (uids) => {
			progress.incr(uids.length);
			const userData = await db.getObjects(uids.map(id => `user:${id}`));

			await Promise.all(userData.map(async (userData, index) => {
				if (!userData || !userData.uid) {
					await db.sortedSetsRemove([
						'users:joindate',
						'users:reputation',
						'users:postcount',
						'users:flags',
					], uids[index]);
					if (userData && !userData.uid) {
						await db.delete(`user:${uids[index]}`);
					}
					return;
				}
				totalUserCount += 1;
				await db.sortedSetAddBulk([
					['users:joindate', userData.joindate || Date.now(), uids[index]],
					['users:reputation', userData.reputation || 0, uids[index]],
					['users:postcount', userData.postcount || 0, uids[index]],
				]);
				if (userData.hasOwnProperty('flags') && parseInt(userData.flags, 10) > 0) {
					await db.sortedSetAdd('users:flags', userData.flags, uids[index]);
				}
			}));
		}, {
			progress: progress,
			batch: 500,
		});

		await db.setObjectField('global', 'userCount', totalUserCount);
'use strict';

const async = require('async');
const winston = require('winston');

const batch = require('../../batch');
const groups = require('../../groups');


module.exports = {
	name: 'rename user mod privileges group',
	timestamp: Date.UTC(2017, 4, 26),
	method: function (callback) {
		const { progress } = this;
		batch.processSortedSet('categories:cid', (cids, next) => {
			async.eachSeries(cids, (cid, next) => {
				const groupName = `cid:${cid}:privileges:mods`;
				const newName = `cid:${cid}:privileges:moderate`;
				groups.exists(groupName, (err, exists) => {
					if (err || !exists) {
						progress.incr();
						return next(err);
					}
					winston.verbose(`renaming ${groupName} to ${newName}`);
					progress.incr();
					groups.renameGroup(groupName, newName, next);
				});
			}, next);
		}, {
			progress: progress,
'use strict';

const async = require('async');

const batch = require('../../batch');

module.exports = {
	name: 'Give tag privilege to registered-users on all categories',
	timestamp: Date.UTC(2017, 5, 16),
	method: function (callback) {
		const { progress } = this;
		const privileges = require('../../privileges');
		batch.processSortedSet('categories:cid', (cids, next) => {
			async.eachSeries(cids, (cid, next) => {
				progress.incr();
				privileges.categories.give(['groups:topics:tag'], cid, 'registered-users', next);
			}, next);
		}, {
			progress: progress,
		}, callback);
'use strict';

const async = require('async');
const batch = require('../../batch');
const db = require('../../database');

module.exports = {
	name: 'Wipe all existing RSS tokens',
	timestamp: Date.UTC(2017, 6, 5),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (uids, next) => {
			async.eachLimit(uids, 500, (uid, next) => {
				progress.incr();
				db.deleteObjectField(`user:${uid}`, 'rss_token', next);
			}, next);
		}, {
			progress: progress,
		}, callback);
'use strict';


const async = require('async');
const groups = require('../../groups');
const privileges = require('../../privileges');
const db = require('../../database');

module.exports = {
	name: 'Give upload privilege to registered-users globally if it is given on a category',
	timestamp: Date.UTC(2018, 0, 3),
	method: function (callback) {
		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}
			async.eachSeries(cids, (cid, next) => {
				getGroupPrivileges(cid, (err, groupPrivileges) => {
					if (err) {
						return next(err);
					}

					const privs = [];
					if (groupPrivileges['groups:upload:post:image']) {
						privs.push('groups:upload:post:image');
					}
					if (groupPrivileges['groups:upload:post:file']) {
						privs.push('groups:upload:post:file');
					}
					privileges.global.give(privs, 'registered-users', next);
				});
			}, callback);
		});
	},
};

function getGroupPrivileges(cid, callback) {
	const tasks = {};

	['groups:upload:post:image', 'groups:upload:post:file'].forEach((privilege) => {
'use strict';

const async = require('async');
const batch = require('../../batch');
const db = require('../../database');

module.exports = {
	name: 'Fix sort by votes for moved topics',
	timestamp: Date.UTC(2018, 0, 8),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('topics:tid', (tids, next) => {
			async.eachLimit(tids, 500, (tid, _next) => {
				progress.incr();
				let topicData;
				async.waterfall([
					function (next) {
						db.getObjectFields(`topic:${tid}`, ['cid', 'oldCid', 'upvotes', 'downvotes', 'pinned'], next);
					},
					function (_topicData, next) {
						topicData = _topicData;
						if (!topicData.cid || !topicData.oldCid) {
							return _next();
						}

						const upvotes = parseInt(topicData.upvotes, 10) || 0;
						const downvotes = parseInt(topicData.downvotes, 10) || 0;
						const votes = upvotes - downvotes;

						async.series([
							function (next) {
								db.sortedSetRemove(`cid:${topicData.oldCid}:tids:votes`, tid, next);
							},
							function (next) {
								if (parseInt(topicData.pinned, 10) !== 1) {
									db.sortedSetAdd(`cid:${topicData.cid}:tids:votes`, votes, tid, next);
								} else {
									next();
								}
							},
						], (err) => {
							next(err);
						});
					},
				], _next);
			}, next);
		}, {
			progress: progress,
			batch: 500,
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Rename privileges:downvote and privileges:flag to min:rep:downvote, min:rep:flag respectively',
	timestamp: Date.UTC(2018, 0, 12),
	method: function (callback) {
		db.getObjectFields('config', ['privileges:downvote', 'privileges:flag'], (err, config) => {
			if (err) {
				return callback(err);
			}

			db.setObject('config', {
				'min:rep:downvote': parseInt(config['privileges:downvote'], 10) || 0,
				'min:rep:flag': parseInt(config['privileges:downvote'], 10) || 0,
			}, (err) => {
				if (err) {
					return callback(err);
				}
'use strict';


const groups = require('../../groups');

module.exports = {
	name: 'Give chat privilege to registered-users',
	timestamp: Date.UTC(2017, 11, 18),
	method: function (callback) {
		groups.join('cid:0:privileges:groups:chat', 'registered-users', callback);
'use strict';

const async = require('async');
const batch = require('../../batch');
const db = require('../../database');

module.exports = {
	name: 'Fix topics in categories per user if they were moved',
	timestamp: Date.UTC(2018, 0, 22),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('topics:tid', (tids, next) => {
			async.eachLimit(tids, 500, (tid, _next) => {
				progress.incr();
				let topicData;
				async.waterfall([
					function (next) {
						db.getObjectFields(`topic:${tid}`, ['cid', 'tid', 'uid', 'oldCid', 'timestamp'], next);
					},
					function (_topicData, next) {
						topicData = _topicData;
						if (!topicData.cid || !topicData.oldCid) {
							return _next();
						}

						db.isSortedSetMember(`cid:${topicData.oldCid}:uid:${topicData.uid}`, topicData.tid, next);
					},
					function (isMember, next) {
						if (isMember) {
							async.series([
								function (next) {
									db.sortedSetRemove(`cid:${topicData.oldCid}:uid:${topicData.uid}:tids`, tid, next);
								},
								function (next) {
									db.sortedSetAdd(`cid:${topicData.cid}:uid:${topicData.uid}:tids`, topicData.timestamp, tid, next);
								},
							], (err) => {
								next(err);
							});
						} else {
							next();
						}
					},
				], _next);
			}, next);
		}, {
			progress: progress,
			batch: 500,
		}, callback);
'use strict';


const async = require('async');

const privileges = require('../../privileges');
const db = require('../../database');

module.exports = {
	name: 'Give vote privilege to registered-users on all categories',
	timestamp: Date.UTC(2018, 0, 9),
	method: function (callback) {
		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}
			async.eachSeries(cids, (cid, next) => {
				privileges.categories.give(['groups:posts:upvote', 'groups:posts:downvote'], cid, 'registered-users', next);
			}, callback);
		});
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Creating users:notvalidated',
	timestamp: Date.UTC(2016, 0, 20),
	method: function (callback) {
		const batch = require('../../batch');
		const now = Date.now();
		batch.processSortedSet('users:joindate', (ids, next) => {
			async.eachSeries(ids, (id, next) => {
				db.getObjectFields(`user:${id}`, ['uid', 'email:confirmed'], (err, userData) => {
					if (err) {
						return next(err);
					}
					if (!userData || !parseInt(userData.uid, 10) || parseInt(userData['email:confirmed'], 10) === 1) {
						return next();
					}
					winston.verbose(`processing uid: ${userData.uid} email:confirmed: ${userData['email:confirmed']}`);
					db.sortedSetAdd('users:notvalidated', now, userData.uid, next);
				});
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Creating user best post sorted sets',
	timestamp: Date.UTC(2016, 0, 14),
	method: function (callback) {
		const batch = require('../../batch');
		const { progress } = this;

		batch.processSortedSet('posts:pid', (ids, next) => {
			async.eachSeries(ids, (id, next) => {
				db.getObjectFields(`post:${id}`, ['pid', 'uid', 'votes'], (err, postData) => {
					if (err) {
						return next(err);
					}
					if (!postData || !parseInt(postData.votes, 10) || !parseInt(postData.uid, 10)) {
						return next();
					}
					winston.verbose(`processing pid: ${postData.pid} uid: ${postData.uid} votes: ${postData.votes}`);
					db.sortedSetAdd(`uid:${postData.uid}:posts:votes`, postData.votes, postData.pid, next);
					progress.incr();
				});
			}, next);
		}, {
			progress: progress,
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Chat room hashes',
	timestamp: Date.UTC(2015, 11, 23),
	method: function (callback) {
		db.getObjectField('global', 'nextChatRoomId', (err, nextChatRoomId) => {
			if (err) {
				return callback(err);
			}
			let currentChatRoomId = 1;
			async.whilst((next) => {
				next(null, currentChatRoomId <= nextChatRoomId);
			}, (next) => {
				db.getSortedSetRange(`chat:room:${currentChatRoomId}:uids`, 0, 0, (err, uids) => {
					if (err) {
						return next(err);
					}
					if (!Array.isArray(uids) || !uids.length || !uids[0]) {
						currentChatRoomId += 1;
						return next();
					}

					db.setObject(`chat:room:${currentChatRoomId}`, { owner: uids[0], roomId: currentChatRoomId }, (err) => {
						if (err) {
							return next(err);
						}
						currentChatRoomId += 1;
						next();
					});
				});
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Upgrading chats',
	timestamp: Date.UTC(2015, 11, 15),
	method: function (callback) {
		db.getObjectFields('global', ['nextMid', 'nextChatRoomId'], (err, globalData) => {
			if (err) {
				return callback(err);
			}

			const rooms = {};
			let roomId = globalData.nextChatRoomId || 1;
			let currentMid = 1;

			async.whilst((next) => {
				next(null, currentMid <= globalData.nextMid);
			}, (next) => {
				db.getObject(`message:${currentMid}`, (err, message) => {
					if (err || !message) {
						winston.verbose('skipping chat message ', currentMid);
						currentMid += 1;
						return next(err);
					}

					const pairID = [parseInt(message.fromuid, 10), parseInt(message.touid, 10)].sort().join(':');
					const msgTime = parseInt(message.timestamp, 10);

					function addMessageToUids(roomId, callback) {
						async.parallel([
							function (next) {
								db.sortedSetAdd(`uid:${message.fromuid}:chat:room:${roomId}:mids`, msgTime, currentMid, next);
							},
							function (next) {
								db.sortedSetAdd(`uid:${message.touid}:chat:room:${roomId}:mids`, msgTime, currentMid, next);
							},
						], callback);
					}

					if (rooms[pairID]) {
						winston.verbose(`adding message ${currentMid} to existing roomID ${roomId}`);
						addMessageToUids(rooms[pairID], (err) => {
							if (err) {
								return next(err);
							}
							currentMid += 1;
							next();
						});
					} else {
						winston.verbose(`adding message ${currentMid} to new roomID ${roomId}`);
						async.parallel([
							function (next) {
								db.sortedSetAdd(`uid:${message.fromuid}:chat:rooms`, msgTime, roomId, next);
							},
							function (next) {
								db.sortedSetAdd(`uid:${message.touid}:chat:rooms`, msgTime, roomId, next);
							},
							function (next) {
								db.sortedSetAdd(`chat:room:${roomId}:uids`, [msgTime, msgTime + 1], [message.fromuid, message.touid], next);
							},
							function (next) {
								addMessageToUids(roomId, next);
							},
						], (err) => {
							if (err) {
								return next(err);
							}
							rooms[pairID] = roomId;
							roomId += 1;
							currentMid += 1;
							db.setObjectField('global', 'nextChatRoomId', roomId, next);
						});
					}
				});
			}, callback);
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Adding theme to active plugins sorted set',
	timestamp: Date.UTC(2015, 11, 23),
	method: function (callback) {
		async.waterfall([
			async.apply(db.getObjectField, 'config', 'theme:id'),
			async.apply(db.sortedSetAdd, 'plugins:active', 0),
		], callback);
	},
'use strict';

const async = require('async');

module.exports = {
	name: 'Creating Global moderators group',
	timestamp: Date.UTC(2016, 0, 23),
	method: function (callback) {
		const groups = require('../../groups');
		async.waterfall([
			function (next) {
				groups.exists('Global Moderators', next);
			},
			function (exists, next) {
				if (exists) {
					return next(null, null);
				}
				groups.create({
					name: 'Global Moderators',
					userTitle: 'Global Moderator',
					description: 'Forum wide moderators',
					hidden: 0,
					private: 1,
					disableJoinRequests: 1,
				}, next);
			},
			function (groupData, next) {
				groups.show('Global Moderators', next);
			},
		], callback);
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Social: Post Sharing',
	timestamp: Date.UTC(2016, 1, 25),
	method: function (callback) {
		const social = require('../../social');
		async.parallel([
			function (next) {
				social.setActivePostSharingNetworks(['facebook', 'google', 'twitter'], next);
			},
			function (next) {
				db.deleteObjectField('config', 'disableSocialButtons', next);
			},
		], callback);
	},
'use strict';

const nconf = require('nconf');

const db = require('../../database');
const meta = require('../../meta');
const topics = require('../../topics');
const batch = require('../../batch');

module.exports = {
	name: 'Migrate existing topic thumbnails to new format',
	timestamp: Date.UTC(2020, 11, 11),
	method: async function () {
		const { progress } = this;
		const current = await meta.configs.get('topicThumbSize');

		if (parseInt(current, 10) === 120) {
			await meta.configs.set('topicThumbSize', 512);
		}

		await batch.processSortedSet('topics:tid', async (tids) => {
			const keys = tids.map(tid => `topic:${tid}`);
			const topicThumbs = (await db.getObjectsFields(keys, ['thumb']))
				.map(obj => (obj.thumb ? obj.thumb.replace(nconf.get('upload_url'), '') : null));

			await Promise.all(tids.map(async (tid, idx) => {
				const path = topicThumbs[idx];
				if (path) {
					if (path.length < 255 && !path.startsWith('data:')) {
						await topics.thumbs.associate({ id: tid, path });
					}
					await db.deleteObjectField(keys[idx], 'thumb');
				}

				progress.incr();
			}));
		}, {
			batch: 500,
			progress: progress,
		});
'use strict';

const async = require('async');
const db = require('../../database');
const batch = require('../../batch');
const topics = require('../../topics');

module.exports = {
	name: 'Create category tags sorted sets',
	timestamp: Date.UTC(2020, 10, 23),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('topics:tid', async (tids) => {
			await async.eachSeries(tids, async (tid) => {
				const [topicData, tags] = await Promise.all([
					topics.getTopicFields(tid, ['cid', 'timestamp']),
					topics.getTopicTags(tid),
				]);

				if (tags.length) {
					const { cid } = topicData;
					await async.eachSeries(tags, async (tag) => {
						await db.sortedSetAdd(`cid:${cid}:tag:${tag}:topics`, topicData.timestamp, tid);
						const count = await db.sortedSetCard(`cid:${cid}:tag:${tag}:topics`);
						await db.sortedSetAdd(`cid:${cid}:tags`, count, tag);
					});
				}

				progress.incr();
			});
		}, {
			batch: 500,
			progress: progress,
		});
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Remove duplicate image field for categories',
	timestamp: Date.UTC(2020, 5, 9),
	method: async () => {
		const batch = require('../../batch');
		await batch.processSortedSet('categories:cid', async (cids) => {
			let categoryData = await db.getObjects(cids.map(c => `category:${c}`));
			categoryData = categoryData.filter(c => c && (c.image || c.backgroundImage));
			if (categoryData.length) {
				await Promise.all(categoryData.map(async (data) => {
					if (data.image && !data.backgroundImage) {
						await db.setObjectField(`category:${data.cid}`, 'backgroundImage', data.image);
					}
					await db.deleteObjectField(`category:${data.cid}`, 'image', data.image);
				}));
			}
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Unescape navigation titles',
	timestamp: Date.UTC(2020, 5, 26),
	method: async function () {
		const data = await db.getSortedSetRangeWithScores('navigation:enabled', 0, -1);
		const translator = require('../../translator');
		const order = [];
		const items = [];
		data.forEach((item) => {
			const navItem = JSON.parse(item.value);
			if (navItem.hasOwnProperty('title')) {
				navItem.title = translator.unescape(navItem.title);
				navItem.title = navItem.title.replace(/&#x5C;/g, '');
			}
			if (navItem.hasOwnProperty('text')) {
				navItem.text = translator.unescape(navItem.text);
				navItem.text = navItem.text.replace(/&#x5C;/g, '');
			}
			if (navItem.hasOwnProperty('route')) {
				navItem.route = navItem.route.replace('&#x2F;', '/');
			}
			order.push(item.score);
			items.push(JSON.stringify(navItem));
		});
		await db.delete('navigation:enabled');
		await db.sortedSetAdd('navigation:enabled', order, items);
'use strict';

const db = require('../../database');

const batch = require('../../batch');

module.exports = {
	name: 'Re-add deleted topics to topics:recent',
	timestamp: Date.UTC(2018, 9, 11),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('topics:tid', async (tids) => {
			progress.incr(tids.length);
			const topicData = await db.getObjectsFields(
				tids.map(tid => `topic:${tid}`),
				['tid', 'lastposttime', 'viewcount', 'postcount', 'upvotes', 'downvotes']
			);
			if (!topicData.tid) {
				return;
			}
			topicData.forEach((t) => {
				if (t.hasOwnProperty('upvotes') && t.hasOwnProperty('downvotes')) {
					t.votes = parseInt(t.upvotes, 10) - parseInt(t.downvotes, 10);
				}
			});

			await db.sortedSetAdd(
				'topics:recent',
				topicData.map(t => t.lastposttime || 0),
				topicData.map(t => t.tid)
			);

			await db.sortedSetAdd(
				'topics:views',
				topicData.map(t => t.viewcount || 0),
				topicData.map(t => t.tid)
			);

			await db.sortedSetAdd(
				'topics:posts',
				topicData.map(t => t.postcount || 0),
				topicData.map(t => t.tid)
			);

			await db.sortedSetAdd(
				'topics:votes',
				topicData.map(t => t.votes || 0),
				topicData.map(t => t.tid)
			);
		}, {
			progress: progress,
			batchSize: 500,
		});
	},
'use strict';

const async = require('async');
const privileges = require('../../privileges');

module.exports = {
	name: 'Global view privileges',
	timestamp: Date.UTC(2019, 0, 5),
	method: function (callback) {
		const meta = require('../../meta');

		const tasks = [
			async.apply(privileges.global.give, ['groups:view:users', 'groups:view:tags', 'groups:view:groups'], 'registered-users'),
		];

		if (parseInt(meta.config.privateUserInfo, 10) !== 1) {
			tasks.push(async.apply(privileges.global.give, ['groups:view:users', 'groups:view:groups'], 'guests'));
			tasks.push(async.apply(privileges.global.give, ['groups:view:users', 'groups:view:groups'], 'spiders'));
		}

		if (parseInt(meta.config.privateTagListing, 10) !== 1) {
			tasks.push(async.apply(privileges.global.give, ['groups:view:tags'], 'guests'));
			tasks.push(async.apply(privileges.global.give, ['groups:view:tags'], 'spiders'));
		}

'use strict';

const async = require('async');

const db = require('../../database');
const batch = require('../../batch');
const categories = require('../../categories');

module.exports = {
	name: 'Update category watch data',
	timestamp: Date.UTC(2018, 11, 13),
	method: function (callback) {
		const { progress } = this;
		let keys;
		async.waterfall([
			function (next) {
				db.getSortedSetRange('categories:cid', 0, -1, next);
			},
			function (cids, next) {
				keys = cids.map(cid => `cid:${cid}:ignorers`);
				batch.processSortedSet('users:joindate', (uids, next) => {
					progress.incr(uids.length);

					async.eachSeries(cids, (cid, next) => {
						db.isSortedSetMembers(`cid:${cid}:ignorers`, uids, (err, isMembers) => {
							if (err) {
								return next(err);
							}
							uids = uids.filter((uid, index) => isMembers[index]);
							if (!uids.length) {
								return setImmediate(next);
							}
							const states = uids.map(() => categories.watchStates.ignoring);
							db.sortedSetAdd(`cid:${cid}:uid:watch:state`, states, uids, next);
						});
					}, next);
				}, {
					progress: progress,
					batch: 500,
				}, next);
			},
			function (next) {
				db.deleteAll(keys, next);
			},
		], callback);
'use strict';

const privileges = require('../../privileges');

module.exports = {
	name: 'Group create global privilege',
	timestamp: Date.UTC(2019, 0, 4),
	method: function (callback) {
		const meta = require('../../meta');
		if (parseInt(meta.config.allowGroupCreation, 10) === 1) {
			privileges.global.give(['groups:group:create'], 'registered-users', callback);
		} else {
			setImmediate(callback);
		}
	},
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Update global and user language keys',
	timestamp: Date.UTC(2016, 10, 22),
	method: function (callback) {
		const user = require('../../user');
		const meta = require('../../meta');
		const batch = require('../../batch');
		let newLanguage;
		async.parallel([
			function (next) {
				meta.configs.get('defaultLang', (err, defaultLang) => {
					if (err) {
						return next(err);
					}

					if (!defaultLang) {
						return setImmediate(next);
					}

					newLanguage = defaultLang.replace('_', '-').replace('@', '-x-');
					if (newLanguage !== defaultLang) {
						meta.configs.set('defaultLang', newLanguage, next);
					} else {
						setImmediate(next);
					}
				});
			},
			function (next) {
				batch.processSortedSet('users:joindate', (ids, next) => {
					async.each(ids, (uid, next) => {
						async.waterfall([
							async.apply(db.getObjectField, `user:${uid}:settings`, 'userLang'),
							function (language, next) {
								if (!language) {
									return setImmediate(next);
								}

								newLanguage = language.replace('_', '-').replace('@', '-x-');
								if (newLanguage !== language) {
									user.setSetting(uid, 'userLang', newLanguage, next);
								} else {
									setImmediate(next);
								}
							},
						], next);
					}, next);
				}, next);
			},
		], callback);
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Sorted set for pinned topics',
	timestamp: Date.UTC(2016, 10, 25),
	method: function (callback) {
		const topics = require('../../topics');
		const batch = require('../../batch');
		batch.processSortedSet('topics:tid', (ids, next) => {
			topics.getTopicsFields(ids, ['tid', 'cid', 'pinned', 'lastposttime'], (err, data) => {
				if (err) {
					return next(err);
				}

				data = data.filter(topicData => parseInt(topicData.pinned, 10) === 1);

				async.eachSeries(data, (topicData, next) => {
					winston.verbose(`processing tid: ${topicData.tid}`);

					async.parallel([
						async.apply(db.sortedSetAdd, `cid:${topicData.cid}:tids:pinned`, Date.now(), topicData.tid),
						async.apply(db.sortedSetRemove, `cid:${topicData.cid}:tids`, topicData.tid),
						async.apply(db.sortedSetRemove, `cid:${topicData.cid}:tids:posts`, topicData.tid),
					], next);
				}, next);
'use strict';

const async = require('async');
const privileges = require('../../privileges');
const groups = require('../../groups');
const db = require('../../database');

module.exports = {
	name: 'Give mods explicit privileges',
	timestamp: Date.UTC(2019, 4, 28),
	method: function (callback) {
		const defaultPrivileges = [
			'find',
			'read',
			'topics:read',
			'topics:create',
			'topics:reply',
			'topics:tag',
			'posts:edit',
			'posts:history',
			'posts:delete',
			'posts:upvote',
			'posts:downvote',
			'topics:delete',
		];
		const modPrivileges = defaultPrivileges.concat([
			'posts:view_deleted',
			'purge',
		]);

		const globalModPrivs = [
			'groups:chat',
			'groups:upload:post:image',
			'groups:upload:post:file',
			'groups:signature',
			'groups:ban',
			'groups:search:content',
			'groups:search:users',
			'groups:search:tags',
			'groups:view:users',
			'groups:view:tags',
			'groups:view:groups',
			'groups:local:login',
		];

		async.waterfall([
			function (next) {
				db.getSortedSetRevRange('categories:cid', 0, -1, next);
			},
			function (cids, next) {
				async.eachSeries(cids, (cid, next) => {
					async.waterfall([
						function (next) {
							givePrivsToModerators(cid, '', next);
						},
						function (next) {
							givePrivsToModerators(cid, 'groups:', next);
						},
						function (next) {
							privileges.categories.give(modPrivileges.map(p => `groups:${p}`), cid, ['Global Moderators'], next);
						},
					], next);
				}, next);
			},
			function (next) {
				privileges.global.give(globalModPrivs, 'Global Moderators', next);
			},
		], callback);

		function givePrivsToModerators(cid, groupPrefix, callback) {
			const privGroups = modPrivileges.map(priv => `cid:${cid}:privileges:${groupPrefix}${priv}`);

			async.waterfall([
				function (next) {
					db.getSortedSetRevRange(`group:cid:${cid}:privileges:${groupPrefix}moderate:members`, 0, -1, next);
				},
				function (members, next) {
					async.eachSeries(members, (member, next) => {
						groups.join(privGroups, member, next);
					}, next);
'use strict';

const async = require('async');

const db = require('../../database');
const batch = require('../../batch');
const posts = require('../../posts');
const topics = require('../../topics');

module.exports = {
	name: 'Create zsets for user posts per category',
	timestamp: Date.UTC(2019, 5, 23),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('posts:pid', (pids, next) => {
			progress.incr(pids.length);
			let postData;
			async.waterfall([
				function (next) {
					posts.getPostsFields(pids, ['pid', 'uid', 'tid', 'upvotes', 'downvotes', 'timestamp'], next);
				},
				function (_postData, next) {
					postData = _postData;
					const tids = postData.map(p => p.tid);
					topics.getTopicsFields(tids, ['cid'], next);
				},
				function (topicData, next) {
					const bulk = [];
					postData.forEach((p, index) => {
						if (p && p.uid && p.pid && p.tid && p.timestamp) {
							bulk.push([`cid:${topicData[index].cid}:uid:${p.uid}:pids`, p.timestamp, p.pid]);
							if (p.votes > 0) {
								bulk.push([`cid:${topicData[index].cid}:uid:${p.uid}:pids:votes`, p.votes, p.pid]);
							}
						}
					});
					db.sortedSetAddBulk(bulk, next);
				},
			], next);
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Disable plugin metrics for existing installs',
	timestamp: Date.UTC(2019, 4, 21),
	method: async function (callback) {
		db.setObjectField('config', 'submitPluginUsage', 0, callback);
	},
'use strict';

const async = require('async');
const db = require('../../database');
const privileges = require('../../privileges');
const groups = require('../../groups');

module.exports = {
	name: 'give mod info privilege',
	timestamp: Date.UTC(2019, 9, 8),
	method: function (callback) {
		async.waterfall([
			function (next) {
				db.getSortedSetRevRange('categories:cid', 0, -1, next);
			},
			function (cids, next) {
				async.eachSeries(cids, (cid, next) => {
					async.waterfall([
						function (next) {
							givePrivsToModerators(cid, '', next);
						},
						function (next) {
							givePrivsToModerators(cid, 'groups:', next);
						},
					], next);
				}, next);
			},
			function (next) {
				privileges.global.give(['groups:view:users:info'], 'Global Moderators', next);
			},
		], callback);
		function givePrivsToModerators(cid, groupPrefix, callback) {
			async.waterfall([
				function (next) {
					db.getSortedSetRevRange(`group:cid:${cid}:privileges:${groupPrefix}moderate:members`, 0, -1, next);
				},
				function (members, next) {
					async.eachSeries(members, (member, next) => {
						groups.join(['cid:0:privileges:view:users:info'], member, next);
					}, next);
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Update registration type',
	timestamp: Date.UTC(2019, 5, 4),
	method: function (callback) {
		const meta = require('../../meta');
		const registrationType = meta.config.registrationType || 'normal';
		if (registrationType === 'admin-approval' || registrationType === 'admin-approval-ip') {
			db.setObject('config', {
				registrationType: 'normal',
				registrationApprovalType: registrationType,
			}, callback);
'use strict';


const async = require('async');

const groups = require('../../groups');
const db = require('../../database');

module.exports = {
	name: 'Give deleted post viewing privilege to moderators on all categories',
	timestamp: Date.UTC(2018, 5, 8),
	method: function (callback) {
		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}
			async.eachSeries(cids, (cid, next) => {
				async.waterfall([
					async.apply(db.getSortedSetRange.bind(db), `group:cid:${cid}:privileges:moderate:members`, 0, -1),
					function (uids, next) {
						async.eachSeries(uids, (uid, next) => groups.join(`cid:${cid}:privileges:posts:view_deleted`, uid, next), next);
					},
				], next);
			}, callback);
		});
'use strict';


const async = require('async');

const privileges = require('../../privileges');
const db = require('../../database');

module.exports = {
	name: 'Give post history viewing privilege to registered-users on all categories',
	timestamp: Date.UTC(2018, 5, 7),
	method: function (callback) {
		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}
			async.eachSeries(cids, (cid, next) => {
				privileges.categories.give(['groups:posts:history'], cid, 'registered-users', next);
			}, callback);
		});
'use strict';

const async = require('async');

module.exports = {
	name: 'Give global search privileges',
	timestamp: Date.UTC(2018, 4, 28),
	method: function (callback) {
		const meta = require('../../meta');
		const privileges = require('../../privileges');
		const allowGuestSearching = parseInt(meta.config.allowGuestSearching, 10) === 1;
		const allowGuestUserSearching = parseInt(meta.config.allowGuestUserSearching, 10) === 1;
		async.waterfall([
			function (next) {
				privileges.global.give(['groups:search:content', 'groups:search:users', 'groups:search:tags'], 'registered-users', next);
			},
			function (next) {
				const guestPrivs = [];
				if (allowGuestSearching) {
					guestPrivs.push('groups:search:content');
				}
				if (allowGuestUserSearching) {
					guestPrivs.push('groups:search:users');
				}
				guestPrivs.push('groups:search:tags');
'use strict';


const async = require('async');
const crypto = require('crypto');
const nconf = require('nconf');
const batch = require('../../batch');
const db = require('../../database');

module.exports = {
	name: 'Hash all IP addresses stored in Recent IPs zset',
	timestamp: Date.UTC(2018, 5, 22),
	method: function (callback) {
		const { progress } = this;
		const hashed = /[a-f0-9]{32}/;
		let hash;

		batch.processSortedSet('ip:recent', (ips, next) => {
			async.each(ips, (set, next) => {
				// Short circuit if already processed
				if (hashed.test(set.value)) {
					progress.incr();
					return setImmediate(next);
				}

				hash = crypto.createHash('sha1').update(set.value + nconf.get('secret')).digest('hex');

				async.series([
					async.apply(db.sortedSetAdd, 'ip:recent', set.score, hash),
					async.apply(db.sortedSetRemove, 'ip:recent', set.value),
				], (err) => {
					progress.incr();
					next(err);
				});
			}, next);
		}, {
			withScores: 1,
			progress: this.progress,
		}, callback);
	},
'use strict';

const db = require('../../database');
const privileges = require('../../privileges');

module.exports = {
	name: 'Removing file upload privilege if file uploads were disabled (`allowFileUploads`)',
	timestamp: Date.UTC(2020, 4, 21),
	method: async () => {
		const allowFileUploads = parseInt(await db.getObjectField('config', 'allowFileUploads'), 10);
		if (allowFileUploads === 1) {
			await db.deleteObjectField('config', 'allowFileUploads');
			return;
		}

		// Remove `upload:post:file` privilege for all groups
		await privileges.categories.rescind(['groups:upload:post:file'], 0, ['guests', 'registered-users', 'Global Moderators']);

		// Clean up the old option from the config hash
		await db.deleteObjectField('config', 'allowFileUploads');
'use strict';

const async = require('async');
const db = require('../../database');
const batch = require('../../batch');


module.exports = {
	name: 'Update moderation notes to hashes',
	timestamp: Date.UTC(2019, 3, 5),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (ids, next) => {
			async.each(ids, (uid, next) => {
				progress.incr();
				db.getSortedSetRevRange(`uid:${uid}:moderation:notes`, 0, -1, (err, notes) => {
					if (err || !notes.length) {
						return next(err);
					}

					async.eachSeries(notes, (note, next) => {
						let noteData;
						async.waterfall([
							function (next) {
								try {
									noteData = JSON.parse(note);
									noteData.timestamp = noteData.timestamp || Date.now();
									setImmediate(next);
								} catch (err) {
									next(err);
								}
							},
							function (next) {
								db.sortedSetRemove(`uid:${uid}:moderation:notes`, note, next);
							},
							function (next) {
								db.setObject(`uid:${uid}:moderation:note:${noteData.timestamp}`, {
									uid: noteData.uid,
									timestamp: noteData.timestamp,
									note: noteData.note,
								}, next);
							},
							function (next) {
								db.sortedSetAdd(`uid:${uid}:moderation:notes`, noteData.timestamp, noteData.timestamp, next);
							},
						], next);
					}, next);
				});
			}, next);
'use strict';

const async = require('async');
const db = require('../../database');
const user = require('../../user');

module.exports = {
	name: 'Delete username email history for deleted users',
	timestamp: Date.UTC(2019, 2, 25),
	method: function (callback) {
		const { progress } = this;
		let currentUid = 1;
		db.getObjectField('global', 'nextUid', (err, nextUid) => {
			if (err) {
				return callback(err);
			}
			progress.total = nextUid;
			async.whilst((next) => {
				next(null, currentUid < nextUid);
			},
			(next) => {
				progress.incr();
				user.exists(currentUid, (err, exists) => {
					if (err) {
						return next(err);
					}
					if (exists) {
						currentUid += 1;
						return next();
					}
					db.deleteAll([`user:${currentUid}:usernames`, `user:${currentUid}:emails`], (err) => {
						if (err) {
							return next(err);
						}
						currentUid += 1;
						next();
					});
				});
			},
			(err) => {
'use strict';

const batch = require('../../batch');
const posts = require('../../posts');
const db = require('../../database');

module.exports = {
	name: 'Calculate image sizes of all uploaded images',
	timestamp: Date.UTC(2019, 2, 16),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('posts:pid', async (postData) => {
			const keys = postData.map(p => `post:${p.pid}:uploads`);
			const uploads = await db.getSortedSetRange(keys, 0, -1);
			await posts.uploads.saveSize(uploads);
			progress.incr(postData.length);
		}, {
			batch: 100,
			progress: progress,
'use strict';

const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Create subCategoriesPerPage property for categories',
	timestamp: Date.UTC(2021, 0, 31),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('categories:cid', async (cids) => {
			const keys = cids.map(cid => `category:${cid}`);
			await db.setObject(keys, {
				subCategoriesPerPage: 10,
			});
			progress.incr(cids.length);
		}, {
			batch: 500,
			progress: progress,
'use strict';

const _ = require('lodash');
const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Store number of thumbs a topic has in the topic object',
	timestamp: Date.UTC(2021, 1, 7),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('topics:tid', async (tids) => {
			const keys = tids.map(tid => `topic:${tid}:thumbs`);
			const counts = await db.sortedSetsCard(keys);
			const tidToCount = _.zip(tids, counts);
			const tidsWithThumbs = tids.filter((t, i) => counts[i] > 0);
			await db.setObjectBulk(
				tidsWithThumbs.map(tid => `topic:${tid}`),
				tidsWithThumbs.map(tid => ({ numThumbs: tidToCount[tid] }))
			);

			progress.incr(tids.length);
		}, {
			batch: 500,
'use strict';

const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Create category name sorted set',
	timestamp: Date.UTC(2021, 0, 27),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('categories:cid', async (cids) => {
			const keys = cids.map(cid => `category:${cid}`);
			let categoryData = await db.getObjectsFields(keys, ['cid', 'name']);
			categoryData = categoryData.filter(c => c.cid && c.name);
			const bulkAdd = categoryData.map(cat => [
				'categories:name',
				0,
				`${String(cat.name).substr(0, 200).toLowerCase()}:${cat.cid}`,
			]);
			await db.sortedSetAddBulk(bulkAdd);
			progress.incr(cids.length);
		}, {
			batch: 500,
			progress: progress,
'use strict';

const batch = require('../../batch');
const db = require('../../database');
const groups = require('../../groups');

const now = Date.now();

module.exports = {
	name: 'Move banned users to banned-users group',
	timestamp: Date.UTC(2020, 11, 13),
	method: async function () {
		const { progress } = this;
		const timestamp = await db.getObjectField('group:administrators', 'timestamp');
		const bannedExists = await groups.exists('banned-users');
		if (!bannedExists) {
			await groups.create({
				name: 'banned-users',
				hidden: 1,
				private: 1,
				system: 1,
				disableLeave: 1,
				disableJoinRequests: 1,
				timestamp: timestamp + 1,
			});
		}

		await batch.processSortedSet('users:banned', async (uids) => {
			progress.incr(uids.length);

			await db.sortedSetAdd(
				'group:banned-users:members',
				uids.map(() => now),
				uids
			);

			await db.sortedSetRemove(
				[
					'group:registered-users:members',
					'group:verified-users:members',
					'group:unverified-users:members',
					'group:Global Moderators:members',
				],
				uids
			);
		}, {
			batch: 500,
			progress: this.progress,
		});


		const bannedCount = await db.sortedSetCard('group:banned-users:members');
		const registeredCount = await db.sortedSetCard('group:registered-users:members');
		const verifiedCount = await db.sortedSetCard('group:verified-users:members');
		const unverifiedCount = await db.sortedSetCard('group:unverified-users:members');
		const globalModCount = await db.sortedSetCard('group:Global Moderators:members');
		await db.setObjectField('group:banned-users', 'memberCount', bannedCount);
		await db.setObjectField('group:registered-users', 'memberCount', registeredCount);
		await db.setObjectField('group:verified-users', 'memberCount', verifiedCount);
		await db.setObjectField('group:unverified-users', 'memberCount', unverifiedCount);
'use strict';

const db = require('../../database');

const batch = require('../../batch');

module.exports = {
	name: 'Remove uid:<uid>:ignored:cids',
	timestamp: Date.UTC(2018, 11, 11),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (uids, next) => {
			progress.incr(uids.length);
			const keys = uids.map(uid => `uid:${uid}:ignored:cids`);
			db.deleteAll(keys, next);
		}, {
			progress: this.progress,
			batch: 500,
		}, callback);
'use strict';

const async = require('async');
const db = require('../../database');

module.exports = {
	name: 'Flatten navigation data',
	timestamp: Date.UTC(2018, 1, 17),
	method: function (callback) {
		async.waterfall([
			function (next) {
				db.getSortedSetRangeWithScores('navigation:enabled', 0, -1, next);
			},
			function (data, next) {
				const order = [];
				const items = [];
				data.forEach((item) => {
					let navItem = JSON.parse(item.value);
					const keys = Object.keys(navItem);
					if (keys.length && parseInt(keys[0], 10) >= 0) {
						navItem = navItem[keys[0]];
					}
					order.push(item.score);
					items.push(JSON.stringify(navItem));
				});

				async.series([
					function (next) {
						db.delete('navigation:enabled', next);
					},
					function (next) {
						db.sortedSetAdd('navigation:enabled', order, items, next);
					},
				], next);
			},
'use strict';

const async = require('async');
const db = require('../../database');

module.exports = {
	name: 'Add default settings for notification delivery types',
	timestamp: Date.UTC(2018, 1, 14),
	method: function (callback) {
		async.waterfall([
			function (next) {
				db.getObject('config', next);
			},
			function (config, next) {
				const postNotifications = parseInt(config.sendPostNotifications, 10) === 1 ? 'notification' : 'none';
				const chatNotifications = parseInt(config.sendChatNotifications, 10) === 1 ? 'notification' : 'none';
				db.setObject('config', {
					notificationType_upvote: config.notificationType_upvote || 'notification',
					'notificationType_new-topic': config['notificationType_new-topic'] || 'notification',
					'notificationType_new-reply': config['notificationType_new-reply'] || postNotifications,
					notificationType_follow: config.notificationType_follow || 'notification',
					'notificationType_new-chat': config['notificationType_new-chat'] || chatNotifications,
					'notificationType_group-invite': config['notificationType_group-invite'] || 'notification',
				}, next);
			},
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Revising minimum password strength to 1 (from 0)',
	timestamp: Date.UTC(2018, 1, 21),
	method: function (callback) {
		async.waterfall([
			async.apply(db.getObjectField.bind(db), 'config', 'minimumPasswordStrength'),
			function (strength, next) {
				if (!strength) {
					return db.setObjectField('config', 'minimumPasswordStrength', 1, next);
				}

				setImmediate(next);
			},
		], callback);
'use strict';

const _ = require('lodash');
const db = require('../../database');

const batch = require('../../batch');

module.exports = {
	name: 'Clear purged replies and toPid',
	timestamp: Date.UTC(2020, 10, 26),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('posts:pid', async (pids) => {
			progress.incr(pids.length);
			let postData = await db.getObjects(pids.map(pid => `post:${pid}`));
			postData = postData.filter(p => p && parseInt(p.toPid, 10));
			if (!postData.length) {
				return;
			}
			const toPids = postData.map(p => p.toPid);
			const exists = await db.exists(toPids.map(pid => `post:${pid}`));
			const pidsToDelete = postData.filter((p, index) => !exists[index]).map(p => p.pid);
			await db.deleteObjectFields(pidsToDelete.map(pid => `post:${pid}`), ['toPid']);

			const repliesToDelete = _.uniq(toPids.filter((pid, index) => !exists[index]));
			await db.deleteAll(repliesToDelete.map(pid => `pid:${pid}:replies`));
		}, {
			progress: progress,
			batchSize: 500,
'use strict';

const async = require('async');
const db = require('../../database');

const batch = require('../../batch');

module.exports = {
	name: 'add filters to events',
	timestamp: Date.UTC(2018, 9, 4),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('events:time', (eids, next) => {
			async.eachSeries(eids, (eid, next) => {
				progress.incr();

				db.getObject(`event:${eid}`, (err, eventData) => {
					if (err) {
						return next(err);
					}
					if (!eventData) {
						return db.sortedSetRemove('events:time', eid, next);
					}
					// privilege events we're missing type field
					if (!eventData.type && eventData.privilege) {
						eventData.type = 'privilege-change';
						async.waterfall([
							function (next) {
								db.setObjectField(`event:${eid}`, 'type', 'privilege-change', next);
							},
							function (next) {
								db.sortedSetAdd(`events:time:${eventData.type}`, eventData.timestamp, eid, next);
							},
						], next);
						return;
					}

					db.sortedSetAdd(`events:time:${eventData.type || ''}`, eventData.timestamp, eid, next);
				});
			}, next);
		}, {
			progress: this.progress,
		}, callback);
	},
'use strict';

const async = require('async');
const db = require('../../database');

const batch = require('../../batch');

module.exports = {
	name: 'Fix category topic zsets',
	timestamp: Date.UTC(2018, 9, 11),
	method: function (callback) {
		const { progress } = this;

		const topics = require('../../topics');
		batch.processSortedSet('topics:tid', (tids, next) => {
			async.eachSeries(tids, (tid, next) => {
				progress.incr();

				async.waterfall([
					function (next) {
						db.getObjectFields(`topic:${tid}`, ['cid', 'pinned', 'postcount'], next);
					},
					function (topicData, next) {
						if (parseInt(topicData.pinned, 10) === 1) {
							return setImmediate(next);
						}
						topicData.postcount = parseInt(topicData.postcount, 10) || 0;
						db.sortedSetAdd(`cid:${topicData.cid}:tids:posts`, topicData.postcount, tid, next);
					},
					function (next) {
						topics.updateLastPostTimeFromLastPid(tid, next);
					},
				], next);
			}, next);
		}, {
'use strict';

const db = require('../../database');
const posts = require('../../posts');
const topics = require('../../topics');
const batch = require('../../batch');

module.exports = {
	name: 'Fix category post zsets',
	timestamp: Date.UTC(2018, 9, 10),
	method: async function () {
		const { progress } = this;

		const cids = await db.getSortedSetRange('categories:cid', 0, -1);
		const keys = cids.map(cid => `cid:${cid}:pids`);

		await batch.processSortedSet('posts:pid', async (postData) => {
			const pids = postData.map(p => p.value);
			const topicData = await posts.getPostsFields(pids, ['tid']);
			const categoryData = await topics.getTopicsFields(topicData.map(t => t.tid), ['cid']);

			await db.sortedSetRemove(keys, pids);
			const bulkAdd = postData.map((p, i) => ([`cid:${categoryData[i].cid}:pids`, p.score, p.value]));
			await db.sortedSetAddBulk(bulkAdd);
			progress.incr(postData.length);
		}, {
			batch: 500,
			progress: progress,
			withScores: true,
		});
'use strict';

const nconf = require('nconf');
const db = require('../../database');

module.exports = {
	name: 'Optimize PostgreSQL sessions',
	timestamp: Date.UTC(2018, 9, 1),
	method: function (callback) {
		if (nconf.get('database') !== 'postgres' || nconf.get('redis')) {
			return callback();
		}

		db.pool.query(`
BEGIN TRANSACTION;

CREATE TABLE IF NOT EXISTS "session" (
	"sid" CHAR(32) NOT NULL
		COLLATE "C"
		PRIMARY KEY,
	"sess" JSONB NOT NULL,
	"expire" TIMESTAMPTZ NOT NULL
) WITHOUT OIDS;

CREATE INDEX IF NOT EXISTS "session_expire_idx" ON "session"("expire");

ALTER TABLE "session"
	ALTER "sid" TYPE CHAR(32) COLLATE "C",
	ALTER "sid" SET STORAGE PLAIN,
	ALTER "sess" TYPE JSONB,
	ALTER "expire" TYPE TIMESTAMPTZ,
	CLUSTER ON "session_expire_idx";

CLUSTER "session";
ANALYZE "session";

COMMIT;`, (err) => {
			callback(err);
		});
	},
'use strict';

const async = require('async');
const db = require('../../database');

const batch = require('../../batch');
const user = require('../../user');

module.exports = {
	name: 'Record first entry in username/email history',
	timestamp: Date.UTC(2018, 7, 28),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (ids, next) => {
			async.each(ids, (uid, next) => {
				async.parallel([
					function (next) {
						// Username
						async.waterfall([
							async.apply(db.sortedSetCard, `user:${uid}:usernames`),
							(count, next) => {
								if (count > 0) {
									// User has changed their username before, no record of original username, skip.
									return setImmediate(next, null, null);
								}

								user.getUserFields(uid, ['username', 'joindate'], next);
							},
							(userdata, next) => {
								if (!userdata || !userdata.joindate) {
									return setImmediate(next);
								}

								db.sortedSetAdd(`user:${uid}:usernames`, userdata.joindate, [userdata.username, userdata.joindate].join(':'), next);
							},
						], next);
					},
					function (next) {
						// Email
						async.waterfall([
							async.apply(db.sortedSetCard, `user:${uid}:emails`),
							(count, next) => {
								if (count > 0) {
									// User has changed their email before, no record of original email, skip.
									return setImmediate(next, null, null);
								}

								user.getUserFields(uid, ['email', 'joindate'], next);
							},
							(userdata, next) => {
								if (!userdata || !userdata.joindate) {
									return setImmediate(next);
								}

								db.sortedSetAdd(`user:${uid}:emails`, userdata.joindate, [userdata.email, userdata.joindate].join(':'), next);
							},
						], next);
					},
				], (err) => {
					progress.incr();
					setImmediate(next, err);
				});
			}, next);
		}, {
'use strict';

const async = require('async');
const db = require('../../database');

const batch = require('../../batch');
// var user = require('../../user');

module.exports = {
	name: 'Upgrade bans to hashes',
	timestamp: Date.UTC(2018, 8, 24),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (uids, next) => {
			async.eachSeries(uids, (uid, next) => {
				progress.incr();

				async.parallel({
					bans: function (next) {
						db.getSortedSetRevRangeWithScores(`uid:${uid}:bans`, 0, -1, next);
					},
					reasons: function (next) {
						db.getSortedSetRevRangeWithScores(`banned:${uid}:reasons`, 0, -1, next);
					},
					userData: function (next) {
						db.getObjectFields(`user:${uid}`, ['banned', 'banned:expire', 'joindate', 'lastposttime', 'lastonline'], next);
					},
				}, (err, results) => {
					function addBan(key, data, callback) {
						async.waterfall([
							function (next) {
								db.setObject(key, data, next);
							},
							function (next) {
								db.sortedSetAdd(`uid:${uid}:bans:timestamp`, data.timestamp, key, next);
							},
						], callback);
					}
					if (err) {
						return next(err);
					}
					// has no ban history and isn't banned, skip
					if (!results.bans.length && !parseInt(results.userData.banned, 10)) {
						return next();
					}

					// has no history, but is banned, create plain object with just uid and timestmap
					if (!results.bans.length && parseInt(results.userData.banned, 10)) {
						const banTimestamp = (
							results.userData.lastonline ||
							results.userData.lastposttime ||
							results.userData.joindate ||
							Date.now()
						);
						const banKey = `uid:${uid}:ban:${banTimestamp}`;
						addBan(banKey, { uid: uid, timestamp: banTimestamp }, next);
						return;
					}

					// process ban history
					async.eachSeries(results.bans, (ban, next) => {
						function findReason(score) {
							return results.reasons.find(reasonData => reasonData.score === score);
						}
						const reasonData = findReason(ban.score);
						const banKey = `uid:${uid}:ban:${ban.score}`;
						const data = {
							uid: uid,
							timestamp: ban.score,
							expire: parseInt(ban.value, 10),
						};
						if (reasonData) {
							data.reason = reasonData.value;
						}
						addBan(banKey, data, next);
					}, (err) => {
						next(err);
					});
				});
			}, next);
		}, {
			progress: this.progress,
		}, callback);
	},
'use strict';

module.exports = {
	name: 'Give global local login privileges',
	timestamp: Date.UTC(2018, 8, 28),
	method: function (callback) {
		const meta = require('../../meta');
		const privileges = require('../../privileges');
		const allowLocalLogin = parseInt(meta.config.allowLocalLogin, 10) !== 0;

		if (allowLocalLogin) {
			privileges.global.give(['groups:local:login'], 'registered-users', callback);
		} else {
			callback();
		}
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Removing best posts with negative scores',
	timestamp: Date.UTC(2016, 7, 5),
	method: function (callback) {
		const batch = require('../../batch');
		batch.processSortedSet('users:joindate', (ids, next) => {
			async.each(ids, (id, next) => {
				winston.verbose(`processing uid ${id}`);
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Giving upload privileges',
	timestamp: Date.UTC(2016, 6, 12),
	method: function (callback) {
		const privilegesAPI = require('../../privileges');
		const meta = require('../../meta');

		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}

			async.eachSeries(cids, (cid, next) => {
				privilegesAPI.categories.list(cid, (err, data) => {
					if (err) {
						return next(err);
					}
					async.eachSeries(data.groups, (group, next) => {
						if (group.name === 'guests' && parseInt(meta.config.allowGuestUploads, 10) !== 1) {
							return next();
						}
						if (group.privileges['groups:read']) {
							privilegesAPI.categories.give(['upload:post:image'], cid, group.name, next);
						} else {
							next();
						}
					}, next);
				});
			}, callback);
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Update global and user sound settings',
	timestamp: Date.UTC(2017, 1, 25),
	method: function (callback) {
		const meta = require('../../meta');
		const batch = require('../../batch');

		const map = {
			'notification.mp3': 'Default | Deedle-dum',
			'waterdrop-high.mp3': 'Default | Water drop (high)',
			'waterdrop-low.mp3': 'Default | Water drop (low)',
		};

		async.parallel([
			function (cb) {
				const keys = ['chat-incoming', 'chat-outgoing', 'notification'];

				db.getObject('settings:sounds', (err, settings) => {
					if (err || !settings) {
						return cb(err);
					}

					keys.forEach((key) => {
						if (settings[key] && !settings[key].includes(' | ')) {
							settings[key] = map[settings[key]] || '';
						}
					});

					meta.configs.setMultiple(settings, cb);
				});
			},
			function (cb) {
				const keys = ['notificationSound', 'incomingChatSound', 'outgoingChatSound'];

				batch.processSortedSet('users:joindate', (ids, next) => {
					async.each(ids, (uid, next) => {
						db.getObject(`user:${uid}:settings`, (err, settings) => {
							if (err || !settings) {
								return next(err);
							}
							const newSettings = {};
							keys.forEach((key) => {
								if (settings[key] && !settings[key].includes(' | ')) {
									newSettings[key] = map[settings[key]] || '';
								}
							});

							if (Object.keys(newSettings).length) {
								db.setObject(`user:${uid}:settings`, newSettings, next);
							} else {
								setImmediate(next);
							}
						});
					}, next);
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Upgrading config urls to use assets route',
	timestamp: Date.UTC(2017, 1, 28),
	method: function (callback) {
		async.waterfall([
			function (cb) {
				db.getObject('config', cb);
			},
			function (config, cb) {
				if (!config) {
					return cb();
				}

				const keys = ['brand:favicon', 'brand:touchicon', 'og:image', 'brand:logo:url', 'defaultAvatar', 'profile:defaultCovers'];

				keys.forEach((key) => {
					const oldValue = config[key];

					if (!oldValue || typeof oldValue !== 'string') {
						return;
					}

					config[key] = oldValue.replace(/(?:\/assets)?\/(images|uploads)\//g, '/assets/$1/');
				});

				db.setObject('config', config, cb);
			},
		], callback);
	},
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Granting edit/delete/delete topic on existing categories',
	timestamp: Date.UTC(2016, 7, 7),
	method: function (callback) {
		const groupsAPI = require('../../groups');
		const privilegesAPI = require('../../privileges');

		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}

			async.eachSeries(cids, (cid, next) => {
				privilegesAPI.categories.list(cid, (err, data) => {
					if (err) {
						return next(err);
					}

					const { groups } = data;
					const { users } = data;

					async.waterfall([
						function (next) {
							async.eachSeries(groups, (group, next) => {
								if (group.privileges['groups:topics:reply']) {
									return async.parallel([
										async.apply(groupsAPI.join, `cid:${cid}:privileges:groups:posts:edit`, group.name),
										async.apply(groupsAPI.join, `cid:${cid}:privileges:groups:posts:delete`, group.name),
									], (err) => {
										if (!err) {
											winston.verbose(`cid:${cid}:privileges:groups:posts:edit, cid:${cid}:privileges:groups:posts:delete granted to gid: ${group.name}`);
										}

										return next(err);
									});
								}

								next(null);
							}, next);
						},
						function (next) {
							async.eachSeries(groups, (group, next) => {
								if (group.privileges['groups:topics:create']) {
									return groupsAPI.join(`cid:${cid}:privileges:groups:topics:delete`, group.name, (err) => {
										if (!err) {
											winston.verbose(`cid:${cid}:privileges:groups:topics:delete granted to gid: ${group.name}`);
										}

										return next(err);
									});
								}

								next(null);
							}, next);
						},
						function (next) {
							async.eachSeries(users, (user, next) => {
								if (user.privileges['topics:reply']) {
									return async.parallel([
										async.apply(groupsAPI.join, `cid:${cid}:privileges:posts:edit`, user.uid),
										async.apply(groupsAPI.join, `cid:${cid}:privileges:posts:delete`, user.uid),
									], (err) => {
										if (!err) {
											winston.verbose(`cid:${cid}:privileges:posts:edit, cid:${cid}:privileges:posts:delete granted to uid: ${user.uid}`);
										}

										return next(err);
									});
								}

								next(null);
							}, next);
						},
						function (next) {
							async.eachSeries(users, (user, next) => {
								if (user.privileges['topics:create']) {
									return groupsAPI.join(`cid:${cid}:privileges:topics:delete`, user.uid, (err) => {
										if (!err) {
											winston.verbose(`cid:${cid}:privileges:topics:delete granted to uid: ${user.uid}`);
										}

										return next(err);
									});
								}

								next(null);
							}, next);
						},
					], (err) => {
						if (!err) {
							winston.verbose(`-- cid ${cid} upgraded`);
						}

						next(err);
					});
				});
			}, callback);
		});
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Category recent tids',
	timestamp: Date.UTC(2016, 8, 22),
	method: function (callback) {
		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}

			async.eachSeries(cids, (cid, next) => {
				db.getSortedSetRevRange(`cid:${cid}:pids`, 0, 0, (err, pid) => {
					if (err || !pid) {
						return next(err);
					}
					db.getObjectFields(`post:${pid}`, ['tid', 'timestamp'], (err, postData) => {
						if (err || !postData || !postData.tid) {
							return next(err);
						}
						db.sortedSetAdd(`cid:${cid}:recent_tids`, postData.timestamp, postData.tid, next);
					});
				});
			}, callback);
		});
	},
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Rename maximumImageWidth to resizeImageWidth',
	timestamp: Date.UTC(2018, 9, 24),
	method: function (callback) {
		const meta = require('../../meta');
		async.waterfall([
			function (next) {
				meta.configs.get('maximumImageWidth', next);
			},
			function (value, next) {
				meta.configs.set('resizeImageWidth', value, next);
			},
			function (next) {
				db.deleteObjectField('config', 'maximumImageWidth', next);
'use strict';

const async = require('async');

module.exports = {
	name: 'Navigation item visibility groups',
	timestamp: Date.UTC(2018, 10, 10),
	method: function (callback) {
		const navigationAdmin = require('../../navigation/admin');

		async.waterfall([
			function (next) {
				navigationAdmin.get(next);
			},
			function (data, next) {
				data.forEach((navItem) => {
					if (navItem && navItem.properties) {
						navItem.groups = [];
						if (navItem.properties.adminOnly) {
							navItem.groups.push('administrators');
						} else if (navItem.properties.globalMod) {
							navItem.groups.push('Global Moderators');
						}

						if (navItem.properties.loggedIn) {
							navItem.groups.push('registered-users');
						} else if (navItem.properties.guestOnly) {
							navItem.groups.push('guests');
						}
					}
				});
				navigationAdmin.save(data, next);
			},
		], callback);
	},
'use strict';

const async = require('async');

module.exports = {
	name: 'Widget visibility groups',
	timestamp: Date.UTC(2018, 10, 10),
	method: function (callback) {
		const widgetAdmin = require('../../widgets/admin');
		const widgets = require('../../widgets');
		async.waterfall([
			function (next) {
				widgetAdmin.getAreas(next);
			},
			function (areas, next) {
				async.eachSeries(areas, (area, next) => {
					if (area.data.length) {
						// area.data is actually an array of widgets
						area.widgets = area.data;
						area.widgets.forEach((widget) => {
							if (widget && widget.data) {
								const groupsToShow = ['administrators', 'Global Moderators'];
								if (widget.data['hide-guests'] !== 'on') {
									groupsToShow.push('guests');
								}
								if (widget.data['hide-registered'] !== 'on') {
									groupsToShow.push('registered-users');
								}

								widget.data.groups = groupsToShow;

								// if we are showing to all 4 groups, set to empty array
								// empty groups is shown to everyone
								if (groupsToShow.length === 4) {
									widget.data.groups.length = 0;
								}
							}
						});
						widgets.setArea(area, next);
					} else {
						next();
					}
				}, next);
			},
		], callback);
'use strict';

const async = require('async');

const db = require('../../database');

module.exports = {
	name: 'New sorted set cid:<cid>:tids:lastposttime',
	timestamp: Date.UTC(2017, 9, 30),
	method: function (callback) {
		const { progress } = this;

		require('../../batch').processSortedSet('topics:tid', (tids, next) => {
			async.eachSeries(tids, (tid, next) => {
				db.getObjectFields(`topic:${tid}`, ['cid', 'timestamp', 'lastposttime'], (err, topicData) => {
					if (err || !topicData) {
						return next(err);
					}
					progress.incr();

					const timestamp = topicData.lastposttime || topicData.timestamp || Date.now();
					db.sortedSetAdd(`cid:${topicData.cid}:tids:lastposttime`, timestamp, tid, next);
				}, next);
			}, next);
		}, {
'use strict';

const async = require('async');
const db = require('../../database');
const batch = require('../../batch');


module.exports = {
	name: 'Reformatting post diffs to be stored in lists and hash instead of single zset',
	timestamp: Date.UTC(2018, 2, 15),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('posts:pid', (pids, next) => {
			async.each(pids, (pid, next) => {
				db.getSortedSetRangeWithScores(`post:${pid}:diffs`, 0, -1, (err, diffs) => {
					if (err) {
						return next(err);
					}

					if (!diffs || !diffs.length) {
						progress.incr();
						return next();
					}

					// For each diff, push to list
					async.each(diffs, (diff, next) => {
						async.series([
							async.apply(db.delete.bind(db), `post:${pid}:diffs`),
							async.apply(db.listPrepend.bind(db), `post:${pid}:diffs`, diff.score),
							async.apply(db.setObject.bind(db), `diff:${pid}.${diff.score}`, {
								pid: pid,
								patch: diff.value,
							}),
						], next);
					}, (err) => {
						if (err) {
							return next(err);
						}

						progress.incr();
						return next();
					});
				});
			}, (err) => {
				if (err) {
					// Probably type error, ok to incr and continue
					progress.incr();
				}

				return next();
			});
		}, {
			progress: progress,
		}, callback);
'use strict';

const async = require('async');
const posts = require('../../posts');

module.exports = {
	name: 'Refresh post-upload associations',
	timestamp: Date.UTC(2018, 3, 16),
	method: function (callback) {
		const { progress } = this;

		require('../../batch').processSortedSet('posts:pid', (pids, next) => {
			async.each(pids, (pid, next) => {
				posts.uploads.sync(pid, next);
				progress.incr();
			}, next);
		}, {
			progress: this.progress,
		}, callback);
	},
'use strict';

const db = require('../../database');

module.exports = {
	name: 'Set default allowed file extensions',
	timestamp: Date.UTC(2017, 3, 14),
	method: function (callback) {
		db.getObjectField('config', 'allowedFileExtensions', (err, value) => {
			if (err || value) {
				return callback(err);
			}
			db.setObjectField('config', 'allowedFileExtensions', 'png,jpg,bmp', callback);
		});
	},
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'New sorted set posts:votes',
	timestamp: Date.UTC(2017, 1, 27),
	method: function (callback) {
		const { progress } = this;

		require('../../batch').processSortedSet('posts:pid', (pids, next) => {
			async.each(pids, (pid, next) => {
				db.getObjectFields(`post:${pid}`, ['upvotes', 'downvotes'], (err, postData) => {
					if (err || !postData) {
						return next(err);
					}

					progress.incr();
					const votes = parseInt(postData.upvotes || 0, 10) - parseInt(postData.downvotes || 0, 10);
					db.sortedSetAdd('posts:votes', votes, pid, next);
				});
			}, next);
		}, {
'use strict';

const async = require('async');
const db = require('../../database');
const batch = require('../../batch');


module.exports = {
	name: 'Remove relative_path from uploaded profile cover urls',
	timestamp: Date.UTC(2017, 3, 26),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (ids, done) => {
			async.each(ids, (uid, cb) => {
				async.waterfall([
					function (next) {
						db.getObjectField(`user:${uid}`, 'cover:url', next);
					},
					function (url, next) {
						progress.incr();

						if (!url) {
							return next();
						}

						const newUrl = url.replace(/^.*?\/uploads\//, '/assets/uploads/');
						db.setObjectField(`user:${uid}`, 'cover:url', newUrl, next);
					},
				], cb);
			}, done);
		}, {
			progress: this.progress,
		}, callback);
	},
'use strict';

const async = require('async');
const db = require('../../database');
const batch = require('../../batch');


module.exports = {
	name: 'Update moderation notes to zset',
	timestamp: Date.UTC(2017, 2, 22),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('users:joindate', (ids, next) => {
			async.each(ids, (uid, next) => {
				db.getObjectField(`user:${uid}`, 'moderationNote', (err, moderationNote) => {
					if (err || !moderationNote) {
						progress.incr();
						return next(err);
					}
					const note = {
						uid: 1,
						note: moderationNote,
						timestamp: Date.now(),
					};

					progress.incr();
					db.sortedSetAdd(`uid:${uid}:moderation:notes`, note.timestamp, JSON.stringify(note), next);
				});
			}, next);
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Migrating flags to new schema',
	timestamp: Date.UTC(2016, 11, 7),
	method: function (callback) {
		const batch = require('../../batch');
		const posts = require('../../posts');
		const flags = require('../../flags');
		const { progress } = this;

		batch.processSortedSet('posts:pid', (ids, next) => {
			posts.getPostsByPids(ids, 1, (err, posts) => {
				if (err) {
					return next(err);
				}

				posts = posts.filter(post => post.hasOwnProperty('flags'));

				async.each(posts, (post, next) => {
					progress.incr();

					async.parallel({
						uids: async.apply(db.getSortedSetRangeWithScores, `pid:${post.pid}:flag:uids`, 0, -1),
						reasons: async.apply(db.getSortedSetRange, `pid:${post.pid}:flag:uid:reason`, 0, -1),
					}, (err, data) => {
						if (err) {
							return next(err);
						}

						// Adding in another check here in case a post was improperly dismissed (flag count > 1 but no flags in db)
						if (!data.uids.length || !data.reasons.length) {
							return setImmediate(next);
						}

						// Just take the first entry
						const datetime = data.uids[0].score;
						const reason = data.reasons[0].split(':')[1];
						let flagObj;

						async.waterfall([
							async.apply(flags.create, 'post', post.pid, data.uids[0].value, reason, datetime),
							function (_flagObj, next) {
								flagObj = _flagObj;
								if (post['flag:state'] || post['flag:assignee']) {
									flags.update(flagObj.flagId, 1, {
										state: post['flag:state'],
										assignee: post['flag:assignee'],
										datetime: datetime,
									}, next);
								} else {
									setImmediate(next);
								}
							},
							function (next) {
								if (post.hasOwnProperty('flag:notes') && post['flag:notes'].length) {
									try {
										let history = JSON.parse(post['flag:history']);
										history = history.filter(event => event.type === 'notes')[0];

										flags.appendNote(flagObj.flagId, history.uid, post['flag:notes'], history.timestamp, next);
									} catch (e) {
										next(e);
									}
								} else {
									setImmediate(next);
								}
							},
						], (err) => {
							if (err && err.message === '[[error:post-already-flagged]]') {
								// Already flagged, no need to parse, but not an error
								next();
							} else {
								next(err);
							}
						});
					});
				}, next);
			});
		}, {
			progress: this.progress,
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Sorted sets for post replies',
	timestamp: Date.UTC(2016, 9, 14),
	method: function (callback) {
		const posts = require('../../posts');
		const batch = require('../../batch');
		const { progress } = this;

		batch.processSortedSet('posts:pid', (ids, next) => {
			posts.getPostsFields(ids, ['pid', 'toPid', 'timestamp'], (err, data) => {
				if (err) {
					return next(err);
				}

				progress.incr();

				async.eachSeries(data, (postData, next) => {
					if (!parseInt(postData.toPid, 10)) {
						return next(null);
					}
					winston.verbose(`processing pid: ${postData.pid} toPid: ${postData.toPid}`);
					async.parallel([
						async.apply(db.sortedSetAdd, `pid:${postData.toPid}:replies`, postData.timestamp, postData.pid),
						async.apply(db.incrObjectField, `post:${postData.toPid}`, 'replies'),
					], next);
				}, next);
			});
		}, {
'use strict';

const async = require('async');
const db = require('../../database');


module.exports = {
	name: 'Favourites to Bookmarks',
	timestamp: Date.UTC(2016, 9, 8),
	method: function (callback) {
		const { progress } = this;

		function upgradePosts(next) {
			const batch = require('../../batch');

			batch.processSortedSet('posts:pid', (ids, next) => {
				async.each(ids, (id, next) => {
					progress.incr();

					async.waterfall([
						function (next) {
							db.rename(`pid:${id}:users_favourited`, `pid:${id}:users_bookmarked`, next);
						},
						function (next) {
							db.getObjectField(`post:${id}`, 'reputation', next);
						},
						function (reputation, next) {
							if (parseInt(reputation, 10)) {
								db.setObjectField(`post:${id}`, 'bookmarks', reputation, next);
							} else {
								next();
							}
						},
						function (next) {
							db.deleteObjectField(`post:${id}`, 'reputation', next);
						},
					], next);
				}, next);
			}, {
				progress: progress,
			}, next);
		}

		function upgradeUsers(next) {
			const batch = require('../../batch');

			batch.processSortedSet('users:joindate', (ids, next) => {
				async.each(ids, (id, next) => {
					db.rename(`uid:${id}:favourites`, `uid:${id}:bookmarks`, next);
				}, next);
			}, {}, next);
		}

		async.series([upgradePosts, upgradeUsers], callback);
	},
'use strict';

const async = require('async');

const nconf = require('nconf');
const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Delete accidentally long-lived sessions',
	timestamp: Date.UTC(2017, 3, 16),
	method: function (callback) {
		let configJSON;
		try {
			configJSON = require('../../../config.json') || { [process.env.database]: true };
		} catch (err) {
			configJSON = { [process.env.database]: true };
		}

		const isRedisSessionStore = configJSON.hasOwnProperty('redis');
		const { progress } = this;

		async.waterfall([
			function (next) {
				if (isRedisSessionStore) {
					const connection = require('../../database/redis/connection');
					let client;
					async.waterfall([
						function (next) {
							connection.connect(nconf.get('redis'), next);
						},
						function (_client, next) {
							client = _client;
							client.keys('sess:*', next);
						},
						function (sessionKeys, next) {
							progress.total = sessionKeys.length;

							batch.processArray(sessionKeys, (keys, next) => {
								const multi = client.multi();
								keys.forEach((key) => {
									progress.incr();
									multi.del(key);
								});
								multi.exec(next);
							}, {
								batch: 1000,
							}, next);
						},
					], (err) => {
						next(err);
					});
				} else if (db.client && db.client.collection) {
					db.client.collection('sessions').deleteMany({}, {}, (err) => {
						next(err);
					});
				} else {
					next();
				}
			},
'use strict';

const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Clean flag byCid zsets',
	timestamp: Date.UTC(2019, 8, 24),
	method: async function () {
		const { progress } = this;

		await batch.processSortedSet('flags:datetime', async (flagIds) => {
			progress.incr(flagIds.length);
			const flagData = await db.getObjects(flagIds.map(id => `flag:${id}`));
			const bulkRemove = [];
			for (const flagObj of flagData) {
				if (flagObj && flagObj.type === 'user' && flagObj.targetId && flagObj.flagId) {
					bulkRemove.push([`flags:byCid:${flagObj.targetId}`, flagObj.flagId]);
				}
			}

			await db.sortedSetRemoveBulk(bulkRemove);
		}, {
			progress: progress,
		});
'use strict';

const db = require('../../database');
const batch = require('../../batch');
const user = require('../../user');

module.exports = {
	name: 'Clean up old notifications and hash data',
	timestamp: Date.UTC(2019, 9, 7),
	method: async function () {
		const { progress } = this;
		const week = 604800000;
		const cutoffTime = Date.now() - week;
		await batch.processSortedSet('users:joindate', async (uids) => {
			progress.incr(uids.length);
			await Promise.all([
				db.sortedSetsRemoveRangeByScore(uids.map(uid => `uid:${uid}:notifications:unread`), '-inf', cutoffTime),
				db.sortedSetsRemoveRangeByScore(uids.map(uid => `uid:${uid}:notifications:read`), '-inf', cutoffTime),
			]);
			const userData = await user.getUsersData(uids);
			await Promise.all(userData.map(async (user) => {
				if (!user) {
					return;
				}
				const fields = [];
				['picture', 'fullname', 'location', 'birthday', 'website', 'signature', 'uploadedpicture'].forEach((field) => {
					if (user[field] === '') {
						fields.push(field);
					}
				});
				['profileviews', 'reputation', 'postcount', 'topiccount', 'lastposttime', 'banned', 'followerCount', 'followingCount'].forEach((field) => {
					if (user[field] === 0) {
						fields.push(field);
					}
				});
				if (user['icon:text']) {
					fields.push('icon:text');
				}
				if (user['icon:bgColor']) {
					fields.push('icon:bgColor');
				}
				if (fields.length) {
					await db.deleteObjectFields(`user:${user.uid}`, fields);
				}
			}));
		}, {
			batch: 500,
			progress: progress,
		});
	},
'use strict';

const db = require('../../database');
const batch = require('../../batch');

module.exports = {
	name: 'Clean up post hash data',
	timestamp: Date.UTC(2019, 9, 7),
	method: async function () {
		const { progress } = this;
		await cleanPost(progress);
		await cleanTopic(progress);
	},
};

async function cleanPost(progress) {
	await batch.processSortedSet('posts:pid', async (pids) => {
		progress.incr(pids.length);

		const postData = await db.getObjects(pids.map(pid => `post:${pid}`));
		await Promise.all(postData.map(async (post) => {
			if (!post) {
				return;
			}
			const fieldsToDelete = [];
			if (post.hasOwnProperty('editor') && post.editor === '') {
				fieldsToDelete.push('editor');
			}
			if (post.hasOwnProperty('deleted') && parseInt(post.deleted, 10) === 0) {
				fieldsToDelete.push('deleted');
			}
			if (post.hasOwnProperty('edited') && parseInt(post.edited, 10) === 0) {
				fieldsToDelete.push('edited');
			}

			// cleanup legacy fields, these are not used anymore
			const legacyFields = [
				'show_banned', 'fav_star_class', 'relativeEditTime',
				'post_rep', 'relativeTime', 'fav_button_class',
				'edited-class',
			];
			legacyFields.forEach((field) => {
				if (post.hasOwnProperty(field)) {
					fieldsToDelete.push(field);
				}
			});

			if (fieldsToDelete.length) {
				await db.deleteObjectFields(`post:${post.pid}`, fieldsToDelete);
			}
		}));
	}, {
		batch: 500,
		progress: progress,
	});
}

async function cleanTopic(progress) {
	await batch.processSortedSet('topics:tid', async (tids) => {
		progress.incr(tids.length);
		const topicData = await db.getObjects(tids.map(tid => `topic:${tid}`));
		await Promise.all(topicData.map(async (topic) => {
			if (!topic) {
				return;
			}
			const fieldsToDelete = [];
			if (topic.hasOwnProperty('deleted') && parseInt(topic.deleted, 10) === 0) {
				fieldsToDelete.push('deleted');
			}
			if (topic.hasOwnProperty('pinned') && parseInt(topic.pinned, 10) === 0) {
				fieldsToDelete.push('pinned');
			}
			if (topic.hasOwnProperty('locked') && parseInt(topic.locked, 10) === 0) {
				fieldsToDelete.push('locked');
			}

			// cleanup legacy fields, these are not used anymore
			const legacyFields = [
				'category_name', 'category_slug',
			];
			legacyFields.forEach((field) => {
				if (topic.hasOwnProperty(field)) {
					fieldsToDelete.push(field);
				}
			});

			if (fieldsToDelete.length) {
				await db.deleteObjectFields(`topic:${topic.tid}`, fieldsToDelete);
			}
		}));
'use strict';

const db = require('../../database');
const meta = require('../../meta');

module.exports = {
	name: 'Generate customHTML block from old customJS setting',
	timestamp: Date.UTC(2017, 9, 12),
	method: function (callback) {
		db.getObjectField('config', 'customJS', (err, newHTML) => {
			if (err) {
				return callback(err);
			}

			let newJS = [];

			// Forgive me for parsing HTML with regex...
			const scriptMatch = /^<script\s?(?!async|deferred)?>([\s\S]+?)<\/script>/m;
			let match = scriptMatch.exec(newHTML);

			while (match) {
				if (match[1]) {
					// Append to newJS array
					newJS.push(match[1].trim());

					// Remove the match from the existing value
					newHTML = ((match.index > 0 ? newHTML.slice(0, match.index) : '') + newHTML.slice(match.index + match[0].length)).trim();
				}

				match = scriptMatch.exec(newHTML);
			}

			// Combine newJS array
			newJS = newJS.join('\n\n');

			// Write both values to config
			meta.configs.setMultiple({
				customHTML: newHTML,
				customJS: newJS,
			}, callback);
'use strict';

const async = require('async');

const db = require('../../database');

module.exports = {
	name: 'Change the schema of simple keys so they don\'t use value field (mongodb only)',
	timestamp: Date.UTC(2017, 11, 18),
	method: function (callback) {
		let configJSON;
		try {
			configJSON = require('../../../config.json') || { [process.env.database]: true, database: process.env.database };
		} catch (err) {
			configJSON = { [process.env.database]: true, database: process.env.database };
		}
		const isMongo = configJSON.hasOwnProperty('mongo') && configJSON.database === 'mongo';
		const { progress } = this;
		if (!isMongo) {
			return callback();
		}
		const { client } = db;
		let cursor;
		async.waterfall([
			function (next) {
				client.collection('objects').countDocuments({
					_key: { $exists: true },
					value: { $exists: true },
					score: { $exists: false },
				}, next);
			},
			function (count, next) {
				progress.total = count;
				cursor = client.collection('objects').find({
					_key: { $exists: true },
					value: { $exists: true },
					score: { $exists: false },
				}).batchSize(1000);

				let done = false;
				async.whilst(
					(next) => {
						next(null, !done);
					},
					(next) => {
						async.waterfall([
							function (next) {
								cursor.next(next);
							},
							function (item, next) {
								progress.incr();
								if (item === null) {
									done = true;
									return next();
								}
								delete item.expireAt;
								if (Object.keys(item).length === 3 && item.hasOwnProperty('_key') && item.hasOwnProperty('value')) {
									client.collection('objects').updateOne({ _key: item._key }, { $rename: { value: 'data' } }, next);
								} else {
									next();
								}
							},
						], (err) => {
							next(err);
						});
					},
					next
				);
			},
		], callback);
'use strict';

const async = require('async');
const batch = require('../../batch');
const db = require('../../database');

module.exports = {
	name: 'Add votes to topics',
	timestamp: Date.UTC(2017, 11, 8),
	method: function (callback) {
		const { progress } = this;

		batch.processSortedSet('topics:tid', (tids, next) => {
			async.eachLimit(tids, 500, (tid, _next) => {
				progress.incr();
				let topicData;
				async.waterfall([
					function (next) {
						db.getObjectFields(`topic:${tid}`, ['mainPid', 'cid', 'pinned'], next);
					},
					function (_topicData, next) {
						topicData = _topicData;
						if (!topicData.mainPid || !topicData.cid) {
							return _next();
						}
						db.getObject(`post:${topicData.mainPid}`, next);
					},
					function (postData, next) {
						if (!postData) {
							return _next();
						}
						const upvotes = parseInt(postData.upvotes, 10) || 0;
						const downvotes = parseInt(postData.downvotes, 10) || 0;
						const data = {
							upvotes: upvotes,
							downvotes: downvotes,
						};
						const votes = upvotes - downvotes;
						async.parallel([
							function (next) {
								db.setObject(`topic:${tid}`, data, next);
							},
							function (next) {
								db.sortedSetAdd('topics:votes', votes, tid, next);
							},
							function (next) {
								if (parseInt(topicData.pinned, 10) !== 1) {
									db.sortedSetAdd(`cid:${topicData.cid}:tids:votes`, votes, tid, next);
								} else {
									next();
								}
							},
						], (err) => {
							next(err);
						});
					},
				], _next);
			}, next);
		}, {
			progress: progress,
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Group title from settings to user profile',
	timestamp: Date.UTC(2016, 3, 14),
	method: function (callback) {
		const user = require('../../user');
		const batch = require('../../batch');
		let count = 0;
		batch.processSortedSet('users:joindate', (uids, next) => {
			winston.verbose(`upgraded ${count} users`);
			user.getMultipleUserSettings(uids, (err, settings) => {
				if (err) {
					return next(err);
				}
				count += uids.length;
				settings = settings.filter(setting => setting && setting.groupTitle);

				async.each(settings, (setting, next) => {
					db.setObjectField(`user:${setting.uid}`, 'groupTitle', setting.groupTitle, next);
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Users post count per tid',
	timestamp: Date.UTC(2016, 3, 19),
	method: function (callback) {
		const batch = require('../../batch');
		const topics = require('../../topics');
		let count = 0;
		batch.processSortedSet('topics:tid', (tids, next) => {
			winston.verbose(`upgraded ${count} topics`);
			count += tids.length;
			async.each(tids, (tid, next) => {
				db.delete(`tid:${tid}:posters`, (err) => {
					if (err) {
						return next(err);
					}
					topics.getPids(tid, (err, pids) => {
						if (err) {
							return next(err);
						}

						if (!pids.length) {
							return next();
						}

						async.eachSeries(pids, (pid, next) => {
							db.getObjectField(`post:${pid}`, 'uid', (err, uid) => {
								if (err) {
									return next(err);
								}
								if (!parseInt(uid, 10)) {
									return next();
								}
								db.sortedSetIncrBy(`tid:${tid}:posters`, 1, uid, next);
							});
						}, next);
					});
				});
			}, next);
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Giving topics:read privs to any group that was previously allowed to Find & Access Category',
	timestamp: Date.UTC(2016, 4, 28),
	method: function (callback) {
		const groupsAPI = require('../../groups');
		const privilegesAPI = require('../../privileges');

		db.getSortedSetRange('categories:cid', 0, -1, (err, cids) => {
			if (err) {
				return callback(err);
			}

			async.eachSeries(cids, (cid, next) => {
				privilegesAPI.categories.list(cid, (err, data) => {
					if (err) {
						return next(err);
					}

					const { groups } = data;
					const { users } = data;

					async.waterfall([
						function (next) {
							async.eachSeries(groups, (group, next) => {
								if (group.privileges['groups:read']) {
									return groupsAPI.join(`cid:${cid}:privileges:groups:topics:read`, group.name, (err) => {
										if (!err) {
											winston.verbose(`cid:${cid}:privileges:groups:topics:read granted to gid: ${group.name}`);
										}

										return next(err);
									});
								}

								next(null);
							}, next);
						},
						function (next) {
							async.eachSeries(users, (user, next) => {
								if (user.privileges.read) {
									return groupsAPI.join(`cid:${cid}:privileges:topics:read`, user.uid, (err) => {
										if (!err) {
											winston.verbose(`cid:${cid}:privileges:topics:read granted to uid: ${user.uid}`);
										}

										return next(err);
									});
								}

								next(null);
							}, next);
						},
					], (err) => {
						if (!err) {
							winston.verbose(`-- cid ${cid} upgraded`);
						}

						next(err);
					});
				});
			}, callback);
		});
	},
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Store upvotes/downvotes separately',
	timestamp: Date.UTC(2016, 5, 13),
	method: function (callback) {
		const batch = require('../../batch');
		const posts = require('../../posts');
		let count = 0;
		const { progress } = this;

		batch.processSortedSet('posts:pid', (pids, next) => {
			winston.verbose(`upgraded ${count} posts`);
			count += pids.length;
			async.each(pids, (pid, next) => {
				async.parallel({
					upvotes: function (next) {
						db.setCount(`pid:${pid}:upvote`, next);
					},
					downvotes: function (next) {
						db.setCount(`pid:${pid}:downvote`, next);
					},
				}, (err, results) => {
					if (err) {
						return next(err);
					}
					const data = {};

					if (parseInt(results.upvotes, 10) > 0) {
						data.upvotes = results.upvotes;
					}
					if (parseInt(results.downvotes, 10) > 0) {
						data.downvotes = results.downvotes;
					}

					if (Object.keys(data).length) {
						posts.setPostFields(pid, data, next);
					} else {
						next();
					}

					progress.incr();
				}, next);
			}, next);
		}, {
'use strict';


const async = require('async');
const winston = require('winston');
const db = require('../../database');

module.exports = {
	name: 'Dismiss flags from deleted topics',
	timestamp: Date.UTC(2016, 3, 29),
	method: function (callback) {
		const posts = require('../../posts');
		const topics = require('../../topics');

		let pids;
		let tids;

		async.waterfall([
			async.apply(db.getSortedSetRange, 'posts:flagged', 0, -1),
			function (_pids, next) {
				pids = _pids;
				posts.getPostsFields(pids, ['tid'], next);
			},
			function (_tids, next) {
				tids = _tids.map(a => a.tid);

				topics.getTopicsFields(tids, ['deleted'], next);
			},
			function (state, next) {
				const toDismiss = state.map((a, idx) => (parseInt(a.deleted, 10) === 1 ? pids[idx] : null)).filter(Boolean);

				winston.verbose(`[2016/04/29] ${toDismiss.length} dismissable flags found`);
				async.each(toDismiss, dismissFlag, next);
			},
		], callback);
	},
};

// copied from core since this function was removed
// https://github.com/NodeBB/NodeBB/blob/v1.x.x/src/posts/flags.js
function dismissFlag(pid, callback) {
	async.waterfall([
		function (next) {
			db.getObjectFields(`post:${pid}`, ['pid', 'uid', 'flags'], next);
		},
		function (postData, next) {
			if (!postData.pid) {
				return callback();
			}
			async.parallel([
				function (next) {
					if (parseInt(postData.uid, 10)) {
						if (parseInt(postData.flags, 10) > 0) {
							async.parallel([
								async.apply(db.sortedSetIncrBy, 'users:flags', -postData.flags, postData.uid),
								async.apply(db.incrObjectFieldBy, `user:${postData.uid}`, 'flags', -postData.flags),
							], next);
						} else {
							next();
						}
					} else {
						next();
					}
				},
				function (next) {
					db.sortedSetsRemove([
						'posts:flagged',
						'posts:flags:count',
						`uid:${postData.uid}:flag:pids`,
					], pid, next);
				},
				function (next) {
					async.series([
						function (next) {
							db.getSortedSetRange(`pid:${pid}:flag:uids`, 0, -1, (err, uids) => {
								if (err) {
									return next(err);
								}

								async.each(uids, (uid, next) => {
									const nid = `post_flag:${pid}:uid:${uid}`;
									async.parallel([
										async.apply(db.delete, `notifications:${nid}`),
										async.apply(db.sortedSetRemove, 'notifications', `post_flag:${pid}:uid:${uid}`),
									], next);
								}, next);
							});
						},
						async.apply(db.delete, `pid:${pid}:flag:uids`),
					], next);
				},
				async.apply(db.deleteObjectField, `post:${pid}`, 'flags'),
				async.apply(db.delete, `pid:${pid}:flag:uid:reason`),
				async.apply(db.deleteObjectFields, `post:${pid}`, ['flag:state', 'flag:assignee', 'flag:notes', 'flag:history']),
			], next);
		},
		function (results, next) {
			db.sortedSetsRemoveRangeByScore(['users:flags'], '-inf', 0, next);
		},
	], callback);

'use strict';

const _ = require('lodash');

const db = require('../database');
const posts = require('../posts');
const topics = require('../topics');
const privileges = require('../privileges');
const plugins = require('../plugins');
const batch = require('../batch');

module.exports = function (Categories) {
	Categories.getRecentReplies = async function (cid, uid, count) {
		if (!parseInt(count, 10)) {
			return [];
		}
		let pids = await db.getSortedSetRevRange(`cid:${cid}:pids`, 0, count - 1);
		pids = await privileges.posts.filter('topics:read', pids, uid);
		return await posts.getPostSummaryByPids(pids, uid, { stripTags: true });
	};

	Categories.updateRecentTid = async function (cid, tid) {
		const [count, numRecentReplies] = await Promise.all([
			db.sortedSetCard(`cid:${cid}:recent_tids`),
			db.getObjectField(`category:${cid}`, 'numRecentReplies'),
		]);

		if (count >= numRecentReplies) {
			const data = await db.getSortedSetRangeWithScores(`cid:${cid}:recent_tids`, 0, count - numRecentReplies);
			const shouldRemove = !(data.length === 1 && count === 1 && data[0].value === String(tid));
			if (data.length && shouldRemove) {
				await db.sortedSetsRemoveRangeByScore([`cid:${cid}:recent_tids`], '-inf', data[data.length - 1].score);
			}
		}
		if (numRecentReplies > 0) {
			await db.sortedSetAdd(`cid:${cid}:recent_tids`, Date.now(), tid);
		}
		await plugins.hooks.fire('action:categories.updateRecentTid', { cid: cid, tid: tid });
	};

	Categories.updateRecentTidForCid = async function (cid) {
		let postData;
		let topicData;
		let index = 0;
		do {
			/* eslint-disable no-await-in-loop */
			const pids = await db.getSortedSetRevRange(`cid:${cid}:pids`, index, index);
			if (!pids.length) {
				return;
			}
			postData = await posts.getPostFields(pids[0], ['tid', 'deleted']);

			if (postData && postData.tid && !postData.deleted) {
				topicData = await topics.getTopicData(postData.tid);
			}
			index += 1;
		} while (!topicData || topicData.deleted);

		if (postData && postData.tid) {
			await Categories.updateRecentTid(cid, postData.tid);
		}
	};

	Categories.getRecentTopicReplies = async function (categoryData, uid, query) {
		if (!Array.isArray(categoryData) || !categoryData.length) {
			return;
		}
		const categoriesToLoad = categoryData.filter(c => c && c.numRecentReplies && parseInt(c.numRecentReplies, 10) > 0);
		let keys = [];
		if (plugins.hooks.hasListeners('filter:categories.getRecentTopicReplies')) {
			const result = await plugins.hooks.fire('filter:categories.getRecentTopicReplies', {
				categories: categoriesToLoad,
				uid: uid,
				query: query,
				keys: [],
			});
			keys = result.keys;
		} else {
			keys = categoriesToLoad.map(c => `cid:${c.cid}:recent_tids`);
		}

		const results = await db.getSortedSetsMembers(keys);
		let tids = _.uniq(_.flatten(results).filter(Boolean));

		tids = await privileges.topics.filterTids('topics:read', tids, uid);
		const topics = await getTopics(tids, uid);
		assignTopicsToCategories(categoryData, topics);

		bubbleUpChildrenPosts(categoryData);
	};

	async function getTopics(tids, uid) {
		const topicData = await topics.getTopicsFields(
			tids,
			['tid', 'mainPid', 'slug', 'title', 'teaserPid', 'cid', 'postcount']
		);
		topicData.forEach((topic) => {
			if (topic) {
				topic.teaserPid = topic.teaserPid || topic.mainPid;
			}
		});
		const cids = _.uniq(topicData.map(t => t && t.cid).filter(cid => parseInt(cid, 10)));
		const getToRoot = async () => await Promise.all(cids.map(Categories.getParentCids));
		const [toRoot, teasers] = await Promise.all([
			getToRoot(),
			topics.getTeasers(topicData, uid),
		]);
		const cidToRoot = _.zipObject(cids, toRoot);

		teasers.forEach((teaser, index) => {
			if (teaser) {
				teaser.cid = topicData[index].cid;
				teaser.parentCids = cidToRoot[teaser.cid];
				teaser.tid = undefined;
				teaser.uid = undefined;
				teaser.topic = {
					slug: topicData[index].slug,
					title: topicData[index].title,
				};
			}
		});
		return teasers.filter(Boolean);
	}

	function assignTopicsToCategories(categories, topics) {
		categories.forEach((category) => {
			if (category) {
				category.posts = topics.filter(t => t.cid && (t.cid === category.cid || t.parentCids.includes(category.cid)))
					.sort((a, b) => b.pid - a.pid)
					.slice(0, parseInt(category.numRecentReplies, 10));
			}
		});
		topics.forEach((t) => { t.parentCids = undefined; });
	}

	function bubbleUpChildrenPosts(categoryData) {
		categoryData.forEach((category) => {
			if (category) {
				if (category.posts.length) {
					return;
				}
				const posts = [];
				getPostsRecursive(category, posts);

				posts.sort((a, b) => b.pid - a.pid);
				if (posts.length) {
					category.posts = [posts[0]];
				}
			}
		});
	}

	function getPostsRecursive(category, posts) {
		if (Array.isArray(category.posts)) {
			category.posts.forEach(p =>	posts.push(p));
		}

		category.children.forEach(child => getPostsRecursive(child, posts));
	}

	// terrible name, should be topics.moveTopicPosts
	Categories.moveRecentReplies = async function (tid, oldCid, cid) {
		await updatePostCount(tid, oldCid, cid);
		const [pids, topicDeleted] = await Promise.all([
			topics.getPids(tid),
			topics.getTopicField(tid, 'deleted'),
		]);

		await batch.processArray(pids, async (pids) => {
			const postData = await posts.getPostsFields(pids, ['pid', 'deleted', 'uid', 'timestamp', 'upvotes', 'downvotes']);

			const bulkRemove = [];
			const bulkAdd = [];
			postData.forEach((post) => {
				bulkRemove.push([`cid:${oldCid}:uid:${post.uid}:pids`, post.pid]);
				bulkRemove.push([`cid:${oldCid}:uid:${post.uid}:pids:votes`, post.pid]);
				bulkAdd.push([`cid:${cid}:uid:${post.uid}:pids`, post.timestamp, post.pid]);
				if (post.votes > 0) {
					bulkAdd.push([`cid:${cid}:uid:${post.uid}:pids:votes`, post.votes, post.pid]);
				}
			});

			const postsToReAdd = postData.filter(p => !p.deleted && !topicDeleted);
			const timestamps = postsToReAdd.map(p => p && p.timestamp);
			await Promise.all([
				db.sortedSetRemove(`cid:${oldCid}:pids`, pids),
				db.sortedSetAdd(`cid:${cid}:pids`, timestamps, postsToReAdd.map(p => p.pid)),
				db.sortedSetRemoveBulk(bulkRemove),
				db.sortedSetAddBulk(bulkAdd),
			]);
		}, { batch: 500 });
	};

	async function updatePostCount(tid, oldCid, newCid) {
		const postCount = await topics.getTopicField(tid, 'postcount');
		if (!postCount) {
			return;
		}

		await Promise.all([
			db.incrObjectFieldBy(`category:${oldCid}`, 'post_count', -postCount),
			db.incrObjectFieldBy(`category:${newCid}`, 'post_count', postCount),
		]);
	}
'use strict';

const db = require('../database');
const user = require('../user');

module.exports = function (Categories) {
	Categories.watchStates = {
		ignoring: 1,
		notwatching: 2,
		watching: 3,
	};

	Categories.isIgnored = async function (cids, uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return cids.map(() => false);
		}
		const states = await Categories.getWatchState(cids, uid);
		return states.map(state => state === Categories.watchStates.ignoring);
	};

	Categories.getWatchState = async function (cids, uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return cids.map(() => Categories.watchStates.notwatching);
		}
		if (!Array.isArray(cids) || !cids.length) {
			return [];
		}
		const keys = cids.map(cid => `cid:${cid}:uid:watch:state`);
		const [userSettings, states] = await Promise.all([
			user.getSettings(uid),
			db.sortedSetsScore(keys, uid),
		]);
		return states.map(state => state || Categories.watchStates[userSettings.categoryWatchState]);
	};

	Categories.getIgnorers = async function (cid, start, stop) {
		const count = (stop === -1) ? -1 : (stop - start + 1);
		return await db.getSortedSetRevRangeByScore(`cid:${cid}:uid:watch:state`, start, count, Categories.watchStates.ignoring, Categories.watchStates.ignoring);
	};

	Categories.filterIgnoringUids = async function (cid, uids) {
		const states = await Categories.getUidsWatchStates(cid, uids);
		const readingUids = uids.filter((uid, index) => uid && states[index] !== Categories.watchStates.ignoring);
		return readingUids;
	};

	Categories.getUidsWatchStates = async function (cid, uids) {
		const [userSettings, states] = await Promise.all([
			user.getMultipleUserSettings(uids),
			db.sortedSetScores(`cid:${cid}:uid:watch:state`, uids),
'use strict';

const async = require('async');
const _ = require('lodash');

const db = require('../database');
const plugins = require('../plugins');
const privileges = require('../privileges');
const utils = require('../utils');
const slugify = require('../slugify');
const cache = require('../cache');

module.exports = function (Categories) {
	Categories.create = async function (data) {
		const parentCid = data.parentCid ? data.parentCid : 0;
		const [cid, firstChild] = await Promise.all([
			db.incrObjectField('global', 'nextCid'),
			db.getSortedSetRangeWithScores(`cid:${parentCid}:children`, 0, 0),
		]);

		data.name = String(data.name || `Category ${cid}`);
		const slug = `${cid}/${slugify(data.name)}`;
		const smallestOrder = firstChild.length ? firstChild[0].score - 1 : 1;
		const order = data.order || smallestOrder;	// If no order provided, place it at the top
		const colours = Categories.assignColours();

		let category = {
			cid: cid,
			name: data.name,
			description: data.description ? data.description : '',
			descriptionParsed: data.descriptionParsed ? data.descriptionParsed : '',
			icon: data.icon ? data.icon : '',
			bgColor: data.bgColor || colours[0],
			color: data.color || colours[1],
			slug: slug,
			parentCid: parentCid,
			topic_count: 0,
			post_count: 0,
			disabled: data.disabled ? 1 : 0,
			order: order,
			link: data.link || '',
			numRecentReplies: 1,
			class: (data.class ? data.class : 'col-md-3 col-xs-6'),
			imageClass: 'cover',
			isSection: 0,
			subCategoriesPerPage: 10,
		};

		if (data.backgroundImage) {
			category.backgroundImage = data.backgroundImage;
		}

		const result = await plugins.hooks.fire('filter:category.create', { category: category, data: data });
		category = result.category;


		await db.setObject(`category:${category.cid}`, category);
		if (!category.descriptionParsed) {
			await Categories.parseDescription(category.cid, category.description);
		}

		await db.sortedSetAddBulk([
			['categories:cid', category.order, category.cid],
			[`cid:${parentCid}:children`, category.order, category.cid],
			['categories:name', 0, `${data.name.substr(0, 200).toLowerCase()}:${category.cid}`],
		]);

		const defaultPrivileges = [
			'groups:find',
			'groups:read',
			'groups:topics:read',
			'groups:topics:create',
			'groups:topics:reply',
			'groups:topics:tag',
			'groups:posts:edit',
			'groups:posts:history',
			'groups:posts:delete',
			'groups:posts:upvote',
			'groups:posts:downvote',
			'groups:topics:delete',
		];
		const modPrivileges = defaultPrivileges.concat([
			'groups:posts:view_deleted',
			'groups:purge',
		]);
		await privileges.categories.give(defaultPrivileges, category.cid, 'registered-users');
		await privileges.categories.give(modPrivileges, category.cid, ['administrators', 'Global Moderators']);
		await privileges.categories.give(['groups:find', 'groups:read', 'groups:topics:read'], category.cid, ['guests', 'spiders']);

		cache.del([
			'categories:cid',
			`cid:${parentCid}:children`,
			`cid:${parentCid}:children:all`,
		]);
		if (data.cloneFromCid && parseInt(data.cloneFromCid, 10)) {
			category = await Categories.copySettingsFrom(data.cloneFromCid, category.cid, !data.parentCid);
		}

		if (data.cloneChildren) {
			await duplicateCategoriesChildren(category.cid, data.cloneFromCid, data.uid);
		}

		plugins.hooks.fire('action:category.create', { category: category });
		return category;
	};

	async function duplicateCategoriesChildren(parentCid, cid, uid) {
		let children = await Categories.getChildren([cid], uid);
		if (!children.length) {
			return;
		}

		children = children[0];

		children.forEach((child) => {
			child.parentCid = parentCid;
			child.cloneFromCid = child.cid;
			child.cloneChildren = true;
			child.name = utils.decodeHTMLEntities(child.name);
			child.description = utils.decodeHTMLEntities(child.description);
			child.uid = uid;
		});

		await async.each(children, Categories.create);
	}

	Categories.assignColours = function () {
		const backgrounds = ['#AB4642', '#DC9656', '#F7CA88', '#A1B56C', '#86C1B9', '#7CAFC2', '#BA8BAF', '#A16946'];
		const text = ['#ffffff', '#ffffff', '#333333', '#ffffff', '#333333', '#ffffff', '#ffffff', '#ffffff'];
		const index = Math.floor(Math.random() * backgrounds.length);
		return [backgrounds[index], text[index]];
	};

	Categories.copySettingsFrom = async function (fromCid, toCid, copyParent) {
		const [source, destination] = await Promise.all([
			db.getObject(`category:${fromCid}`),
			db.getObject(`category:${toCid}`),
		]);
		if (!source) {
			throw new Error('[[error:invalid-cid]]');
		}

		const oldParent = parseInt(destination.parentCid, 10) || 0;
		const newParent = parseInt(source.parentCid, 10) || 0;
		if (copyParent && newParent !== parseInt(toCid, 10)) {
			await db.sortedSetRemove(`cid:${oldParent}:children`, toCid);
			await db.sortedSetAdd(`cid:${newParent}:children`, source.order, toCid);
			cache.del([
				`cid:${oldParent}:children`,
				`cid:${oldParent}:children:all`,
				`cid:${newParent}:children`,
				`cid:${newParent}:children:all`,
			]);
		}

		destination.description = source.description;
		destination.descriptionParsed = source.descriptionParsed;
		destination.icon = source.icon;
		destination.bgColor = source.bgColor;
		destination.color = source.color;
		destination.link = source.link;
		destination.numRecentReplies = source.numRecentReplies;
		destination.class = source.class;
		destination.image = source.image;
		destination.imageClass = source.imageClass;
		destination.minTags = source.minTags;
		destination.maxTags = source.maxTags;

		if (copyParent) {
			destination.parentCid = source.parentCid || 0;
		}

		await db.setObject(`category:${toCid}`, destination);

		await copyTagWhitelist(fromCid, toCid);

		await Categories.copyPrivilegesFrom(fromCid, toCid);

		return destination;
	};

	async function copyTagWhitelist(fromCid, toCid) {
		const data = await db.getSortedSetRangeWithScores(`cid:${fromCid}:tag:whitelist`, 0, -1);
		await db.delete(`cid:${toCid}:tag:whitelist`);
		await db.sortedSetAdd(`cid:${toCid}:tag:whitelist`, data.map(item => item.score), data.map(item => item.value));
		cache.del(`cid:${toCid}:tag:whitelist`);
	}

	Categories.copyPrivilegesFrom = async function (fromCid, toCid, group) {
		group = group || '';

		const data = await plugins.hooks.fire('filter:categories.copyPrivilegesFrom', {
			privileges: group ?
				privileges.categories.groupPrivilegeList.slice() :
				privileges.categories.privilegeList.slice(),
			fromCid: fromCid,
			toCid: toCid,
			group: group,
		});
		if (group) {
			await copyPrivilegesByGroup(data.privileges, data.fromCid, data.toCid, group);
		} else {
			await copyPrivileges(data.privileges, data.fromCid, data.toCid);
		}
	};

	async function copyPrivileges(privileges, fromCid, toCid) {
		const toGroups = privileges.map(privilege => `group:cid:${toCid}:privileges:${privilege}:members`);
		const fromGroups = privileges.map(privilege => `group:cid:${fromCid}:privileges:${privilege}:members`);

		const currentMembers = await db.getSortedSetsMembers(toGroups.concat(fromGroups));
		const copyGroups = _.uniq(_.flatten(currentMembers));
		await async.each(copyGroups, async (group) => {
			await copyPrivilegesByGroup(privileges, fromCid, toCid, group);
		});
	}

	async function copyPrivilegesByGroup(privilegeList, fromCid, toCid, group) {
		const fromGroups = privilegeList.map(privilege => `group:cid:${fromCid}:privileges:${privilege}:members`);
		const toGroups = privilegeList.map(privilege => `group:cid:${toCid}:privileges:${privilege}:members`);
		const [fromChecks, toChecks] = await Promise.all([
			db.isMemberOfSortedSets(fromGroups, group),
			db.isMemberOfSortedSets(toGroups, group),
		]);
		const givePrivs = privilegeList.filter((priv, index) => fromChecks[index] && !toChecks[index]);
'use strict';

const validator = require('validator');

const db = require('../database');
const meta = require('../meta');
const plugins = require('../plugins');
const utils = require('../utils');

const intFields = [
	'cid', 'parentCid', 'disabled', 'isSection', 'order',
	'topic_count', 'post_count', 'numRecentReplies',
	'minTags', 'maxTags', 'postQueue', 'subCategoriesPerPage',
];

module.exports = function (Categories) {
	Categories.getCategoriesFields = async function (cids, fields) {
		if (!Array.isArray(cids) || !cids.length) {
			return [];
		}

		const keys = cids.map(cid => `category:${cid}`);
		const categories = await (fields.length ? db.getObjectsFields(keys, fields) : db.getObjects(keys));
		const result = await plugins.hooks.fire('filter:category.getFields', {
			cids: cids,
			categories: categories,
			fields: fields,
			keys: keys,
		});
		result.categories.forEach(category => modifyCategory(category, fields));
		return result.categories;
	};

	Categories.getCategoryData = async function (cid) {
		const categories = await Categories.getCategoriesFields([cid], []);
		return categories && categories.length ? categories[0] : null;
	};

	Categories.getCategoriesData = async function (cids) {
		return await Categories.getCategoriesFields(cids, []);
	};

	Categories.getCategoryField = async function (cid, field) {
		const category = await Categories.getCategoryFields(cid, [field]);
		return category ? category[field] : null;
	};

	Categories.getCategoryFields = async function (cid, fields) {
		const categories = await Categories.getCategoriesFields([cid], fields);
		return categories ? categories[0] : null;
	};

	Categories.getAllCategoryFields = async function (fields) {
		const cids = await Categories.getAllCidsFromSet('categories:cid');
		return await Categories.getCategoriesFields(cids, fields);
	};

	Categories.setCategoryField = async function (cid, field, value) {
		await db.setObjectField(`category:${cid}`, field, value);
	};

	Categories.incrementCategoryFieldBy = async function (cid, field, value) {
		await db.incrObjectFieldBy(`category:${cid}`, field, value);
	};
};

function defaultIntField(category, fields, fieldName, defaultField) {
	if (!fields.length || fields.includes(fieldName)) {
		const useDefault = !category.hasOwnProperty(fieldName) ||
			category[fieldName] === null ||
			category[fieldName] === '' ||
			!utils.isNumber(category[fieldName]);

		category[fieldName] = useDefault ? meta.config[defaultField] : category[fieldName];
	}
}

function modifyCategory(category, fields) {
	if (!category) {
		return;
	}

	defaultIntField(category, fields, 'minTags', 'minimumTagsPerTopic');
	defaultIntField(category, fields, 'maxTags', 'maximumTagsPerTopic');
	defaultIntField(category, fields, 'postQueue', 'postQueue');

	db.parseIntFields(category, intFields, fields);

	const escapeFields = ['name', 'color', 'bgColor', 'imageClass', 'class', 'link'];
	escapeFields.forEach((field) => {
		if (category.hasOwnProperty(field)) {
			category[field] = validator.escape(String(category[field] || ''));
		}
	});

	if (category.hasOwnProperty('icon')) {
		category.icon = category.icon || 'hidden';
	}

	if (category.hasOwnProperty('post_count')) {
		category.totalPostCount = category.post_count;
	}

	if (category.hasOwnProperty('topic_count')) {
		category.totalTopicCount = category.topic_count;
	}

	if (category.description) {
		category.description = validator.escape(String(category.description));
		category.descriptionParsed = category.descriptionParsed || category.description;
'use strict';

const async = require('async');
const db = require('../database');
const batch = require('../batch');
const plugins = require('../plugins');
const topics = require('../topics');
const groups = require('../groups');
const privileges = require('../privileges');
const cache = require('../cache');

module.exports = function (Categories) {
	Categories.purge = async function (cid, uid) {
		await batch.processSortedSet(`cid:${cid}:tids`, async (tids) => {
			await async.eachLimit(tids, 10, async (tid) => {
				await topics.purgePostsAndTopic(tid, uid);
			});
		}, { alwaysStartAt: 0 });

		const pinnedTids = await db.getSortedSetRevRange(`cid:${cid}:tids:pinned`, 0, -1);
		await async.eachLimit(pinnedTids, 10, async (tid) => {
			await topics.purgePostsAndTopic(tid, uid);
		});
		const categoryData = await Categories.getCategoryData(cid);
		await purgeCategory(categoryData);
		plugins.hooks.fire('action:category.delete', { cid: cid, uid: uid, category: categoryData });
	};

	async function purgeCategory(categoryData) {
		const { cid } = categoryData;
		await db.sortedSetRemoveBulk([
			['categories:cid', cid],
			['categories:name', `${categoryData.name.substr(0, 200).toLowerCase()}:${cid}`],
		]);
		await removeFromParent(cid);
		await deleteTags(cid);
		await db.deleteAll([
			`cid:${cid}:tids`,
			`cid:${cid}:tids:pinned`,
			`cid:${cid}:tids:posts`,
			`cid:${cid}:tids:votes`,
			`cid:${cid}:tids:lastposttime`,
			`cid:${cid}:recent_tids`,
			`cid:${cid}:pids`,
			`cid:${cid}:read_by_uid`,
			`cid:${cid}:uid:watch:state`,
			`cid:${cid}:children`,
			`cid:${cid}:tag:whitelist`,
			`category:${cid}`,
		]);
		await groups.destroy(privileges.categories.privilegeList.map(privilege => `cid:${cid}:privileges:${privilege}`));
	}

	async function removeFromParent(cid) {
		const [parentCid, children] = await Promise.all([
			Categories.getCategoryField(cid, 'parentCid'),
			db.getSortedSetRange(`cid:${cid}:children`, 0, -1),
		]);

		const bulkAdd = [];
		const childrenKeys = children.map((cid) => {
			bulkAdd.push(['cid:0:children', cid, cid]);
			return `category:${cid}`;
		});

		await Promise.all([
			db.sortedSetRemove(`cid:${parentCid}:children`, cid),
			db.setObjectField(childrenKeys, 'parentCid', 0),
			db.sortedSetAddBulk(bulkAdd),
		]);

		cache.del([
			'categories:cid',
			'cid:0:children',
			`cid:${parentCid}:children`,
			`cid:${parentCid}:children:all`,
			`cid:${cid}:children`,
			`cid:${cid}:children:all`,
			`cid:${cid}:tag:whitelist`,
		]);
	}

	async function deleteTags(cid) {
		const tags = await db.getSortedSetMembers(`cid:${cid}:tags`);
		await db.deleteAll(tags.map(tag => `cid:${cid}:tag:${tag}:topics`));
'use strict';

const db = require('../database');

module.exports = function (Categories) {
	Categories.markAsRead = async function (cids, uid) {
		if (!Array.isArray(cids) || !cids.length || parseInt(uid, 10) <= 0) {
			return;
		}
		let keys = cids.map(cid => `cid:${cid}:read_by_uid`);
		const hasRead = await db.isMemberOfSets(keys, uid);
		keys = keys.filter((key, index) => !hasRead[index]);
		await db.setsAdd(keys, uid);
	};

	Categories.markAsUnreadForAll = async function (cid) {
		if (!parseInt(cid, 10)) {
			return;
		}
		await db.delete(`cid:${cid}:read_by_uid`);
	};

	Categories.hasReadCategories = async function (cids, uid) {
		if (parseInt(uid, 10) <= 0) {
			return cids.map(() => false);
		}

		const sets = cids.map(cid => `cid:${cid}:read_by_uid`);
		return await db.isMemberOfSets(sets, uid);
	};

	Categories.hasReadCategory = async function (cid, uid) {
		if (parseInt(uid, 10) <= 0) {
			return false;
		}
'use strict';

const db = require('../database');
const topics = require('../topics');
const plugins = require('../plugins');
const meta = require('../meta');
const user = require('../user');

module.exports = function (Categories) {
	Categories.getCategoryTopics = async function (data) {
		let results = await plugins.hooks.fire('filter:category.topics.prepare', data);
		const tids = await Categories.getTopicIds(results);
		let topicsData = await topics.getTopicsByTids(tids, data.uid);
		topicsData = await user.blocks.filter(data.uid, topicsData);

		if (!topicsData.length) {
			return { topics: [], uid: data.uid };
		}
		topics.calculateTopicIndices(topicsData, data.start);

		results = await plugins.hooks.fire('filter:category.topics.get', { cid: data.cid, topics: topicsData, uid: data.uid });
		return { topics: results.topics, nextStart: data.stop + 1 };
	};

	Categories.getTopicIds = async function (data) {
		const dataForPinned = { ...data };
		dataForPinned.start = 0;
		dataForPinned.stop = -1;

		const [pinnedTids, set, direction] = await Promise.all([
			Categories.getPinnedTids(dataForPinned),
			Categories.buildTopicsSortedSet(data),
			Categories.getSortedSetRangeDirection(data.sort),
		]);

		const totalPinnedCount = pinnedTids.length;
		const pinnedTidsOnPage = pinnedTids.slice(data.start, data.stop !== -1 ? data.stop + 1 : undefined);
		const pinnedCountOnPage = pinnedTidsOnPage.length;
		const topicsPerPage = data.stop - data.start + 1;
		const normalTidsToGet = Math.max(0, topicsPerPage - pinnedCountOnPage);

		if (!normalTidsToGet && data.stop !== -1) {
			return pinnedTidsOnPage;
		}

		if (plugins.hooks.hasListeners('filter:categories.getTopicIds')) {
			const result = await plugins.hooks.fire('filter:categories.getTopicIds', {
				tids: [],
				data: data,
				pinnedTids: pinnedTidsOnPage,
				allPinnedTids: pinnedTids,
				totalPinnedCount: totalPinnedCount,
				normalTidsToGet: normalTidsToGet,
			});
			return result && result.tids;
		}

		let { start } = data;
		if (start > 0 && totalPinnedCount) {
			start -= totalPinnedCount - pinnedCountOnPage;
		}

		const stop = data.stop === -1 ? data.stop : start + normalTidsToGet - 1;
		let normalTids;
		const reverse = direction === 'highest-to-lowest';
		if (Array.isArray(set)) {
			const weights = set.map((s, index) => (index ? 0 : 1));
			normalTids = await db[reverse ? 'getSortedSetRevIntersect' : 'getSortedSetIntersect']({ sets: set, start: start, stop: stop, weights: weights });
		} else {
			normalTids = await db[reverse ? 'getSortedSetRevRange' : 'getSortedSetRange'](set, start, stop);
		}
		normalTids = normalTids.filter(tid => !pinnedTids.includes(tid));
		return pinnedTidsOnPage.concat(normalTids);
	};

	Categories.getTopicCount = async function (data) {
		if (plugins.hooks.hasListeners('filter:categories.getTopicCount')) {
			const result = await plugins.hooks.fire('filter:categories.getTopicCount', {
				topicCount: data.category.topic_count,
				data: data,
			});
			return result && result.topicCount;
		}
		const set = await Categories.buildTopicsSortedSet(data);
		if (Array.isArray(set)) {
			return await db.sortedSetIntersectCard(set);
		} else if (data.targetUid && set) {
			return await db.sortedSetCard(set);
		}
		return data.category.topic_count;
	};

	Categories.buildTopicsSortedSet = async function (data) {
		const { cid } = data;
		let set = `cid:${cid}:tids`;
		const sort = data.sort || (data.settings && data.settings.categoryTopicSort) || meta.config.categoryTopicSort || 'newest_to_oldest';

		if (sort === 'most_posts') {
			set = `cid:${cid}:tids:posts`;
		} else if (sort === 'most_votes') {
			set = `cid:${cid}:tids:votes`;
		}

		if (data.targetUid) {
			set = `cid:${cid}:uid:${data.targetUid}:tids`;
		}

		if (data.tag) {
			if (Array.isArray(data.tag)) {
				set = [set].concat(data.tag.map(tag => `tag:${tag}:topics`));
			} else {
				set = [set, `tag:${data.tag}:topics`];
			}
		}
		const result = await plugins.hooks.fire('filter:categories.buildTopicsSortedSet', {
			set: set,
			data: data,
		});
		return result && result.set;
	};

	Categories.getSortedSetRangeDirection = async function (sort) {
		sort = sort || 'newest_to_oldest';
		const direction = sort === 'newest_to_oldest' || sort === 'most_posts' || sort === 'most_votes' ? 'highest-to-lowest' : 'lowest-to-highest';
		const result = await plugins.hooks.fire('filter:categories.getSortedSetRangeDirection', {
			sort: sort,
			direction: direction,
		});
		return result && result.direction;
	};

	Categories.getAllTopicIds = async function (cid, start, stop) {
		return await db.getSortedSetRange([`cid:${cid}:tids:pinned`, `cid:${cid}:tids`], start, stop);
	};

	Categories.getPinnedTids = async function (data) {
		if (plugins.hooks.hasListeners('filter:categories.getPinnedTids')) {
			const result = await plugins.hooks.fire('filter:categories.getPinnedTids', {
				pinnedTids: [],
				data: data,
			});
			return result && result.pinnedTids;
		}
		const pinnedTids = await db.getSortedSetRevRange(`cid:${data.cid}:tids:pinned`, data.start, data.stop);
		return await topics.tools.checkPinExpiry(pinnedTids);
	};

	Categories.modifyTopicsByPrivilege = function (topics, privileges) {
		if (!Array.isArray(topics) || !topics.length || privileges.isAdminOrMod) {
			return;
		}

		topics.forEach((topic) => {
			if (topic.deleted && !topic.isOwner) {
				topic.title = '[[topic:topic_is_deleted]]';
				topic.slug = topic.tid;
				topic.teaser = null;
				topic.noAnchor = true;
				topic.tags = [];
			}
		});
	};

	Categories.onNewPostMade = async function (cid, pinned, postData) {
		if (!cid || !postData) {
			return;
		}
		const promises = [
			db.sortedSetAdd(`cid:${cid}:pids`, postData.timestamp, postData.pid),
			db.incrObjectField(`category:${cid}`, 'post_count'),
		];
		if (!pinned) {
			promises.push(db.sortedSetIncrBy(`cid:${cid}:tids:posts`, 1, postData.tid));
		}
		await Promise.all(promises);
'use strict';

const _ = require('lodash');

const posts = require('../posts');
const db = require('../database');

module.exports = function (Categories) {
	Categories.getActiveUsers = async function (cids) {
		if (!Array.isArray(cids)) {
			cids = [cids];
		}
		const pids = await db.getSortedSetRevRange(cids.map(cid => `cid:${cid}:pids`), 0, 24);
		const postData = await posts.getPostsFields(pids, ['uid']);
		return _.uniq(postData.map(post => post.uid).filter(uid => uid));
'use strict';

const _ = require('lodash');

const privileges = require('../privileges');
const plugins = require('../plugins');
const db = require('../database');

module.exports = function (Categories) {
	Categories.search = async function (data) {
		const query = data.query || '';
		const page = data.page || 1;
		const uid = data.uid || 0;
		const paginate = data.hasOwnProperty('paginate') ? data.paginate : true;

		const startTime = process.hrtime();

		let cids = await findCids(query, data.hardCap);

		const result = await plugins.hooks.fire('filter:categories.search', {
			cids: cids,
			uid: uid,
		});
		cids = await privileges.categories.filterCids('find', result.cids, uid);

		const searchResult = {
			matchCount: cids.length,
		};

		if (paginate) {
			const resultsPerPage = data.resultsPerPage || 50;
			const start = Math.max(0, page - 1) * resultsPerPage;
			const stop = start + resultsPerPage;
			searchResult.pageCount = Math.ceil(cids.length / resultsPerPage);
			cids = cids.slice(start, stop);
		}

		const childrenCids = await getChildrenCids(cids, uid);
		const uniqCids = _.uniq(cids.concat(childrenCids));
		const categoryData = await Categories.getCategories(uniqCids, uid);

		Categories.getTree(categoryData, 0);
		await Categories.getRecentTopicReplies(categoryData, uid, data.qs);
		categoryData.forEach((category) => {
			if (category && Array.isArray(category.children)) {
				category.children = category.children.slice(0, category.subCategoriesPerPage);
				category.children.forEach((child) => {
					child.children = undefined;
				});
			}
		});

		categoryData.sort((c1, c2) => {
			if (c1.parentCid !== c2.parentCid) {
				return c1.parentCid - c2.parentCid;
			}
			return c1.order - c2.order;
		});
		searchResult.timing = (process.elapsedTimeSince(startTime) / 1000).toFixed(2);
		searchResult.categories = categoryData.filter(c => cids.includes(c.cid));
		return searchResult;
	};

	async function findCids(query, hardCap) {
		if (!query || String(query).length < 2) {
			return [];
		}
		const data = await db.getSortedSetScan({
			key: 'categories:name',
			match: `*${String(query).toLowerCase()}*`,
			limit: hardCap || 500,
		});
		return data.map(data => parseInt(data.split(':').pop(), 10));
	}


'use strict';

const _ = require('lodash');

const db = require('../database');
const user = require('../user');
const groups = require('../groups');
const plugins = require('../plugins');
const privileges = require('../privileges');
const cache = require('../cache');

const Categories = module.exports;

require('./data')(Categories);
require('./create')(Categories);
require('./delete')(Categories);
require('./topics')(Categories);
require('./unread')(Categories);
require('./activeusers')(Categories);
require('./recentreplies')(Categories);
require('./update')(Categories);
require('./watch')(Categories);
require('./search')(Categories);

Categories.exists = async function (cid) {
	if (Array.isArray(cid)) {
		return await db.exists(cid.map(cid => `category:${cid}`));
	}
	return await db.exists(`category:${cid}`);
};

Categories.getCategoryById = async function (data) {
	const categories = await Categories.getCategories([data.cid], data.uid);
	if (!categories[0]) {
		return null;
	}
	const category = categories[0];
	data.category = category;

	const promises = [
		Categories.getCategoryTopics(data),
		Categories.getTopicCount(data),
		Categories.getWatchState([data.cid], data.uid),
		getChildrenTree(category, data.uid),
	];

	if (category.parentCid) {
		promises.push(Categories.getCategoryData(category.parentCid));
	}
	const [topics, topicCount, watchState, , parent] = await Promise.all(promises);

	category.topics = topics.topics;
	category.nextStart = topics.nextStart;
	category.topic_count = topicCount;
	category.isWatched = watchState[0] === Categories.watchStates.watching;
	category.isNotWatched = watchState[0] === Categories.watchStates.notwatching;
	category.isIgnored = watchState[0] === Categories.watchStates.ignoring;
	category.parent = parent;


	calculateTopicPostCount(category);
	const result = await plugins.hooks.fire('filter:category.get', { category: category, uid: data.uid });
	return result.category;
};

Categories.getAllCidsFromSet = async function (key) {
	let cids = cache.get(key);
	if (cids) {
		return cids.slice();
	}

	cids = await db.getSortedSetRange(key, 0, -1);
	cids = cids.map(cid => parseInt(cid, 10));
	cache.set(key, cids);
	return cids.slice();
};

Categories.getAllCategories = async function (uid) {
	const cids = await Categories.getAllCidsFromSet('categories:cid');
	return await Categories.getCategories(cids, uid);
};

Categories.getCidsByPrivilege = async function (set, uid, privilege) {
	const cids = await Categories.getAllCidsFromSet(set);
	return await privileges.categories.filterCids(privilege, cids, uid);
};

Categories.getCategoriesByPrivilege = async function (set, uid, privilege) {
	const cids = await Categories.getCidsByPrivilege(set, uid, privilege);
	return await Categories.getCategories(cids, uid);
};

Categories.getModerators = async function (cid) {
	const uids = await Categories.getModeratorUids([cid]);
	return await user.getUsersFields(uids[0], ['uid', 'username', 'userslug', 'picture']);
};

Categories.getModeratorUids = async function (cids) {
	const groupNames = cids.reduce((memo, cid) => {
		memo.push(`cid:${cid}:privileges:moderate`);
		memo.push(`cid:${cid}:privileges:groups:moderate`);
		return memo;
	}, []);

	const memberSets = await groups.getMembersOfGroups(groupNames);
	// Every other set is actually a list of user groups, not uids, so convert those to members
	const sets = memberSets.reduce((memo, set, idx) => {
		if (idx % 2) {
			memo.groupNames.push(set);
		} else {
			memo.uids.push(set);
		}

		return memo;
	}, { groupNames: [], uids: [] });

	const uniqGroups = _.uniq(_.flatten(sets.groupNames));
	const groupUids = await groups.getMembersOfGroups(uniqGroups);
	const map = _.zipObject(uniqGroups, groupUids);
	const moderatorUids = cids.map(
		(cid, index) => _.uniq(sets.uids[index].concat(_.flatten(sets.groupNames[index].map(g => map[g]))))
	);
	return moderatorUids;
};

Categories.getCategories = async function (cids, uid) {
	if (!Array.isArray(cids)) {
		throw new Error('[[error:invalid-cid]]');
	}

	if (!cids.length) {
		return [];
	}
	uid = parseInt(uid, 10);

	const [categories, tagWhitelist, hasRead] = await Promise.all([
		Categories.getCategoriesData(cids),
		Categories.getTagWhitelist(cids),
		Categories.hasReadCategories(cids, uid),
	]);
	categories.forEach((category, i) => {
		if (category) {
			category.tagWhitelist = tagWhitelist[i];
			category['unread-class'] = (category.topic_count === 0 || (hasRead[i] && uid !== 0)) ? '' : 'unread';
		}
	});
	return categories;
};

Categories.getTagWhitelist = async function (cids) {
	const cachedData = {};

	const nonCachedCids = cids.filter((cid) => {
		const data = cache.get(`cid:${cid}:tag:whitelist`);
		const isInCache = data !== undefined;
		if (isInCache) {
			cachedData[cid] = data;
		}
		return !isInCache;
	});

	if (!nonCachedCids.length) {
		return cids.map(cid => cachedData[cid]);
	}

	const keys = nonCachedCids.map(cid => `cid:${cid}:tag:whitelist`);
	const data = await db.getSortedSetsMembers(keys);

	nonCachedCids.forEach((cid, index) => {
		cachedData[cid] = data[index];
		cache.set(`cid:${cid}:tag:whitelist`, data[index]);
	});
	return cids.map(cid => cachedData[cid]);
};

function calculateTopicPostCount(category) {
	if (!category) {
		return;
	}

	let postCount = category.post_count;
	let topicCount = category.topic_count;
	if (Array.isArray(category.children)) {
		category.children.forEach((child) => {
			calculateTopicPostCount(child);
			postCount += parseInt(child.totalPostCount, 10) || 0;
			topicCount += parseInt(child.totalTopicCount, 10) || 0;
		});
	}

	category.totalPostCount = postCount;
	category.totalTopicCount = topicCount;
}
Categories.calculateTopicPostCount = calculateTopicPostCount;

Categories.getParents = async function (cids) {
	const categoriesData = await Categories.getCategoriesFields(cids, ['parentCid']);
	const parentCids = categoriesData.filter(c => c && c.parentCid).map(c => c.parentCid);
	if (!parentCids.length) {
		return cids.map(() => null);
	}
	const parentData = await Categories.getCategoriesData(parentCids);
	const cidToParent = _.zipObject(parentCids, parentData);
	return categoriesData.map(category => cidToParent[category.parentCid]);
};

Categories.getChildren = async function (cids, uid) {
	const categoryData = await Categories.getCategoriesFields(cids, ['parentCid']);
	const categories = categoryData.map((category, index) => ({ cid: cids[index], parentCid: category.parentCid }));
	await Promise.all(categories.map(c => getChildrenTree(c, uid)));
	return categories.map(c => c && c.children);
};

async function getChildrenTree(category, uid) {
	let childrenCids = await Categories.getChildrenCids(category.cid);
	childrenCids = await privileges.categories.filterCids('find', childrenCids, uid);
	childrenCids = childrenCids.filter(cid => parseInt(category.cid, 10) !== parseInt(cid, 10));
	if (!childrenCids.length) {
		category.children = [];
		return;
	}
	let childrenData = await Categories.getCategoriesData(childrenCids);
	childrenData = childrenData.filter(Boolean);
	childrenCids = childrenData.map(child => child.cid);
	const hasRead = await Categories.hasReadCategories(childrenCids, uid);
	childrenData.forEach((child, i) => {
		child['unread-class'] = (child.topic_count === 0 || (hasRead[i] && uid !== 0)) ? '' : 'unread';
	});
	Categories.getTree([category].concat(childrenData), category.parentCid);
}

Categories.getChildrenTree = getChildrenTree;

Categories.getParentCids = async function (currentCid) {
	let cid = currentCid;
	const parents = [];
	while (parseInt(cid, 10)) {
		// eslint-disable-next-line
		cid = await Categories.getCategoryField(cid, 'parentCid');
		if (cid) {
			parents.unshift(cid);
		}
	}
	return parents;
};

Categories.getChildrenCids = async function (rootCid) {
	let allCids = [];
	async function recursive(keys) {
		let childrenCids = await db.getSortedSetRange(keys, 0, -1);

		childrenCids = childrenCids.filter(cid => !allCids.includes(parseInt(cid, 10)));
		if (!childrenCids.length) {
			return;
		}
		keys = childrenCids.map(cid => `cid:${cid}:children`);
		childrenCids.forEach(cid => allCids.push(parseInt(cid, 10)));
		await recursive(keys);
	}
	const key = `cid:${rootCid}:children`;
	const cacheKey = `${key}:all`;
	const childrenCids = cache.get(cacheKey);
	if (childrenCids) {
		return childrenCids.slice();
	}

	await recursive(key);
	allCids = _.uniq(allCids);
	cache.set(cacheKey, allCids);
	return allCids.slice();
};

Categories.flattenCategories = function (allCategories, categoryData) {
	categoryData.forEach((category) => {
		if (category) {
			allCategories.push(category);

			if (Array.isArray(category.children) && category.children.length) {
				Categories.flattenCategories(allCategories, category.children);
			}
		}
	});
};

/**
 * build tree from flat list of categories
 *
 * @param categories {array} flat list of categories
 * @param parentCid {number} start from 0 to build full tree
 */
Categories.getTree = function (categories, parentCid) {
	parentCid = parentCid || 0;
	const cids = categories.map(category => category && category.cid);
	const cidToCategory = {};
	const parents = {};
	cids.forEach((cid, index) => {
		if (cid) {
			categories[index].children = undefined;
			cidToCategory[cid] = categories[index];
			parents[cid] = { ...categories[index] };
		}
	});

	const tree = [];

	categories.forEach((category) => {
		if (category) {
			category.children = category.children || [];
			if (!category.cid) {
				return;
			}
			if (!category.hasOwnProperty('parentCid') || category.parentCid === null) {
				category.parentCid = 0;
			}
			if (category.parentCid === parentCid) {
				tree.push(category);
				category.parent = parents[parentCid];
			} else {
				const parent = cidToCategory[category.parentCid];
				if (parent && parent.cid !== category.cid) {
					category.parent = parents[category.parentCid];
					parent.children = parent.children || [];
					parent.children.push(category);
				}
			}
		}
	});
	function sortTree(tree) {
		tree.sort((a, b) => {
			if (a.order !== b.order) {
				return a.order - b.order;
			}
			return a.cid - b.cid;
		});
		tree.forEach((category) => {
			if (category && Array.isArray(category.children)) {
				sortTree(category.children);
			}
		});
	}
	sortTree(tree);

	categories.forEach(c => calculateTopicPostCount(c));
	return tree;
};

Categories.buildForSelect = async function (uid, privilege, fields) {
	const cids = await Categories.getCidsByPrivilege('categories:cid', uid, privilege);
	return await getSelectData(cids, fields);
};

Categories.buildForSelectAll = async function (fields) {
	const cids = await Categories.getAllCidsFromSet('categories:cid');
	return await getSelectData(cids, fields);
};

async function getSelectData(cids, fields) {
	const categoryData = await Categories.getCategoriesData(cids);
	const tree = Categories.getTree(categoryData);
	return Categories.buildForSelectCategories(tree, fields);
}

Categories.buildForSelectCategories = function (categories, fields, parentCid) {
	function recursive(category, categoriesData, level, depth) {
		const bullet = level ? '&bull; ' : '';
		category.value = category.cid;
		category.level = level;
		category.text = level + bullet + category.name;
		category.depth = depth;
		categoriesData.push(category);
		if (Array.isArray(category.children)) {
			category.children.forEach(child => recursive(child, categoriesData, `&nbsp;&nbsp;&nbsp;&nbsp;${level}`, depth + 1));
		}
	}
	parentCid = parentCid || 0;
	const categoriesData = [];

	const rootCategories = categories.filter(category => category && category.parentCid === parentCid);

	rootCategories.forEach(category => recursive(category, categoriesData, '', 0));

	const pickFields = [
		'cid', 'name', 'level', 'icon',	'parentCid',
		'color', 'bgColor', 'backgroundImage', 'imageClass',
	];
	fields = fields || [];
	if (fields.includes('text') && fields.includes('value')) {
		return categoriesData.map(category => _.pick(category, fields));
	}
	if (fields.length) {
		pickFields.push(...fields);
	}

	return categoriesData.map(category => _.pick(category, pickFields));
'use strict';

const async = require('async');

const db = require('../database');
const meta = require('../meta');
const utils = require('../utils');
const slugify = require('../slugify');
const translator = require('../translator');
const plugins = require('../plugins');
const cache = require('../cache');

module.exports = function (Categories) {
	Categories.update = async function (modified) {
		const cids = Object.keys(modified);
		await Promise.all(cids.map(cid => updateCategory(cid, modified[cid])));
		return cids;
	};

	async function updateCategory(cid, modifiedFields) {
		const exists = await Categories.exists(cid);
		if (!exists) {
			return;
		}

		if (modifiedFields.hasOwnProperty('name')) {
			const translated = await translator.translate(modifiedFields.name);
			modifiedFields.slug = `${cid}/${slugify(translated)}`;
		}
		const result = await plugins.hooks.fire('filter:category.update', { cid: cid, category: modifiedFields });

		const { category } = result;
		const fields = Object.keys(category);
		// move parent to front, so its updated first
		const parentCidIndex = fields.indexOf('parentCid');
		if (parentCidIndex !== -1 && fields.length > 1) {
			fields.splice(0, 0, fields.splice(parentCidIndex, 1)[0]);
		}

		await async.eachSeries(fields, async (key) => {
			await updateCategoryField(cid, key, category[key]);
		});
		plugins.hooks.fire('action:category.update', { cid: cid, modified: category });
	}

	async function updateCategoryField(cid, key, value) {
		if (key === 'parentCid') {
			return await updateParent(cid, value);
		} else if (key === 'tagWhitelist') {
			return await updateTagWhitelist(cid, value);
		} else if (key === 'name') {
			return await updateName(cid, value);
		} else if (key === 'order') {
			return await updateOrder(cid, value);
		}

		await db.setObjectField(`category:${cid}`, key, value);
		if (key === 'description') {
			await Categories.parseDescription(cid, value);
		}
	}

	async function updateParent(cid, newParent) {
		newParent = parseInt(newParent, 10) || 0;
		if (parseInt(cid, 10) === newParent) {
			throw new Error('[[error:cant-set-self-as-parent]]');
		}
		const childrenCids = await Categories.getChildrenCids(cid);
		if (childrenCids.includes(newParent)) {
			throw new Error('[[error:cant-set-child-as-parent]]');
		}
		const oldParent = await Categories.getCategoryField(cid, 'parentCid');
		await Promise.all([
			db.sortedSetRemove(`cid:${oldParent}:children`, cid),
			db.sortedSetAdd(`cid:${newParent}:children`, cid, cid),
			db.setObjectField(`category:${cid}`, 'parentCid', newParent),
		]);

		cache.del([
			`cid:${oldParent}:children`,
			`cid:${newParent}:children`,
			`cid:${oldParent}:children:all`,
			`cid:${newParent}:children:all`,
		]);
	}

	async function updateTagWhitelist(cid, tags) {
		tags = tags.split(',').map(tag => utils.cleanUpTag(tag, meta.config.maximumTagLength))
			.filter(Boolean);
		await db.delete(`cid:${cid}:tag:whitelist`);
		const scores = tags.map((tag, index) => index);
		await db.sortedSetAdd(`cid:${cid}:tag:whitelist`, scores, tags);
		cache.del(`cid:${cid}:tag:whitelist`);
	}

	async function updateOrder(cid, order) {
		const parentCid = await Categories.getCategoryField(cid, 'parentCid');
		await db.sortedSetsAdd('categories:cid', order, cid);

		const childrenCids = await db.getSortedSetRange(
			`cid:${parentCid}:children`, 0, -1
		);

		const currentIndex = childrenCids.indexOf(String(cid));
		if (currentIndex === -1) {
			throw new Error('[[error:no-category]]');
		}
		// moves cid to index order-1 in the array
		if (childrenCids.length > 1) {
			childrenCids.splice(Math.max(0, order - 1), 0, childrenCids.splice(currentIndex, 1)[0]);
		}

		// recalculate orders from array indices
		await db.sortedSetAdd(
			`cid:${parentCid}:children`,
			childrenCids.map((cid, index) => index + 1),
			childrenCids
		);

		await db.setObjectBulk(
			childrenCids.map(cid => `category:${cid}`),
			childrenCids.map((cid, index) => ({ order: index + 1 }))
		);

		cache.del([
			'categories:cid',
			`cid:${parentCid}:children`,
			`cid:${parentCid}:children:all`,
		]);
	}

	Categories.parseDescription = async function (cid, description) {
		const parsedDescription = await plugins.hooks.fire('filter:parse.raw', description);
		await Categories.setCategoryField(cid, 'descriptionParsed', parsedDescription);
	};

	async function updateName(cid, newName) {
		const oldName = await Categories.getCategoryField(cid, 'name');
		await db.sortedSetRemove('categories:name', `${oldName.substr(0, 200).toLowerCase()}:${cid}`);
		await db.sortedSetAdd('categories:name', 0, `${newName.substr(0, 200).toLowerCase()}:${cid}`);
'use strict';

const plugins = require('./plugins');
const db = require('./database');

const social = module.exports;

social.postSharing = null;

social.getPostSharing = async function () {
	if (social.postSharing) {
		return social.postSharing;
	}

	let networks = [
		{
			id: 'facebook',
			name: 'Facebook',
			class: 'fa-facebook',
		},
		{
			id: 'twitter',
			name: 'Twitter',
			class: 'fa-twitter',
		},
	];
	networks = await plugins.hooks.fire('filter:social.posts', networks);
	const activated = await db.getSetMembers('social:posts.activated');
	networks.forEach((network) => {
		network.activated = activated.includes(network.id);
	});

	social.postSharing = networks;
	return networks;
};

social.getActivePostSharing = async function () {
	const networks = await social.getPostSharing();
	return networks.filter(network => network && network.activated);
};

social.setActivePostSharingNetworks = async function (networkIDs) {
	await db.delete('social:posts.activated');
	if (!networkIDs.length) {
		return;
	}
	await db.setAdd('social:posts.activated', networkIDs);
	social.postSharing = null;
};


'use strict';

const fs = require('fs');
const util = require('util');
const path = require('path');
const os = require('os');
const nconf = require('nconf');
const express = require('express');

const app = express();
app.renderAsync = util.promisify((tpl, data, callback) => app.render(tpl, data, callback));
let server;
const winston = require('winston');
const async = require('async');
const flash = require('connect-flash');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const useragent = require('express-useragent');
const favicon = require('serve-favicon');
const detector = require('spider-detector');
const helmet = require('helmet');

const Benchpress = require('benchpressjs');
const db = require('./database');
const analytics = require('./analytics');
const file = require('./file');
const emailer = require('./emailer');
const meta = require('./meta');
const logger = require('./logger');
const plugins = require('./plugins');
const flags = require('./flags');
const topicEvents = require('./topics/events');
const routes = require('./routes');
const auth = require('./routes/authentication');

const helpers = require('../public/src/modules/helpers');

if (nconf.get('ssl')) {
	server = require('https').createServer({
		key: fs.readFileSync(nconf.get('ssl').key),
		cert: fs.readFileSync(nconf.get('ssl').cert),
	}, app);
} else {
	server = require('http').createServer(app);
}

module.exports.server = server;
module.exports.app = app;

server.on('error', (err) => {
	if (err.code === 'EADDRINUSE') {
		winston.error(`NodeBB address in use, exiting...\n${err.stack}`);
	} else {
		winston.error(err.stack);
	}

	throw err;
});

// see https://github.com/isaacs/server-destroy/blob/master/index.js
const connections = {};
server.on('connection', (conn) => {
	const key = `${conn.remoteAddress}:${conn.remotePort}`;
	connections[key] = conn;
	conn.on('close', () => {
		delete connections[key];
	});
});

exports.destroy = function (callback) {
	server.close(callback);
	for (const connection of Object.values(connections)) {
		connection.destroy();
	}
};

exports.listen = async function () {
	emailer.registerApp(app);
	setupExpressApp(app);
	helpers.register();
	logger.init(app);
	await initializeNodeBB();
	winston.info('NodeBB Ready');

	require('./socket.io').server.emit('event:nodebb.ready', {
		'cache-buster': meta.config['cache-buster'],
		hostname: os.hostname(),
	});

	plugins.hooks.fire('action:nodebb.ready');

	await util.promisify(listen)();
};

async function initializeNodeBB() {
	const middleware = require('./middleware');
	await meta.themes.setupPaths();
	await plugins.init(app, middleware);
	await plugins.hooks.fire('static:assets.prepare', {});
	await plugins.hooks.fire('static:app.preload', {
		app: app,
		middleware: middleware,
	});
	await routes(app, middleware);
	await meta.blacklist.load();
	await flags.init();
	await analytics.init();
	await topicEvents.init();
}

function setupExpressApp(app) {
	const middleware = require('./middleware');
	const pingController = require('./controllers/ping');

	const relativePath = nconf.get('relative_path');
	const viewsDir = nconf.get('views_dir');

	app.engine('tpl', (filepath, data, next) => {
		filepath = filepath.replace(/\.tpl$/, '.js');

		Benchpress.__express(filepath, data, next);
	});
	app.set('view engine', 'tpl');
	app.set('views', viewsDir);
	app.set('json spaces', global.env === 'development' ? 4 : 0);
	app.use(flash());

	app.enable('view cache');

	if (global.env !== 'development') {
		app.enable('cache');
		app.enable('minification');
	}

	if (meta.config.useCompression) {
		const compression = require('compression');
		app.use(compression());
	}

	app.get(`${relativePath}/ping`, pingController.ping);
	app.get(`${relativePath}/sping`, pingController.ping);

	setupFavicon(app);

	app.use(`${relativePath}/apple-touch-icon`, middleware.routeTouchIcon);

	configureBodyParser(app);

	app.use(cookieParser(nconf.get('secret')));
	const userAgentMiddleware = useragent.express();
	app.use((req, res, next) => {
		userAgentMiddleware(req, res, next);
	});
	const spiderDetectorMiddleware = detector.middleware();
	app.use((req, res, next) => {
		spiderDetectorMiddleware(req, res, next);
	});

	app.use(session({
		store: db.sessionStore,
		secret: nconf.get('secret'),
		key: nconf.get('sessionKey'),
		cookie: setupCookie(),
		resave: nconf.get('sessionResave') || false,
		saveUninitialized: nconf.get('sessionSaveUninitialized') || false,
	}));

	setupHelmet(app);

	app.use(middleware.addHeaders);
	app.use(middleware.processRender);
	auth.initialize(app, middleware);
	app.use(middleware.autoLocale);	// must be added after auth middlewares are added

	const toobusy = require('toobusy-js');
	toobusy.maxLag(meta.config.eventLoopLagThreshold);
	toobusy.interval(meta.config.eventLoopInterval);
}

function setupHelmet(app) {
	app.use(helmet.dnsPrefetchControl());
	app.use(helmet.expectCt());
	app.use(helmet.frameguard());
	app.use(helmet.hidePoweredBy());
	app.use(helmet.ieNoOpen());
	app.use(helmet.noSniff());
	app.use(helmet.permittedCrossDomainPolicies());
	app.use(helmet.xssFilter());

	app.use(helmet.referrerPolicy({ policy: 'strict-origin-when-cross-origin' }));
	if (meta.config['hsts-enabled']) {
		app.use(helmet.hsts({
			maxAge: meta.config['hsts-maxage'],
			includeSubDomains: !!meta.config['hsts-subdomains'],
			preload: !!meta.config['hsts-preload'],
		}));
	}
}


function setupFavicon(app) {
	let faviconPath = meta.config['brand:favicon'] || 'favicon.ico';
	faviconPath = path.join(nconf.get('base_dir'), 'public', faviconPath.replace(/assets\/uploads/, 'uploads'));
	if (file.existsSync(faviconPath)) {
		app.use(nconf.get('relative_path'), favicon(faviconPath));
	}
}

function configureBodyParser(app) {
	const urlencodedOpts = nconf.get('bodyParser:urlencoded') || {};
	if (!urlencodedOpts.hasOwnProperty('extended')) {
		urlencodedOpts.extended = true;
	}
	app.use(bodyParser.urlencoded(urlencodedOpts));

	const jsonOpts = nconf.get('bodyParser:json') || {};
	app.use(bodyParser.json(jsonOpts));
}

function setupCookie() {
	const cookie = meta.configs.cookie.get();
	const ttl = meta.getSessionTTLSeconds() * 1000;
	cookie.maxAge = ttl;

	return cookie;
}

function listen(callback) {
	callback = callback || function () { };
	let port = nconf.get('port');
	const isSocket = isNaN(port) && !Array.isArray(port);
	const socketPath = isSocket ? nconf.get('port') : '';

	if (Array.isArray(port)) {
		if (!port.length) {
			winston.error('[startup] empty ports array in config.json');
			process.exit();
		}

		winston.warn('[startup] If you want to start nodebb on multiple ports please use loader.js');
		winston.warn(`[startup] Defaulting to first port in array, ${port[0]}`);
		port = port[0];
		if (!port) {
			winston.error('[startup] Invalid port, exiting');
			process.exit();
		}
	}
	port = parseInt(port, 10);
	if ((port !== 80 && port !== 443) || nconf.get('trust_proxy') === true) {
		winston.info('Enabling \'trust proxy\'');
		app.enable('trust proxy');
	}

	if ((port === 80 || port === 443) && process.env.NODE_ENV !== 'development') {
		winston.info('Using ports 80 and 443 is not recommend; use a proxy instead. See README.md');
	}

	const bind_address = ((nconf.get('bind_address') === '0.0.0.0' || !nconf.get('bind_address')) ? '0.0.0.0' : nconf.get('bind_address'));
	const args = isSocket ? [socketPath] : [port, bind_address];
	let oldUmask;

	args.push((err) => {
		if (err) {
			winston.info(`[startup] NodeBB was unable to listen on: ${bind_address}:${port}`);
			process.exit();
		}

		winston.info(`NodeBB is now listening on: ${isSocket ? socketPath : `${bind_address}:${port}`}`);
		if (oldUmask) {
			process.umask(oldUmask);
		}
		callback();
	});

	// Alter umask if necessary
	if (isSocket) {
		oldUmask = process.umask('0000');
		module.exports.testSocket(socketPath, (err) => {
			if (err) {
				winston.error(`[startup] NodeBB was unable to secure domain socket access (${socketPath})\n${err.stack}`);
				throw err;
			}

			server.listen(...args);
		});
	} else {
		server.listen(...args);
	}
}

exports.testSocket = function (socketPath, callback) {
	if (typeof socketPath !== 'string') {
		return callback(new Error(`invalid socket path : ${socketPath}`));
	}
	const net = require('net');
	const file = require('./file');
	async.series([
		function (next) {
			file.exists(socketPath, (err, exists) => {
				if (exists) {
					next();
				} else {
					callback(err);
				}
			});
		},
		function (next) {
			const testSocket = new net.Socket();
			testSocket.on('error', (err) => {
				next(err.code !== 'ECONNREFUSED' ? err : null);
			});
			testSocket.connect({ path: socketPath }, () => {
				// Something's listening here, abort
				callback(new Error('port-in-use'));
			});
		},
		async.apply(fs.unlink, socketPath),	// The socket was stale, kick it out of the way
	], callback);

'use strict';

const path = require('path');
const util = require('util');
const semver = require('semver');
const readline = require('readline');
const winston = require('winston');

const db = require('./database');
const file = require('./file');
const { paths } = require('./constants');

/*
 * Need to write an upgrade script for NodeBB? Cool.
 *
 * 1. Copy TEMPLATE to a unique file name of your choice. Try to be succinct.
 * 2. Open up that file and change the user-friendly name (can be longer/more descriptive than the file name)
 *    and timestamp (don't forget the timestamp!)
 * 3. Add your script under the "method" property
 */

const Upgrade = module.exports;

Upgrade.getAll = async function () {
	let files = await file.walk(path.join(__dirname, './upgrades'));

	// Sort the upgrade scripts based on version
	files = files.filter(file => path.basename(file) !== 'TEMPLATE').sort((a, b) => {
		const versionA = path.dirname(a).split(path.sep).pop();
		const versionB = path.dirname(b).split(path.sep).pop();
		const semverCompare = semver.compare(versionA, versionB);
		if (semverCompare) {
			return semverCompare;
		}
		const timestampA = require(a).timestamp;
		const timestampB = require(b).timestamp;
		return timestampA - timestampB;
	});

	await Upgrade.appendPluginScripts(files);

	// check duplicates and error
	const seen = {};
	const dupes = [];
	files.forEach((file) => {
		if (seen[file]) {
			dupes.push(file);
		} else {
			seen[file] = true;
		}
	});
	if (dupes.length) {
		winston.error(`Found duplicate upgrade scripts\n${dupes}`);
		throw new Error('[[error:duplicate-upgrade-scripts]]');
	}

	return files;
};

Upgrade.appendPluginScripts = async function (files) {
	// Find all active plugins
	const plugins = await db.getSortedSetRange('plugins:active', 0, -1);
	plugins.forEach((plugin) => {
		const configPath = path.join(paths.nodeModules, plugin, 'plugin.json');
		try {
			const pluginConfig = require(configPath);
			if (pluginConfig.hasOwnProperty('upgrades') && Array.isArray(pluginConfig.upgrades)) {
				pluginConfig.upgrades.forEach((script) => {
					files.push(path.join(path.dirname(configPath), script));
				});
			}
		} catch (e) {
			winston.warn(`[upgrade/appendPluginScripts] Unable to read plugin.json for plugin \`${plugin}\`. Skipping.`);
		}
	});
	return files;
};

Upgrade.check = async function () {
	// Throw 'schema-out-of-date' if not all upgrade scripts have run
	const files = await Upgrade.getAll();
	const executed = await db.getSortedSetRange('schemaLog', 0, -1);
	const remainder = files.filter(name => !executed.includes(path.basename(name, '.js')));
	if (remainder.length > 0) {
		throw new Error('schema-out-of-date');
	}
};

Upgrade.run = async function () {
	console.log('\nParsing upgrade scripts... ');

	const [completed, available] = await Promise.all([
		db.getSortedSetRange('schemaLog', 0, -1),
		Upgrade.getAll(),
	]);

	let skipped = 0;
	const queue = available.filter((cur) => {
		const upgradeRan = completed.includes(path.basename(cur, '.js'));
		if (upgradeRan) {
			skipped += 1;
		}
		return !upgradeRan;
	});

	await Upgrade.process(queue, skipped);
};

Upgrade.runParticular = async function (names) {
	console.log('\nParsing upgrade scripts... ');
	const files = await file.walk(path.join(__dirname, './upgrades'));
	await Upgrade.appendPluginScripts(files);
	const upgrades = files.filter(file => names.includes(path.basename(file, '.js')));
	await Upgrade.process(upgrades, 0);
};

Upgrade.process = async function (files, skipCount) {
	console.log('OK'.green + ' | '.reset + String(files.length).cyan + ' script(s) found'.cyan + (skipCount > 0 ? ', '.cyan + String(skipCount).cyan + ' skipped'.cyan : ''));
	const [schemaDate, schemaLogCount] = await Promise.all([
		db.get('schemaDate'),
		db.sortedSetCard('schemaLog'),
	]);

	for (const file of files) {
		/* eslint-disable no-await-in-loop */
		const scriptExport = require(file);
		const date = new Date(scriptExport.timestamp);
		const version = path.dirname(file).split('/').pop();
		const progress = {
			current: 0,
			counter: 0,
			total: 0,
			incr: Upgrade.incrementProgress,
			script: scriptExport,
			date: date,
		};

		process.stdout.write(`${'  → '.white + String(`[${[date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate()].join('/')}] `).gray + String(scriptExport.name).reset}...`);

		// For backwards compatibility, cross-reference with schemaDate (if found). If a script's date is older, skip it
		if ((!schemaDate && !schemaLogCount) || (scriptExport.timestamp <= schemaDate && semver.lt(version, '1.5.0'))) {
			process.stdout.write(' skipped\n'.grey);

			await db.sortedSetAdd('schemaLog', Date.now(), path.basename(file, '.js'));
			// eslint-disable-next-line no-continue
			continue;
		}

		// Promisify method if necessary
		if (scriptExport.method.constructor && scriptExport.method.constructor.name !== 'AsyncFunction') {
			scriptExport.method = util.promisify(scriptExport.method);
		}

		// Do the upgrade...
		const upgradeStart = Date.now();
		try {
			await scriptExport.method.bind({
				progress: progress,
			})();
		} catch (err) {
			console.error('Error occurred');
			throw err;
		}
		const upgradeDuration = ((Date.now() - upgradeStart) / 1000).toFixed(2);
		process.stdout.write(` OK (${upgradeDuration} seconds)\n`.green);

		// Record success in schemaLog
		await db.sortedSetAdd('schemaLog', Date.now(), path.basename(file, '.js'));
	}

	console.log('Schema update complete!\n'.green);
};

Upgrade.incrementProgress = function (value) {
	// Newline on first invocation
	if (this.current === 0) {
		process.stdout.write('\n');
	}

	this.current += value || 1;
	this.counter += value || 1;
	const step = (this.total ? Math.floor(this.total / 100) : 100);

	if (this.counter > step || this.current >= this.total) {
		this.counter -= step;
		let percentage = 0;
		let filled = 0;
		let unfilled = 15;
		if (this.total) {
			percentage = `${Math.floor((this.current / this.total) * 100)}%`;
			filled = Math.floor((this.current / this.total) * 15);
			unfilled = Math.max(0, 15 - filled);
		}

		readline.cursorTo(process.stdout, 0);
		process.stdout.write(`    [${filled ? new Array(filled).join('#') : ''}${new Array(unfilled).join(' ')}] (${this.current}/${this.total || '??'}) ${percentage} `);
	}
};

'use strict';

const path = require('path');

const baseDir = path.join(__dirname, '../');
const loader = path.join(baseDir, 'loader.js');
const app = path.join(baseDir, 'app.js');
const pidfile = path.join(baseDir, 'pidfile');
const config = path.join(baseDir, 'config.json');
const currentPackage = path.join(baseDir, 'package.json');
const installPackage = path.join(baseDir, 'install/package.json');
const nodeModules = path.join(baseDir, 'node_modules');

exports.paths = {
	baseDir,
	loader,
	app,
	pidfile,
	config,
	currentPackage,
	installPackage,
	nodeModules,
};

exports.pluginNamePattern = /^(@[\w-]+\/)?nodebb-(theme|plugin|widget|rewards)-[\w-]+$/;
'use strict';

const Client = {
	sendMessage: function (channel, message) {
		process.send({
			action: 'socket.io',
			channel: channel,
			message: message,
		});
	},
	trigger: function (channel, message) {
		Client.message.concat(Client.pmessage).forEach((callback) => {
			setImmediate(() => {
				callback.call(Client, channel, message);
			});
		});
	},
	publish: function (channel, message) {
		Client.sendMessage(channel, message);
	},
	// we don't actually care about which channels we're subscribed to
	subscribe: function () {},
	psubscribe: function () {},
	unsubscribe: function () {},
	unpsubscribe: function () {},
	message: [],
	pmessage: [],
	on: function (event, callback) {
		if (event !== 'message' && event !== 'pmessage') {
			return;
		}
		Client[event].push(callback);
	},
	off: function (event, callback) {
		if (event !== 'message' && event !== 'pmessage') {
			return;
		}
		if (callback) {
			Client[event] = Client[event].filter(c => c !== callback);
		} else {
			Client[event] = [];
		}
	},
};

process.on('message', (message) => {
	if (message && typeof message === 'object' && message.action === 'socket.io') {
		Client.trigger(message.channel, message.message);
	}
});

const adapter = require('socket.io-adapter-cluster')({
	client: Client,
});
// Otherwise, every node thinks it is the master node and ignores messages
// because they are from "itself".
Object.defineProperty(adapter.prototype, 'id', {
	get: function () {
		return process.pid;
	},
'use strict';

const groups = require('../groups');
const user = require('../user');
const utils = require('../utils');
const events = require('../events');
const privileges = require('../privileges');
const api = require('../api');
const sockets = require('.');

const SocketGroups = module.exports;

SocketGroups.before = async (socket, method, data) => {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
};

SocketGroups.join = async (socket, data) => {
	sockets.warnDeprecated(socket, 'PUT /api/v3/groups/:slug/membership/:uid');
	const slug = await groups.getGroupField(data.groupName, 'slug');
	await api.groups.join(socket, { slug: slug, uid: data.uid || socket.uid });
};

SocketGroups.leave = async (socket, data) => {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/groups/:slug/membership/:uid');
	const slug = await groups.getGroupField(data.groupName, 'slug');
	await api.groups.leave(socket, { slug: slug, uid: data.uid || socket.uid });
};

SocketGroups.addMember = async (socket, data) => {
	await isOwner(socket, data);
	if (data.groupName === 'administrators' || groups.isPrivilegeGroup(data.groupName)) {
		throw new Error('[[error:not-allowed]]');
	}
	if (!data.uid) {
		throw new Error('[[error:invalid-data]]');
	}
	data.uid = !Array.isArray(data.uid) ? [data.uid] : data.uid;
	if (data.uid.filter(uid => !(parseInt(uid, 10) > 0)).length) {
		throw new Error('[[error:invalid-uid]]');
	}
	for (const uid of data.uid) {
		// eslint-disable-next-line no-await-in-loop
		await groups.join(data.groupName, uid);
	}

	logGroupEvent(socket, 'group-add-member', {
		groupName: data.groupName,
		targetUid: String(data.uid),
	});
};

async function isOwner(socket, data) {
	if (typeof data.groupName !== 'string') {
		throw new Error('[[error:invalid-group-name]]');
	}
	const results = await utils.promiseParallel({
		isAdmin: await user.isAdministrator(socket.uid),
		isGlobalModerator: await user.isGlobalModerator(socket.uid),
		isOwner: await groups.ownership.isOwner(socket.uid, data.groupName),
		group: await groups.getGroupData(data.groupName),
	});

	const isOwner = results.isOwner || results.isAdmin || (results.isGlobalModerator && !results.group.system);
	if (!isOwner) {
		throw new Error('[[error:no-privileges]]');
	}
}

async function isInvited(socket, data) {
	if (typeof data.groupName !== 'string') {
		throw new Error('[[error:invalid-group-name]]');
	}
	const invited = await groups.isInvited(socket.uid, data.groupName);
	if (!invited) {
		throw new Error('[[error:not-invited]]');
	}
}

SocketGroups.grant = async (socket, data) => {
	sockets.warnDeprecated(socket, 'PUT /api/v3/groups/:slug/ownership/:uid');

	await isOwner(socket, data);
	await groups.ownership.grant(data.toUid, data.groupName);
	logGroupEvent(socket, 'group-owner-grant', {
		groupName: data.groupName,
		targetUid: data.toUid,
	});
};

SocketGroups.rescind = async (socket, data) => {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/groups/:slug/ownership/:uid');

	await isOwner(socket, data);
	await groups.ownership.rescind(data.toUid, data.groupName);
	logGroupEvent(socket, 'group-owner-rescind', {
		groupName: data.groupName,
		targetUid: data.toUid,
	});
};

SocketGroups.accept = async (socket, data) => {
	await isOwner(socket, data);
	await groups.acceptMembership(data.groupName, data.toUid);
	logGroupEvent(socket, 'group-accept-membership', {
		groupName: data.groupName,
		targetUid: data.toUid,
	});
};

SocketGroups.reject = async (socket, data) => {
	await isOwner(socket, data);
	await groups.rejectMembership(data.groupName, data.toUid);
	logGroupEvent(socket, 'group-reject-membership', {
		groupName: data.groupName,
		targetUid: data.toUid,
	});
};

SocketGroups.acceptAll = async (socket, data) => {
	await isOwner(socket, data);
	await acceptRejectAll(SocketGroups.accept, socket, data);
};

SocketGroups.rejectAll = async (socket, data) => {
	await isOwner(socket, data);
	await acceptRejectAll(SocketGroups.reject, socket, data);
};

async function acceptRejectAll(method, socket, data) {
	if (typeof data.groupName !== 'string') {
		throw new Error('[[error:invalid-group-name]]');
	}
	const uids = await groups.getPending(data.groupName);
	await Promise.all(uids.map(async (uid) => {
		await method(socket, { groupName: data.groupName, toUid: uid });
	}));
}

SocketGroups.issueInvite = async (socket, data) => {
	await isOwner(socket, data);
	await groups.invite(data.groupName, data.toUid);
	logGroupEvent(socket, 'group-invite', {
		groupName: data.groupName,
		targetUid: data.toUid,
	});
};

SocketGroups.issueMassInvite = async (socket, data) => {
	await isOwner(socket, data);
	if (!data || !data.usernames || !data.groupName) {
		throw new Error('[[error:invalid-data]]');
	}
	let usernames = String(data.usernames).split(',');
	usernames = usernames.map(username => username && username.trim());

	let uids = await user.getUidsByUsernames(usernames);
	uids = uids.filter(uid => !!uid && parseInt(uid, 10));

	await groups.invite(data.groupName, uids);

	for (const uid of uids) {
		logGroupEvent(socket, 'group-invite', {
			groupName: data.groupName,
			targetUid: uid,
		});
	}
};

SocketGroups.rescindInvite = async (socket, data) => {
	await isOwner(socket, data);
	await groups.rejectMembership(data.groupName, data.toUid);
};

SocketGroups.acceptInvite = async (socket, data) => {
	await isInvited(socket, data);
	await groups.acceptMembership(data.groupName, socket.uid);
	logGroupEvent(socket, 'group-invite-accept', {
		groupName: data.groupName,
	});
};

SocketGroups.rejectInvite = async (socket, data) => {
	await isInvited(socket, data);
	await groups.rejectMembership(data.groupName, socket.uid);
	logGroupEvent(socket, 'group-invite-reject', {
		groupName: data.groupName,
	});
};

SocketGroups.update = async (socket, data) => {
	sockets.warnDeprecated(socket, 'PUT /api/v3/groups/:slug');
	await isOwner(socket, data);

	const slug = await groups.getGroupField(data.groupName, 'slug');
	await api.groups.update(socket, { slug, ...data.values });
};


SocketGroups.kick = async (socket, data) => {
	await isOwner(socket, data);
	if (socket.uid === parseInt(data.uid, 10)) {
		throw new Error('[[error:cant-kick-self]]');
	}

	const isOwnerBit = await groups.ownership.isOwner(data.uid, data.groupName);
	await groups.kick(data.uid, data.groupName, isOwnerBit);
	logGroupEvent(socket, 'group-kick', {
		groupName: data.groupName,
		targetUid: data.uid,
	});
};

SocketGroups.create = async (socket, data) => {
	sockets.warnDeprecated(socket, 'POST /api/v3/groups');
	const groupData = await api.groups.create(socket, data);
	return groupData;
};

SocketGroups.delete = async (socket, data) => {
	sockets.warnDeprecated(socket, 'DEL /api/v3/groups');
	const slug = await groups.getGroupField(data.groupName, 'slug');
	await api.groups.delete(socket, { slug: slug });
};

SocketGroups.search = async (socket, data) => {
	data.options = data.options || {};

	if (!data.query) {
		const groupsPerPage = 15;
		const groupData = await groups.getGroupsBySort(data.options.sort, 0, groupsPerPage - 1);
		return groupData;
	}
	data.options.filterHidden = data.options.filterHidden || !await user.isAdministrator(socket.uid);
	return await groups.search(data.query, data.options);
};

SocketGroups.loadMore = async (socket, data) => {
	if (!data.sort || !utils.isNumber(data.after) || parseInt(data.after, 10) < 0) {
		throw new Error('[[error:invalid-data]]');
	}

	const groupsPerPage = 10;
	const start = parseInt(data.after, 10);
	const stop = start + groupsPerPage - 1;
	const groupData = await groups.getGroupsBySort(data.sort, start, stop);
	return { groups: groupData, nextStart: stop + 1 };
};

SocketGroups.searchMembers = async (socket, data) => {
	if (!data.groupName) {
		throw new Error('[[error:invalid-data]]');
	}
	await canSearchMembers(socket.uid, data.groupName);
	if (!await privileges.global.can('search:users', socket.uid)) {
		throw new Error('[[error:no-privileges]]');
	}
	return await groups.searchMembers({
		uid: socket.uid,
		query: data.query,
		groupName: data.groupName,
	});
};

SocketGroups.loadMoreMembers = async (socket, data) => {
	if (!data.groupName || !utils.isNumber(data.after) || parseInt(data.after, 10) < 0) {
		throw new Error('[[error:invalid-data]]');
	}
	await canSearchMembers(socket.uid, data.groupName);
	data.after = parseInt(data.after, 10);
	const users = await groups.getOwnersAndMembers(data.groupName, socket.uid, data.after, data.after + 9);
	return {
		users: users,
		nextStart: data.after + 10,
	};
};

async function canSearchMembers(uid, groupName) {
	const [isHidden, isMember, isAdmin, isGlobalMod, viewGroups] = await Promise.all([
		groups.isHidden(groupName),
		groups.isMember(uid, groupName),
		user.isAdministrator(uid),
		user.isGlobalModerator(uid),
		privileges.global.can('view:groups', uid),
	]);

	if (!viewGroups || (isHidden && !isMember && !isAdmin && !isGlobalMod)) {
		throw new Error('[[error:no-privileges]]');
	}
}

SocketGroups.cover = {};

SocketGroups.cover.update = async (socket, data) => {
	if (!socket.uid) {
		throw new Error('[[error:no-privileges]]');
	}
	if (data.file || (!data.imageData && !data.position)) {
		throw new Error('[[error:invalid-data]]');
	}
	await canModifyGroup(socket.uid, data.groupName);
	return await groups.updateCover(socket.uid, {
		groupName: data.groupName,
		imageData: data.imageData,
		position: data.position,
	});
};

SocketGroups.cover.remove = async (socket, data) => {
	if (!socket.uid) {
		throw new Error('[[error:no-privileges]]');
	}

	await canModifyGroup(socket.uid, data.groupName);
	await groups.removeCover({
		groupName: data.groupName,
	});
};

async function canModifyGroup(uid, groupName) {
	if (typeof groupName !== 'string') {
		throw new Error('[[error:invalid-group-name]]');
	}
	const results = await utils.promiseParallel({
		isOwner: groups.ownership.isOwner(uid, groupName),
		system: groups.getGroupField(groupName, 'system'),
		isAdmin: user.isAdministrator(uid),
		isGlobalMod: user.isGlobalModerator(uid),
	});

	if (!(results.isOwner || results.isAdmin || (results.isGlobalMod && !results.system))) {
		throw new Error('[[error:no-privileges]]');
	}
}

function logGroupEvent(socket, event, additional) {
	events.log({
		type: event,
		uid: socket.uid,
		ip: socket.ip,
		...additional,
	});
}

'use strict';

const winston = require('winston');

const meta = require('../meta');
const user = require('../user');
const events = require('../events');
const db = require('../database');
const privileges = require('../privileges');
const websockets = require('./index');
const index = require('./index');
const getAdminSearchDict = require('../admin/search').getDictionary;

const SocketAdmin = module.exports;
SocketAdmin.user = require('./admin/user');
SocketAdmin.categories = require('./admin/categories');
SocketAdmin.settings = require('./admin/settings');
SocketAdmin.groups = require('./admin/groups');
SocketAdmin.tags = require('./admin/tags');
SocketAdmin.rewards = require('./admin/rewards');
SocketAdmin.navigation = require('./admin/navigation');
SocketAdmin.rooms = require('./admin/rooms');
SocketAdmin.social = require('./admin/social');
SocketAdmin.themes = require('./admin/themes');
SocketAdmin.plugins = require('./admin/plugins');
SocketAdmin.widgets = require('./admin/widgets');
SocketAdmin.config = require('./admin/config');
SocketAdmin.settings = require('./admin/settings');
SocketAdmin.email = require('./admin/email');
SocketAdmin.analytics = require('./admin/analytics');
SocketAdmin.logs = require('./admin/logs');
SocketAdmin.errors = require('./admin/errors');
SocketAdmin.uploads = require('./admin/uploads');
SocketAdmin.digest = require('./admin/digest');
SocketAdmin.cache = require('./admin/cache');

SocketAdmin.before = async function (socket, method) {
	const isAdmin = await user.isAdministrator(socket.uid);
	if (isAdmin) {
		return;
	}

	// Check admin privileges mapping (if not in mapping, deny access)
	const privilegeSet = privileges.admin.socketMap.hasOwnProperty(method) ? privileges.admin.socketMap[method].split(';') : [];
	const hasPrivilege = (await Promise.all(privilegeSet.map(
		async privilege => privileges.admin.can(privilege, socket.uid)
	))).some(Boolean);
	if (privilegeSet.length && hasPrivilege) {
		return;
	}

	winston.warn(`[socket.io] Call to admin method ( ${method} ) blocked (accessed by uid ${socket.uid})`);
	throw new Error('[[error:no-privileges]]');
};

SocketAdmin.restart = async function (socket) {
	await logRestart(socket);
	meta.restart();
};

async function logRestart(socket) {
	await events.log({
		type: 'restart',
		uid: socket.uid,
		ip: socket.ip,
	});
	await db.setObject('lastrestart', {
		uid: socket.uid,
		ip: socket.ip,
		timestamp: Date.now(),
	});
}

SocketAdmin.reload = async function (socket) {
	await require('../meta/build').buildAll();
	await events.log({
		type: 'build',
		uid: socket.uid,
		ip: socket.ip,
	});

	await logRestart(socket);
	meta.restart();
};

SocketAdmin.fireEvent = function (socket, data, callback) {
	index.server.emit(data.name, data.payload || {});
	callback();
};

SocketAdmin.deleteEvents = function (socket, eids, callback) {
	events.deleteEvents(eids, callback);
};

SocketAdmin.deleteAllEvents = function (socket, data, callback) {
	events.deleteAll(callback);
};

SocketAdmin.getSearchDict = async function (socket) {
	const settings = await user.getSettings(socket.uid);
	const lang = settings.userLang || meta.config.defaultLang || 'en-GB';
	return await getAdminSearchDict(lang);
};

SocketAdmin.deleteAllSessions = function (socket, data, callback) {
	user.auth.deleteAllSessions(callback);
};

SocketAdmin.reloadAllSessions = function (socket, data, callback) {
	websockets.in(`uid_${socket.uid}`).emit('event:livereload');
	callback();
};

SocketAdmin.getServerTime = function (socket, data, callback) {
	const now = new Date();

	callback(null, {
		timestamp: now.getTime(),
		offset: now.getTimezoneOffset(),
	});
'use strict';

const _ = require('lodash');

const meta = require('../../meta');
const categories = require('../../categories');
const privileges = require('../../privileges');
const controllersHelpers = require('../../controllers/helpers');

module.exports = function (SocketCategories) {
	// used by categorySeach module
	SocketCategories.categorySearch = async function (socket, data) {
		let cids = [];
		let matchedCids = [];
		const privilege = data.privilege || 'topics:read';
		data.states = (data.states || ['watching', 'notwatching', 'ignoring']).map(
			state => categories.watchStates[state]
		);

		if (data.query) {
			({ cids, matchedCids } = await findMatchedCids(socket.uid, data));
		} else {
			cids = await loadCids(socket.uid, data.parentCid);
		}

		const visibleCategories = await controllersHelpers.getVisibleCategories({
			cids, uid: socket.uid, states: data.states, privilege, showLinks: data.showLinks, parentCid: data.parentCid,
		});

		if (Array.isArray(data.selectedCids)) {
			data.selectedCids = data.selectedCids.map(cid => parseInt(cid, 10));
		}

		let categoriesData = categories.buildForSelectCategories(visibleCategories, ['disabledClass'], data.parentCid);
		categoriesData = categoriesData.slice(0, 200);

		categoriesData.forEach((category) => {
			category.selected = data.selectedCids ? data.selectedCids.includes(category.cid) : false;
			if (matchedCids.includes(category.cid)) {
				category.match = true;
			}
		});
		return categoriesData;
	};

	async function findMatchedCids(uid, data) {
		const result = await categories.search({
			query: data.query,
			paginate: false,
		});


		let matchedCids = result.categories.map(c => c.cid);
		// no need to filter if all 3 states are used
		const filterByWatchState = !Object.values(categories.watchStates)
			.every(state => data.states.includes(state));

		if (filterByWatchState) {
			const states = await categories.getWatchState(matchedCids, uid);
			matchedCids = matchedCids.filter((cid, index) => data.states.includes(states[index]));
		}

		const rootCids = _.uniq(_.flatten(await Promise.all(matchedCids.map(categories.getParentCids))));
		const allChildCids = _.uniq(_.flatten(await Promise.all(matchedCids.map(categories.getChildrenCids))));

		return {
			cids: _.uniq(rootCids.concat(allChildCids).concat(matchedCids)),
			matchedCids: matchedCids,
		};
	}

	async function loadCids(uid, parentCid) {
		let resultCids = [];
		async function getCidsRecursive(cids) {
			const categoryData = await categories.getCategoriesFields(cids, ['subCategoriesPerPage']);
			const cidToData = _.zipObject(cids, categoryData);
			await Promise.all(cids.map(async (cid) => {
				const allChildCids = await categories.getAllCidsFromSet(`cid:${cid}:children`);
				if (allChildCids.length) {
					const childCids = await privileges.categories.filterCids('find', allChildCids, uid);
					resultCids.push(...childCids.slice(0, cidToData[cid].subCategoriesPerPage));
					await getCidsRecursive(childCids);
				}
			}));
		}

		const allRootCids = await categories.getAllCidsFromSet(`cid:${parentCid}:children`);
		const rootCids = await privileges.categories.filterCids('find', allRootCids, uid);
		const pageCids = rootCids.slice(0, meta.config.categoriesPerPage);
		resultCids = pageCids;
'use strict';

const SocketPlugins = {};

/*
	This file is provided exclusively so that plugins can require it and add their own socket listeners.

	How? From your plugin:

		var SocketPlugins = require.main.require('./src/socket.io/plugins');
		SocketPlugins.myPlugin = {};
		SocketPlugins.myPlugin.myMethod = function(socket, data, callback) { ... };

	Be a good lad and namespace your methods.
*/
'use strict';

const api = require('../../api');
const sockets = require('..');

module.exports = function (SocketPosts) {
	function moveChecks(socket, typeCheck, data) {
		if (!socket.uid) {
			throw new Error('[[error:not-logged-in]]');
		}

		if (!data || !typeCheck || !data.tid) {
			throw new Error('[[error:invalid-data]]');
		}
	}

	SocketPosts.movePost = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid/move');

		moveChecks(socket, isFinite(data.pid), data);
		await api.posts.move(socket, data);
	};

	SocketPosts.movePosts = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid/move');

		moveChecks(socket, !Array.isArray(data.pids), data);
		await Promise.all(data.pids.map(async pid => api.posts.move(socket, {
			tid: data.tid,
			pid,
'use strict';

const sockets = require('..');
const api = require('../../api');

module.exports = function (SocketPosts) {
	SocketPosts.bookmark = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid/bookmark');
		return await api.posts.bookmark(socket, data);
	};

	SocketPosts.unbookmark = async function (socket, data) {
		sockets.warnDeprecated(socket, 'DELETE /api/v3/posts/:pid/bookmark');
		return await api.posts.unbookmark(socket, data);
	};
'use strict';

const db = require('../../database');
const user = require('../../user');
const posts = require('../../posts');
const privileges = require('../../privileges');
const meta = require('../../meta');
const api = require('../../api');

const sockets = require('..');

module.exports = function (SocketPosts) {
	SocketPosts.getVoters = async function (socket, data) {
		if (!data || !data.pid || !data.cid) {
			throw new Error('[[error:invalid-data]]');
		}
		const showDownvotes = !meta.config['downvote:disabled'];
		const canSeeVotes = meta.config.votesArePublic || await privileges.categories.isAdminOrMod(data.cid, socket.uid);
		if (!canSeeVotes) {
			throw new Error('[[error:no-privileges]]');
		}
		const [upvoteUids, downvoteUids] = await Promise.all([
			db.getSetMembers(`pid:${data.pid}:upvote`),
			showDownvotes ? db.getSetMembers(`pid:${data.pid}:downvote`) : [],
		]);

		const [upvoters, downvoters] = await Promise.all([
			user.getUsersFields(upvoteUids, ['username', 'userslug', 'picture']),
			user.getUsersFields(downvoteUids, ['username', 'userslug', 'picture']),
		]);

		return {
			upvoteCount: upvoters.length,
			downvoteCount: downvoters.length,
			showDownvotes: showDownvotes,
			upvoters: upvoters,
			downvoters: downvoters,
		};
	};

	SocketPosts.getUpvoters = async function (socket, pids) {
		if (!Array.isArray(pids)) {
			throw new Error('[[error:invalid-data]]');
		}
		const data = await posts.getUpvotedUidsByPids(pids);
		if (!data.length) {
			return [];
		}

		const result = await Promise.all(data.map(async (uids) => {
			let otherCount = 0;
			if (uids.length > 6) {
				otherCount = uids.length - 5;
				uids = uids.slice(0, 5);
			}
			const usernames = await user.getUsernamesByUids(uids);
			return {
				otherCount: otherCount,
				usernames: usernames,
			};
		}));
		return result;
	};

	SocketPosts.upvote = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid/vote');
		return await api.posts.upvote(socket, data);
	};

	SocketPosts.downvote = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid/vote');
		return await api.posts.downvote(socket, data);
	};

	SocketPosts.unvote = async function (socket, data) {
'use strict';

const api = require('../../api');
const websockets = require('../index');

module.exports = function (SocketPosts) {
	SocketPosts.edit = async function (socket, data) {
		websockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid');

		if (!socket.uid) {
			throw new Error('[[error:not-logged-in]]');
		}

		return await api.posts.edit(socket, data);
	};
'use strict';

const posts = require('../../posts');
const flags = require('../../flags');
const events = require('../../events');
const privileges = require('../../privileges');
const plugins = require('../../plugins');
const social = require('../../social');
const user = require('../../user');
const utils = require('../../utils');
const api = require('../../api');

const sockets = require('..');

module.exports = function (SocketPosts) {
	SocketPosts.loadPostTools = async function (socket, data) {
		if (!data || !data.pid || !data.cid) {
			throw new Error('[[error:invalid-data]]');
		}

		const results = await utils.promiseParallel({
			posts: posts.getPostFields(data.pid, ['deleted', 'bookmarks', 'uid', 'ip', 'flagId']),
			isAdmin: user.isAdministrator(socket.uid),
			isGlobalMod: user.isGlobalModerator(socket.uid),
			isModerator: user.isModerator(socket.uid, data.cid),
			canEdit: privileges.posts.canEdit(data.pid, socket.uid),
			canDelete: privileges.posts.canDelete(data.pid, socket.uid),
			canPurge: privileges.posts.canPurge(data.pid, socket.uid),
			canFlag: privileges.posts.canFlag(data.pid, socket.uid),
			flagged: flags.exists('post', data.pid, socket.uid),	// specifically, whether THIS calling user flagged
			bookmarked: posts.hasBookmarked(data.pid, socket.uid),
			postSharing: social.getActivePostSharing(),
			history: posts.diffs.exists(data.pid),
			canViewInfo: privileges.global.can('view:users:info', socket.uid),
		});

		const postData = results.posts;
		postData.bookmarked = results.bookmarked;
		postData.selfPost = socket.uid && socket.uid === postData.uid;
		postData.display_edit_tools = results.canEdit.flag;
		postData.display_delete_tools = results.canDelete.flag;
		postData.display_purge_tools = results.canPurge;
		postData.display_flag_tools = socket.uid && results.canFlag.flag;
		postData.display_moderator_tools = postData.display_edit_tools || postData.display_delete_tools;
		postData.display_move_tools = results.isAdmin || results.isModerator;
		postData.display_change_owner_tools = results.isAdmin || results.isModerator;
		postData.display_ip_ban = (results.isAdmin || results.isGlobalMod) && !postData.selfPost;
		postData.display_history = results.history;
		postData.flags = {
			flagId: parseInt(results.posts.flagId, 10) || null,
			can: results.canFlag.flag,
			exists: !!results.posts.flagId,
			flagged: results.flagged,
		};

		if (!results.isAdmin && !results.canViewInfo) {
			postData.ip = undefined;
		}
		const tools = await plugins.hooks.fire('filter:post.tools', {
			pid: data.pid,
			post: postData,
			uid: socket.uid,
			tools: [],
		});
		postData.tools = tools.tools;
		return results;
	};

	SocketPosts.delete = async function (socket, data) {
		sockets.warnDeprecated(socket, 'DELETE /api/v3/posts/:pid/state');
		await api.posts.delete(socket, data);
	};

	SocketPosts.restore = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid/state');
		await api.posts.restore(socket, data);
	};

	SocketPosts.deletePosts = async function (socket, data) {
		await deletePurgePosts(socket, data, 'delete');
	};

	SocketPosts.purgePosts = async function (socket, data) {
		await deletePurgePosts(socket, data, 'purge');
	};

	async function deletePurgePosts(socket, data, command) {
		if (!data || !Array.isArray(data.pids)) {
			throw new Error('[[error:invalid-data]]');
		}
		for (const pid of data.pids) {
			/* eslint-disable no-await-in-loop */
			await SocketPosts[command](socket, { pid: pid });
		}
	}

	SocketPosts.purge = async function (socket, data) {
		sockets.warnDeprecated(socket, 'DELETE /api/v3/posts/:pid');
		await api.posts.purge(socket, data);
	};

	SocketPosts.changeOwner = async function (socket, data) {
		if (!data || !Array.isArray(data.pids) || !data.toUid) {
			throw new Error('[[error:invalid-data]]');
		}
		const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(socket.uid);
		if (!isAdminOrGlobalMod) {
			throw new Error('[[error:no-privileges]]');
		}

		const postData = await posts.changeOwner(data.pids, data.toUid);
		const logs = postData.map(({ pid, uid, cid }) => (events.log({
			type: 'post-change-owner',
			uid: socket.uid,
			ip: socket.ip,
			targetUid: data.toUid,
			pid: pid,
			originalUid: uid,
			cid: cid,
		})));
'use strict';

const api = require('../../api');
const websockets = require('..');

module.exports = function (SocketPosts) {
	SocketPosts.getDiffs = async function (socket, data) {
		websockets.warnDeprecated(socket, 'GET /api/v3/posts/:pid/diffs');
		return await api.posts.getDiffs(socket, data);
	};

	SocketPosts.showPostAt = async function (socket, data) {
		websockets.warnDeprecated(socket, 'GET /api/v3/posts/:pid/diffs/:since');
		return await api.posts.loadDiff(socket, data);
	};

	SocketPosts.restoreDiff = async function (socket, data) {
		websockets.warnDeprecated(socket, 'PUT /api/v3/posts/:pid/diffs/:since');
		return await api.posts.restoreDiff(socket, data);
	};
'use strict';

const validator = require('validator');

const db = require('../database');
const meta = require('../meta');
const notifications = require('../notifications');
const plugins = require('../plugins');
const Messaging = require('../messaging');
const utils = require('../utils');
const server = require('./index');
const user = require('../user');
const privileges = require('../privileges');

const SocketModules = module.exports;

SocketModules.chats = {};
SocketModules.settings = {};

/* Chat */

SocketModules.chats.getRaw = async function (socket, data) {
	if (!data || !data.hasOwnProperty('mid')) {
		throw new Error('[[error:invalid-data]]');
	}
	const roomId = await Messaging.getMessageField(data.mid, 'roomId');
	const [isAdmin, hasMessage, inRoom] = await Promise.all([
		user.isAdministrator(socket.uid),
		db.isSortedSetMember(`uid:${socket.uid}:chat:room:${roomId}:mids`, data.mid),
		Messaging.isUserInRoom(socket.uid, roomId),
	]);

	if (!isAdmin && (!inRoom || !hasMessage)) {
		throw new Error('[[error:not-allowed]]');
	}

	return await Messaging.getMessageField(data.mid, 'content');
};

SocketModules.chats.isDnD = async function (socket, uid) {
	const status = await db.getObjectField(`user:${uid}`, 'status');
	return status === 'dnd';
};

SocketModules.chats.newRoom = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}

	if (rateLimitExceeded(socket)) {
		throw new Error('[[error:too-many-messages]]');
	}

	const canChat = await privileges.global.can('chat', socket.uid);
	if (!canChat) {
		throw new Error('[[error:no-privileges]]');
	}
	await Messaging.canMessageUser(socket.uid, data.touid);
	return await Messaging.newRoom(socket.uid, [data.touid]);
};

SocketModules.chats.send = async function (socket, data) {
	if (!data || !data.roomId || !socket.uid) {
		throw new Error('[[error:invalid-data]]');
	}

	if (rateLimitExceeded(socket)) {
		throw new Error('[[error:too-many-messages]]');
	}
	const canChat = await privileges.global.can('chat', socket.uid);
	if (!canChat) {
		throw new Error('[[error:no-privileges]]');
	}
	const results = await plugins.hooks.fire('filter:messaging.send', {
		data: data,
		uid: socket.uid,
	});
	data = results.data;

	await Messaging.canMessageRoom(socket.uid, data.roomId);
	const message = await Messaging.sendMessage({
		uid: socket.uid,
		roomId: data.roomId,
		content: data.message,
		timestamp: Date.now(),
		ip: socket.ip,
	});
	Messaging.notifyUsersInRoom(socket.uid, data.roomId, message);
	user.updateOnlineUsers(socket.uid);
	return message;
};

function rateLimitExceeded(socket) {
	const now = Date.now();
	socket.lastChatMessageTime = socket.lastChatMessageTime || 0;
	if (now - socket.lastChatMessageTime < meta.config.chatMessageDelay) {
		return true;
	}
	socket.lastChatMessageTime = now;
	return false;
}

SocketModules.chats.loadRoom = async function (socket, data) {
	if (!data || !data.roomId) {
		throw new Error('[[error:invalid-data]]');
	}

	return await Messaging.loadRoom(socket.uid, data);
};

SocketModules.chats.getUsersInRoom = async function (socket, data) {
	if (!data || !data.roomId) {
		throw new Error('[[error:invalid-data]]');
	}
	const [isUserInRoom, isOwner, userData] = await Promise.all([
		Messaging.isUserInRoom(socket.uid, data.roomId),
		Messaging.isRoomOwner(socket.uid, data.roomId),
		Messaging.getUsersInRoom(data.roomId, 0, -1),
	]);
	if (!isUserInRoom) {
		throw new Error('[[error:no-privileges]]');
	}
	userData.forEach((user) => {
		user.canKick = (parseInt(user.uid, 10) !== parseInt(socket.uid, 10)) && isOwner;
	});
	return userData;
};

SocketModules.chats.addUserToRoom = async function (socket, data) {
	if (!data || !data.roomId || !data.username) {
		throw new Error('[[error:invalid-data]]');
	}

	const canChat = await privileges.global.can('chat', socket.uid);
	if (!canChat) {
		throw new Error('[[error:no-privileges]]');
	}

	const userCount = await Messaging.getUserCountInRoom(data.roomId);
	const maxUsers = meta.config.maximumUsersInChatRoom;
	if (maxUsers && userCount >= maxUsers) {
		throw new Error('[[error:cant-add-more-users-to-chat-room]]');
	}

	const uid = await user.getUidByUsername(data.username);
	if (!uid) {
		throw new Error('[[error:no-user]]');
	}
	if (socket.uid === parseInt(uid, 10)) {
		throw new Error('[[error:cant-chat-with-yourself]]');
	}
	const [settings, isAdminOrGlobalMod, isFollowing] = await Promise.all([
		user.getSettings(uid),
		user.isAdminOrGlobalMod(socket.uid),
		user.isFollowing(uid, socket.uid),
	]);

	if (settings.restrictChat && !isAdminOrGlobalMod && !isFollowing) {
		throw new Error('[[error:chat-restricted]]');
	}

	await Messaging.addUsersToRoom(socket.uid, [uid], data.roomId);
};

SocketModules.chats.removeUserFromRoom = async function (socket, data) {
	if (!data || !data.roomId) {
		throw new Error('[[error:invalid-data]]');
	}
	const exists = await user.exists(data.uid);
	if (!exists) {
		throw new Error('[[error:no-user]]');
	}

	await Messaging.removeUsersFromRoom(socket.uid, [data.uid], data.roomId);
};

SocketModules.chats.leave = async function (socket, roomid) {
	if (!socket.uid || !roomid) {
		throw new Error('[[error:invalid-data]]');
	}

	await Messaging.leaveRoom([socket.uid], roomid);
};

SocketModules.chats.edit = async function (socket, data) {
	if (!data || !data.roomId || !data.message) {
		throw new Error('[[error:invalid-data]]');
	}
	await Messaging.canEdit(data.mid, socket.uid);
	await Messaging.editMessage(socket.uid, data.mid, data.roomId, data.message);
};

SocketModules.chats.delete = async function (socket, data) {
	if (!data || !data.roomId || !data.messageId) {
		throw new Error('[[error:invalid-data]]');
	}
	await Messaging.canDelete(data.messageId, socket.uid);
	await Messaging.deleteMessage(data.messageId, socket.uid);
};

SocketModules.chats.restore = async function (socket, data) {
	if (!data || !data.roomId || !data.messageId) {
		throw new Error('[[error:invalid-data]]');
	}
	await Messaging.canDelete(data.messageId, socket.uid);
	await Messaging.restoreMessage(data.messageId, socket.uid);
};

SocketModules.chats.canMessage = async function (socket, roomId) {
	await Messaging.canMessageRoom(socket.uid, roomId);
};

SocketModules.chats.markRead = async function (socket, roomId) {
	if (!socket.uid || !roomId) {
		throw new Error('[[error:invalid-data]]');
	}
	const [uidsInRoom] = await Promise.all([
		Messaging.getUidsInRoom(roomId, 0, -1),
		Messaging.markRead(socket.uid, roomId),
	]);

	Messaging.pushUnreadCount(socket.uid);
	server.in(`uid_${socket.uid}`).emit('event:chats.markedAsRead', { roomId: roomId });

	if (!uidsInRoom.includes(String(socket.uid))) {
		return;
	}

	// Mark notification read
	const nids = uidsInRoom.filter(uid => parseInt(uid, 10) !== socket.uid)
		.map(uid => `chat_${uid}_${roomId}`);

	await notifications.markReadMultiple(nids, socket.uid);
	await user.notifications.pushCount(socket.uid);
};

SocketModules.chats.markAllRead = async function (socket) {
	await Messaging.markAllRead(socket.uid);
	Messaging.pushUnreadCount(socket.uid);
};

SocketModules.chats.renameRoom = async function (socket, data) {
	if (!data || !data.roomId || !data.newName) {
		throw new Error('[[error:invalid-data]]');
	}
	await Messaging.renameRoom(socket.uid, data.roomId, data.newName);
	const uids = await Messaging.getUidsInRoom(data.roomId, 0, -1);
	const eventData = { roomId: data.roomId, newName: validator.escape(String(data.newName)) };
	uids.forEach((uid) => {
		server.in(`uid_${uid}`).emit('event:chats.roomRename', eventData);
	});
};

SocketModules.chats.getRecentChats = async function (socket, data) {
	if (!data || !utils.isNumber(data.after) || !utils.isNumber(data.uid)) {
		throw new Error('[[error:invalid-data]]');
	}
	const start = parseInt(data.after, 10);
	const stop = start + 9;
	return await Messaging.getRecentChats(socket.uid, data.uid, start, stop);
};

SocketModules.chats.hasPrivateChat = async function (socket, uid) {
	if (socket.uid <= 0 || uid <= 0) {
		throw new Error('[[error:invalid-data]]');
	}
	return await Messaging.hasPrivateChat(socket.uid, uid);
};

SocketModules.chats.getMessages = async function (socket, data) {
	if (!socket.uid || !data || !data.uid || !data.roomId) {
		throw new Error('[[error:invalid-data]]');
	}

	return await Messaging.getMessages({
		callerUid: socket.uid,
		uid: data.uid,
		roomId: data.roomId,
		start: parseInt(data.start, 10) || 0,
		count: 50,
	});
};

SocketModules.chats.getIP = async function (socket, mid) {
	const allowed = await privileges.global.can('view:users:info', socket.uid);
	if (!allowed) {
		throw new Error('[[error:no-privilege]]');
	}
	return await Messaging.getMessageField(mid, 'ip');
};
'use strict';

const user = require('../../user');
const events = require('../../events');

module.exports = function (SocketUser) {
	SocketUser.acceptRegistration = async function (socket, data) {
		const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(socket.uid);
		if (!isAdminOrGlobalMod) {
			throw new Error('[[error:no-privileges]]');
		}
		const uid = await user.acceptRegistration(data.username);
		await events.log({
			type: 'registration-approved',
			uid: socket.uid,
			ip: socket.ip,
			targetUid: uid,
		});
		return uid;
	};

	SocketUser.rejectRegistration = async function (socket, data) {
		const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(socket.uid);
		if (!isAdminOrGlobalMod) {
			throw new Error('[[error:no-privileges]]');
		}
		await user.rejectRegistration(data.username);
		await events.log({
			type: 'registration-rejected',
			uid: socket.uid,
			ip: socket.ip,
			username: data.username,
		});
	};

	SocketUser.deleteInvitation = async function (socket, data) {
		const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(socket.uid);
		if (!isAdminOrGlobalMod) {
			throw new Error('[[error:no-privileges]]');
		}
'use strict';

const path = require('path');
const nconf = require('nconf');

const user = require('../../user');
const plugins = require('../../plugins');
const file = require('../../file');

module.exports = function (SocketUser) {
	SocketUser.changePicture = async function (socket, data) {
		if (!socket.uid) {
			throw new Error('[[error:invalid-uid]]');
		}

		if (!data) {
			throw new Error('[[error:invalid-data]]');
		}

		const { type } = data;
		let picture = '';
		await user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);
		if (type === 'default') {
			picture = '';
		} else if (type === 'uploaded') {
			picture = await user.getUserField(data.uid, 'uploadedpicture');
		} else {
			const returnData = await plugins.hooks.fire('filter:user.getPicture', {
				uid: socket.uid,
				type: type,
				picture: undefined,
			});
			picture = returnData && returnData.picture;
		}

		const validBackgrounds = await user.getIconBackgrounds(socket.uid);
		if (!validBackgrounds.includes(data.bgColor)) {
			data.bgColor = validBackgrounds[0];
		}

		await user.setUserFields(data.uid, {
			picture,
			'icon:bgColor': data.bgColor,
		});
	};

	SocketUser.removeUploadedPicture = async function (socket, data) {
		if (!socket.uid || !data || !data.uid) {
			throw new Error('[[error:invalid-data]]');
		}
		await user.isAdminOrSelf(socket.uid, data.uid);
		const userData = await user.getUserFields(data.uid, ['uploadedpicture', 'picture']);
		if (userData.uploadedpicture && !userData.uploadedpicture.startsWith('http')) {
			const pathToFile = path.join(nconf.get('base_dir'), 'public', userData.uploadedpicture);
			if (pathToFile.startsWith(nconf.get('upload_path'))) {
				file.delete(pathToFile);
			}
		}
		await user.setUserFields(data.uid, {
			uploadedpicture: '',
			// if current picture is uploaded picture, reset to user icon
			picture: userData.uploadedpicture === userData.picture ? '' : userData.picture,
		});
		plugins.hooks.fire('action:user.removeUploadedPicture', {
			callerUid: socket.uid,
			uid: data.uid,
			user: userData,
		});
	};

	SocketUser.getProfilePictures = async function (socket, data) {
		if (!data || !data.uid) {
			throw new Error('[[error:invalid-data]]');
		}

		const [list, uploaded] = await Promise.all([
			plugins.hooks.fire('filter:user.listPictures', {
				uid: data.uid,
				pictures: [],
			}),
			user.getUserField(data.uid, 'uploadedpicture'),
		]);

		if (uploaded) {
			list.pictures.push({
				type: 'uploaded',
				url: uploaded,
				text: '[[user:uploaded_picture]]',
			});
		}
'use strict';

const pagination = require('../../pagination');
const api = require('../../api');
const sockets = require('..');

module.exports = function (SocketUser) {
	SocketUser.search = async function (socket, data) {
		sockets.warnDeprecated(socket, 'GET /api/users');
		if (!data) {
			throw new Error('[[error:invalid-data]]');
		}
		const result = api.users.search(socket, data);
		result.pagination = pagination.create(data.page, result.pageCount);
		return result;
'use strict';

const api = require('../../api');
const websockets = require('../index');

module.exports = function (SocketUser) {
	SocketUser.banUsers = async function (socket, data) {
		websockets.warnDeprecated(socket, 'PUT /api/v3/users/:uid/ban');
		await Promise.all(data.uids.map(async (uid) => {
			const payload = { ...data };
			delete payload.uids;
			payload.uid = uid;
			await api.users.ban(socket, payload);
		}));
	};

	SocketUser.unbanUsers = async function (socket, uids) {
		websockets.warnDeprecated(socket, 'DELETE /api/v3/users/:uid/ban');
		await Promise.all(uids.map(async (uid) => {
			await api.users.unban(socket, { uid });
'use strict';

const winston = require('winston');

const api = require('../../api');
const user = require('../../user');
const events = require('../../events');
const notifications = require('../../notifications');
const db = require('../../database');
const plugins = require('../../plugins');
const sockets = require('..');

module.exports = function (SocketUser) {
	SocketUser.changeUsernameEmail = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/users/:uid');

		if (!data || !data.uid || !socket.uid) {
			throw new Error('[[error:invalid-data]]');
		}
		await isPrivilegedOrSelfAndPasswordMatch(socket, data);
		return await SocketUser.updateProfile(socket, data);
	};

	SocketUser.updateCover = async function (socket, data) {
		if (!socket.uid) {
			throw new Error('[[error:no-privileges]]');
		}
		await user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);
		await user.checkMinReputation(socket.uid, data.uid, 'min:rep:cover-picture');
		return await user.updateCoverPicture(data);
	};

	SocketUser.uploadCroppedPicture = async function (socket, data) {
		if (!socket.uid) {
			throw new Error('[[error:no-privileges]]');
		}
		await user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);
		await user.checkMinReputation(socket.uid, data.uid, 'min:rep:profile-picture');
		return await user.uploadCroppedPicture(data);
	};

	SocketUser.removeCover = async function (socket, data) {
		if (!socket.uid) {
			throw new Error('[[error:no-privileges]]');
		}
		await user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);
		const userData = await user.getUserFields(data.uid, ['cover:url']);
		await user.removeCoverPicture(data);
		plugins.hooks.fire('action:user.removeCoverPicture', {
			callerUid: socket.uid,
			uid: data.uid,
			user: userData,
		});
	};

	async function isPrivilegedOrSelfAndPasswordMatch(socket, data) {
		const { uid } = socket;
		const isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);

		const [isAdmin, isTargetAdmin, isGlobalMod] = await Promise.all([
			user.isAdministrator(uid),
			user.isAdministrator(data.uid),
			user.isGlobalModerator(uid),
		]);

		if ((isTargetAdmin && !isAdmin) || (!isSelf && !(isAdmin || isGlobalMod))) {
			throw new Error('[[error:no-privileges]]');
		}
		const [hasPassword, passwordMatch] = await Promise.all([
			user.hasPassword(data.uid),
			data.password ? user.isPasswordCorrect(data.uid, data.password, socket.ip) : false,
		]);

		if (isSelf && hasPassword && !passwordMatch) {
			throw new Error('[[error:invalid-password]]');
		}
	}

	SocketUser.changePassword = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/users/:uid/password');
		await api.users.changePassword(socket, data);
	};

	SocketUser.updateProfile = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/users/:uid');
		return await api.users.update(socket, data);
	};

	SocketUser.toggleBlock = async function (socket, data) {
		const [is] = await Promise.all([
			user.blocks.is(data.blockeeUid, data.blockerUid),
			user.blocks.can(socket.uid, data.blockerUid, data.blockeeUid),
		]);
		const isBlocked = is;
		await user.blocks[isBlocked ? 'remove' : 'add'](data.blockeeUid, data.blockerUid);
		return !isBlocked;
	};

	SocketUser.exportProfile = async function (socket, data) {
		await doExport(socket, data, 'profile');
	};

	SocketUser.exportPosts = async function (socket, data) {
		await doExport(socket, data, 'posts');
	};

	SocketUser.exportUploads = async function (socket, data) {
		await doExport(socket, data, 'uploads');
	};

	async function doExport(socket, data, type) {
		if (!socket.uid) {
			throw new Error('[[error:invalid-uid]]');
		}

		if (!data || !(parseInt(data.uid, 10) > 0)) {
			throw new Error('[[error:invalid-data]]');
		}

		await user.isAdminOrSelf(socket.uid, data.uid);

		const count = await db.incrObjectField('locks', `export:${data.uid}${type}`);
		if (count > 1) {
			throw new Error('[[error:already-exporting]]');
		}

		const child = require('child_process').fork(`./src/user/jobs/export-${type}.js`, [], {
			env: process.env,
		});
		child.send({ uid: data.uid });
		child.on('error', async (err) => {
			winston.error(err.stack);
			await db.deleteObjectField('locks', `export:${data.uid}${type}`);
		});
		child.on('exit', async () => {
			await db.deleteObjectField('locks', `export:${data.uid}${type}`);
			const userData = await user.getUserFields(data.uid, ['username', 'userslug']);
			const n = await notifications.create({
				bodyShort: `[[notifications:${type}-exported, ${userData.username}]]`,
				path: `/api/user/uid/${userData.userslug}/export/${type}`,
				nid: `${type}:export:${data.uid}`,
				from: data.uid,
			});
			await notifications.push(n, [socket.uid]);
			await events.log({
				type: `export:${type}`,
				uid: socket.uid,
				targetUid: data.uid,
				ip: socket.ip,
			});
'use strict';

const user = require('../../user');
const websockets = require('../index');

module.exports = function (SocketUser) {
	SocketUser.checkStatus = async function (socket, uid) {
		if (!socket.uid) {
			throw new Error('[[error:invalid-uid]]');
		}
		const userData = await user.getUserFields(uid, ['lastonline', 'status']);
		return user.getStatus(userData);
	};

	SocketUser.setStatus = async function (socket, status) {
		if (socket.uid <= 0) {
			throw new Error('[[error:invalid-uid]]');
		}

		const allowedStatus = ['online', 'offline', 'dnd', 'away'];
		if (!allowedStatus.includes(status)) {
			throw new Error('[[error:invalid-user-status]]');
		}

		const userData = { status: status };
		if (status !== 'offline') {
			userData.lastonline = Date.now();
		}
		await user.setUserFields(socket.uid, userData);
		if (status !== 'offline') {
			await user.updateOnlineUsers(socket.uid);
		}
		const eventData = {
			uid: socket.uid,
			status: status,
'use strict';

const api = require('../api');
const topics = require('../topics');
const user = require('../user');
const meta = require('../meta');
const privileges = require('../privileges');
const sockets = require('.');

const SocketTopics = module.exports;

require('./topics/unread')(SocketTopics);
require('./topics/move')(SocketTopics);
require('./topics/tools')(SocketTopics);
require('./topics/infinitescroll')(SocketTopics);
require('./topics/tags')(SocketTopics);
require('./topics/merge')(SocketTopics);

SocketTopics.post = async function (socket, data) {
	sockets.warnDeprecated(socket, 'POST /api/v3/topics');
	return await api.topics.create(socket, data);
};

SocketTopics.postcount = async function (socket, tid) {
	const canRead = await privileges.topics.can('topics:read', tid, socket.uid);
	if (!canRead) {
		throw new Error('[[no-privileges]]');
	}
	return await topics.getTopicField(tid, 'postcount');
};

SocketTopics.bookmark = async function (socket, data) {
	if (!socket.uid || !data) {
		throw new Error('[[error:invalid-data]]');
	}
	const postcount = await topics.getTopicField(data.tid, 'postcount');
	if (data.index > meta.config.bookmarkThreshold && postcount > meta.config.bookmarkThreshold) {
		await topics.setUserBookmark(data.tid, socket.uid, data.index);
	}
};

SocketTopics.createTopicFromPosts = async function (socket, data) {
	if (!socket.uid) {
		throw new Error('[[error:not-logged-in]]');
	}

	if (!data || !data.title || !data.pids || !Array.isArray(data.pids)) {
		throw new Error('[[error:invalid-data]]');
	}

	return await topics.createTopicFromPosts(socket.uid, data.title, data.pids, data.fromTid);
};

SocketTopics.changeWatching = async function (socket, data) {
	if (!data || !data.tid || !data.type) {
		throw new Error('[[error:invalid-data]]');
	}
	const commands = ['follow', 'unfollow', 'ignore'];
	if (!commands.includes(data.type)) {
		throw new Error('[[error:invalid-command]]');
	}

	sockets.warnDeprecated(socket, 'PUT/DELETE /api/v3/topics/:tid/(follow|ignore)');
	await followCommand(data.type, socket, data.tid);
};

SocketTopics.follow = async function (socket, tid) {
	sockets.warnDeprecated(socket, 'PUT /api/v3/topics/:tid/follow');
	await followCommand('follow', socket, tid);
};

async function followCommand(method, socket, tid) {
	if (!socket.uid) {
		throw new Error('[[error:not-logged-in]]');
	}

	await api.topics[method](socket, { tid });
}

SocketTopics.isFollowed = async function (socket, tid) {
	const isFollowing = await topics.isFollowing([tid], socket.uid);
	return isFollowing[0];
};

SocketTopics.search = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	return await topics.search(data.tid, data.term);
};

SocketTopics.isModerator = async function (socket, tid) {
	const cid = await topics.getTopicField(tid, 'cid');
	return await user.isModerator(socket.uid, cid);
};

SocketTopics.getTopic = async function (socket, tid) {
	sockets.warnDeprecated(socket, 'GET /api/v3/topics/:tid');
	return await api.topics.get(socket, { tid });
};

'use strict';

const user = require('../user');
const meta = require('../meta');
const events = require('../events');

const SocketBlacklist = module.exports;

SocketBlacklist.validate = async function (socket, data) {
	return meta.blacklist.validate(data.rules);
};

SocketBlacklist.save = async function (socket, rules) {
	await blacklist(socket, 'save', rules);
};

SocketBlacklist.addRule = async function (socket, rule) {
	await blacklist(socket, 'addRule', rule);
};

async function blacklist(socket, method, rule) {
	const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(socket.uid);
	if (!isAdminOrGlobalMod) {
		throw new Error('[[error:no-privileges]]');
	}
	await meta.blacklist[method](rule);
	await events.log({
		type: `ip-blacklist-${method}`,
		uid: socket.uid,
		ip: socket.ip,
		rule: rule,
	});
}

'use strict';

const _ = require('lodash');

const db = require('../database');
const websockets = require('./index');
const user = require('../user');
const posts = require('../posts');
const topics = require('../topics');
const categories = require('../categories');
const privileges = require('../privileges');
const notifications = require('../notifications');
const plugins = require('../plugins');
const utils = require('../utils');
const batch = require('../batch');
const apiHelpers = require('../api/helpers');

const SocketHelpers = module.exports;

SocketHelpers.setDefaultPostData = function (data, socket) {
	data.uid = socket.uid;
	data.req = apiHelpers.buildReqObject(socket);
	data.timestamp = Date.now();
	data.fromQueue = false;
};

SocketHelpers.notifyNew = async function (uid, type, result) {
	let uids = await user.getUidsFromSet('users:online', 0, -1);
	uids = uids.filter(toUid => parseInt(toUid, 10) !== uid);
	await batch.processArray(uids, async (uids) => {
		await notifyUids(uid, uids, type, result);
	}, {
		interval: 1000,
	});
};

async function notifyUids(uid, uids, type, result) {
	const post = result.posts[0];
	const { tid } = post.topic;
	const { cid } = post.topic;
	uids = await privileges.topics.filterUids('topics:read', tid, uids);
	const watchStateUids = uids;

	const watchStates = await getWatchStates(watchStateUids, tid, cid);

	const categoryWatchStates = _.zipObject(watchStateUids, watchStates.categoryWatchStates);
	const topicFollowState = _.zipObject(watchStateUids, watchStates.topicFollowed);
	uids = filterTidCidIgnorers(watchStateUids, watchStates);
	uids = await user.blocks.filterUids(uid, uids);
	uids = await user.blocks.filterUids(post.topic.uid, uids);
	const data = await plugins.hooks.fire('filter:sockets.sendNewPostToUids', { uidsTo: uids, uidFrom: uid, type: type });

	post.ip = undefined;

	data.uidsTo.forEach((toUid) => {
		post.categoryWatchState = categoryWatchStates[toUid];
		post.topic.isFollowing = topicFollowState[toUid];
		websockets.in(`uid_${toUid}`).emit('event:new_post', result);
		if (result.topic && type === 'newTopic') {
			websockets.in(`uid_${toUid}`).emit('event:new_topic', result.topic);
		}
	});
}

async function getWatchStates(uids, tid, cid) {
	return await utils.promiseParallel({
		topicFollowed: db.isSetMembers(`tid:${tid}:followers`, uids),
		topicIgnored: db.isSetMembers(`tid:${tid}:ignorers`, uids),
		categoryWatchStates: categories.getUidsWatchStates(cid, uids),
	});
}

function filterTidCidIgnorers(uids, watchStates) {
	return uids.filter((uid, index) => watchStates.topicFollowed[index] ||
			(!watchStates.topicIgnored[index] && watchStates.categoryWatchStates[index] !== categories.watchStates.ignoring));
}

SocketHelpers.sendNotificationToPostOwner = async function (pid, fromuid, command, notification) {
	if (!pid || !fromuid || !notification) {
		return;
	}
	fromuid = parseInt(fromuid, 10);
	const postData = await posts.getPostFields(pid, ['tid', 'uid', 'content']);
	const [canRead, isIgnoring] = await Promise.all([
		privileges.posts.can('topics:read', pid, postData.uid),
		topics.isIgnoring([postData.tid], postData.uid),
	]);
	if (!canRead || isIgnoring[0] || !postData.uid || fromuid === postData.uid) {
		return;
	}
	const [username, topicTitle, postObj] = await Promise.all([
		user.getUserField(fromuid, 'username'),
		topics.getTopicField(postData.tid, 'title'),
		posts.parsePost(postData),
	]);

	const title = utils.decodeHTMLEntities(topicTitle);
	const titleEscaped = title.replace(/%/g, '&#37;').replace(/,/g, '&#44;');

	const notifObj = await notifications.create({
		type: command,
		bodyShort: `[[${notification}, ${username}, ${titleEscaped}]]`,
		bodyLong: postObj.content,
		pid: pid,
		tid: postData.tid,
		path: `/post/${pid}`,
		nid: `${command}:post:${pid}:uid:${fromuid}`,
		from: fromuid,
		mergeId: `${notification}|${pid}`,
		topicTitle: topicTitle,
	});

	notifications.push(notifObj, [postData.uid]);
};


SocketHelpers.sendNotificationToTopicOwner = async function (tid, fromuid, command, notification) {
	if (!tid || !fromuid || !notification) {
		return;
	}

	fromuid = parseInt(fromuid, 10);

	const [username, topicData] = await Promise.all([
		user.getUserField(fromuid, 'username'),
		topics.getTopicFields(tid, ['uid', 'slug', 'title']),
	]);

	if (fromuid === topicData.uid) {
		return;
	}
	const ownerUid = topicData.uid;
	const title = utils.decodeHTMLEntities(topicData.title);
	const titleEscaped = title.replace(/%/g, '&#37;').replace(/,/g, '&#44;');

	const notifObj = await notifications.create({
		bodyShort: `[[${notification}, ${username}, ${titleEscaped}]]`,
		path: `/topic/${topicData.slug}`,
		nid: `${command}:tid:${tid}:uid:${fromuid}`,
		from: fromuid,
	});

	if (ownerUid) {
		notifications.push(notifObj, [ownerUid]);
	}
};

SocketHelpers.upvote = async function (data, notification) {
	if (!data || !data.post || !data.post.uid || !data.post.votes || !data.post.pid || !data.fromuid) {
		return;
	}

	const { votes } = data.post;
	const touid = data.post.uid;
	const { fromuid } = data;
	const { pid } = data.post;

	const shouldNotify = {
		all: function () {
			return votes > 0;
		},
		first: function () {
			return votes === 1;
		},
		everyTen: function () {
			return votes > 0 && votes % 10 === 0;
		},
		threshold: function () {
			return [1, 5, 10, 25].includes(votes) || (votes >= 50 && votes % 50 === 0);
		},
		logarithmic: function () {
			return votes > 1 && Math.log10(votes) % 1 === 0;
		},
		disabled: function () {
			return false;
		},
	};
	const settings = await user.getSettings(touid);
	const should = shouldNotify[settings.upvoteNotifFreq] || shouldNotify.all;

	if (should()) {
		SocketHelpers.sendNotificationToPostOwner(pid, fromuid, 'upvote', notification);
	}
};

SocketHelpers.rescindUpvoteNotification = async function (pid, fromuid) {
	await notifications.rescind(`upvote:post:${pid}:uid:${fromuid}`);
	const uid = await posts.getPostField(pid, 'uid');
	const count = await user.notifications.getUnreadCount(uid);
	websockets.in(`uid_${uid}`).emit('event:notifications.updateCount', count);
};

SocketHelpers.emitToUids = async function (event, data, uids) {
	uids.forEach(toUid => websockets.in(`uid_${toUid}`).emit(event, data));
};
'use strict';

const util = require('util');
const winston = require('winston');

const sleep = util.promisify(setTimeout);

const api = require('../api');
const user = require('../user');
const topics = require('../topics');
const messaging = require('../messaging');
const plugins = require('../plugins');
const meta = require('../meta');
const events = require('../events');
const emailer = require('../emailer');
const db = require('../database');
const userController = require('../controllers/user');
const privileges = require('../privileges');
const utils = require('../utils');
const sockets = require('.');

const SocketUser = module.exports;

require('./user/profile')(SocketUser);
require('./user/search')(SocketUser);
require('./user/status')(SocketUser);
require('./user/picture')(SocketUser);
require('./user/ban')(SocketUser);
require('./user/registration')(SocketUser);

SocketUser.exists = async function (socket, data) {
	sockets.warnDeprecated(socket, 'HEAD /api/v3/users/bySlug/:userslug *AND* HEAD /api/v3/groups/:slug');

	if (!data || !data.username) {
		throw new Error('[[error:invalid-data]]');
	}
	return await meta.userOrGroupExists(data.username);
};

SocketUser.deleteAccount = async function (socket, data) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/users/:uid/account');
	data.uid = socket.uid;
	await api.users.deleteAccount(socket, data);
};

SocketUser.emailExists = async function (socket, data) {
	if (!data || !data.email) {
		throw new Error('[[error:invalid-data]]');
	}
	return await user.email.exists(data.email);
};

SocketUser.emailConfirm = async function (socket) {
	if (!socket.uid) {
		throw new Error('[[error:no-privileges]]');
	}

	if (!meta.config.requireEmailConfirmation) {
		throw new Error('[[error:email-confirmations-are-disabled]]');
	}

	return await user.email.sendValidationEmail(socket.uid);
};


// Password Reset
SocketUser.reset = {};

SocketUser.reset.send = async function (socket, email) {
	if (!email) {
		throw new Error('[[error:invalid-data]]');
	}

	if (meta.config['password:disableEdit']) {
		throw new Error('[[error:no-privileges]]');
	}
	async function logEvent(text) {
		await events.log({
			type: 'password-reset',
			text: text,
			ip: socket.ip,
			uid: socket.uid,
			email: email,
		});
	}
	try {
		await user.reset.send(email);
		await logEvent('[[success:success]]');
		await sleep(2500);
	} catch (err) {
		await logEvent(err.message);
		const internalErrors = ['[[error:invalid-email]]', '[[error:reset-rate-limited]]'];
		if (!internalErrors.includes(err.message)) {
			throw err;
		}
	}
};

SocketUser.reset.commit = async function (socket, data) {
	if (!data || !data.code || !data.password) {
		throw new Error('[[error:invalid-data]]');
	}
	const [uid] = await Promise.all([
		db.getObjectField('reset:uid', data.code),
		user.reset.commit(data.code, data.password),
		plugins.hooks.fire('action:password.reset', { uid: socket.uid }),
	]);

	await events.log({
		type: 'password-reset',
		uid: uid,
		ip: socket.ip,
	});

	const username = await user.getUserField(uid, 'username');
	const now = new Date();
	const parsedDate = `${now.getFullYear()}/${now.getMonth() + 1}/${now.getDate()}`;
	emailer.send('reset_notify', uid, {
		username: username,
		date: parsedDate,
		subject: '[[email:reset.notify.subject]]',
	}).catch(err => winston.error(`[emailer.send] ${err.stack}`));
};

SocketUser.isFollowing = async function (socket, data) {
	if (!socket.uid || !data.uid) {
		return false;
	}

	return await user.isFollowing(socket.uid, data.uid);
};

SocketUser.follow = async function (socket, data) {
	sockets.warnDeprecated(socket, 'POST /api/v3/users/follow');
	await api.users.follow(socket, data);
};

SocketUser.unfollow = async function (socket, data) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/users/unfollow');
	await api.users.unfollow(socket, data);
};

SocketUser.saveSettings = async function (socket, data) {
	sockets.warnDeprecated(socket, 'PUT /api/v3/users/:uid/settings');
	const settings = await api.users.updateSettings(socket, data);
	return settings;
};

SocketUser.setTopicSort = async function (socket, sort) {
	sockets.warnDeprecated(socket, 'PUT /api/v3/users/:uid/setting/topicPostSort');
	await api.users.updateSetting(socket, {
		uid: socket.uid,
		setting: 'topicPostSort',
		value: sort,
	});
};

SocketUser.setCategorySort = async function (socket, sort) {
	sockets.warnDeprecated(socket, 'PUT /api/v3/users/:uid/setting/categoryTopicSort');
	await api.users.updateSetting(socket, {
		uid: socket.uid,
		setting: 'categoryTopicSort',
		value: sort,
	});
};

SocketUser.getUnreadCount = async function (socket) {
	if (!socket.uid) {
		return 0;
	}
	return await topics.getTotalUnread(socket.uid, '');
};

SocketUser.getUnreadChatCount = async function (socket) {
	if (!socket.uid) {
		return 0;
	}
	return await messaging.getUnreadCount(socket.uid);
};

SocketUser.getUnreadCounts = async function (socket) {
	if (!socket.uid) {
		return {};
	}
	const results = await utils.promiseParallel({
		unreadCounts: topics.getUnreadTids({ uid: socket.uid, count: true }),
		unreadChatCount: messaging.getUnreadCount(socket.uid),
		unreadNotificationCount: user.notifications.getUnreadCount(socket.uid),
	});
	results.unreadTopicCount = results.unreadCounts[''];
	results.unreadNewTopicCount = results.unreadCounts.new;
	results.unreadWatchedTopicCount = results.unreadCounts.watched;
	results.unreadUnrepliedTopicCount = results.unreadCounts.unreplied;
	return results;
};

SocketUser.getUserByUID = async function (socket, uid) {
	return await userController.getUserDataByField(socket.uid, 'uid', uid);
};

SocketUser.getUserByUsername = async function (socket, username) {
	return await userController.getUserDataByField(socket.uid, 'username', username);
};

SocketUser.getUserByEmail = async function (socket, email) {
	return await userController.getUserDataByField(socket.uid, 'email', email);
};

SocketUser.setModerationNote = async function (socket, data) {
	if (!socket.uid || !data || !data.uid || !data.note) {
		throw new Error('[[error:invalid-data]]');
	}
	const noteData = {
		uid: socket.uid,
		note: data.note,
		timestamp: Date.now(),
	};
	let canEdit = await privileges.users.canEdit(socket.uid, data.uid);
	if (!canEdit) {
		canEdit = await user.isModeratorOfAnyCategory(socket.uid);
	}
	if (!canEdit) {
		throw new Error('[[error:no-privileges]]');
	}

	await user.appendModerationNote({ uid: data.uid, noteData });
};

SocketUser.deleteUpload = async function (socket, data) {
	if (!data || !data.name || !data.uid) {
		throw new Error('[[error:invalid-data]]');
	}
	await user.deleteUpload(socket.uid, data.uid, data.name);
};

SocketUser.gdpr = {};

SocketUser.gdpr.consent = async function (socket) {
	await user.setUserField(socket.uid, 'gdpr_consent', 1);
};

SocketUser.gdpr.check = async function (socket, data) {
	const isAdmin = await user.isAdministrator(socket.uid);
	if (!isAdmin) {
		data.uid = socket.uid;
'use strict';


const user = require('../user');
const topics = require('../topics');

const SocketMeta = {
	rooms: {},
};

SocketMeta.reconnected = function (socket, data, callback) {
	callback = callback || function () {};
	if (socket.uid) {
		topics.pushUnreadCount(socket.uid);
		user.notifications.pushCount(socket.uid);
	}
	callback();
};

/* Rooms */

SocketMeta.rooms.enter = function (socket, data, callback) {
	if (!socket.uid) {
		return callback();
	}

	if (!data) {
		return callback(new Error('[[error:invalid-data]]'));
	}

	if (data.enter) {
		data.enter = data.enter.toString();
	}

	if (data.enter && data.enter.startsWith('uid_') && data.enter !== `uid_${socket.uid}`) {
		return callback(new Error('[[error:not-allowed]]'));
	}

	leaveCurrentRoom(socket);

	if (data.enter) {
		socket.join(data.enter);
		socket.currentRoom = data.enter;
	}
	callback();
};

SocketMeta.rooms.leaveCurrent = function (socket, data, callback) {
	if (!socket.uid || !socket.currentRoom) {
		return callback();
	}
	leaveCurrentRoom(socket);
	callback();
};

function leaveCurrentRoom(socket) {
	if (socket.currentRoom) {
		socket.leave(socket.currentRoom);
		socket.currentRoom = '';
	}
'use strict';

const os = require('os');
const nconf = require('nconf');
const winston = require('winston');
const util = require('util');
const validator = require('validator');
const cookieParser = require('cookie-parser')(nconf.get('secret'));

const db = require('../database');
const user = require('../user');
const logger = require('../logger');
const plugins = require('../plugins');
const ratelimit = require('../middleware/ratelimit');

const Namespaces = {};

const Sockets = module.exports;

Sockets.init = async function (server) {
	requireModules();

	const SocketIO = require('socket.io').Server;
	const io = new SocketIO({
		path: `${nconf.get('relative_path')}/socket.io`,
	});

	if (nconf.get('isCluster')) {
		// socket.io-adapter-cluster needs update
		// if (nconf.get('singleHostCluster')) {
		// 	io.adapter(require('./single-host-cluster'));
		// } else if (nconf.get('redis')) {
		if (nconf.get('redis')) {
			const adapter = await require('../database/redis').socketAdapter();
			io.adapter(adapter);
		} else {
			winston.warn('clustering detected, you should setup redis!');
		}
	}

	io.use(authorize);

	io.on('connection', onConnection);

	const opts = {
		transports: nconf.get('socket.io:transports') || ['polling', 'websocket'],
		cookie: false,
	};
	/*
	 * Restrict socket.io listener to cookie domain. If none is set, infer based on url.
	 * Production only so you don't get accidentally locked out.
	 * Can be overridden via config (socket.io:origins)
	 */
	if (process.env.NODE_ENV !== 'development') {
		const origins = nconf.get('socket.io:origins');
		opts.cors = {
			origin: origins,
			methods: ['GET', 'POST'],
			allowedHeaders: ['content-type'],
		};
		winston.info(`[socket.io] Restricting access to origin: ${origins}`);
	}

	io.listen(server, opts);
	Sockets.server = io;
};

function onConnection(socket) {
	socket.ip = (socket.request.headers['x-forwarded-for'] || socket.request.connection.remoteAddress || '').split(',')[0];
	socket.request.ip = socket.ip;
	logger.io_one(socket, socket.uid);

	onConnect(socket);
	socket.onAny((event, ...args) => {
		const payload = { data: [event].concat(args) };
		onMessage(socket, payload);
	});

	socket.on('disconnect', () => {
		onDisconnect(socket);
	});
}

function onDisconnect(socket) {
	require('./uploads').clear(socket.id);
	plugins.hooks.fire('action:sockets.disconnect', { socket: socket });
}

function onConnect(socket) {
	if (socket.uid) {
		socket.join(`uid_${socket.uid}`);
		socket.join('online_users');
	} else {
		socket.join('online_guests');
	}

	socket.join(`sess_${socket.request.signedCookies[nconf.get('sessionKey')]}`);
	socket.emit('checkSession', socket.uid);
	socket.emit('setHostname', os.hostname());
	plugins.hooks.fire('action:sockets.connect', { socket: socket });
}

async function onMessage(socket, payload) {
	if (!payload.data.length) {
		return winston.warn('[socket.io] Empty payload');
	}

	const eventName = payload.data[0];
	const params = typeof payload.data[1] === 'function' ? {} : payload.data[1];
	const callback = typeof payload.data[payload.data.length - 1] === 'function' ? payload.data[payload.data.length - 1] : function () {};

	if (!eventName) {
		return winston.warn('[socket.io] Empty method name');
	}

	const parts = eventName.toString().split('.');
	const namespace = parts[0];
	const methodToCall = parts.reduce((prev, cur) => {
		if (prev !== null && prev[cur]) {
			return prev[cur];
		}
		return null;
	}, Namespaces);

	if (!methodToCall || typeof methodToCall !== 'function') {
		if (process.env.NODE_ENV === 'development') {
			winston.warn(`[socket.io] Unrecognized message: ${eventName}`);
		}
		const escapedName = validator.escape(String(eventName));
		return callback({ message: `[[error:invalid-event, ${escapedName}]]` });
	}

	socket.previousEvents = socket.previousEvents || [];
	socket.previousEvents.push(eventName);
	if (socket.previousEvents.length > 20) {
		socket.previousEvents.shift();
	}

	if (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {
		winston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);
		return socket.disconnect();
	}

	try {
		await checkMaintenance(socket);
		await validateSession(socket);

		if (Namespaces[namespace].before) {
			await Namespaces[namespace].before(socket, eventName, params);
		}

		if (methodToCall.constructor && methodToCall.constructor.name === 'AsyncFunction') {
			const result = await methodToCall(socket, params);
			callback(null, result);
		} else {
			methodToCall(socket, params, (err, result) => {
				callback(err ? { message: err.message } : null, result);
			});
		}
	} catch (err) {
		winston.error(`${eventName}\n${err.stack ? err.stack : err.message}`);
		callback({ message: err.message });
	}
}

function requireModules() {
	const modules = ['admin', 'categories', 'groups', 'meta', 'modules',
		'notifications', 'plugins', 'posts', 'topics', 'user', 'blacklist',
		'flags', 'uploads',
	];

	modules.forEach((module) => {
		Namespaces[module] = require(`./${module}`);
	});
}

async function checkMaintenance(socket) {
	const meta = require('../meta');
	if (!meta.config.maintenanceMode) {
		return;
	}
	const isAdmin = await user.isAdministrator(socket.uid);
	if (isAdmin) {
		return;
	}
	const validator = require('validator');
	throw new Error(`[[pages:maintenance.text, ${validator.escape(String(meta.config.title || 'NodeBB'))}]]`);
}

const getSessionAsync = util.promisify(
	(sid, callback) => db.sessionStore.get(sid, (err, sessionObj) => callback(err, sessionObj || null))
);

async function validateSession(socket) {
	const req = socket.request;
	if (!req.signedCookies || !req.signedCookies[nconf.get('sessionKey')]) {
		return;
	}
	const sessionData = await getSessionAsync(req.signedCookies[nconf.get('sessionKey')]);
	if (!sessionData) {
		throw new Error('[[error:invalid-session]]');
	}
	const result = await plugins.hooks.fire('static:sockets.validateSession', {
		req: req,
		socket: socket,
		session: sessionData,
	});
	return result;
}

const cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));

async function authorize(socket, callback) {
	const { request } = socket;

	if (!request) {
		return callback(new Error('[[error:not-authorized]]'));
	}

	await cookieParserAsync(request);
	const sessionData = await getSessionAsync(request.signedCookies[nconf.get('sessionKey')]);
	if (sessionData && sessionData.passport && sessionData.passport.user) {
		request.session = sessionData;
		socket.uid = parseInt(sessionData.passport.user, 10);
	} else {
		socket.uid = 0;
	}
	request.uid = socket.uid;
	callback();
}

Sockets.in = function (room) {
	return Sockets.server && Sockets.server.in(room);
};

Sockets.getUserSocketCount = function (uid) {
	return Sockets.getCountInRoom(`uid_${uid}`);
};

Sockets.getCountInRoom = function (room) {
	if (!Sockets.server) {
		return 0;
	}
	const roomMap = Sockets.server.sockets.adapter.rooms.get(room);
	return roomMap ? roomMap.size : 0;
};

Sockets.warnDeprecated = (socket, replacement) => {
	if (socket.previousEvents) {
		socket.emit('event:deprecated_call', {
			eventName: socket.previousEvents[socket.previousEvents.length - 1],
			replacement: replacement,
		});
	}
	winston.warn(`[deprecated]\n ${new Error('-').stack.split('\n').slice(2, 5).join('\n')}\n     use ${replacement}`);
'use strict';

const categories = require('../categories');
const privileges = require('../privileges');
const user = require('../user');
const topics = require('../topics');
const api = require('../api');
const sockets = require('.');

const SocketCategories = module.exports;

require('./categories/search')(SocketCategories);

SocketCategories.getRecentReplies = async function (socket, cid) {
	return await categories.getRecentReplies(cid, socket.uid, 4);
};

SocketCategories.get = async function (socket) {
	async function getCategories() {
		const cids = await categories.getCidsByPrivilege('categories:cid', socket.uid, 'find');
		return await categories.getCategoriesData(cids);
	}
	const [isAdmin, categoriesData] = await Promise.all([
		user.isAdministrator(socket.uid),
		getCategories(),
	]);
	return categoriesData.filter(category => category && (!category.disabled || isAdmin));
};

SocketCategories.getWatchedCategories = async function (socket) {
	const [categoriesData, ignoredCids] = await Promise.all([
		categories.getCategoriesByPrivilege('cid:0:children', socket.uid, 'find'),
		user.getIgnoredCategories(socket.uid),
	]);
	return categoriesData.filter(category => category && !ignoredCids.includes(String(category.cid)));
};

SocketCategories.loadMore = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	data.query = data.query || {};
	const [userPrivileges, settings, targetUid] = await Promise.all([
		privileges.categories.get(data.cid, socket.uid),
		user.getSettings(socket.uid),
		user.getUidByUserslug(data.query.author),
	]);

	if (!userPrivileges.read) {
		throw new Error('[[error:no-privileges]]');
	}

	const infScrollTopicsPerPage = 20;
	const sort = data.sort || data.categoryTopicSort;

	let start = Math.max(0, parseInt(data.after, 10));

	if (data.direction === -1) {
		start -= infScrollTopicsPerPage;
	}

	let stop = start + infScrollTopicsPerPage - 1;

	start = Math.max(0, start);
	stop = Math.max(0, stop);
	const result = await categories.getCategoryTopics({
		uid: socket.uid,
		cid: data.cid,
		start: start,
		stop: stop,
		sort: sort,
		settings: settings,
		query: data.query,
		tag: data.query.tag,
		targetUid: targetUid,
	});
	categories.modifyTopicsByPrivilege(data.topics, userPrivileges);

	result.privileges = userPrivileges;
	result.template = {
		category: true,
		name: 'category',
	};
	return result;
};

SocketCategories.getTopicCount = async function (socket, cid) {
	return await categories.getCategoryField(cid, 'topic_count');
};

SocketCategories.getCategoriesByPrivilege = async function (socket, privilege) {
	return await categories.getCategoriesByPrivilege('categories:cid', socket.uid, privilege);
};

SocketCategories.getMoveCategories = async function (socket, data) {
	return await SocketCategories.getSelectCategories(socket, data);
};

SocketCategories.getSelectCategories = async function (socket) {
	const [isAdmin, categoriesData] = await Promise.all([
		user.isAdministrator(socket.uid),
		categories.buildForSelect(socket.uid, 'find', ['disabled', 'link']),
	]);
	return categoriesData.filter(category => category && (!category.disabled || isAdmin) && !category.link);
};

SocketCategories.setWatchState = async function (socket, data) {
	if (!data || !data.cid || !data.state) {
		throw new Error('[[error:invalid-data]]');
	}
	return await ignoreOrWatch(async (uid, cids) => {
		await user.setCategoryWatchState(uid, cids, categories.watchStates[data.state]);
	}, socket, data);
};

SocketCategories.watch = async function (socket, data) {
	return await ignoreOrWatch(user.watchCategory, socket, data);
};

SocketCategories.ignore = async function (socket, data) {
	return await ignoreOrWatch(user.ignoreCategory, socket, data);
};

async function ignoreOrWatch(fn, socket, data) {
	let targetUid = socket.uid;
	const cids = Array.isArray(data.cid) ? data.cid.map(cid => parseInt(cid, 10)) : [parseInt(data.cid, 10)];
	if (data.hasOwnProperty('uid')) {
		targetUid = data.uid;
	}
	await user.isAdminOrGlobalModOrSelf(socket.uid, targetUid);
	const allCids = await categories.getAllCidsFromSet('categories:cid');
	const categoryData = await categories.getCategoriesFields(allCids, ['cid', 'parentCid']);

	// filter to subcategories of cid
	let cat;
	do {
		cat = categoryData.find(c => !cids.includes(c.cid) && cids.includes(c.parentCid));
		if (cat) {
			cids.push(cat.cid);
		}
	} while (cat);

	await fn(targetUid, cids);
	await topics.pushUnreadCount(targetUid);
	return cids;
}

SocketCategories.isModerator = async function (socket, cid) {
	return await user.isModerator(socket.uid, cid);
};

SocketCategories.getCategory = async function (socket, cid) {
	sockets.warnDeprecated(socket, 'GET /api/v3/categories/:cid');
	return await api.categories.get(socket, { cid });
	// return await apiController.getCategoryData(cid, socket.uid);
};

SocketCategories.loadMoreSubCategories = async function (socket, data) {
	if (!data || !data.cid || !(parseInt(data.start, 10) > 0)) {
		throw new Error('[[error:invalid-data]]');
	}
	const allowed = await privileges.categories.can('read', data.cid, socket.uid);
	if (!allowed) {
		throw new Error('[[error:no-privileges]]');
	}
	const category = await categories.getCategoryData(data.cid);
	await categories.getChildrenTree(category, socket.uid);
	const allCategories = [];
	categories.flattenCategories(allCategories, category.children);
	await categories.getRecentTopicReplies(allCategories, socket.uid);
'use strict';

const user = require('../user');
const flags = require('../flags');

const SocketFlags = module.exports;

SocketFlags.create = async function (socket, data) {
	if (!socket.uid) {
		throw new Error('[[error:not-logged-in]]');
	}

	if (!data || !data.type || !data.id || !data.reason) {
		throw new Error('[[error:invalid-data]]');
	}
	await flags.validate({
		uid: socket.uid,
		type: data.type,
		id: data.id,
	});

	const flagObj = await flags.create(data.type, data.id, socket.uid, data.reason);
	await flags.notify(flagObj, socket.uid);
	return flagObj.flagId;
};

SocketFlags.update = async function (socket, data) {
	if (!data || !(data.flagId && data.data)) {
		throw new Error('[[error:invalid-data]]');
	}

	const allowed = await user.isPrivileged(socket.uid);
	if (!allowed) {
		throw new Error('[[no-privileges]]');
	}
	let payload = {};
	// Translate form data into object
	payload = data.data.reduce((memo, cur) => {
		memo[cur.name] = cur.value;
		return memo;
	}, payload);

	await flags.update(data.flagId, socket.uid, payload);
	return await flags.getHistory(data.flagId);
};

SocketFlags.appendNote = async function (socket, data) {
	if (!data || !(data.flagId && data.note)) {
		throw new Error('[[error:invalid-data]]');
	}

	const allowed = await user.isPrivileged(socket.uid);
	if (!allowed) {
		throw new Error('[[no-privileges]]');
	}
	await flags.appendNote(data.flagId, socket.uid, data.note, data.datetime);

	const [notes, history] = await Promise.all([
		flags.getNotes(data.flagId),
		flags.getHistory(data.flagId),
	]);
	return { notes: notes, history: history };
};

SocketFlags.deleteNote = async function (socket, data) {
	if (!data || !(data.flagId && data.datetime)) {
		throw new Error('[[error:invalid-data]]');
	}

	const note = await flags.getNote(data.flagId, data.datetime);
	if (note.uid !== socket.uid) {
		throw new Error('[[error:no-privileges]]');
	}

	await flags.deleteNote(data.flagId, data.datetime);

	const [notes, history] = await Promise.all([
		flags.getNotes(data.flagId),
		flags.getHistory(data.flagId),
	]);
'use strict';

const async = require('async');
const user = require('../../user');
const topics = require('../../topics');
const categories = require('../../categories');
const privileges = require('../../privileges');
const socketHelpers = require('../helpers');

module.exports = function (SocketTopics) {
	SocketTopics.move = async function (socket, data) {
		if (!data || !Array.isArray(data.tids) || !data.cid) {
			throw new Error('[[error:invalid-data]]');
		}

		const canMove = await privileges.categories.isAdminOrMod(data.cid, socket.uid);
		if (!canMove) {
			throw new Error('[[error:no-privileges]]');
		}

		const uids = await user.getUidsFromSet('users:online', 0, -1);

		await async.eachLimit(data.tids, 10, async (tid) => {
			const canMove = await privileges.topics.isAdminOrMod(tid, socket.uid);
			if (!canMove) {
				throw new Error('[[error:no-privileges]]');
			}
			const topicData = await topics.getTopicFields(tid, ['tid', 'cid', 'slug', 'deleted']);
			data.uid = socket.uid;
			await topics.tools.move(tid, data);

			const notifyUids = await privileges.categories.filterUids('topics:read', topicData.cid, uids);
			socketHelpers.emitToUids('event:topic_moved', topicData, notifyUids);
			if (!topicData.deleted) {
				socketHelpers.sendNotificationToTopicOwner(tid, socket.uid, 'move', 'notifications:moved_your_topic');
			}
		});
	};


	SocketTopics.moveAll = async function (socket, data) {
		if (!data || !data.cid || !data.currentCid) {
			throw new Error('[[error:invalid-data]]');
		}
		const canMove = await privileges.categories.canMoveAllTopics(data.currentCid, data.cid, socket.uid);
		if (!canMove) {
			throw new Error('[[error:no-privileges]]');
		}

		const tids = await categories.getAllTopicIds(data.currentCid, 0, -1);
		data.uid = socket.uid;
		await async.eachLimit(tids, 50, async (tid) => {
			await topics.tools.move(tid, data);
		});
	};
'use strict';

const db = require('../../database');
const user = require('../../user');
const topics = require('../../topics');

module.exports = function (SocketTopics) {
	SocketTopics.markAsRead = async function (socket, tids) {
		if (!Array.isArray(tids) || socket.uid <= 0) {
			throw new Error('[[error:invalid-data]]');
		}
		const hasMarked = await topics.markAsRead(tids, socket.uid);
		const promises = [topics.markTopicNotificationsRead(tids, socket.uid)];
		if (hasMarked) {
			promises.push(topics.pushUnreadCount(socket.uid));
		}
		await Promise.all(promises);
	};

	SocketTopics.markTopicNotificationsRead = async function (socket, tids) {
		if (!Array.isArray(tids) || !socket.uid) {
			throw new Error('[[error:invalid-data]]');
		}
		await topics.markTopicNotificationsRead(tids, socket.uid);
	};

	SocketTopics.markAllRead = async function (socket) {
		if (socket.uid <= 0) {
			throw new Error('[[error:invalid-uid]]');
		}
		await topics.markAllRead(socket.uid);
		topics.pushUnreadCount(socket.uid);
	};

	SocketTopics.markCategoryTopicsRead = async function (socket, cid) {
		const tids = await topics.getUnreadTids({ cid: cid, uid: socket.uid, filter: '' });
		await SocketTopics.markAsRead(socket, tids);
	};

	SocketTopics.markUnread = async function (socket, tid) {
		if (!tid || socket.uid <= 0) {
			throw new Error('[[error:invalid-data]]');
		}
		await topics.markUnread(tid, socket.uid);
		topics.pushUnreadCount(socket.uid);
	};

	SocketTopics.markAsUnreadForAll = async function (socket, tids) {
		if (!Array.isArray(tids)) {
			throw new Error('[[error:invalid-tid]]');
		}

		if (socket.uid <= 0) {
			throw new Error('[[error:no-privileges]]');
		}
		const isAdmin = await user.isAdministrator(socket.uid);
		const now = Date.now();
		await Promise.all(tids.map(async (tid) => {
			const topicData = await topics.getTopicFields(tid, ['tid', 'cid']);
			if (!topicData.tid) {
				throw new Error('[[error:no-topic]]');
			}
			const isMod = await user.isModerator(socket.uid, topicData.cid);
			if (!isAdmin && !isMod) {
				throw new Error('[[error:no-privileges]]');
			}
			await topics.markAsUnreadForAll(tid);
			await topics.updateRecent(tid, now);
			await db.sortedSetAdd(`cid:${topicData.cid}:tids:lastposttime`, now, tid);
			await topics.setTopicField(tid, 'lastposttime', now);
'use strict';

const topics = require('../../topics');
const privileges = require('../../privileges');

module.exports = function (SocketTopics) {
	SocketTopics.merge = async function (socket, data) {
		if (!data || !Array.isArray(data.tids)) {
			throw new Error('[[error:invalid-data]]');
		}
		const allowed = await Promise.all(data.tids.map(tid => privileges.topics.isAdminOrMod(tid, socket.uid)));
		if (allowed.includes(false)) {
			throw new Error('[[error:no-privileges]]');
		}
		if (data.options && data.options.mainTid && !data.tids.includes(data.options.mainTid)) {
			throw new Error('[[error:invalid-data]]');
		}
		const mergeIntoTid = await topics.merge(data.tids, socket.uid, data.options);
		return mergeIntoTid;
	};
'use strict';

const api = require('../../api');
const topics = require('../../topics');
const privileges = require('../../privileges');
const plugins = require('../../plugins');
const sockets = require('..');

module.exports = function (SocketTopics) {
	SocketTopics.loadTopicTools = async function (socket, data) {
		if (!socket.uid) {
			throw new Error('[[error:no-privileges]]');
		}
		if (!data) {
			throw new Error('[[error:invalid-data]]');
		}

		const [topicData, userPrivileges] = await Promise.all([
			topics.getTopicData(data.tid),
			privileges.topics.get(data.tid, socket.uid),
		]);

		if (!topicData) {
			throw new Error('[[error:no-topic]]');
		}
		if (!userPrivileges['topics:read']) {
			throw new Error('[[error:no-privileges]]');
		}
		topicData.privileges = userPrivileges;
		const result = await plugins.hooks.fire('filter:topic.thread_tools', { topic: topicData, uid: socket.uid, tools: [] });
		result.topic.thread_tools = result.tools;
		return result.topic;
	};

	SocketTopics.delete = async function (socket, data) {
		sockets.warnDeprecated(socket, 'DELETE /api/v3/topics/state');
		await api.topics.delete(socket, data);
	};

	SocketTopics.restore = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/topics/state');
		await api.topics.restore(socket, data);
	};

	SocketTopics.purge = async function (socket, data) {
		sockets.warnDeprecated(socket, 'DELETE /api/v3/topics');
		await api.topics.purge(socket, data);
	};

	SocketTopics.lock = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/topics/lock');
		await api.topics.lock(socket, data);
	};

	SocketTopics.unlock = async function (socket, data) {
		sockets.warnDeprecated(socket, 'DELETE /api/v3/topics/lock');
		await api.topics.unlock(socket, data);
	};

	SocketTopics.pin = async function (socket, data) {
		sockets.warnDeprecated(socket, 'PUT /api/v3/topics/pin');
		await api.topics.pin(socket, data);
	};

	SocketTopics.unpin = async function (socket, data) {
		sockets.warnDeprecated(socket, 'DELETE /api/v3/topics/pin');
		await api.topics.unpin(socket, data);
	};

	SocketTopics.orderPinnedTopics = async function (socket, data) {
		if (!Array.isArray(data)) {
			throw new Error('[[error:invalid-data]]');
		}

		await topics.tools.orderPinnedTopics(socket.uid, data);
'use strict';

const meta = require('../../meta');
const user = require('../../user');
const topics = require('../../topics');
const categories = require('../../categories');
const privileges = require('../../privileges');
const utils = require('../../utils');

module.exports = function (SocketTopics) {
	SocketTopics.isTagAllowed = async function (socket, data) {
		if (!data || !utils.isNumber(data.cid) || !data.tag) {
			throw new Error('[[error:invalid-data]]');
		}

		const systemTags = (meta.config.systemTags || '').split(',');
		const [tagWhitelist, isPrivileged] = await Promise.all([
			categories.getTagWhitelist([data.cid]),
			user.isPrivileged(socket.uid),
		]);
		return isPrivileged ||
			(
				!systemTags.includes(data.tag) &&
				(!tagWhitelist[0].length || tagWhitelist[0].includes(data.tag))
			);
	};

	SocketTopics.autocompleteTags = async function (socket, data) {
		if (data.cid) {
			const canRead = await privileges.categories.can('topics:read', data.cid, socket.uid);
			if (!canRead) {
				throw new Error('[[error:no-privileges]]');
			}
		}
		data.cids = await categories.getCidsByPrivilege('categories:cid', socket.uid, 'topics:read');
		const result = await topics.autocompleteTags(data);
		return result.map(tag => tag.value);
	};

	SocketTopics.searchTags = async function (socket, data) {
		const result = await searchTags(socket.uid, topics.searchTags, data);
		return result.map(tag => tag.value);
	};

	SocketTopics.searchAndLoadTags = async function (socket, data) {
		return await searchTags(socket.uid, topics.searchAndLoadTags, data);
	};

	async function searchTags(uid, method, data) {
		const allowed = await privileges.global.can('search:tags', uid);
		if (!allowed) {
			throw new Error('[[error:no-privileges]]');
		}
		if (data.cid) {
			const canRead = await privileges.categories.can('topics:read', data.cid, uid);
			if (!canRead) {
				throw new Error('[[error:no-privileges]]');
			}
		}
		data.cids = await categories.getCidsByPrivilege('categories:cid', uid, 'topics:read');
		return await method(data);
	}

	SocketTopics.loadMoreTags = async function (socket, data) {
		if (!data || !utils.isNumber(data.after)) {
			throw new Error('[[error:invalid-data]]');
		}

		const start = parseInt(data.after, 10);
		const stop = start + 99;
'use strict';

const topics = require('../../topics');
const privileges = require('../../privileges');
const meta = require('../../meta');
const utils = require('../../utils');
const social = require('../../social');

module.exports = function (SocketTopics) {
	SocketTopics.loadMore = async function (socket, data) {
		if (!data || !data.tid || !utils.isNumber(data.after) || parseInt(data.after, 10) < 0) {
			throw new Error('[[error:invalid-data]]');
		}

		const [userPrivileges, topicData] = await Promise.all([
			privileges.topics.get(data.tid, socket.uid),
			topics.getTopicFields(data.tid, ['postcount', 'deleted', 'uid']),
		]);

		if (!userPrivileges['topics:read'] || (topicData.deleted && !userPrivileges.view_deleted)) {
			throw new Error('[[error:no-privileges]]');
		}

		const set = data.topicPostSort === 'most_votes' ? `tid:${data.tid}:posts:votes` : `tid:${data.tid}:posts`;
		const reverse = data.topicPostSort === 'newest_to_oldest' || data.topicPostSort === 'most_votes';
		let start = Math.max(0, parseInt(data.after, 10));

		const infScrollPostsPerPage = Math.max(0, Math.min(
			meta.config.postsPerPage || 20,
			parseInt(data.count, 10) || meta.config.postsPerPage || 20
		));

		if (data.direction === -1) {
			start -= (infScrollPostsPerPage + 1);
		}

		let stop = start + infScrollPostsPerPage - 1;

		start = Math.max(0, start);
		stop = Math.max(0, stop);

		const [mainPost, posts, postSharing] = await Promise.all([
			start > 0 ? null : topics.getMainPost(data.tid, socket.uid),
			topics.getTopicPosts(data.tid, set, start, stop, socket.uid, reverse),
			social.getActivePostSharing(),
		]);

		if (mainPost) {
			topicData.mainPost = mainPost;
			topicData.posts = [mainPost].concat(posts);
		} else {
			topicData.posts = posts;
		}

		topicData.privileges = userPrivileges;
		topicData.postSharing = postSharing;
		topicData['reputation:disabled'] = meta.config['reputation:disabled'] === 1;
		topicData['downvote:disabled'] = meta.config['downvote:disabled'] === 1;

		topics.modifyPostsByPrivilege(topicData, userPrivileges);
		return topicData;
	};

	SocketTopics.loadMoreSortedTopics = async function (socket, data) {
		if (!data || !utils.isNumber(data.after) || parseInt(data.after, 10) < 0) {
			throw new Error('[[error:invalid-data]]');
		}
		const { start, stop } = calculateStartStop(data);
		const params = {
			uid: socket.uid,
			start: start,
			stop: stop,
			filter: data.filter,
			query: data.query,
		};
		if (data.sort === 'unread') {
			params.cid = data.cid;
			return await topics.getUnreadTopics(params);
		}
		params.cids = data.cid;
		params.tags = data.tags;
		params.sort = data.sort;
		params.term = data.term;
		return await topics.getSortedTopics(params);
	};

	SocketTopics.loadMoreFromSet = async function (socket, data) {
		if (!data || !utils.isNumber(data.after) || parseInt(data.after, 10) < 0 || !data.set) {
			throw new Error('[[error:invalid-data]]');
		}
		const { start, stop } = calculateStartStop(data);
		return await topics.getTopicsFromSet(data.set, socket.uid, start, stop);
	};

	function calculateStartStop(data) {
		const itemsPerPage = Math.min(
			meta.config.topicsPerPage || 20,
			parseInt(data.count, 10) || meta.config.topicsPerPage || 20
		);
		let start = Math.max(0, parseInt(data.after, 10));
		if (data.direction === -1) {
			start -= itemsPerPage;
		}
		const stop = start + Math.max(0, itemsPerPage - 1);
		return { start: Math.max(0, start), stop: Math.max(0, stop) };
'use strict';

const db = require('../database');
const posts = require('../posts');
const privileges = require('../privileges');
const plugins = require('../plugins');
const meta = require('../meta');
const topics = require('../topics');
const user = require('../user');
const socketHelpers = require('./helpers');
const utils = require('../utils');
const api = require('../api');

const sockets = require('.');

const SocketPosts = module.exports;

require('./posts/edit')(SocketPosts);
require('./posts/move')(SocketPosts);
require('./posts/votes')(SocketPosts);
require('./posts/bookmarks')(SocketPosts);
require('./posts/tools')(SocketPosts);
require('./posts/diffs')(SocketPosts);

SocketPosts.reply = async function (socket, data) {
	sockets.warnDeprecated(socket, 'POST /api/v3/topics/:tid');

	if (!data || !data.tid || (meta.config.minimumPostLength !== 0 && !data.content)) {
		throw new Error('[[error:invalid-data]]');
	}

	socketHelpers.setDefaultPostData(data, socket);
	await meta.blacklist.test(data.req.ip);
	const shouldQueue = await posts.shouldQueue(socket.uid, data);
	if (shouldQueue) {
		return await posts.addToQueue(data);
	}
	return await postReply(socket, data);
};

async function postReply(socket, data) {
	const postData = await topics.reply(data);
	const result = {
		posts: [postData],
		'reputation:disabled': meta.config['reputation:disabled'] === 1,
		'downvote:disabled': meta.config['downvote:disabled'] === 1,
	};

	socket.emit('event:new_post', result);

	user.updateOnlineUsers(socket.uid);

	socketHelpers.notifyNew(socket.uid, 'newPost', result);

	return postData;
}

SocketPosts.getRawPost = async function (socket, pid) {
	const canRead = await privileges.posts.can('topics:read', pid, socket.uid);
	if (!canRead) {
		throw new Error('[[error:no-privileges]]');
	}

	const postData = await posts.getPostFields(pid, ['content', 'deleted']);
	if (postData.deleted) {
		throw new Error('[[error:no-post]]');
	}
	postData.pid = pid;
	const result = await plugins.hooks.fire('filter:post.getRawPost', { uid: socket.uid, postData: postData });
	return result.postData.content;
};

SocketPosts.getPostSummaryByIndex = async function (socket, data) {
	if (data.index < 0) {
		data.index = 0;
	}
	let pid;
	if (data.index === 0) {
		pid = await topics.getTopicField(data.tid, 'mainPid');
	} else {
		pid = await db.getSortedSetRange(`tid:${data.tid}:posts`, data.index - 1, data.index - 1);
	}
	pid = Array.isArray(pid) ? pid[0] : pid;
	if (!pid) {
		return 0;
	}

	const topicPrivileges = await privileges.topics.get(data.tid, socket.uid);
	if (!topicPrivileges['topics:read']) {
		throw new Error('[[error:no-privileges]]');
	}

	const postsData = await posts.getPostSummaryByPids([pid], socket.uid, { stripTags: false });
	posts.modifyPostByPrivilege(postsData[0], topicPrivileges);
	return postsData[0];
};

SocketPosts.getPost = async function (socket, pid) {
	sockets.warnDeprecated(socket, 'GET /api/v3/posts/:pid');
	return await api.posts.get(socket, { pid });
};

SocketPosts.getCategory = async function (socket, pid) {
	return await posts.getCidByPid(pid);
};

SocketPosts.getPidIndex = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	return await posts.getPidIndex(data.pid, data.tid, data.topicPostSort);
};

SocketPosts.getReplies = async function (socket, pid) {
	if (!utils.isNumber(pid)) {
		throw new Error('[[error:invalid-data]]');
	}

	const pids = await posts.getPidsFromSet(`pid:${pid}:replies`, 0, -1, false);

	let [postData, postPrivileges] = await Promise.all([
		posts.getPostsByPids(pids, socket.uid),
		privileges.posts.get(pids, socket.uid),
	]);
	postData = await topics.addPostData(postData, socket.uid);
	postData.forEach((postData, index) => posts.modifyPostByPrivilege(postData, postPrivileges[index]));
	postData = postData.filter((postData, index) => postData && postPrivileges[index].read);
	return postData;
};

SocketPosts.accept = async function (socket, data) {
	await acceptOrReject(posts.submitFromQueue, socket, data);
};

SocketPosts.reject = async function (socket, data) {
	await acceptOrReject(posts.removeFromQueue, socket, data);
};

async function acceptOrReject(method, socket, data) {
	const canEditQueue = await posts.canEditQueue(socket.uid, data);
	if (!canEditQueue) {
		throw new Error('[[error:no-privileges]]');
	}
	await method(data.id);
}

SocketPosts.editQueuedContent = async function (socket, data) {
	if (!data || !data.id || (!data.content && !data.title && !data.cid)) {
		throw new Error('[[error:invalid-data]]');
	}
	await posts.editQueuedContent(socket.uid, data);
	if (data.content) {
		return await plugins.hooks.fire('filter:parse.post', { postData: data });
	}
	return { postData: data };
'use strict';

const user = require('../user');
const notifications = require('../notifications');

const SocketNotifs = module.exports;

SocketNotifs.get = async function (socket, data) {
	if (data && Array.isArray(data.nids) && socket.uid) {
		return await user.notifications.getNotifications(data.nids, socket.uid);
	}
	return await user.notifications.get(socket.uid);
};

SocketNotifs.getCount = async function (socket) {
	return await user.notifications.getUnreadCount(socket.uid);
};

SocketNotifs.deleteAll = async function (socket) {
	if (!socket.uid) {
		throw new Error('[[error:no-privileges]]');
	}

	await user.notifications.deleteAll(socket.uid);
};

SocketNotifs.markRead = async function (socket, nid) {
	await notifications.markRead(nid, socket.uid);
	user.notifications.pushCount(socket.uid);
};

SocketNotifs.markUnread = async function (socket, nid) {
	await notifications.markUnread(nid, socket.uid);
	user.notifications.pushCount(socket.uid);
};

SocketNotifs.markAllRead = async function (socket) {
	await notifications.markAllRead(socket.uid);
	user.notifications.pushCount(socket.uid);
};
'use strict';

const meta = require('../../meta');

const Logs = module.exports;

Logs.get = function (socket, data, callback) {
	meta.logs.get(callback);
};

'use strict';

const groups = require('../../groups');
const sockets = require('..');
const api = require('../../api');

const Groups = module.exports;

Groups.create = async function (socket, data) {
	sockets.warnDeprecated(socket, 'POST /api/v3/groups');

	if (!data) {
		throw new Error('[[error:invalid-data]]');
	} else if (groups.isPrivilegeGroup(data.name)) {
		throw new Error('[[error:invalid-group-name]]');
	}

	return await groups.create({
		name: data.name,
		description: data.description,
		private: data.private,
		hidden: data.hidden,
		ownerUid: socket.uid,
	});
};

Groups.join = async (socket, data) => {
	sockets.warnDeprecated(socket, 'PUT /api/v3/groups/:slug/membership/:uid');
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	const slug = await groups.getGroupField(data.groupName, 'slug');
	return await api.groups.join(socket, { slug: slug, uid: data.uid });
};

Groups.leave = async function (socket, data) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/groups/:slug/membership/:uid');
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	const slug = await groups.getGroupField(data.groupName, 'slug');
	await api.groups.leave(socket, { slug: slug, uid: data.uid });
};

Groups.update = async function (socket, data) {
	sockets.warnDeprecated(socket, 'PUT /api/v3/groups/:slug');
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}

'use strict';

const meta = require('../../meta');
const events = require('../../events');

const Settings = module.exports;

Settings.get = function (socket, data, callback) {
	meta.settings.get(data.hash, callback);
};

Settings.set = async function (socket, data) {
	await meta.settings.set(data.hash, data.values);
	const eventData = data.values;
	eventData.type = 'settings-change';
	eventData.uid = socket.uid;
	eventData.ip = socket.ip;
	eventData.hash = data.hash;
	await events.log(eventData);
};
'use strict';

const meta = require('../../meta');

const Errors = module.exports;
'use strict';

const social = require('../../social');

const SocketSocial = module.exports;
'use strict';

const meta = require('../../meta');
const userDigest = require('../../user/digest');

const Digest = module.exports;

Digest.resend = async (socket, data) => {
	const { uid } = data;
	const interval = data.action.startsWith('resend-') ? data.action.slice(7) : await userDigest.getUsersInterval(uid);

	if (!interval && meta.config.dailyDigestFreq === 'off') {
		throw new Error('[[error:digest-not-enabled]]');
	}

	if (uid) {
		await userDigest.execute({
			interval: interval || meta.config.dailyDigestFreq,
			subscribers: [uid],
		});
'use strict';

const plugins = require('../../plugins');
const events = require('../../events');
const db = require('../../database');

const Plugins = module.exports;

Plugins.toggleActive = async function (socket, plugin_id) {
	require('../../posts/cache').reset();
	const data = await plugins.toggleActive(plugin_id);
	await events.log({
		type: `plugin-${data.active ? 'activate' : 'deactivate'}`,
		text: plugin_id,
		uid: socket.uid,
	});
	return data;
};

Plugins.toggleInstall = async function (socket, data) {
	require('../../posts/cache').reset();
	await plugins.checkWhitelist(data.id, data.version);
	const pluginData = await plugins.toggleInstall(data.id, data.version);
	await events.log({
		type: `plugin-${pluginData.installed ? 'install' : 'uninstall'}`,
		text: data.id,
		version: data.version,
		uid: socket.uid,
	});
	return pluginData;
};

Plugins.getActive = function (socket, data, callback) {
	plugins.getActive(callback);
};

Plugins.orderActivePlugins = async function (socket, data) {
	data = data.filter(plugin => plugin && plugin.name);
	await Promise.all(data.map(plugin => db.sortedSetAdd('plugins:active', plugin.order || 0, plugin.name)));
};
'use strict';

const navigationAdmin = require('../../navigation/admin');

const SocketNavigation = module.exports;
'use strict';

const async = require('async');
const winston = require('winston');

const db = require('../../database');
const api = require('../../api');
const groups = require('../../groups');
const user = require('../../user');
const events = require('../../events');
const meta = require('../../meta');
const translator = require('../../translator');
const sockets = require('..');

const User = module.exports;

User.makeAdmins = async function (socket, uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}
	const isMembersOfBanned = await groups.isMembers(uids, groups.BANNED_USERS);
	if (isMembersOfBanned.includes(true)) {
		throw new Error('[[error:cant-make-banned-users-admin]]');
	}
	for (const uid of uids) {
		/* eslint-disable no-await-in-loop */
		await groups.join('administrators', uid);
		await events.log({
			type: 'user-makeAdmin',
			uid: socket.uid,
			targetUid: uid,
			ip: socket.ip,
		});
	}
};

User.removeAdmins = async function (socket, uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}
	for (const uid of uids) {
		/* eslint-disable no-await-in-loop */
		const count = await groups.getMemberCount('administrators');
		if (count === 1) {
			throw new Error('[[error:cant-remove-last-admin]]');
		}
		await groups.leave('administrators', uid);
		await events.log({
			type: 'user-removeAdmin',
			uid: socket.uid,
			targetUid: uid,
			ip: socket.ip,
		});
	}
};

User.createUser = async function (socket, userData) {
	sockets.warnDeprecated(socket, 'POST /api/v3/users');
	return await api.users.create(socket, userData);
};

User.resetLockouts = async function (socket, uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}
	await Promise.all(uids.map(uid => user.auth.resetLockout(uid)));
};

User.validateEmail = async function (socket, uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}

	for (const uid of uids) {
		await user.email.confirmByUid(uid);
	}
};

User.sendValidationEmail = async function (socket, uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}

	if (!meta.config.requireEmailConfirmation) {
		throw new Error('[[error:email-confirmations-are-disabled]]');
	}

	const failed = [];

	await async.eachLimit(uids, 50, async (uid) => {
		await user.email.sendValidationEmail(uid, { force: true }).catch((err) => {
			winston.error(`[user.create] Validation email failed to send\n[emailer.send] ${err.stack}`);
			failed.push(uid);
		});
	});

	if (failed.length) {
		throw Error(`Email sending failed for the following uids, check server logs for more info: ${failed.join(',')}`);
	}
};

User.sendPasswordResetEmail = async function (socket, uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}

	uids = uids.filter(uid => parseInt(uid, 10));

	await Promise.all(uids.map(async (uid) => {
		const userData = await user.getUserFields(uid, ['email', 'username']);
		if (!userData.email) {
			throw new Error(`[[error:user-doesnt-have-email, ${userData.username}]]`);
		}
		await user.reset.send(userData.email);
	}));
};

User.forcePasswordReset = async function (socket, uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}

	uids = uids.filter(uid => parseInt(uid, 10));

	await db.setObjectField(uids.map(uid => `user:${uid}`), 'passwordExpiry', Date.now());
	await user.auth.revokeAllSessions(uids);
	uids.forEach(uid => sockets.in(`uid_${uid}`).emit('event:logout'));
};

User.deleteUsers = async function (socket, uids) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/users/:uid/account');
	await Promise.all(uids.map(async (uid) => {
		await api.users.deleteAccount(socket, { uid });
	}));
};

User.deleteUsersContent = async function (socket, uids) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/users/:uid/content');
	await Promise.all(uids.map(async (uid) => {
		await api.users.deleteContent(socket, { uid });
	}));
};

User.deleteUsersAndContent = async function (socket, uids) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/users or DELETE /api/v3/users/:uid');
	await api.users.deleteMany(socket, { uids });
};

User.restartJobs = async function () {
	user.startJobs();
};

User.loadGroups = async function (socket, uids) {
	const [userData, groupData] = await Promise.all([
		user.getUsersData(uids),
		groups.getUserGroupsFromSet('groups:createtime', uids),
	]);
	userData.forEach((data, index) => {
		data.groups = groupData[index].filter(group => !groups.isPrivilegeGroup(group.name));
		data.groups.forEach((group) => {
			group.nameEscaped = translator.escape(group.displayName);
		});
	});
	return { users: userData };
};

User.exportUsersCSV = async function (socket) {
	await events.log({
		type: 'exportUsersCSV',
		uid: socket.uid,
		ip: socket.ip,
	});
	setTimeout(async () => {
		try {
			await user.exportUsersCSV();
			socket.emit('event:export-users-csv');
			const notifications = require('../../notifications');
			const n = await notifications.create({
				bodyShort: '[[notifications:users-csv-exported]]',
				path: '/api/admin/users/csv',
				nid: 'users:csv:export',
				from: socket.uid,
			});
			await notifications.push(n, [socket.uid]);
		} catch (err) {
'use strict';

const winston = require('winston');

const groups = require('../../groups');
const user = require('../../user');
const categories = require('../../categories');
const privileges = require('../../privileges');
const plugins = require('../../plugins');
const events = require('../../events');
const api = require('../../api');
const sockets = require('..');

const Categories = module.exports;

Categories.create = async function (socket, data) {
	sockets.warnDeprecated(socket, 'POST /api/v3/categories');

	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	return await api.categories.create(socket, data);
};

// DEPRECATED: @1.14.3, remove in version >=1.16
Categories.getAll = async function () {
	winston.warn('[deprecated] admin.categories.getAll deprecated, data is returned in the api route');
	const cids = await categories.getAllCidsFromSet('categories:cid');
	const fields = [
		'cid', 'name', 'icon', 'parentCid', 'disabled', 'link',
		'color', 'bgColor', 'backgroundImage', 'imageClass',
	];
	const categoriesData = await categories.getCategoriesFields(cids, fields);
	const result = await plugins.hooks.fire('filter:admin.categories.get', { categories: categoriesData, fields: fields });
	return categories.getTree(result.categories, 0);
};

Categories.getNames = async function () {
	return await categories.getAllCategoryFields(['cid', 'name']);
};

Categories.purge = async function (socket, cid) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/categories/:cid');

	await api.categories.delete(socket, { cid: cid });
};

Categories.update = async function (socket, data) {
	sockets.warnDeprecated(socket, 'PUT /api/v3/categories/:cid');

	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	return await api.categories.update(socket, data);
};

Categories.setPrivilege = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	const [userExists, groupExists] = await Promise.all([
		user.exists(data.member),
		groups.exists(data.member),
	]);

	if (!userExists && !groupExists) {
		throw new Error('[[error:no-user-or-group]]');
	}

	await privileges.categories[data.set ? 'give' : 'rescind'](
		Array.isArray(data.privilege) ? data.privilege : [data.privilege], data.cid, data.member
	);

	await events.log({
		uid: socket.uid,
		type: 'privilege-change',
		ip: socket.ip,
		privilege: data.privilege.toString(),
		cid: data.cid,
		action: data.set ? 'grant' : 'rescind',
		target: data.member,
	});
};

Categories.getPrivilegeSettings = async function (socket, cid) {
	if (cid === 'admin') {
		return await privileges.admin.list(socket.uid);
	} else if (!parseInt(cid, 10)) {
		return await privileges.global.list();
	}
	return await privileges.categories.list(cid);
};

Categories.copyPrivilegesToChildren = async function (socket, data) {
	const result = await categories.getChildren([data.cid], socket.uid);
	const children = result[0];
	for (const child of children) {
		// eslint-disable-next-line no-await-in-loop
		await copyPrivilegesToChildrenRecursive(data.cid, child, data.group);
	}
};

async function copyPrivilegesToChildrenRecursive(parentCid, category, group) {
	await categories.copyPrivilegesFrom(parentCid, category.cid, group);
	for (const child of category.children) {
		// eslint-disable-next-line no-await-in-loop
		await copyPrivilegesToChildrenRecursive(parentCid, child, group);
	}
}

Categories.copySettingsFrom = async function (socket, data) {
	return await categories.copySettingsFrom(data.fromCid, data.toCid, data.copyParent);
};

Categories.copyPrivilegesFrom = async function (socket, data) {
	await categories.copyPrivilegesFrom(data.fromCid, data.toCid, data.group);
};

Categories.copyPrivilegesToAllCategories = async function (socket, data) {
	let cids = await categories.getAllCidsFromSet('categories:cid');
	cids = cids.filter(cid => parseInt(cid, 10) !== parseInt(data.cid, 10));
	for (const toCid of cids) {
		// eslint-disable-next-line no-await-in-loop
		await categories.copyPrivilegesFrom(data.cid, toCid, data.group);
	}
'use strict';

const async = require('async');
const widgets = require('../../widgets');

const Widgets = module.exports;

Widgets.set = function (socket, data, callback) {
	if (!Array.isArray(data)) {
		return callback(new Error('[[error:invalid-data]]'));
'use strict';

const meta = require('../../meta');
const plugins = require('../../plugins');
const logger = require('../../logger');
const events = require('../../events');
const index = require('../index');

const Config = module.exports;

Config.set = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	const _data = {};
	_data[data.key] = data.value;
	await Config.setMultiple(socket, _data);
};

Config.setMultiple = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}

	const changes = {};
	const newData = meta.configs.serialize(data);
	const oldData = meta.configs.serialize(meta.config);
	Object.keys(newData).forEach((key) => {
		if (newData[key] !== oldData[key]) {
			changes[key] = newData[key];
			changes[`${key}_old`] = meta.config[key];
		}
	});
	await meta.configs.setMultiple(data);
	for (const [key, value] of Object.entries(data)) {
		const setting = { key, value };
		plugins.hooks.fire('action:config.set', setting);
		logger.monitorConfig({ io: index.server }, setting);
	}
	if (Object.keys(changes).length) {
		changes.type = 'config-change';
		changes.uid = socket.uid;
		changes.ip = socket.ip;
		await events.log(changes);
	}
'use strict';

const async = require('async');
const analytics = require('../../analytics');

const Analytics = module.exports;

Analytics.get = function (socket, data, callback) {
	if (!data || !data.graph || !data.units) {
		return callback(new Error('[[error:invalid-data]]'));
	}

	// Default returns views from past 24 hours, by hour
	if (!data.amount) {
		if (data.units === 'days') {
			data.amount = 30;
		} else {
			data.amount = 24;
		}
	}
	const getStats = data.units === 'days' ? analytics.getDailyStatsForSet : analytics.getHourlyStatsForSet;
	if (data.graph === 'traffic') {
		async.parallel({
			uniqueVisitors: function (next) {
				getStats('analytics:uniquevisitors', data.until || Date.now(), data.amount, next);
			},
			pageviews: function (next) {
				getStats('analytics:pageviews', data.until || Date.now(), data.amount, next);
			},
			pageviewsRegistered: function (next) {
				getStats('analytics:pageviews:registered', data.until || Date.now(), data.amount, next);
			},
			pageviewsGuest: function (next) {
				getStats('analytics:pageviews:guest', data.until || Date.now(), data.amount, next);
			},
			pageviewsBot: function (next) {
				getStats('analytics:pageviews:bot', data.until || Date.now(), data.amount, next);
			},
			summary: function (next) {
				analytics.getSummary(next);
			},
		}, (err, data) => {
			data.pastDay = data.pageviews.reduce((a, b) => parseInt(a, 10) + parseInt(b, 10));
			const last = data.pageviews.length - 1;
			data.pageviews[last] = parseInt(data.pageviews[last], 10) + analytics.getUnwrittenPageviews();
'use strict';

const meta = require('../../meta');
const widgets = require('../../widgets');

const Themes = module.exports;

Themes.getInstalled = function (socket, data, callback) {
	meta.themes.get(callback);
};

Themes.set = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	if (data.type === 'local') {
		await widgets.reset();
	}

	data.ip = socket.ip;
'use strict';

const SocketCache = module.exports;

SocketCache.clear = async function (socket, data) {
	if (data.name === 'post') {
		require('../../posts/cache').reset();
	} else if (data.name === 'object') {
		require('../../database').objectCache.reset();
	} else if (data.name === 'group') {
		require('../../groups').cache.reset();
	} else if (data.name === 'local') {
		require('../../cache').reset();
	}
};

SocketCache.toggle = async function (socket, data) {
	const caches = {
		post: require('../../posts/cache'),
		object: require('../../database').objectCache,
		group: require('../../groups').cache,
		local: require('../../cache'),
	};
	if (!caches[data.name]) {
		return;
'use strict';

const topics = require('../../topics');

const Tags = module.exports;

Tags.create = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}

	await topics.createEmptyTag(data.tag);
};

Tags.update = async function (socket, data) {
	if (!Array.isArray(data)) {
		throw new Error('[[error:invalid-data]]');
	}

	await topics.updateTags(data);
};

Tags.rename = async function (socket, data) {
	if (!Array.isArray(data)) {
		throw new Error('[[error:invalid-data]]');
	}

	await topics.renameTags(data);
};

Tags.deleteTags = async function (socket, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}

'use strict';

const os = require('os');
const nconf = require('nconf');

const topics = require('../../topics');
const pubsub = require('../../pubsub');
const utils = require('../../utils');

const stats = {};
const totals = {};

const SocketRooms = module.exports;

SocketRooms.stats = stats;
SocketRooms.totals = totals;

pubsub.on('sync:stats:start', () => {
	const stats = SocketRooms.getLocalStats();
	pubsub.publish('sync:stats:end', {
		stats: stats,
		id: `${os.hostname()}:${nconf.get('port')}`,
	});
});

pubsub.on('sync:stats:end', (data) => {
	stats[data.id] = data.stats;
});

pubsub.on('sync:stats:guests', (eventId) => {
	const Sockets = require('../index');
	const guestCount = Sockets.getCountInRoom('online_guests');
	pubsub.publish(eventId, guestCount);
});

SocketRooms.getTotalGuestCount = function (callback) {
	let count = 0;
	const eventId = `sync:stats:guests:end:${utils.generateUUID()}`;
	pubsub.on(eventId, (guestCount) => {
		count += guestCount;
	});

	pubsub.publish('sync:stats:guests', eventId);

	setTimeout(() => {
		pubsub.removeAllListeners(eventId);
		callback(null, count);
	}, 100);
};


SocketRooms.getAll = async function () {
	pubsub.publish('sync:stats:start');

	totals.onlineGuestCount = 0;
	totals.onlineRegisteredCount = 0;
	totals.socketCount = 0;
	totals.topics = {};
	totals.users = {
		categories: 0,
		recent: 0,
		unread: 0,
		topics: 0,
		category: 0,
	};

	for (const instance of Object.values(stats)) {
		totals.onlineGuestCount += instance.onlineGuestCount;
		totals.onlineRegisteredCount += instance.onlineRegisteredCount;
		totals.socketCount += instance.socketCount;
		totals.users.categories += instance.users.categories;
		totals.users.recent += instance.users.recent;
		totals.users.unread += instance.users.unread;
		totals.users.topics += instance.users.topics;
		totals.users.category += instance.users.category;

		instance.topics.forEach((topic) => {
			totals.topics[topic.tid] = totals.topics[topic.tid] || { count: 0, tid: topic.tid };
			totals.topics[topic.tid].count += topic.count;
		});
	}

	let topTenTopics = [];
	Object.keys(totals.topics).forEach((tid) => {
		topTenTopics.push({ tid: tid, count: totals.topics[tid].count || 0 });
	});

	topTenTopics = topTenTopics.sort((a, b) => b.count - a.count).slice(0, 10);

	const topTenTids = topTenTopics.map(topic => topic.tid);

	const titles = await topics.getTopicsFields(topTenTids, ['title']);
	totals.topTenTopics = topTenTopics.map((topic, index) => {
		topic.title = titles[index].title;
		return topic;
	});
	return totals;
};

SocketRooms.getOnlineUserCount = function (io) {
	let count = 0;

	if (io) {
		for (const [key] of io.sockets.adapter.rooms) {
			if (key.startsWith('uid_')) {
				count += 1;
			}
		}
	}

	return count;
};

SocketRooms.getLocalStats = function () {
	const Sockets = require('../index');
	const io = Sockets.server;

	const socketData = {
		onlineGuestCount: 0,
		onlineRegisteredCount: 0,
		socketCount: 0,
		users: {
			categories: 0,
			recent: 0,
			unread: 0,
			topics: 0,
			category: 0,
		},
		topics: {},
	};

	if (io && io.sockets) {
		socketData.onlineGuestCount = Sockets.getCountInRoom('online_guests');
		socketData.onlineRegisteredCount = SocketRooms.getOnlineUserCount(io);
		socketData.socketCount = io.sockets.sockets.size;
		socketData.users.categories = Sockets.getCountInRoom('categories');
		socketData.users.recent = Sockets.getCountInRoom('recent_topics');
		socketData.users.unread = Sockets.getCountInRoom('unread_topics');

		let topTenTopics = [];
		let tid;

		for (const [room, clients] of io.sockets.adapter.rooms) {
			tid = room.match(/^topic_(\d+)/);
			if (tid) {
				socketData.users.topics += clients.size;
				topTenTopics.push({ tid: tid[1], count: clients.size });
			} else if (room.match(/^category/)) {
				socketData.users.category += clients.size;
			}
		}

		topTenTopics = topTenTopics.sort((a, b) => b.count - a.count).slice(0, 10);
		socketData.topics = topTenTopics;
	}
'use strict';

const rewardsAdmin = require('../../rewards/admin');

const SocketRewards = module.exports;

SocketRewards.save = async function (socket, data) {
	await rewardsAdmin.save(data);
};

'use strict';

const fs = require('fs');
const path = require('path');
const nconf = require('nconf');

const sockets = require('..');

const Uploads = module.exports;

Uploads.delete = function (socket, pathToFile, callback) {
	sockets.warnDeprecated(socket, 'DELETE /api/v3/files');

	pathToFile = path.join(nconf.get('upload_path'), pathToFile);
	if (!pathToFile.startsWith(nconf.get('upload_path'))) {
'use strict';

const userDigest = require('../../user/digest');
const userEmail = require('../../user/email');
const notifications = require('../../notifications');
const emailer = require('../../emailer');
const utils = require('../../utils');

const Email = module.exports;

Email.test = async function (socket, data) {
	const payload = {
		subject: '[[email:test-email.subject]]',
	};

	switch (data.template) {
		case 'digest':
			await userDigest.execute({
				interval: 'alltime',
				subscribers: [socket.uid],
			});
			break;

		case 'banned':
			Object.assign(payload, {
				username: 'test-user',
				until: utils.toISOString(Date.now()),
				reason: 'Test Reason',
			});
			await emailer.send(data.template, socket.uid, payload);
			break;

		case 'welcome':
			await userEmail.sendValidationEmail(socket.uid, {
				force: 1,
			});
			break;

		case 'notification': {
			const notification = await notifications.create({
				type: 'test',
				bodyShort: '[[email:notif.test.short]]',
				bodyLong: '[[email:notif.test.long]]',
				nid: `uid:${socket.uid}:test`,
				path: '/',
				from: socket.uid,
			});
			await emailer.send('notification', socket.uid, {
				path: notification.path,
				subject: utils.stripHTMLTags(notification.subject || '[[notifications:new_notification]]'),
				intro: utils.stripHTMLTags(notification.bodyShort),
				body: notification.bodyLong || '',
				notification,
				showUnsubscribe: true,
			});
		} break;

		default:
			await emailer.send(data.template, socket.uid, payload);
			break;
'use strict';

const socketUser = require('./user');
const socketGroup = require('./groups');
const image = require('../image');
const meta = require('../meta');

const inProgress = {};

const uploads = module.exports;

uploads.upload = async function (socket, data) {
	const methodToFunc = {
		'user.uploadCroppedPicture': socketUser.uploadCroppedPicture,
		'user.updateCover': socketUser.updateCover,
		'groups.cover.update': socketGroup.cover.update,
	};
	if (!socket.uid || !data || !data.chunk || !data.params || !data.params.method || !methodToFunc[data.params.method]) {
		throw new Error('[[error:invalid-data]]');
	}

	inProgress[socket.id] = inProgress[socket.id] || {};
	const socketUploads = inProgress[socket.id];
	const { method } = data.params;

	socketUploads[method] = socketUploads[method] || { imageData: '' };
	socketUploads[method].imageData += data.chunk;

	try {
		const maxSize = data.params.method === 'user.uploadCroppedPicture' ?
			meta.config.maximumProfileImageSize : meta.config.maximumCoverImageSize;
		const size = image.sizeFromBase64(socketUploads[method].imageData);

		if (size > maxSize * 1024) {
			throw new Error(`[[error:file-too-big, ${maxSize}]]`);
		}
		if (socketUploads[method].imageData.length < data.params.size) {
			return;
		}
		data.params.imageData = socketUploads[method].imageData;
		const result = await methodToFunc[data.params.method](socket, data.params);
		delete socketUploads[method];
		return result;
	} catch (err) {
		delete inProgress[socket.id];
		throw err;
	}
};

uploads.clear = function (sid) {
'use strict';

const validator = require('validator');

const privileges = require('../privileges');
const events = require('../events');
const groups = require('../groups');
const user = require('../user');
const meta = require('../meta');
const notifications = require('../notifications');
const slugify = require('../slugify');

const groupsAPI = module.exports;

groupsAPI.create = async function (caller, data) {
	if (!caller.uid) {
		throw new Error('[[error:no-privileges]]');
	} else if (typeof data.name !== 'string' || groups.isPrivilegeGroup(data.name)) {
		throw new Error('[[error:invalid-group-name]]');
	}

	const canCreate = await privileges.global.can('group:create', caller.uid);
	if (!canCreate) {
		throw new Error('[[error:no-privileges]]');
	}
	data.ownerUid = caller.uid;
	data.system = false;
	const groupData = await groups.create(data);
	logGroupEvent(caller, 'group-create', {
		groupName: data.name,
	});

	return groupData;
};

groupsAPI.update = async function (caller, data) {
	const groupName = await groups.getGroupNameByGroupSlug(data.slug);
	await isOwner(caller, groupName);

	delete data.slug;
	await groups.update(groupName, data);

	return await groups.getGroupData(data.name || groupName);
};

groupsAPI.delete = async function (caller, data) {
	const groupName = await groups.getGroupNameByGroupSlug(data.slug);
	await isOwner(caller, groupName);
	if (
		groups.systemGroups.includes(groupName) ||
		groups.ephemeralGroups.includes(groupName)
	) {
		throw new Error('[[error:not-allowed]]');
	}

	await groups.destroy(groupName);
	logGroupEvent(caller, 'group-delete', {
		groupName: groupName,
	});
};

groupsAPI.join = async function (caller, data) {
	if (caller.uid <= 0 || !data.uid) {
		throw new Error('[[error:invalid-uid]]');
	}

	const groupName = await groups.getGroupNameByGroupSlug(data.slug);
	if (!groupName) {
		throw new Error('[[error:no-group]]');
	}

	const isCallerAdmin = await user.isAdministrator(caller.uid);
	if (!isCallerAdmin && (
		groups.systemGroups.includes(groupName) ||
		groups.isPrivilegeGroup(groupName)
	)) {
		throw new Error('[[error:not-allowed]]');
	}

	const [groupData, isCallerOwner, userExists] = await Promise.all([
		groups.getGroupData(groupName),
		groups.ownership.isOwner(caller.uid, groupName),
		user.exists(data.uid),
	]);

	if (!userExists) {
		throw new Error('[[error:invalid-uid]]');
	}

	const isSelf = parseInt(caller.uid, 10) === parseInt(data.uid, 10);
	if (!meta.config.allowPrivateGroups && isSelf) {
		// all groups are public!
		await groups.join(groupName, data.uid);
		logGroupEvent(caller, 'group-join', {
			groupName: groupName,
			targetUid: data.uid,
		});
		return;
	}

	if (isSelf && groupData.private && groupData.disableJoinRequests) {
		throw new Error('[[error:group-join-disabled]]');
	}

	if ((!groupData.private && isSelf) || isCallerAdmin || isCallerOwner) {
		await groups.join(groupName, data.uid);
		logGroupEvent(caller, 'group-join', {
			groupName: groupName,
			targetUid: data.uid,
		});
	} else if (isSelf) {
		await groups.requestMembership(groupName, caller.uid);
		logGroupEvent(caller, 'group-request-membership', {
			groupName: groupName,
			targetUid: data.uid,
		});
	}
};

groupsAPI.leave = async function (caller, data) {
	if (caller.uid <= 0) {
		throw new Error('[[error:invalid-uid]]');
	}
	const isSelf = parseInt(caller.uid, 10) === parseInt(data.uid, 10);
	const groupName = await groups.getGroupNameByGroupSlug(data.slug);
	if (!groupName) {
		throw new Error('[[error:no-group]]');
	}

	if (typeof groupName !== 'string') {
		throw new Error('[[error:invalid-group-name]]');
	}

	if (groupName === 'administrators' && isSelf) {
		throw new Error('[[error:cant-remove-self-as-admin]]');
	}

	const [groupData, isCallerAdmin, isCallerOwner, userExists, isMember] = await Promise.all([
		groups.getGroupData(groupName),
		user.isAdministrator(caller.uid),
		groups.ownership.isOwner(caller.uid, groupName),
		user.exists(data.uid),
		groups.isMember(data.uid, groupName),
	]);

	if (!userExists) {
		throw new Error('[[error:invalid-uid]]');
	}
	if (!isMember) {
		return;
	}

	if (groupData.disableLeave && isSelf) {
		throw new Error('[[error:group-leave-disabled]]');
	}

	if (isSelf || isCallerAdmin || isCallerOwner) {
		await groups.leave(groupName, data.uid);
	} else {
		throw new Error('[[error:no-privileges]]');
	}

	const username = await user.getUserField(data.uid, 'username');
	const notification = await notifications.create({
		type: 'group-leave',
		bodyShort: `[[groups:membership.leave.notification_title, ${username}, ${groupName}]]`,
		nid: `group:${validator.escape(groupName)}:uid:${data.uid}:group-leave`,
		path: `/groups/${slugify(groupName)}`,
		from: data.uid,
	});
	const uids = await groups.getOwners(groupName);
	await notifications.push(notification, uids);

	logGroupEvent(caller, 'group-leave', {
		groupName: groupName,
		targetUid: data.uid,
	});
};

groupsAPI.grant = async (caller, data) => {
	const groupName = await groups.getGroupNameByGroupSlug(data.slug);
	await isOwner(caller, groupName);

	await groups.ownership.grant(data.uid, groupName);
	logGroupEvent(caller, 'group-owner-grant', {
		groupName: groupName,
		targetUid: data.uid,
	});
};

groupsAPI.rescind = async (caller, data) => {
	const groupName = await groups.getGroupNameByGroupSlug(data.slug);
	await isOwner(caller, groupName);

	await groups.ownership.rescind(data.uid, groupName);
	logGroupEvent(caller, 'group-owner-rescind', {
		groupName: groupName,
		targetUid: data.uid,
	});
};

async function isOwner(caller, groupName) {
	if (typeof groupName !== 'string') {
		throw new Error('[[error:invalid-group-name]]');
	}
	const [isAdmin, isGlobalModerator, isOwner, group] = await Promise.all([
		user.isAdministrator(caller.uid),
		user.isGlobalModerator(caller.uid),
		groups.ownership.isOwner(caller.uid, groupName),
		groups.getGroupData(groupName),
	]);

	const check = isOwner || isAdmin || (isGlobalModerator && !group.system);
	if (!check) {
		throw new Error('[[error:no-privileges]]');
	}
}

function logGroupEvent(caller, event, additional) {
	events.log({
		type: event,
		uid: caller.uid,
		ip: caller.ip,
		...additional,
	});
'use strict';

const user = require('../user');
const topics = require('../topics');
const posts = require('../posts');
const meta = require('../meta');
const privileges = require('../privileges');

const apiHelpers = require('./helpers');

const { doTopicAction } = apiHelpers;

const websockets = require('../socket.io');
const socketHelpers = require('../socket.io/helpers');

const topicsAPI = module.exports;

topicsAPI.get = async function (caller, data) {
	const [userPrivileges, topic] = await Promise.all([
		privileges.topics.get(data.tid, caller.uid),
		topics.getTopicData(data.tid),
	]);
	if (!topic || !userPrivileges.read || !userPrivileges['topics:read'] || (topic.deleted && !userPrivileges.view_deleted)) {
		return null;
	}

	return topic;
};

topicsAPI.create = async function (caller, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}

	const payload = { ...data };
	payload.tags = payload.tags || [];
	payload.uid = caller.uid;
	payload.req = apiHelpers.buildReqObject(caller);
	payload.timestamp = Date.now();
	payload.fromQueue = false;

	// Blacklist & Post Queue
	await meta.blacklist.test(caller.ip);
	const shouldQueue = await posts.shouldQueue(caller.uid, payload);
	if (shouldQueue) {
		const queueObj = await posts.addToQueue(payload);
		return queueObj;
	}

	const result = await topics.post(payload);
	await topics.thumbs.migrate(data.uuid, result.topicData.tid);

	socketHelpers.emitToUids('event:new_post', { posts: [result.postData] }, [caller.uid]);
	socketHelpers.emitToUids('event:new_topic', result.topicData, [caller.uid]);
	socketHelpers.notifyNew(caller.uid, 'newTopic', { posts: [result.postData], topic: result.topicData });

	return result.topicData;
};

topicsAPI.reply = async function (caller, data) {
	const payload = {
		tid: data.tid,
		uid: caller.uid,
		req: apiHelpers.buildReqObject(caller),	// For IP recording
		content: data.content,
		timestamp: Date.now(),
		fromQueue: false,
	};

	if (data.toPid) { payload.toPid = data.toPid; }

	// Blacklist & Post Queue
	await meta.blacklist.test(caller.ip);
	const shouldQueue = await posts.shouldQueue(caller.uid, payload);
	if (shouldQueue) {
		const queueObj = await posts.addToQueue(payload);
		return queueObj;
	}

	const postData = await topics.reply(payload);	// postData seems to be a subset of postObj, refactor?
	const postObj = await posts.getPostSummaryByPids([postData.pid], caller.uid, {});

	const result = {
		posts: [postData],
		'reputation:disabled': meta.config['reputation:disabled'] === 1,
		'downvote:disabled': meta.config['downvote:disabled'] === 1,
	};

	user.updateOnlineUsers(caller.uid);
	if (caller.uid) {
		socketHelpers.emitToUids('event:new_post', result, [caller.uid]);
	} else if (caller.uid === 0) {
		websockets.in('online_guests').emit('event:new_post', result);
	}

	socketHelpers.notifyNew(caller.uid, 'newPost', result);

	return postObj[0];
};

topicsAPI.delete = async function (caller, data) {
	await doTopicAction('delete', 'event:topic_deleted', caller, {
		tids: data.tids,
	});
};

topicsAPI.restore = async function (caller, data) {
	await doTopicAction('restore', 'event:topic_restored', caller, {
		tids: data.tids,
	});
};

topicsAPI.purge = async function (caller, data) {
	await doTopicAction('purge', 'event:topic_purged', caller, {
		tids: data.tids,
	});
};

topicsAPI.pin = async function (caller, data) {
	await doTopicAction('pin', 'event:topic_pinned', caller, {
		tids: data.tids,
	});
};

topicsAPI.unpin = async function (caller, data) {
	await doTopicAction('unpin', 'event:topic_unpinned', caller, {
		tids: data.tids,
	});
};

topicsAPI.lock = async function (caller, data) {
	await doTopicAction('lock', 'event:topic_locked', caller, {
		tids: data.tids,
	});
};

topicsAPI.unlock = async function (caller, data) {
	await doTopicAction('unlock', 'event:topic_unlocked', caller, {
		tids: data.tids,
	});
};

topicsAPI.follow = async function (caller, data) {
	await topics.follow(data.tid, caller.uid);
};

topicsAPI.ignore = async function (caller, data) {
	await topics.ignore(data.tid, caller.uid);
};

'use strict';

const url = require('url');
const user = require('../user');
const topics = require('../topics');
const posts = require('../posts');
const privileges = require('../privileges');
const plugins = require('../plugins');
const socketHelpers = require('../socket.io/helpers');
const websockets = require('../socket.io');
const events = require('../events');

// creates a slimmed down version of the request object
exports.buildReqObject = (req, payload) => {
	req = req || {};
	const headers = req.headers || {};
	const encrypted = req.connection ? !!req.connection.encrypted : false;
	let { host } = headers;
	const referer = headers.referer || '';

	if (!host) {
		host = url.parse(referer).host || '';
	}

	return {
		uid: req.uid,
		params: req.params,
		method: req.method,
		body: payload || req.body,
		session: req.session,
		ip: req.ip,
		host: host,
		protocol: encrypted ? 'https' : 'http',
		secure: encrypted,
		url: referer,
		path: referer.substr(referer.indexOf(host) + host.length),
		headers: headers,
	};
};

exports.doTopicAction = async function (action, event, caller, { tids }) {
	if (!Array.isArray(tids)) {
		throw new Error('[[error:invalid-tid]]');
	}

	const exists = (await Promise.all(tids.map(async tid => await topics.exists(tid)))).every(Boolean);
	if (!exists) {
		throw new Error('[[error:no-topic]]');
	}

	if (typeof topics.tools[action] !== 'function') {
		return;
	}

	const uids = await user.getUidsFromSet('users:online', 0, -1);

	await Promise.all(tids.map(async (tid) => {
		const title = await topics.getTopicField(tid, 'title');
		const data = await topics.tools[action](tid, caller.uid);
		const notifyUids = await privileges.categories.filterUids('topics:read', data.cid, uids);
		socketHelpers.emitToUids(event, data, notifyUids);
		await logTopicAction(action, caller, tid, title);
	}));
};

async function logTopicAction(action, req, tid, title) {
	// Only log certain actions to system event log
	const actionsToLog = ['delete', 'restore', 'purge'];
	if (!actionsToLog.includes(action)) {
		return;
	}
	await events.log({
		type: `topic-${action}`,
		uid: req.uid,
		ip: req.ip,
		tid: tid,
		title: String(title),
	});
}

exports.postCommand = async function (caller, command, eventName, notification, data) {
	if (!caller.uid) {
		throw new Error('[[error:not-logged-in]]');
	}

	if (!data || !data.pid) {
		throw new Error('[[error:invalid-data]]');
	}

	if (!data.room_id) {
		throw new Error(`[[error:invalid-room-id, ${data.room_id} ]]`);
	}
	const [exists, deleted] = await Promise.all([
		posts.exists(data.pid),
		posts.getPostField(data.pid, 'deleted'),
	]);

	if (!exists) {
		throw new Error('[[error:invalid-pid]]');
	}

	if (deleted) {
		throw new Error('[[error:post-deleted]]');
	}

	/*
	hooks:
		filter:post.upvote
		filter:post.downvote
		filter:post.unvote
		filter:post.bookmark
		filter:post.unbookmark
	 */
	const filteredData = await plugins.hooks.fire(`filter:post.${command}`, {
		data: data,
		uid: caller.uid,
	});
	return await executeCommand(caller, command, eventName, notification, filteredData.data);
};

async function executeCommand(caller, command, eventName, notification, data) {
	const result = await posts[command](data.pid, caller.uid);
	if (result && eventName) {
		websockets.in(`uid_${caller.uid}`).emit(`posts.${command}`, result);
		websockets.in(data.room_id).emit(`event:${eventName}`, result);
	}
	if (result && command === 'upvote') {
		socketHelpers.upvote(result, notification);
	} else if (result && notification) {
		socketHelpers.sendNotificationToPostOwner(data.pid, caller.uid, command, notification);
'use strict';

module.exports = {
	users: require('./users'),
	groups: require('./groups'),
'use strict';

const categories = require('../categories');
const events = require('../events');
const privileges = require('../privileges');

const categoriesAPI = module.exports;

categoriesAPI.get = async function (caller, data) {
	const [userPrivileges, category] = await Promise.all([
		privileges.categories.get(data.cid, caller.uid),
		categories.getCategoryData(data.cid),
	]);
	if (!category || !userPrivileges.read) {
		return null;
	}

	return category;
};

categoriesAPI.create = async function (caller, data) {
	const response = await categories.create(data);
	const categoryObjs = await categories.getCategories([response.cid], caller.uid);
	return categoryObjs[0];
};

categoriesAPI.update = async function (caller, data) {
	await categories.update(data);
};

categoriesAPI.delete = async function (caller, data) {
	const name = await categories.getCategoryField(data.cid, 'name');
	await categories.purge(data.cid, caller.uid);
	await events.log({
		type: 'category-purge',
		uid: caller.uid,
		ip: caller.ip,
		cid: data.cid,
		name: name,
	});
'use strict';

const validator = require('validator');
const _ = require('lodash');

const utils = require('../utils');
const user = require('../user');
const posts = require('../posts');
const topics = require('../topics');
const groups = require('../groups');
const meta = require('../meta');
const events = require('../events');
const privileges = require('../privileges');
const apiHelpers = require('./helpers');
const websockets = require('../socket.io');
const socketHelpers = require('../socket.io/helpers');

const postsAPI = module.exports;

postsAPI.get = async function (caller, data) {
	const [userPrivileges, post, voted] = await Promise.all([
		privileges.posts.get([data.pid], caller.uid),
		posts.getPostData(data.pid),
		posts.hasVoted(data.pid, caller.uid),
	]);
	if (!post) {
		return null;
	}
	Object.assign(post, voted);

	const userPrivilege = userPrivileges[0];
	if (!userPrivilege.read || !userPrivilege['topics:read']) {
		return null;
	}

	post.ip = userPrivilege.isAdminOrMod ? post.ip : undefined;
	const selfPost = caller.uid && caller.uid === parseInt(post.uid, 10);
	if (post.deleted && !(userPrivilege.isAdminOrMod || selfPost)) {
		post.content = '[[topic:post_is_deleted]]';
	}

	return post;
};

postsAPI.edit = async function (caller, data) {
	if (!data || !data.pid || (meta.config.minimumPostLength !== 0 && !data.content)) {
		throw new Error('[[error:invalid-data]]');
	}
	// Trim and remove HTML (latter for composers that send in HTML, like redactor)
	const contentLen = utils.stripHTMLTags(data.content).trim().length;

	if (data.title && data.title.length < meta.config.minimumTitleLength) {
		throw new Error(`[[error:title-too-short, ${meta.config.minimumTitleLength}]]`);
	} else if (data.title && data.title.length > meta.config.maximumTitleLength) {
		throw new Error(`[[error:title-too-long, ${meta.config.maximumTitleLength}]]`);
	} else if (meta.config.minimumPostLength !== 0 && contentLen < meta.config.minimumPostLength) {
		throw new Error(`[[error:content-too-short, ${meta.config.minimumPostLength}]]`);
	} else if (contentLen > meta.config.maximumPostLength) {
		throw new Error(`[[error:content-too-long, ${meta.config.maximumPostLength}]]`);
	}

	data.uid = caller.uid;
	data.req = apiHelpers.buildReqObject(caller);

	const editResult = await posts.edit(data);
	if (editResult.topic.isMainPost) {
		await topics.thumbs.migrate(data.uuid, editResult.topic.tid);
	}
	if (editResult.topic.renamed) {
		await events.log({
			type: 'topic-rename',
			uid: caller.uid,
			ip: caller.ip,
			tid: editResult.topic.tid,
			oldTitle: validator.escape(String(editResult.topic.oldTitle)),
			newTitle: validator.escape(String(editResult.topic.title)),
		});
	}
	const postObj = await posts.getPostSummaryByPids([editResult.post.pid], caller.uid, {});
	const returnData = { ...postObj[0], ...editResult.post };
	returnData.topic = { ...postObj[0].topic, ...editResult.post.topic };

	if (!editResult.post.deleted) {
		websockets.in(`topic_${editResult.topic.tid}`).emit('event:post_edited', editResult);
		return returnData;
	}

	const memberData = await groups.getMembersOfGroups([
		'administrators',
		'Global Moderators',
		`cid:${editResult.topic.cid}:privileges:moderate`,
		`cid:${editResult.topic.cid}:privileges:groups:moderate`,
	]);

	const uids = _.uniq(_.flatten(memberData).concat(String(caller.uid)));
	uids.forEach(uid =>	websockets.in(`uid_${uid}`).emit('event:post_edited', editResult));
	return returnData;
};

postsAPI.delete = async function (caller, data) {
	await deleteOrRestore(caller, data, {
		command: 'delete',
		event: 'event:post_deleted',
		type: 'post-delete',
	});
};

postsAPI.restore = async function (caller, data) {
	await deleteOrRestore(caller, data, {
		command: 'restore',
		event: 'event:post_restored',
		type: 'post-restore',
	});
};

async function deleteOrRestore(caller, data, params) {
	if (!data || !data.pid) {
		throw new Error('[[error:invalid-data]]');
	}
	const postData = await posts.tools[params.command](caller.uid, data.pid);
	const results = await isMainAndLastPost(data.pid);
	if (results.isMain && results.isLast) {
		await deleteOrRestoreTopicOf(params.command, data.pid, caller);
	}

	websockets.in(`topic_${postData.tid}`).emit(params.event, postData);

	await events.log({
		type: params.type,
		uid: caller.uid,
		pid: data.pid,
		tid: postData.tid,
		ip: caller.ip,
	});
}

async function deleteOrRestoreTopicOf(command, pid, caller) {
	const topic = await posts.getTopicFields(pid, ['tid', 'cid', 'deleted']);
	// command: delete/restore
	await apiHelpers.doTopicAction(
		command,
		topic.deleted ? 'event:topic_restored' : 'event:topic_deleted',
		caller,
		{ tids: [topic.tid], cid: topic.cid }
	);
}

postsAPI.purge = async function (caller, data) {
	if (!data || !parseInt(data.pid, 10)) {
		throw new Error('[[error:invalid-data]]');
	}

	const results = await isMainAndLastPost(data.pid);
	if (results.isMain && !results.isLast) {
		throw new Error('[[error:cant-purge-main-post]]');
	}

	const isMainAndLast = results.isMain && results.isLast;
	const postData = await posts.getPostFields(data.pid, ['toPid', 'tid']);
	postData.pid = data.pid;

	const canPurge = await privileges.posts.canPurge(data.pid, caller.uid);
	if (!canPurge) {
		throw new Error('[[error:no-privileges]]');
	}
	require('../posts/cache').del(data.pid);
	await posts.purge(data.pid, caller.uid);

	websockets.in(`topic_${postData.tid}`).emit('event:post_purged', postData);
	const topicData = await topics.getTopicFields(postData.tid, ['title', 'cid']);

	await events.log({
		type: 'post-purge',
		pid: data.pid,
		uid: caller.uid,
		ip: caller.ip,
		tid: postData.tid,
		title: String(topicData.title),
	});

	if (isMainAndLast) {
		await apiHelpers.doTopicAction(
			'purge',
			'event:topic_purged',
			caller,
			{ tids: [postData.tid], cid: topicData.cid }
		);
	}
};

async function isMainAndLastPost(pid) {
	const [isMain, topicData] = await Promise.all([
		posts.isMain(pid),
		posts.getTopicFields(pid, ['postcount']),
	]);
	return {
		isMain: isMain,
		isLast: topicData && topicData.postcount === 1,
	};
}

postsAPI.move = async function (caller, data) {
	const canMove = await Promise.all([
		privileges.topics.isAdminOrMod(data.tid, caller.uid),
		privileges.posts.canMove(data.pid, caller.uid),
	]);
	if (!canMove.every(Boolean)) {
		throw new Error('[[error:no-privileges]]');
	}

	await topics.movePostToTopic(caller.uid, data.pid, data.tid);

	const [postDeleted, topicDeleted] = await Promise.all([
		posts.getPostField(data.pid, 'deleted'),
		topics.getTopicField(data.tid, 'deleted'),
	]);

	if (!postDeleted && !topicDeleted) {
		socketHelpers.sendNotificationToPostOwner(data.pid, caller.uid, 'move', 'notifications:moved_your_post');
	}
};

postsAPI.upvote = async function (caller, data) {
	return await apiHelpers.postCommand(caller, 'upvote', 'voted', 'notifications:upvoted_your_post_in', data);
};

postsAPI.downvote = async function (caller, data) {
	return await apiHelpers.postCommand(caller, 'downvote', 'voted', '', data);
};

postsAPI.unvote = async function (caller, data) {
	return await apiHelpers.postCommand(caller, 'unvote', 'voted', '', data);
};

postsAPI.bookmark = async function (caller, data) {
	return await apiHelpers.postCommand(caller, 'bookmark', 'bookmarked', '', data);
};

postsAPI.unbookmark = async function (caller, data) {
	return await apiHelpers.postCommand(caller, 'unbookmark', 'bookmarked', '', data);
};

async function diffsPrivilegeCheck(pid, uid) {
	const [deleted, privilegesData] = await Promise.all([
		posts.getPostField(pid, 'deleted'),
		privileges.posts.get([pid], uid),
	]);

	const allowed = privilegesData[0]['posts:history'] && (deleted ? privilegesData[0]['posts:view_deleted'] : true);
	if (!allowed) {
		throw new Error('[[error:no-privileges]]');
	}
}

postsAPI.getDiffs = async (caller, data) => {
	await diffsPrivilegeCheck(data.pid, caller.uid);
	const timestamps = await posts.diffs.list(data.pid);
	const post = await posts.getPostFields(data.pid, ['timestamp', 'uid']);

	const diffs = await posts.diffs.get(data.pid);
	const uids = diffs.map(diff => diff.uid || null);
	uids.push(post.uid);
	let usernames = await user.getUsersFields(uids, ['username']);
	usernames = usernames.map(userObj => (userObj.uid ? userObj.username : null));

	const cid = await posts.getCidByPid(data.pid);
	const [isAdmin, isModerator] = await Promise.all([
		user.isAdministrator(caller.uid),
		privileges.users.isModerator(caller.uid, cid),
	]);

	// timestamps returned by posts.diffs.list are strings
	timestamps.push(String(post.timestamp));

	return {
		timestamps: timestamps,
		revisions: timestamps.map((timestamp, idx) => ({
			timestamp: timestamp,
			username: usernames[idx],
		})),
		// Only admins, global mods and moderator of that cid can delete a diff
		deletable: isAdmin || isModerator,
		// These and post owners can restore to a different post version
		editable: isAdmin || isModerator || parseInt(caller.uid, 10) === parseInt(post.uid, 10),
	};
};

postsAPI.loadDiff = async (caller, data) => {
	await diffsPrivilegeCheck(data.pid, caller.uid);
	return await posts.diffs.load(data.pid, data.since, caller.uid);
};

postsAPI.restoreDiff = async (caller, data) => {
	const cid = await posts.getCidByPid(data.pid);
	const canEdit = await privileges.categories.can('posts:edit', cid, caller.uid);
	if (!canEdit) {
		throw new Error('[[error:no-privileges]]');
	}

	const edit = await posts.diffs.restore(data.pid, data.since, caller.uid, apiHelpers.buildReqObject(caller));
'use strict';

const validator = require('validator');

const db = require('../database');
const user = require('../user');
const groups = require('../groups');
const meta = require('../meta');
const flags = require('../flags');
const privileges = require('../privileges');
const notifications = require('../notifications');
const plugins = require('../plugins');
const events = require('../events');
const translator = require('../translator');
const sockets = require('../socket.io');

const usersAPI = module.exports;

usersAPI.create = async function (caller, data) {
	if (!data) {
		throw new Error('[[error:invalid-data]]');
	}
	const uid = await user.create(data);
	return await user.getUserData(uid);
};

usersAPI.update = async function (caller, data) {
	if (!caller.uid) {
		throw new Error('[[error:invalid-uid]]');
	}

	if (!data || !data.uid) {
		throw new Error('[[error:invalid-data]]');
	}

	const oldUserData = await user.getUserFields(data.uid, ['email', 'username']);
	if (!oldUserData || !oldUserData.username) {
		throw new Error('[[error:invalid-data]]');
	}

	const [isAdminOrGlobalMod, canEdit] = await Promise.all([
		user.isAdminOrGlobalMod(caller.uid),
		privileges.users.canEdit(caller.uid, data.uid),
	]);

	// Changing own email/username requires password confirmation
	if (['email', 'username'].some(prop => Object.keys(data).includes(prop))) {
		await isPrivilegedOrSelfAndPasswordMatch(caller, data);
	}

	if (!canEdit) {
		throw new Error('[[error:no-privileges]]');
	}

	if (!isAdminOrGlobalMod && meta.config['username:disableEdit']) {
		data.username = oldUserData.username;
	}

	if (!isAdminOrGlobalMod && meta.config['email:disableEdit']) {
		data.email = oldUserData.email;
	}

	await user.updateProfile(caller.uid, data);
	const userData = await user.getUserData(data.uid);

	async function log(type, eventData) {
		eventData.type = type;
		eventData.uid = caller.uid;
		eventData.targetUid = data.uid;
		eventData.ip = caller.ip;
		await events.log(eventData);
	}

	if (userData.email !== oldUserData.email) {
		await log('email-change', { oldEmail: oldUserData.email, newEmail: userData.email });
	}

	if (userData.username !== oldUserData.username) {
		await log('username-change', { oldUsername: oldUserData.username, newUsername: userData.username });
	}
	return userData;
};

usersAPI.delete = async function (caller, { uid, password }) {
	await processDeletion({ uid: uid, method: 'delete', password, caller });
};

usersAPI.deleteContent = async function (caller, { uid, password }) {
	await processDeletion({ uid, method: 'deleteContent', password, caller });
};

usersAPI.deleteAccount = async function (caller, { uid, password }) {
	await processDeletion({ uid, method: 'deleteAccount', password, caller });
};

usersAPI.deleteMany = async function (caller, data) {
	if (await canDeleteUids(data.uids)) {
		await Promise.all(data.uids.map(uid => processDeletion({ uid, method: 'delete', caller })));
	}
};

usersAPI.updateSettings = async function (caller, data) {
	if (!caller.uid || !data || !data.settings) {
		throw new Error('[[error:invalid-data]]');
	}

	const canEdit = await privileges.users.canEdit(caller.uid, data.uid);
	if (!canEdit) {
		throw new Error('[[error:no-privileges]]');
	}

	let defaults = await user.getSettings(0);
	defaults = {
		postsPerPage: defaults.postsPerPage,
		topicsPerPage: defaults.topicsPerPage,
		userLang: defaults.userLang,
		acpLang: defaults.acpLang,
	};
	// load raw settings without parsing values to booleans
	const current = await db.getObject(`user:${data.uid}:settings`);
	const payload = { ...defaults, ...current, ...data.settings };
	delete payload.uid;

	return await user.saveSettings(data.uid, payload);
};

usersAPI.changePassword = async function (caller, data) {
	await user.changePassword(caller.uid, Object.assign(data, { ip: caller.ip }));
	await events.log({
		type: 'password-change',
		uid: caller.uid,
		targetUid: data.uid,
		ip: caller.ip,
	});
};

usersAPI.follow = async function (caller, data) {
	await user.follow(caller.uid, data.uid);
	plugins.hooks.fire('action:user.follow', {
		fromUid: caller.uid,
		toUid: data.uid,
	});

	const userData = await user.getUserFields(caller.uid, ['username', 'userslug']);
	const notifObj = await notifications.create({
		type: 'follow',
		bodyShort: `[[notifications:user_started_following_you, ${userData.username}]]`,
		nid: `follow:${data.uid}:uid:${caller.uid}`,
		from: caller.uid,
		path: `/uid/${data.uid}/followers`,
		mergeId: 'notifications:user_started_following_you',
	});
	if (!notifObj) {
		return;
	}
	notifObj.user = userData;
	await notifications.push(notifObj, [data.uid]);
};

usersAPI.unfollow = async function (caller, data) {
	await user.unfollow(caller.uid, data.uid);
	plugins.hooks.fire('action:user.unfollow', {
		fromUid: caller.uid,
		toUid: data.uid,
	});
};

usersAPI.ban = async function (caller, data) {
	if (!await privileges.users.hasBanPrivilege(caller.uid)) {
		throw new Error('[[error:no-privileges]]');
	} else if (await user.isAdministrator(data.uid)) {
		throw new Error('[[error:cant-ban-other-admins]]');
	}

	const banData = await user.bans.ban(data.uid, data.until, data.reason);
	await db.setObjectField(`uid:${data.uid}:ban:${banData.timestamp}`, 'fromUid', caller.uid);

	if (!data.reason) {
		data.reason = await translator.translate('[[user:info.banned-no-reason]]');
	}

	sockets.in(`uid_${data.uid}`).emit('event:banned', {
		until: data.until,
		reason: validator.escape(String(data.reason || '')),
	});

	await flags.resolveFlag('user', data.uid, caller.uid);
	await flags.resolveUserPostFlags(data.uid, caller.uid);
	await events.log({
		type: 'user-ban',
		uid: caller.uid,
		targetUid: data.uid,
		ip: caller.ip,
		reason: data.reason || undefined,
	});
	plugins.hooks.fire('action:user.banned', {
		callerUid: caller.uid,
		ip: caller.ip,
		uid: data.uid,
		until: data.until > 0 ? data.until : undefined,
		reason: data.reason || undefined,
	});
	const canLoginIfBanned = await user.bans.canLoginIfBanned(data.uid);
	if (!canLoginIfBanned) {
		await user.auth.revokeAllSessions(data.uid);
	}
};

usersAPI.unban = async function (caller, data) {
	if (!await privileges.users.hasBanPrivilege(caller.uid)) {
		throw new Error('[[error:no-privileges]]');
	}

	await user.bans.unban(data.uid);

	sockets.in(`uid_${data.uid}`).emit('event:unbanned');

	await events.log({
		type: 'user-unban',
		uid: caller.uid,
		targetUid: data.uid,
		ip: caller.ip,
	});
	plugins.hooks.fire('action:user.unbanned', {
		callerUid: caller.uid,
		ip: caller.ip,
		uid: data.uid,
	});
};

async function isPrivilegedOrSelfAndPasswordMatch(caller, data) {
	const { uid } = caller;
	const isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);

	const [isAdmin, isTargetAdmin, isGlobalMod] = await Promise.all([
		user.isAdministrator(uid),
		user.isAdministrator(data.uid),
		user.isGlobalModerator(uid),
	]);

	if ((isTargetAdmin && !isAdmin) || (!isSelf && !(isAdmin || isGlobalMod))) {
		throw new Error('[[error:no-privileges]]');
	}
	const [hasPassword, passwordMatch] = await Promise.all([
		user.hasPassword(data.uid),
		data.password ? user.isPasswordCorrect(data.uid, data.password, caller.ip) : false,
	]);

	if (isSelf && hasPassword && !passwordMatch) {
		throw new Error('[[error:invalid-password]]');
	}
}

async function processDeletion({ uid, method, password, caller }) {
	const isTargetAdmin = await user.isAdministrator(uid);
	const isSelf = parseInt(uid, 10) === caller.uid;
	const isAdmin = await user.isAdministrator(caller.uid);

	if (isSelf && meta.config.allowAccountDelete !== 1) {
		throw new Error('[[error:account-deletion-disabled]]');
	} else if (!isSelf && !isAdmin) {
		throw new Error('[[error:no-privileges]]');
	} else if (isTargetAdmin) {
		throw new Error('[[error:cant-delete-admin]');
	}

	// Privilege checks -- only deleteAccount is available for non-admins
	const hasAdminPrivilege = await privileges.admin.can('admin:users', caller.uid);
	if (!hasAdminPrivilege && ['delete', 'deleteContent'].includes(method)) {
		throw new Error('[[error:no-privileges]]');
	}

	// Self-deletions require a password
	const hasPassword = await user.hasPassword(uid);
	if (isSelf && hasPassword) {
		const ok = await user.isPasswordCorrect(uid, password, caller.ip);
		if (!ok) {
			throw new Error('[[error:invalid-password]]');
		}
	}

	await flags.resolveFlag('user', uid, caller.uid);

	let userData;
	if (method === 'deleteAccount') {
		userData = await user[method](uid);
	} else {
		userData = await user[method](caller.uid, uid);
	}
	userData = userData || {};

	sockets.server.sockets.emit('event:user_status_change', { uid: caller.uid, status: 'offline' });

	plugins.hooks.fire('action:user.delete', {
		callerUid: caller.uid,
		uid: uid,
		ip: caller.ip,
		user: userData,
	});

	await events.log({
		type: `user-${method}`,
		uid: caller.uid,
		targetUid: uid,
		ip: caller.ip,
		username: userData.username,
		email: userData.email,
	});
}

async function canDeleteUids(uids) {
	if (!Array.isArray(uids)) {
		throw new Error('[[error:invalid-data]]');
	}
	const isMembers = await groups.isMembers(uids, 'administrators');
	if (isMembers.includes(true)) {
		throw new Error('[[error:cant-delete-other-admins]]');
	}

	return true;
}

usersAPI.search = async function (caller, data) {
	const [allowed, isPrivileged] = await Promise.all([
		privileges.global.can('search:users', caller.uid),
		user.isPrivileged(caller.uid),
	]);
	let filters = data.filters || [];
	filters = Array.isArray(filters) ? filters : [filters];
	if (!allowed ||
		((
			data.searchBy === 'ip' ||
			data.searchBy === 'email' ||
			filters.includes('banned') ||
			filters.includes('flagged')
		) && !isPrivileged)
	) {
		throw new Error('[[error:no-privileges]]');
	}
	return await user.search({
		query: data.query,
		searchBy: data.searchBy || 'username',
		page: data.page || 1,
		sortBy: data.sortBy || 'lastonline',
		filters: filters,
'use strict';

const meta = require('../meta');
const plugins = require('../plugins');
const slugify = require('../slugify');
const db = require('../database');

module.exports = function (Groups) {
	Groups.create = async function (data) {
		const isSystem = isSystemGroup(data);
		const timestamp = data.timestamp || Date.now();
		let disableJoinRequests = parseInt(data.disableJoinRequests, 10) === 1 ? 1 : 0;
		if (data.name === 'administrators') {
			disableJoinRequests = 1;
		}
		const disableLeave = parseInt(data.disableLeave, 10) === 1 ? 1 : 0;
		const isHidden = parseInt(data.hidden, 10) === 1;

		Groups.validateGroupName(data.name);

		const exists = await meta.userOrGroupExists(data.name);
		if (exists) {
			throw new Error('[[error:group-already-exists]]');
		}

		const memberCount = data.hasOwnProperty('ownerUid') ? 1 : 0;
		const isPrivate = data.hasOwnProperty('private') && data.private !== undefined ? parseInt(data.private, 10) === 1 : true;
		let groupData = {
			name: data.name,
			slug: slugify(data.name),
			createtime: timestamp,
			userTitle: data.userTitle || data.name,
			userTitleEnabled: parseInt(data.userTitleEnabled, 10) === 1 ? 1 : 0,
			description: data.description || '',
			memberCount: memberCount,
			hidden: isHidden ? 1 : 0,
			system: isSystem ? 1 : 0,
			private: isPrivate ? 1 : 0,
			disableJoinRequests: disableJoinRequests,
			disableLeave: disableLeave,
		};

		await plugins.hooks.fire('filter:group.create', { group: groupData, data: data });

		await db.sortedSetAdd('groups:createtime', groupData.createtime, groupData.name);
		await db.setObject(`group:${groupData.name}`, groupData);

		if (data.hasOwnProperty('ownerUid')) {
			await db.setAdd(`group:${groupData.name}:owners`, data.ownerUid);
			await db.sortedSetAdd(`group:${groupData.name}:members`, timestamp, data.ownerUid);
		}

		if (!isHidden && !isSystem) {
			await db.sortedSetAddBulk([
				['groups:visible:createtime', timestamp, groupData.name],
				['groups:visible:memberCount', groupData.memberCount, groupData.name],
				['groups:visible:name', 0, `${groupData.name.toLowerCase()}:${groupData.name}`],
			]);
		}

		await db.setObjectField('groupslug:groupname', groupData.slug, groupData.name);

		groupData = await Groups.getGroupData(groupData.name);
		plugins.hooks.fire('action:group.create', { group: groupData });
		return groupData;
	};

	function isSystemGroup(data) {
		return data.system === true || parseInt(data.system, 10) === 1 ||
			Groups.systemGroups.includes(data.name) ||
			Groups.isPrivilegeGroup(data.name);
	}

	Groups.validateGroupName = function (name) {
		if (!name) {
			throw new Error('[[error:group-name-too-short]]');
		}

		if (typeof name !== 'string') {
			throw new Error('[[error:invalid-group-name]]');
		}

		if (!Groups.isPrivilegeGroup(name) && name.length > meta.config.maximumGroupNameLength) {
			throw new Error('[[error:group-name-too-long]]');
		}

		if (name === 'guests' || (!Groups.isPrivilegeGroup(name) && name.includes(':'))) {
			throw new Error('[[error:invalid-group-name]]');
		}

'use strict';

const _ = require('lodash');

const db = require('../database');
const user = require('../user');
const slugify = require('../slugify');
const plugins = require('../plugins');
const notifications = require('../notifications');

module.exports = function (Groups) {
	Groups.requestMembership = async function (groupName, uid) {
		await inviteOrRequestMembership(groupName, uid, 'request');
		const username = await user.getUserField(uid, 'username');
		const [notification, owners] = await Promise.all([
			notifications.create({
				type: 'group-request-membership',
				bodyShort: `[[groups:request.notification_title, ${username}]]`,
				bodyLong: `[[groups:request.notification_text, ${username}, ${groupName}]]`,
				nid: `group:${groupName}:uid:${uid}:request`,
				path: `/groups/${slugify(groupName)}`,
				from: uid,
			}),
			Groups.getOwners(groupName),
		]);

		await notifications.push(notification, owners);
	};

	Groups.acceptMembership = async function (groupName, uid) {
		await db.setsRemove([`group:${groupName}:pending`, `group:${groupName}:invited`], uid);
		await Groups.join(groupName, uid);

		const notification = await notifications.create({
			type: 'group-invite',
			bodyShort: `[[groups:membership.accept.notification_title, ${groupName}]]`,
			nid: `group:${groupName}:uid:${uid}:invite-accepted`,
			path: `/groups/${slugify(groupName)}`,
		});
		await notifications.push(notification, [uid]);
	};

	Groups.rejectMembership = async function (groupNames, uid) {
		if (!Array.isArray(groupNames)) {
			groupNames = [groupNames];
		}
		const sets = [];
		groupNames.forEach(groupName =>	sets.push(`group:${groupName}:pending`, `group:${groupName}:invited`));
		await db.setsRemove(sets, uid);
	};

	Groups.invite = async function (groupName, uids) {
		uids = Array.isArray(uids) ? uids : [uids];
		uids = await inviteOrRequestMembership(groupName, uids, 'invite');

		const notificationData = await Promise.all(uids.map(uid => notifications.create({
			type: 'group-invite',
			bodyShort: `[[groups:invited.notification_title, ${groupName}]]`,
			bodyLong: '',
			nid: `group:${groupName}:uid:${uid}:invite`,
			path: `/groups/${slugify(groupName)}`,
		})));

		await Promise.all(uids.map((uid, index) => notifications.push(notificationData[index], uid)));
	};

	async function inviteOrRequestMembership(groupName, uids, type) {
		uids = Array.isArray(uids) ? uids : [uids];
		uids = uids.filter(uid => parseInt(uid, 10) > 0);
		const [exists, isMember, isPending, isInvited] = await Promise.all([
			Groups.exists(groupName),
			Groups.isMembers(uids, groupName),
			Groups.isPending(uids, groupName),
			Groups.isInvited(uids, groupName),
		]);

		if (!exists) {
			throw new Error('[[error:no-group]]');
		}

		uids = uids.filter((uid, i) => !isMember[i] && ((type === 'invite' && !isInvited[i]) || (type === 'request' && !isPending[i])));

		const set = type === 'invite' ? `group:${groupName}:invited` : `group:${groupName}:pending`;
		await db.setAdd(set, uids);
		const hookName = type === 'invite' ? 'action:group.inviteMember' : 'action:group.requestMembership';
		plugins.hooks.fire(hookName, {
			groupName: groupName,
			uids: uids,
		});
		return uids;
	}

	Groups.isInvited = async function (uids, groupName) {
		return await checkInvitePending(uids, `group:${groupName}:invited`);
	};

	Groups.isPending = async function (uids, groupName) {
		return await checkInvitePending(uids, `group:${groupName}:pending`);
	};

	async function checkInvitePending(uids, set) {
		const isArray = Array.isArray(uids);
		uids = isArray ? uids : [uids];
		const checkUids = uids.filter(uid => parseInt(uid, 10) > 0);
		const isMembers = await db.isSetMembers(set, checkUids);
		const map = _.zipObject(checkUids, isMembers);
		return isArray ? uids.map(uid => !!map[uid]) : !!map[uids[0]];
	}

	Groups.getPending = async function (groupName) {
		if (!groupName) {
			return [];
		}
		return await db.getSetMembers(`group:${groupName}:pending`);
	};
'use strict';

const validator = require('validator');
const nconf = require('nconf');

const db = require('../database');
const plugins = require('../plugins');
const utils = require('../utils');
const translator = require('../translator');

const intFields = [
	'createtime', 'memberCount', 'hidden', 'system', 'private',
	'userTitleEnabled', 'disableJoinRequests', 'disableLeave',
];

module.exports = function (Groups) {
	Groups.getGroupsFields = async function (groupNames, fields) {
		if (!Array.isArray(groupNames) || !groupNames.length) {
			return [];
		}

		const ephemeralIdx = groupNames.reduce((memo, cur, idx) => {
			if (Groups.ephemeralGroups.includes(cur)) {
				memo.push(idx);
			}
			return memo;
		}, []);

		const keys = groupNames.map(groupName => `group:${groupName}`);
		const groupData = await (fields.length ? db.getObjectsFields(keys, fields) : db.getObjects(keys));
		if (ephemeralIdx.length) {
			ephemeralIdx.forEach((idx) => {
				groupData[idx] = Groups.getEphemeralGroup(groupNames[idx]);
			});
		}

		groupData.forEach(group => modifyGroup(group, fields));

		const results = await plugins.hooks.fire('filter:groups.get', { groups: groupData });
		return results.groups;
	};

	Groups.getGroupsData = async function (groupNames) {
		return await Groups.getGroupsFields(groupNames, []);
	};

	Groups.getGroupData = async function (groupName) {
		const groupsData = await Groups.getGroupsData([groupName]);
		return Array.isArray(groupsData) && groupsData[0] ? groupsData[0] : null;
	};

	Groups.getGroupField = async function (groupName, field) {
		const groupData = await Groups.getGroupFields(groupName, [field]);
		return groupData ? groupData[field] : null;
	};

	Groups.getGroupFields = async function (groupName, fields) {
		const groups = await Groups.getGroupsFields([groupName], fields);
		return groups ? groups[0] : null;
	};

	Groups.setGroupField = async function (groupName, field, value) {
		await db.setObjectField(`group:${groupName}`, field, value);
		plugins.hooks.fire('action:group.set', { field: field, value: value, type: 'set' });
	};
};

function modifyGroup(group, fields) {
	if (group) {
		db.parseIntFields(group, intFields, fields);

		escapeGroupData(group);
		group.userTitleEnabled = ([null, undefined].includes(group.userTitleEnabled)) ? 1 : group.userTitleEnabled;
		group.labelColor = validator.escape(String(group.labelColor || '#000000'));
		group.textColor = validator.escape(String(group.textColor || '#ffffff'));
		group.icon = validator.escape(String(group.icon || ''));
		group.createtimeISO = utils.toISOString(group.createtime);
		group.private = ([null, undefined].includes(group.private)) ? 1 : group.private;
		group.memberPostCids = group.memberPostCids || '';
		group.memberPostCidsArray = group.memberPostCids.split(',').map(cid => parseInt(cid, 10)).filter(Boolean);

		group['cover:thumb:url'] = group['cover:thumb:url'] || group['cover:url'];

		if (group['cover:url']) {
			group['cover:url'] = group['cover:url'].startsWith('http') ? group['cover:url'] : (nconf.get('relative_path') + group['cover:url']);
		} else {
			group['cover:url'] = require('../coverPhoto').getDefaultGroupCover(group.name);
		}

		if (group['cover:thumb:url']) {
			group['cover:thumb:url'] = group['cover:thumb:url'].startsWith('http') ? group['cover:thumb:url'] : (nconf.get('relative_path') + group['cover:thumb:url']);
		} else {
			group['cover:thumb:url'] = require('../coverPhoto').getDefaultGroupCover(group.name);
		}

		group['cover:position'] = validator.escape(String(group['cover:position'] || '50% 50%'));
	}
}

function escapeGroupData(group) {
	if (group) {
		group.nameEncoded = encodeURIComponent(group.name);
		group.displayName = validator.escape(String(group.name));
		group.description = validator.escape(String(group.description || ''));
		group.userTitle = validator.escape(String(group.userTitle || ''));
'use strict';

const plugins = require('../plugins');
const slugify = require('../slugify');
const db = require('../database');
const batch = require('../batch');

module.exports = function (Groups) {
	Groups.destroy = async function (groupNames) {
		if (!Array.isArray(groupNames)) {
			groupNames = [groupNames];
		}

		let groupsData = await Groups.getGroupsData(groupNames);
		groupsData = groupsData.filter(Boolean);
		if (!groupsData.length) {
			return;
		}
		const keys = [];
		groupNames.forEach((groupName) => {
			keys.push(
				`group:${groupName}`,
				`group:${groupName}:members`,
				`group:${groupName}:pending`,
				`group:${groupName}:invited`,
				`group:${groupName}:owners`,
				`group:${groupName}:member:pids`
			);
		});
		const sets = groupNames.map(groupName => `${groupName.toLowerCase()}:${groupName}`);
		const fields = groupNames.map(groupName => slugify(groupName));

		await Promise.all([
			db.deleteAll(keys),
			db.sortedSetRemove([
				'groups:createtime',
				'groups:visible:createtime',
				'groups:visible:memberCount',
			], groupNames),
			db.sortedSetRemove('groups:visible:name', sets),
			db.deleteObjectFields('groupslug:groupname', fields),
			removeGroupsFromPrivilegeGroups(groupNames),
		]);
		Groups.cache.reset();
		plugins.hooks.fire('action:groups.destroy', { groups: groupsData });
	};

	async function removeGroupsFromPrivilegeGroups(groupNames) {
		await batch.processSortedSet('groups:createtime', async (otherGroups) => {
			const privilegeGroups = otherGroups.filter(group => Groups.isPrivilegeGroup(group));
			const keys = privilegeGroups.map(group => `group:${group}:members`);
			await db.sortedSetRemove(keys, groupNames);
		}, {
			batch: 500,
		});
'use strict';

const db = require('../database');
const user = require('../user');
const plugins = require('../plugins');
const cache = require('../cache');

module.exports = function (Groups) {
	Groups.leave = async function (groupNames, uid) {
		if (Array.isArray(groupNames) && !groupNames.length) {
			return;
		}
		if (!Array.isArray(groupNames)) {
			groupNames = [groupNames];
		}

		const isMembers = await Groups.isMemberOfGroups(uid, groupNames);

		const groupsToLeave = groupNames.filter((groupName, index) => isMembers[index]);
		if (!groupsToLeave.length) {
			return;
		}

		await Promise.all([
			db.sortedSetRemove(groupsToLeave.map(groupName => `group:${groupName}:members`), uid),
			db.setRemove(groupsToLeave.map(groupName => `group:${groupName}:owners`), uid),
			db.decrObjectField(groupsToLeave.map(groupName => `group:${groupName}`), 'memberCount'),
		]);

		Groups.clearCache(uid, groupsToLeave);
		cache.del(groupsToLeave.map(name => `group:${name}:members`));

		const groupData = await Groups.getGroupsFields(groupsToLeave, ['name', 'hidden', 'memberCount']);
		if (!groupData) {
			return;
		}

		const emptyPrivilegeGroups = groupData.filter(g => g && Groups.isPrivilegeGroup(g.name) && g.memberCount === 0);
		const visibleGroups = groupData.filter(g => g && !g.hidden);

		const promises = [];
		if (emptyPrivilegeGroups.length) {
			promises.push(Groups.destroy, emptyPrivilegeGroups);
		}
		if (visibleGroups.length) {
			promises.push(
				db.sortedSetAdd,
				'groups:visible:memberCount',
				visibleGroups.map(groupData => groupData.memberCount),
				visibleGroups.map(groupData => groupData.name)
			);
		}

		await Promise.all(promises);

		await clearGroupTitleIfSet(groupsToLeave, uid);

		plugins.hooks.fire('action:group.leave', {
			groupNames: groupsToLeave,
			uid: uid,
		});
	};

	async function clearGroupTitleIfSet(groupNames, uid) {
		groupNames = groupNames.filter(groupName => groupName !== 'registered-users' && !Groups.isPrivilegeGroup(groupName));
		if (!groupNames.length) {
			return;
		}
		const userData = await user.getUserData(uid);
		if (!userData) {
			return;
		}

		const newTitleArray = userData.groupTitleArray.filter(groupTitle => !groupNames.includes(groupTitle));
		if (newTitleArray.length) {
			await db.setObjectField(`user:${uid}`, 'groupTitle', JSON.stringify(newTitleArray));
		} else {
			await db.deleteObjectField(`user:${uid}`, 'groupTitle');
		}
	}

	Groups.leaveAllGroups = async function (uid) {
		const groups = await db.getSortedSetRange('groups:createtime', 0, -1);
		await Promise.all([
			Groups.leave(groups, uid),
			Groups.rejectMembership(groups, uid),
		]);
	};

	Groups.kick = async function (uid, groupName, isOwner) {
		if (isOwner) {
			// If the owners set only contains one member, error out!
			const numOwners = await db.setCount(`group:${groupName}:owners`);
			if (numOwners <= 1) {
				throw new Error('[[error:group-needs-owner]]');
'use strict';

const user = require('../user');
const db = require('../database');

module.exports = function (Groups) {
	Groups.search = async function (query, options) {
		if (!query) {
			return [];
		}
		query = String(query).toLowerCase();
		let groupNames = await db.getSortedSetRange('groups:createtime', 0, -1);
		if (!options.hideEphemeralGroups) {
			groupNames = Groups.ephemeralGroups.concat(groupNames);
		}
		groupNames = groupNames.filter(name => name.toLowerCase().includes(query) &&
			name !== Groups.BANNED_USERS && // hide banned-users in searches
			!Groups.isPrivilegeGroup(name));
		groupNames = groupNames.slice(0, 100);

		let groupsData;
		if (options.showMembers) {
			groupsData = await Groups.getGroupsAndMembers(groupNames);
		} else {
			groupsData = await Groups.getGroupsData(groupNames);
		}
		groupsData = groupsData.filter(Boolean);
		if (options.filterHidden) {
			groupsData = groupsData.filter(group => !group.hidden);
		}
		return Groups.sort(options.sort, groupsData);
	};

	Groups.sort = function (strategy, groups) {
		switch (strategy) {
			case 'count':
				groups.sort((a, b) => a.slug > b.slug)
					.sort((a, b) => b.memberCount - a.memberCount);
				break;

			case 'date':
				groups.sort((a, b) => b.createtime - a.createtime);
				break;

			case 'alpha':	// intentional fall-through
			default:
				groups.sort((a, b) => (a.slug > b.slug ? 1 : -1));
		}

		return groups;
	};

	Groups.searchMembers = async function (data) {
		if (!data.query) {
			const users = await Groups.getOwnersAndMembers(data.groupName, data.uid, 0, 19);
			return { users: users };
		}

		const results = await user.search({
			...data,
			paginate: false,
			hardCap: -1,
		});

		const uids = results.users.map(user => user && user.uid);
		const isOwners = await Groups.ownership.isOwners(uids, data.groupName);

		results.users.forEach((user, index) => {
			if (user) {
				user.isOwner = isOwners[index];
			}
		});

		results.users.sort((a, b) => {
			if (a.isOwner && !b.isOwner) {
				return -1;
			} else if (!a.isOwner && b.isOwner) {
				return 1;
			}
			return 0;
'use strict';

const _ = require('lodash');

const db = require('../database');
const user = require('../user');
const cache = require('../cache');

module.exports = function (Groups) {
	Groups.getMembers = async function (groupName, start, stop) {
		return await db.getSortedSetRevRange(`group:${groupName}:members`, start, stop);
	};

	Groups.getMemberUsers = async function (groupNames, start, stop) {
		async function get(groupName) {
			const uids = await Groups.getMembers(groupName, start, stop);
			return await user.getUsersFields(uids, ['uid', 'username', 'picture', 'userslug']);
		}
		return await Promise.all(groupNames.map(name => get(name)));
	};

	Groups.getMembersOfGroups = async function (groupNames) {
		return await db.getSortedSetsMembers(groupNames.map(name => `group:${name}:members`));
	};

	Groups.isMember = async function (uid, groupName) {
		if (!uid || parseInt(uid, 10) <= 0 || !groupName) {
			return false;
		}

		const cacheKey = `${uid}:${groupName}`;
		let isMember = Groups.cache.get(cacheKey);
		if (isMember !== undefined) {
			return isMember;
		}
		isMember = await db.isSortedSetMember(`group:${groupName}:members`, uid);
		Groups.cache.set(cacheKey, isMember);
		return isMember;
	};

	Groups.isMembers = async function (uids, groupName) {
		if (!groupName || !uids.length) {
			return uids.map(() => false);
		}

		if (groupName === 'guests') {
			return uids.map(uid => parseInt(uid, 10) === 0);
		}

		const cachedData = {};
		const nonCachedUids = uids.filter(uid => filterNonCached(cachedData, uid, groupName));

		if (!nonCachedUids.length) {
			return uids.map(uid => cachedData[`${uid}:${groupName}`]);
		}

		const isMembers = await db.isSortedSetMembers(`group:${groupName}:members`, nonCachedUids);
		nonCachedUids.forEach((uid, index) => {
			cachedData[`${uid}:${groupName}`] = isMembers[index];
			Groups.cache.set(`${uid}:${groupName}`, isMembers[index]);
		});
		return uids.map(uid => cachedData[`${uid}:${groupName}`]);
	};

	Groups.isMemberOfGroups = async function (uid, groups) {
		if (!uid || parseInt(uid, 10) <= 0 || !groups.length) {
			return groups.map(groupName => groupName === 'guests');
		}
		const cachedData = {};
		const nonCachedGroups = groups.filter(groupName => filterNonCached(cachedData, uid, groupName));

		if (!nonCachedGroups.length) {
			return groups.map(groupName => cachedData[`${uid}:${groupName}`]);
		}
		const nonCachedGroupsMemberSets = nonCachedGroups.map(groupName => `group:${groupName}:members`);
		const isMembers = await db.isMemberOfSortedSets(nonCachedGroupsMemberSets, uid);
		nonCachedGroups.forEach((groupName, index) => {
			cachedData[`${uid}:${groupName}`] = isMembers[index];
			Groups.cache.set(`${uid}:${groupName}`, isMembers[index]);
		});

		return groups.map(groupName => cachedData[`${uid}:${groupName}`]);
	};

	function filterNonCached(cachedData, uid, groupName) {
		const isMember = Groups.cache.get(`${uid}:${groupName}`);
		const isInCache = isMember !== undefined;
		if (isInCache) {
			cachedData[`${uid}:${groupName}`] = isMember;
		}
		return !isInCache;
	}

	Groups.isMemberOfAny = async function (uid, groups) {
		if (!groups.length) {
			return false;
		}
		const isMembers = await Groups.isMemberOfGroups(uid, groups);
		return isMembers.includes(true);
	};

	Groups.getMemberCount = async function (groupName) {
		const count = await db.getObjectField(`group:${groupName}`, 'memberCount');
		return parseInt(count, 10);
	};

	Groups.isMemberOfGroupList = async function (uid, groupListKey) {
		let groupNames = await getGroupNames(groupListKey);
		groupNames = Groups.removeEphemeralGroups(groupNames);
		if (!groupNames.length) {
			return false;
		}

		const isMembers = await Groups.isMemberOfGroups(uid, groupNames);
		return isMembers.includes(true);
	};

	Groups.isMemberOfGroupsList = async function (uid, groupListKeys) {
		const members = await getGroupNames(groupListKeys);

		let uniqueGroups = _.uniq(_.flatten(members));
		uniqueGroups = Groups.removeEphemeralGroups(uniqueGroups);

		const isMembers = await Groups.isMemberOfGroups(uid, uniqueGroups);
		const isGroupMember = _.zipObject(uniqueGroups, isMembers);

		return members.map(groupNames => !!groupNames.find(name => isGroupMember[name]));
	};

	Groups.isMembersOfGroupList = async function (uids, groupListKey) {
		const results = uids.map(() => false);

		let groupNames = await getGroupNames(groupListKey);
		groupNames = Groups.removeEphemeralGroups(groupNames);
		if (!groupNames.length) {
			return results;
		}
		const isGroupMembers = await Promise.all(groupNames.map(name => Groups.isMembers(uids, name)));

		isGroupMembers.forEach((isMembers) => {
			results.forEach((isMember, index) => {
				if (!isMember && isMembers[index]) {
					results[index] = true;
				}
			});
		});
		return results;
	};

	async function getGroupNames(keys) {
		const isArray = Array.isArray(keys);
		keys = isArray ? keys : [keys];

		const cachedData = {};
		const nonCachedKeys = keys.filter((groupName) => {
			const groupMembers = cache.get(`group:${groupName}:members`);
			const isInCache = groupMembers !== undefined;
			if (isInCache) {
				cachedData[groupName] = groupMembers;
			}
			return !isInCache;
		});

		if (!nonCachedKeys.length) {
			return isArray ? keys.map(groupName => cachedData[groupName]) : cachedData[keys[0]];
		}
		const groupMembers = await db.getSortedSetsMembers(nonCachedKeys.map(name => `group:${name}:members`));

		nonCachedKeys.forEach((groupName, index) => {
			cachedData[groupName] = groupMembers[index];
'use strict';

const db = require('../database');
const user = require('../user');

module.exports = function (Groups) {
	Groups.getUsersFromSet = async function (set, fields) {
		const uids = await db.getSetMembers(set);

		if (fields) {
			return await user.getUsersFields(uids, fields);
		}
		return await user.getUsersData(uids);
	};

	Groups.getUserGroups = async function (uids) {
		return await Groups.getUserGroupsFromSet('groups:visible:createtime', uids);
	};

	Groups.getUserGroupsFromSet = async function (set, uids) {
		const memberOf = await Groups.getUserGroupMembership(set, uids);
		return await Promise.all(memberOf.map(memberOf => Groups.getGroupsData(memberOf)));
	};

	Groups.getUserGroupMembership = async function (set, uids) {
		const groupNames = await db.getSortedSetRevRange(set, 0, -1);
		return await Promise.all(uids.map(uid => findUserGroups(uid, groupNames)));
	};

	async function findUserGroups(uid, groupNames) {
		const isMembers = await Groups.isMemberOfGroups(uid, groupNames);
		return groupNames.filter((name, i) => isMembers[i]);
	}

	Groups.getUserInviteGroups = async function (uid) {
		let allGroups = await Groups.getNonPrivilegeGroups('groups:createtime', 0, -1);
		allGroups = allGroups.filter(group => !Groups.ephemeralGroups.includes(group.name));

		const publicGroups = allGroups.filter(group => group.hidden === 0 && group.system === 0 && group.private === 0);
		const adminModGroups = [{ name: 'administrators' }, { name: 'Global Moderators' }];
		// Private (but not hidden)
		const privateGroups = allGroups.filter(group => group.hidden === 0 && group.system === 0 && group.private === 1);

		const [ownership, isAdmin, isGlobalMod] = await Promise.all([
			Promise.all(privateGroups.map(group => Groups.ownership.isOwner(uid, group.name))),
			user.isAdministrator(uid),
			user.isGlobalModerator(uid),
		]);
		const ownGroups = privateGroups.filter((group, index) => ownership[index]);

		let inviteGroups = [];
		if (isAdmin) {
			inviteGroups = inviteGroups.concat(adminModGroups).concat(privateGroups);
		} else if (isGlobalMod) {
			inviteGroups = inviteGroups.concat(privateGroups);
		} else {
			inviteGroups = inviteGroups.concat(ownGroups);
		}

		return inviteGroups
'use strict';

const user = require('../user');
const db = require('../database');
const plugins = require('../plugins');
const slugify = require('../slugify');

const Groups = module.exports;

require('./data')(Groups);
require('./create')(Groups);
require('./delete')(Groups);
require('./update')(Groups);
require('./invite')(Groups);
require('./membership')(Groups);
require('./ownership')(Groups);
require('./search')(Groups);
require('./cover')(Groups);
require('./posts')(Groups);
require('./user')(Groups);
require('./join')(Groups);
require('./leave')(Groups);
require('./cache')(Groups);

Groups.BANNED_USERS = 'banned-users';

Groups.ephemeralGroups = ['guests', 'spiders'];

Groups.systemGroups = [
	'registered-users',
	'verified-users',
	'unverified-users',
	Groups.BANNED_USERS,
	'administrators',
	'Global Moderators',
];

Groups.getEphemeralGroup = function (groupName) {
	return {
		name: groupName,
		slug: slugify(groupName),
		description: '',
		hidden: 0,
		system: 1,
	};
};

Groups.removeEphemeralGroups = function (groups) {
	for (let x = groups.length; x >= 0; x -= 1) {
		if (Groups.ephemeralGroups.includes(groups[x])) {
			groups.splice(x, 1);
		}
	}

	return groups;
};

const isPrivilegeGroupRegex = /^cid:\d+:privileges:[\w\-:]+$/;
Groups.isPrivilegeGroup = function (groupName) {
	return isPrivilegeGroupRegex.test(groupName);
};

Groups.getGroupsFromSet = async function (set, start, stop) {
	let groupNames;
	if (set === 'groups:visible:name') {
		groupNames = await db.getSortedSetRangeByLex(set, '-', '+', start, stop - start + 1);
	} else {
		groupNames = await db.getSortedSetRevRange(set, start, stop);
	}
	if (set === 'groups:visible:name') {
		groupNames = groupNames.map(name => name.split(':')[1]);
	}

	return await Groups.getGroupsAndMembers(groupNames);
};

Groups.getGroupsBySort = async function (sort, start, stop) {
	let set = 'groups:visible:name';
	if (sort === 'count') {
		set = 'groups:visible:memberCount';
	} else if (sort === 'date') {
		set = 'groups:visible:createtime';
	}
	return await Groups.getGroupsFromSet(set, start, stop);
};

Groups.getNonPrivilegeGroups = async function (set, start, stop) {
	let groupNames = await db.getSortedSetRevRange(set, start, stop);
	groupNames = groupNames.concat(Groups.ephemeralGroups).filter(groupName => !Groups.isPrivilegeGroup(groupName));
	const groupsData = await Groups.getGroupsData(groupNames);
	return groupsData.filter(Boolean);
};

Groups.getGroups = async function (set, start, stop) {
	return await db.getSortedSetRevRange(set, start, stop);
};

Groups.getGroupsAndMembers = async function (groupNames) {
	const [groups, members] = await Promise.all([
		Groups.getGroupsData(groupNames),
		Groups.getMemberUsers(groupNames, 0, 3),
	]);
	groups.forEach((group, index) => {
		if (group) {
			group.members = members[index] || [];
			group.truncated = group.memberCount > group.members.length;
		}
	});
	return groups;
};

Groups.get = async function (groupName, options) {
	if (!groupName) {
		throw new Error('[[error:invalid-group]]');
	}

	let stop = -1;

	if (options.truncateUserList) {
		stop = (parseInt(options.userListCount, 10) || 4) - 1;
	}

	const [groupData, members, pending, invited, isMember, isPending, isInvited, isOwner] = await Promise.all([
		Groups.getGroupData(groupName),
		Groups.getOwnersAndMembers(groupName, options.uid, 0, stop),
		Groups.getUsersFromSet(`group:${groupName}:pending`, ['username', 'userslug', 'picture']),
		Groups.getUsersFromSet(`group:${groupName}:invited`, ['username', 'userslug', 'picture']),
		Groups.isMember(options.uid, groupName),
		Groups.isPending(options.uid, groupName),
		Groups.isInvited(options.uid, groupName),
		Groups.ownership.isOwner(options.uid, groupName),
	]);

	if (!groupData) {
		return null;
	}
	const descriptionParsed = await plugins.hooks.fire('filter:parse.raw', groupData.description);
	groupData.descriptionParsed = descriptionParsed;
	groupData.members = members;
	groupData.membersNextStart = stop + 1;
	groupData.pending = pending.filter(Boolean);
	groupData.invited = invited.filter(Boolean);
	groupData.isMember = isMember;
	groupData.isPending = isPending;
	groupData.isInvited = isInvited;
	groupData.isOwner = isOwner;
	const results = await plugins.hooks.fire('filter:group.get', { group: groupData });
	return results.group;
};

Groups.getOwners = async function (groupName) {
	return await db.getSetMembers(`group:${groupName}:owners`);
};

Groups.getOwnersAndMembers = async function (groupName, uid, start, stop) {
	const ownerUids = await db.getSetMembers(`group:${groupName}:owners`);
	const countToReturn = stop - start + 1;
	const ownerUidsOnPage = ownerUids.slice(start, stop !== -1 ? stop + 1 : undefined);
	const owners = await user.getUsers(ownerUidsOnPage, uid);
	owners.forEach((user) => {
		if (user) {
			user.isOwner = true;
		}
	});

	let done = false;
	let returnUsers = owners;
	let memberStart = start - ownerUids.length;
	let memberStop = memberStart + countToReturn - 1;
	memberStart = Math.max(0, memberStart);
	memberStop = Math.max(0, memberStop);
	async function addMembers(start, stop) {
		let batch = await user.getUsersFromSet(`group:${groupName}:members`, uid, start, stop);
		if (!batch.length) {
			done = true;
		}
		batch = batch.filter(user => user && user.uid && !ownerUids.includes(user.uid.toString()));
		returnUsers = returnUsers.concat(batch);
	}

	if (stop === -1) {
		await addMembers(memberStart, -1);
	} else {
		while (returnUsers.length < countToReturn && !done) {
			/* eslint-disable no-await-in-loop */
			await addMembers(memberStart, memberStop);
			memberStart = memberStop + 1;
			memberStop = memberStart + countToReturn - 1;
		}
	}
	returnUsers = countToReturn > 0 ? returnUsers.slice(0, countToReturn) : returnUsers;
	const result = await plugins.hooks.fire('filter:group.getOwnersAndMembers', {
		users: returnUsers,
		uid: uid,
		start: start,
		stop: stop,
	});
	return result.users;
};

Groups.getByGroupslug = async function (slug, options) {
	options = options || {};
	const groupName = await db.getObjectField('groupslug:groupname', slug);
	if (!groupName) {
		throw new Error('[[error:no-group]]');
	}
	return await Groups.get(groupName, options);
};

Groups.getGroupNameByGroupSlug = async function (slug) {
	return await db.getObjectField('groupslug:groupname', slug);
};

Groups.isPrivate = async function (groupName) {
	return await isFieldOn(groupName, 'private');
};

Groups.isHidden = async function (groupName) {
	return await isFieldOn(groupName, 'hidden');
};

async function isFieldOn(groupName, field) {
	const value = await db.getObjectField(`group:${groupName}`, field);
	return parseInt(value, 10) === 1;
}

Groups.exists = async function (name) {
	if (Array.isArray(name)) {
		const slugs = name.map(groupName => slugify(groupName));
		const isMembersOfRealGroups = await db.isSortedSetMembers('groups:createtime', name);
		const isMembersOfEphemeralGroups = slugs.map(slug => Groups.ephemeralGroups.includes(slug));
		return name.map((n, index) => isMembersOfRealGroups[index] || isMembersOfEphemeralGroups[index]);
	}
	const slug = slugify(name);
	const isMemberOfRealGroups = await db.isSortedSetMember('groups:createtime', name);
	const isMemberOfEphemeralGroups = Groups.ephemeralGroups.includes(slug);
	return isMemberOfRealGroups || isMemberOfEphemeralGroups;
};

Groups.existsBySlug = async function (slug) {
	if (Array.isArray(slug)) {
		return await db.isObjectFields('groupslug:groupname', slug);
	}
	return await db.isObjectField('groupslug:groupname', slug);
};
'use strict';

const db = require('../database');
const plugins = require('../plugins');

module.exports = function (Groups) {
	Groups.ownership = {};

	Groups.ownership.isOwner = async function (uid, groupName) {
		if (!(parseInt(uid, 10) > 0)) {
			return false;
		}
		return await db.isSetMember(`group:${groupName}:owners`, uid);
	};

	Groups.ownership.isOwners = async function (uids, groupName) {
		if (!Array.isArray(uids)) {
			return [];
		}

		return await db.isSetMembers(`group:${groupName}:owners`, uids);
	};

	Groups.ownership.grant = async function (toUid, groupName) {
		await db.setAdd(`group:${groupName}:owners`, toUid);
		plugins.hooks.fire('action:group.grantOwnership', { uid: toUid, groupName: groupName });
	};

	Groups.ownership.rescind = async function (toUid, groupName) {
		// If the owners set only contains one member (and toUid is that member), error out!
		const numOwners = await db.setCount(`group:${groupName}:owners`);
		const isOwner = await db.isSortedSetMember(`group:${groupName}:owners`);
		if (numOwners <= 1 && isOwner) {
			throw new Error('[[error:group-needs-owner]]');
		}
'use strict';

const cacheCreate = require('../cacheCreate');

module.exports = function (Groups) {
	Groups.cache = cacheCreate({
		name: 'group',
		max: 40000,
		maxAge: 0,
	});

	Groups.clearCache = function (uid, groupNames) {
		if (!Array.isArray(groupNames)) {
			groupNames = [groupNames];
		}
'use strict';

const winston = require('winston');

const categories = require('../categories');
const plugins = require('../plugins');
const slugify = require('../slugify');
const db = require('../database');
const user = require('../user');
const batch = require('../batch');
const meta = require('../meta');
const cache = require('../cache');


module.exports = function (Groups) {
	Groups.update = async function (groupName, values) {
		const exists = await db.exists(`group:${groupName}`);
		if (!exists) {
			throw new Error('[[error:no-group]]');
		}

		({ values } = await plugins.hooks.fire('filter:group.update', {
			groupName: groupName,
			values: values,
		}));

		// Cast some values as bool (if not boolean already)
		// 'true' and '1' = true, everything else false
		['userTitleEnabled', 'private', 'hidden', 'disableJoinRequests', 'disableLeave'].forEach((prop) => {
			if (values.hasOwnProperty(prop) && typeof values[prop] !== 'boolean') {
				values[prop] = values[prop] === 'true' || parseInt(values[prop], 10) === 1;
			}
		});

		const payload = {
			description: values.description || '',
			icon: values.icon || '',
			labelColor: values.labelColor || '#000000',
			textColor: values.textColor || '#ffffff',
		};

		if (values.hasOwnProperty('userTitle')) {
			payload.userTitle = values.userTitle || '';
		}

		if (values.hasOwnProperty('userTitleEnabled')) {
			payload.userTitleEnabled = values.userTitleEnabled ? '1' : '0';
		}

		if (values.hasOwnProperty('hidden')) {
			payload.hidden = values.hidden ? '1' : '0';
		}

		if (values.hasOwnProperty('private')) {
			payload.private = values.private ? '1' : '0';
		}

		if (values.hasOwnProperty('disableJoinRequests')) {
			payload.disableJoinRequests = values.disableJoinRequests ? '1' : '0';
		}

		if (values.hasOwnProperty('disableLeave')) {
			payload.disableLeave = values.disableLeave ? '1' : '0';
		}

		if (values.hasOwnProperty('name')) {
			await checkNameChange(groupName, values.name);
		}

		if (values.hasOwnProperty('private')) {
			await updatePrivacy(groupName, values.private);
		}

		if (values.hasOwnProperty('hidden')) {
			await updateVisibility(groupName, values.hidden);
		}

		if (values.hasOwnProperty('memberPostCids')) {
			const validCids = await categories.getCidsByPrivilege('categories:cid', groupName, 'topics:read');
			const cidsArray = values.memberPostCids.split(',').map(cid => parseInt(cid.trim(), 10)).filter(Boolean);
			payload.memberPostCids = cidsArray.filter(cid => validCids.includes(cid)).join(',') || '';
		}

		await db.setObject(`group:${groupName}`, payload);
		await Groups.renameGroup(groupName, values.name);

		plugins.hooks.fire('action:group.update', {
			name: groupName,
			values: values,
		});
	};

	async function updateVisibility(groupName, hidden) {
		if (hidden) {
			await db.sortedSetRemoveBulk([
				['groups:visible:createtime', groupName],
				['groups:visible:memberCount', groupName],
				['groups:visible:name', `${groupName.toLowerCase()}:${groupName}`],
			]);
			return;
		}
		const groupData = await db.getObjectFields(`group:${groupName}`, ['createtime', 'memberCount']);
		await db.sortedSetAddBulk([
			['groups:visible:createtime', groupData.createtime, groupName],
			['groups:visible:memberCount', groupData.memberCount, groupName],
			['groups:visible:name', 0, `${groupName.toLowerCase()}:${groupName}`],
		]);
	}

	Groups.hide = async function (groupName) {
		await showHide(groupName, 'hidden');
	};

	Groups.show = async function (groupName) {
		await showHide(groupName, 'show');
	};

	async function showHide(groupName, hidden) {
		hidden = hidden === 'hidden';
		await Promise.all([
			db.setObjectField(`group:${groupName}`, 'hidden', hidden ? 1 : 0),
			updateVisibility(groupName, hidden),
		]);
	}

	async function updatePrivacy(groupName, isPrivate) {
		const groupData = await Groups.getGroupFields(groupName, ['private']);
		const currentlyPrivate = groupData.private === 1;
		if (!currentlyPrivate || currentlyPrivate === isPrivate) {
			return;
		}
		const pendingUids = await db.getSetMembers(`group:${groupName}:pending`);
		if (!pendingUids.length) {
			return;
		}

		winston.verbose(`[groups.update] Group is now public, automatically adding ${pendingUids.length} new members, who were pending prior.`);

		for (const uid of pendingUids) {
			/* eslint-disable no-await-in-loop */
			await Groups.join(groupName, uid);
		}
		await db.delete(`group:${groupName}:pending`);
	}

	async function checkNameChange(currentName, newName) {
		if (Groups.isPrivilegeGroup(newName)) {
			throw new Error('[[error:invalid-group-name]]');
		}
		const currentSlug = slugify(currentName);
		const newSlug = slugify(newName);
		if (currentName === newName || currentSlug === newSlug) {
			return;
		}
		Groups.validateGroupName(newName);
		const [group, exists] = await Promise.all([
			Groups.getGroupData(currentName),
			Groups.existsBySlug(newSlug),
		]);

		if (exists) {
			throw new Error('[[error:group-already-exists]]');
		}

		if (!group) {
			throw new Error('[[error:no-group]]');
		}

		if (group.system) {
			throw new Error('[[error:not-allowed-to-rename-system-group]]');
		}
	}

	Groups.renameGroup = async function (oldName, newName) {
		if (oldName === newName || !newName || String(newName).length === 0) {
			return;
		}
		const group = await db.getObject(`group:${oldName}`);
		if (!group) {
			return;
		}

		const exists = await Groups.exists(newName);
		if (exists) {
			throw new Error('[[error:group-already-exists]]');
		}

		await updateMemberGroupTitles(oldName, newName);
		await updateNavigationItems(oldName, newName);
		await updateWidgets(oldName, newName);
		await updateConfig(oldName, newName);
		await db.setObject(`group:${oldName}`, { name: newName, slug: slugify(newName) });
		await db.deleteObjectField('groupslug:groupname', group.slug);
		await db.setObjectField('groupslug:groupname', slugify(newName), newName);

		const allGroups = await db.getSortedSetRange('groups:createtime', 0, -1);
		const keys = allGroups.map(group => `group:${group}:members`);
		await renameGroupsMember(keys, oldName, newName);
		cache.del(keys);

		await db.rename(`group:${oldName}`, `group:${newName}`);
		await db.rename(`group:${oldName}:members`, `group:${newName}:members`);
		await db.rename(`group:${oldName}:owners`, `group:${newName}:owners`);
		await db.rename(`group:${oldName}:pending`, `group:${newName}:pending`);
		await db.rename(`group:${oldName}:invited`, `group:${newName}:invited`);
		await db.rename(`group:${oldName}:member:pids`, `group:${newName}:member:pids`);

		await renameGroupsMember(['groups:createtime', 'groups:visible:createtime', 'groups:visible:memberCount'], oldName, newName);
		await renameGroupsMember(['groups:visible:name'], `${oldName.toLowerCase()}:${oldName}`, `${newName.toLowerCase()}:${newName}`);

		plugins.hooks.fire('action:group.rename', {
			old: oldName,
			new: newName,
		});
		Groups.cache.reset();
	};

	async function updateMemberGroupTitles(oldName, newName) {
		await batch.processSortedSet(`group:${oldName}:members`, async (uids) => {
			let usersData = await user.getUsersData(uids);
			usersData = usersData.filter(userData => userData && userData.groupTitleArray.includes(oldName));

			usersData.forEach((userData) => {
				userData.newTitleArray = userData.groupTitleArray.map(oldTitle => (oldTitle === oldName ? newName : oldTitle));
			});

			await Promise.all(usersData.map(u => user.setUserField(u.uid, 'groupTitle', JSON.stringify(u.newTitleArray))));
		}, {});
	}

	async function renameGroupsMember(keys, oldName, newName) {
		const isMembers = await db.isMemberOfSortedSets(keys, oldName);
		keys = keys.filter((key, index) => isMembers[index]);
		if (!keys.length) {
			return;
		}
		const scores = await db.sortedSetsScore(keys, oldName);
		await db.sortedSetsRemove(keys, oldName);
		await db.sortedSetsAdd(keys, scores, newName);
	}

	async function updateNavigationItems(oldName, newName) {
		const navigation = require('../navigation/admin');
		const navItems = await navigation.get();
		navItems.forEach((navItem) => {
			if (navItem && Array.isArray(navItem.groups) && navItem.groups.includes(oldName)) {
				navItem.groups.splice(navItem.groups.indexOf(oldName), 1, newName);
			}
		});
		navigation.unescapeFields(navItems);
		await navigation.save(navItems);
	}

	async function updateWidgets(oldName, newName) {
		const admin = require('../widgets/admin');
		const widgets = require('../widgets');

		const data = await admin.get();

		data.areas.forEach((area) => {
			area.widgets = area.data;
			area.widgets.forEach((widget) => {
				if (widget && widget.data && Array.isArray(widget.data.groups) && widget.data.groups.includes(oldName)) {
					widget.data.groups.splice(widget.data.groups.indexOf(oldName), 1, newName);
				}
			});
		});
		for (const area of data.areas) {
			if (area.data.length) {
				await widgets.setArea(area);
			}
		}
	}

	async function updateConfig(oldName, newName) {
		if (meta.config.groupsExemptFromPostQueue.includes(oldName)) {
			meta.config.groupsExemptFromPostQueue.splice(meta.config.groupsExemptFromPostQueue.indexOf(oldName), 1, newName);
			await meta.configs.set('groupsExemptFromPostQueue', meta.config.groupsExemptFromPostQueue);
		}
	}
'use strict';

const path = require('path');

const db = require('../database');
const image = require('../image');
const file = require('../file');

module.exports = function (Groups) {
	const allowedTypes = ['image/png', 'image/jpeg', 'image/bmp'];
	Groups.updateCoverPosition = async function (groupName, position) {
		if (!groupName) {
			throw new Error('[[error:invalid-data]]');
		}
		await Groups.setGroupField(groupName, 'cover:position', position);
	};

	Groups.updateCover = async function (uid, data) {
		let tempPath = data.file ? data.file.path : '';
		try {
			// Position only? That's fine
			if (!data.imageData && !data.file && data.position) {
				return await Groups.updateCoverPosition(data.groupName, data.position);
			}
			const type = data.file ? data.file.type : image.mimeFromBase64(data.imageData);
			if (!type || !allowedTypes.includes(type)) {
				throw new Error('[[error:invalid-image]]');
			}

			if (!tempPath) {
				tempPath = await image.writeImageDataToTempFile(data.imageData);
			}

			const filename = `groupCover-${data.groupName}${path.extname(tempPath)}`;
			const uploadData = await image.uploadImage(filename, 'files', {
				path: tempPath,
				uid: uid,
				name: 'groupCover',
			});
			const { url } = uploadData;
			await Groups.setGroupField(data.groupName, 'cover:url', url);

			await image.resizeImage({
				path: tempPath,
				width: 358,
			});
			const thumbUploadData = await image.uploadImage(`groupCoverThumb-${data.groupName}${path.extname(tempPath)}`, 'files', {
				path: tempPath,
				uid: uid,
				name: 'groupCover',
			});
			await Groups.setGroupField(data.groupName, 'cover:thumb:url', thumbUploadData.url);

			if (data.position) {
				await Groups.updateCoverPosition(data.groupName, data.position);
			}

			return { url: url };
		} finally {
			file.delete(tempPath);
		}
	};

	Groups.removeCover = async function (data) {
		await db.deleteObjectFields(`group:${data.groupName}`, ['cover:url', 'cover:thumb:url', 'cover:position']);
'use strict';

const async = require('async');
const winston = require('winston');

const db = require('../database');
const user = require('../user');
const plugins = require('../plugins');
const cache = require('../cache');

module.exports = function (Groups) {
	Groups.join = async function (groupNames, uid) {
		if (!groupNames) {
			throw new Error('[[error:invalid-data]]');
		}
		if (Array.isArray(groupNames) && !groupNames.length) {
			return;
		}
		if (!Array.isArray(groupNames)) {
			groupNames = [groupNames];
		}

		if (!uid) {
			throw new Error('[[error:invalid-uid]]');
		}

		const [isMembers, exists, isAdmin] = await Promise.all([
			Groups.isMemberOfGroups(uid, groupNames),
			Groups.exists(groupNames),
			user.isAdministrator(uid),
		]);

		const groupsToCreate = groupNames.filter((groupName, index) => groupName && !exists[index]);
		const groupsToJoin = groupNames.filter((groupName, index) => !isMembers[index]);

		if (!groupsToJoin.length) {
			return;
		}
		await createNonExistingGroups(groupsToCreate);

		const promises = [
			db.sortedSetsAdd(groupsToJoin.map(groupName => `group:${groupName}:members`), Date.now(), uid),
			db.incrObjectField(groupsToJoin.map(groupName => `group:${groupName}`), 'memberCount'),
		];
		if (isAdmin) {
			promises.push(db.setsAdd(groupsToJoin.map(groupName => `group:${groupName}:owners`), uid));
		}

		await Promise.all(promises);

		Groups.clearCache(uid, groupsToJoin);
		cache.del(groupsToJoin.map(name => `group:${name}:members`));

		const groupData = await Groups.getGroupsFields(groupsToJoin, ['name', 'hidden', 'memberCount']);
		const visibleGroups = groupData.filter(groupData => groupData && !groupData.hidden);

		if (visibleGroups.length) {
			await db.sortedSetAdd(
				'groups:visible:memberCount',
				visibleGroups.map(groupData => groupData.memberCount),
				visibleGroups.map(groupData => groupData.name)
			);
		}

		await setGroupTitleIfNotSet(groupsToJoin, uid);

		plugins.hooks.fire('action:group.join', {
			groupNames: groupsToJoin,
			uid: uid,
		});
	};

	async function createNonExistingGroups(groupsToCreate) {
		if (!groupsToCreate.length) {
			return;
		}

		await async.eachSeries(groupsToCreate, async (groupName) => {
			try {
				await Groups.create({
					name: groupName,
					hidden: 1,
				});
			} catch (err) {
				if (err && err.message !== '[[error:group-already-exists]]') {
					winston.error(`[groups.join] Could not create new hidden group (${groupName})\n${err.stack}`);
					throw err;
				}
			}
		});
	}

	async function setGroupTitleIfNotSet(groupNames, uid) {
		const ignore = ['registered-users', 'verified-users', 'unverified-users', Groups.BANNED_USERS];
		groupNames = groupNames.filter(
			groupName => !ignore.includes(groupName) && !Groups.isPrivilegeGroup(groupName)
		);
		if (!groupNames.length) {
			return;
		}

		const currentTitle = await db.getObjectField(`user:${uid}`, 'groupTitle');
		if (currentTitle || currentTitle === '') {
			return;
		}
'use strict';

const db = require('../database');
const groups = require('.');
const privileges = require('../privileges');
const posts = require('../posts');

module.exports = function (Groups) {
	Groups.onNewPostMade = async function (postData) {
		if (!parseInt(postData.uid, 10)) {
			return;
		}

		let groupNames = await Groups.getUserGroupMembership('groups:visible:createtime', [postData.uid]);
		groupNames = groupNames[0];

		// Only process those groups that have the cid in its memberPostCids setting (or no setting at all)
		const groupData = await groups.getGroupsFields(groupNames, ['memberPostCids']);
		groupNames = groupNames.filter((groupName, idx) => (
			!groupData[idx].memberPostCidsArray.length ||
			groupData[idx].memberPostCidsArray.includes(postData.cid)
		));

		const keys = groupNames.map(groupName => `group:${groupName}:member:pids`);
		await db.sortedSetsAdd(keys, postData.timestamp, postData.pid);
		await Promise.all(groupNames.map(name => truncateMemberPosts(name)));
	};

	async function truncateMemberPosts(groupName) {
		let lastPid = await db.getSortedSetRevRange(`group:${groupName}:member:pids`, 10, 10);
		lastPid = lastPid[0];
		if (!parseInt(lastPid, 10)) {
			return;
		}
		const score = await db.sortedSetScore(`group:${groupName}:member:pids`, lastPid);
		await db.sortedSetsRemoveRangeByScore([`group:${groupName}:member:pids`], '-inf', score);
	}

	Groups.getLatestMemberPosts = async function (groupName, max, uid) {
		let pids = await db.getSortedSetRevRange(`group:${groupName}:member:pids`, 0, max - 1);
'use strict';

const db = require('../database');
const plugins = require('../plugins');

module.exports = function (Posts) {
	Posts.bookmark = async function (pid, uid) {
		return await toggleBookmark('bookmark', pid, uid);
	};

	Posts.unbookmark = async function (pid, uid) {
		return await toggleBookmark('unbookmark', pid, uid);
	};

	async function toggleBookmark(type, pid, uid) {
		if (parseInt(uid, 10) <= 0) {
			throw new Error('[[error:not-logged-in]]');
		}

		const isBookmarking = type === 'bookmark';

		const [postData, hasBookmarked] = await Promise.all([
			Posts.getPostFields(pid, ['pid', 'uid']),
			Posts.hasBookmarked(pid, uid),
		]);

		if (isBookmarking && hasBookmarked) {
			throw new Error('[[error:already-bookmarked]]');
		}

		if (!isBookmarking && !hasBookmarked) {
			throw new Error('[[error:already-unbookmarked]]');
		}

		if (isBookmarking) {
			await db.sortedSetAdd(`uid:${uid}:bookmarks`, Date.now(), pid);
		} else {
			await db.sortedSetRemove(`uid:${uid}:bookmarks`, pid);
		}
		await db[isBookmarking ? 'setAdd' : 'setRemove'](`pid:${pid}:users_bookmarked`, uid);
		postData.bookmarks = await db.setCount(`pid:${pid}:users_bookmarked`);
		await Posts.setPostField(pid, 'bookmarks', postData.bookmarks);

		plugins.hooks.fire(`action:post.${type}`, {
			pid: pid,
			uid: uid,
			owner: postData.uid,
			current: hasBookmarked ? 'bookmarked' : 'unbookmarked',
		});

		return {
			post: postData,
			isBookmarked: isBookmarking,
		};
	}

	Posts.hasBookmarked = async function (pid, uid) {
		if (parseInt(uid, 10) <= 0) {
			return Array.isArray(pid) ? pid.map(() => false) : false;
		}

		if (Array.isArray(pid)) {
			const sets = pid.map(pid => `pid:${pid}:users_bookmarked`);
			return await db.isMemberOfSets(sets, uid);
		}
'use strict';

const _ = require('lodash');

const meta = require('../meta');
const db = require('../database');
const plugins = require('../plugins');
const user = require('../user');
const topics = require('../topics');
const categories = require('../categories');
const groups = require('../groups');
const utils = require('../utils');

module.exports = function (Posts) {
	Posts.create = async function (data) {
		// This is an internal method, consider using Topics.reply instead
		const { uid } = data;
		const { tid } = data;
		const content = data.content.toString();
		const timestamp = data.timestamp || Date.now();
		const isMain = data.isMain || false;

		if (!uid && parseInt(uid, 10) !== 0) {
			throw new Error('[[error:invalid-uid]]');
		}

		if (data.toPid && !utils.isNumber(data.toPid)) {
			throw new Error('[[error:invalid-pid]]');
		}

		const pid = await db.incrObjectField('global', 'nextPid');
		let postData = {
			pid: pid,
			uid: uid,
			tid: tid,
			content: content,
			timestamp: timestamp,
		};

		if (data.toPid) {
			postData.toPid = data.toPid;
		}
		if (data.ip && meta.config.trackIpPerPost) {
			postData.ip = data.ip;
		}
		if (data.handle && !parseInt(uid, 10)) {
			postData.handle = data.handle;
		}

		let result = await plugins.hooks.fire('filter:post.create', { post: postData, data: data });
		postData = result.post;
		await db.setObject(`post:${postData.pid}`, postData);

		const topicData = await topics.getTopicFields(tid, ['cid', 'pinned']);
		postData.cid = topicData.cid;

		await Promise.all([
			db.sortedSetAdd('posts:pid', timestamp, postData.pid),
			db.incrObjectField('global', 'postCount'),
			user.onNewPostMade(postData),
			topics.onNewPostMade(postData),
			categories.onNewPostMade(topicData.cid, topicData.pinned, postData),
			groups.onNewPostMade(postData),
			addReplyTo(postData, timestamp),
			Posts.uploads.sync(postData.pid),
		]);

		result = await plugins.hooks.fire('filter:post.get', { post: postData, uid: data.uid });
		result.post.isMain = isMain;
		plugins.hooks.fire('action:post.save', { post: _.clone(result.post) });
		return result.post;
	};

	async function addReplyTo(postData, timestamp) {
		if (!postData.toPid) {
			return;
		}
		await Promise.all([
			db.sortedSetAdd(`pid:${postData.toPid}:replies`, timestamp, postData.pid),
			db.incrObjectField(`post:${postData.toPid}`, 'replies'),
'use strict';

const _ = require('lodash');
const validator = require('validator');
const nconf = require('nconf');

const db = require('../database');
const user = require('../user');
const meta = require('../meta');
const groups = require('../groups');
const topics = require('../topics');
const categories = require('../categories');
const notifications = require('../notifications');
const privileges = require('../privileges');
const plugins = require('../plugins');
const utils = require('../utils');
const cache = require('../cache');
const socketHelpers = require('../socket.io/helpers');

module.exports = function (Posts) {
	Posts.getQueuedPosts = async (filter = {}, options = {}) => {
		options = { metadata: true, ...options };	// defaults
		let postData;
		if (cache.has('post-queue')) {
			postData = cache.get('post-queue');
		} else {
			const ids = await db.getSortedSetRange('post:queue', 0, -1);
			const keys = ids.map(id => `post:queue:${id}`);
			postData = await db.getObjects(keys);
			postData.forEach((data) => {
				if (data) {
					data.data = JSON.parse(data.data);
					data.data.timestampISO = utils.toISOString(data.data.timestamp);
				}
			});
			const uids = postData.map(data => data && data.uid);
			const userData = await user.getUsersFields(uids, ['username', 'userslug', 'picture']);
			postData.forEach((postData, index) => {
				if (postData) {
					postData.user = userData[index];
					postData.data.rawContent = validator.escape(String(postData.data.content));
					postData.data.title = validator.escape(String(postData.data.title || ''));
				}
			});
			cache.set('post-queue', postData);
		}

		if (options.metadata) {
			await Promise.all(postData.map(p => addMetaData(p)));
		}

		// Filter by tid if present
		if (isFinite(filter.tid)) {
			const tid = parseInt(filter.tid, 10);
			postData = postData.filter(item => item.data.tid && parseInt(item.data.tid, 10) === tid);
		}

		return postData;
	};

	async function addMetaData(postData) {
		if (!postData) {
			return;
		}
		postData.topic = { cid: 0 };
		if (postData.data.cid) {
			postData.topic = { cid: parseInt(postData.data.cid, 10) };
		} else if (postData.data.tid) {
			postData.topic = await topics.getTopicFields(postData.data.tid, ['title', 'cid']);
		}
		postData.category = await categories.getCategoryData(postData.topic.cid);
		const result = await plugins.hooks.fire('filter:parse.post', { postData: postData.data });
		postData.data.content = result.postData.content;
	}

	Posts.shouldQueue = async function (uid, data) {
		const [userData, isMemberOfExempt, categoryQueueEnabled] = await Promise.all([
			user.getUserFields(uid, ['uid', 'reputation', 'postcount']),
			groups.isMemberOfAny(uid, meta.config.groupsExemptFromPostQueue),
			isCategoryQueueEnabled(data),
		]);

		const shouldQueue = meta.config.postQueue && categoryQueueEnabled &&
			!isMemberOfExempt &&
			(!userData.uid || userData.reputation < meta.config.postQueueReputationThreshold || userData.postcount <= 0);
		const result = await plugins.hooks.fire('filter:post.shouldQueue', {
			shouldQueue: !!shouldQueue,
			uid: uid,
			data: data,
		});
		return result.shouldQueue;
	};

	async function isCategoryQueueEnabled(data) {
		const type = getType(data);
		const cid = await getCid(type, data);
		if (!cid) {
			throw new Error('[[error:invalid-cid]]');
		}
		return await categories.getCategoryField(cid, 'postQueue');
	}

	function getType(data) {
		if (data.hasOwnProperty('tid')) {
			return 'reply';
		} else if (data.hasOwnProperty('cid')) {
			return 'topic';
		}
		throw new Error('[[error:invalid-type]]');
	}

	async function removeQueueNotification(id) {
		await notifications.rescind(`post-queue-${id}`);
		const data = await getParsedObject(id);
		if (!data) {
			return;
		}
		const cid = await getCid(data.type, data);
		const uids = await getNotificationUids(cid);
		uids.forEach(uid => user.notifications.pushCount(uid));
	}

	async function getNotificationUids(cid) {
		const results = await Promise.all([
			groups.getMembersOfGroups(['administrators', 'Global Moderators']),
			categories.getModeratorUids([cid]),
		]);
		return _.uniq(_.flattenDeep(results));
	}

	Posts.addToQueue = async function (data) {
		const type = getType(data);
		const now = Date.now();
		const id = `${type}-${now}`;
		await canPost(type, data);

		let payload = {
			id: id,
			uid: data.uid,
			type: type,
			data: data,
		};
		payload = await plugins.hooks.fire('filter:post-queue.save', payload);
		payload.data = JSON.stringify(data);

		await db.sortedSetAdd('post:queue', now, id);
		await db.setObject(`post:queue:${id}`, payload);
		await user.setUserField(data.uid, 'lastqueuetime', now);
		cache.del('post-queue');

		const cid = await getCid(type, data);
		const uids = await getNotificationUids(cid);
		const bodyLong = await parseBodyLong(cid, type, data);

		const notifObj = await notifications.create({
			type: 'post-queue',
			nid: `post-queue-${id}`,
			mergeId: 'post-queue',
			bodyShort: '[[notifications:post_awaiting_review]]',
			bodyLong: bodyLong,
			path: '/post-queue',
		});
		await notifications.push(notifObj, uids);
		return {
			id: id,
			type: type,
			queued: true,
			message: '[[success:post-queued]]',
		};
	};

	async function parseBodyLong(cid, type, data) {
		const url = nconf.get('url');
		const [content, category, userData] = await Promise.all([
			plugins.hooks.fire('filter:parse.raw', data.content),
			categories.getCategoryFields(cid, ['name', 'slug']),
			user.getUserFields(data.uid, ['uid', 'username']),
		]);

		category.url = `${url}/category/${category.slug}`;
		if (userData.uid > 0) {
			userData.url = `${url}/uid/${userData.uid}`;
		}

		const topic = { cid: cid, title: data.title, tid: data.tid };
		if (type === 'reply') {
			topic.title = await topics.getTopicField(data.tid, 'title');
			topic.url = `${url}/topic/${data.tid}`;
		}
		const { app } = require('../webserver');
		return await app.renderAsync('emails/partials/post-queue-body', {
			content: content,
			category: category,
			user: userData,
			topic: topic,
		});
	}

	async function getCid(type, data) {
		if (type === 'topic') {
			return data.cid;
		} else if (type === 'reply') {
			return await topics.getTopicField(data.tid, 'cid');
		}
		return null;
	}

	async function canPost(type, data) {
		const cid = await getCid(type, data);
		const typeToPrivilege = {
			topic: 'topics:create',
			reply: 'topics:reply',
		};

		topics.checkContent(data.content);
		if (type === 'topic') {
			topics.checkTitle(data.title);
			if (data.tags) {
				await topics.validateTags(data.tags, cid, data.uid);
			}
		}

		const [canPost] = await Promise.all([
			privileges.categories.can(typeToPrivilege[type], cid, data.uid),
			user.isReadyToQueue(data.uid, cid),
		]);
		if (!canPost) {
			throw new Error('[[error:no-privileges]]');
		}
	}

	Posts.removeFromQueue = async function (id) {
		await removeQueueNotification(id);
		await db.sortedSetRemove('post:queue', id);
		await db.delete(`post:queue:${id}`);
		cache.del('post-queue');
	};

	Posts.submitFromQueue = async function (id) {
		const data = await getParsedObject(id);
		if (!data) {
			return;
		}
		if (data.type === 'topic') {
			await createTopic(data.data);
		} else if (data.type === 'reply') {
			await createReply(data.data);
		}
		await Posts.removeFromQueue(id);
	};

	async function getParsedObject(id) {
		const data = await db.getObject(`post:queue:${id}`);
		if (!data) {
			return null;
		}
		data.data = JSON.parse(data.data);
		data.data.fromQueue = true;
		return data;
	}

	async function createTopic(data) {
		const result = await topics.post(data);
		socketHelpers.notifyNew(data.uid, 'newTopic', { posts: [result.postData], topic: result.topicData });
	}

	async function createReply(data) {
		const postData = await topics.reply(data);
		const result = {
			posts: [postData],
			'reputation:disabled': !!meta.config['reputation:disabled'],
			'downvote:disabled': !!meta.config['downvote:disabled'],
		};
		socketHelpers.notifyNew(data.uid, 'newPost', result);
	}

	Posts.editQueuedContent = async function (uid, editData) {
		const canEditQueue = await Posts.canEditQueue(uid, editData);
		if (!canEditQueue) {
			throw new Error('[[error:no-privileges]]');
		}
		const data = await getParsedObject(editData.id);
		if (!data) {
			return;
		}
		if (editData.content !== undefined) {
			data.data.content = editData.content;
		}
		if (editData.title !== undefined) {
			data.data.title = editData.title;
		}
		if (editData.cid !== undefined) {
			data.data.cid = editData.cid;
		}
		await db.setObjectField(`post:queue:${editData.id}`, 'data', JSON.stringify(data.data));
		cache.del('post-queue');
	};

	Posts.canEditQueue = async function (uid, editData) {
		const [isAdminOrGlobalMod, data] = await Promise.all([
			user.isAdminOrGlobalMod(uid),
			getParsedObject(editData.id),
		]);
		if (!data) {
			return false;
		}

		if (isAdminOrGlobalMod) {
			return true;
		}

		let cid;
		if (data.type === 'topic') {
			cid = data.data.cid;
		} else if (data.type === 'reply') {
			cid = await topics.getTopicField(data.data.tid, 'cid');
		}
		const isModerator = await user.isModerator(uid, cid);
		let isModeratorOfTargetCid = true;
		if (editData.cid) {
'use strict';

const db = require('../database');
const plugins = require('../plugins');
const utils = require('../utils');

const intFields = [
	'uid', 'pid', 'tid', 'deleted', 'timestamp',
	'upvotes', 'downvotes', 'deleterUid', 'edited',
	'replies', 'bookmarks',
];

module.exports = function (Posts) {
	Posts.getPostsFields = async function (pids, fields) {
		if (!Array.isArray(pids) || !pids.length) {
			return [];
		}
		const keys = pids.map(pid => `post:${pid}`);
		const postData = await (fields.length ? db.getObjectsFields(keys, fields) : db.getObjects(keys));
		const result = await plugins.hooks.fire('filter:post.getFields', {
			pids: pids,
			posts: postData,
			fields: fields,
		});
		result.posts.forEach(post => modifyPost(post, fields));
		return Array.isArray(result.posts) ? result.posts : null;
	};

	Posts.getPostData = async function (pid) {
		const posts = await Posts.getPostsFields([pid], []);
		return posts && posts.length ? posts[0] : null;
	};

	Posts.getPostsData = async function (pids) {
		return await Posts.getPostsFields(pids, []);
	};

	Posts.getPostField = async function (pid, field) {
		const post = await Posts.getPostFields(pid, [field]);
		return post ? post[field] : null;
	};

	Posts.getPostFields = async function (pid, fields) {
		const posts = await Posts.getPostsFields([pid], fields);
		return posts ? posts[0] : null;
	};

	Posts.setPostField = async function (pid, field, value) {
		await Posts.setPostFields(pid, { [field]: value });
	};

	Posts.setPostFields = async function (pid, data) {
		await db.setObject(`post:${pid}`, data);
		plugins.hooks.fire('action:post.setFields', { data: { ...data, pid } });
	};
};

function modifyPost(post, fields) {
	if (post) {
		db.parseIntFields(post, intFields, fields);
		if (post.hasOwnProperty('upvotes') && post.hasOwnProperty('downvotes')) {
			post.votes = post.upvotes - post.downvotes;
		}
		if (post.hasOwnProperty('timestamp')) {
			post.timestampISO = utils.toISOString(post.timestamp);
		}
		if (post.hasOwnProperty('edited')) {
			post.editedISO = post.edited !== 0 ? utils.toISOString(post.edited) : '';
		}
	}
'use strict';

const _ = require('lodash');

const db = require('../database');
const topics = require('../topics');
const categories = require('../categories');
const user = require('../user');
const groups = require('../groups');
const notifications = require('../notifications');
const plugins = require('../plugins');
const flags = require('../flags');

module.exports = function (Posts) {
	Posts.delete = async function (pid, uid) {
		return await deleteOrRestore('delete', pid, uid);
	};

	Posts.restore = async function (pid, uid) {
		return await deleteOrRestore('restore', pid, uid);
	};

	async function deleteOrRestore(type, pid, uid) {
		const isDeleting = type === 'delete';
		await plugins.hooks.fire(`filter:post.${type}`, { pid: pid, uid: uid });
		await Posts.setPostFields(pid, {
			deleted: isDeleting ? 1 : 0,
			deleterUid: isDeleting ? uid : 0,
		});
		const postData = await Posts.getPostFields(pid, ['pid', 'tid', 'uid', 'content', 'timestamp']);
		const topicData = await topics.getTopicFields(postData.tid, ['tid', 'cid', 'pinned']);
		postData.cid = topicData.cid;
		await Promise.all([
			topics.updateLastPostTimeFromLastPid(postData.tid),
			topics.updateTeaser(postData.tid),
			isDeleting ?
				db.sortedSetRemove(`cid:${topicData.cid}:pids`, pid) :
				db.sortedSetAdd(`cid:${topicData.cid}:pids`, postData.timestamp, pid),
		]);
		await categories.updateRecentTidForCid(postData.cid);
		plugins.hooks.fire(`action:post.${type}`, { post: _.clone(postData), uid: uid });
		if (type === 'delete') {
			await flags.resolveFlag('post', pid, uid);
		}
		return postData;
	}

	Posts.purge = async function (pid, uid) {
		const postData = await Posts.getPostData(pid);
		if (!postData) {
			return;
		}
		const topicData = await topics.getTopicFields(postData.tid, ['tid', 'cid', 'pinned']);
		postData.cid = topicData.cid;
		await plugins.hooks.fire('filter:post.purge', { post: postData, pid: pid, uid: uid });
		await Promise.all([
			deletePostFromTopicUserNotification(postData, topicData),
			deletePostFromCategoryRecentPosts(postData),
			deletePostFromUsersBookmarks(pid),
			deletePostFromUsersVotes(pid),
			deletePostFromReplies(postData),
			deletePostFromGroups(postData),
			db.sortedSetsRemove(['posts:pid', 'posts:votes', 'posts:flagged'], pid),
			Posts.uploads.dissociateAll(pid),
		]);
		await flags.resolveFlag('post', pid, uid);
		plugins.hooks.fire('action:post.purge', { post: postData, uid: uid });
		await db.delete(`post:${pid}`);
	};

	async function deletePostFromTopicUserNotification(postData, topicData) {
		await db.sortedSetsRemove([
			`tid:${postData.tid}:posts`,
			`tid:${postData.tid}:posts:votes`,
			`uid:${postData.uid}:posts`,
		], postData.pid);

		const tasks = [
			db.decrObjectField('global', 'postCount'),
			db.decrObjectField(`category:${topicData.cid}`, 'post_count'),
			db.sortedSetRemove(`cid:${topicData.cid}:uid:${postData.uid}:pids`, postData.pid),
			db.sortedSetRemove(`cid:${topicData.cid}:uid:${postData.uid}:pids:votes`, postData.pid),
			topics.decreasePostCount(postData.tid),
			topics.updateTeaser(postData.tid),
			topics.updateLastPostTimeFromLastPid(postData.tid),
			db.sortedSetIncrBy(`tid:${postData.tid}:posters`, -1, postData.uid),
			user.incrementUserPostCountBy(postData.uid, -1),
			notifications.rescind(`new_post:tid:${postData.tid}:pid:${postData.pid}:uid:${postData.uid}`),
		];

		if (!topicData.pinned) {
			tasks.push(db.sortedSetIncrBy(`cid:${topicData.cid}:tids:posts`, -1, postData.tid));
		}
		await Promise.all(tasks);
	}

	async function deletePostFromCategoryRecentPosts(postData) {
		const cids = await categories.getAllCidsFromSet('categories:cid');
		const sets = cids.map(cid => `cid:${cid}:pids`);
		await db.sortedSetsRemove(sets, postData.pid);
		await categories.updateRecentTidForCid(postData.cid);
	}

	async function deletePostFromUsersBookmarks(pid) {
		const uids = await db.getSetMembers(`pid:${pid}:users_bookmarked`);
		const sets = uids.map(uid => `uid:${uid}:bookmarks`);
		await db.sortedSetsRemove(sets, pid);
		await db.delete(`pid:${pid}:users_bookmarked`);
	}

	async function deletePostFromUsersVotes(pid) {
		const [upvoters, downvoters] = await Promise.all([
			db.getSetMembers(`pid:${pid}:upvote`),
			db.getSetMembers(`pid:${pid}:downvote`),
		]);
		const upvoterSets = upvoters.map(uid => `uid:${uid}:upvote`);
		const downvoterSets = downvoters.map(uid => `uid:${uid}:downvote`);
		await Promise.all([
			db.sortedSetsRemove(upvoterSets.concat(downvoterSets), pid),
			db.deleteAll([`pid:${pid}:upvote`, `pid:${pid}:downvote`]),
		]);
	}

	async function deletePostFromReplies(postData) {
		const replyPids = await db.getSortedSetMembers(`pid:${postData.pid}:replies`);
		const promises = [
			db.deleteObjectFields(
				replyPids.map(pid => `post:${pid}`), ['toPid']
			),
			db.delete(`pid:${postData.pid}:replies`),
		];
		if (parseInt(postData.toPid, 10)) {
			promises.push(db.sortedSetRemove(`pid:${postData.toPid}:replies`, postData.pid));
			promises.push(db.decrObjectField(`post:${postData.toPid}`, 'replies'));
		}
		await Promise.all(promises);
	}

	async function deletePostFromGroups(postData) {
		if (!parseInt(postData.uid, 10)) {
			return;
		}
		const groupNames = await groups.getUserGroupMembership('groups:visible:createtime', [postData.uid]);
		const keys = groupNames[0].map(groupName => `group:${groupName}:member:pids`);
		await db.sortedSetsRemove(keys, postData.pid);

'use strict';


const _ = require('lodash');

const db = require('../database');
const topics = require('../topics');

module.exports = function (Posts) {
	Posts.getCidByPid = async function (pid) {
		const tid = await Posts.getPostField(pid, 'tid');
		return await topics.getTopicField(tid, 'cid');
	};

	Posts.getCidsByPids = async function (pids) {
		const postData = await Posts.getPostsFields(pids, ['tid']);
		const tids = _.uniq(postData.map(post => post && post.tid).filter(Boolean));
		const topicData = await topics.getTopicsFields(tids, ['cid']);
		const tidToTopic = _.zipObject(tids, topicData);
		const cids = postData.map(post => tidToTopic[post.tid] && tidToTopic[post.tid].cid);
		return cids;
	};

	Posts.filterPidsByCid = async function (pids, cid) {
		if (!cid) {
			return pids;
		}

		if (!Array.isArray(cid) || cid.length === 1) {
			return await filterPidsBySingleCid(pids, cid);
		}
		const pidsArr = await Promise.all(cid.map(c => Posts.filterPidsByCid(pids, c)));
		return _.union(...pidsArr);
	};

	async function filterPidsBySingleCid(pids, cid) {
		const isMembers = await db.isSortedSetMembers(`cid:${parseInt(cid, 10)}:pids`, pids);
		return pids.filter((pid, index) => pid && isMembers[index]);
	}
'use strict';

const _ = require('lodash');

const db = require('../database');
const privileges = require('../privileges');


module.exports = function (Posts) {
	const terms = {
		day: 86400000,
		week: 604800000,
		month: 2592000000,
	};

	Posts.getRecentPosts = async function (uid, start, stop, term) {
		let min = 0;
		if (terms[term]) {
			min = Date.now() - terms[term];
		}

		const count = parseInt(stop, 10) === -1 ? stop : stop - start + 1;
		let pids = await db.getSortedSetRevRangeByScore('posts:pid', start, count, '+inf', min);
		pids = await privileges.posts.filter('topics:read', pids, uid);
		return await Posts.getPostSummaryByPids(pids, uid, { stripTags: true });
	};

	Posts.getRecentPosterUids = async function (start, stop) {
		const pids = await db.getSortedSetRevRange('posts:pid', start, stop);
		const postData = await Posts.getPostsFields(pids, ['uid']);

'use strict';

const topics = require('../topics');
const utils = require('../utils');

module.exports = function (Posts) {
	Posts.getPostsFromSet = async function (set, start, stop, uid, reverse) {
		const pids = await Posts.getPidsFromSet(set, start, stop, reverse);
		return await Posts.getPostsByPids(pids, uid);
	};

	Posts.isMain = async function (pids) {
		const isArray = Array.isArray(pids);
		pids = isArray ? pids : [pids];
		const postData = await Posts.getPostsFields(pids, ['tid']);
		const topicData = await topics.getTopicsFields(postData.map(t => t.tid), ['mainPid']);
		const result = pids.map((pid, i) => parseInt(pid, 10) === parseInt(topicData[i].mainPid, 10));
		return isArray ? result : result[0];
	};

	Posts.getTopicFields = async function (pid, fields) {
		const tid = await Posts.getPostField(pid, 'tid');
		return await topics.getTopicFields(tid, fields);
	};

	Posts.generatePostPath = async function (pid, uid) {
		const paths = await Posts.generatePostPaths([pid], uid);
		return Array.isArray(paths) && paths.length ? paths[0] : null;
	};

	Posts.generatePostPaths = async function (pids, uid) {
		const postData = await Posts.getPostsFields(pids, ['pid', 'tid']);
		const tids = postData.map(post => post && post.tid);
		const [indices, topicData] = await Promise.all([
			Posts.getPostIndices(postData, uid),
			topics.getTopicsFields(tids, ['slug']),
		]);

		const paths = pids.map((pid, index) => {
			const slug = topicData[index] ? topicData[index].slug : null;
			const postIndex = utils.isNumber(indices[index]) ? parseInt(indices[index], 10) + 1 : null;

			if (slug && postIndex) {
				return `/topic/${slug}/${postIndex}`;
			}
			return null;
		});

		return paths;
'use strict';

const nconf = require('nconf');
const url = require('url');
const winston = require('winston');
const sanitize = require('sanitize-html');
const _ = require('lodash');

const meta = require('../meta');
const plugins = require('../plugins');
const translator = require('../translator');
const utils = require('../utils');

let sanitizeConfig = {
	allowedTags: sanitize.defaults.allowedTags.concat([
		// Some safe-to-use tags to add
		'sup', 'ins', 'del', 'img', 'button',
		'video', 'audio', 'iframe', 'embed',
		// 'sup' still necessary until https://github.com/apostrophecms/sanitize-html/pull/422 merged
	]),
	allowedAttributes: {
		...sanitize.defaults.allowedAttributes,
		a: ['href', 'name', 'hreflang', 'media', 'rel', 'target', 'type'],
		img: ['alt', 'height', 'ismap', 'src', 'usemap', 'width', 'srcset'],
		iframe: ['height', 'name', 'src', 'width'],
		video: ['autoplay', 'controls', 'height', 'loop', 'muted', 'poster', 'preload', 'src', 'width'],
		audio: ['autoplay', 'controls', 'loop', 'muted', 'preload', 'src'],
		embed: ['height', 'src', 'type', 'width'],
	},
	globalAttributes: ['accesskey', 'class', 'contenteditable', 'dir',
		'draggable', 'dropzone', 'hidden', 'id', 'lang', 'spellcheck', 'style',
		'tabindex', 'title', 'translate', 'aria-expanded', 'data-*',
	],
	allowedClasses: {
		...sanitize.defaults.allowedClasses,
	},
};

module.exports = function (Posts) {
	Posts.urlRegex = {
		regex: /href="([^"]+)"/g,
		length: 6,
	};

	Posts.imgRegex = {
		regex: /src="([^"]+)"/g,
		length: 5,
	};

	Posts.parsePost = async function (postData) {
		if (!postData) {
			return postData;
		}
		postData.content = String(postData.content || '');
		const cache = require('./cache');
		const pid = String(postData.pid);
		const cachedContent = cache.get(pid);
		if (postData.pid && cachedContent !== undefined) {
			postData.content = cachedContent;
			return postData;
		}

		const data = await plugins.hooks.fire('filter:parse.post', { postData: postData });
		data.postData.content = translator.escape(data.postData.content);
		if (data.postData.pid) {
			cache.set(pid, data.postData.content);
		}
		return data.postData;
	};

	Posts.parseSignature = async function (userData, uid) {
		userData.signature = sanitizeSignature(userData.signature || '');
		return await plugins.hooks.fire('filter:parse.signature', { userData: userData, uid: uid });
	};

	Posts.relativeToAbsolute = function (content, regex) {
		// Turns relative links in content to absolute urls
		if (!content) {
			return content;
		}
		let parsed;
		let current = regex.regex.exec(content);
		let absolute;
		while (current !== null) {
			if (current[1]) {
				try {
					parsed = url.parse(current[1]);
					if (!parsed.protocol) {
						if (current[1].startsWith('/')) {
							// Internal link
							absolute = nconf.get('base_url') + current[1];
						} else {
							// External link
							absolute = `//${current[1]}`;
						}

						content = content.slice(0, current.index + regex.length) +
						absolute +
						content.slice(current.index + regex.length + current[1].length);
					}
				} catch (err) {
					winston.verbose(err.messsage);
				}
			}
			current = regex.regex.exec(content);
		}

		return content;
	};

	Posts.sanitize = function (content) {
		return sanitize(content, {
			allowedTags: sanitizeConfig.allowedTags,
			allowedAttributes: sanitizeConfig.allowedAttributes,
			allowedClasses: sanitizeConfig.allowedClasses,
		});
	};

	Posts.configureSanitize = async () => {
		// Each allowed tags should have some common global attributes...
		sanitizeConfig.allowedTags.forEach((tag) => {
			sanitizeConfig.allowedAttributes[tag] = _.union(
				sanitizeConfig.allowedAttributes[tag],
				sanitizeConfig.globalAttributes
			);
		});

		// Some plugins might need to adjust or whitelist their own tags...
		sanitizeConfig = await plugins.hooks.fire('filter:sanitize.config', sanitizeConfig);
	};

	Posts.registerHooks = () => {
		plugins.hooks.register('core', {
			hook: 'filter:parse.post',
			method: async (data) => {
				data.postData.content = Posts.sanitize(data.postData.content);
				return data;
			},
		});

		plugins.hooks.register('core', {
			hook: 'filter:parse.raw',
			method: async content => Posts.sanitize(content),
		});

		plugins.hooks.register('core', {
			hook: 'filter:parse.aboutme',
			method: async content => Posts.sanitize(content),
		});

		plugins.hooks.register('core', {
			hook: 'filter:parse.signature',
			method: async (data) => {
				data.userData.signature = Posts.sanitize(data.userData.signature);
				return data;
			},
		});
	};

	function sanitizeSignature(signature) {
		signature = translator.escape(signature);
		const tagsToStrip = [];

		if (meta.config['signatures:disableLinks']) {
			tagsToStrip.push('a');
		}

		if (meta.config['signatures:disableImages']) {
			tagsToStrip.push('img');
		}
'use strict';

const meta = require('../meta');
const db = require('../database');
const user = require('../user');
const topics = require('../topics');
const plugins = require('../plugins');
const privileges = require('../privileges');

module.exports = function (Posts) {
	const votesInProgress = {};

	Posts.upvote = async function (pid, uid) {
		if (meta.config['reputation:disabled']) {
			throw new Error('[[error:reputation-system-disabled]]');
		}
		const canUpvote = await privileges.posts.can('posts:upvote', pid, uid);
		if (!canUpvote) {
			throw new Error('[[error:no-privileges]]');
		}

		if (voteInProgress(pid, uid)) {
			throw new Error('[[error:already-voting-for-this-post]]');
		}
		putVoteInProgress(pid, uid);

		try {
			return await toggleVote('upvote', pid, uid);
		} finally {
			clearVoteProgress(pid, uid);
		}
	};

	Posts.downvote = async function (pid, uid) {
		if (meta.config['reputation:disabled']) {
			throw new Error('[[error:reputation-system-disabled]]');
		}

		if (meta.config['downvote:disabled']) {
			throw new Error('[[error:downvoting-disabled]]');
		}
		const canDownvote = await privileges.posts.can('posts:downvote', pid, uid);
		if (!canDownvote) {
			throw new Error('[[error:no-privileges]]');
		}

		if (voteInProgress(pid, uid)) {
			throw new Error('[[error:already-voting-for-this-post]]');
		}

		putVoteInProgress(pid, uid);
		try {
			return await toggleVote('downvote', pid, uid);
		} finally {
			clearVoteProgress(pid, uid);
		}
	};

	Posts.unvote = async function (pid, uid) {
		if (voteInProgress(pid, uid)) {
			throw new Error('[[error:already-voting-for-this-post]]');
		}

		putVoteInProgress(pid, uid);
		try {
			return await unvote(pid, uid, 'unvote');
		} finally {
			clearVoteProgress(pid, uid);
		}
	};

	Posts.hasVoted = async function (pid, uid) {
		if (parseInt(uid, 10) <= 0) {
			return { upvoted: false, downvoted: false };
		}
		const hasVoted = await db.isMemberOfSets([`pid:${pid}:upvote`, `pid:${pid}:downvote`], uid);
		return { upvoted: hasVoted[0], downvoted: hasVoted[1] };
	};

	Posts.getVoteStatusByPostIDs = async function (pids, uid) {
		if (parseInt(uid, 10) <= 0) {
			const data = pids.map(() => false);
			return { upvotes: data, downvotes: data };
		}
		const upvoteSets = pids.map(pid => `pid:${pid}:upvote`);
		const downvoteSets = pids.map(pid => `pid:${pid}:downvote`);
		const data = await db.isMemberOfSets(upvoteSets.concat(downvoteSets), uid);
		return {
			upvotes: data.slice(0, pids.length),
			downvotes: data.slice(pids.length, pids.length * 2),
		};
	};

	Posts.getUpvotedUidsByPids = async function (pids) {
		return await db.getSetsMembers(pids.map(pid => `pid:${pid}:upvote`));
	};

	function voteInProgress(pid, uid) {
		return Array.isArray(votesInProgress[uid]) && votesInProgress[uid].includes(parseInt(pid, 10));
	}

	function putVoteInProgress(pid, uid) {
		votesInProgress[uid] = votesInProgress[uid] || [];
		votesInProgress[uid].push(parseInt(pid, 10));
	}

	function clearVoteProgress(pid, uid) {
		if (Array.isArray(votesInProgress[uid])) {
			const index = votesInProgress[uid].indexOf(parseInt(pid, 10));
			if (index !== -1) {
				votesInProgress[uid].splice(index, 1);
			}
		}
	}

	async function toggleVote(type, pid, uid) {
		await unvote(pid, uid, type);
		return await vote(type, false, pid, uid);
	}

	async function unvote(pid, uid, command) {
		const [owner, voteStatus] = await Promise.all([
			Posts.getPostField(pid, 'uid'),
			Posts.hasVoted(pid, uid),
		]);

		if (parseInt(uid, 10) === parseInt(owner, 10)) {
			throw new Error('[[error:self-vote]]');
		}

		if (command === 'downvote') {
			await checkDownvoteLimitation(pid, uid);
		}

		let hook;
		let current = voteStatus.upvoted ? 'upvote' : 'downvote';

		if ((voteStatus.upvoted && command === 'downvote') || (voteStatus.downvoted && command === 'upvote')) {	// e.g. User *has* upvoted, and clicks downvote
			hook = command;
		} else if (voteStatus.upvoted || voteStatus.downvoted) {	// e.g. User *has* upvoted, clicks upvote (so we "unvote")
			hook = 'unvote';
		} else {	// e.g. User *has not* voted, clicks upvote
			hook = command;
			current = 'unvote';
		}

		plugins.hooks.fire(`action:post.${hook}`, {
			pid: pid,
			uid: uid,
			owner: owner,
			current: current,
		});

		if (!voteStatus || (!voteStatus.upvoted && !voteStatus.downvoted)) {
			return;
		}

		return await vote(voteStatus.upvoted ? 'downvote' : 'upvote', true, pid, uid);
	}

	async function checkDownvoteLimitation(pid, uid) {
		const oneDay = 86400000;
		const [reputation, targetUid, downvotedPids] = await Promise.all([
			user.getUserField(uid, 'reputation'),
			Posts.getPostField(pid, 'uid'),
			db.getSortedSetRevRangeByScore(
				`uid:${uid}:downvote`, 0, -1, '+inf', Date.now() - oneDay
			),
		]);

		if (reputation < meta.config['min:rep:downvote']) {
			throw new Error('[[error:not-enough-reputation-to-downvote]]');
		}

		if (meta.config.downvotesPerDay && downvotedPids.length >= meta.config.downvotesPerDay) {
			throw new Error(`[[error:too-many-downvotes-today, ${meta.config.downvotesPerDay}]]`);
		}

		if (meta.config.downvotesPerUserPerDay) {
			const postData = await Posts.getPostsFields(downvotedPids, ['uid']);
			const targetDownvotes = postData.filter(p => p.uid === targetUid).length;
			if (targetDownvotes >= meta.config.downvotesPerUserPerDay) {
				throw new Error(`[[error:too-many-downvotes-today-user, ${meta.config.downvotesPerUserPerDay}]]`);
			}
		}
	}

	async function vote(type, unvote, pid, uid) {
		uid = parseInt(uid, 10);
		if (uid <= 0) {
			throw new Error('[[error:not-logged-in]]');
		}
		const now = Date.now();

		if (type === 'upvote' && !unvote) {
			await db.sortedSetAdd(`uid:${uid}:upvote`, now, pid);
		} else {
			await db.sortedSetRemove(`uid:${uid}:upvote`, pid);
		}

		if (type === 'upvote' || unvote) {
			await db.sortedSetRemove(`uid:${uid}:downvote`, pid);
		} else {
			await db.sortedSetAdd(`uid:${uid}:downvote`, now, pid);
		}

		const postData = await Posts.getPostFields(pid, ['pid', 'uid', 'tid']);
		const newReputation = await user.incrementUserReputationBy(postData.uid, type === 'upvote' ? 1 : -1);

		await adjustPostVotes(postData, uid, type, unvote);

		return {
			user: {
				reputation: newReputation,
			},
			fromuid: uid,
			post: postData,
			upvote: type === 'upvote' && !unvote,
			downvote: type === 'downvote' && !unvote,
		};
	}

	async function adjustPostVotes(postData, uid, type, unvote) {
		const notType = (type === 'upvote' ? 'downvote' : 'upvote');
		if (unvote) {
			await db.setRemove(`pid:${postData.pid}:${type}`, uid);
		} else {
			await db.setAdd(`pid:${postData.pid}:${type}`, uid);
		}
		await db.setRemove(`pid:${postData.pid}:${notType}`, uid);

		const [upvotes, downvotes] = await Promise.all([
			db.setCount(`pid:${postData.pid}:upvote`),
			db.setCount(`pid:${postData.pid}:downvote`),
		]);
		postData.upvotes = upvotes;
		postData.downvotes = downvotes;
		postData.votes = postData.upvotes - postData.downvotes;
		await Posts.updatePostVoteCount(postData);
	}

	Posts.updatePostVoteCount = async function (postData) {
		if (!postData || !postData.pid || !postData.tid) {
			return;
		}
		await Promise.all([
			updateTopicVoteCount(postData),
			db.sortedSetAdd('posts:votes', postData.votes, postData.pid),
			Posts.setPostFields(postData.pid, {
				upvotes: postData.upvotes,
				downvotes: postData.downvotes,
			}),
		]);
		plugins.hooks.fire('action:post.updatePostVoteCount', { post: postData });
	};

	async function updateTopicVoteCount(postData) {
		const topicData = await topics.getTopicFields(postData.tid, ['mainPid', 'cid', 'pinned']);

		if (postData.uid) {
			if (postData.votes > 0) {
				await db.sortedSetAdd(`cid:${topicData.cid}:uid:${postData.uid}:pids:votes`, postData.votes, postData.pid);
			} else {
				await db.sortedSetRemove(`cid:${topicData.cid}:uid:${postData.uid}:pids:votes`, postData.pid);
			}
		}

		if (parseInt(topicData.mainPid, 10) !== parseInt(postData.pid, 10)) {
			return await db.sortedSetAdd(`tid:${postData.tid}:posts:votes`, postData.votes, postData.pid);
		}
		const promises = [
			topics.setTopicFields(postData.tid, {
				upvotes: postData.upvotes,
				downvotes: postData.downvotes,
			}),
			db.sortedSetAdd('topics:votes', postData.votes, postData.tid),
		];
		if (!topicData.pinned) {
			promises.push(db.sortedSetAdd(`cid:${topicData.cid}:tids:votes`, postData.votes, postData.tid));
		}
'use strict';

const validator = require('validator');
const _ = require('lodash');

const db = require('../database');
const meta = require('../meta');
const topics = require('../topics');
const user = require('../user');
const privileges = require('../privileges');
const plugins = require('../plugins');
const pubsub = require('../pubsub');
const utils = require('../utils');
const slugify = require('../slugify');
const translator = require('../translator');

module.exports = function (Posts) {
	pubsub.on('post:edit', (pid) => {
		require('./cache').del(pid);
	});

	Posts.edit = async function (data) {
		const canEdit = await privileges.posts.canEdit(data.pid, data.uid);
		if (!canEdit.flag) {
			throw new Error(canEdit.message);
		}
		const postData = await Posts.getPostData(data.pid);
		if (!postData) {
			throw new Error('[[error:no-post]]');
		}

		const oldContent = postData.content; // for diffing purposes
		const now = Date.now();
		const editPostData = {
			content: data.content,
			edited: now,
			editor: data.uid,
		};
		if (data.handle) {
			editPostData.handle = data.handle;
		}

		const result = await plugins.hooks.fire('filter:post.edit', {
			req: data.req,
			post: editPostData,
			data: data,
			uid: data.uid,
		});

		const [editor, topic] = await Promise.all([
			user.getUserFields(data.uid, ['username', 'userslug']),
			editMainPost(data, postData),
		]);

		await Posts.setPostFields(data.pid, result.post);

		if (meta.config.enablePostHistory === 1) {
			await Posts.diffs.save({
				pid: data.pid,
				uid: data.uid,
				oldContent: oldContent,
				newContent: data.content,
			});
		}
		await Posts.uploads.sync(data.pid);

		// Normalize data prior to constructing returnPostData (match types with getPostSummaryByPids)
		postData.deleted = !!postData.deleted;

		const returnPostData = { ...postData, ...result.post };
		returnPostData.cid = topic.cid;
		returnPostData.topic = topic;
		returnPostData.editedISO = utils.toISOString(now);
		returnPostData.changed = oldContent !== data.content;

		await topics.notifyFollowers(returnPostData, data.uid, {
			type: 'post-edit',
			bodyShort: translator.compile('notifications:user_edited_post', editor.username, topic.title),
			nid: `edit_post:${data.pid}:uid:${data.uid}`,
		});

		plugins.hooks.fire('action:post.edit', { post: _.clone(returnPostData), data: data, uid: data.uid });

		require('./cache').del(String(postData.pid));
		pubsub.publish('post:edit', String(postData.pid));

		await Posts.parsePost(returnPostData);

		return {
			topic: topic,
			editor: editor,
			post: returnPostData,
		};
	};

	async function editMainPost(data, postData) {
		const { tid } = postData;
		const title = data.title ? data.title.trim() : '';

		const [topicData, isMain] = await Promise.all([
			topics.getTopicFields(tid, ['cid', 'title', 'timestamp']),
			Posts.isMain(data.pid),
		]);

		if (!isMain) {
			return {
				tid: tid,
				cid: topicData.cid,
				title: validator.escape(String(topicData.title)),
				isMainPost: false,
				renamed: false,
			};
		}

		const newTopicData = {
			tid: tid,
			cid: topicData.cid,
			uid: postData.uid,
			mainPid: data.pid,
		};
		if (title) {
			newTopicData.title = title;
			newTopicData.slug = `${tid}/${slugify(title) || 'topic'}`;
		}

		data.tags = data.tags || [];

		if (data.tags.length) {
			const canTag = await privileges.categories.can('topics:tag', topicData.cid, data.uid);
			if (!canTag) {
				throw new Error('[[error:no-privileges]]');
			}
		}
		await topics.validateTags(data.tags, topicData.cid, data.uid);

		const results = await plugins.hooks.fire('filter:topic.edit', {
			req: data.req,
			topic: newTopicData,
			data: data,
		});
		await db.setObject(`topic:${tid}`, results.topic);
		await topics.updateTopicTags(tid, data.tags);
		const tags = await topics.getTopicTagsObjects(tid);

		newTopicData.tags = data.tags;
		newTopicData.oldTitle = topicData.title;
		newTopicData.timestamp = topicData.timestamp;
		const renamed = translator.escape(validator.escape(String(title))) !== topicData.title;
		plugins.hooks.fire('action:topic.edit', { topic: newTopicData, uid: data.uid });
		return {
			tid: tid,
			cid: newTopicData.cid,
			uid: postData.uid,
			title: validator.escape(String(title)),
			oldTitle: topicData.title,
			slug: newTopicData.slug,
			isMainPost: true,
			renamed: renamed,
			tags: tags,
		};
'use strict';

const async = require('async');
const validator = require('validator');
const _ = require('lodash');

const db = require('../database');
const user = require('../user');
const topics = require('../topics');
const groups = require('../groups');
const meta = require('../meta');
const plugins = require('../plugins');
const privileges = require('../privileges');

module.exports = function (Posts) {
	Posts.getUserInfoForPosts = async function (uids, uid) {
		const [userData, userSettings, canUseSignature] = await Promise.all([
			getUserData(uids, uid),
			user.getMultipleUserSettings(uids),
			privileges.global.can('signature', uid),
		]);

		const groupsMap = await getGroupsMap(userData);

		userData.forEach((userData, index) => {
			userData.signature = validator.escape(String(userData.signature || ''));
			userData.fullname = userSettings[index].showfullname ? validator.escape(String(userData.fullname || '')) : undefined;
			userData.selectedGroups = [];

			if (meta.config.hideFullname) {
				userData.fullname = undefined;
			}
		});

		return await Promise.all(userData.map(async (userData) => {
			const [isMemberOfGroups, signature, customProfileInfo] = await Promise.all([
				checkGroupMembership(userData.uid, userData.groupTitleArray),
				parseSignature(userData, uid, canUseSignature),
				plugins.hooks.fire('filter:posts.custom_profile_info', { profile: [], uid: userData.uid }),
			]);

			if (isMemberOfGroups && userData.groupTitleArray) {
				userData.groupTitleArray.forEach((userGroup, index) => {
					if (isMemberOfGroups[index] && groupsMap[userGroup]) {
						userData.selectedGroups.push(groupsMap[userGroup]);
					}
				});
			}
			userData.signature = signature;
			userData.custom_profile_info = customProfileInfo.profile;

			return await plugins.hooks.fire('filter:posts.modifyUserInfo', userData);
		}));
	};

	async function checkGroupMembership(uid, groupTitleArray) {
		if (!Array.isArray(groupTitleArray) || !groupTitleArray.length) {
			return null;
		}
		return await groups.isMemberOfGroups(uid, groupTitleArray);
	}

	async function parseSignature(userData, uid, canUseSignature) {
		if (!userData.signature || !canUseSignature || meta.config.disableSignatures) {
			return '';
		}
		const result = await Posts.parseSignature(userData, uid);
		return result.userData.signature;
	}

	async function getGroupsMap(userData) {
		const groupTitles = _.uniq(_.flatten(userData.map(u => u && u.groupTitleArray)));
		const groupsMap = {};
		const groupsData = await groups.getGroupsData(groupTitles);
		groupsData.forEach((group) => {
			if (group && group.userTitleEnabled && !group.hidden) {
				groupsMap[group.name] = {
					name: group.name,
					slug: group.slug,
					labelColor: group.labelColor,
					textColor: group.textColor,
					icon: group.icon,
					userTitle: group.userTitle,
				};
			}
		});
		return groupsMap;
	}

	async function getUserData(uids, uid) {
		const fields = [
			'uid', 'username', 'fullname', 'userslug',
			'reputation', 'postcount', 'topiccount', 'picture',
			'signature', 'banned', 'banned:expire', 'status',
			'lastonline', 'groupTitle',
		];
		const result = await plugins.hooks.fire('filter:posts.addUserFields', {
			fields: fields,
			uid: uid,
			uids: uids,
		});
		return await user.getUsersFields(result.uids, _.uniq(result.fields));
	}

	Posts.isOwner = async function (pids, uid) {
		uid = parseInt(uid, 10);
		const isArray = Array.isArray(pids);
		pids = isArray ? pids : [pids];
		if (uid <= 0) {
			return isArray ? pids.map(() => false) : false;
		}
		const postData = await Posts.getPostsFields(pids, ['uid']);
		const result = postData.map(post => post && post.uid === uid);
		return isArray ? result : result[0];
	};

	Posts.isModerator = async function (pids, uid) {
		if (parseInt(uid, 10) <= 0) {
			return pids.map(() => false);
		}
		const cids = await Posts.getCidsByPids(pids);
		return await user.isModerator(uid, cids);
	};

	Posts.changeOwner = async function (pids, toUid) {
		const exists = await user.exists(toUid);
		if (!exists) {
			throw new Error('[[error:no-user]]');
		}
		let postData = await Posts.getPostsFields(pids, [
			'pid', 'tid', 'uid', 'content', 'deleted', 'timestamp', 'upvotes', 'downvotes',
		]);
		postData = postData.filter(p => p.pid && p.uid !== parseInt(toUid, 10));
		pids = postData.map(p => p.pid);

		const cids = await Posts.getCidsByPids(pids);

		const bulkRemove = [];
		const bulkAdd = [];
		let repChange = 0;
		const postsByUser = {};
		postData.forEach((post, i) => {
			post.cid = cids[i];
			repChange += post.votes;
			bulkRemove.push([`uid:${post.uid}:posts`, post.pid]);
			bulkRemove.push([`cid:${post.cid}:uid:${post.uid}:pids`, post.pid]);
			bulkRemove.push([`cid:${post.cid}:uid:${post.uid}:pids:votes`, post.pid]);

			bulkAdd.push([`uid:${toUid}:posts`, post.timestamp, post.pid]);
			bulkAdd.push([`cid:${post.cid}:uid:${toUid}:pids`, post.timestamp, post.pid]);
			if (post.votes > 0) {
				bulkAdd.push([`cid:${post.cid}:uid:${toUid}:pids:votes`, post.votes, post.pid]);
			}
			postsByUser[post.uid] = postsByUser[post.uid] || [];
			postsByUser[post.uid].push(post);
		});

		await Promise.all([
			db.setObjectField(pids.map(pid => `post:${pid}`), 'uid', toUid),
			db.sortedSetRemoveBulk(bulkRemove),
			db.sortedSetAddBulk(bulkAdd),
			user.incrementUserPostCountBy(toUid, pids.length),
			user.incrementUserReputationBy(toUid, repChange),
			handleMainPidOwnerChange(postData, toUid),
			reduceCounters(postsByUser),
			updateTopicPosters(postData, toUid),
		]);

		plugins.hooks.fire('action:post.changeOwner', {
			posts: _.cloneDeep(postData),
			toUid: toUid,
		});
		return postData;
	};

	async function reduceCounters(postsByUser) {
		await async.eachOfSeries(postsByUser, async (posts, uid) => {
			const repChange = posts.reduce((acc, val) => acc + val.votes, 0);
			await Promise.all([
				user.incrementUserPostCountBy(uid, -posts.length),
				user.incrementUserReputationBy(uid, -repChange),
			]);
		});
	}

	async function updateTopicPosters(postData, toUid) {
		const postsByTopic = _.groupBy(postData, p => parseInt(p.tid, 10));
		await async.eachOf(postsByTopic, async (posts, tid) => {
			const postsByUser = _.groupBy(posts, p => parseInt(p.uid, 10));
			await db.sortedSetIncrBy(`tid:${tid}:posters`, posts.length, toUid);
			await async.eachOf(postsByUser, async (posts, uid) => {
				await db.sortedSetIncrBy(`tid:${tid}:posters`, -posts.length, uid);
			});
		});
	}

	async function handleMainPidOwnerChange(postData, toUid) {
		const tids = _.uniq(postData.map(p => p.tid));
		const topicData = await topics.getTopicsFields(tids, [
			'tid', 'cid', 'deleted', 'title', 'uid', 'mainPid', 'timestamp',
		]);
		const tidToTopic = _.zipObject(tids, topicData);

		const mainPosts = postData.filter(p => p.pid === tidToTopic[p.tid].mainPid);
		if (!mainPosts.length) {
			return;
		}

		const bulkAdd = [];
		const bulkRemove = [];
		const postsByUser = {};
		mainPosts.forEach((post) => {
			bulkRemove.push([`cid:${post.cid}:uid:${post.uid}:tids`, post.tid]);
			bulkRemove.push([`uid:${post.uid}:topics`, post.tid]);

			bulkAdd.push([`cid:${post.cid}:uid:${toUid}:tids`, tidToTopic[post.tid].timestamp, post.tid]);
			bulkAdd.push([`uid:${toUid}:topics`, tidToTopic[post.tid].timestamp, post.tid]);
			postsByUser[post.uid] = postsByUser[post.uid] || [];
			postsByUser[post.uid].push(post);
		});

		await Promise.all([
			db.setObjectField(mainPosts.map(p => `topic:${p.tid}`), 'uid', toUid),
			db.sortedSetRemoveBulk(bulkRemove),
			db.sortedSetAddBulk(bulkAdd),
			user.incrementUserFieldBy(toUid, 'topiccount', mainPosts.length),
			reduceTopicCounts(postsByUser),
		]);

		const changedTopics = mainPosts.map(p => tidToTopic[p.tid]);
		plugins.hooks.fire('action:topic.changeOwner', {
			topics: _.cloneDeep(changedTopics),
			toUid: toUid,
		});
	}

	async function reduceTopicCounts(postsByUser) {
		await async.eachSeries(Object.keys(postsByUser), async (uid) => {
			const posts = postsByUser[uid];
			const exists = await user.exists(uid);
			if (exists) {
				await user.incrementUserFieldBy(uid, 'topiccount', -posts.length);
			}
		});
	}
'use strict';

const _ = require('lodash');

const db = require('../database');
const utils = require('../utils');
const user = require('../user');
const privileges = require('../privileges');
const plugins = require('../plugins');

const Posts = module.exports;

require('./data')(Posts);
require('./create')(Posts);
require('./delete')(Posts);
require('./edit')(Posts);
require('./parse')(Posts);
require('./user')(Posts);
require('./topics')(Posts);
require('./category')(Posts);
require('./summary')(Posts);
require('./recent')(Posts);
require('./tools')(Posts);
require('./votes')(Posts);
require('./bookmarks')(Posts);
require('./queue')(Posts);
require('./diffs')(Posts);
require('./uploads')(Posts);

Posts.exists = async function (pids) {
	const isArray = Array.isArray(pids);
	pids = isArray ? pids : [pids];
	const exists = await db.exists(pids.map(pid => `post:${pid}`));
	return isArray ? exists : exists[0];
};

Posts.getPidsFromSet = async function (set, start, stop, reverse) {
	if (isNaN(start) || isNaN(stop)) {
		return [];
	}
	return await db[reverse ? 'getSortedSetRevRange' : 'getSortedSetRange'](set, start, stop);
};

Posts.getPostsByPids = async function (pids, uid) {
	if (!Array.isArray(pids) || !pids.length) {
		return [];
	}
	let posts = await Posts.getPostsData(pids);
	posts = await Promise.all(posts.map(p => Posts.parsePost(p)));
	posts = await user.blocks.filter(uid, posts);
	const data = await plugins.hooks.fire('filter:post.getPosts', { posts: posts, uid: uid });
	if (!data || !Array.isArray(data.posts)) {
		return [];
	}
	return data.posts.filter(Boolean);
};

Posts.getPostSummariesFromSet = async function (set, uid, start, stop) {
	let pids = await db.getSortedSetRevRange(set, start, stop);
	pids = await privileges.posts.filter('topics:read', pids, uid);
	const posts = await Posts.getPostSummaryByPids(pids, uid, { stripTags: false });
	return { posts: posts, nextStart: stop + 1 };
};

Posts.getPidIndex = async function (pid, tid, topicPostSort) {
	const set = topicPostSort === 'most_votes' ? `tid:${tid}:posts:votes` : `tid:${tid}:posts`;
	const reverse = topicPostSort === 'newest_to_oldest' || topicPostSort === 'most_votes';
	const index = await db[reverse ? 'sortedSetRevRank' : 'sortedSetRank'](set, pid);
	if (!utils.isNumber(index)) {
		return 0;
	}
	return utils.isNumber(index) ? parseInt(index, 10) + 1 : 0;
};

Posts.getPostIndices = async function (posts, uid) {
	if (!Array.isArray(posts) || !posts.length) {
		return [];
	}
	const settings = await user.getSettings(uid);

	const byVotes = settings.topicPostSort === 'most_votes';
	let sets = posts.map(p => (byVotes ? `tid:${p.tid}:posts:votes` : `tid:${p.tid}:posts`));
	const reverse = settings.topicPostSort === 'newest_to_oldest' || settings.topicPostSort === 'most_votes';

	const uniqueSets = _.uniq(sets);
	let method = reverse ? 'sortedSetsRevRanks' : 'sortedSetsRanks';
	if (uniqueSets.length === 1) {
		method = reverse ? 'sortedSetRevRanks' : 'sortedSetRanks';
		sets = uniqueSets[0];
	}

	const pids = posts.map(post => post.pid);
	const indices = await db[method](sets, pids);
	return indices.map(index => (utils.isNumber(index) ? parseInt(index, 10) + 1 : 0));
};

Posts.modifyPostByPrivilege = function (post, privileges) {
	if (post.deleted && !(post.selfPost || privileges['posts:view_deleted'])) {
		post.content = '[[topic:post_is_deleted]]';
		if (post.user) {
			post.user.signature = '';
		}
	}
};

'use strict';

const cacheCreate = require('../cacheCreate');
const meta = require('../meta');

module.exports = cacheCreate({
	name: 'post',
	max: meta.config.postCacheSize,
	length: function (n) { return n.length; },
	maxAge: 0,
'use strict';

const privileges = require('../privileges');

module.exports = function (Posts) {
	Posts.tools = {};

	Posts.tools.delete = async function (uid, pid) {
		return await togglePostDelete(uid, pid, true);
	};

	Posts.tools.restore = async function (uid, pid) {
		return await togglePostDelete(uid, pid, false);
	};

	async function togglePostDelete(uid, pid, isDelete) {
		const [postData, canDelete] = await Promise.all([
			Posts.getPostData(pid),
			privileges.posts.canDelete(pid, uid),
		]);
		if (!postData) {
			throw new Error('[[error:no-post]]');
		}

		if (postData.deleted && isDelete) {
			throw new Error('[[error:post-already-deleted]]');
		} else if (!postData.deleted && !isDelete) {
			throw new Error('[[error:post-already-restored]]');
		}

		if (!canDelete.flag) {
			throw new Error(canDelete.message);
		}
		let post;
		if (isDelete) {
			require('./cache').del(pid);
			post = await Posts.delete(pid, uid);
		} else {
			post = await Posts.restore(pid, uid);
			post = await Posts.parsePost(post);

'use strict';

const validator = require('validator');
const _ = require('lodash');

const topics = require('../topics');
const user = require('../user');
const plugins = require('../plugins');
const categories = require('../categories');
const utils = require('../utils');

module.exports = function (Posts) {
	Posts.getPostSummaryByPids = async function (pids, uid, options) {
		if (!Array.isArray(pids) || !pids.length) {
			return [];
		}

		options.stripTags = options.hasOwnProperty('stripTags') ? options.stripTags : false;
		options.parse = options.hasOwnProperty('parse') ? options.parse : true;
		options.extraFields = options.hasOwnProperty('extraFields') ? options.extraFields : [];

		const fields = ['pid', 'tid', 'content', 'uid', 'timestamp', 'deleted', 'upvotes', 'downvotes', 'replies'].concat(options.extraFields);

		let posts = await Posts.getPostsFields(pids, fields);
		posts = posts.filter(Boolean);
		posts = await user.blocks.filter(uid, posts);

		const uids = _.uniq(posts.map(p => p && p.uid));
		const tids = _.uniq(posts.map(p => p && p.tid));

		const [users, topicsAndCategories] = await Promise.all([
			user.getUsersFields(uids, ['uid', 'username', 'userslug', 'picture', 'status']),
			getTopicAndCategories(tids),
		]);

		const uidToUser = toObject('uid', users);
		const tidToTopic = toObject('tid', topicsAndCategories.topics);
		const cidToCategory = toObject('cid', topicsAndCategories.categories);

		posts.forEach((post) => {
			// If the post author isn't represented in the retrieved users' data,
			// then it means they were deleted, assume guest.
			if (!uidToUser.hasOwnProperty(post.uid)) {
				post.uid = 0;
			}
			post.user = uidToUser[post.uid];
			post.topic = tidToTopic[post.tid];
			post.category = post.topic && cidToCategory[post.topic.cid];
			post.isMainPost = post.topic && post.pid === post.topic.mainPid;
			post.deleted = post.deleted === 1;
			post.timestampISO = utils.toISOString(post.timestamp);
		});

		posts = posts.filter(post => tidToTopic[post.tid]);

		posts = await parsePosts(posts, options);
		const result = await plugins.hooks.fire('filter:post.getPostSummaryByPids', { posts: posts, uid: uid });
		return result.posts;
	};

	async function parsePosts(posts, options) {
		async function parse(post) {
			if (!post.content || !options.parse) {
				post.content = post.content ? validator.escape(String(post.content)) : post.content;
				return post;
			}
			post = await Posts.parsePost(post);
			if (options.stripTags) {
				post.content = stripTags(post.content);
			}
			return post;
		}
		return await Promise.all(posts.map(p => parse(p)));
	}

	async function getTopicAndCategories(tids) {
		const topicsData = await topics.getTopicsFields(tids, ['uid', 'tid', 'title', 'cid', 'slug', 'deleted', 'postcount', 'mainPid', 'teaserPid']);
		const cids = _.uniq(topicsData.map(topic => topic && topic.cid));
		const categoriesData = await categories.getCategoriesFields(cids, ['cid', 'name', 'icon', 'slug', 'parentCid', 'bgColor', 'color', 'backgroundImage', 'imageClass']);
		return { topics: topicsData, categories: categoriesData };
	}

	function toObject(key, data) {
		const obj = {};
		for (let i = 0; i < data.length; i += 1) {
			obj[data[i][key]] = data[i];
		}
		return obj;
	}

	function stripTags(content) {
		if (content) {
			return utils.stripHTMLTags(content, utils.stripTags);
		}
'use strict';

const async = require('async');
const nconf = require('nconf');
const crypto = require('crypto');
const path = require('path');
const winston = require('winston');
const mime = require('mime');
const validator = require('validator');

const db = require('../database');
const image = require('../image');
const topics = require('../topics');
const file = require('../file');

module.exports = function (Posts) {
	Posts.uploads = {};

	const md5 = filename => crypto.createHash('md5').update(filename).digest('hex');
	const pathPrefix = path.join(nconf.get('upload_path'), 'files');
	const searchRegex = /\/assets\/uploads\/files\/([^\s")]+\.?[\w]*)/g;

	Posts.uploads.sync = async function (pid) {
		// Scans a post's content and updates sorted set of uploads

		const [content, currentUploads, isMainPost] = await Promise.all([
			Posts.getPostField(pid, 'content'),
			Posts.uploads.list(pid),
			Posts.isMain(pid),
		]);

		// Extract upload file paths from post content
		let match = searchRegex.exec(content);
		const uploads = [];
		while (match) {
			uploads.push(match[1].replace('-resized', ''));
			match = searchRegex.exec(content);
		}

		// Main posts can contain topic thumbs, which are also tracked by pid
		if (isMainPost) {
			const tid = await Posts.getPostField(pid, 'tid');
			let thumbs = await topics.thumbs.get(tid);
			thumbs = thumbs.map(thumb => thumb.url.replace(path.join(nconf.get('relative_path'), nconf.get('upload_url'), 'files/'), '')).filter(path => !validator.isURL(path, {
				require_protocol: true,
			}));
			uploads.push(...thumbs);
		}

		// Create add/remove sets
		const add = uploads.filter(path => !currentUploads.includes(path));
		const remove = currentUploads.filter(path => !uploads.includes(path));
		await Promise.all([
			Posts.uploads.associate(pid, add),
			Posts.uploads.dissociate(pid, remove),
		]);
	};

	Posts.uploads.list = async function (pid) {
		return await db.getSortedSetMembers(`post:${pid}:uploads`);
	};

	Posts.uploads.listWithSizes = async function (pid) {
		const paths = await Posts.uploads.list(pid);
		const sizes = await db.getObjects(paths.map(path => `upload:${md5(path)}`)) || [];

		return sizes.map((sizeObj, idx) => ({
			...sizeObj,
			name: paths[idx],
		}));
	};

	Posts.uploads.isOrphan = async function (filePath) {
		const length = await db.sortedSetCard(`upload:${md5(filePath)}:pids`);
		return length === 0;
	};

	Posts.uploads.getUsage = async function (filePaths) {
		// Given an array of file names, determines which pids they are used in
		if (!Array.isArray(filePaths)) {
			filePaths = [filePaths];
		}

		const keys = filePaths.map(fileObj => `upload:${md5(fileObj.name.replace('-resized', ''))}:pids`);
		return await Promise.all(keys.map(k => db.getSortedSetRange(k, 0, -1)));
	};

	Posts.uploads.associate = async function (pid, filePaths) {
		// Adds an upload to a post's sorted set of uploads
		filePaths = !Array.isArray(filePaths) ? [filePaths] : filePaths;
		if (!filePaths.length) {
			return;
		}
		// Only process files that exist
		filePaths = await async.filter(filePaths, async filePath => await file.exists(path.join(pathPrefix, filePath)));

		const now = Date.now();
		const scores = filePaths.map(() => now);
		const bulkAdd = filePaths.map(path => [`upload:${md5(path)}:pids`, now, pid]);
		await Promise.all([
			db.sortedSetAdd(`post:${pid}:uploads`, scores, filePaths),
			db.sortedSetAddBulk(bulkAdd),
			Posts.uploads.saveSize(filePaths),
		]);
	};

	Posts.uploads.dissociate = async function (pid, filePaths) {
		// Removes an upload from a post's sorted set of uploads
		filePaths = !Array.isArray(filePaths) ? [filePaths] : filePaths;
		if (!filePaths.length) {
			return;
		}

		const bulkRemove = filePaths.map(path => [`upload:${md5(path)}:pids`, pid]);
		await Promise.all([
			db.sortedSetRemove(`post:${pid}:uploads`, filePaths),
			db.sortedSetRemoveBulk(bulkRemove),
		]);
	};

	Posts.uploads.dissociateAll = async (pid) => {
		const current = await Posts.uploads.list(pid);
		await Promise.all(current.map(async path => await Posts.uploads.dissociate(pid, path)));
	};

	Posts.uploads.saveSize = async (filePaths) => {
		filePaths = filePaths.filter((fileName) => {
			const type = mime.getType(fileName);
			return type && type.match(/image./);
		});
		await Promise.all(filePaths.map(async (fileName) => {
			try {
				const size = await image.size(path.join(pathPrefix, fileName));
				winston.verbose(`[posts/uploads/${fileName}] Saving size`);
				await db.setObject(`upload:${md5(fileName)}`, {
					width: size.width,
					height: size.height,
				});
			} catch (err) {
				winston.error(`[posts/uploads] Error while saving post upload sizes (${fileName}): ${err.message}`);
'use strict';

const validator = require('validator');
const diff = require('diff');

const db = require('../database');
const meta = require('../meta');
const plugins = require('../plugins');
const translator = require('../translator');


module.exports = function (Posts) {
	const Diffs = {};
	Posts.diffs = Diffs;
	Diffs.exists = async function (pid) {
		if (meta.config.enablePostHistory !== 1) {
			return false;
		}

		const numDiffs = await db.listLength(`post:${pid}:diffs`);
		return !!numDiffs;
	};

	Diffs.get = async function (pid, since) {
		const timestamps = await Diffs.list(pid);
		if (!since) {
			since = 0;
		}

		// Pass those made after `since`, and create keys
		const keys = timestamps.filter(t => (parseInt(t, 10) || 0) > since)
			.map(t => `diff:${pid}.${t}`);
		return await db.getObjects(keys);
	};

	Diffs.list = async function (pid) {
		return await db.getListRange(`post:${pid}:diffs`, 0, -1);
	};

	Diffs.save = async function (data) {
		const { pid, uid, oldContent, newContent } = data;
		const now = Date.now();
		const patch = diff.createPatch('', newContent, oldContent);
		await Promise.all([
			db.listPrepend(`post:${pid}:diffs`, now),
			db.setObject(`diff:${pid}.${now}`, {
				uid: uid,
				pid: pid,
				patch: patch,
			}),
		]);
	};

	Diffs.load = async function (pid, since, uid) {
		const post = await postDiffLoad(pid, since, uid);
		post.content = String(post.content || '');

		const result = await plugins.hooks.fire('filter:parse.post', { postData: post });
		result.postData.content = translator.escape(result.postData.content);
		return result.postData;
	};

	Diffs.restore = async function (pid, since, uid, req) {
		const post = await postDiffLoad(pid, since, uid);

		return await Posts.edit({
			uid: uid,
			pid: pid,
			content: post.content,
			req: req,
		});
	};

	Diffs.delete = async function (pid, timestamp, uid) {
		getValidatedTimestamp(timestamp);

		const [post, diffs, timestamps] = await Promise.all([
			Posts.getPostSummaryByPids([pid], uid, { parse: false }),
			Diffs.get(pid),
			Diffs.list(pid),
		]);

		const timestampIndex = timestamps.indexOf(timestamp);
		const lastTimestampIndex = timestamps.length - 1;

		if (timestamp === String(post[0].timestamp)) {
			// Deleting oldest diff, so history rewrite is not needed
			return Promise.all([
				db.delete(`diff:${pid}.${timestamps[lastTimestampIndex]}`),
				db.listRemoveAll(`post:${pid}:diffs`, timestamps[lastTimestampIndex]),
			]);
		}
		if (timestampIndex === 0 || timestampIndex === -1) {
			throw new Error('[[error:invalid-data]]');
		}

		const postContent = validator.unescape(post[0].content);
		const versionContents = {};
		for (let i = 0, content = postContent; i < timestamps.length; ++i) {
			versionContents[timestamps[i]] = applyPatch(content, diffs[i]);
			content = versionContents[timestamps[i]];
		}

		/* eslint-disable no-await-in-loop */
		for (let i = lastTimestampIndex; i >= timestampIndex; --i) {
			// Recreate older diffs with skipping the deleted diff
			const newContentIndex = i === timestampIndex ? i - 2 : i - 1;
			const timestampToUpdate = newContentIndex + 1;
			const newContent = newContentIndex < 0 ? postContent : versionContents[timestamps[newContentIndex]];
			const patch = diff.createPatch('', newContent, versionContents[timestamps[i]]);
			await db.setObject(`diff:${pid}.${timestamps[timestampToUpdate]}`, { patch });
		}

		return Promise.all([
			db.delete(`diff:${pid}.${timestamp}`),
			db.listRemoveAll(`post:${pid}:diffs`, timestamp),
		]);
	};

	async function postDiffLoad(pid, since, uid) {
		// Retrieves all diffs made since `since` and replays them to reconstruct what the post looked like at `since`
		since = getValidatedTimestamp(since);

		const [post, diffs] = await Promise.all([
			Posts.getPostSummaryByPids([pid], uid, { parse: false }),
			Posts.diffs.get(pid, since),
		]);

		// Replace content with re-constructed content from that point in time
		post[0].content = diffs.reduce(applyPatch, validator.unescape(post[0].content));

		return post[0];
	}

	function getValidatedTimestamp(timestamp) {
		timestamp = parseInt(timestamp, 10);

		if (isNaN(timestamp) || timestamp > Date.now()) {
			throw new Error('[[error:invalid-data]]');
		}

		return timestamp;
	}

	function applyPatch(content, aDiff) {
		const result = diff.applyPatch(content, aDiff.patch, {
			fuzzFactor: 1,
		});
		return typeof result === 'string' ? result : content;
	}
'use strict';

const winston = require('winston');
const cronJob = require('cron').CronJob;

const meta = require('../meta');

const jobs = {};

module.exports = function (User) {
	User.startJobs = function () {
		winston.verbose('[user/jobs] (Re-)starting jobs...');

		let started = 0;
		let { digestHour } = meta.config;

		// Fix digest hour if invalid
		if (isNaN(digestHour)) {
			digestHour = 17;
		} else if (digestHour > 23 || digestHour < 0) {
			digestHour = 0;
		}

		User.stopJobs();

		startDigestJob('digest.daily', `0 ${digestHour} * * *`, 'day');
		startDigestJob('digest.weekly', `0 ${digestHour} * * 0`, 'week');
		startDigestJob('digest.monthly', `0 ${digestHour} 1 * *`, 'month');
		started += 3;

		jobs['reset.clean'] = new cronJob('0 0 * * *', User.reset.clean, null, true);
		winston.verbose('[user/jobs] Starting job (reset.clean)');
		started += 1;

		winston.verbose(`[user/jobs] ${started} jobs started`);
	};

	function startDigestJob(name, cronString, term) {
		jobs[name] = new cronJob(cronString, (() => {
			winston.verbose(`[user/jobs] Digest job (${name}) started.`);
			User.digest.execute({ interval: term });
		}), null, true);
		winston.verbose(`[user/jobs] Starting job (${name})`);
	}

	User.stopJobs = function () {
		let terminated = 0;
		// Terminate any active cron jobs
		for (const jobId of Object.keys(jobs)) {
			winston.verbose(`[user/jobs] Terminating job (${jobId})`);
			jobs[jobId].stop();
			delete jobs[jobId];
			terminated += 1;
		}
		if (terminated > 0) {

'use strict';

const validator = require('validator');

const meta = require('../meta');
const db = require('../database');
const plugins = require('../plugins');
const notifications = require('../notifications');
const languages = require('../languages');

module.exports = function (User) {
	User.getSettings = async function (uid) {
		if (parseInt(uid, 10) <= 0) {
			return await onSettingsLoaded(0, {});
		}
		let settings = await db.getObject(`user:${uid}:settings`);
		settings = settings || {};
		settings.uid = uid;
		return await onSettingsLoaded(uid, settings);
	};

	User.getMultipleUserSettings = async function (uids) {
		if (!Array.isArray(uids) || !uids.length) {
			return [];
		}

		const keys = uids.map(uid => `user:${uid}:settings`);
		let settings = await db.getObjects(keys);
		settings = settings.map((userSettings, index) => {
			userSettings = userSettings || {};
			userSettings.uid = uids[index];
			return userSettings;
		});
		return await Promise.all(settings.map(s => onSettingsLoaded(s.uid, s)));
	};

	async function onSettingsLoaded(uid, settings) {
		const data = await plugins.hooks.fire('filter:user.getSettings', { uid: uid, settings: settings });
		settings = data.settings;

		const defaultTopicsPerPage = meta.config.topicsPerPage;
		const defaultPostsPerPage = meta.config.postsPerPage;

		settings.showemail = parseInt(getSetting(settings, 'showemail', 0), 10) === 1;
		settings.showfullname = parseInt(getSetting(settings, 'showfullname', 0), 10) === 1;
		settings.openOutgoingLinksInNewTab = parseInt(getSetting(settings, 'openOutgoingLinksInNewTab', 0), 10) === 1;
		settings.dailyDigestFreq = getSetting(settings, 'dailyDigestFreq', 'off');
		settings.usePagination = parseInt(getSetting(settings, 'usePagination', 0), 10) === 1;
		settings.topicsPerPage = Math.min(
			meta.config.maxTopicsPerPage,
			settings.topicsPerPage ? parseInt(settings.topicsPerPage, 10) : defaultTopicsPerPage,
			defaultTopicsPerPage
		);
		settings.postsPerPage = Math.min(
			meta.config.maxPostsPerPage,
			settings.postsPerPage ? parseInt(settings.postsPerPage, 10) : defaultPostsPerPage,
			defaultPostsPerPage
		);
		settings.userLang = settings.userLang || meta.config.defaultLang || 'en-GB';
		settings.acpLang = settings.acpLang || settings.userLang;
		settings.topicPostSort = getSetting(settings, 'topicPostSort', 'oldest_to_newest');
		settings.categoryTopicSort = getSetting(settings, 'categoryTopicSort', 'newest_to_oldest');
		settings.followTopicsOnCreate = parseInt(getSetting(settings, 'followTopicsOnCreate', 1), 10) === 1;
		settings.followTopicsOnReply = parseInt(getSetting(settings, 'followTopicsOnReply', 0), 10) === 1;
		settings.upvoteNotifFreq = getSetting(settings, 'upvoteNotifFreq', 'all');
		settings.restrictChat = parseInt(getSetting(settings, 'restrictChat', 0), 10) === 1;
		settings.topicSearchEnabled = parseInt(getSetting(settings, 'topicSearchEnabled', 0), 10) === 1;
		settings.updateUrlWithPostIndex = parseInt(getSetting(settings, 'updateUrlWithPostIndex', 1), 10) === 1;
		settings.bootswatchSkin = validator.escape(String(settings.bootswatchSkin || ''));
		settings.homePageRoute = validator.escape(String(settings.homePageRoute || '')).replace(/&#x2F;/g, '/');
		settings.scrollToMyPost = parseInt(getSetting(settings, 'scrollToMyPost', 1), 10) === 1;
		settings.categoryWatchState = getSetting(settings, 'categoryWatchState', 'notwatching');

		const notificationTypes = await notifications.getAllNotificationTypes();
		notificationTypes.forEach((notificationType) => {
			settings[notificationType] = getSetting(settings, notificationType, 'notification');
		});

		return settings;
	}

	function getSetting(settings, key, defaultValue) {
		if (settings[key] || settings[key] === 0) {
			return settings[key];
		} else if (meta.config[key] || meta.config[key] === 0) {
			return meta.config[key];
		}
		return defaultValue;
	}

	User.saveSettings = async function (uid, data) {
		const maxPostsPerPage = meta.config.maxPostsPerPage || 20;
		if (
			!data.postsPerPage ||
			parseInt(data.postsPerPage, 10) <= 1 ||
			parseInt(data.postsPerPage, 10) > maxPostsPerPage
		) {
			throw new Error(`[[error:invalid-pagination-value, 2, ${maxPostsPerPage}]]`);
		}

		const maxTopicsPerPage = meta.config.maxTopicsPerPage || 20;
		if (
			!data.topicsPerPage ||
			parseInt(data.topicsPerPage, 10) <= 1 ||
			parseInt(data.topicsPerPage, 10) > maxTopicsPerPage
		) {
			throw new Error(`[[error:invalid-pagination-value, 2, ${maxTopicsPerPage}]]`);
		}

		const languageCodes = await languages.listCodes();
		if (data.userLang && !languageCodes.includes(data.userLang)) {
			throw new Error('[[error:invalid-language]]');
		}
		if (data.acpLang && !languageCodes.includes(data.acpLang)) {
			throw new Error('[[error:invalid-language]]');
		}
		data.userLang = data.userLang || meta.config.defaultLang;

		plugins.hooks.fire('action:user.saveSettings', { uid: uid, settings: data });

		const settings = {
			showemail: data.showemail,
			showfullname: data.showfullname,
			openOutgoingLinksInNewTab: data.openOutgoingLinksInNewTab,
			dailyDigestFreq: data.dailyDigestFreq || 'off',
			usePagination: data.usePagination,
			topicsPerPage: Math.min(data.topicsPerPage, parseInt(maxTopicsPerPage, 10) || 20),
			postsPerPage: Math.min(data.postsPerPage, parseInt(maxPostsPerPage, 10) || 20),
			userLang: data.userLang || meta.config.defaultLang,
			acpLang: data.acpLang || meta.config.defaultLang,
			followTopicsOnCreate: data.followTopicsOnCreate,
			followTopicsOnReply: data.followTopicsOnReply,
			restrictChat: data.restrictChat,
			topicSearchEnabled: data.topicSearchEnabled,
			updateUrlWithPostIndex: data.updateUrlWithPostIndex,
			homePageRoute: ((data.homePageRoute === 'custom' ? data.homePageCustom : data.homePageRoute) || '').replace(/^\//, ''),
			scrollToMyPost: data.scrollToMyPost,
			upvoteNotifFreq: data.upvoteNotifFreq,
			bootswatchSkin: data.bootswatchSkin,
			categoryWatchState: data.categoryWatchState,
			categoryTopicSort: data.categoryTopicSort,
			topicPostSort: data.topicPostSort,
		};
		const notificationTypes = await notifications.getAllNotificationTypes();
		notificationTypes.forEach((notificationType) => {
			if (data[notificationType]) {
				settings[notificationType] = data[notificationType];
			}
		});
		const result = await plugins.hooks.fire('filter:user.saveSettings', { settings: settings, data: data });
		await db.setObject(`user:${uid}:settings`, result.settings);
		await User.updateDigestSetting(uid, data.dailyDigestFreq);
		return await User.getSettings(uid);
	};

	User.updateDigestSetting = async function (uid, dailyDigestFreq) {
		await db.sortedSetsRemove(['digest:day:uids', 'digest:week:uids', 'digest:month:uids'], uid);
		if (['day', 'week', 'month'].includes(dailyDigestFreq)) {
			await db.sortedSetAdd(`digest:${dailyDigestFreq}:uids`, Date.now(), uid);
		}
	};

	User.setSetting = async function (uid, key, value) {
		if (parseInt(uid, 10) <= 0) {
			return;
		}

		await db.setObjectField(`user:${uid}:settings`, key, value);
	};
'use strict';

const zxcvbn = require('zxcvbn');
const winston = require('winston');

const db = require('../database');
const utils = require('../utils');
const slugify = require('../slugify');
const plugins = require('../plugins');
const groups = require('../groups');
const meta = require('../meta');
const analytics = require('../analytics');

module.exports = function (User) {
	User.create = async function (data) {
		data.username = data.username.trim();
		data.userslug = slugify(data.username);
		if (data.email !== undefined) {
			data.email = String(data.email).trim();
		}

		try {
			await lock(data.username, '[[error:username-taken]]');
			if (data.email) {
				await lock(data.email, '[[error:email-taken]]');
			}

			await User.isDataValid(data);

			return await create(data);
		} finally {
			await db.deleteObjectFields('locks', [data.username, data.email]);
		}
	};

	async function lock(value, error) {
		const count = await db.incrObjectField('locks', value);
		if (count > 1) {
			throw new Error(error);
		}
	}

	async function create(data) {
		const timestamp = data.timestamp || Date.now();

		let userData = {
			username: data.username,
			userslug: data.userslug,
			email: data.email || '',
			joindate: timestamp,
			lastonline: timestamp,
			status: 'online',
		};
		['picture', 'fullname', 'location', 'birthday'].forEach((field) => {
			if (data[field]) {
				userData[field] = data[field];
			}
		});
		if (data.gdpr_consent === true) {
			userData.gdpr_consent = 1;
		}
		if (data.acceptTos === true) {
			userData.acceptTos = 1;
		}

		const renamedUsername = await User.uniqueUsername(userData);
		const userNameChanged = !!renamedUsername;
		if (userNameChanged) {
			userData.username = renamedUsername;
			userData.userslug = slugify(renamedUsername);
		}

		const results = await plugins.hooks.fire('filter:user.create', { user: userData, data: data });
		userData = results.user;

		const uid = await db.incrObjectField('global', 'nextUid');
		const isFirstUser = uid === 1;
		userData.uid = uid;

		if (isFirstUser) {
			userData['email:confirmed'] = 1;
		}
		await db.setObject(`user:${uid}`, userData);

		const bulkAdd = [
			['username:uid', userData.uid, userData.username],
			[`user:${userData.uid}:usernames`, timestamp, `${userData.username}:${timestamp}`],
			['username:sorted', 0, `${userData.username.toLowerCase()}:${userData.uid}`],
			['userslug:uid', userData.uid, userData.userslug],
			['users:joindate', timestamp, userData.uid],
			['users:online', timestamp, userData.uid],
			['users:postcount', 0, userData.uid],
			['users:reputation', 0, userData.uid],
		];

		if (userData.email) {
			bulkAdd.push(['email:uid', userData.uid, userData.email.toLowerCase()]);
			bulkAdd.push(['email:sorted', 0, `${userData.email.toLowerCase()}:${userData.uid}`]);
			bulkAdd.push([`user:${userData.uid}:emails`, timestamp, `${userData.email}:${timestamp}`]);
		}

		if (userData.fullname) {
			bulkAdd.push(['fullname:sorted', 0, `${userData.fullname.toLowerCase()}:${userData.uid}`]);
		}

		const groupsToJoin = ['registered-users'].concat(
			isFirstUser ? 'verified-users' : 'unverified-users'
		);

		await Promise.all([
			db.incrObjectField('global', 'userCount'),
			analytics.increment('registrations'),
			db.sortedSetAddBulk(bulkAdd),
			groups.join(groupsToJoin, userData.uid),
			User.notifications.sendWelcomeNotification(userData.uid),
			storePassword(userData.uid, data.password),
			User.updateDigestSetting(userData.uid, meta.config.dailyDigestFreq),
		]);

		if (userData.email && userData.uid > 1 && meta.config.requireEmailConfirmation) {
			User.email.sendValidationEmail(userData.uid, {
				email: userData.email,
			}).catch(err => winston.error(`[user.create] Validation email failed to send\n[emailer.send] ${err.stack}`));
		}
		if (userNameChanged) {
			await User.notifications.sendNameChangeNotification(userData.uid, userData.username);
		}
		plugins.hooks.fire('action:user.create', { user: userData, data: data });
		return userData.uid;
	}

	async function storePassword(uid, password) {
		if (!password) {
			return;
		}
		const hash = await User.hashPassword(password);
		await Promise.all([
			User.setUserFields(uid, {
				password: hash,
				'password:shaWrapped': 1,
			}),
			User.reset.updateExpiry(uid),
		]);
	}

	User.isDataValid = async function (userData) {
		if (userData.email && !utils.isEmailValid(userData.email)) {
			throw new Error('[[error:invalid-email]]');
		}

		if (!utils.isUserNameValid(userData.username) || !userData.userslug) {
			throw new Error(`[[error:invalid-username, ${userData.username}]]`);
		}

		if (userData.password) {
			User.isPasswordValid(userData.password);
		}

		if (userData.email) {
			const available = await User.email.available(userData.email);
			if (!available) {
				throw new Error('[[error:email-taken]]');
			}
		}
	};

	User.isPasswordValid = function (password, minStrength) {
		minStrength = (minStrength || minStrength === 0) ? minStrength : meta.config.minimumPasswordStrength;

		// Sanity checks: Checks if defined and is string
		if (!password || !utils.isPasswordValid(password)) {
			throw new Error('[[error:invalid-password]]');
		}

		if (password.length < meta.config.minimumPasswordLength) {
			throw new Error('[[reset_password:password_too_short]]');
		}

		if (password.length > 512) {
			throw new Error('[[error:password-too-long]]');
		}

		const strength = zxcvbn(password);
		if (strength.score < minStrength) {
			throw new Error('[[user:weak_password]]');
		}
	};

	User.uniqueUsername = async function (userData) {
		let numTries = 0;
		let { username } = userData;
		while (true) {
			/* eslint-disable no-await-in-loop */
			const exists = await meta.userOrGroupExists(username);
			if (!exists) {
				return numTries ? username : null;
			}
			username = `${userData.username} ${numTries.toString(32)}`;
			numTries += 1;
		}

'use strict';

const fs = require('fs');
const path = require('path');
const winston = require('winston');
const validator = require('validator');

const { baseDir } = require('../constants').paths;
const db = require('../database');
const plugins = require('../plugins');
const batch = require('../batch');

module.exports = function (User) {
	User.logIP = async function (uid, ip) {
		if (!(parseInt(uid, 10) > 0)) {
			return;
		}
		const now = Date.now();
		const bulk = [
			[`uid:${uid}:ip`, now, ip || 'Unknown'],
		];
		if (ip) {
			bulk.push([`ip:${ip}:uid`, now, uid]);
		}
		await db.sortedSetAddBulk(bulk);
	};

	User.getIPs = async function (uid, stop) {
		const ips = await db.getSortedSetRevRange(`uid:${uid}:ip`, 0, stop);
		return ips.map(ip => validator.escape(String(ip)));
	};

	User.getUsersCSV = async function () {
		winston.verbose('[user/getUsersCSV] Compiling User CSV data');

		const data = await plugins.hooks.fire('filter:user.csvFields', { fields: ['uid', 'email', 'username'] });
		let csvContent = `${data.fields.join(',')}\n`;
		await batch.processSortedSet('users:joindate', async (uids) => {
			const usersData = await User.getUsersFields(uids, data.fields);
			csvContent += usersData.reduce((memo, user) => {
				memo += `${data.fields.map(field => user[field]).join(',')}\n`;
				return memo;
			}, '');
		}, {});

		return csvContent;
	};

	User.exportUsersCSV = async function () {
		winston.verbose('[user/exportUsersCSV] Exporting User CSV data');

		const data = await plugins.hooks.fire('filter:user.csvFields', { fields: ['email', 'username', 'uid'] });
		const fd = await fs.promises.open(
			path.join(baseDir, 'build/export', 'users.csv'),
			'w'
		);
		fs.promises.appendFile(fd, `${data.fields.join(',')}\n`);
		await batch.processSortedSet('users:joindate', async (uids) => {
			const usersData = await User.getUsersFields(uids, data.fields.slice());
			let line = '';
			usersData.forEach((user) => {
				line += `${data.fields.map(field => user[field]).join(',')}\n`;
			});

			await fs.promises.appendFile(fd, line);
		}, {
			batch: 5000,
			interval: 250,
		});
'use strict';

const db = require('../database');
const topics = require('../topics');
const plugins = require('../plugins');
const meta = require('../meta');

module.exports = function (User) {
	User.updateLastOnlineTime = async function (uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return;
		}
		const userData = await db.getObjectFields(`user:${uid}`, ['status', 'lastonline']);
		const now = Date.now();
		if (userData.status === 'offline' || now - parseInt(userData.lastonline, 10) < 300000) {
			return;
		}
		await User.setUserField(uid, 'lastonline', now);
	};

	User.updateOnlineUsers = async function (uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return;
		}
		const now = Date.now();
		const userOnlineTime = await db.sortedSetScore('users:online', uid);
		if (now - parseInt(userOnlineTime, 10) < 300000) {
			return;
		}
		await db.sortedSetAdd('users:online', now, uid);
		topics.pushUnreadCount(uid);
		plugins.hooks.fire('action:user.online', { uid: uid, timestamp: now });
	};

	User.isOnline = async function (uid) {
		const now = Date.now();
		const isArray = Array.isArray(uid);
		uid = isArray ? uid : [uid];
		const lastonline = await db.sortedSetScores('users:online', uid);
		const isOnline = uid.map((uid, index) => (now - lastonline[index]) < (meta.config.onlineCutoff * 60000));

'use strict';

const async = require('async');
const nconf = require('nconf');
const validator = require('validator');

const db = require('../database');
const meta = require('../meta');
const emailer = require('../emailer');
const groups = require('../groups');
const translator = require('../translator');
const utils = require('../utils');

module.exports = function (User) {
	User.getInvites = async function (uid) {
		const emails = await db.getSetMembers(`invitation:uid:${uid}`);
		return emails.map(email => validator.escape(String(email)));
	};

	User.getInvitesNumber = async function (uid) {
		return await db.setCount(`invitation:uid:${uid}`);
	};

	User.getInvitingUsers = async function () {
		return await db.getSetMembers('invitation:uids');
	};

	User.getAllInvites = async function () {
		const uids = await User.getInvitingUsers();
		const invitations = await async.map(uids, User.getInvites);
		return invitations.map((invites, index) => ({
			uid: uids[index],
			invitations: invites,
		}));
	};

	User.sendInvitationEmail = async function (uid, email, groupsToJoin) {
		if (!uid) {
			throw new Error('[[error:invalid-uid]]');
		}

		const email_exists = await User.getUidByEmail(email);
		if (email_exists) {
			throw new Error('[[error:email-taken]]');
		}

		const invitation_exists = await db.exists(`invitation:email:${email}`);
		if (invitation_exists) {
			throw new Error('[[error:email-invited]]');
		}

		const data = await prepareInvitation(uid, email, groupsToJoin);
		await emailer.sendToEmail('invitation', email, meta.config.defaultLang, data);
	};

	User.verifyInvitation = async function (query) {
		if (!query.token || !query.email) {
			if (meta.config.registrationType.startsWith('admin-')) {
				throw new Error('[[register:invite.error-admin-only]]');
			} else {
				throw new Error('[[register:invite.error-invite-only]]');
			}
		}
		const token = await db.getObjectField(`invitation:email:${query.email}`, 'token');
		if (!token || token !== query.token) {
			throw new Error('[[register:invite.error-invalid-data]]');
		}
	};

	User.joinGroupsFromInvitation = async function (uid, email) {
		let groupsToJoin = await db.getObjectField(`invitation:email:${email}`, 'groupsToJoin');

		try {
			groupsToJoin = JSON.parse(groupsToJoin);
		} catch (e) {
			return;
		}

		if (!groupsToJoin || groupsToJoin.length < 1) {
			return;
		}

		await groups.join(groupsToJoin, uid);
	};

	User.deleteInvitation = async function (invitedBy, email) {
		const invitedByUid = await User.getUidByUsername(invitedBy);
		if (!invitedByUid) {
			throw new Error('[[error:invalid-username]]');
		}
		await Promise.all([
			deleteFromReferenceList(invitedByUid, email),
			db.delete(`invitation:email:${email}`),
		]);
	};

	User.deleteInvitationKey = async function (email) {
		const uids = await User.getInvitingUsers();
		await Promise.all(uids.map(uid => deleteFromReferenceList(uid, email)));
		await db.delete(`invitation:email:${email}`);
	};

	async function deleteFromReferenceList(uid, email) {
		await db.setRemove(`invitation:uid:${uid}`, email);
		const count = await db.setCount(`invitation:uid:${uid}`);
		if (count === 0) {
			await db.setRemove('invitation:uids', uid);
		}
	}

	async function prepareInvitation(uid, email, groupsToJoin) {
		const inviterExists = await User.exists(uid);
		if (!inviterExists) {
			throw new Error('[[error:invalid-uid]]');
		}

		const token = utils.generateUUID();
		const registerLink = `${nconf.get('url')}/register?token=${token}&email=${encodeURIComponent(email)}`;

		const expireDays = meta.config.inviteExpiration;
		const expireIn = expireDays * 86400000;

		await db.setAdd(`invitation:uid:${uid}`, email);
		await db.setAdd('invitation:uids', uid);
		await db.setObject(`invitation:email:${email}`, {
			token,
			groupsToJoin: JSON.stringify(groupsToJoin),
		});
		await db.pexpireAt(`invitation:email:${email}`, Date.now() + expireIn);

		const username = await User.getUserField(uid, 'username');
		const title = meta.config.title || meta.config.browserTitle || 'NodeBB';
		const subject = await translator.translate(`[[email:invite, ${title}]]`, meta.config.defaultLang);

		return {
			...emailer._defaultPayload, // Append default data to this email payload
			site_title: title,
			registerLink: registerLink,
			subject: subject,
			username: username,
			template: 'invitation',
			expireDays: expireDays,
		};
	}
'use strict';

const winston = require('winston');
const nconf = require('nconf');

const db = require('../database');
const batch = require('../batch');
const meta = require('../meta');
const user = require('./index');
const topics = require('../topics');
const plugins = require('../plugins');
const emailer = require('../emailer');
const utils = require('../utils');

const Digest = module.exports;

const baseUrl = nconf.get('base_url');

Digest.execute = async function (payload) {
	const digestsDisabled = meta.config.disableEmailSubscriptions === 1;
	if (digestsDisabled) {
		winston.info(`[user/jobs] Did not send digests (${payload.interval}) because subscription system is disabled.`);
		return;
	}
	let { subscribers } = payload;
	if (!subscribers) {
		subscribers = await Digest.getSubscribers(payload.interval);
	}
	if (!subscribers.length) {
		return;
	}
	try {
		winston.info(`[user/jobs] Digest (${payload.interval}) scheduling completed (${subscribers.length} subscribers). Sending emails; this may take some time...`);
		await Digest.send({
			interval: payload.interval,
			subscribers: subscribers,
		});
		winston.info(`[user/jobs] Digest (${payload.interval}) complete.`);
	} catch (err) {
		winston.error(`[user/jobs] Could not send digests (${payload.interval})\n${err.stack}`);
		throw err;
	}
};

Digest.getUsersInterval = async (uids) => {
	// Checks whether user specifies digest setting, or null/false for system default setting
	let single = false;
	if (!Array.isArray(uids) && !isNaN(parseInt(uids, 10))) {
		uids = [uids];
		single = true;
	}

	const settings = await Promise.all([
		db.isSortedSetMembers('digest:day:uids', uids),
		db.isSortedSetMembers('digest:week:uids', uids),
		db.isSortedSetMembers('digest:month:uids', uids),
	]);

	const interval = uids.map((uid, index) => {
		if (settings[0][index]) {
			return 'day';
		} else if (settings[1][index]) {
			return 'week';
		} else if (settings[2][index]) {
			return 'month';
		}
		return false;
	});

	return single ? interval[0] : interval;
};

Digest.getSubscribers = async function (interval) {
	let subscribers = [];

	await batch.processSortedSet('users:joindate', async (uids) => {
		const settings = await user.getMultipleUserSettings(uids);
		let subUids = [];
		settings.forEach((hash) => {
			if (hash.dailyDigestFreq === interval) {
				subUids.push(hash.uid);
			}
		});
		subUids = await user.bans.filterBanned(subUids);
		subscribers = subscribers.concat(subUids);
	}, {
		interval: 1000,
		batch: 500,
	});

	const results = await plugins.hooks.fire('filter:digest.subscribers', {
		interval: interval,
		subscribers: subscribers,
	});
	return results.subscribers;
};

Digest.send = async function (data) {
	let emailsSent = 0;
	if (!data || !data.subscribers || !data.subscribers.length) {
		return emailsSent;
	}

	await batch.processArray(data.subscribers, async (uids) => {
		let userData = await user.getUsersFields(uids, ['uid', 'email', 'email:confirmed', 'username', 'userslug', 'lastonline']);
		userData = userData.filter(u => u && u.email && (!meta.config.requireEmailConfirmation || u['email:confirmed']));
		if (!userData.length) {
			return;
		}
		await Promise.all(userData.map(async (userObj) => {
			const [notifications, topics] = await Promise.all([
				user.notifications.getUnreadInterval(userObj.uid, data.interval),
				getTermTopics(data.interval, userObj.uid),
			]);
			const unreadNotifs = notifications.filter(Boolean);
			// If there are no notifications and no new topics, don't bother sending a digest
			if (!unreadNotifs.length && !topics.top.length && !topics.popular.length && !topics.recent.length) {
				return;
			}

			unreadNotifs.forEach((n) => {
				if (n.image && !n.image.startsWith('http')) {
					n.image = baseUrl + n.image;
				}
				if (n.path) {
					n.notification_url = n.path.startsWith('http') ? n.path : baseUrl + n.path;
				}
			});

			emailsSent += 1;
			const now = new Date();
			await emailer.send('digest', userObj.uid, {
				subject: `[[email:digest.subject, ${now.getFullYear()}/${now.getMonth() + 1}/${now.getDate()}]]`,
				username: userObj.username,
				userslug: userObj.userslug,
				notifications: unreadNotifs,
				recent: topics.recent,
				topTopics: topics.top,
				popularTopics: topics.popular,
				interval: data.interval,
				showUnsubscribe: true,
			}).catch(err => winston.error(`[user/jobs] Could not send digest email\n[emailer.send] ${err.stack}`));
		}));
		if (data.interval !== 'alltime') {
			const now = Date.now();
			await db.sortedSetAdd('digest:delivery', userData.map(() => now), userData.map(u => u.uid));
		}
	}, {
		interval: 1000,
		batch: 100,
	});
	winston.info(`[user/jobs] Digest (${data.interval}) sending completed. ${emailsSent} emails sent.`);
};

Digest.getDeliveryTimes = async (start, stop) => {
	const count = await db.sortedSetCard('users:joindate');
	const uids = await user.getUidsFromSet('users:joindate', start, stop);
	if (!uids) {
		return [];
	}

	// Grab the last time a digest was successfully delivered to these uids
	const scores = await db.sortedSetScores('digest:delivery', uids);

	// Get users' digest settings
	const settings = await Digest.getUsersInterval(uids);

	// Populate user data
	let userData = await user.getUsersFields(uids, ['username', 'picture']);
	userData = userData.map((user, idx) => {
		user.lastDelivery = scores[idx] ? new Date(scores[idx]).toISOString() : '[[admin/manage/digest:null]]';
		user.setting = settings[idx];
		return user;
	});

	return {
		users: userData,
		count: count,
	};
};

async function getTermTopics(term, uid) {
	const data = await topics.getSortedTopics({
		uid: uid,
		start: 0,
		stop: 199,
		term: term,
		sort: 'votes',
		teaserPost: 'first',
	});
	data.topics = data.topics.filter(topic => topic && !topic.deleted);

	const top = data.topics.filter(t => t.votes > 0).slice(0, 10);
	const topTids = top.map(t => t.tid);

	const popular = data.topics
		.filter(t => t.postcount > 1 && !topTids.includes(t.tid))
		.sort((a, b) => b.postcount - a.postcount)
		.slice(0, 10);
	const popularTids = popular.map(t => t.tid);

	const recent = data.topics
		.filter(t => !topTids.includes(t.tid) && !popularTids.includes(t.tid))
		.sort((a, b) => b.lastposttime - a.lastposttime)
		.slice(0, 10);

	[...top, ...popular, ...recent].forEach((topicObj) => {
		if (topicObj) {
			if (topicObj.teaser && topicObj.teaser.content && topicObj.teaser.content.length > 255) {
				topicObj.teaser.content = `${topicObj.teaser.content.slice(0, 255)}...`;
			}
			// Fix relative paths in topic data
			const user = topicObj.hasOwnProperty('teaser') && topicObj.teaser && topicObj.teaser.user ?
				topicObj.teaser.user : topicObj.user;
			if (user && user.picture && utils.isRelativeUrl(user.picture)) {
				user.picture = baseUrl + user.picture;
			}
		}
	});
	return { top, popular, recent };
'use strict';

const async = require('async');
const LRU = require('lru-cache');

const db = require('../database');
const pubsub = require('../pubsub');
const plugins = require('../plugins');

module.exports = function (User) {
	User.blocks = {
		_cache: new LRU({
			max: 100,
			length: function () { return 1; },
			maxAge: 0,
		}),
	};

	User.blocks.is = async function (targetUid, uid) {
		const blocks = await User.blocks.list(uid);
		return blocks.includes(parseInt(targetUid, 10));
	};

	User.blocks.can = async function (callerUid, blockerUid, blockeeUid) {
		// Guests can't block
		if (blockerUid === 0 || blockeeUid === 0) {
			throw new Error('[[error:cannot-block-guest]]');
		} else if (blockerUid === blockeeUid) {
			throw new Error('[[error:cannot-block-self]]');
		}

		// Administrators and global moderators cannot be blocked
		// Only admins/mods can block users as another user
		const [isCallerAdminOrMod, isBlockeeAdminOrMod] = await Promise.all([
			User.isAdminOrGlobalMod(callerUid),
			User.isAdminOrGlobalMod(blockeeUid),
		]);
		if (isBlockeeAdminOrMod) {
			throw new Error('[[error:cannot-block-privileged]]');
		}
		if (parseInt(callerUid, 10) !== parseInt(blockerUid, 10) && !isCallerAdminOrMod) {
			throw new Error('[[error:no-privileges]]');
		}
	};

	User.blocks.list = async function (uid) {
		if (User.blocks._cache.has(parseInt(uid, 10))) {
			return User.blocks._cache.get(parseInt(uid, 10));
		}

		let blocked = await db.getSortedSetRange(`uid:${uid}:blocked_uids`, 0, -1);
		blocked = blocked.map(uid => parseInt(uid, 10)).filter(Boolean);
		User.blocks._cache.set(parseInt(uid, 10), blocked);
		return blocked;
	};

	pubsub.on('user:blocks:cache:del', (uid) => {
		User.blocks._cache.del(uid);
	});

	User.blocks.add = async function (targetUid, uid) {
		await User.blocks.applyChecks('block', targetUid, uid);
		await db.sortedSetAdd(`uid:${uid}:blocked_uids`, Date.now(), targetUid);
		await User.incrementUserFieldBy(uid, 'blocksCount', 1);
		User.blocks._cache.del(parseInt(uid, 10));
		pubsub.publish('user:blocks:cache:del', parseInt(uid, 10));
		plugins.hooks.fire('action:user.blocks.add', { uid: uid, targetUid: targetUid });
	};

	User.blocks.remove = async function (targetUid, uid) {
		await User.blocks.applyChecks('unblock', targetUid, uid);
		await db.sortedSetRemove(`uid:${uid}:blocked_uids`, targetUid);
		await User.decrementUserFieldBy(uid, 'blocksCount', 1);
		User.blocks._cache.del(parseInt(uid, 10));
		pubsub.publish('user:blocks:cache:del', parseInt(uid, 10));
		plugins.hooks.fire('action:user.blocks.remove', { uid: uid, targetUid: targetUid });
	};

	User.blocks.applyChecks = async function (type, targetUid, uid) {
		await User.blocks.can(uid, uid, targetUid);
		const isBlock = type === 'block';
		const is = await User.blocks.is(targetUid, uid);
		if (is === isBlock) {
			throw new Error(`[[error:already-${isBlock ? 'blocked' : 'unblocked'}]]`);
		}
	};

	User.blocks.filterUids = async function (targetUid, uids) {
		return await async.filter(uids, async (uid) => {
			const isBlocked = await User.blocks.is(targetUid, uid);
			return !isBlocked;
		});
	};

	User.blocks.filter = async function (uid, property, set) {
		// Given whatever is passed in, iterates through it, and removes entries made by blocked uids
		// property is optional
		if (Array.isArray(property) && typeof set === 'undefined') {
			set = property;
			property = 'uid';
		}

		if (!Array.isArray(set) || !set.length) {
			return set;
		}

		const isPlain = typeof set[0] !== 'object';
		const blocked_uids = await User.blocks.list(uid);
		const blockedSet = new Set(blocked_uids);

		set = set.filter(item => !blockedSet.has(parseInt(isPlain ? item : (item && item[property]), 10)));
		const data = await plugins.hooks.fire('filter:user.blocks.filter', { set: set, property: property, uid: uid, blockedSet: blockedSet });

		return data.set;
	};
'use strict';

const validator = require('validator');
const nconf = require('nconf');
const _ = require('lodash');

const db = require('../database');
const meta = require('../meta');
const plugins = require('../plugins');
const utils = require('../utils');

const relative_path = nconf.get('relative_path');

const intFields = [
	'uid', 'postcount', 'topiccount', 'reputation', 'profileviews',
	'banned', 'banned:expire', 'email:confirmed', 'joindate', 'lastonline',
	'lastqueuetime', 'lastposttime', 'followingCount', 'followerCount',
	'blocksCount', 'passwordExpiry',
];

module.exports = function (User) {
	const fieldWhitelist = [
		'uid', 'username', 'userslug', 'email', 'email:confirmed', 'joindate',
		'lastonline', 'picture', 'icon:bgColor', 'fullname', 'location', 'birthday', 'website',
		'aboutme', 'signature', 'uploadedpicture', 'profileviews', 'reputation',
		'postcount', 'topiccount', 'lastposttime', 'banned', 'banned:expire',
		'status', 'flags', 'followerCount', 'followingCount', 'cover:url',
		'cover:position', 'groupTitle',
	];

	User.guestData = {
		uid: 0,
		username: '[[global:guest]]',
		displayname: '[[global:guest]]',
		userslug: '',
		fullname: '[[global:guest]]',
		email: '',
		'icon:text': '?',
		'icon:bgColor': '#aaa',
		groupTitle: '',
		groupTitleArray: [],
		status: 'offline',
		reputation: 0,
		'email:confirmed': 0,
	};

	User.getUsersFields = async function (uids, fields) {
		if (!Array.isArray(uids) || !uids.length) {
			return [];
		}

		uids = uids.map(uid => (isNaN(uid) ? 0 : parseInt(uid, 10)));

		const fieldsToRemove = [];
		ensureRequiredFields(fields, fieldsToRemove);

		const uniqueUids = _.uniq(uids).filter(uid => uid > 0);

		const results = await plugins.hooks.fire('filter:user.whitelistFields', { uids: uids, whitelist: fieldWhitelist.slice() });
		if (!fields.length) {
			fields = results.whitelist;
		} else {
			// Never allow password retrieval via this method
			fields = fields.filter(value => value !== 'password');
		}

		const users = await db.getObjectsFields(uniqueUids.map(uid => `user:${uid}`), fields);
		const result = await plugins.hooks.fire('filter:user.getFields', {
			uids: uniqueUids,
			users: users,
			fields: fields,
		});
		result.users.forEach((user, index) => {
			if (uniqueUids[index] > 0 && !user.uid) {
				user.oldUid = uniqueUids[index];
			}
		});
		await modifyUserData(result.users, fields, fieldsToRemove);
		return uidsToUsers(uids, uniqueUids, result.users);
	};

	function ensureRequiredFields(fields, fieldsToRemove) {
		function addField(field) {
			if (!fields.includes(field)) {
				fields.push(field);
				fieldsToRemove.push(field);
			}
		}

		if (fields.length && !fields.includes('uid')) {
			fields.push('uid');
		}

		if (fields.includes('picture')) {
			addField('uploadedpicture');
		}

		if (fields.includes('status')) {
			addField('lastonline');
		}

		if (fields.includes('banned') && !fields.includes('banned:expire')) {
			addField('banned:expire');
		}

		if (fields.includes('username') && !fields.includes('fullname')) {
			addField('fullname');
		}
	}

	function uidsToUsers(uids, uniqueUids, usersData) {
		const uidToUser = _.zipObject(uniqueUids, usersData);
		const users = uids.map((uid) => {
			const user = uidToUser[uid] || { ...User.guestData };
			if (!parseInt(user.uid, 10)) {
				user.username = (user.hasOwnProperty('oldUid') && parseInt(user.oldUid, 10)) ? '[[global:former_user]]' : '[[global:guest]]';
				user.displayname = user.username;
			}

			return user;
		});
		return users;
	}

	User.getUserField = async function (uid, field) {
		const user = await User.getUserFields(uid, [field]);
		return user ? user[field] : null;
	};

	User.getUserFields = async function (uid, fields) {
		const users = await User.getUsersFields([uid], fields);
		return users ? users[0] : null;
	};

	User.getUserData = async function (uid) {
		const users = await User.getUsersData([uid]);
		return users ? users[0] : null;
	};

	User.getUsersData = async function (uids) {
		return await User.getUsersFields(uids, []);
	};

	async function modifyUserData(users, requestedFields, fieldsToRemove) {
		let uidToSettings = {};
		if (meta.config.showFullnameAsDisplayName) {
			const uids = users.map(user => user.uid);
			uidToSettings = _.zipObject(uids, await db.getObjectsFields(
				uids.map(uid => `user:${uid}:settings`),
				['showfullname']
			));
		}

		await Promise.all(users.map(async (user) => {
			if (!user) {
				return;
			}

			db.parseIntFields(user, intFields, requestedFields);

			if (user.hasOwnProperty('username')) {
				parseDisplayName(user, uidToSettings);
				user.username = validator.escape(user.username ? user.username.toString() : '');
			}

			if (user.hasOwnProperty('email')) {
				user.email = validator.escape(user.email ? user.email.toString() : '');
			}

			if (!parseInt(user.uid, 10)) {
				for (const [key, value] of Object.entries(User.guestData)) {
					user[key] = value;
				}
				user.picture = User.getDefaultAvatar();
			}

			if (user.hasOwnProperty('groupTitle')) {
				parseGroupTitle(user);
			}

			if (user.picture && user.picture === user.uploadedpicture) {
				user.uploadedpicture = user.picture.startsWith('http') ? user.picture : relative_path + user.picture;
				user.picture = user.uploadedpicture;
			} else if (user.uploadedpicture) {
				user.uploadedpicture = user.uploadedpicture.startsWith('http') ? user.uploadedpicture : relative_path + user.uploadedpicture;
			}
			if (meta.config.defaultAvatar && !user.picture) {
				user.picture = User.getDefaultAvatar();
			}

			if (user.hasOwnProperty('status') && user.hasOwnProperty('lastonline')) {
				user.status = User.getStatus(user);
			}

			for (let i = 0; i < fieldsToRemove.length; i += 1) {
				user[fieldsToRemove[i]] = undefined;
			}

			// User Icons
			if (requestedFields.includes('picture') && user.username && parseInt(user.uid, 10) && !meta.config.defaultAvatar) {
				const iconBackgrounds = await User.getIconBackgrounds(user.uid);
				let bgColor = await User.getUserField(user.uid, 'icon:bgColor');
				if (!iconBackgrounds.includes(bgColor)) {
					bgColor = Array.prototype.reduce.call(user.username, (cur, next) => cur + next.charCodeAt(), 0);
					bgColor = iconBackgrounds[bgColor % iconBackgrounds.length];
				}
				user['icon:text'] = (user.username[0] || '').toUpperCase();
				user['icon:bgColor'] = bgColor;
			}

			if (user.hasOwnProperty('joindate')) {
				user.joindateISO = utils.toISOString(user.joindate);
			}

			if (user.hasOwnProperty('lastonline')) {
				user.lastonlineISO = utils.toISOString(user.lastonline) || user.joindateISO;
			}

			if (user.hasOwnProperty('banned') || user.hasOwnProperty('banned:expire')) {
				const result = await User.bans.calcExpiredFromUserData(user);
				user.banned = result.banned;
				const unban = result.banned && result.banExpired;
				user.banned_until = unban ? 0 : user['banned:expire'];
				user.banned_until_readable = user.banned_until && !unban ? utils.toISOString(user.banned_until) : 'Not Banned';
				if (unban) {
					await User.bans.unban(user.uid);
					user.banned = false;
				}
			}
		}));

		return await plugins.hooks.fire('filter:users.get', users);
	}

	function parseDisplayName(user, uidToSettings) {
		let showfullname = parseInt(meta.config.showfullname, 10) === 1;
		if (uidToSettings[user.uid]) {
			if (parseInt(uidToSettings[user.uid].showfullname, 10) === 0) {
				showfullname = false;
			} else if (parseInt(uidToSettings[user.uid].showfullname, 10) === 1) {
				showfullname = true;
			}
		}

		user.displayname = validator.escape(String(
			meta.config.showFullnameAsDisplayName && showfullname && user.fullname ?
				user.fullname :
				user.username
		));
	}

	function parseGroupTitle(user) {
		try {
			user.groupTitleArray = JSON.parse(user.groupTitle);
		} catch (err) {
			if (user.groupTitle) {
				user.groupTitleArray = [user.groupTitle];
			} else {
				user.groupTitle = '';
				user.groupTitleArray = [];
			}
		}
		if (!Array.isArray(user.groupTitleArray)) {
			if (user.groupTitleArray) {
				user.groupTitleArray = [user.groupTitleArray];
			} else {
				user.groupTitleArray = [];
			}
		}
		if (!meta.config.allowMultipleBadges && user.groupTitleArray.length) {
			user.groupTitleArray = [user.groupTitleArray[0]];
		}
	}

	User.getIconBackgrounds = async (uid = 0) => {
		let iconBackgrounds = [
			'#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3',
			'#009688', '#1b5e20', '#33691e', '#827717', '#e65100', '#ff5722',
			'#795548', '#607d8b',
		];

		({ iconBackgrounds } = await plugins.hooks.fire('filter:user.iconBackgrounds', { uid, iconBackgrounds }));
		return iconBackgrounds;
	};

	User.getDefaultAvatar = function () {
		if (!meta.config.defaultAvatar) {
			return '';
		}
		return meta.config.defaultAvatar.startsWith('http') ? meta.config.defaultAvatar : relative_path + meta.config.defaultAvatar;
	};

	User.setUserField = async function (uid, field, value) {
		await User.setUserFields(uid, { [field]: value });
	};

	User.setUserFields = async function (uid, data) {
		await db.setObject(`user:${uid}`, data);
		for (const [field, value] of Object.entries(data)) {
			plugins.hooks.fire('action:user.set', { uid, field, value, type: 'set' });
		}
	};

	User.incrementUserFieldBy = async function (uid, field, value) {
		return await incrDecrUserFieldBy(uid, field, value, 'increment');
	};

	User.decrementUserFieldBy = async function (uid, field, value) {
		return await incrDecrUserFieldBy(uid, field, -value, 'decrement');
	};

	async function incrDecrUserFieldBy(uid, field, value, type) {
		const newValue = await db.incrObjectFieldBy(`user:${uid}`, field, value);
		plugins.hooks.fire('action:user.set', { uid: uid, field: field, value: newValue, type: type });
		return newValue;
'use strict';

const async = require('async');
const _ = require('lodash');
const path = require('path');
const nconf = require('nconf');

const db = require('../database');
const posts = require('../posts');
const flags = require('../flags');
const topics = require('../topics');
const groups = require('../groups');
const messaging = require('../messaging');
const plugins = require('../plugins');
const batch = require('../batch');
const file = require('../file');

module.exports = function (User) {
	const deletesInProgress = {};

	User.delete = async (callerUid, uid) => {
		await User.deleteContent(callerUid, uid);
		await removeFromSortedSets(uid);
		return await User.deleteAccount(uid);
	};

	User.deleteContent = async function (callerUid, uid) {
		if (parseInt(uid, 10) <= 0) {
			throw new Error('[[error:invalid-uid]]');
		}
		if (deletesInProgress[uid]) {
			throw new Error('[[error:already-deleting]]');
		}
		deletesInProgress[uid] = 'user.delete';
		await deletePosts(callerUid, uid);
		await deleteTopics(callerUid, uid);
		await deleteUploads(uid);
		await deleteQueued(uid);
		delete deletesInProgress[uid];
	};

	async function deletePosts(callerUid, uid) {
		await batch.processSortedSet(`uid:${uid}:posts`, async (ids) => {
			await async.eachSeries(ids, async (pid) => {
				await posts.purge(pid, callerUid);
			});
		}, { alwaysStartAt: 0 });
	}

	async function deleteTopics(callerUid, uid) {
		await batch.processSortedSet(`uid:${uid}:topics`, async (ids) => {
			await async.eachSeries(ids, async (tid) => {
				await topics.purge(tid, callerUid);
			});
		}, { alwaysStartAt: 0 });
	}

	async function deleteUploads(uid) {
		await batch.processSortedSet(`uid:${uid}:uploads`, async (uploadNames) => {
			await async.each(uploadNames, async (uploadName) => {
				await file.delete(path.join(nconf.get('upload_path'), uploadName));
			});
			await db.sortedSetRemove(`uid:${uid}:uploads`, uploadNames);
		}, { alwaysStartAt: 0 });
	}

	async function deleteQueued(uid) {
		let deleteIds = [];
		await batch.processSortedSet('post:queue', async (ids) => {
			const data = await db.getObjects(ids.map(id => `post:queue:${id}`));
			const userQueuedIds = data.filter(d => parseInt(d.uid, 10) === parseInt(uid, 10)).map(d => d.id);
			deleteIds = deleteIds.concat(userQueuedIds);
		}, { batch: 500 });
		await async.eachSeries(deleteIds, posts.removeFromQueue);
	}

	async function removeFromSortedSets(uid) {
		await db.sortedSetsRemove([
			'users:joindate',
			'users:postcount',
			'users:reputation',
			'users:banned',
			'users:banned:expire',
			'users:flags',
			'users:online',
			'digest:day:uids',
			'digest:week:uids',
			'digest:month:uids',
		], uid);
	}

	User.deleteAccount = async function (uid) {
		if (deletesInProgress[uid] === 'user.deleteAccount') {
			throw new Error('[[error:already-deleting]]');
		}
		deletesInProgress[uid] = 'user.deleteAccount';

		await removeFromSortedSets(uid);
		const userData = await db.getObject(`user:${uid}`);

		if (!userData || !userData.username) {
			delete deletesInProgress[uid];
			throw new Error('[[error:no-user]]');
		}

		await plugins.hooks.fire('static:user.delete', { uid: uid });
		await deleteVotes(uid);
		await deleteChats(uid);
		await User.auth.revokeAllSessions(uid);

		const keys = [
			`uid:${uid}:notifications:read`,
			`uid:${uid}:notifications:unread`,
			`uid:${uid}:bookmarks`,
			`uid:${uid}:followed_tids`,
			`uid:${uid}:ignored_tids`,
			`user:${uid}:settings`,
			`user:${uid}:usernames`,
			`user:${uid}:emails`,
			`uid:${uid}:topics`, `uid:${uid}:posts`,
			`uid:${uid}:chats`, `uid:${uid}:chats:unread`,
			`uid:${uid}:chat:rooms`, `uid:${uid}:chat:rooms:unread`,
			`uid:${uid}:upvote`, `uid:${uid}:downvote`,
			`uid:${uid}:flag:pids`,
			`uid:${uid}:sessions`, `uid:${uid}:sessionUUID:sessionId`,
			`invitation:uid:${uid}`,
		];

		const bulkRemove = [
			['username:uid', userData.username],
			['username:sorted', `${userData.username.toLowerCase()}:${uid}`],
			['userslug:uid', userData.userslug],
			['fullname:uid', userData.fullname],
		];
		if (userData.email) {
			bulkRemove.push(['email:uid', userData.email.toLowerCase()]);
			bulkRemove.push(['email:sorted', `${userData.email.toLowerCase()}:${uid}`]);
		}

		if (userData.fullname) {
			bulkRemove.push(['fullname:sorted', `${userData.fullname.toLowerCase()}:${uid}`]);
		}

		await Promise.all([
			db.sortedSetRemoveBulk(bulkRemove),
			db.decrObjectField('global', 'userCount'),
			db.deleteAll(keys),
			db.setRemove('invitation:uids', uid),
			deleteUserIps(uid),
			deleteBans(uid),
			deleteUserFromFollowers(uid),
			deleteImages(uid),
			groups.leaveAllGroups(uid),
			flags.resolveFlag('user', uid, uid),
			User.reset.cleanByUid(uid),
		]);
		await db.deleteAll([`followers:${uid}`, `following:${uid}`, `user:${uid}`]);
		delete deletesInProgress[uid];
		return userData;
	};

	async function deleteVotes(uid) {
		const [upvotedPids, downvotedPids] = await Promise.all([
			db.getSortedSetRange(`uid:${uid}:upvote`, 0, -1),
			db.getSortedSetRange(`uid:${uid}:downvote`, 0, -1),
		]);
		const pids = _.uniq(upvotedPids.concat(downvotedPids).filter(Boolean));
		await async.eachSeries(pids, async (pid) => {
			await posts.unvote(pid, uid);
		});
	}

	async function deleteChats(uid) {
		const roomIds = await db.getSortedSetRange(`uid:${uid}:chat:rooms`, 0, -1);
		const userKeys = roomIds.map(roomId => `uid:${uid}:chat:room:${roomId}:mids`);

		await Promise.all([
			messaging.leaveRooms(uid, roomIds),
			db.deleteAll(userKeys),
		]);
	}

	async function deleteUserIps(uid) {
		const ips = await db.getSortedSetRange(`uid:${uid}:ip`, 0, -1);
		await db.sortedSetsRemove(ips.map(ip => `ip:${ip}:uid`), uid);
		await db.delete(`uid:${uid}:ip`);
	}

	async function deleteBans(uid) {
		const bans = await db.getSortedSetRange(`uid:${uid}:bans:timestamp`, 0, -1);
		await db.deleteAll(bans);
		await db.delete(`uid:${uid}:bans:timestamp`);
	}

	async function deleteUserFromFollowers(uid) {
		const [followers, following] = await Promise.all([
			db.getSortedSetRange(`followers:${uid}`, 0, -1),
			db.getSortedSetRange(`following:${uid}`, 0, -1),
		]);

		async function updateCount(uids, name, fieldName) {
			await async.each(uids, async (uid) => {
				let count = await db.sortedSetCard(name + uid);
				count = parseInt(count, 10) || 0;
				await db.setObjectField(`user:${uid}`, fieldName, count);
			});
		}

		const followingSets = followers.map(uid => `following:${uid}`);
		const followerSets = following.map(uid => `followers:${uid}`);

		await Promise.all([
			db.sortedSetsRemove(followerSets.concat(followingSets), uid),
			updateCount(following, 'followers:', 'followerCount'),
			updateCount(followers, 'following:', 'followingCount'),
		]);
	}

	async function deleteImages(uid) {
		const extensions = User.getAllowedProfileImageExtensions();
		const folder = path.join(nconf.get('upload_path'), 'profile');
		await Promise.all(extensions.map(async (ext) => {
			await file.delete(path.join(folder, `${uid}-profilecover.${ext}`));
			await file.delete(path.join(folder, `${uid}-profileavatar.${ext}`));
		}));
'use strict';

const nconf = require('nconf');
const winston = require('winston');

const user = require('./index');
const groups = require('../groups');
const utils = require('../utils');
const batch = require('../batch');

const db = require('../database');
const meta = require('../meta');
const emailer = require('../emailer');
const Password = require('../password');

const UserReset = module.exports;

const twoHours = 7200000;

UserReset.validate = async function (code) {
	const uid = await db.getObjectField('reset:uid', code);
	if (!uid) {
		return false;
	}
	const issueDate = await db.sortedSetScore('reset:issueDate', code);
	return parseInt(issueDate, 10) > Date.now() - twoHours;
};

UserReset.generate = async function (uid) {
	const code = utils.generateUUID();
	await Promise.all([
		db.setObjectField('reset:uid', code, uid),
		db.sortedSetAdd('reset:issueDate', Date.now(), code),
	]);
	return code;
};

async function canGenerate(uid) {
	const score = await db.sortedSetScore('reset:issueDate:uid', uid);
	if (score > Date.now() - (1000 * 60)) {
		throw new Error('[[error:reset-rate-limited]]');
	}
}

UserReset.send = async function (email) {
	const uid = await user.getUidByEmail(email);
	if (!uid) {
		throw new Error('[[error:invalid-email]]');
	}
	await canGenerate(uid);
	await db.sortedSetAdd('reset:issueDate:uid', Date.now(), uid);
	const code = await UserReset.generate(uid);
	await emailer.send('reset', uid, {
		reset_link: `${nconf.get('url')}/reset/${code}`,
		subject: '[[email:password-reset-requested]]',
		template: 'reset',
		uid: uid,
	}).catch(err => winston.error(`[emailer.send] ${err.stack}`));
};

UserReset.commit = async function (code, password) {
	user.isPasswordValid(password);
	const validated = await UserReset.validate(code);
	if (!validated) {
		throw new Error('[[error:reset-code-not-valid]]');
	}
	const uid = await db.getObjectField('reset:uid', code);
	if (!uid) {
		throw new Error('[[error:reset-code-not-valid]]');
	}
	const userData = await db.getObjectFields(
		`user:${uid}`,
		['password', 'passwordExpiry', 'password:shaWrapped']
	);
	const ok = await Password.compare(password, userData.password, !!parseInt(userData['password:shaWrapped'], 10));
	if (ok) {
		throw new Error('[[error:reset-same-password]]');
	}
	const hash = await user.hashPassword(password);
	const data = {
		password: hash,
		'password:shaWrapped': 1,
	};

	// don't verify email if password reset is due to expiry
	const isPasswordExpired = userData.passwordExpiry && userData.passwordExpiry < Date.now();
	if (!isPasswordExpired) {
		data['email:confirmed']	= 1;
		await groups.join('verified-users', uid);
		await groups.leave('unverified-users', uid);
	}
	await user.setUserFields(uid, data);
	await db.deleteObjectField('reset:uid', code);
	await db.sortedSetRemoveBulk([
		['reset:issueDate', code],
		['reset:issueDate:uid', uid],
	]);
	await user.reset.updateExpiry(uid);
	await user.auth.resetLockout(uid);
	await db.delete(`uid:${uid}:confirm:email:sent`);
	await UserReset.cleanByUid(uid);
};

UserReset.updateExpiry = async function (uid) {
	const expireDays = meta.config.passwordExpiryDays;
	if (expireDays > 0) {
		const oneDay = 1000 * 60 * 60 * 24;
		const expiry = Date.now() + (oneDay * expireDays);
		await user.setUserField(uid, 'passwordExpiry', expiry);
	} else {
		await db.deleteObjectField(`user:${uid}`, 'passwordExpiry');
	}
};

UserReset.clean = async function () {
	const [tokens, uids] = await Promise.all([
		db.getSortedSetRangeByScore('reset:issueDate', 0, -1, '-inf', Date.now() - twoHours),
		db.getSortedSetRangeByScore('reset:issueDate:uid', 0, -1, '-inf', Date.now() - twoHours),
	]);
	if (!tokens.length && !uids.length) {
		return;
	}

	winston.verbose(`[UserReset.clean] Removing ${tokens.length} reset tokens from database`);
	await cleanTokensAndUids(tokens, uids);
};

UserReset.cleanByUid = async function (uid) {
	const tokensToClean = [];
	uid = parseInt(uid, 10);

	await batch.processSortedSet('reset:issueDate', async (tokens) => {
		const results = await db.getObjectFields('reset:uid', tokens);
		for (const [code, result] of Object.entries(results)) {
			if (parseInt(result, 10) === uid) {
				tokensToClean.push(code);
			}
		}
	}, { batch: 500 });

	if (!tokensToClean.length) {
		winston.verbose(`[UserReset.cleanByUid] No tokens found for uid (${uid}).`);
		return;
	}

	winston.verbose(`[UserReset.cleanByUid] Found ${tokensToClean.length} token(s), removing...`);
	await cleanTokensAndUids(tokensToClean, uid);
};

async function cleanTokensAndUids(tokens, uids) {
	await Promise.all([
		db.deleteObjectFields('reset:uid', tokens),
		db.sortedSetRemove('reset:issueDate', tokens),
		db.sortedSetRemove('reset:issueDate:uid', uids),
	]);
'use strict';

const winston = require('winston');
const validator = require('validator');
const util = require('util');
const _ = require('lodash');
const db = require('../database');
const meta = require('../meta');
const events = require('../events');
const batch = require('../batch');
const utils = require('../utils');

module.exports = function (User) {
	User.auth = {};

	User.auth.logAttempt = async function (uid, ip) {
		if (!(parseInt(uid, 10) > 0)) {
			return;
		}
		const exists = await db.exists(`lockout:${uid}`);
		if (exists) {
			throw new Error('[[error:account-locked]]');
		}
		const attempts = await db.increment(`loginAttempts:${uid}`);
		if (attempts <= meta.config.loginAttempts) {
			return await db.pexpire(`loginAttempts:${uid}`, 1000 * 60 * 60);
		}
		// Lock out the account
		await db.set(`lockout:${uid}`, '');
		const duration = 1000 * 60 * meta.config.lockoutDuration;

		await db.delete(`loginAttempts:${uid}`);
		await db.pexpire(`lockout:${uid}`, duration);
		await events.log({
			type: 'account-locked',
			uid: uid,
			ip: ip,
		});
		throw new Error('[[error:account-locked]]');
	};

	User.auth.getFeedToken = async function (uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return;
		}
		const _token = await db.getObjectField(`user:${uid}`, 'rss_token');
		const token = _token || utils.generateUUID();
		if (!_token) {
			await User.setUserField(uid, 'rss_token', token);
		}
		return token;
	};

	User.auth.clearLoginAttempts = async function (uid) {
		await db.delete(`loginAttempts:${uid}`);
	};

	User.auth.resetLockout = async function (uid) {
		await db.deleteAll([
			`loginAttempts:${uid}`,
			`lockout:${uid}`,
		]);
	};

	const getSessionFromStore = util.promisify(
		(sid, callback) => db.sessionStore.get(sid, (err, sessObj) => callback(err, sessObj || null))
	);
	const sessionStoreDestroy = util.promisify(
		(sid, callback) => db.sessionStore.destroy(sid, err => callback(err))
	);

	User.auth.getSessions = async function (uid, curSessionId) {
		await cleanExpiredSessions(uid);
		const sids = await db.getSortedSetRevRange(`uid:${uid}:sessions`, 0, 19);
		let sessions = await Promise.all(sids.map(sid => getSessionFromStore(sid)));
		sessions = sessions.map((sessObj, idx) => {
			if (sessObj && sessObj.meta) {
				sessObj.meta.current = curSessionId === sids[idx];
				sessObj.meta.datetimeISO = new Date(sessObj.meta.datetime).toISOString();
				sessObj.meta.ip = validator.escape(String(sessObj.meta.ip));
			}
			return sessObj && sessObj.meta;
		}).filter(Boolean);
		return sessions;
	};

	async function cleanExpiredSessions(uid) {
		const uuidMapping = await db.getObject(`uid:${uid}:sessionUUID:sessionId`);
		if (!uuidMapping) {
			return;
		}
		const expiredUUIDs = [];
		const expiredSids = [];
		await Promise.all(Object.keys(uuidMapping).map(async (uuid) => {
			const sid = uuidMapping[uuid];
			const sessionObj = await getSessionFromStore(sid);
			const expired = !sessionObj || !sessionObj.hasOwnProperty('passport') ||
				!sessionObj.passport.hasOwnProperty('user')	||
				parseInt(sessionObj.passport.user, 10) !== parseInt(uid, 10);
			if (expired) {
				expiredUUIDs.push(uuid);
				expiredSids.push(sid);
			}
		}));
		await db.deleteObjectFields(`uid:${uid}:sessionUUID:sessionId`, expiredUUIDs);
		await db.sortedSetRemove(`uid:${uid}:sessions`, expiredSids);
	}

	User.auth.addSession = async function (uid, sessionId) {
		if (!(parseInt(uid, 10) > 0)) {
			return;
		}
		await cleanExpiredSessions(uid);
		await db.sortedSetAdd(`uid:${uid}:sessions`, Date.now(), sessionId);
		await revokeSessionsAboveThreshold(uid, meta.config.maxUserSessions);
	};

	async function revokeSessionsAboveThreshold(uid, maxUserSessions) {
		const activeSessions = await db.getSortedSetRange(`uid:${uid}:sessions`, 0, -1);
		if (activeSessions.length > maxUserSessions) {
			const sessionsToRevoke = activeSessions.slice(0, activeSessions.length - maxUserSessions);
			await Promise.all(sessionsToRevoke.map(sessionId => User.auth.revokeSession(sessionId, uid)));
		}
	}

	User.auth.revokeSession = async function (sessionId, uid) {
		winston.verbose(`[user.auth] Revoking session ${sessionId} for user ${uid}`);
		const sessionObj = await getSessionFromStore(sessionId);
		if (sessionObj && sessionObj.meta && sessionObj.meta.uuid) {
			await db.deleteObjectField(`uid:${uid}:sessionUUID:sessionId`, sessionObj.meta.uuid);
		}
		await Promise.all([
			db.sortedSetRemove(`uid:${uid}:sessions`, sessionId),
			sessionStoreDestroy(sessionId),
		]);
	};

	User.auth.revokeAllSessions = async function (uids) {
		uids = Array.isArray(uids) ? uids : [uids];
		const sids = await db.getSortedSetsMembers(uids.map(uid => `uid:${uid}:sessions`));
		const promises = [];
		uids.forEach((uid, index) => {
			promises.push(sids[index].map(s => User.auth.revokeSession(s, uid)));
		});
		await Promise.all(promises);
	};

	User.auth.deleteAllSessions = async function () {
		await batch.processSortedSet('users:joindate', async (uids) => {
			const sessionKeys = uids.map(uid => `uid:${uid}:sessions`);
			const sessionUUIDKeys = uids.map(uid => `uid:${uid}:sessionUUID:sessionId`);
			const sids = _.flatten(await db.getSortedSetRange(sessionKeys, 0, -1));

			await Promise.all([
				db.deleteAll(sessionKeys.concat(sessionUUIDKeys)),
'use strict';


const nconf = require('nconf');

const db = require('../database');
const Password = require('../password');

module.exports = function (User) {
	User.hashPassword = async function (password) {
		if (!password) {
			return password;
		}

		return await Password.hash(nconf.get('bcrypt_rounds') || 12, password);
	};

	User.isPasswordCorrect = async function (uid, password, ip) {
		password = password || '';
		let {
			password: hashedPassword,
			'password:shaWrapped': shaWrapped,
		} = await db.getObjectFields(`user:${uid}`, ['password', 'password:shaWrapped']);
		if (!hashedPassword) {
			// Non-existant user, submit fake hash for comparison
			hashedPassword = '';
		}

		User.isPasswordValid(password, 0);
		await User.auth.logAttempt(uid, ip);
		const ok = await Password.compare(password, hashedPassword, !!parseInt(shaWrapped, 10));
		if (ok) {
			await User.auth.clearLoginAttempts(uid);
		}
		return ok;
	};

	User.hasPassword = async function (uid) {
		const hashedPassword = await db.getObjectField(`user:${uid}`, 'password');
		return !!hashedPassword;
'use strict';

const db = require('../database');

module.exports = function (User) {
	User.getIgnoredTids = async function (uid, start, stop) {
		return await db.getSortedSetRevRange(`uid:${uid}:ignored_tids`, start, stop);
	};

	User.addTopicIdToUser = async function (uid, tid, timestamp) {
		await Promise.all([
			db.sortedSetAdd(`uid:${uid}:topics`, timestamp, tid),
			User.incrementUserFieldBy(uid, 'topiccount', 1),
		]);
	};
'use strict';

const winston = require('winston');
const mime = require('mime');
const path = require('path');
const nconf = require('nconf');

const db = require('../database');
const file = require('../file');
const image = require('../image');
const meta = require('../meta');
const plugins = require('../plugins');

module.exports = function (User) {
	User.getAllowedProfileImageExtensions = function () {
		const exts = User.getAllowedImageTypes().map(type => mime.getExtension(type));
		if (exts.includes('jpeg')) {
			exts.push('jpg');
		}
		return exts;
	};

	User.getAllowedImageTypes = function () {
		const allowedTypes = ['image/png', 'image/jpeg', 'image/bmp'];
		if (plugins.hooks.hasListeners('filter:image.isFileTypeAllowed')) {
			allowedTypes.push('image/gif');
		}
		return allowedTypes;
	};

	User.updateCoverPosition = async function (uid, position) {
		// Reject anything that isn't two percentages
		if (!/^[\d.]+%\s[\d.]+%$/.test(position)) {
			winston.warn(`[user/updateCoverPosition] Invalid position received: ${position}`);
			throw new Error('[[error:invalid-data]]');
		}

		await User.setUserField(uid, 'cover:position', position);
	};

	User.updateCoverPicture = async function (data) {
		const picture = {
			name: 'profileCover',
			uid: data.uid,
		};

		try {
			if (!data.imageData && data.position) {
				return await User.updateCoverPosition(data.uid, data.position);
			}

			validateUpload(data, meta.config.maximumCoverImageSize, ['image/png', 'image/jpeg', 'image/bmp']);

			picture.path = await image.writeImageDataToTempFile(data.imageData);

			const extension = file.typeToExtension(image.mimeFromBase64(data.imageData));
			const filename = `${data.uid}-profilecover-${Date.now()}${extension}`;
			const uploadData = await image.uploadImage(filename, 'profile', picture);

			await deleteCurrentPicture(data.uid, 'cover:url');
			await User.setUserField(data.uid, 'cover:url', uploadData.url);

			if (data.position) {
				await User.updateCoverPosition(data.uid, data.position);
			}

			return {
				url: uploadData.url,
			};
		} finally {
			await file.delete(picture.path);
		}
	};

	// uploads a image file as profile picture
	User.uploadCroppedPictureFile = async function (data) {
		const userPhoto = data.file;
		if (!meta.config.allowProfileImageUploads) {
			throw new Error('[[error:profile-image-uploads-disabled]]');
		}

		if (userPhoto.size > meta.config.maximumProfileImageSize * 1024) {
			throw new Error(`[[error:file-too-big, ${meta.config.maximumProfileImageSize}]]`);
		}

		if (!userPhoto.type || !User.getAllowedImageTypes().includes(userPhoto.type)) {
			throw new Error('[[error:invalid-image]]');
		}

		const extension = file.typeToExtension(userPhoto.type);
		if (!extension) {
			throw new Error('[[error:invalid-image-extension]]');
		}

		const newPath = await convertToPNG(userPhoto.path);

		await image.resizeImage({
			path: newPath,
			width: meta.config.profileImageDimension,
			height: meta.config.profileImageDimension,
		});

		const filename = generateProfileImageFilename(data.uid, extension);
		const uploadedImage = await image.uploadImage(filename, 'profile', {
			uid: data.uid,
			path: newPath,
			name: 'profileAvatar',
		});

		await deleteCurrentPicture(data.uid, 'uploadedpicture');
		await User.setUserFields(data.uid, {
			uploadedpicture: uploadedImage.url,
			picture: uploadedImage.url,
		});
		return uploadedImage;
	};

	// uploads image data in base64 as profile picture
	User.uploadCroppedPicture = async function (data) {
		const picture = {
			name: 'profileAvatar',
			uid: data.uid,
		};

		try {
			if (!meta.config.allowProfileImageUploads) {
				throw new Error('[[error:profile-image-uploads-disabled]]');
			}

			validateUpload(data, meta.config.maximumProfileImageSize, User.getAllowedImageTypes());

			const extension = file.typeToExtension(image.mimeFromBase64(data.imageData));
			if (!extension) {
				throw new Error('[[error:invalid-image-extension]]');
			}

			picture.path = await image.writeImageDataToTempFile(data.imageData);
			picture.path = await convertToPNG(picture.path);

			await image.resizeImage({
				path: picture.path,
				width: meta.config.profileImageDimension,
				height: meta.config.profileImageDimension,
			});

			const filename = generateProfileImageFilename(data.uid, extension);
			const uploadedImage = await image.uploadImage(filename, 'profile', picture);

			await deleteCurrentPicture(data.uid, 'uploadedpicture');
			await User.setUserFields(data.uid, {
				uploadedpicture: uploadedImage.url,
				picture: uploadedImage.url,
			});
			return uploadedImage;
		} finally {
			await file.delete(picture.path);
		}
	};

	async function deleteCurrentPicture(uid, field) {
		if (meta.config['profile:keepAllUserImages']) {
			return;
		}
		const value = await User.getUserField(uid, field);
		if (value && value.startsWith('/assets/uploads/profile/')) {
			const filename = value.split('/').pop();
			const uploadPath = path.join(nconf.get('upload_path'), 'profile', filename);
			await file.delete(uploadPath);
		}
	}

	function validateUpload(data, maxSize, allowedTypes) {
		if (!data.imageData) {
			throw new Error('[[error:invalid-data]]');
		}
		const size = image.sizeFromBase64(data.imageData);
		if (size > maxSize * 1024) {
			throw new Error(`[[error:file-too-big, ${maxSize}]]`);
		}

		const type = image.mimeFromBase64(data.imageData);
		if (!type || !allowedTypes.includes(type)) {
			throw new Error('[[error:invalid-image]]');
		}
	}

	async function convertToPNG(path) {
		const convertToPNG = meta.config['profile:convertProfileImageToPNG'] === 1;
		if (!convertToPNG) {
			return path;
		}
		const newPath = await image.normalise(path);
		await file.delete(path);
		return newPath;
	}

	function generateProfileImageFilename(uid, extension) {
		const convertToPNG = meta.config['profile:convertProfileImageToPNG'] === 1;
		return `${uid}-profileavatar-${Date.now()}${convertToPNG ? '.png' : extension}`;
	}

'use strict';

const _ = require('lodash');

const meta = require('../meta');
const plugins = require('../plugins');
const db = require('../database');
const groups = require('../groups');
const utils = require('../utils');

module.exports = function (User) {
	const filterFnMap = {
		online: user => user.status !== 'offline' && (Date.now() - user.lastonline < 300000),
		flagged: user => parseInt(user.flags, 10) > 0,
		verified: user => !!user['email:confirmed'],
		unverified: user => !user['email:confirmed'],
	};

	const filterFieldMap = {
		online: ['status', 'lastonline'],
		flagged: ['flags'],
		verified: ['email:confirmed'],
		unverified: ['email:confirmed'],
	};


	User.search = async function (data) {
		const query = data.query || '';
		const searchBy = data.searchBy || 'username';
		const page = data.page || 1;
		const uid = data.uid || 0;
		const paginate = data.hasOwnProperty('paginate') ? data.paginate : true;

		const startTime = process.hrtime();

		let uids = [];
		if (searchBy === 'ip') {
			uids = await searchByIP(query);
		} else if (searchBy === 'uid') {
			uids = [query];
		} else {
			const searchMethod = data.findUids || findUids;
			uids = await searchMethod(query, searchBy, data.hardCap);
		}

		uids = await filterAndSortUids(uids, data);
		const result = await plugins.hooks.fire('filter:users.search', { uids: uids, uid: uid });
		uids = result.uids;

		const searchResult = {
			matchCount: uids.length,
		};

		if (paginate) {
			const resultsPerPage = data.resultsPerPage || meta.config.userSearchResultsPerPage;
			const start = Math.max(0, page - 1) * resultsPerPage;
			const stop = start + resultsPerPage;
			searchResult.pageCount = Math.ceil(uids.length / resultsPerPage);
			uids = uids.slice(start, stop);
		}

		const userData = await User.getUsers(uids, uid);
		searchResult.timing = (process.elapsedTimeSince(startTime) / 1000).toFixed(2);
		searchResult.users = userData.filter(user => user && user.uid > 0);
		return searchResult;
	};

	async function findUids(query, searchBy, hardCap) {
		if (!query) {
			return [];
		}
		query = String(query).toLowerCase();
		const min = query;
		const max = query.substr(0, query.length - 1) + String.fromCharCode(query.charCodeAt(query.length - 1) + 1);

		const resultsPerPage = meta.config.userSearchResultsPerPage;
		hardCap = hardCap || resultsPerPage * 10;

		const data = await db.getSortedSetRangeByLex(`${searchBy}:sorted`, min, max, 0, hardCap);
		const uids = data.map(data => data.split(':').pop());
		return uids;
	}

	async function filterAndSortUids(uids, data) {
		uids = uids.filter(uid => parseInt(uid, 10));
		let filters = data.filters || [];
		filters = Array.isArray(filters) ? filters : [data.filters];
		const fields = [];

		if (data.sortBy) {
			fields.push(data.sortBy);
		}

		filters.forEach((filter) => {
			if (filterFieldMap[filter]) {
				fields.push(...filterFieldMap[filter]);
			}
		});

		if (data.groupName) {
			const isMembers = await groups.isMembers(uids, data.groupName);
			uids = uids.filter((uid, index) => isMembers[index]);
		}

		if (!fields.length) {
			return uids;
		}

		if (filters.includes('banned') || filters.includes('notbanned')) {
			const isMembersOfBanned = await groups.isMembers(uids, groups.BANNED_USERS);
			const checkBanned = filters.includes('banned');
			uids = uids.filter((uid, index) => (checkBanned ? isMembersOfBanned[index] : !isMembersOfBanned[index]));
		}

		fields.push('uid');
		let userData = await User.getUsersFields(uids, fields);

		filters.forEach((filter) => {
			if (filterFnMap[filter]) {
				userData = userData.filter(filterFnMap[filter]);
			}
		});

		if (data.sortBy) {
			sortUsers(userData, data.sortBy, data.sortDirection);
		}

		return userData.map(user => user.uid);
	}

	function sortUsers(userData, sortBy, sortDirection) {
		if (!userData || !userData.length) {
			return;
		}
		sortDirection = sortDirection || 'desc';
		const direction = sortDirection === 'desc' ? 1 : -1;

		const isNumeric = utils.isNumber(userData[0][sortBy]);
		if (isNumeric) {
			userData.sort((u1, u2) => direction * (u2[sortBy] - u1[sortBy]));
		} else {
			userData.sort((u1, u2) => {
				if (u1[sortBy] < u2[sortBy]) {
					return direction * -1;
				} else if (u1[sortBy] > u2[sortBy]) {
					return direction * 1;
				}
				return 0;
			});
		}
	}

	async function searchByIP(ip) {
		const ipKeys = await db.scan({ match: `ip:${ip}*` });
'use strict';

const _ = require('lodash');

const groups = require('../groups');
const plugins = require('../plugins');
const db = require('../database');
const privileges = require('../privileges');
const categories = require('../categories');
const meta = require('../meta');
const utils = require('../utils');

const User = module.exports;

User.email = require('./email');
User.notifications = require('./notifications');
User.reset = require('./reset');
User.digest = require('./digest');

require('./data')(User);
require('./auth')(User);
require('./bans')(User);
require('./create')(User);
require('./posts')(User);
require('./topics')(User);
require('./categories')(User);
require('./follow')(User);
require('./profile')(User);
require('./admin')(User);
require('./delete')(User);
require('./settings')(User);
require('./search')(User);
require('./jobs')(User);
require('./picture')(User);
require('./approval')(User);
require('./invite')(User);
require('./password')(User);
require('./info')(User);
require('./online')(User);
require('./blocks')(User);
require('./uploads')(User);

User.exists = async function (uid) {
	return await db.isSortedSetMember('users:joindate', uid);
};

User.existsBySlug = async function (userslug) {
	const exists = await User.getUidByUserslug(userslug);
	return !!exists;
};

User.getUidsFromSet = async function (set, start, stop) {
	if (set === 'users:online') {
		const count = parseInt(stop, 10) === -1 ? stop : stop - start + 1;
		const now = Date.now();
		return await db.getSortedSetRevRangeByScore(set, start, count, '+inf', now - (meta.config.onlineCutoff * 60000));
	}
	return await db.getSortedSetRevRange(set, start, stop);
};

User.getUsersFromSet = async function (set, uid, start, stop) {
	const uids = await User.getUidsFromSet(set, start, stop);
	return await User.getUsers(uids, uid);
};

User.getUsersWithFields = async function (uids, fields, uid) {
	let results = await plugins.hooks.fire('filter:users.addFields', { fields: fields });
	results.fields = _.uniq(results.fields);
	const userData = await User.getUsersFields(uids, results.fields);
	results = await plugins.hooks.fire('filter:userlist.get', { users: userData, uid: uid });
	return results.users;
};

User.getUsers = async function (uids, uid) {
	return await User.getUsersWithFields(uids, [
		'uid', 'username', 'userslug', 'picture', 'status',
		'postcount', 'reputation', 'email:confirmed', 'lastonline',
		'flags', 'banned', 'banned:expire', 'joindate',
	], uid);
};

User.getStatus = function (userData) {
	if (userData.uid <= 0) {
		return 'offline';
	}
	const isOnline = (Date.now() - userData.lastonline) < (meta.config.onlineCutoff * 60000);
	return isOnline ? (userData.status || 'online') : 'offline';
};

User.getUidByUsername = async function (username) {
	if (!username) {
		return 0;
	}
	return await db.sortedSetScore('username:uid', username);
};

User.getUidsByUsernames = async function (usernames) {
	return await db.sortedSetScores('username:uid', usernames);
};

User.getUidByUserslug = async function (userslug) {
	if (!userslug) {
		return 0;
	}
	return await db.sortedSetScore('userslug:uid', userslug);
};

User.getUsernamesByUids = async function (uids) {
	const users = await User.getUsersFields(uids, ['username']);
	return users.map(user => user.username);
};

User.getUsernameByUserslug = async function (slug) {
	const uid = await User.getUidByUserslug(slug);
	return await User.getUserField(uid, 'username');
};

User.getUidByEmail = async function (email) {
	return await db.sortedSetScore('email:uid', email.toLowerCase());
};

User.getUidsByEmails = async function (emails) {
	emails = emails.map(email => email && email.toLowerCase());
	return await db.sortedSetScores('email:uid', emails);
};

User.getUsernameByEmail = async function (email) {
	const uid = await db.sortedSetScore('email:uid', String(email).toLowerCase());
	return await User.getUserField(uid, 'username');
};

User.isModerator = async function (uid, cid) {
	return await privileges.users.isModerator(uid, cid);
};

User.isModeratorOfAnyCategory = async function (uid) {
	const cids = await User.getModeratedCids(uid);
	return Array.isArray(cids) ? !!cids.length : false;
};

User.isAdministrator = async function (uid) {
	return await privileges.users.isAdministrator(uid);
};

User.isGlobalModerator = async function (uid) {
	return await privileges.users.isGlobalModerator(uid);
};

User.getPrivileges = async function (uid) {
	return await utils.promiseParallel({
		isAdmin: User.isAdministrator(uid),
		isGlobalModerator: User.isGlobalModerator(uid),
		isModeratorOfAnyCategory: User.isModeratorOfAnyCategory(uid),
	});
};

User.isPrivileged = async function (uid) {
	const results = await User.getPrivileges(uid);
	return results ? (results.isAdmin || results.isGlobalModerator || results.isModeratorOfAnyCategory) : false;
};

User.isAdminOrGlobalMod = async function (uid) {
	const [isAdmin, isGlobalMod] = await Promise.all([
		User.isAdministrator(uid),
		User.isGlobalModerator(uid),
	]);
	return isAdmin || isGlobalMod;
};

User.isAdminOrSelf = async function (callerUid, uid) {
	await isSelfOrMethod(callerUid, uid, User.isAdministrator);
};

User.isAdminOrGlobalModOrSelf = async function (callerUid, uid) {
	await isSelfOrMethod(callerUid, uid, User.isAdminOrGlobalMod);
};

User.isPrivilegedOrSelf = async function (callerUid, uid) {
	await isSelfOrMethod(callerUid, uid, User.isPrivileged);
};

async function isSelfOrMethod(callerUid, uid, method) {
	if (parseInt(callerUid, 10) === parseInt(uid, 10)) {
		return;
	}
	const isPass = await method(callerUid);
	if (!isPass) {
		throw new Error('[[error:no-privileges]]');
	}
}

User.getAdminsandGlobalMods = async function () {
	const results = await groups.getMembersOfGroups(['administrators', 'Global Moderators']);
	return await User.getUsersData(_.union(...results));
};

User.getAdminsandGlobalModsandModerators = async function () {
	const results = await Promise.all([
		groups.getMembers('administrators', 0, -1),
		groups.getMembers('Global Moderators', 0, -1),
		User.getModeratorUids(),
	]);
	return await User.getUsersData(_.union(...results));
};

User.getModeratorUids = async function () {
	const cids = await categories.getAllCidsFromSet('categories:cid');
	const uids = await categories.getModeratorUids(cids);
	return _.union(...uids);
};

User.getModeratedCids = async function (uid) {
	if (parseInt(uid, 10) <= 0) {
		return [];
	}
	const cids = await categories.getAllCidsFromSet('categories:cid');
	const isMods = await User.isModerator(uid, cids);
	return cids.filter((cid, index) => cid && isMods[index]);
};

User.addInterstitials = function (callback) {
	plugins.hooks.register('core', {
		hook: 'filter:register.interstitial',
		method: [
			// GDPR information collection/processing consent + email consent
			async function (data) {
				if (!meta.config.gdpr_enabled || (data.userData && data.userData.gdpr_consent)) {
					return data;
				}
				if (!data.userData) {
					throw new Error('[[error:invalid-data]]');
				}

				if (data.userData.uid) {
					const consented = await db.getObjectField(`user:${data.userData.uid}`, 'gdpr_consent');
					if (parseInt(consented, 10)) {
						return data;
					}
				}

				data.interstitials.push({
					template: 'partials/gdpr_consent',
					data: {
						digestFrequency: meta.config.dailyDigestFreq,
						digestEnabled: meta.config.dailyDigestFreq !== 'off',
					},
					callback: function (userData, formData, next) {
						if (formData.gdpr_agree_data === 'on' && formData.gdpr_agree_email === 'on') {
							userData.gdpr_consent = true;
						}

						next(userData.gdpr_consent ? null : new Error('[[register:gdpr_consent_denied]]'));
					},
				});
				return data;
			},

			// Forum Terms of Use
			async function (data) {
				if (!data.userData) {
					throw new Error('[[error:invalid-data]]');
				}
				if (!meta.config.termsOfUse || data.userData.acceptTos) {
					// no ToS or ToS accepted, nothing to do
					return data;
				}

				if (data.userData.uid) {
					const accepted = await db.getObjectField(`user:${data.userData.uid}`, 'acceptTos');
					if (parseInt(accepted, 10)) {
						return data;
					}
				}

				const termsOfUse = await plugins.hooks.fire('filter:parse.post', {
					postData: {
						content: meta.config.termsOfUse || '',
					},
				});

				data.interstitials.push({
					template: 'partials/acceptTos',
					data: {
						termsOfUse: termsOfUse.postData.content,
					},
					callback: function (userData, formData, next) {
						if (formData['agree-terms'] === 'on') {
							userData.acceptTos = true;
						}

						next(userData.acceptTos ? null : new Error('[[register:terms_of_use_error]]'));
					},
				});
				return data;
			},
		],
	});

	callback();
};
'use strict';

const nconf = require('nconf');

nconf.argv().env({
	separator: '__',
});

const fs = require('fs');
const path = require('path');
const json2csvAsync = require('json2csv').parseAsync;

process.env.NODE_ENV = process.env.NODE_ENV || 'production';

// Alternate configuration file support
const configFile = path.resolve(__dirname, '../../../', nconf.any(['config', 'CONFIG']) || 'config.json');
const prestart = require('../../prestart');

prestart.loadConfig(configFile);
prestart.setupWinston();

const db = require('../../database');
const batch = require('../../batch');

process.on('message', async (msg) => {
	if (msg && msg.uid) {
		await db.init();

		const targetUid = msg.uid;
		const filePath = path.join(__dirname, '../../../build/export', `${targetUid}_posts.csv`);

		const posts = require('../../posts');

		let payload = [];
		await batch.processSortedSet(`uid:${targetUid}:posts`, async (pids) => {
			let postData = await posts.getPostsData(pids);
			// Remove empty post references and convert newlines in content
			postData = postData.filter(Boolean).map((post) => {
				post.content = `"${String(post.content || '').replace(/\n/g, '\\n').replace(/"/g, '\\"')}"`;
				return post;
			});
			payload = payload.concat(postData);
		}, {
			batch: 500,
			interval: 1000,
		});

		const fields = payload.length ? Object.keys(payload[0]) : [];
		const opts = { fields };
		const csv = await json2csvAsync(payload, opts);
		await fs.promises.writeFile(filePath, csv);

		await db.close();
		process.exit(0);
	}
'use strict';

const nconf = require('nconf');

nconf.argv().env({
	separator: '__',
});

const fs = require('fs');
const path = require('path');
const _ = require('lodash');

process.env.NODE_ENV = process.env.NODE_ENV || 'production';

// Alternate configuration file support
const configFile = path.resolve(__dirname, '../../../', nconf.any(['config', 'CONFIG']) || 'config.json');
const prestart = require('../../prestart');

prestart.loadConfig(configFile);
prestart.setupWinston();

const db = require('../../database');
const batch = require('../../batch');

process.on('message', async (msg) => {
	if (msg && msg.uid) {
		await db.init();
		await db.initSessionStore();

		const targetUid = msg.uid;

		const profileFile = `${targetUid}_profile.json`;
		const profilePath = path.join(__dirname, '../../../build/export', profileFile);

		const user = require('../index');
		const [
			userData,
			userSettings,
			ips,
			sessions,
			usernames,
			emails,
			bookmarks,
			watchedTopics,
			upvoted,
			downvoted,
			following,
		] = await Promise.all([
			db.getObject(`user:${targetUid}`),
			db.getObject(`user:${targetUid}:settings`),
			user.getIPs(targetUid, 9),
			user.auth.getSessions(targetUid),
			user.getHistory(`user:${targetUid}:usernames`),
			user.getHistory(`user:${targetUid}:emails`),
			getSetData(`uid:${targetUid}:bookmarks`, 'post:', targetUid),
			getSetData(`uid:${targetUid}:followed_tids`, 'topic:', targetUid),
			getSetData(`uid:${targetUid}:upvote`, 'post:', targetUid),
			getSetData(`uid:${targetUid}:downvote`, 'post:', targetUid),
			getSetData(`following:${targetUid}`, 'user:', targetUid),
		]);
		delete userData.password;

		let chatData = [];
		await batch.processSortedSet(`uid:${targetUid}:chat:rooms`, async (roomIds) => {
			const result = await Promise.all(roomIds.map(roomId => getRoomMessages(targetUid, roomId)));
			chatData = chatData.concat(_.flatten(result));
		}, { batch: 100, interval: 1000 });

		await fs.promises.writeFile(profilePath, JSON.stringify({
			user: userData,
			settings: userSettings,
			ips: ips,
			sessions: sessions,
			usernames: usernames,
			emails: emails,
			messages: chatData,
			bookmarks: bookmarks,
			watchedTopics: watchedTopics,
			upvoted: upvoted,
			downvoted: downvoted,
			following: following,
		}, null, 4));

		await db.close();
		process.exit(0);
	}
});

async function getRoomMessages(uid, roomId) {
	const batch = require('../../batch');
	let data = [];
	await batch.processSortedSet(`uid:${uid}:chat:room:${roomId}:mids`, async (mids) => {
		const messageData = await db.getObjects(mids.map(mid => `message:${mid}`));
		data = data.concat(
			messageData
				.filter(m => m && m.fromuid === uid && !m.system)
				.map(m => ({ content: m.content, timestamp: m.timestamp }))
		);
	}, { batch: 500, interval: 1000 });
	return data;
}

async function getSetData(set, keyPrefix, uid) {
	const privileges = require('../../privileges');
	const batch = require('../../batch');
	let data = [];
	await batch.processSortedSet(set, async (ids) => {
		if (keyPrefix === 'post:') {
			ids = await privileges.posts.filter('topics:read', ids, uid);
		} else if (keyPrefix === 'topic:') {
			ids = await privileges.topics.filterTids('topics:read', ids, uid);
		}
		let objData = await db.getObjects(ids.map(id => keyPrefix + id));
		if (keyPrefix === 'post:') {
			objData = objData.map(o => _.pick(o, ['pid', 'content', 'timestamp']));
		} else if (keyPrefix === 'topic:') {
			objData = objData.map(o => _.pick(o, ['tid', 'title', 'timestamp']));
		} else if (keyPrefix === 'user:') {
			objData = objData.map(o => _.pick(o, ['uid', 'username']));
		}
'use strict';

const nconf = require('nconf');

nconf.argv().env({
	separator: '__',
});

const fs = require('fs');
const path = require('path');
const archiver = require('archiver');
const winston = require('winston');

process.env.NODE_ENV = process.env.NODE_ENV || 'production';

// Alternate configuration file support
const configFile = path.resolve(__dirname, '../../../', nconf.any(['config', 'CONFIG']) || 'config.json');
const prestart = require('../../prestart');

prestart.loadConfig(configFile);
prestart.setupWinston();

const db = require('../../database');

process.on('message', async (msg) => {
	if (msg && msg.uid) {
		await db.init();

		const targetUid = msg.uid;

		const archivePath = path.join(__dirname, '../../../build/export', `${targetUid}_uploads.zip`);
		const rootDirectory = path.join(__dirname, '../../../public/uploads/');

		const user = require('../index');

		const archive = archiver('zip', {
			zlib: { level: 9 }, // Sets the compression level.
		});

		archive.on('warning', (err) => {
			switch (err.code) {
				case 'ENOENT':
					winston.warn(`[user/export/uploads] File not found: ${err.path}`);
					break;

				default:
					winston.warn(`[user/export/uploads] Unexpected warning: ${err.message}`);
					break;
			}
		});

		archive.on('error', (err) => {
			const trimPath = function (path) {
				return path.replace(rootDirectory, '');
			};
			switch (err.code) {
				case 'EACCES':
					winston.error(`[user/export/uploads] File inaccessible: ${trimPath(err.path)}`);
					break;

				default:
					winston.error(`[user/export/uploads] Unable to construct archive: ${err.message}`);
					break;
			}
		});

		const output = fs.createWriteStream(archivePath);
		output.on('close', async () => {
			await db.close();
			process.exit(0);
		});

		archive.pipe(output);
		winston.verbose(`[user/export/uploads] Collating uploads for uid ${targetUid}`);
		await user.collateUploads(targetUid, archive);

		const uploadedPicture = await user.getUserField(targetUid, 'uploadedpicture');
		if (uploadedPicture) {
			const filePath = uploadedPicture.replace(nconf.get('upload_url'), '');
			archive.file(path.join(nconf.get('upload_path'), filePath), {
				name: path.basename(filePath),
			});
		}

		archive.finalize();
'use strict';

const _ = require('lodash');

const db = require('../database');
const categories = require('../categories');

module.exports = function (User) {
	User.setCategoryWatchState = async function (uid, cids, state) {
		if (!(parseInt(uid, 10) > 0)) {
			return;
		}
		const isStateValid = Object.values(categories.watchStates).includes(parseInt(state, 10));
		if (!isStateValid) {
			throw new Error('[[error:invalid-watch-state]]');
		}
		cids = Array.isArray(cids) ? cids : [cids];
		const exists = await categories.exists(cids);
		if (exists.includes(false)) {
			throw new Error('[[error:no-category]]');
		}
		await db.sortedSetsAdd(cids.map(cid => `cid:${cid}:uid:watch:state`), state, uid);
	};

	User.getCategoryWatchState = async function (uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return {};
		}

		const cids = await categories.getAllCidsFromSet('categories:cid');
		const states = await categories.getWatchState(cids, uid);
		return _.zipObject(cids, states);
	};

	User.getIgnoredCategories = async function (uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return [];
		}
		return await User.getCategoriesByStates(uid, [categories.watchStates.ignoring]);
	};

	User.getWatchedCategories = async function (uid) {
		if (!(parseInt(uid, 10) > 0)) {
			return [];
		}
		return await User.getCategoriesByStates(uid, [categories.watchStates.watching]);
	};

	User.getCategoriesByStates = async function (uid, states) {
		if (!(parseInt(uid, 10) > 0)) {
			return await categories.getAllCidsFromSet('categories:cid');
		}
		const cids = await categories.getAllCidsFromSet('categories:cid');
		const userState = await categories.getWatchState(cids, uid);
		return cids.filter((cid, index) => states.includes(userState[index]));
	};

	User.ignoreCategory = async function (uid, cid) {
		await User.setCategoryWatchState(uid, cid, categories.watchStates.ignoring);
	};
'use strict';

const winston = require('winston');

const meta = require('../meta');
const emailer = require('../emailer');
const db = require('../database');
const groups = require('../groups');
const privileges = require('../privileges');

module.exports = function (User) {
	User.bans = {};

	User.bans.ban = async function (uid, until, reason) {
		// "until" (optional) is unix timestamp in milliseconds
		// "reason" (optional) is a string
		until = until || 0;
		reason = reason || '';

		const now = Date.now();

		until = parseInt(until, 10);
		if (isNaN(until)) {
			throw new Error('[[error:ban-expiry-missing]]');
		}

		const banKey = `uid:${uid}:ban:${now}`;
		const banData = {
			uid: uid,
			timestamp: now,
			expire: until > now ? until : 0,
		};
		if (reason) {
			banData.reason = reason;
		}

		// Leaving all other system groups to have privileges constrained to the "banned-users" group
		const systemGroups = groups.systemGroups.filter(group => group !== groups.BANNED_USERS);
		await groups.leave(systemGroups, uid);
		await groups.join(groups.BANNED_USERS, uid);
		await db.sortedSetAdd('users:banned', now, uid);
		await db.sortedSetAdd(`uid:${uid}:bans:timestamp`, now, banKey);
		await db.setObject(banKey, banData);
		await User.setUserField(uid, 'banned:expire', banData.expire);
		if (until > now) {
			await db.sortedSetAdd('users:banned:expire', until, uid);
		} else {
			await db.sortedSetRemove('users:banned:expire', uid);
		}

		// Email notification of ban
		const username = await User.getUserField(uid, 'username');
		const siteTitle = meta.config.title || 'NodeBB';

		const data = {
			subject: `[[email:banned.subject, ${siteTitle}]]`,
			username: username,
			until: until ? (new Date(until)).toUTCString().replace(/,/g, '\\,') : false,
			reason: reason,
		};
		await emailer.send('banned', uid, data).catch(err => winston.error(`[emailer.send] ${err.stack}`));

		return banData;
	};

	User.bans.unban = async function (uids) {
		uids = Array.isArray(uids) ? uids : [uids];
		const userData = await User.getUsersFields(uids, ['email:confirmed']);

		await db.setObject(uids.map(uid => `user:${uid}`), { 'banned:expire': 0 });

		/* eslint-disable no-await-in-loop */
		for (const user of userData) {
			const systemGroupsToJoin = [
				'registered-users',
				(parseInt(user['email:confirmed'], 10) === 1 ? 'verified-users' : 'unverified-users'),
			];
			await groups.leave(groups.BANNED_USERS, user.uid);
			// An unbanned user would lost its previous "Global Moderator" status
			await groups.join(systemGroupsToJoin, user.uid);
		}

		await db.sortedSetRemove(['users:banned', 'users:banned:expire'], uids);
	};

	User.bans.isBanned = async function (uids) {
		const isArray = Array.isArray(uids);
		uids = isArray ? uids : [uids];
		const result = await User.bans.unbanIfExpired(uids);
		return isArray ? result.map(r => r.banned) : result[0].banned;
	};

	User.bans.canLoginIfBanned = async function (uid) {
		let canLogin = true;

		const { banned } = (await User.bans.unbanIfExpired([uid]))[0];
		// Group privilege overshadows individual one
		if (banned) {
			canLogin = await privileges.global.canGroup('local:login', groups.BANNED_USERS);
		}
		if (banned && !canLogin) {
			// Checking a single privilege of user
			canLogin = await groups.isMember(uid, 'cid:0:privileges:local:login');
		}

		return canLogin;
	};

	User.bans.unbanIfExpired = async function (uids) {
		// loading user data will unban if it has expired -barisu
		const userData = await User.getUsersFields(uids, ['banned:expire']);
		return User.bans.calcExpiredFromUserData(userData);
	};

	User.bans.calcExpiredFromUserData = async function (userData) {
		const isArray = Array.isArray(userData);
		userData = isArray ? userData : [userData];
		const banned = await groups.isMembers(userData.map(u => u.uid), groups.BANNED_USERS);
		userData = userData.map((userData, index) => ({
			banned: banned[index],
			'banned:expire': userData && userData['banned:expire'],
			banExpired: userData && userData['banned:expire'] <= Date.now() && userData['banned:expire'] !== 0,
		}));
		return isArray ? userData : userData[0];
	};

	User.bans.filterBanned = async function (uids) {
		const isBanned = await User.bans.isBanned(uids);
		return uids.filter((uid, index) => !isBanned[index]);
	};

	User.bans.getReason = async function (uid) {
		if (parseInt(uid, 10) <= 0) {
			return '';
		}
		const keys = await db.getSortedSetRevRange(`uid:${uid}:bans:timestamp`, 0, 0);
		if (!keys.length) {
			return '';
		}
		const banObj = await db.getObject(keys[0]);

'use strict';

const async = require('async');
const validator = require('validator');
const winston = require('winston');

const utils = require('../utils');
const slugify = require('../slugify');
const meta = require('../meta');
const db = require('../database');
const groups = require('../groups');
const plugins = require('../plugins');

module.exports = function (User) {
	User.updateProfile = async function (uid, data) {
		let fields = [
			'username', 'email', 'fullname', 'website', 'location',
			'groupTitle', 'birthday', 'signature', 'aboutme',
		];
		if (!data.uid) {
			throw new Error('[[error:invalid-update-uid]]');
		}
		const updateUid = data.uid;

		const result = await plugins.hooks.fire('filter:user.updateProfile', {
			uid: uid,
			data: data,
			fields: fields,
		});
		fields = result.fields;
		data = result.data;

		await validateData(uid, data);

		const oldData = await User.getUserFields(updateUid, fields);

		await async.each(fields, async (field) => {
			if (!(data[field] !== undefined && typeof data[field] === 'string')) {
				return;
			}

			data[field] = data[field].trim();

			if (field === 'email') {
				return await updateEmail(updateUid, data.email);
			} else if (field === 'username') {
				return await updateUsername(updateUid, data.username);
			} else if (field === 'fullname') {
				return await updateFullname(updateUid, data.fullname);
			}

			await User.setUserField(updateUid, field, data[field]);
		});

		plugins.hooks.fire('action:user.updateProfile', {
			uid: uid,
			data: data,
			fields: fields,
			oldData: oldData,
		});

		return await User.getUserFields(updateUid, [
			'email', 'username', 'userslug',
			'picture', 'icon:text', 'icon:bgColor',
		]);
	};

	async function validateData(callerUid, data) {
		await isEmailAvailable(data, data.uid);
		await isUsernameAvailable(data, data.uid);
		await isWebsiteValid(callerUid, data);
		await isAboutMeValid(callerUid, data);
		await isSignatureValid(callerUid, data);
		isFullnameValid(data);
		isLocationValid(data);
		isBirthdayValid(data);
		isGroupTitleValid(data);
	}

	async function isEmailAvailable(data, uid) {
		if (!data.email) {
			return;
		}

		data.email = data.email.trim();
		if (!utils.isEmailValid(data.email)) {
			throw new Error('[[error:invalid-email]]');
		}
		const email = await User.getUserField(uid, 'email');
		if (email === data.email) {
			return;
		}
		const available = await User.email.available(data.email);
		if (!available) {
			throw new Error('[[error:email-taken]]');
		}
	}

	async function isUsernameAvailable(data, uid) {
		if (!data.username) {
			return;
		}
		data.username = data.username.trim();
		const userData = await User.getUserFields(uid, ['username', 'userslug']);
		if (userData.username === data.username) {
			return;
		}

		if (data.username.length < meta.config.minimumUsernameLength) {
			throw new Error('[[error:username-too-short]]');
		}

		if (data.username.length > meta.config.maximumUsernameLength) {
			throw new Error('[[error:username-too-long]]');
		}

		const userslug = slugify(data.username);
		if (!utils.isUserNameValid(data.username) || !userslug) {
			throw new Error('[[error:invalid-username]]');
		}

		if (userslug === userData.userslug) {
			return;
		}
		const exists = await User.existsBySlug(userslug);
		if (exists) {
			throw new Error('[[error:username-taken]]');
		}
	}

	async function isWebsiteValid(callerUid, data) {
		if (!data.website) {
			return;
		}
		if (data.website.length > 255) {
			throw new Error('[[error:invalid-website]]');
		}
		await User.checkMinReputation(callerUid, data.uid, 'min:rep:website');
	}

	async function isAboutMeValid(callerUid, data) {
		if (!data.aboutme) {
			return;
		}
		if (data.aboutme !== undefined && data.aboutme.length > meta.config.maximumAboutMeLength) {
			throw new Error(`[[error:about-me-too-long, ${meta.config.maximumAboutMeLength}]]`);
		}

		await User.checkMinReputation(callerUid, data.uid, 'min:rep:aboutme');
	}

	async function isSignatureValid(callerUid, data) {
		if (!data.signature) {
			return;
		}
		if (data.signature !== undefined && data.signature.length > meta.config.maximumSignatureLength) {
			throw new Error(`[[error:signature-too-long, ${meta.config.maximumSignatureLength}]]`);
		}
		await User.checkMinReputation(callerUid, data.uid, 'min:rep:signature');
	}

	function isFullnameValid(data) {
		if (data.fullname && (validator.isURL(data.fullname) || data.fullname.length > 255)) {
			throw new Error('[[error:invalid-fullname]]');
		}
	}

	function isLocationValid(data) {
		if (data.location && (validator.isURL(data.location) || data.location.length > 255)) {
			throw new Error('[[error:invalid-location]]');
		}
	}

	function isBirthdayValid(data) {
		if (!data.birthday) {
			return;
		}

		const result = new Date(data.birthday);
		if (result && result.toString() === 'Invalid Date') {
			throw new Error('[[error:invalid-birthday]]');
		}
	}

	function isGroupTitleValid(data) {
		function checkTitle(title) {
			if (title === 'registered-users' || groups.isPrivilegeGroup(title)) {
				throw new Error('[[error:invalid-group-title]]');
			}
		}
		if (!data.groupTitle) {
			return;
		}
		let groupTitles = [];
		if (validator.isJSON(data.groupTitle)) {
			groupTitles = JSON.parse(data.groupTitle);
			if (!Array.isArray(groupTitles)) {
				throw new Error('[[error:invalid-group-title]]');
			}
			groupTitles.forEach(title => checkTitle(title));
		} else {
			groupTitles = [data.groupTitle];
			checkTitle(data.groupTitle);
		}
		if (!meta.config.allowMultipleBadges && groupTitles.length > 1) {
			data.groupTitle = JSON.stringify(groupTitles[0]);
		}
	}

	User.checkMinReputation = async function (callerUid, uid, setting) {
		const isSelf = parseInt(callerUid, 10) === parseInt(uid, 10);
		if (!isSelf || meta.config['reputation:disabled']) {
			return;
		}
		const reputation = await User.getUserField(uid, 'reputation');
		if (reputation < meta.config[setting]) {
			throw new Error(`[[error:not-enough-reputation-${setting.replace(/:/g, '-')}]]`);
		}
	};

	async function updateEmail(uid, newEmail) {
		let oldEmail = await User.getUserField(uid, 'email');
		oldEmail = oldEmail || '';
		if (oldEmail === newEmail) {
			return;
		}

		await db.sortedSetRemove('email:uid', oldEmail.toLowerCase());
		await db.sortedSetRemove('email:sorted', `${oldEmail.toLowerCase()}:${uid}`);
		await User.auth.revokeAllSessions(uid);

		await Promise.all([
			db.sortedSetAddBulk([
				['email:uid', uid, newEmail.toLowerCase()],
				['email:sorted', 0, `${newEmail.toLowerCase()}:${uid}`],
				[`user:${uid}:emails`, Date.now(), `${newEmail}:${Date.now()}`],
			]),
			User.setUserFields(uid, { email: newEmail, 'email:confirmed': 0 }),
			groups.leave('verified-users', uid),
			groups.join('unverified-users', uid),
			User.reset.cleanByUid(uid),
		]);

		if (meta.config.requireEmailConfirmation && newEmail) {
			await User.email.sendValidationEmail(uid, {
				email: newEmail,
				subject: '[[email:email.verify-your-email.subject]]',
				template: 'verify_email',
			}).catch(err => winston.error(`[user.create] Validation email failed to send\n[emailer.send] ${err.stack}`));
		}
	}

	async function updateUsername(uid, newUsername) {
		if (!newUsername) {
			return;
		}
		const userData = await User.getUserFields(uid, ['username', 'userslug']);
		if (userData.username === newUsername) {
			return;
		}
		const newUserslug = slugify(newUsername);
		const now = Date.now();
		await Promise.all([
			updateUidMapping('username', uid, newUsername, userData.username),
			updateUidMapping('userslug', uid, newUserslug, userData.userslug),
			db.sortedSetAdd(`user:${uid}:usernames`, now, `${newUsername}:${now}`),
		]);
		await db.sortedSetRemove('username:sorted', `${userData.username.toLowerCase()}:${uid}`);
		await db.sortedSetAdd('username:sorted', 0, `${newUsername.toLowerCase()}:${uid}`);
	}

	async function updateUidMapping(field, uid, value, oldValue) {
		if (value === oldValue) {
			return;
		}
		await db.sortedSetRemove(`${field}:uid`, oldValue);
		await User.setUserField(uid, field, value);
		if (value) {
			await db.sortedSetAdd(`${field}:uid`, uid, value);
		}
	}

	async function updateFullname(uid, newFullname) {
		const fullname = await User.getUserField(uid, 'fullname');
		await updateUidMapping('fullname', uid, newFullname, fullname);
		if (newFullname !== fullname) {
			if (fullname) {
				await db.sortedSetRemove('fullname:sorted', `${fullname.toLowerCase()}:${uid}`);
			}
			if (newFullname) {
				await db.sortedSetAdd('fullname:sorted', 0, `${newFullname.toLowerCase()}:${uid}`);
			}
		}
	}

	User.changePassword = async function (uid, data) {
		if (uid <= 0 || !data || !data.uid) {
			throw new Error('[[error:invalid-uid]]');
		}
		User.isPasswordValid(data.newPassword);
		const [isAdmin, hasPassword] = await Promise.all([
			User.isAdministrator(uid),
			User.hasPassword(uid),
		]);

		if (meta.config['password:disableEdit'] && !isAdmin) {
			throw new Error('[[error:no-privileges]]');
		}

		const isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);

		if (!isAdmin && !isSelf) {
			throw new Error('[[user:change_password_error_privileges]]');
		}

		if (isSelf && hasPassword) {
			const correct = await User.isPasswordCorrect(data.uid, data.currentPassword, data.ip);
			if (!correct) {
				throw new Error('[[user:change_password_error_wrong_current]]');
			}
		}

		const hashedPassword = await User.hashPassword(data.newPassword);
		await Promise.all([
			User.setUserFields(data.uid, {
				password: hashedPassword,
				'password:shaWrapped': 1,
				rss_token: utils.generateUUID(),
			}),
			User.reset.cleanByUid(data.uid),
			User.reset.updateExpiry(data.uid),
			User.auth.revokeAllSessions(data.uid),
		]);

'use strict';

const db = require('../database');
const meta = require('../meta');
const privileges = require('../privileges');

module.exports = function (User) {
	User.isReadyToPost = async function (uid, cid) {
		await isReady(uid, cid, 'lastposttime');
	};

	User.isReadyToQueue = async function (uid, cid) {
		await isReady(uid, cid, 'lastqueuetime');
	};

	async function isReady(uid, cid, field) {
		if (parseInt(uid, 10) === 0) {
			return;
		}
		const [userData, isAdminOrMod] = await Promise.all([
			User.getUserFields(uid, ['uid', 'banned', 'joindate', 'email', 'reputation'].concat([field])),
			privileges.categories.isAdminOrMod(cid, uid),
		]);

		if (!userData.uid) {
			throw new Error('[[error:no-user]]');
		}

		if (isAdminOrMod) {
			return;
		}

		if (userData.banned) {
			throw new Error('[[error:user-banned]]');
		}

		const now = Date.now();
		if (now - userData.joindate < meta.config.initialPostDelay * 1000) {
			throw new Error(`[[error:user-too-new, ${meta.config.initialPostDelay}]]`);
		}

		const lasttime = userData[field] || 0;

		if (
			meta.config.newbiePostDelay > 0 &&
			meta.config.newbiePostDelayThreshold > userData.reputation &&
			now - lasttime < meta.config.newbiePostDelay * 1000
		) {
			throw new Error(`[[error:too-many-posts-newbie, ${meta.config.newbiePostDelay}, ${meta.config.newbiePostDelayThreshold}]]`);
		} else if (now - lasttime < meta.config.postDelay * 1000) {
			throw new Error(`[[error:too-many-posts, ${meta.config.postDelay}]]`);
		}
	}

	User.onNewPostMade = async function (postData) {
		await User.addPostIdToUser(postData);
		await User.incrementUserPostCountBy(postData.uid, 1);
		await User.setUserField(postData.uid, 'lastposttime', postData.timestamp);
		await User.updateLastOnlineTime(postData.uid);
	};

	User.addPostIdToUser = async function (postData) {
		await db.sortedSetsAdd([
			`uid:${postData.uid}:posts`,
			`cid:${postData.cid}:uid:${postData.uid}:pids`,
		], postData.timestamp, postData.pid);
	};

	User.incrementUserPostCountBy = async function (uid, value) {
		return await incrementUserFieldAndSetBy(uid, 'postcount', 'users:postcount', value);
	};

	User.incrementUserReputationBy = async function (uid, value) {
		return await incrementUserFieldAndSetBy(uid, 'reputation', 'users:reputation', value);
	};

	User.incrementUserFlagsBy = async function (uid, value) {
		return await incrementUserFieldAndSetBy(uid, 'flags', 'users:flags', value);
	};

	async function incrementUserFieldAndSetBy(uid, field, set, value) {
		value = parseInt(value, 10);
		if (!value || !field || !(parseInt(uid, 10) > 0)) {
			return;
		}
		const exists = await User.exists(uid);
		if (!exists) {
			return;
		}
		const newValue = await User.incrementUserFieldBy(uid, field, value);
		await db.sortedSetAdd(set, newValue, uid);
		return newValue;
	}

	User.getPostIds = async function (uid, start, stop) {

'use strict';

const plugins = require('../plugins');
const db = require('../database');

module.exports = function (User) {
	User.follow = async function (uid, followuid) {
		await toggleFollow('follow', uid, followuid);
	};

	User.unfollow = async function (uid, unfollowuid) {
		await toggleFollow('unfollow', uid, unfollowuid);
	};

	async function toggleFollow(type, uid, theiruid) {
		if (parseInt(uid, 10) <= 0 || parseInt(theiruid, 10) <= 0) {
			throw new Error('[[error:invalid-uid]]');
		}

		if (parseInt(uid, 10) === parseInt(theiruid, 10)) {
			throw new Error('[[error:you-cant-follow-yourself]]');
		}
		const exists = await User.exists(theiruid);
		if (!exists) {
			throw new Error('[[error:no-user]]');
		}
		const isFollowing = await User.isFollowing(uid, theiruid);
		if (type === 'follow') {
			if (isFollowing) {
				throw new Error('[[error:already-following]]');
			}
			const now = Date.now();
			await Promise.all([
				db.sortedSetAddBulk([
					[`following:${uid}`, now, theiruid],
					[`followers:${theiruid}`, now, uid],
				]),
			]);
		} else {
			if (!isFollowing) {
				throw new Error('[[error:not-following]]');
			}
			await Promise.all([
				db.sortedSetRemoveBulk([
					[`following:${uid}`, theiruid],
					[`followers:${theiruid}`, uid],
				]),
			]);
		}

		const [followingCount, followerCount] = await Promise.all([
			db.sortedSetCard(`following:${uid}`),
			db.sortedSetCard(`followers:${theiruid}`),
		]);
		await Promise.all([
			User.setUserField(uid, 'followingCount', followingCount),
			User.setUserField(theiruid, 'followerCount', followerCount),
		]);
	}

	User.getFollowing = async function (uid, start, stop) {
		return await getFollow(uid, 'following', start, stop);
	};

	User.getFollowers = async function (uid, start, stop) {
		return await getFollow(uid, 'followers', start, stop);
	};

	async function getFollow(uid, type, start, stop) {
		if (parseInt(uid, 10) <= 0) {
			return [];
		}
		const uids = await db.getSortedSetRevRange(`${type}:${uid}`, start, stop);
		const data = await plugins.hooks.fire(`filter:user.${type}`, {
			uids: uids,
			uid: uid,
			start: start,
			stop: stop,
		});
		return await User.getUsers(data.uids, uid);
	}

	User.isFollowing = async function (uid, theirid) {
		if (parseInt(uid, 10) <= 0 || parseInt(theirid, 10) <= 0) {

'use strict';

const winston = require('winston');
const _ = require('lodash');

const db = require('../database');
const meta = require('../meta');
const notifications = require('../notifications');
const privileges = require('../privileges');
const plugins = require('../plugins');
const utils = require('../utils');

const UserNotifications = module.exports;

UserNotifications.get = async function (uid) {
	if (parseInt(uid, 10) <= 0) {
		return { read: [], unread: [] };
	}

	let unread = await getNotificationsFromSet(`uid:${uid}:notifications:unread`, uid, 0, 29);
	unread = unread.filter(Boolean);
	let read = [];
	if (unread.length < 30) {
		read = await getNotificationsFromSet(`uid:${uid}:notifications:read`, uid, 0, 29 - unread.length);
	}

	return await plugins.hooks.fire('filter:user.notifications.get', {
		uid,
		read: read.filter(Boolean),
		unread: unread,
	});
};

async function filterNotifications(nids, filter) {
	if (!filter) {
		return nids;
	}
	const keys = nids.map(nid => `notifications:${nid}`);
	const notifications = await db.getObjectsFields(keys, ['nid', 'type']);
	return notifications.filter(n => n && n.nid && n.type === filter).map(n => n.nid);
}

UserNotifications.getAll = async function (uid, filter) {
	let nids = await db.getSortedSetRevRange([
		`uid:${uid}:notifications:unread`,
		`uid:${uid}:notifications:read`,
	], 0, -1);
	nids = _.uniq(nids);
	const exists = await db.isSortedSetMembers('notifications', nids);
	const deleteNids = [];

	nids = nids.filter((nid, index) => {
		if (!nid || !exists[index]) {
			deleteNids.push(nid);
		}
		return nid && exists[index];
	});

	await deleteUserNids(deleteNids, uid);
	return await filterNotifications(nids, filter);
};

async function deleteUserNids(nids, uid) {
	await db.sortedSetRemove([
		`uid:${uid}:notifications:read`,
		`uid:${uid}:notifications:unread`,
	], nids);
}

async function getNotificationsFromSet(set, uid, start, stop) {
	const nids = await db.getSortedSetRevRange(set, start, stop);
	return await UserNotifications.getNotifications(nids, uid);
}

UserNotifications.getNotifications = async function (nids, uid) {
	if (!Array.isArray(nids) || !nids.length) {
		return [];
	}

	const [notifObjs, hasRead] = await Promise.all([
		notifications.getMultiple(nids),
		db.isSortedSetMembers(`uid:${uid}:notifications:read`, nids),
	]);

	const deletedNids = [];
	let notificationData = notifObjs.filter((notification, index) => {
		if (!notification || !notification.nid) {
			deletedNids.push(nids[index]);
		}
		if (notification) {
			notification.read = hasRead[index];
			notification.readClass = !notification.read ? 'unread' : '';
		}

		return notification;
	});

	await deleteUserNids(deletedNids, uid);
	notificationData = await notifications.merge(notificationData);
	const result = await plugins.hooks.fire('filter:user.notifications.getNotifications', {
		uid: uid,
		notifications: notificationData,
	});
	return result && result.notifications;
};

UserNotifications.getUnreadInterval = async function (uid, interval) {
	const dayInMs = 1000 * 60 * 60 * 24;
	const times = {
		day: dayInMs,
		week: 7 * dayInMs,
		month: 30 * dayInMs,
	};
	if (!times[interval]) {
		return [];
	}
	const min = Date.now() - times[interval];
	const nids = await db.getSortedSetRevRangeByScore(`uid:${uid}:notifications:unread`, 0, 20, '+inf', min);
	return await UserNotifications.getNotifications(nids, uid);
};

UserNotifications.getDailyUnread = async function (uid) {
	return await UserNotifications.getUnreadInterval(uid, 'day');
};

UserNotifications.getUnreadCount = async function (uid) {
	if (parseInt(uid, 10) <= 0) {
		return 0;
	}
	let nids = await db.getSortedSetRevRange(`uid:${uid}:notifications:unread`, 0, 99);
	nids = await notifications.filterExists(nids);
	const keys = nids.map(nid => `notifications:${nid}`);
	const notifData = await db.getObjectsFields(keys, ['mergeId']);
	const mergeIds = notifData.map(n => n.mergeId);

	// Collapse any notifications with identical mergeIds
	let count = mergeIds.reduce((count, mergeId, idx, arr) => {
		// A missing (null) mergeId means that notification is counted separately.
		if (mergeId === null || idx === arr.indexOf(mergeId)) {
			count += 1;
		}

		return count;
	}, 0);

	({ count } = await plugins.hooks.fire('filter:user.notifications.getCount', { uid, count }));
	return count;
};

UserNotifications.getUnreadByField = async function (uid, field, values) {
	const nids = await db.getSortedSetRevRange(`uid:${uid}:notifications:unread`, 0, 99);
	if (!nids.length) {
		return [];
	}
	const keys = nids.map(nid => `notifications:${nid}`);
	const notifData = await db.getObjectsFields(keys, ['nid', field]);
	const valuesSet = new Set(values.map(value => String(value)));
	return notifData.filter(n => n && n[field] && valuesSet.has(String(n[field]))).map(n => n.nid);
};

UserNotifications.deleteAll = async function (uid) {
	if (parseInt(uid, 10) <= 0) {
		return;
	}
	await db.deleteAll([
		`uid:${uid}:notifications:unread`,
		`uid:${uid}:notifications:read`,
	]);
};

UserNotifications.sendTopicNotificationToFollowers = async function (uid, topicData, postData) {
	try {
		let followers = await db.getSortedSetRange(`followers:${uid}`, 0, -1);
		followers = await privileges.categories.filterUids('read', topicData.cid, followers);
		if (!followers.length) {
			return;
		}
		let { title } = topicData;
		if (title) {
			title = utils.decodeHTMLEntities(title);
			title = title.replace(/,/g, '\\,');
		}

		const notifObj = await notifications.create({
			type: 'new-topic',
			bodyShort: `[[notifications:user_posted_topic, ${postData.user.username}, ${title}]]`,
			bodyLong: postData.content,
			pid: postData.pid,
			path: `/post/${postData.pid}`,
			nid: `tid:${postData.tid}:uid:${uid}`,
			tid: postData.tid,
			from: uid,
		});

		await notifications.push(notifObj, followers);
	} catch (err) {
		winston.error(err.stack);
	}
};

UserNotifications.sendWelcomeNotification = async function (uid) {
	if (!meta.config.welcomeNotification) {
		return;
	}

	const path = meta.config.welcomeLink ? meta.config.welcomeLink : '#';
	const notifObj = await notifications.create({
		bodyShort: meta.config.welcomeNotification,
		path: path,
		nid: `welcome_${uid}`,
		from: meta.config.welcomeUid ? meta.config.welcomeUid : null,
	});

	await notifications.push(notifObj, [uid]);
};

UserNotifications.sendNameChangeNotification = async function (uid, username) {
	const notifObj = await notifications.create({
		bodyShort: `[[user:username_taken_workaround, ${username}]]`,
		image: 'brand:logo',
		nid: `username_taken:${uid}`,
		datetime: Date.now(),
	});

	await notifications.push(notifObj, uid);
};

UserNotifications.pushCount = async function (uid) {
	const websockets = require('../socket.io');
'use strict';

const _ = require('lodash');
const validator = require('validator');

const db = require('../database');
const posts = require('../posts');
const topics = require('../topics');
const utils = require('../../public/src/utils');

module.exports = function (User) {
	User.getLatestBanInfo = async function (uid) {
		// Simply retrieves the last record of the user's ban, even if they've been unbanned since then.
		const record = await db.getSortedSetRevRange(`uid:${uid}:bans:timestamp`, 0, 0);
		if (!record.length) {
			throw new Error('no-ban-info');
		}
		const banInfo = await db.getObject(record[0]);
		const expire = parseInt(banInfo.expire, 10);
		const expire_readable = utils.toISOString(expire);
		return {
			uid: uid,
			timestamp: banInfo.timestamp,
			banned_until: expire,
			expiry: expire, /* backward compatible alias */
			banned_until_readable: expire_readable,
			expiry_readable: expire_readable, /* backward compatible alias */
			reason: validator.escape(String(banInfo.reason || '')),
		};
	};

	User.getModerationHistory = async function (uid) {
		let [flags, bans] = await Promise.all([
			db.getSortedSetRevRangeWithScores(`flags:byTargetUid:${uid}`, 0, 19),
			db.getSortedSetRevRange(`uid:${uid}:bans:timestamp`, 0, 19),
		]);

		// Get pids from flag objects
		const keys = flags.map(flagObj => `flag:${flagObj.value}`);
		const payload = await db.getObjectsFields(keys, ['type', 'targetId']);

		// Only pass on flag ids from posts
		flags = payload.reduce((memo, cur, idx) => {
			if (cur.type === 'post') {
				memo.push({
					value: parseInt(cur.targetId, 10),
					score: flags[idx].score,
				});
			}

			return memo;
		}, []);

		[flags, bans] = await Promise.all([
			getFlagMetadata(flags),
			formatBanData(bans),
		]);

		return {
			flags: flags,
			bans: bans,
		};
	};

	User.getHistory = async function (set) {
		const data = await db.getSortedSetRevRangeWithScores(set, 0, -1);
		return data.map((set) => {
			set.timestamp = set.score;
			set.timestampISO = utils.toISOString(set.score);
			set.value = validator.escape(String(set.value.split(':')[0]));
			delete set.score;
			return set;
		});
	};

	async function getFlagMetadata(flags) {
		const pids = flags.map(flagObj => parseInt(flagObj.value, 10));
		const postData = await posts.getPostsFields(pids, ['tid']);
		const tids = postData.map(post => post.tid);

		const topicData = await topics.getTopicsFields(tids, ['title']);
		flags = flags.map((flagObj, idx) => {
			flagObj.pid = flagObj.value;
			flagObj.timestamp = flagObj.score;
			flagObj.timestampISO = new Date(flagObj.score).toISOString();
			flagObj.timestampReadable = new Date(flagObj.score).toString();

			delete flagObj.value;
			delete flagObj.score;
			if (!tids[idx]) {
				flagObj.targetPurged = true;
			}
			return _.extend(flagObj, topicData[idx]);
		});
		return flags;
	}

	async function formatBanData(bans) {
		const banData = await db.getObjects(bans);
		const uids = banData.map(banData => banData.fromUid);
		const usersData = await User.getUsersFields(uids, ['uid', 'username', 'userslug', 'picture']);
		return banData.map((banObj, index) => {
			banObj.user = usersData[index];
			banObj.until = parseInt(banObj.expire, 10);
			banObj.untilReadable = new Date(banObj.until).toString();
			banObj.timestampReadable = new Date(parseInt(banObj.timestamp, 10)).toString();
			banObj.timestampISO = utils.toISOString(banObj.timestamp);
			banObj.reason = validator.escape(String(banObj.reason || '')) || '[[user:info.banned-no-reason]]';
			return banObj;
		});
	}

	User.getModerationNotes = async function (uid, start, stop) {
		const noteIds = await db.getSortedSetRevRange(`uid:${uid}:moderation:notes`, start, stop);
		const keys = noteIds.map(id => `uid:${uid}:moderation:note:${id}`);
		const notes = await db.getObjects(keys);
		const uids = [];

		const noteData = notes.map((note) => {
			if (note) {
				uids.push(note.uid);
				note.timestampISO = utils.toISOString(note.timestamp);
				note.note = validator.escape(String(note.note));
			}
			return note;
		});

		const userData = await User.getUsersFields(uids, ['uid', 'username', 'userslug', 'picture']);
		noteData.forEach((note, index) => {
			if (note) {
				note.user = userData[index];
			}
		});
		return noteData;
	};

	User.appendModerationNote = async ({ uid, noteData }) => {
		await db.sortedSetAdd(`uid:${uid}:moderation:notes`, noteData.timestamp, noteData.timestamp);
		await db.setObject(`uid:${uid}:moderation:note:${noteData.timestamp}`, noteData);
	};
'use strict';

const path = require('path');
const nconf = require('nconf');
const winston = require('winston');

const db = require('../database');
const file = require('../file');
const batch = require('../batch');

module.exports = function (User) {
	User.deleteUpload = async function (callerUid, uid, uploadName) {
		const [isUsersUpload, isAdminOrGlobalMod] = await Promise.all([
			db.isSortedSetMember(`uid:${callerUid}:uploads`, uploadName),
			User.isAdminOrGlobalMod(callerUid),
		]);
		if (!isAdminOrGlobalMod && !isUsersUpload) {
			throw new Error('[[error:no-privileges]]');
		}

		const finalPath = path.join(nconf.get('upload_path'), uploadName);
		if (!finalPath.startsWith(nconf.get('upload_path'))) {
			throw new Error('[[error:invalid-path]]');
		}
		winston.verbose(`[user/deleteUpload] Deleting ${uploadName}`);
		await Promise.all([
			file.delete(finalPath),
			file.delete(file.appendToFileName(finalPath, '-resized')),
		]);
		await db.sortedSetRemove(`uid:${uid}:uploads`, uploadName);
	};

	User.collateUploads = async function (uid, archive) {
		await batch.processSortedSet(`uid:${uid}:uploads`, (files, next) => {
			files.forEach((file) => {
				archive.file(path.join(nconf.get('upload_path'), file), {
					name: path.basename(file),
				});
			});


'use strict';

const nconf = require('nconf');

const user = require('./index');
const utils = require('../utils');
const plugins = require('../plugins');
const db = require('../database');
const meta = require('../meta');
const emailer = require('../emailer');
const groups = require('../groups');

const UserEmail = module.exports;

UserEmail.exists = async function (email) {
	const uid = await user.getUidByEmail(email.toLowerCase());
	return !!uid;
};

UserEmail.available = async function (email) {
	const exists = await db.isSortedSetMember('email:uid', email.toLowerCase());
	return !exists;
};

UserEmail.sendValidationEmail = async function (uid, options) {
	/*
	 * 	Options:
	 * 		- email, overrides email retrieval
	 * 		- force, sends email even if it is too soon to send another
	 */

	options = options || {};

	// Fallback behaviour (email passed in as second argument)
	if (typeof options === 'string') {
		options = {
			email: options,
		};
	}

	let confirm_code = utils.generateUUID();
	const confirm_link = `${nconf.get('url')}/confirm/${confirm_code}`;

	const emailInterval = meta.config.emailConfirmInterval;

	// If no email passed in (default), retrieve email from uid
	if (!options.email || !options.email.length) {
		options.email = await user.getUserField(uid, 'email');
	}
	if (!options.email) {
		return;
	}
	let sent = false;
	if (!options.force) {
		sent = await db.get(`uid:${uid}:confirm:email:sent`);
	}
	if (sent) {
		throw new Error(`[[error:confirm-email-already-sent, ${emailInterval}]]`);
	}
	await db.set(`uid:${uid}:confirm:email:sent`, 1);
	await db.pexpireAt(`uid:${uid}:confirm:email:sent`, Date.now() + (emailInterval * 60 * 1000));
	confirm_code = await plugins.hooks.fire('filter:user.verify.code', confirm_code);

	await db.setObject(`confirm:${confirm_code}`, {
		email: options.email.toLowerCase(),
		uid: uid,
	});
	await db.expireAt(`confirm:${confirm_code}`, Math.floor((Date.now() / 1000) + (60 * 60 * 24)));
	const username = await user.getUserField(uid, 'username');

	const data = {
		username: username,
		confirm_link: confirm_link,
		confirm_code: confirm_code,

		subject: options.subject || `[[email:welcome-to, ${meta.config.title || meta.config.browserTitle || 'NodeBB'}]]`,
		template: options.template || 'welcome',
		uid: uid,
	};

	if (plugins.hooks.hasListeners('action:user.verify')) {
		plugins.hooks.fire('action:user.verify', { uid: uid, data: data });
	} else {
		await emailer.send(data.template, uid, data);
	}
	return confirm_code;
};

// confirm email by code sent by confirmation email
UserEmail.confirmByCode = async function (code) {
	const confirmObj = await db.getObject(`confirm:${code}`);
	if (!confirmObj || !confirmObj.uid || !confirmObj.email) {
		throw new Error('[[error:invalid-data]]');
	}
	const currentEmail = await user.getUserField(confirmObj.uid, 'email');
	if (!currentEmail || currentEmail.toLowerCase() !== confirmObj.email) {
		throw new Error('[[error:invalid-email]]');
	}
	await UserEmail.confirmByUid(confirmObj.uid);
	await db.delete(`confirm:${code}`);
};

// confirm uid's email
UserEmail.confirmByUid = async function (uid) {
	if (!(parseInt(uid, 10) > 0)) {
		throw new Error('[[error:invalid-uid]]');
	}
	const currentEmail = await user.getUserField(uid, 'email');
	if (!currentEmail) {
		throw new Error('[[error:invalid-email]]');
	}
	await Promise.all([
		user.setUserField(uid, 'email:confirmed', 1),
		groups.join('verified-users', uid),
'use strict';

const validator = require('validator');
const winston = require('winston');
const cronJob = require('cron').CronJob;

const db = require('../database');
const meta = require('../meta');
const emailer = require('../emailer');
const notifications = require('../notifications');
const groups = require('../groups');
const utils = require('../utils');
const slugify = require('../slugify');
const plugins = require('../plugins');

module.exports = function (User) {
	new cronJob('0 * * * *', (() => {
		User.autoApprove();
	}), null, true);

	User.addToApprovalQueue = async function (userData) {
		userData.username = userData.username.trim();
		userData.userslug = slugify(userData.username);
		await canQueue(userData);
		const hashedPassword = await User.hashPassword(userData.password);
		const data = {
			username: userData.username,
			email: userData.email,
			ip: userData.ip,
			hashedPassword: hashedPassword,
		};
		const results = await plugins.hooks.fire('filter:user.addToApprovalQueue', { data: data, userData: userData });
		await db.setObject(`registration:queue:name:${userData.username}`, results.data);
		await db.sortedSetAdd('registration:queue', Date.now(), userData.username);
		await sendNotificationToAdmins(userData.username);
	};

	async function canQueue(userData) {
		await User.isDataValid(userData);
		const usernames = await db.getSortedSetRange('registration:queue', 0, -1);
		if (usernames.includes(userData.username)) {
			throw new Error('[[error:username-taken]]');
		}
		const keys = usernames.filter(Boolean).map(username => `registration:queue:name:${username}`);
		const data = await db.getObjectsFields(keys, ['email']);
		const emails = data.map(data => data && data.email);
		if (emails.includes(userData.email)) {
			throw new Error('[[error:email-taken]]');
		}
	}

	async function sendNotificationToAdmins(username) {
		const notifObj = await notifications.create({
			type: 'new-register',
			bodyShort: `[[notifications:new_register, ${username}]]`,
			nid: `new_register:${username}`,
			path: '/admin/manage/registration',
			mergeId: 'new_register',
		});
		await notifications.pushGroup(notifObj, 'administrators');
	}

	User.acceptRegistration = async function (username) {
		const userData = await db.getObject(`registration:queue:name:${username}`);
		if (!userData) {
			throw new Error('[[error:invalid-data]]');
		}
		const creation_time = await db.sortedSetScore('registration:queue', username);
		const uid = await User.create(userData);
		await User.setUserFields(uid, {
			password: userData.hashedPassword,
			'password:shaWrapped': 1,
		});
		await removeFromQueue(username);
		await markNotificationRead(username);
		await plugins.hooks.fire('filter:register.complete', { uid: uid });
		await emailer.send('registration_accepted', uid, {
			username: username,
			subject: `[[email:welcome-to, ${meta.config.title || meta.config.browserTitle || 'NodeBB'}]]`,
			template: 'registration_accepted',
			uid: uid,
		}).catch(err => winston.error(`[emailer.send] ${err.stack}`));
		const total = await db.incrObjectField('registration:queue:approval:times', 'totalTime', Math.floor((Date.now() - creation_time) / 60000));
		const counter = await db.incrObjectField('registration:queue:approval:times', 'counter', 1);
		await db.setObjectField('registration:queue:approval:times', 'average', total / counter);
		return uid;
	};

	async function markNotificationRead(username) {
		const nid = `new_register:${username}`;
		const uids = await groups.getMembers('administrators', 0, -1);
		const promises = uids.map(uid => notifications.markRead(nid, uid));
		await Promise.all(promises);
	}

	User.rejectRegistration = async function (username) {
		await removeFromQueue(username);
		await markNotificationRead(username);
	};

	async function removeFromQueue(username) {
		await Promise.all([
			db.sortedSetRemove('registration:queue', username),
			db.delete(`registration:queue:name:${username}`),
		]);
	}

	User.shouldQueueUser = async function (ip) {
		const { registrationApprovalType } = meta.config;
		if (registrationApprovalType === 'admin-approval') {
			return true;
		} else if (registrationApprovalType === 'admin-approval-ip') {
			const count = await db.sortedSetCard(`ip:${ip}:uid`);
			return !!count;
		}
		return false;
	};

	User.getRegistrationQueue = async function (start, stop) {
		const data = await db.getSortedSetRevRangeWithScores('registration:queue', start, stop);
		const keys = data.filter(Boolean).map(user => `registration:queue:name:${user.value}`);
		let users = await db.getObjects(keys);
		users = users.filter(Boolean).map((user, index) => {
			user.timestampISO = utils.toISOString(data[index].score);
			user.email = validator.escape(String(user.email));
			user.usernameEscaped = validator.escape(String(user.username));
			delete user.hashedPassword;
			return user;
		});
		await Promise.all(users.map(async (user) => {
			// temporary: see http://www.stopforumspam.com/forum/viewtopic.php?id=6392
			// need to keep this for getIPMatchedUsers
			user.ip = user.ip.replace('::ffff:', '');
			await getIPMatchedUsers(user);
			user.customActions = [].concat(user.customActions);
			/*
				// then spam prevention plugins, using the "filter:user.getRegistrationQueue" hook can be like:
				user.customActions.push({
					title: '[[spam-be-gone:report-user]]',
					id: 'report-spam-user-' + user.username,
					class: 'btn-warning report-spam-user',
					icon: 'fa-flag'
				});
			 */
		}));

		const results = await plugins.hooks.fire('filter:user.getRegistrationQueue', { users: users });
		return results.users;
	};

	async function getIPMatchedUsers(user) {
		const uids = await User.getUidsFromSet(`ip:${user.ip}:uid`, 0, -1);
		user.ipMatch = await User.getUsersFields(uids, ['uid', 'username', 'picture']);
	}

	User.autoApprove = async function () {
		if (meta.config.autoApproveTime <= 0) {
			return;
		}
		const users = await db.getSortedSetRevRangeWithScores('registration:queue', 0, -1);
		const now = Date.now();
		for (const user of users.filter(user => now - user.score >= meta.config.autoApproveTime * 3600000)) {
			// eslint-disable-next-line no-await-in-loop
			await User.acceptRegistration(user.value);
		}
'use strict';

const fs = require('fs');
const path = require('path');
const winston = require('winston');

const db = require('../database');
const file = require('../file');
const { paths } = require('../constants');

const Data = module.exports;

const basePath = path.join(__dirname, '../../');

Data.getPluginPaths = async function () {
	let plugins = await db.getSortedSetRange('plugins:active', 0, -1);
	plugins = plugins.filter(plugin => plugin && typeof plugin === 'string')
		.map(plugin => path.join(paths.nodeModules, plugin));

	const exists = await Promise.all(plugins.map(p => file.exists(p)));
	return plugins.filter((p, i) => exists[i]);
};

Data.loadPluginInfo = async function (pluginPath) {
	const [packageJson, pluginJson] = await Promise.all([
		fs.promises.readFile(path.join(pluginPath, 'package.json'), 'utf8'),
		fs.promises.readFile(path.join(pluginPath, 'plugin.json'), 'utf8'),
	]);

	let pluginData;
	let packageData;
	try {
		pluginData = JSON.parse(pluginJson);
		packageData = JSON.parse(packageJson);

		pluginData.license = parseLicense(packageData);

		pluginData.id = packageData.name;
		pluginData.name = packageData.name;
		pluginData.description = packageData.description;
		pluginData.version = packageData.version;
		pluginData.repository = packageData.repository;
		pluginData.nbbpm = packageData.nbbpm;
		pluginData.path = pluginPath;
	} catch (err) {
		const pluginDir = path.basename(pluginPath);

		winston.error(`[plugins/${pluginDir}] Error in plugin.json or package.json!${err.stack}`);
		throw new Error('[[error:parse-error]]');
	}
	return pluginData;
};

function parseLicense(packageData) {
	try {
		const licenseData = require(`spdx-license-list/licenses/${packageData.license}`);
		return {
			name: licenseData.name,
			text: licenseData.licenseText,
		};
	} catch (e) {
		// No license matched
		return null;
	}
}

Data.getActive = async function () {
	const pluginPaths = await Data.getPluginPaths();
	return await Promise.all(pluginPaths.map(p => Data.loadPluginInfo(p)));
};


Data.getStaticDirectories = async function (pluginData) {
	const validMappedPath = /^[\w\-_]+$/;

	if (!pluginData.staticDirs) {
		return;
	}

	const dirs = Object.keys(pluginData.staticDirs);
	if (!dirs.length) {
		return;
	}

	const staticDirs = {};

	async function processDir(route) {
		if (!validMappedPath.test(route)) {
			winston.warn(`[plugins/${pluginData.id}] Invalid mapped path specified: ${
				route}. Path must adhere to: ${validMappedPath.toString()}`);
			return;
		}

		const dirPath = path.join(pluginData.path, pluginData.staticDirs[route]);
		try {
			const stats = await fs.promises.stat(dirPath);
			if (!stats.isDirectory()) {
				winston.warn(`[plugins/${pluginData.id}] Mapped path '${
					route} => ${dirPath}' is not a directory.`);
				return;
			}

			staticDirs[`${pluginData.id}/${route}`] = dirPath;
		} catch (err) {
			if (err.code === 'ENOENT') {
				winston.warn(`[plugins/${pluginData.id}] Mapped path '${
					route} => ${dirPath}' not found.`);
				return;
			}
			throw err;
		}
	}

	await Promise.all(dirs.map(route => processDir(route)));
	winston.verbose(`[plugins] found ${Object.keys(staticDirs).length
	} static directories for ${pluginData.id}`);
	return staticDirs;
};


Data.getFiles = async function (pluginData, type) {
	if (!Array.isArray(pluginData[type]) || !pluginData[type].length) {
		return;
	}

	winston.verbose(`[plugins] Found ${pluginData[type].length} ${type} file(s) for plugin ${pluginData.id}`);

	return pluginData[type].map(file => path.join(pluginData.id, file));
};

/**
 * With npm@3, dependencies can become flattened, and appear at the root level.
 * This method resolves these differences if it can.
 */
async function resolveModulePath(basePath, modulePath) {
	const isNodeModule = /node_modules/;

	const currentPath = path.join(basePath, modulePath);
	const exists = await file.exists(currentPath);
	if (exists) {
		return currentPath;
	}
	if (!isNodeModule.test(modulePath)) {
		winston.warn(`[plugins] File not found: ${currentPath} (Ignoring)`);
		return;
	}

	const dirPath = path.dirname(basePath);
	if (dirPath === basePath) {
		winston.warn(`[plugins] File not found: ${currentPath} (Ignoring)`);
		return;
	}

	return await resolveModulePath(dirPath, modulePath);
}


Data.getScripts = async function getScripts(pluginData, target) {
	target = (target === 'client') ? 'scripts' : 'acpScripts';

	const input = pluginData[target];
	if (!Array.isArray(input) || !input.length) {
		return;
	}

	const scripts = [];

	for (const filePath of input) {
		/* eslint-disable no-await-in-loop */
		const modulePath = await resolveModulePath(pluginData.path, filePath);
		if (modulePath) {
			scripts.push(modulePath);
		}
	}
	if (scripts.length) {
		winston.verbose(`[plugins] Found ${scripts.length} js file(s) for plugin ${pluginData.id}`);
	}
	return scripts;
};


Data.getModules = async function getModules(pluginData) {
	if (!pluginData.modules || !pluginData.hasOwnProperty('modules')) {
		return;
	}

	let pluginModules = pluginData.modules;

	if (Array.isArray(pluginModules)) {
		const strip = parseInt(pluginData.modulesStrip, 10) || 0;

		pluginModules = pluginModules.reduce((prev, modulePath) => {
			let key;
			if (strip) {
				key = modulePath.replace(new RegExp(`.?(/[^/]+){${strip}}/`), '');
			} else {
				key = path.basename(modulePath);
			}

			prev[key] = modulePath;
			return prev;
		}, {});
	}

	const modules = {};
	async function processModule(key) {
		const modulePath = await resolveModulePath(pluginData.path, pluginModules[key]);
		if (modulePath) {
			modules[key] = path.relative(basePath, modulePath);
		}
	}

	await Promise.all(Object.keys(pluginModules).map(key => processModule(key)));

	const len = Object.keys(modules).length;
	winston.verbose(`[plugins] Found ${len} AMD-style module(s) for plugin ${pluginData.id}`);
	return modules;
};

Data.getLanguageData = async function getLanguageData(pluginData) {
	if (typeof pluginData.languages !== 'string') {
		return;
	}

	const pathToFolder = path.join(paths.nodeModules, pluginData.id, pluginData.languages);
	const filepaths = await file.walk(pathToFolder);

	const namespaces = [];
	const languages = [];

	filepaths.forEach((p) => {
		const rel = path.relative(pathToFolder, p).split(/[/\\]/);
		const language = rel.shift().replace('_', '-').replace('@', '-x-');
		const namespace = rel.join('/').replace(/\.json$/, '');

		if (!language || !namespace) {
			return;
		}

		languages.push(language);
		namespaces.push(namespace);
	});

	return {
		languages,
'use strict';

const nconf = require('nconf');
const request = require('request');
const winston = require('winston');
const crypto = require('crypto');
const cronJob = require('cron').CronJob;

const pkg = require('../../package.json');

const meta = require('../meta');

module.exports = function (Plugins) {
	Plugins.startJobs = function () {
		new cronJob('0 0 0 * * *', (() => {
			Plugins.submitUsageData();
		}), null, true);
	};

	Plugins.submitUsageData = function () {
		if (!meta.config.submitPluginUsage || !Plugins.loadedPlugins.length || global.env !== 'production') {
			return;
		}

		const hash = crypto.createHash('sha256');
		hash.update(nconf.get('url'));
		request.post(`${nconf.get('registry') || 'https://packages.nodebb.org'}/api/v1/plugin/usage`, {
			form: {
				id: hash.digest('hex'),
				version: pkg.version,
				plugins: Plugins.loadedPlugins,
			},
			timeout: 5000,
		}, (err, res, body) => {
			if (err) {
				return winston.error(err.stack);
			}
			if (res.statusCode !== 200) {
				winston.error(`[plugins.submitUsageData] received ${res.statusCode} ${body}`);
			}
'use strict';

const winston = require('winston');
const async = require('async');
const utils = require('../utils');
const plugins = require('.');

const Hooks = module.exports;

Hooks.deprecatedHooks = {
	'filter:router.page': 'response:router.page',	// 👋 @ 2.0.0
};

Hooks.internals = {
	_register: function (data) {
		plugins.loadedHooks[data.hook] = plugins.loadedHooks[data.hook] || [];
		plugins.loadedHooks[data.hook].push(data);
	},
};

const hookTypeToMethod = {
	filter: fireFilterHook,
	action: fireActionHook,
	static: fireStaticHook,
	response: fireResponseHook,
};

/*
	`data` is an object consisting of (* is required):
		`data.hook`*, the name of the NodeBB hook
		`data.method`*, the method called in that plugin (can be an array of functions)
		`data.priority`, the relative priority of the method when it is eventually called (default: 10)
*/
Hooks.register = function (id, data) {
	if (!data.hook || !data.method) {
		winston.warn(`[plugins/${id}] registerHook called with invalid data.hook/method`, data);
		return;
	}

	// `hasOwnProperty` needed for hooks with no alternative (set to null)
	if (Hooks.deprecatedHooks.hasOwnProperty(data.hook)) {
		const deprecated = Hooks.deprecatedHooks[data.hook];

		if (deprecated) {
			winston.warn(`[plugins/${id}] Hook "${data.hook}" is deprecated, please use "${deprecated}" instead.`);
		} else {
			winston.warn(`[plugins/${id}] Hook "${data.hook}" is deprecated, there is no alternative.`);
		}
	}

	data.id = id;
	if (!data.priority) {
		data.priority = 10;
	}

	if (Array.isArray(data.method) && data.method.every(method => typeof method === 'function' || typeof method === 'string')) {
		// Go go gadget recursion!
		data.method.forEach((method) => {
			const singularData = { ...data, method: method };
			Hooks.register(id, singularData);
		});
	} else if (typeof data.method === 'string' && data.method.length > 0) {
		const method = data.method.split('.').reduce((memo, prop) => {
			if (memo && memo[prop]) {
				return memo[prop];
			}
			// Couldn't find method by path, aborting
			return null;
		}, plugins.libraries[data.id]);

		// Write the actual method reference to the hookObj
		data.method = method;

		Hooks.internals._register(data);
	} else if (typeof data.method === 'function') {
		Hooks.internals._register(data);
	} else {
		winston.warn(`[plugins/${id}] Hook method mismatch: ${data.hook} => ${data.method}`);
	}
};

Hooks.unregister = function (id, hook, method) {
	const hooks = plugins.loadedHooks[hook] || [];
	plugins.loadedHooks[hook] = hooks.filter(hookData => hookData && hookData.id !== id && hookData.method !== method);
};

Hooks.fire = async function (hook, params) {
	const hookList = plugins.loadedHooks[hook];
	const hookType = hook.split(':')[0];
	if (global.env === 'development' && hook !== 'action:plugins.firehook') {
		winston.verbose(`[plugins/fireHook] ${hook}`);
	}

	if (!hookTypeToMethod[hookType]) {
		winston.warn(`[plugins] Unknown hookType: ${hookType}, hook : ${hook}`);
		return;
	}
	const result = await hookTypeToMethod[hookType](hook, hookList, params);

	if (hook !== 'action:plugins.firehook') {
		Hooks.fire('action:plugins.firehook', { hook: hook, params: params });
	}
	if (result !== undefined) {
		return result;
	}
};

Hooks.hasListeners = function (hook) {
	return !!(plugins.loadedHooks[hook] && plugins.loadedHooks[hook].length > 0);
};

async function fireFilterHook(hook, hookList, params) {
	if (!Array.isArray(hookList) || !hookList.length) {
		return params;
	}

	return await async.reduce(hookList, params, (params, hookObj, next) => {
		if (typeof hookObj.method !== 'function') {
			if (global.env === 'development') {
				winston.warn(`[plugins] Expected method for hook '${hook}' in plugin '${hookObj.id}' not found, skipping.`);
			}
			return next(null, params);
		}
		const returned = hookObj.method(params, next);
		if (utils.isPromise(returned)) {
			returned.then(
				payload => setImmediate(next, null, payload),
				err => setImmediate(next, err)
			);
		}
	});
}

async function fireActionHook(hook, hookList, params) {
	if (!Array.isArray(hookList) || !hookList.length) {
		return;
	}
	for (const hookObj of hookList) {
		if (typeof hookObj.method !== 'function') {
			if (global.env === 'development') {
				winston.warn(`[plugins] Expected method for hook '${hook}' in plugin '${hookObj.id}' not found, skipping.`);
			}
		} else {
			/* eslint-disable no-await-in-loop */
			await hookObj.method(params);
		}
	}
}

async function fireStaticHook(hook, hookList, params) {
	if (!Array.isArray(hookList) || !hookList.length) {
		return;
	}
	// don't bubble errors from these hooks, so bad plugins don't stop startup
	const noErrorHooks = ['static:app.load', 'static:assets.prepare', 'static:app.preload'];
	await async.each(hookList, (hookObj, next) => {
		if (typeof hookObj.method !== 'function') {
			return next();
		}

		let timedOut = false;
		const timeoutId = setTimeout(() => {
			winston.warn(`[plugins] Callback timed out, hook '${hook}' in plugin '${hookObj.id}'`);
			timedOut = true;
			next();
		}, 5000);

		const callback = (err) => {
			clearTimeout(timeoutId);
			if (err) {
				winston.error(`[plugins] Error executing '${hook}' in plugin '${hookObj.id}'`);
				winston.error(err.stack);
			}
			if (!timedOut) {
				next(noErrorHooks.includes(hook) ? null : err);
			}
		};
		try {
			const returned = hookObj.method(params, callback);
			if (utils.isPromise(returned)) {
				returned.then(
					payload => setImmediate(callback, null, payload),
					err => setImmediate(callback, err)
				);
			}
		} catch (err) {
			callback(err);
		}
	});
}

async function fireResponseHook(hook, hookList, params) {
	if (!Array.isArray(hookList) || !hookList.length) {
		return;
	}
	await async.eachSeries(hookList, async (hookObj) => {
		if (typeof hookObj.method !== 'function') {
			if (global.env === 'development') {
				winston.warn(`[plugins] Expected method for hook '${hook}' in plugin '${hookObj.id}' not found, skipping.`);
			}
			return;
		}

		// Skip remaining hooks if headers have been sent
		if (params.res.headersSent) {
			return;
		}

		await hookObj.method(params);
	});
'use strict';

const fs = require('fs');
const os = require('os');
const path = require('path');
const async = require('async');
const winston = require('winston');
const semver = require('semver');
const nconf = require('nconf');
const request = require('request-promise-native');

const user = require('../user');
const posts = require('../posts');
const meta = require('../meta');

const { pluginNamePattern, themeNamePattern, paths } = require('../constants');

let app;
let middleware;

const Plugins = module.exports;

require('./install')(Plugins);
require('./load')(Plugins);
require('./usage')(Plugins);
Plugins.data = require('./data');
Plugins.hooks = require('./hooks');

// Backwards compatibility for hooks, remove in v1.18.0
const _deprecate = async function (...args) {
	const oldMethod = args.shift();
	const newMethod = args.shift();
	const method = args.shift();
	const stack = new Error().stack.toString().split(os.EOL);
	const context = stack[stack.findIndex(line => line.startsWith('    at Object.wrapperCallback')) + 1];
	winston.warn(`[plugins/hooks] ${oldMethod} has been deprecated, call ${newMethod} instead.`);
	winston.warn(`[plugins/hooks] ${context}`);
	return method.apply(Plugins.hooks, args);
};
Plugins.registerHook = _deprecate.bind(null, 'Plugins.registerHook', 'Plugins.hooks.register', Plugins.hooks.register);
Plugins.unregisterHook = _deprecate.bind(null, 'Plugins.unregisterHook', 'Plugins.hooks.unregister', Plugins.hooks.unregister);
Plugins.fireHook = _deprecate.bind(null, 'Plugins.fireHook', 'Plugins.hooks.fire', Plugins.hooks.fire);
Plugins.hasListeners = _deprecate.bind(null, 'Plugins.hasListeners', 'Plugins.hooks.hasListeners', Plugins.hooks.hasListeners);
// end

Plugins.getPluginPaths = Plugins.data.getPluginPaths;
Plugins.loadPluginInfo = Plugins.data.loadPluginInfo;

Plugins.pluginsData = {};
Plugins.libraries = {};
Plugins.loadedHooks = {};
Plugins.staticDirs = {};
Plugins.cssFiles = [];
Plugins.lessFiles = [];
Plugins.acpLessFiles = [];
Plugins.clientScripts = [];
Plugins.acpScripts = [];
Plugins.libraryPaths = [];
Plugins.versionWarning = [];
Plugins.languageData = {};
Plugins.loadedPlugins = [];

Plugins.initialized = false;

Plugins.requireLibrary = function (pluginData) {
	let libraryPath;
	// attempt to load a plugin directly with `require("nodebb-plugin-*")`
	// Plugins should define their entry point in the standard `main` property of `package.json`
	try {
		libraryPath = pluginData.path;
		Plugins.libraries[pluginData.id] = require(libraryPath);
	} catch (e) {
		// DEPRECATED: @1.15.0, remove in version >=1.17
		// for backwards compatibility
		// if that fails, fall back to `pluginData.library`
		if (pluginData.library) {
			winston.warn(`   [plugins/${pluginData.id}] The plugin.json field "library" is deprecated. Please use the package.json field "main" instead.`);
			winston.verbose(`[plugins/${pluginData.id}] See https://github.com/NodeBB/NodeBB/issues/8686`);

			libraryPath = path.join(pluginData.path, pluginData.library);
			Plugins.libraries[pluginData.id] = require(libraryPath);
		} else {
			throw e;
		}
	}

	Plugins.libraryPaths.push(libraryPath);
};

Plugins.init = async function (nbbApp, nbbMiddleware) {
	if (Plugins.initialized) {
		return;
	}

	if (nbbApp) {
		app = nbbApp;
		middleware = nbbMiddleware;
	}

	if (global.env === 'development') {
		winston.verbose('[plugins] Initializing plugins system');
	}

	await Plugins.reload();
	if (global.env === 'development') {
		winston.info('[plugins] Plugins OK');
	}

	Plugins.initialized = true;
};

Plugins.reload = async function () {
	// Resetting all local plugin data
	Plugins.libraries = {};
	Plugins.loadedHooks = {};
	Plugins.staticDirs = {};
	Plugins.versionWarning = [];
	Plugins.cssFiles.length = 0;
	Plugins.lessFiles.length = 0;
	Plugins.acpLessFiles.length = 0;
	Plugins.clientScripts.length = 0;
	Plugins.acpScripts.length = 0;
	Plugins.libraryPaths.length = 0;
	Plugins.loadedPlugins.length = 0;

	await user.addInterstitials();

	const paths = await Plugins.getPluginPaths();
	for (const path of paths) {
		/* eslint-disable no-await-in-loop */
		await Plugins.loadPlugin(path);
	}

	// If some plugins are incompatible, throw the warning here
	if (Plugins.versionWarning.length && nconf.get('isPrimary')) {
		console.log('');
		winston.warn('[plugins/load] The following plugins may not be compatible with your version of NodeBB. This may cause unintended behaviour or crashing. In the event of an unresponsive NodeBB caused by this plugin, run `./nodebb reset -p PLUGINNAME` to disable it.');
		for (let x = 0, numPlugins = Plugins.versionWarning.length; x < numPlugins; x += 1) {
			console.log('  * '.yellow + Plugins.versionWarning[x]);
		}
		console.log('');
	}

	// Core hooks
	posts.registerHooks();
	meta.configs.registerHooks();

	// Lower priority runs earlier
	Object.keys(Plugins.loadedHooks).forEach((hook) => {
		Plugins.loadedHooks[hook].sort((a, b) => a.priority - b.priority);
	});

	// Post-reload actions
	await posts.configureSanitize();
};

Plugins.reloadRoutes = async function (params) {
	const controllers = require('../controllers');
	await Plugins.hooks.fire('static:app.load', { app: app, router: params.router, middleware: middleware, controllers: controllers });
	winston.verbose('[plugins] All plugins reloaded and rerouted');
};

Plugins.get = async function (id) {
	const url = `${nconf.get('registry') || 'https://packages.nodebb.org'}/api/v1/plugins/${id}`;
	const body = await request(url, {
		json: true,
	});

	let normalised = await Plugins.normalise([body ? body.payload : {}]);
	normalised = normalised.filter(plugin => plugin.id === id);
	return normalised.length ? normalised[0] : undefined;
};

Plugins.list = async function (matching) {
	if (matching === undefined) {
		matching = true;
	}
	const { version } = require(paths.currentPackage);
	const url = `${nconf.get('registry') || 'https://packages.nodebb.org'}/api/v1/plugins${matching !== false ? `?version=${version}` : ''}`;
	try {
		const body = await request(url, {
			json: true,
		});
		return await Plugins.normalise(body);
	} catch (err) {
		winston.error(`Error loading ${url}`, err);
		return await Plugins.normalise([]);
	}
};

Plugins.listTrending = async () => {
	const url = `${nconf.get('registry') || 'https://packages.nodebb.org'}/api/v1/analytics/top/week`;
	return await request(url, {
		json: true,
	});
};

Plugins.normalise = async function (apiReturn) {
	const pluginMap = {};
	const { dependencies } = require(paths.currentPackage);
	apiReturn = Array.isArray(apiReturn) ? apiReturn : [];
	apiReturn.forEach((packageData) => {
		packageData.id = packageData.name;
		packageData.installed = false;
		packageData.active = false;
		packageData.url = packageData.url || (packageData.repository ? packageData.repository.url : '');
		pluginMap[packageData.name] = packageData;
	});

	let installedPlugins = await Plugins.showInstalled();
	installedPlugins = installedPlugins.filter(plugin => plugin && !plugin.system);

	installedPlugins.forEach((plugin) => {
		// If it errored out because a package.json or plugin.json couldn't be read, no need to do this stuff
		if (plugin.error) {
			pluginMap[plugin.id] = pluginMap[plugin.id] || {};
			pluginMap[plugin.id].installed = true;
			pluginMap[plugin.id].error = true;
			return;
		}

		pluginMap[plugin.id] = pluginMap[plugin.id] || {};
		pluginMap[plugin.id].id = pluginMap[plugin.id].id || plugin.id;
		pluginMap[plugin.id].name = plugin.name || pluginMap[plugin.id].name;
		pluginMap[plugin.id].description = plugin.description;
		pluginMap[plugin.id].url = pluginMap[plugin.id].url || plugin.url;
		pluginMap[plugin.id].installed = true;
		pluginMap[plugin.id].isTheme = themeNamePattern.test(plugin.id);
		pluginMap[plugin.id].error = plugin.error || false;
		pluginMap[plugin.id].active = plugin.active;
		pluginMap[plugin.id].version = plugin.version;
		pluginMap[plugin.id].settingsRoute = plugin.settingsRoute;
		pluginMap[plugin.id].license = plugin.license;

		// If package.json defines a version to use, stick to that
		if (dependencies.hasOwnProperty(plugin.id) && semver.valid(dependencies[plugin.id])) {
			pluginMap[plugin.id].latest = dependencies[plugin.id];
		} else {
			pluginMap[plugin.id].latest = pluginMap[plugin.id].latest || plugin.version;
		}
		pluginMap[plugin.id].outdated = semver.gt(pluginMap[plugin.id].latest, pluginMap[plugin.id].version);
	});

	const pluginArray = Object.values(pluginMap);

	pluginArray.sort((a, b) => {
		if (a.name > b.name) {
			return 1;
		} else if (a.name < b.name) {
			return -1;
		}
		return 0;
	});

	return pluginArray;
};

Plugins.nodeModulesPath = paths.nodeModules;

Plugins.showInstalled = async function () {
	const dirs = await fs.promises.readdir(Plugins.nodeModulesPath);

	let pluginPaths = await findNodeBBModules(dirs);
	pluginPaths = pluginPaths.map(dir => path.join(Plugins.nodeModulesPath, dir));

	async function load(file) {
		try {
			const pluginData = await Plugins.loadPluginInfo(file);
			const isActive = await Plugins.isActive(pluginData.name);
			delete pluginData.hooks;
			delete pluginData.library;
			pluginData.active = isActive;
			pluginData.installed = true;
			pluginData.error = false;
			return pluginData;
		} catch (err) {
			winston.error(err.stack);
		}
	}
	const plugins = await Promise.all(pluginPaths.map(file => load(file)));
	return plugins.filter(Boolean);
};

async function findNodeBBModules(dirs) {
	const pluginPaths = [];
	await async.each(dirs, (dirname, next) => {
		const dirPath = path.join(Plugins.nodeModulesPath, dirname);

		async.waterfall([
			function (cb) {
				fs.stat(dirPath, (err, stats) => {
					if (err && err.code !== 'ENOENT') {
						return cb(err);
					}
					if (err || !stats.isDirectory()) {
						return next();
					}

					if (pluginNamePattern.test(dirname)) {
						pluginPaths.push(dirname);
						return next();
					}

					if (dirname[0] !== '@') {
						return next();
					}
					fs.readdir(dirPath, cb);
				});
			},
			function (subdirs, cb) {
				async.each(subdirs, (subdir, next) => {
					if (!pluginNamePattern.test(subdir)) {
						return next();
					}

					const subdirPath = path.join(dirPath, subdir);
					fs.stat(subdirPath, (err, stats) => {
						if (err && err.code !== 'ENOENT') {
							return next(err);
						}

						if (err || !stats.isDirectory()) {
							return next();
						}

						pluginPaths.push(`${dirname}/${subdir}`);
						next();
					});
				}, cb);
			},
		], next);
	});
	return pluginPaths;
}

'use strict';

const semver = require('semver');
const async = require('async');
const winston = require('winston');
const nconf = require('nconf');
const _ = require('lodash');

const meta = require('../meta');
const { themeNamePattern } = require('../constants');

module.exports = function (Plugins) {
	async function registerPluginAssets(pluginData, fields) {
		function add(dest, arr) {
			dest.push(...(arr || []));
		}

		const handlers = {
			staticDirs: function (next) {
				Plugins.data.getStaticDirectories(pluginData, next);
			},
			cssFiles: function (next) {
				Plugins.data.getFiles(pluginData, 'css', next);
			},
			lessFiles: function (next) {
				Plugins.data.getFiles(pluginData, 'less', next);
			},
			acpLessFiles: function (next) {
				Plugins.data.getFiles(pluginData, 'acpLess', next);
			},
			clientScripts: function (next) {
				Plugins.data.getScripts(pluginData, 'client', next);
			},
			acpScripts: function (next) {
				Plugins.data.getScripts(pluginData, 'acp', next);
			},
			modules: function (next) {
				Plugins.data.getModules(pluginData, next);
			},
			languageData: function (next) {
				Plugins.data.getLanguageData(pluginData, next);
			},
		};

		let methods = {};
		if (Array.isArray(fields)) {
			fields.forEach((field) => {
				methods[field] = handlers[field];
			});
		} else {
			methods = handlers;
		}

		const results = await async.parallel(methods);

		Object.assign(Plugins.staticDirs, results.staticDirs || {});
		add(Plugins.cssFiles, results.cssFiles);
		add(Plugins.lessFiles, results.lessFiles);
		add(Plugins.acpLessFiles, results.acpLessFiles);
		add(Plugins.clientScripts, results.clientScripts);
		add(Plugins.acpScripts, results.acpScripts);
		Object.assign(meta.js.scripts.modules, results.modules || {});
		if (results.languageData) {
			Plugins.languageData.languages = _.union(Plugins.languageData.languages, results.languageData.languages);
			Plugins.languageData.namespaces = _.union(Plugins.languageData.namespaces, results.languageData.namespaces);
		}
		Plugins.pluginsData[pluginData.id] = pluginData;
	}

	Plugins.prepareForBuild = async function (targets) {
		const map = {
			'plugin static dirs': ['staticDirs'],
			'requirejs modules': ['modules'],
			'client js bundle': ['clientScripts'],
			'admin js bundle': ['acpScripts'],
			'client side styles': ['cssFiles', 'lessFiles'],
			'admin control panel styles': ['cssFiles', 'lessFiles', 'acpLessFiles'],
			languages: ['languageData'],
		};

		const fields = _.uniq(_.flatMap(targets, target => map[target] || []));

		// clear old data before build
		fields.forEach((field) => {
			switch (field) {
				case 'clientScripts':
				case 'acpScripts':
				case 'cssFiles':
				case 'lessFiles':
				case 'acpLessFiles':
					Plugins[field].length = 0;
					break;
				case 'languageData':
					Plugins.languageData.languages = [];
					Plugins.languageData.namespaces = [];
					break;
			// do nothing for modules and staticDirs
			}
		});

		winston.verbose(`[plugins] loading the following fields from plugin data: ${fields.join(', ')}`);
		const plugins = await Plugins.data.getActive();
		await Promise.all(plugins.map(p => registerPluginAssets(p, fields)));
	};

	Plugins.loadPlugin = async function (pluginPath) {
		let pluginData;
		try {
			pluginData = await Plugins.data.loadPluginInfo(pluginPath);
		} catch (err) {
			if (err.message === '[[error:parse-error]]') {
				return;
			}
			if (!themeNamePattern.test(pluginPath)) {
				throw err;
			}
			return;
		}
		checkVersion(pluginData);

		try {
			registerHooks(pluginData);
			await registerPluginAssets(pluginData);
		} catch (err) {
			winston.error(err.stack);
			winston.verbose(`[plugins] Could not load plugin : ${pluginData.id}`);
			return;
		}

		if (!pluginData.private) {
			Plugins.loadedPlugins.push({
				id: pluginData.id,
				version: pluginData.version,
			});
		}

		winston.verbose(`[plugins] Loaded plugin: ${pluginData.id}`);
	};

	function checkVersion(pluginData) {
		function add() {
			if (!Plugins.versionWarning.includes(pluginData.id)) {
				Plugins.versionWarning.push(pluginData.id);
			}
		}

		if (pluginData.nbbpm && pluginData.nbbpm.compatibility && semver.validRange(pluginData.nbbpm.compatibility)) {
			if (!semver.satisfies(nconf.get('version'), pluginData.nbbpm.compatibility)) {
				add();
			}
		} else {
			add();
		}
	}

	function registerHooks(pluginData) {
		try {
			if (!Plugins.libraries[pluginData.id]) {
				Plugins.requireLibrary(pluginData);
			}

			if (Array.isArray(pluginData.hooks)) {
				pluginData.hooks.forEach(hook => Plugins.hooks.register(pluginData.id, hook));
			}
		} catch (err) {
'use strict';

const winston = require('winston');
const path = require('path');
const fs = require('fs');
const nconf = require('nconf');
const os = require('os');
const cproc = require('child_process');
const util = require('util');
const request = require('request-promise-native');

const db = require('../database');
const meta = require('../meta');
const pubsub = require('../pubsub');
const { paths } = require('../constants');

const supportedPackageManagerList = require('../cli/package-install').supportedPackageManager;
// load config from src/cli/package-install.js
const packageManager = supportedPackageManagerList.indexOf(nconf.get('package_manager')) >= 0 ? nconf.get('package_manager') : 'npm';
let packageManagerExecutable = packageManager;
const packageManagerCommands = {
	yarn: {
		install: 'add',
		uninstall: 'remove',
	},
	npm: {
		install: 'install',
		uninstall: 'uninstall',
	},
	cnpm: {
		install: 'install',
		uninstall: 'uninstall',
	},
	pnpm: {
		install: 'install',
		uninstall: 'uninstall',
	},
};

if (process.platform === 'win32') {
	packageManagerExecutable += '.cmd';
}

module.exports = function (Plugins) {
	if (nconf.get('isPrimary')) {
		pubsub.on('plugins:toggleInstall', (data) => {
			if (data.hostname !== os.hostname()) {
				toggleInstall(data.id, data.version);
			}
		});

		pubsub.on('plugins:upgrade', (data) => {
			if (data.hostname !== os.hostname()) {
				upgrade(data.id, data.version);
			}
		});
	}

	Plugins.toggleActive = async function (id) {
		const isActive = await Plugins.isActive(id);
		if (isActive) {
			await db.sortedSetRemove('plugins:active', id);
		} else {
			const count = await db.sortedSetCard('plugins:active');
			await db.sortedSetAdd('plugins:active', count, id);
		}
		meta.reloadRequired = true;
		Plugins.hooks.fire(isActive ? 'action:plugin.deactivate' : 'action:plugin.activate', { id: id });
		return { id: id, active: !isActive };
	};

	Plugins.checkWhitelist = async function (id, version) {
		const body = await request({
			method: 'GET',
			url: `https://packages.nodebb.org/api/v1/plugins/${encodeURIComponent(id)}`,
			json: true,
		});

		if (body && body.code === 'ok' && (version === 'latest' || body.payload.valid.includes(version))) {
			return;
		}

		throw new Error('[[error:plugin-not-whitelisted]]');
	};

	Plugins.toggleInstall = async function (id, version) {
		pubsub.publish('plugins:toggleInstall', { hostname: os.hostname(), id: id, version: version });
		return await toggleInstall(id, version);
	};

	const runPackageManagerCommandAsync = util.promisify(runPackageManagerCommand);

	async function toggleInstall(id, version) {
		const [installed, active] = await Promise.all([
			Plugins.isInstalled(id),
			Plugins.isActive(id),
		]);
		const type = installed ? 'uninstall' : 'install';
		if (active) {
			await Plugins.toggleActive(id);
		}
		await runPackageManagerCommandAsync(type, id, version || 'latest');
		const pluginData = await Plugins.get(id);
		Plugins.hooks.fire(`action:plugin.${type}`, { id: id, version: version });
		return pluginData;
	}

	function runPackageManagerCommand(command, pkgName, version, callback) {
		cproc.execFile(packageManagerExecutable, [
			packageManagerCommands[packageManager][command],
			pkgName + (command === 'install' ? `@${version}` : ''),
			'--save',
		], (err, stdout) => {
			if (err) {
				return callback(err);
			}

			winston.verbose(`[plugins/${command}] ${stdout}`);
			callback();
		});
	}


	Plugins.upgrade = async function (id, version) {
		pubsub.publish('plugins:upgrade', { hostname: os.hostname(), id: id, version: version });
		return await upgrade(id, version);
	};

	async function upgrade(id, version) {
		await runPackageManagerCommandAsync('install', id, version || 'latest');
		const isActive = await Plugins.isActive(id);
		meta.reloadRequired = isActive;
		return isActive;
	}

	Plugins.isInstalled = async function (id) {
		const pluginDir = path.join(paths.nodeModules, id);
		try {
			const stats = await fs.promises.stat(pluginDir);
			return stats.isDirectory();
		} catch (err) {
			return false;
		}
	};

	Plugins.isActive = async function (id) {
		return await db.isSortedSetMember('plugins:active', id);
	};

	Plugins.getActive = async function () {
'use strict';

const nconf = require('nconf');
const winston = require('winston');

const start = module.exports;

start.start = async function () {
	printStartupInfo();

	addProcessHandlers();

	try {
		const db = require('./database');
		await db.init();
		await db.checkCompatibility();

		const meta = require('./meta');
		await meta.configs.init();

		if (nconf.get('runJobs')) {
			await runUpgrades();
		}

		if (nconf.get('dep-check') === undefined || nconf.get('dep-check') !== false) {
			await meta.dependencies.check();
		} else {
			winston.warn('[init] Dependency checking skipped!');
		}

		await db.initSessionStore();

		const webserver = require('./webserver');
		const sockets = require('./socket.io');
		await sockets.init(webserver.server);

		if (nconf.get('runJobs')) {
			require('./notifications').startJobs();
			require('./user').startJobs();
			require('./plugins').startJobs();
			await db.delete('locks');
		}

		await webserver.listen();

		if (process.send) {
			process.send({
				action: 'listening',
			});
		}
	} catch (err) {
		switch (err.message) {
			case 'dependencies-out-of-date':
				winston.error('One or more of NodeBB\'s dependent packages are out-of-date. Please run the following command to update them:');
				winston.error('    ./nodebb upgrade');
				break;
			case 'dependencies-missing':
				winston.error('One or more of NodeBB\'s dependent packages are missing. Please run the following command to update them:');
				winston.error('    ./nodebb upgrade');
				break;
			default:
				winston.error(err.stack);
				break;
		}

		// Either way, bad stuff happened. Abort start.
		process.exit();
	}
};

async function runUpgrades() {
	const upgrade = require('./upgrade');
	try {
		await upgrade.check();
	} catch (err) {
		if (err && err.message === 'schema-out-of-date') {
			await upgrade.run();
		} else {
			throw err;
		}
	}
}

function printStartupInfo() {
	if (nconf.get('isPrimary')) {
		winston.info('Initializing NodeBB v%s %s', nconf.get('version'), nconf.get('url'));

		const host = nconf.get(`${nconf.get('database')}:host`);
		const storeLocation = host ? `at ${host}${!host.includes('/') ? `:${nconf.get(`${nconf.get('database')}:port`)}` : ''}` : '';

		winston.verbose('* using %s store %s', nconf.get('database'), storeLocation);
		winston.verbose('* using themes stored in: %s', nconf.get('themes_path'));
	}
}

function addProcessHandlers() {
	process.on('SIGTERM', shutdown);
	process.on('SIGINT', shutdown);
	process.on('SIGHUP', restart);
	process.on('uncaughtException', (err) => {
		winston.error(err.stack);

		require('./meta').js.killMinifier();
		shutdown(1);
	});
	process.on('message', (msg) => {
		if (msg && msg.compiling === 'tpl') {
			const benchpressjs = require('benchpressjs');
			benchpressjs.flush();
		} else if (msg && msg.compiling === 'lang') {
			const translator = require('./translator');
			translator.flush();
		}
	});
}

function restart() {
	if (process.send) {
		winston.info('[app] Restarting...');
		process.send({
			action: 'restart',
		});
	} else {
		winston.error('[app] Could not restart server. Shutting down.');
		shutdown(1);
	}
}

async function shutdown(code) {
	winston.info('[app] Shutdown (SIGTERM/SIGINT) Initialised.');
	try {
		await require('./webserver').destroy();
		winston.info('[app] Web server closed to connections.');
		await require('./analytics').writeData();
		winston.info('[app] Live analytics saved.');
		await require('./database').close();
		winston.info('[app] Database connection closed.');
		winston.info('[app] Shutdown complete.');
		process.exit(code || 0);
	} catch (err) {
'use strict';

const path = require('path');
const crypto = require('crypto');
const util = require('util');

const bcrypt = require('bcryptjs');

const fork = require('./meta/debugFork');

function forkChild(message, callback) {
	const child = fork(path.join(__dirname, 'password'));

	child.on('message', (msg) => {
		callback(msg.err ? new Error(msg.err) : null, msg.result);
	});

	child.send(message);
}

const forkChildAsync = util.promisify(forkChild);

exports.hash = async function (rounds, password) {
	password = crypto.createHash('sha512').update(password).digest('hex');
	return await forkChildAsync({ type: 'hash', rounds: rounds, password: password });
};

exports.compare = async function (password, hash, shaWrapped) {
	const fakeHash = await getFakeHash();

	if (shaWrapped) {
		password = crypto.createHash('sha512').update(password).digest('hex');
	}

	return await forkChildAsync({ type: 'compare', password: password, hash: hash || fakeHash });
};

let fakeHashCache;
async function getFakeHash() {
	if (fakeHashCache) {
		return fakeHashCache;
	}
	fakeHashCache = await exports.hash(12, Math.random().toString());
	return fakeHashCache;
}

// child process
process.on('message', (msg) => {
	if (msg.type === 'hash') {
		tryMethod(hashPassword, msg);
	} else if (msg.type === 'compare') {
		tryMethod(compare, msg);
	}
});

async function tryMethod(method, msg) {
	try {
		const result = await method(msg);
		process.send({ result: result });
	} catch (err) {
		process.send({ err: err.message });
	} finally {
		process.disconnect();
	}
}

async function hashPassword(msg) {
	const salt = await bcrypt.genSalt(parseInt(msg.rounds, 10));
	const hash = await bcrypt.hash(msg.password, salt);
	return hash;
}

async function compare(msg) {
	return await bcrypt.compare(String(msg.password || ''), String(msg.hash || ''));
}
'use strict';

/*
 * Logger module: ability to dynamically turn on/off logging for http requests & socket.io events
 */

const fs = require('fs');
const path = require('path');
const winston = require('winston');
const util = require('util');
const morgan = require('morgan');

const file = require('./file');
const meta = require('./meta');


const opts = {
	/*
	 * state used by Logger
	 */
	express: {
		app: {},
		set: 0,
		ofn: null,
	},
	streams: {
		log: { f: process.stdout },
	},
};

/* -- Logger -- */
const Logger = module.exports;

Logger.init = function (app) {
	opts.express.app = app;
	/* Open log file stream & initialize express logging if meta.config.logger* variables are set */
	Logger.setup();
};

Logger.setup = function () {
	Logger.setup_one('loggerPath', meta.config.loggerPath);
};

Logger.setup_one = function (key, value) {
	/*
	 * 1. Open the logger stream: stdout or file
	 * 2. Re-initialize the express logger hijack
	 */
	if (key === 'loggerPath') {
		Logger.setup_one_log(value);
		Logger.express_open();
	}
};

Logger.setup_one_log = function (value) {
	/*
	 * If logging is currently enabled, create a stream.
	 * Otherwise, close the current stream
	 */
	if (meta.config.loggerStatus > 0 || meta.config.loggerIOStatus) {
		const stream = Logger.open(value);
		if (stream) {
			opts.streams.log.f = stream;
		} else {
			opts.streams.log.f = process.stdout;
		}
	} else {
		Logger.close(opts.streams.log);
	}
};

Logger.open = function (value) {
	/* Open the streams to log to: either a path or stdout */
	let stream;
	if (value) {
		if (file.existsSync(value)) {
			const stats = fs.statSync(value);
			if (stats) {
				if (stats.isDirectory()) {
					stream = fs.createWriteStream(path.join(value, 'nodebb.log'), { flags: 'a' });
				} else {
					stream = fs.createWriteStream(value, { flags: 'a' });
				}
			}
		} else {
			stream = fs.createWriteStream(value, { flags: 'a' });
		}

		if (stream) {
			stream.on('error', (err) => {
				winston.error(err.stack);
			});
		}
	} else {
		stream = process.stdout;
	}
	return stream;
};

Logger.close = function (stream) {
	if (stream.f !== process.stdout && stream.f) {
		stream.end();
	}
	stream.f = null;
};

Logger.monitorConfig = function (socket, data) {
	/*
	 * This monitor's when a user clicks "save" in the Logger section of the admin panel
	 */
	Logger.setup_one(data.key, data.value);
	Logger.io_close(socket);
	Logger.io(socket);
};

Logger.express_open = function () {
	if (opts.express.set !== 1) {
		opts.express.set = 1;
		opts.express.app.use(Logger.expressLogger);
	}
	/*
	 * Always initialize "ofn" (original function) with the original logger function
	 */
	opts.express.ofn = morgan('combined', { stream: opts.streams.log.f });
};

Logger.expressLogger = function (req, res, next) {
	/*
	 * The new express.logger
	 *
	 * This hijack allows us to turn logger on/off dynamically within express
	 */
	if (meta.config.loggerStatus > 0) {
		return opts.express.ofn(req, res, next);
	}
	return next();
};

Logger.prepare_io_string = function (_type, _uid, _args) {
	/*
	 * This prepares the output string for intercepted socket.io events
	 *
	 * The format is: io: <uid> <event> <args>
	 */
	try {
		return `io: ${_uid} ${_type} ${util.inspect(Array.prototype.slice.call(_args), { depth: 3 })}\n`;
	} catch (err) {
		winston.info('Logger.prepare_io_string: Failed', err);
		return 'error';
	}
};

Logger.io_close = function (socket) {
	/*
	 * Restore all hijacked sockets to their original emit/on functions
	 */
	if (!socket || !socket.io || !socket.io.sockets || !socket.io.sockets.sockets) {
		return;
	}

	const clientsMap = socket.io.sockets.sockets;

	for (const [, client] of clientsMap) {
		if (client.oEmit && client.oEmit !== client.emit) {
			client.emit = client.oEmit;
		}

		if (client.$onevent && client.$onevent !== client.onevent) {
			client.onevent = client.$onevent;
		}
	}
};

Logger.io = function (socket) {
	/*
	 * Go through all of the currently established sockets & hook their .emit/.on
	 */

	if (!socket || !socket.io || !socket.io.sockets || !socket.io.sockets.sockets) {
		return;
	}

	const clientsMap = socket.io.sockets.sockets;
	for (const [, socketObj] of clientsMap) {
		Logger.io_one(socketObj, socketObj.uid);
	}
};

Logger.io_one = function (socket, uid) {
	/*
	 * This function replaces a socket's .emit/.on functions in order to intercept events
	 */
	function override(method, name, errorMsg) {
		return (...args) => {
			if (opts.streams.log.f) {
				opts.streams.log.f.write(Logger.prepare_io_string(name, uid, args));
			}

			try {
				method.apply(socket, args);
			} catch (err) {
				winston.info(errorMsg, err);
			}
		};
	}

	if (socket && meta.config.loggerIOStatus > 0) {
		// courtesy of: http://stackoverflow.com/a/9674248
		socket.oEmit = socket.emit;
		const { emit } = socket;
		socket.emit = override(emit, 'emit', 'Logger.io_one: emit.apply: Failed');

		socket.$onvent = socket.onevent;
		const $onevent = socket.onevent;
		socket.onevent = override($onevent, 'on', 'Logger.io_one: $emit.apply: Failed');
'use strict';

const validator = require('validator');
const nconf = require('nconf');

const meta = require('../meta');
const groups = require('../groups');
const user = require('../user');
const helpers = require('./helpers');
const pagination = require('../pagination');
const privileges = require('../privileges');

const groupsController = module.exports;

groupsController.list = async function (req, res) {
	const sort = req.query.sort || 'alpha';

	const [groupData, allowGroupCreation] = await Promise.all([
		groups.getGroupsBySort(sort, 0, 14),
		privileges.global.can('group:create', req.uid),
	]);

	res.render('groups/list', {
		groups: groupData,
		allowGroupCreation: allowGroupCreation,
		nextStart: 15,
		title: '[[pages:groups]]',
		breadcrumbs: helpers.buildBreadcrumbs([{ text: '[[pages:groups]]' }]),
	});
};

groupsController.details = async function (req, res, next) {
	const lowercaseSlug = req.params.slug.toLowerCase();
	if (req.params.slug !== lowercaseSlug) {
		if (res.locals.isAPI) {
			req.params.slug = lowercaseSlug;
		} else {
			return res.redirect(`${nconf.get('relative_path')}/groups/${lowercaseSlug}`);
		}
	}
	const groupName = await groups.getGroupNameByGroupSlug(req.params.slug);
	if (!groupName) {
		return next();
	}
	const [exists, isHidden, isAdmin, isGlobalMod] = await Promise.all([
		groups.exists(groupName),
		groups.isHidden(groupName),
		user.isAdministrator(req.uid),
		user.isGlobalModerator(req.uid),
	]);
	if (!exists) {
		return next();
	}
	if (isHidden && !isAdmin && !isGlobalMod) {
		const [isMember, isInvited] = await Promise.all([
			groups.isMember(req.uid, groupName),
			groups.isInvited(req.uid, groupName),
		]);
		if (!isMember && !isInvited) {
			return next();
		}
	}
	const [groupData, posts] = await Promise.all([
		groups.get(groupName, {
			uid: req.uid,
			truncateUserList: true,
			userListCount: 20,
		}),
		groups.getLatestMemberPosts(groupName, 10, req.uid),
	]);
	if (!groupData) {
		return next();
	}
	groupData.isOwner = groupData.isOwner || isAdmin || (isGlobalMod && !groupData.system);

	res.render('groups/details', {
		title: `[[pages:group, ${groupData.displayName}]]`,
		group: groupData,
		posts: posts,
		isAdmin: isAdmin,
		isGlobalMod: isGlobalMod,
		allowPrivateGroups: meta.config.allowPrivateGroups,
		breadcrumbs: helpers.buildBreadcrumbs([{ text: '[[pages:groups]]', url: '/groups' }, { text: groupData.displayName }]),
	});
};

groupsController.members = async function (req, res, next) {
	const page = parseInt(req.query.page, 10) || 1;
	const usersPerPage = 50;
	const start = Math.max(0, (page - 1) * usersPerPage);
	const stop = start + usersPerPage - 1;
	const groupName = await groups.getGroupNameByGroupSlug(req.params.slug);
	if (!groupName) {
		return next();
	}
	const [groupData, isAdminOrGlobalMod, isMember, isHidden] = await Promise.all([
		groups.getGroupData(groupName),
		user.isAdminOrGlobalMod(req.uid),
		groups.isMember(req.uid, groupName),
		groups.isHidden(groupName),
	]);

	if (isHidden && !isMember && !isAdminOrGlobalMod) {
		return next();
	}
	const users = await user.getUsersFromSet(`group:${groupName}:members`, req.uid, start, stop);

	const breadcrumbs = helpers.buildBreadcrumbs([
		{ text: '[[pages:groups]]', url: '/groups' },
		{ text: validator.escape(String(groupName)), url: `/groups/${req.params.slug}` },
		{ text: '[[groups:details.members]]' },
	]);

	const pageCount = Math.max(1, Math.ceil(groupData.memberCount / usersPerPage));
	res.render('groups/members', {
'use strict';

const validator = require('validator');
const nconf = require('nconf');

const meta = require('../meta');
const user = require('../user');
const categories = require('../categories');
const plugins = require('../plugins');
const translator = require('../translator');
const languages = require('../languages');

const apiController = module.exports;

const relative_path = nconf.get('relative_path');
const upload_url = nconf.get('upload_url');
const socketioTransports = nconf.get('socket.io:transports') || ['polling', 'websocket'];
const socketioOrigins = nconf.get('socket.io:origins');
const websocketAddress = nconf.get('socket.io:address') || '';

apiController.loadConfig = async function (req) {
	const config = {
		relative_path,
		upload_url,
		assetBaseUrl: `${relative_path}/assets`,
		siteTitle: validator.escape(String(meta.config.title || meta.config.browserTitle || 'NodeBB')),
		browserTitle: validator.escape(String(meta.config.browserTitle || meta.config.title || 'NodeBB')),
		titleLayout: (meta.config.titleLayout || '{pageTitle} | {browserTitle}').replace(/{/g, '&#123;').replace(/}/g, '&#125;'),
		showSiteTitle: meta.config.showSiteTitle === 1,
		minimumTitleLength: meta.config.minimumTitleLength,
		maximumTitleLength: meta.config.maximumTitleLength,
		minimumPostLength: meta.config.minimumPostLength,
		maximumPostLength: meta.config.maximumPostLength,
		minimumTagsPerTopic: meta.config.minimumTagsPerTopic || 0,
		maximumTagsPerTopic: meta.config.maximumTagsPerTopic || 5,
		minimumTagLength: meta.config.minimumTagLength || 3,
		maximumTagLength: meta.config.maximumTagLength || 15,
		useOutgoingLinksPage: meta.config.useOutgoingLinksPage === 1,
		outgoingLinksWhitelist: meta.config.useOutgoingLinksPage === 1 ? meta.config['outgoingLinks:whitelist'] : undefined,
		allowGuestHandles: meta.config.allowGuestHandles === 1,
		allowTopicsThumbnail: meta.config.allowTopicsThumbnail === 1,
		usePagination: meta.config.usePagination === 1,
		disableChat: meta.config.disableChat === 1,
		disableChatMessageEditing: meta.config.disableChatMessageEditing === 1,
		maximumChatMessageLength: meta.config.maximumChatMessageLength || 1000,
		socketioTransports,
		socketioOrigins,
		websocketAddress,
		maxReconnectionAttempts: meta.config.maxReconnectionAttempts,
		reconnectionDelay: meta.config.reconnectionDelay,
		topicsPerPage: meta.config.topicsPerPage || 20,
		postsPerPage: meta.config.postsPerPage || 20,
		maximumFileSize: meta.config.maximumFileSize,
		'theme:id': meta.config['theme:id'],
		'theme:src': meta.config['theme:src'],
		defaultLang: meta.config.defaultLang || 'en-GB',
		userLang: req.query.lang ? validator.escape(String(req.query.lang)) : (meta.config.defaultLang || 'en-GB'),
		loggedIn: !!req.user,
		uid: req.uid,
		'cache-buster': meta.config['cache-buster'] || '',
		requireEmailConfirmation: meta.config.requireEmailConfirmation === 1,
		topicPostSort: meta.config.topicPostSort || 'oldest_to_newest',
		categoryTopicSort: meta.config.categoryTopicSort || 'newest_to_oldest',
		csrf_token: req.uid >= 0 && req.csrfToken && req.csrfToken(),
		searchEnabled: plugins.hooks.hasListeners('filter:search.query'),
		bootswatchSkin: meta.config.bootswatchSkin || '',
		enablePostHistory: meta.config.enablePostHistory === 1,
		timeagoCutoff: meta.config.timeagoCutoff !== '' ? Math.max(0, parseInt(meta.config.timeagoCutoff, 10)) : meta.config.timeagoCutoff,
		timeagoCodes: languages.timeagoCodes,
		cookies: {
			enabled: meta.config.cookieConsentEnabled === 1,
			message: translator.escape(validator.escape(meta.config.cookieConsentMessage || '[[global:cookies.message]]')).replace(/\\/g, '\\\\'),
			dismiss: translator.escape(validator.escape(meta.config.cookieConsentDismiss || '[[global:cookies.accept]]')).replace(/\\/g, '\\\\'),
			link: translator.escape(validator.escape(meta.config.cookieConsentLink || '[[global:cookies.learn_more]]')).replace(/\\/g, '\\\\'),
			link_url: translator.escape(validator.escape(meta.config.cookieConsentLinkUrl || 'https://www.cookiesandyou.com')).replace(/\\/g, '\\\\'),
		},
		thumbs: {
			size: meta.config.topicThumbSize,
		},
		iconBackgrounds: await user.getIconBackgrounds(req.uid),
	};

	let settings = config;
	let isAdminOrGlobalMod;
	if (req.loggedIn) {
		([settings, isAdminOrGlobalMod] = await Promise.all([
			user.getSettings(req.uid),
			user.isAdminOrGlobalMod(req.uid),
		]));
	}

	// Handle old skin configs
	const oldSkins = ['noskin', 'default'];
	settings.bootswatchSkin = oldSkins.includes(settings.bootswatchSkin) ? '' : settings.bootswatchSkin;

	config.usePagination = settings.usePagination;
	config.topicsPerPage = settings.topicsPerPage;
	config.postsPerPage = settings.postsPerPage;
	config.userLang = validator.escape(
		String((req.query.lang ? req.query.lang : null) || settings.userLang || config.defaultLang)
	);
	config.acpLang = validator.escape(String((req.query.lang ? req.query.lang : null) || settings.acpLang));
	config.openOutgoingLinksInNewTab = settings.openOutgoingLinksInNewTab;
	config.topicPostSort = settings.topicPostSort || config.topicPostSort;
	config.categoryTopicSort = settings.categoryTopicSort || config.categoryTopicSort;
	config.topicSearchEnabled = settings.topicSearchEnabled || false;
	config.bootswatchSkin = (meta.config.disableCustomUserSkins !== 1 && settings.bootswatchSkin && settings.bootswatchSkin !== '') ? settings.bootswatchSkin : '';

	// Overrides based on privilege
	config.disableChatMessageEditing = isAdminOrGlobalMod ? false : config.disableChatMessageEditing;

	return await plugins.hooks.fire('filter:config.get', config);
};

apiController.getConfig = async function (req, res) {
	const config = await apiController.loadConfig(req);
	res.json(config);
};

apiController.getModerators = async function (req, res) {
'use strict';

const nconf = require('nconf');
const winston = require('winston');
const validator = require('validator');
const plugins = require('../plugins');
const middleware = require('../middleware');

exports.handleURIErrors = async function handleURIErrors(err, req, res, next) {
	// Handle cases where malformed URIs are passed in
	if (err instanceof URIError) {
		const cleanPath = req.path.replace(new RegExp(`^${nconf.get('relative_path')}`), '');
		const tidMatch = cleanPath.match(/^\/topic\/(\d+)\//);
		const cidMatch = cleanPath.match(/^\/category\/(\d+)\//);

		if (tidMatch) {
			res.redirect(nconf.get('relative_path') + tidMatch[0]);
		} else if (cidMatch) {
			res.redirect(nconf.get('relative_path') + cidMatch[0]);
		} else {
			winston.warn(`[controller] Bad request: ${req.path}`);
			if (req.path.startsWith(`${nconf.get('relative_path')}/api`)) {
				res.status(400).json({
					error: '[[global:400.title]]',
				});
			} else {
				await middleware.buildHeaderAsync(req, res);
				res.status(400).render('400', { error: validator.escape(String(err.message)) });
			}
		}
	} else {
		next(err);
	}
};

// this needs to have four arguments or express treats it as `(req, res, next)`
// don't remove `next`!
exports.handleErrors = function handleErrors(err, req, res, next) { // eslint-disable-line no-unused-vars
	const cases = {
		EBADCSRFTOKEN: function () {
			winston.error(`${req.path}\n${err.message}`);
			res.sendStatus(403);
		},
		'blacklisted-ip': function () {
			res.status(403).type('text/plain').send(err.message);
		},
	};
	const defaultHandler = async function () {
		// Display NodeBB error page
		const status = parseInt(err.status, 10);
		if ((status === 302 || status === 308) && err.path) {
			return res.locals.isAPI ? res.set('X-Redirect', err.path).status(200).json(err.path) : res.redirect(nconf.get('relative_path') + err.path);
		}

		winston.error(`${req.path}\n${err.stack}`);

		res.status(status || 500);

		const path = String(req.path || '');
		if (res.locals.isAPI) {
			res.json({ path: validator.escape(path), error: err.message });
		} else {
			await middleware.buildHeaderAsync(req, res);
			res.render('500', { path: validator.escape(path), error: validator.escape(String(err.message)) });
		}
	};

	plugins.hooks.fire('filter:error.handle', {
		cases: cases,
	}, (_err, data) => {
		if (_err) {
			// Assume defaults
			winston.warn(`[errors/handle] Unable to retrieve plugin handlers for errors: ${_err.message}`);
			data.cases = cases;
		}

		if (data.cases.hasOwnProperty(err.code)) {
			data.cases[err.code](err, req, res, defaultHandler);
		} else {
			defaultHandler();
'use strict';

const privileges = require('../privileges');
const helpers = require('./helpers');

const adminController = {
	dashboard: require('./admin/dashboard'),
	categories: require('./admin/categories'),
	privileges: require('./admin/privileges'),
	adminsMods: require('./admin/admins-mods'),
	tags: require('./admin/tags'),
	groups: require('./admin/groups'),
	digest: require('./admin/digest'),
	appearance: require('./admin/appearance'),
	extend: {
		widgets: require('./admin/widgets'),
		rewards: require('./admin/rewards'),
	},
	events: require('./admin/events'),
	hooks: require('./admin/hooks'),
	logs: require('./admin/logs'),
	errors: require('./admin/errors'),
	database: require('./admin/database'),
	cache: require('./admin/cache'),
	plugins: require('./admin/plugins'),
	settings: require('./admin/settings'),
	logger: require('./admin/logger'),
	themes: require('./admin/themes'),
	users: require('./admin/users'),
	uploads: require('./admin/uploads'),
	info: require('./admin/info'),
};

adminController.routeIndex = async (req, res) => {
	const privilegeSet = await privileges.admin.get(req.uid);

	if (privilegeSet.superadmin || privilegeSet['admin:dashboard']) {
		return adminController.dashboard.get(req, res);
	} else if (privilegeSet['admin:categories']) {
		return helpers.redirect(res, 'admin/manage/categories');
	} else if (privilegeSet['admin:privileges']) {
		return helpers.redirect(res, 'admin/manage/privileges');
	} else if (privilegeSet['admin:users']) {
		return helpers.redirect(res, 'admin/manage/users');
	} else if (privilegeSet['admin:groups']) {
		return helpers.redirect(res, 'admin/manage/groups');
	} else if (privilegeSet['admin:admins-mods']) {
		return helpers.redirect(res, 'admin/manage/admins-mods');
	} else if (privilegeSet['admin:tags']) {
		return helpers.redirect(res, 'admin/manage/tags');
	} else if (privilegeSet['admin:settings']) {
		return helpers.redirect(res, 'admin/settings/general');
	}

	return helpers.notAllowed(req, res);
'use strict';

const xml = require('xml');
const nconf = require('nconf');

const plugins = require('../plugins');
const meta = require('../meta');

module.exports.handle = function (req, res, next) {
	if (plugins.hooks.hasListeners('filter:search.query')) {
		res.type('application/opensearchdescription+xml').send(generateXML());
	} else {
		next();
	}
};

function generateXML() {
	return xml([{
		OpenSearchDescription: [
			{
				_attr: {
					xmlns: 'http://a9.com/-/spec/opensearch/1.1/',
					'xmlns:moz': 'http://www.mozilla.org/2006/browser/search/',
				},
			},
			{ ShortName: trimToLength(String(meta.config.title || meta.config.browserTitle || 'NodeBB'), 16) },
			{ Description: trimToLength(String(meta.config.description || ''), 1024) },
			{ InputEncoding: 'UTF-8' },
			{
				Image: [
					{
						_attr: {
							width: '16',
							height: '16',
							type: 'image/x-icon',
						},
					},
					`${nconf.get('url')}/favicon.ico`,
				],
			},
			{
				Url: {
					_attr: {
						type: 'text/html',
						method: 'get',
						template: `${nconf.get('url')}/search?term={searchTerms}&in=titlesposts`,
					},
				},
			},
			{ 'moz:SearchForm': `${nconf.get('url')}/search` },
		],
	}], { declaration: true, indent: '\t' });
}

function trimToLength(string, length) {
'use strict';

const user = require('../user');
const meta = require('../meta');
const analytics = require('../analytics');
const usersController = require('./admin/users');
const helpers = require('./helpers');

const globalModsController = module.exports;

globalModsController.ipBlacklist = async function (req, res, next) {
	const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(req.uid);
	if (!isAdminOrGlobalMod) {
		return next();
	}

	const [rules, analyticsData] = await Promise.all([
		meta.blacklist.get(),
		analytics.getBlacklistAnalytics(),
	]);
	res.render('ip-blacklist', {
		title: '[[pages:ip-blacklist]]',
		rules: rules,
		analytics: analyticsData,
		breadcrumbs: helpers.buildBreadcrumbs([{ text: '[[pages:ip-blacklist]]' }]),
	});
};


globalModsController.registrationQueue = async function (req, res, next) {
	const isAdminOrGlobalMod = await user.isAdminOrGlobalMod(req.uid);
	if (!isAdminOrGlobalMod) {
		return next();
	}
	await usersController.registrationQueue(req, res);
'use strict';

const nconf = require('nconf');

const user = require('../user');
const plugins = require('../plugins');
const topics = require('../topics');
const posts = require('../posts');
const helpers = require('./helpers');

exports.get = async function (req, res, callback) {
	res.locals.metaTags = {
		...res.locals.metaTags,
		name: 'robots',
		content: 'noindex',
	};

	const data = await plugins.hooks.fire('filter:composer.build', {
		req: req,
		res: res,
		next: callback,
		templateData: {},
	});

	if (res.headersSent) {
		return;
	}
	if (!data || !data.templateData) {
		return callback(new Error('[[error:invalid-data]]'));
	}

	if (data.templateData.disabled) {
		res.render('', {
			title: '[[modules:composer.compose]]',
		});
	} else {
		data.templateData.title = '[[modules:composer.compose]]';
		res.render('compose', data.templateData);
	}
};

exports.post = async function (req, res) {
	const { body } = req;
	const data = {
		uid: req.uid,
		req: req,
		timestamp: Date.now(),
		content: body.content,
		fromQueue: false,
	};
	req.body.noscript = 'true';

	if (!data.content) {
		return helpers.noScriptErrors(req, res, '[[error:invalid-data]]', 400);
	}
	async function queueOrPost(postFn, data) {
		const shouldQueue = await posts.shouldQueue(req.uid, data);
		if (shouldQueue) {
			delete data.req;
			return await posts.addToQueue(data);
		}
		return await postFn(data);
	}

	try {
		let result;
		if (body.tid) {
			data.tid = body.tid;
			result = await queueOrPost(topics.reply, data);
		} else if (body.cid) {
			data.cid = body.cid;
			data.title = body.title;
			data.tags = [];
			data.thumb = '';
			result = await queueOrPost(topics.post, data);
		} else {
			throw new Error('[[error:invalid-data]]');
		}
		if (result.queued) {
			return res.redirect(`${nconf.get('relative_path') || '/'}?noScriptMessage=[[success:post-queued]]`);
		}
		const uid = result.uid ? result.uid : result.topicData.uid;
		user.updateOnlineUsers(uid);
		const path = result.pid ? `/post/${result.pid}` : `/topic/${result.topicData.slug}`;
		res.redirect(nconf.get('relative_path') + path);
'use strict';

const groups = require('../../groups');
const helpers = require('../helpers');
const accountHelpers = require('./helpers');

const groupsController = module.exports;

groupsController.get = async function (req, res, next) {
	const userData = await accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid);
	if (!userData) {
		return next();
	}
	let groupsData = await groups.getUserGroups([userData.uid]);
	groupsData = groupsData[0];
	const groupNames = groupsData.filter(Boolean).map(group => group.name);
	const members = await groups.getMemberUsers(groupNames, 0, 3);
	groupsData.forEach((group, index) => {
		group.members = members[index];
	});
'use strict';

const db = require('../../database');
const meta = require('../../meta');
const helpers = require('../helpers');
const accountHelpers = require('./helpers');

const consentController = module.exports;

consentController.get = async function (req, res, next) {
	if (!meta.config.gdpr_enabled) {
		return next();
	}

	const userData = await accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid);
	if (!userData) {
		return next();
	}
	const consented = await db.getObjectField(`user:${userData.uid}`, 'gdpr_consent');
	userData.gdpr_consent = parseInt(consented, 10) === 1;
	userData.digest = {
		frequency: meta.config.dailyDigestFreq || 'off',
		enabled: meta.config.dailyDigestFreq !== 'off',
	};

'use strict';

const nconf = require('nconf');
const winston = require('winston');
const _ = require('lodash');
const jwt = require('jsonwebtoken');
const util = require('util');

const user = require('../../user');
const languages = require('../../languages');
const meta = require('../../meta');
const plugins = require('../../plugins');
const notifications = require('../../notifications');
const db = require('../../database');
const helpers = require('../helpers');
const accountHelpers = require('./helpers');

const settingsController = module.exports;

settingsController.get = async function (req, res, next) {
	const userData = await accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid);
	if (!userData) {
		return next();
	}
	const [settings, languagesData] = await Promise.all([
		user.getSettings(userData.uid),
		languages.list(),
	]);

	userData.settings = settings;
	userData.languages = languagesData;
	if (userData.isAdmin && userData.isSelf) {
		userData.acpLanguages = _.cloneDeep(languagesData);
	}

	const data = await plugins.hooks.fire('filter:user.customSettings', {
		settings: settings,
		customSettings: [],
		uid: req.uid,
	});

	const [notificationSettings, routes] = await Promise.all([
		getNotificationSettings(userData),
		getHomePageRoutes(userData),
	]);

	userData.customSettings = data.customSettings;
	userData.homePageRoutes = routes;
	userData.notificationSettings = notificationSettings;
	userData.disableEmailSubscriptions = meta.config.disableEmailSubscriptions;

	userData.dailyDigestFreqOptions = [
		{ value: 'off', name: '[[user:digest_off]]', selected: userData.settings.dailyDigestFreq === 'off' },
		{ value: 'day', name: '[[user:digest_daily]]', selected: userData.settings.dailyDigestFreq === 'day' },
		{ value: 'week', name: '[[user:digest_weekly]]', selected: userData.settings.dailyDigestFreq === 'week' },
		{ value: 'month', name: '[[user:digest_monthly]]', selected: userData.settings.dailyDigestFreq === 'month' },
	];

	userData.bootswatchSkinOptions = [
		{ name: 'Default', value: '' },
		{ name: 'Cerulean', value: 'cerulean' },
		{ name: 'Cosmo', value: 'cosmo'	},
		{ name: 'Cyborg', value: 'cyborg' },
		{ name: 'Darkly', value: 'darkly' },
		{ name: 'Flatly', value: 'flatly' },
		{ name: 'Journal', value: 'journal'	},
		{ name: 'Lumen', value: 'lumen' },
		{ name: 'Paper', value: 'paper' },
		{ name: 'Readable', value: 'readable' },
		{ name: 'Sandstone', value: 'sandstone' },
		{ name: 'Simplex', value: 'simplex' },
		{ name: 'Slate', value: 'slate'	},
		{ name: 'Spacelab', value: 'spacelab' },
		{ name: 'Superhero', value: 'superhero' },
		{ name: 'United', value: 'united' },
		{ name: 'Yeti', value: 'yeti' },
	];

	userData.bootswatchSkinOptions.forEach((skin) => {
		skin.selected = skin.value === userData.settings.bootswatchSkin;
	});

	userData.languages.forEach((language) => {
		language.selected = language.code === userData.settings.userLang;
	});

	if (userData.isAdmin && userData.isSelf) {
		userData.acpLanguages.forEach((language) => {
			language.selected = language.code === userData.settings.acpLang;
		});
	}

	const notifFreqOptions = [
		'all',
		'first',
		'everyTen',
		'threshold',
		'logarithmic',
		'disabled',
	];

	userData.upvoteNotifFreq = notifFreqOptions.map(
		name => ({ name: name, selected: name === userData.settings.upvoteNotifFreq })
	);

	userData.categoryWatchState = { [userData.settings.categoryWatchState]: true };

	userData.disableCustomUserSkins = meta.config.disableCustomUserSkins || 0;

	userData.allowUserHomePage = meta.config.allowUserHomePage === 1 ? 1 : 0;

	userData.hideFullname = meta.config.hideFullname || 0;
	userData.hideEmail = meta.config.hideEmail || 0;

	userData.inTopicSearchAvailable = plugins.hooks.hasListeners('filter:topic.search');

	userData.maxTopicsPerPage = meta.config.maxTopicsPerPage;
	userData.maxPostsPerPage = meta.config.maxPostsPerPage;

	userData.title = '[[pages:account/settings]]';
	userData.breadcrumbs = helpers.buildBreadcrumbs([{ text: userData.username, url: `/user/${userData.userslug}` }, { text: '[[user:settings]]' }]);

	res.render('account/settings', userData);
};

const unsubscribable = ['digest', 'notification'];
const jwtVerifyAsync = util.promisify((token, callback) => {
	jwt.verify(token, nconf.get('secret'), (err, payload) => callback(err, payload));
});
const doUnsubscribe = async (payload) => {
	if (payload.template === 'digest') {
		await Promise.all([
			user.setSetting(payload.uid, 'dailyDigestFreq', 'off'),
			user.updateDigestSetting(payload.uid, 'off'),
		]);
	} else if (payload.template === 'notification') {
		const current = await db.getObjectField(`user:${payload.uid}:settings`, `notificationType_${payload.type}`);
		await user.setSetting(payload.uid, `notificationType_${payload.type}`, (current === 'notificationemail' ? 'notification' : 'none'));
	}
	return true;
};

settingsController.unsubscribe = async (req, res) => {
	let payload;
	try {
		payload = await jwtVerifyAsync(req.params.token);
		if (!payload || !unsubscribable.includes(payload.template)) {
			return;
		}
	} catch (err) {
		throw new Error(err);
	}

	try {
		await doUnsubscribe(payload);
		res.render('unsubscribe', {
			payload: payload,
		});
	} catch (err) {
		throw new Error(err);
	}
};

settingsController.unsubscribePost = async function (req, res) {
	let payload;
	try {
		payload = await jwtVerifyAsync(req.params.token);
		if (!payload || !unsubscribable.includes(payload.template)) {
			return res.sendStatus(404);
		}
	} catch (err) {
		return res.sendStatus(403);
	}
	try {
		await doUnsubscribe(payload);
		res.sendStatus(200);
	} catch (err) {
		winston.error(`[settings/unsubscribe] One-click unsubscribe failed with error: ${err.message}`);
		res.sendStatus(500);
	}
};

async function getNotificationSettings(userData) {
	const privilegedTypes = [];

	const privileges = await user.getPrivileges(userData.uid);
	if (privileges.isAdmin) {
		privilegedTypes.push('notificationType_new-register');
	}
	if (privileges.isAdmin || privileges.isGlobalMod || privileges.isModeratorOfAnyCategory) {
		privilegedTypes.push('notificationType_post-queue', 'notificationType_new-post-flag');
	}
	if (privileges.isAdmin || privileges.isGlobalMod) {
		privilegedTypes.push('notificationType_new-user-flag');
	}
	const results = await plugins.hooks.fire('filter:user.notificationTypes', {
		types: notifications.baseTypes.slice(),
		privilegedTypes: privilegedTypes,
	});

	function modifyType(type) {
		const setting = userData.settings[type];
		return {
			name: type,
			label: `[[notifications:${type}]]`,
			none: setting === 'none',
			notification: setting === 'notification',
			email: setting === 'email',
			notificationemail: setting === 'notificationemail',
		};
	}

	if (meta.config.disableChat) {
		results.types = results.types.filter(type => type !== 'notificationType_new-chat');
	}

	return results.types.map(modifyType).concat(results.privilegedTypes.map(modifyType));
}

async function getHomePageRoutes(userData) {
	let routes = await helpers.getHomePageRoutes(userData.uid);

	// Set selected for each route
	let customIdx;
	let hasSelected = false;
	routes = routes.map((route, idx) => {
		if (route.route === userData.settings.homePageRoute) {
			route.selected = true;
			hasSelected = true;
		} else {
			route.selected = false;
		}

		if (route.route === 'custom') {
			customIdx = idx;
		}

		return route;
	});

	if (!hasSelected && customIdx && userData.settings.homePageRoute !== 'none') {
		routes[customIdx].selected = true;
	}

	return routes;
'use strict';

const messaging = require('../../messaging');
const meta = require('../../meta');
const user = require('../../user');
const privileges = require('../../privileges');
const helpers = require('../helpers');

const chatsController = module.exports;

chatsController.get = async function (req, res, next) {
	if (meta.config.disableChat) {
		return next();
	}

	const uid = await user.getUidByUserslug(req.params.userslug);
	if (!uid) {
		return next();
	}
	const canChat = await privileges.global.can('chat', req.uid);
	if (!canChat) {
		return next(new Error('[[error:no-privileges]]'));
	}
	const recentChats = await messaging.getRecentChats(req.uid, uid, 0, 19);
	if (!recentChats) {
		return next();
	}

	if (!req.params.roomid) {
		return res.render('chats', {
			rooms: recentChats.rooms,
			uid: uid,
			userslug: req.params.userslug,
			nextStart: recentChats.nextStart,
			allowed: true,
			title: '[[pages:chats]]',
		});
	}
	const room = await messaging.loadRoom(req.uid, { uid: uid, roomId: req.params.roomid });
	if (!room) {
		return next();
	}

	room.rooms = recentChats.rooms;
	room.nextStart = recentChats.nextStart;
	room.title = room.roomName || room.usernames || '[[pages:chats]]';
	room.uid = uid;
	room.userslug = req.params.userslug;

	room.canViewInfo = await privileges.global.can('view:users:info', uid);

	res.render('chats', room);
};

chatsController.redirectToChat = async function (req, res, next) {
	if (!req.loggedIn) {
		return next();
	}
	const userslug = await user.getUserField(req.uid, 'userslug');
	if (!userslug) {
'use strict';

const helpers = require('../helpers');
const accountHelpers = require('./helpers');
const pagination = require('../../pagination');
const user = require('../../user');
const plugins = require('../../plugins');

const blocksController = module.exports;

blocksController.getBlocks = async function (req, res, next) {
	const page = parseInt(req.query.page, 10) || 1;
	const resultsPerPage = 50;
	const start = Math.max(0, page - 1) * resultsPerPage;
	const stop = start + resultsPerPage - 1;

	const userData = await accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid);
	if (!userData) {
		return next();
	}
	const uids = await user.blocks.list(userData.uid);
	const data = await plugins.hooks.fire('filter:user.getBlocks', {
		uids: uids,
		uid: userData.uid,
		start: start,
		stop: stop,
	});

	data.uids = data.uids.slice(start, stop + 1);
	userData.users = await user.getUsers(data.uids, req.uid);
	userData.title = `[[pages:account/blocks, ${userData.username}]]`;

	const pageCount = Math.ceil(userData.counts.blocks / resultsPerPage);
	userData.pagination = pagination.create(page, pageCount);

'use strict';

const validator = require('validator');
const nconf = require('nconf');

const db = require('../../database');
const user = require('../../user');
const groups = require('../../groups');
const plugins = require('../../plugins');
const meta = require('../../meta');
const utils = require('../../utils');
const privileges = require('../../privileges');
const translator = require('../../translator');
const messaging = require('../../messaging');
const categories = require('../../categories');

const helpers = module.exports;

helpers.getUserDataByUserSlug = async function (userslug, callerUID) {
	const uid = await user.getUidByUserslug(userslug);
	if (!uid) {
		return null;
	}

	const results = await getAllData(uid, callerUID);
	if (!results.userData) {
		throw new Error('[[error:invalid-uid]]');
	}
	await parseAboutMe(results.userData);

	const { userData } = results;
	const { userSettings } = results;
	const { isAdmin } = results;
	const { isGlobalModerator } = results;
	const { isModerator } = results;
	const { canViewInfo } = results;
	const isSelf = parseInt(callerUID, 10) === parseInt(userData.uid, 10);

	userData.age = Math.max(
		0,
		userData.birthday ? Math.floor((new Date().getTime() - new Date(userData.birthday).getTime()) / 31536000000) : 0
	);

	userData.emailClass = 'hide';

	if (!isAdmin && !isGlobalModerator && !isSelf && (!userSettings.showemail || meta.config.hideEmail)) {
		userData.email = '';
	} else if (!userSettings.showemail) {
		userData.emailClass = '';
	}

	if (!isAdmin && !isGlobalModerator && !isSelf && (!userSettings.showfullname || meta.config.hideFullname)) {
		userData.fullname = '';
	}

	if (isAdmin || isSelf || (canViewInfo && !results.isTargetAdmin)) {
		userData.ips = results.ips;
	}

	if (!isAdmin && !isGlobalModerator && !isModerator) {
		userData.moderationNote = undefined;
	}

	userData.isBlocked = results.isBlocked;
	userData.yourid = callerUID;
	userData.theirid = userData.uid;
	userData.isTargetAdmin = results.isTargetAdmin;
	userData.isAdmin = isAdmin;
	userData.isGlobalModerator = isGlobalModerator;
	userData.isModerator = isModerator;
	userData.isAdminOrGlobalModerator = isAdmin || isGlobalModerator;
	userData.isAdminOrGlobalModeratorOrModerator = isAdmin || isGlobalModerator || isModerator;
	userData.isSelfOrAdminOrGlobalModerator = isSelf || isAdmin || isGlobalModerator;
	userData.canEdit = results.canEdit;
	userData.canBan = results.canBanUser;
	userData.canFlag = (await privileges.users.canFlag(callerUID, userData.uid)).flag;
	userData.canChangePassword = isAdmin || (isSelf && !meta.config['password:disableEdit']);
	userData.isSelf = isSelf;
	userData.isFollowing = results.isFollowing;
	userData.hasPrivateChat = results.hasPrivateChat;
	userData.showHidden = isSelf || isAdmin || (isGlobalModerator && !results.isTargetAdmin);
	userData.groups = Array.isArray(results.groups) && results.groups.length ? results.groups[0] : [];
	userData.disableSignatures = meta.config.disableSignatures === 1;
	userData['reputation:disabled'] = meta.config['reputation:disabled'] === 1;
	userData['downvote:disabled'] = meta.config['downvote:disabled'] === 1;
	userData['email:confirmed'] = !!userData['email:confirmed'];
	userData.profile_links = filterLinks(results.profile_menu.links, {
		self: isSelf,
		other: !isSelf,
		moderator: isModerator,
		globalMod: isGlobalModerator,
		admin: isAdmin,
		canViewInfo: canViewInfo,
	});

	userData.sso = results.sso.associations;
	userData.banned = Boolean(userData.banned);
	userData.website = validator.escape(String(userData.website || ''));
	userData.websiteLink = !userData.website.startsWith('http') ? `http://${userData.website}` : userData.website;
	userData.websiteName = userData.website.replace(validator.escape('http://'), '').replace(validator.escape('https://'), '');

	userData.fullname = validator.escape(String(userData.fullname || ''));
	userData.location = validator.escape(String(userData.location || ''));
	userData.signature = validator.escape(String(userData.signature || ''));
	userData.birthday = validator.escape(String(userData.birthday || ''));
	userData.moderationNote = validator.escape(String(userData.moderationNote || ''));

	if (userData['cover:url']) {
		userData['cover:url'] = userData['cover:url'].startsWith('http') ? userData['cover:url'] : (nconf.get('relative_path') + userData['cover:url']);
	} else {
		userData['cover:url'] = require('../../coverPhoto').getDefaultProfileCover(userData.uid);
	}

	userData['cover:position'] = validator.escape(String(userData['cover:position'] || '50% 50%'));
	userData['username:disableEdit'] = !userData.isAdmin && meta.config['username:disableEdit'];
	userData['email:disableEdit'] = !userData.isAdmin && meta.config['email:disableEdit'];

	await getCounts(userData, callerUID);

	const hookData = await plugins.hooks.fire('filter:helpers.getUserDataByUserSlug', { userData: userData, callerUID: callerUID });
	return hookData.userData;
};

async function getAllData(uid, callerUID) {
	return await utils.promiseParallel({
		userData: user.getUserData(uid),
		isTargetAdmin: user.isAdministrator(uid),
		userSettings: user.getSettings(uid),
		isAdmin: user.isAdministrator(callerUID),
		isGlobalModerator: user.isGlobalModerator(callerUID),
		isModerator: user.isModeratorOfAnyCategory(callerUID),
		isFollowing: user.isFollowing(callerUID, uid),
		ips: user.getIPs(uid, 4),
		profile_menu: getProfileMenu(uid, callerUID),
		groups: groups.getUserGroups([uid]),
		sso: plugins.hooks.fire('filter:auth.list', { uid: uid, associations: [] }),
		canEdit: privileges.users.canEdit(callerUID, uid),
		canBanUser: privileges.users.canBanUser(callerUID, uid),
		isBlocked: user.blocks.is(uid, callerUID),
		canViewInfo: privileges.global.can('view:users:info', callerUID),
		hasPrivateChat: messaging.hasPrivateChat(callerUID, uid),
	});
}

async function getCounts(userData, callerUID) {
	const { uid } = userData;
	const cids = await categories.getCidsByPrivilege('categories:cid', callerUID, 'topics:read');
	const promises = {
		posts: db.sortedSetsCardSum(cids.map(c => `cid:${c}:uid:${uid}:pids`)),
		best: db.sortedSetsCardSum(cids.map(c => `cid:${c}:uid:${uid}:pids:votes`)),
		topics: db.sortedSetsCardSum(cids.map(c => `cid:${c}:uid:${uid}:tids`)),
	};
	if (userData.isAdmin || userData.isSelf) {
		promises.ignored = db.sortedSetCard(`uid:${uid}:ignored_tids`);
		promises.watched = db.sortedSetCard(`uid:${uid}:followed_tids`);
		promises.upvoted = db.sortedSetCard(`uid:${uid}:upvote`);
		promises.downvoted = db.sortedSetCard(`uid:${uid}:downvote`);
		promises.bookmarks = db.sortedSetCard(`uid:${uid}:bookmarks`);
		promises.uploaded = db.sortedSetCard(`uid:${uid}:uploads`);
		promises.categoriesWatched = user.getWatchedCategories(uid);
		promises.blocks = user.getUserField(userData.uid, 'blocksCount');
	}
	const counts = await utils.promiseParallel(promises);
	counts.categoriesWatched = counts.categoriesWatched && counts.categoriesWatched.length;
	counts.groups = userData.groups.length;
	counts.following = userData.followingCount;
	counts.followers = userData.followerCount;
	userData.blocksCount = counts.blocks || 0; // for backwards compatibility, remove in 1.16.0
	userData.counts = counts;
}

async function getProfileMenu(uid, callerUID) {
	const links = [{
		id: 'info',
		route: 'info',
		name: '[[user:account_info]]',
		icon: 'fa-info',
		visibility: {
			self: false,
			other: false,
			moderator: false,
			globalMod: false,
			admin: true,
			canViewInfo: true,
		},
	}, {
		id: 'sessions',
		route: 'sessions',
		name: '[[pages:account/sessions]]',
		icon: 'fa-group',
		visibility: {
			self: true,
			other: false,
			moderator: false,
			globalMod: false,
			admin: false,
			canViewInfo: false,
		},
	}];

	if (meta.config.gdpr_enabled) {
		links.push({
			id: 'consent',
			route: 'consent',
			name: '[[user:consent.title]]',
			icon: 'fa-thumbs-o-up',
			visibility: {
				self: true,
				other: false,
				moderator: false,
				globalMod: false,
				admin: false,
				canViewInfo: false,
			},
		});
	}

	return await plugins.hooks.fire('filter:user.profileMenu', {
		uid: uid,
		callerUID: callerUID,
		links: links,
	});
}

async function parseAboutMe(userData) {
	if (!userData.aboutme) {
		userData.aboutme = '';
		userData.aboutmeParsed = '';
		return;
	}
	userData.aboutme = validator.escape(String(userData.aboutme || ''));
	const parsed = await plugins.hooks.fire('filter:parse.aboutme', userData.aboutme);
	userData.aboutmeParsed = translator.escape(parsed);
}

function filterLinks(links, states) {
	return links.filter((link, index) => {
		// Default visibility
		link.visibility = {
			self: true,
			other: true,
			moderator: true,
			globalMod: true,
			admin: true,
			canViewInfo: true,
			...link.visibility,
		};

		const permit = Object.keys(states).some(state => states[state] && link.visibility[state]);

		links[index].public = permit;
		return permit;
	});
}

'use strict';

const user = require('../../user');
const meta = require('../../meta');
const helpers = require('../helpers');
const groups = require('../../groups');
const accountHelpers = require('./helpers');
const privileges = require('../../privileges');
const file = require('../../file');

const editController = module.exports;

editController.get = async function (req, res, next) {
	const [userData, canUseSignature] = await Promise.all([
		accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid),
		privileges.global.can('signature', req.uid),
	]);
	if (!userData) {
		return next();
	}
	userData.maximumSignatureLength = meta.config.maximumSignatureLength;
	userData.maximumAboutMeLength = meta.config.maximumAboutMeLength;
	userData.maximumProfileImageSize = meta.config.maximumProfileImageSize;
	userData.allowProfilePicture = !userData.isSelf || !!meta.config['reputation:disabled'] || userData.reputation >= meta.config['min:rep:profile-picture'];
	userData.allowCoverPicture = !userData.isSelf || !!meta.config['reputation:disabled'] || userData.reputation >= meta.config['min:rep:cover-picture'];
	userData.allowProfileImageUploads = meta.config.allowProfileImageUploads;
	userData.allowedProfileImageExtensions = user.getAllowedProfileImageExtensions().map(ext => `.${ext}`).join(', ');
	userData.allowMultipleBadges = meta.config.allowMultipleBadges === 1;
	userData.allowAccountDelete = meta.config.allowAccountDelete === 1;
	userData.allowWebsite = !userData.isSelf || !!meta.config['reputation:disabled'] || userData.reputation >= meta.config['min:rep:website'];
	userData.allowAboutMe = !userData.isSelf || !!meta.config['reputation:disabled'] || userData.reputation >= meta.config['min:rep:aboutme'];
	userData.allowSignature = canUseSignature && (!userData.isSelf || !!meta.config['reputation:disabled'] || userData.reputation >= meta.config['min:rep:signature']);
	userData.profileImageDimension = meta.config.profileImageDimension;
	userData.defaultAvatar = user.getDefaultAvatar();

	userData.groups = userData.groups.filter(g => g && g.userTitleEnabled && !groups.isPrivilegeGroup(g.name) && g.name !== 'registered-users');

	if (!userData.allowMultipleBadges) {
		userData.groupTitle = userData.groupTitleArray[0];
	}

	userData.groups.sort((a, b) => {
		const i1 = userData.groupTitleArray.indexOf(a.name);
		const i2 = userData.groupTitleArray.indexOf(b.name);
		if (i1 === -1) {
			return 1;
		} else if (i2 === -1) {
			return -1;
		}
		return i1 - i2;
	});
	userData.groups.forEach((group) => {
		group.userTitle = group.userTitle || group.displayName;
		group.selected = userData.groupTitleArray.includes(group.name);
	});
	userData.groupSelectSize = Math.min(10, Math.max(5, userData.groups.length + 1));

	userData.title = `[[pages:account/edit, ${userData.username}]]`;
	userData.breadcrumbs = helpers.buildBreadcrumbs([
		{
			text: userData.username,
			url: `/user/${userData.userslug}`,
		},
		{
			text: '[[user:edit]]',
		},
	]);
	userData.editButtons = [];
	res.render('account/edit', userData);
};

editController.password = async function (req, res, next) {
	await renderRoute('password', req, res, next);
};

editController.username = async function (req, res, next) {
	await renderRoute('username', req, res, next);
};

editController.email = async function (req, res, next) {
	await renderRoute('email', req, res, next);
};

async function renderRoute(name, req, res, next) {
	const userData = await getUserData(req, next);
	if (!userData) {
		return next();
	}
	if (meta.config[`${name}:disableEdit`] && !userData.isAdmin) {
		return helpers.notAllowed(req, res);
	}

	if (name === 'password') {
		userData.minimumPasswordLength = meta.config.minimumPasswordLength;
		userData.minimumPasswordStrength = meta.config.minimumPasswordStrength;
	}

	userData.title = `[[pages:account/edit/${name}, ${userData.username}]]`;
	userData.breadcrumbs = helpers.buildBreadcrumbs([
		{
			text: userData.username,
			url: `/user/${userData.userslug}`,
		},
		{
			text: '[[user:edit]]',
			url: `/user/${userData.userslug}/edit`,
		},
		{
			text: `[[user:${name}]]`,
		},
	]);

	res.render(`account/edit/${name}`, userData);
}

async function getUserData(req) {
	const userData = await accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid);
	if (!userData) {
		return null;
	}

	userData.hasPassword = await user.hasPassword(userData.uid);
	return userData;
}

editController.uploadPicture = async function (req, res, next) {
	const userPhoto = req.files.files[0];
	try {
		const updateUid = await user.getUidByUserslug(req.params.userslug);
		const isAllowed = await privileges.users.canEdit(req.uid, updateUid);
		if (!isAllowed) {
			return helpers.notAllowed(req, res);
		}
		await user.checkMinReputation(req.uid, updateUid, 'min:rep:profile-picture');

		const image = await user.uploadCroppedPictureFile({
			uid: updateUid,
			file: userPhoto,
		});

		res.json([{
			name: userPhoto.name,
			url: image.url,
		}]);
	} catch (err) {
'use strict';

const user = require('../../user');
const categories = require('../../categories');
const accountHelpers = require('./helpers');
const helpers = require('../helpers');
const pagination = require('../../pagination');
const meta = require('../../meta');

const categoriesController = module.exports;

categoriesController.get = async function (req, res, next) {
	const userData = await accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid);
	if (!userData) {
		return next();
	}
	const [states, allCategoriesData] = await Promise.all([
		user.getCategoryWatchState(userData.uid),
		categories.buildForSelect(userData.uid, 'find', ['descriptionParsed', 'depth', 'slug']),
	]);

	const pageCount = Math.max(1, Math.ceil(allCategoriesData.length / meta.config.categoriesPerPage));
	const page = Math.min(parseInt(req.query.page, 10) || 1, pageCount);
	const start = Math.max(0, (page - 1) * meta.config.categoriesPerPage);
	const stop = start + meta.config.categoriesPerPage - 1;
	const categoriesData = allCategoriesData.slice(start, stop + 1);


	categoriesData.forEach((category) => {
		if (category) {
			category.isIgnored = states[category.cid] === categories.watchStates.ignoring;
			category.isWatched = states[category.cid] === categories.watchStates.watching;
			category.isNotWatched = states[category.cid] === categories.watchStates.notwatching;
		}
	});
	userData.categories = categoriesData;
	userData.title = `[[pages:account/watched_categories, ${userData.username}]]`;
	userData.breadcrumbs = helpers.buildBreadcrumbs([
		{ text: userData.username, url: `/user/${userData.userslug}` },
		{ text: '[[pages:categories]]' },
'use strict';

const nconf = require('nconf');
const _ = require('lodash');

const db = require('../../database');
const user = require('../../user');
const posts = require('../../posts');
const categories = require('../../categories');
const meta = require('../../meta');
const accountHelpers = require('./helpers');
const helpers = require('../helpers');
const utils = require('../../utils');

const profileController = module.exports;

profileController.get = async function (req, res, next) {
	const lowercaseSlug = req.params.userslug.toLowerCase();

	if (req.params.userslug !== lowercaseSlug) {
		if (res.locals.isAPI) {
			req.params.userslug = lowercaseSlug;
		} else {
			return res.redirect(`${nconf.get('relative_path')}/user/${lowercaseSlug}`);
		}
	}

	const userData = await accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid);
	if (!userData) {
		return next();
	}

	await incrementProfileViews(req, userData);

	const [latestPosts, bestPosts] = await Promise.all([
		getLatestPosts(req.uid, userData),
		getBestPosts(req.uid, userData),
		posts.parseSignature(userData, req.uid),
	]);

	if (meta.config['reputation:disabled']) {
		delete userData.reputation;
	}

	userData.posts = latestPosts; // for backwards compat.
	userData.latestPosts = latestPosts;
	userData.bestPosts = bestPosts;
	userData.breadcrumbs = helpers.buildBreadcrumbs([{ text: userData.username }]);
	userData.title = userData.username;
	userData.allowCoverPicture = !userData.isSelf || !!meta.config['reputation:disabled'] || userData.reputation >= meta.config['min:rep:cover-picture'];

	if (!userData.profileviews) {
		userData.profileviews = 1;
	}

	addMetaTags(res, userData);

	userData.selectedGroup = userData.groups.filter(group => group && userData.groupTitleArray.includes(group.name))
		.sort((a, b) => userData.groupTitleArray.indexOf(a.name) - userData.groupTitleArray.indexOf(b.name));

	res.render('account/profile', userData);
};

async function incrementProfileViews(req, userData) {
	if (req.uid >= 1) {
		req.session.uids_viewed = req.session.uids_viewed || {};

		if (
			req.uid !== userData.uid &&
			(!req.session.uids_viewed[userData.uid] || req.session.uids_viewed[userData.uid] < Date.now() - 3600000)
		) {
			await user.incrementUserFieldBy(userData.uid, 'profileviews', 1);
			req.session.uids_viewed[userData.uid] = Date.now();
		}
	}
}

async function getLatestPosts(callerUid, userData) {
	return await getPosts(callerUid, userData, 'pids');
}

async function getBestPosts(callerUid, userData) {
	return await getPosts(callerUid, userData, 'pids:votes');
}

async function getPosts(callerUid, userData, setSuffix) {
	const cids = await categories.getCidsByPrivilege('categories:cid', callerUid, 'topics:read');
	const keys = cids.map(c => `cid:${c}:uid:${userData.uid}:${setSuffix}`);
	let hasMorePosts = true;
	let start = 0;
	const count = 10;
	const postData = [];

	const [isAdmin, isModOfCids] = await Promise.all([
		user.isAdministrator(callerUid),
		user.isModerator(callerUid, cids),
	]);
	const cidToIsMod = _.zipObject(cids, isModOfCids);

	do {
		/* eslint-disable no-await-in-loop */
		const pids = await db.getSortedSetRevRange(keys, start, start + count - 1);
		if (!pids.length || pids.length < count) {
			hasMorePosts = false;
		}
		if (pids.length) {
			const p = await posts.getPostSummaryByPids(pids, callerUid, { stripTags: false });
			postData.push(...p.filter(
				p => p && p.topic && (isAdmin || cidToIsMod[p.topic.cid] || (!p.deleted && !p.topic.deleted))
			));
		}
		start += count;
	} while (postData.length < count && hasMorePosts);
	return postData.slice(0, count);
}

function addMetaTags(res, userData) {
	const plainAboutMe = userData.aboutme ? utils.stripHTMLTags(utils.decodeHTMLEntities(userData.aboutme)) : '';
	res.locals.metaTags = [
		{
			name: 'title',
			content: userData.fullname || userData.username,
			noEscape: true,
		},
		{
			name: 'description',
			content: plainAboutMe,
		},
		{
			property: 'og:title',
			content: userData.fullname || userData.username,
			noEscape: true,
		},
		{
			property: 'og:description',
			content: plainAboutMe,
		},
	];

	if (userData.picture) {
		res.locals.metaTags.push(
			{
				property: 'og:image',
				content: userData.picture,
				noEscape: true,
			},
			{
				property: 'og:image:url',
				content: userData.picture,
				noEscape: true,
'use strict';

const db = require('../../database');
const user = require('../../user');
const posts = require('../../posts');
const topics = require('../../topics');
const categories = require('../../categories');
const pagination = require('../../pagination');
const helpers = require('../helpers');
const accountHelpers = require('./helpers');

const postsController = module.exports;

const templateToData = {
	'account/bookmarks': {
		type: 'posts',
		noItemsFoundKey: '[[topic:bookmarks.has_no_bookmarks]]',
		crumb: '[[user:bookmarks]]',
		getSets: function (callerUid, userData) {
			return `uid:${userData.uid}:bookmarks`;
		},
	},
	'account/posts': {
		type: 'posts',
		noItemsFoundKey: '[[user:has_no_posts]]',
		crumb: '[[global:posts]]',
		getSets: async function (callerUid, userData) {
			const cids = await categories.getCidsByPrivilege('categories:cid', callerUid, 'topics:read');
			return cids.map(c => `cid:${c}:uid:${userData.uid}:pids`);
		},
	},
	'account/upvoted': {
		type: 'posts',
		noItemsFoundKey: '[[user:has_no_upvoted_posts]]',
		crumb: '[[global:upvoted]]',
		getSets: function (callerUid, userData) {
			return `uid:${userData.uid}:upvote`;
		},
	},
	'account/downvoted': {
		type: 'posts',
		noItemsFoundKey: '[[user:has_no_downvoted_posts]]',
		crumb: '[[global:downvoted]]',
		getSets: function (callerUid, userData) {
			return `uid:${userData.uid}:downvote`;
		},
	},
	'account/best': {
		type: 'posts',
		noItemsFoundKey: '[[user:has_no_voted_posts]]',
		crumb: '[[global:best]]',
		getSets: async function (callerUid, userData) {
			const cids = await categories.getCidsByPrivilege('categories:cid', callerUid, 'topics:read');
			return cids.map(c => `cid:${c}:uid:${userData.uid}:pids:votes`);
		},
	},
	'account/watched': {
		type: 'topics',
		noItemsFoundKey: '[[user:has_no_watched_topics]]',
		crumb: '[[user:watched]]',
		getSets: function (callerUid, userData) {
			return `uid:${userData.uid}:followed_tids`;
		},
		getTopics: async function (set, req, start, stop) {
			const { sort } = req.query;
			const map = {
				votes: 'topics:votes',
				posts: 'topics:posts',
				views: 'topics:views',
				lastpost: 'topics:recent',
				firstpost: 'topics:tid',
			};

			if (!sort || !map[sort]) {
				return await topics.getTopicsFromSet(set, req.uid, start, stop);
			}
			const sortSet = map[sort];
			let tids = await db.getSortedSetRevRange(set, 0, -1);
			const scores = await db.sortedSetScores(sortSet, tids);
			tids = tids.map((tid, i) => ({ tid: tid, score: scores[i] }))
				.sort((a, b) => b.score - a.score)
				.slice(start, stop + 1)
				.map(t => t.tid);

			const topicsData = await topics.getTopics(tids, req.uid);
			topics.calculateTopicIndices(topicsData, start);
			return { topics: topicsData, nextStart: stop + 1 };
		},
	},
	'account/ignored': {
		type: 'topics',
		noItemsFoundKey: '[[user:has_no_ignored_topics]]',
		crumb: '[[user:ignored]]',
		getSets: function (callerUid, userData) {
			return `uid:${userData.uid}:ignored_tids`;
		},
	},
	'account/topics': {
		type: 'topics',
		noItemsFoundKey: '[[user:has_no_topics]]',
		crumb: '[[global:topics]]',
		getSets: async function (callerUid, userData) {
			const cids = await categories.getCidsByPrivilege('categories:cid', callerUid, 'topics:read');
			return cids.map(c => `cid:${c}:uid:${userData.uid}:tids`);
		},
	},
};

postsController.getBookmarks = async function (req, res, next) {
	await getFromUserSet('account/bookmarks', req, res, next);
};

postsController.getPosts = async function (req, res, next) {
	await getFromUserSet('account/posts', req, res, next);
};

postsController.getUpVotedPosts = async function (req, res, next) {
	await getFromUserSet('account/upvoted', req, res, next);
};

postsController.getDownVotedPosts = async function (req, res, next) {
	await getFromUserSet('account/downvoted', req, res, next);
};

postsController.getBestPosts = async function (req, res, next) {
	await getFromUserSet('account/best', req, res, next);
};

postsController.getWatchedTopics = async function (req, res, next) {
	await getFromUserSet('account/watched', req, res, next);
};

postsController.getIgnoredTopics = async function (req, res, next) {
	await getFromUserSet('account/ignored', req, res, next);
};

postsController.getTopics = async function (req, res, next) {
	await getFromUserSet('account/topics', req, res, next);
};

async function getFromUserSet(template, req, res, callback) {
	const data = templateToData[template];
	const page = Math.max(1, parseInt(req.query.page, 10) || 1);

	const [userData, settings] = await Promise.all([
		accountHelpers.getUserDataByUserSlug(req.params.userslug, req.uid),
		user.getSettings(req.uid),
	]);

	if (!userData) {
		return callback();
	}
	const itemsPerPage = data.type === 'topics' ? settings.topicsPerPage : settings.postsPerPage;
	const start = (page - 1) * itemsPerPage;
	const stop = start + itemsPerPage - 1;
	const sets = await data.getSets(req.uid, userData);

	const [itemCount, itemData] = await Promise.all([
		settings.usePagination ? db.sortedSetsCardSum(sets) : 0,
		getItemData(sets, data, req, start, stop),
	]);

	userData[data.type] = itemData[data.type];
	userData.nextStart = itemData.nextStart;

	const pageCount = Math.ceil(itemCount / itemsPerPage);
	userData.pagination = pagination.create(page, pageCount, req.query);

	userData.noItemsFoundKey = data.noItemsFoundKey;
	userData.title = `[[pages:${template}, ${userData.username}]]`;
	userData.breadcrumbs = helpers.buildBreadcrumbs([{ text: userData.username, url: `/user/${userData.userslug}` }, { text: data.crumb }]);
	userData.showSort = template === 'account/watched';
	const baseUrl = (req.baseUrl + req.path.replace(/^\/api/, ''));
	userData.sortOptions = [
		{ url: `${baseUrl}?sort=votes`, name: '[[global:votes]]' },
		{ url: `${baseUrl}?sort=posts`, name: '[[global:posts]]' },
		{ url: `${baseUrl}?sort=views`, name: '[[global:views]]' },
		{ url: `${baseUrl}?sort=lastpost`, name: '[[global:lastpost]]' },
		{ url: `${baseUrl}?sort=firstpost`, name: '[[global:firstpost]]' },
	];
	userData.sortOptions.forEach((option) => {
		option.selected = option.url.includes(`sort=${req.query.sort}`);
	});

	res.render(template, userData);
}

async function getItemData(sets, data, req, start, stop) {
	if (data.getTopics) {
		return await data.getTopics(sets, req, start, stop);
'use strict';

const user = require('../../user');
const helpers = require('../helpers');
const accountHelpers = require('./helpers');
const pagination = require('../../pagination');

const followController = module.exports;

followController.getFollowing = async function (req, res, next) {
	await getFollow('account/following', 'following', req, res, next);
};

followController.getFollowers = async function (req, res, next) {
	await getFollow('account/followers', 'followers', req, res, next);
