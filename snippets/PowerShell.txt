$terminalProfile = "${HOME}\AppData\Local\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\profiles.json"

# Load existing profile
$configData = Get-Content -Path $terminalProfile | ConvertFrom-Json

# Get a list of scheme names to avoid duplicates
$installedNames = $configData.schemes | ForEach-Object { $_.name }

# Get color files into an array of schemes
$toInstall = Get-ChildItem -Path "${PSScriptRoot}\..\windowsterminal"  -Filter '*.json' | ForEach-Object { Get-Content $_ | ConvertFrom-Json }

# Filter out any schemes with conflicting names
if ($null -ne $installedNames) {
  $toInstall = $toInstall | Where-Object { !$installedNames.Contains($_.name) }
}

# Create a new list to store schemes
$newSchemes = New-Object Collections.Generic.List[Object]

# Get currently installed schemes
$configData.schemes | ForEach-Object { $newSchemes.Add($_) }

# Add new schemes to install
$toInstall | ForEach-Object { $newSchemes.Add($_) }

#requires -version 5
if (-not (Test-Path ../vscode)) {New-Item -ItemType Directory ../vscode}
Get-Item ../WindowsTerminal/*.json | Foreach-Object {
    write-verbose "Generating vscode theme for $($PSItem.name)"
    $theme = Get-Content -raw $PSItem | ConvertFrom-JSON
    @"
{
    "workbench.colorCustomizations": {
        "terminal.foreground": "$($theme.foreground)",
        "terminal.background": "$($theme.background)",
        "terminal.ansiBlack": "$($theme.black)",
        "terminal.ansiBlue": "$($theme.blue)",
        "terminal.ansiCyan": "$($theme.cyan)",
        "terminal.ansiGreen": "$($theme.green)",
        "terminal.ansiMagenta": "$($theme.purple)",
        "terminal.ansiRed": "$($theme.red)",
        "terminal.ansiWhite": "$($theme.white)",
        "terminal.ansiYellow": "$($theme.yellow)",
        "terminal.ansiBrightBlack": "$($theme.brightBlack)",
        "terminal.ansiBrightBlue": "$($theme.brightBlue)",
        "terminal.ansiBrightCyan": "$($theme.brightCyan)",
        "terminal.ansiBrightGreen": "$($theme.brightGreen)",
        "terminal.ansiBrightMagenta": "$($theme.brightPurple)",
        "terminal.ansiBrightRed": "$($theme.brightRed)",
        "terminal.ansiBrightWhite": "$($theme.brightWhite)",
        "terminal.ansiBrightYellow": "$($theme.brightYellow)"
    }
}
"@ > "../vscode/$($PSItem.Name)"
}
[CmdletBinding()]
Param(
    #[switch]$CustomParam,
    [Parameter(Position=0,Mandatory=$false,ValueFromRemainingArguments=$true)]
    [string[]]$BuildArguments
)

Write-Output "Windows PowerShell $($Host.Version)"

Set-StrictMode -Version 2.0; $ErrorActionPreference = "Stop"; $ConfirmPreference = "None"; trap { exit 1 }
$PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent

###########################################################################
# CONFIGURATION
###########################################################################

$BuildProjectFile = "$PSScriptRoot\nukebuild\_build.csproj"
$TempDirectory = "$PSScriptRoot\\.tmp"

$DotNetGlobalFile = "$PSScriptRoot\\global.json"
$DotNetInstallUrl = "https://raw.githubusercontent.com/dotnet/cli/master/scripts/obtain/dotnet-install.ps1"
$DotNetChannel = "Current"

$env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE = 1
$env:DOTNET_CLI_TELEMETRY_OPTOUT = 1
$env:NUGET_XMLDOC_MODE = "skip"

###########################################################################
# EXECUTION
###########################################################################

function ExecSafe([scriptblock] $cmd) {
    & $cmd
    if ($LASTEXITCODE) { exit $LASTEXITCODE }
}

# If global.json exists, load expected version
if (Test-Path $DotNetGlobalFile) {
    $DotNetGlobal = $(Get-Content $DotNetGlobalFile | Out-String | ConvertFrom-Json)
    if ($DotNetGlobal.PSObject.Properties["sdk"] -and $DotNetGlobal.sdk.PSObject.Properties["version"]) {
        $DotNetVersion = $DotNetGlobal.sdk.version
    }
}

# If dotnet is installed locally, and expected version is not set or installation matches the expected version
if ($null -ne (Get-Command "dotnet" -ErrorAction SilentlyContinue) -and `
     (!(Test-Path variable:DotNetVersion) -or $(& dotnet --version) -eq $DotNetVersion)) {
    $env:DOTNET_EXE = (Get-Command "dotnet").Path
}
else {
    $DotNetDirectory = "$TempDirectory\dotnet-win"
    $env:DOTNET_EXE = "$DotNetDirectory\dotnet.exe"

    # Download install script
    $DotNetInstallFile = "$TempDirectory\dotnet-install.ps1"
    mkdir -force $TempDirectory > $null
    (New-Object System.Net.WebClient).DownloadFile($DotNetInstallUrl, $DotNetInstallFile)

    # Install by channel or version
    if (!(Test-Path variable:DotNetVersion)) {
        ExecSafe { & $DotNetInstallFile -InstallDir $DotNetDirectory -Channel $DotNetChannel -NoPath }
    } else {
        ExecSafe { & $DotNetInstallFile -InstallDir $DotNetDirectory -Version $DotNetVersion -NoPath }
    }

    $env:PATH="$DotNetDirectory;$env:PATH"
}

Write-Output "Microsoft (R) .NET Core SDK version $(& $env:DOTNET_EXE --version)"

# WARNING: When editing this file, consider submitting a PR to
# https://github.com/kevpar/docker-w2wCIScripts/blob/master/runCI/executeCI.ps1, and make sure that
# https://github.com/kevpar/docker-w2wCIScripts/blob/master/runCI/Invoke-DockerCI.ps1 isn't broken.
# Validate using a test context in Jenkins, then copy/paste into Jenkins production.
#
# Jenkins CI scripts for Windows to Windows CI (Powershell Version)
# By John Howard (@jhowardmsft) January 2016 - bash version; July 2016 Ported to PowerShell

$ErrorActionPreference = 'Stop'
$StartTime=Get-Date

# Put up top to be blindingly obvious. The production jenkins.dockerproject.org Linux-container 
# CI job is "Docker-PRs-LoW-RS3". Force into LCOW mode for this run, or not.
if ($env:BUILD_TAG -match "-LoW") { $env:LCOW_MODE=1 }
if ($env:BUILD_TAG -match "-WoW") { $env:LCOW_MODE="" }


Write-Host -ForegroundColor Red "DEBUG: print all environment variables to check how Jenkins runs this script"
$allArgs = [Environment]::GetCommandLineArgs()
Write-Host -ForegroundColor Red $allArgs
Write-Host -ForegroundColor Red "----------------------------------------------------------------------------"

# -------------------------------------------------------------------------------------------
# When executed, we rely on four variables being set in the environment:
#
# [The reason for being environment variables rather than parameters is historical. No reason
# why it couldn't be updated.]
#
#    SOURCES_DRIVE       is the drive on which the sources being tested are cloned from.
#                        This should be a straight drive letter, no platform semantics.
#                        For example 'c'
#
#    SOURCES_SUBDIR      is the top level directory under SOURCES_DRIVE where the
#                        sources are cloned to. There are no platform semantics in this
#                        as it does not include slashes. 
#                        For example 'gopath'
#
#                        Based on the above examples, it would be expected that Jenkins
#                        would clone the sources being tested to
#                        SOURCES_DRIVE\SOURCES_SUBDIR\src\github.com\docker\docker, or
#                        c:\gopath\src\github.com\docker\docker
#
#    TESTRUN_DRIVE       is the drive where we build the binary on and redirect everything
#                        to for the daemon under test. On an Azure D2 type host which has
#                        an SSD temporary storage D: drive, this is ideal for performance.
#                        For example 'd'
#
#    TESTRUN_SUBDIR      is the top level directory under TESTRUN_DRIVE where we redirect
#                        everything to for the daemon under test. For example 'CI'.
#                        Hence, the daemon under test is run under
#                        TESTRUN_DRIVE\TESTRUN_SUBDIR\CI-<CommitID> or
#                        d:\CI\CI-<CommitID>
#
# Optional environment variables help in CI:
#
#    BUILD_NUMBER + BRANCH_NAME   are optional variables to be added to the directory below TESTRUN_SUBDIR
#                        to have individual folder per CI build. If some files couldn't be
#                        cleaned up and we want to re-run the build in CI.
#                        Hence, the daemon under test is run under
#                        TESTRUN_DRIVE\TESTRUN_SUBDIR\PR-<PR-Number>\<BuildNumber> or
#                        d:\CI\PR-<PR-Number>\<BuildNumber>
#
# In addition, the following variables can control the run configuration:
#
#    DOCKER_DUT_DEBUG         if defined starts the daemon under test in debug mode.
#
#   DOCKER_STORAGE_OPTS       comma-separated list of optional storage driver options for the daemon under test
#                             examples:
#                             DOCKER_STORAGE_OPTS="size=40G"
#                             DOCKER_STORAGE_OPTS="lcow.globalmode=false,lcow.kernel=kernel.efi"
#
#    SKIP_VALIDATION_TESTS    if defined skips the validation tests
#
#    SKIP_UNIT_TESTS          if defined skips the unit tests
#
#    SKIP_INTEGRATION_TESTS   if defined skips the integration tests
#
#    SKIP_COPY_GO             if defined skips copy the go installer from the image
#
#    DOCKER_DUT_HYPERV        if default daemon under test default isolation is hyperv
#
#    INTEGRATION_TEST_NAME    to only run partial tests eg "TestInfo*" will only run
#                             any tests starting "TestInfo"
#
#    SKIP_BINARY_BUILD        if defined skips building the binary
#
#    SKIP_ZAP_DUT             if defined doesn't zap the daemon under test directory
#
#    SKIP_IMAGE_BUILD         if defined doesn't build the 'docker' image
#
#    INTEGRATION_IN_CONTAINER if defined, runs the integration tests from inside a container.
#                             As of July 2016, there are known issues with this. 
#
#    SKIP_ALL_CLEANUP         if defined, skips any cleanup at the start or end of the run
#
#    WINDOWS_BASE_IMAGE       if defined, uses that as the base image. Note that the
#                             docker integration tests are also coded to use the same
#                             environment variable, and if no set, defaults to microsoft/windowsservercore
#
#    WINDOWS_BASE_IMAGE_TAG   if defined, uses that as the tag name for the base image.
#                             if no set, defaults to latest
#
#    LCOW_BASIC_MODE          if defined, does very basic LCOW verification. Ultimately we 
#                             want to run the entire CI suite from docker, but that's a way off.
#                            
#    LCOW_MODE                if defined, runs the entire CI suite
#                            
# -------------------------------------------------------------------------------------------
#
# Jenkins Integration. Add a Windows Powershell build step as follows:
#
#    Write-Host -ForegroundColor green "INFO: Jenkins build step starting"
#    $CISCRIPT_DEFAULT_LOCATION = "https://raw.githubusercontent.com/moby/moby/master/hack/ci/windows.ps1"
#    $CISCRIPT_LOCAL_LOCATION = "$env:TEMP\executeCI.ps1"
#    Write-Host -ForegroundColor green "INFO: Removing cached execution script"
#    Remove-Item $CISCRIPT_LOCAL_LOCATION -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
#    $wc = New-Object net.webclient
#    try {
#        Write-Host -ForegroundColor green "INFO: Downloading latest execution script..."
#        $wc.Downloadfile($CISCRIPT_DEFAULT_LOCATION, $CISCRIPT_LOCAL_LOCATION)
#    } 
#    catch [System.Net.WebException]
#    {
#        Throw ("Failed to download: $_")
#    }
#    & $CISCRIPT_LOCAL_LOCATION
# -------------------------------------------------------------------------------------------


$SCRIPT_VER="05-Feb-2019 09:03 PDT" 
$FinallyColour="Cyan"

#$env:DOCKER_DUT_DEBUG="yes" # Comment out to not be in debug mode
#$env:SKIP_UNIT_TESTS="yes"
#$env:SKIP_VALIDATION_TESTS="yes"
#$env:SKIP_ZAP_DUT=""
#$env:SKIP_BINARY_BUILD="yes"
#$env:INTEGRATION_TEST_NAME=""
#$env:SKIP_IMAGE_BUILD="yes"
#$env:SKIP_ALL_CLEANUP="yes"
#$env:INTEGRATION_IN_CONTAINER="yes"
#$env:WINDOWS_BASE_IMAGE=""
#$env:SKIP_COPY_GO="yes"
#$env:INTEGRATION_TESTFLAGS="-test.v"

Function Nuke-Everything {
    $ErrorActionPreference = 'SilentlyContinue'

    try {

        if ($null -eq $env:SKIP_ALL_CLEANUP) {
            Write-Host -ForegroundColor green "INFO: Nuke-Everything..."
            $containerCount = ($(docker ps -aq | Measure-Object -line).Lines) 
            if (-not $LastExitCode -eq 0) {
                Throw "ERROR: Failed to get container count from control daemon while nuking"
            }

            Write-Host -ForegroundColor green "INFO: Container count on control daemon to delete is $containerCount"
            if ($(docker ps -aq | Measure-Object -line).Lines -gt 0) {
                docker rm -f $(docker ps -aq)
            }

            $allImages  = $(docker images --format "{{.Repository}}#{{.ID}}")
            $toRemove   = ($allImages | Select-String -NotMatch "servercore","nanoserver","docker","busybox")
            $imageCount = ($toRemove | Measure-Object -line).Lines

            if ($imageCount -gt 0) {
                Write-Host -Foregroundcolor green "INFO: Non-base image count on control daemon to delete is $imageCount"
                docker rmi -f ($toRemove | Foreach-Object { $_.ToString().Split("#")[1] })
            }
        } else {
            Write-Host -ForegroundColor Magenta "WARN: Skipping cleanup of images and containers"
        }

        # Kill any spurious daemons. The '-' is IMPORTANT otherwise will kill the control daemon!
        $pids=$(get-process | where-object {$_.ProcessName -like 'dockerd-*'}).id
        foreach ($p in $pids) {
            Write-Host "INFO: Killing daemon with PID $p"
            Stop-Process -Id $p -Force -ErrorAction SilentlyContinue
        }

        if ($null -ne $pidFile) {
            Write-Host "INFO: Tidying pidfile $pidfile"
             if (Test-Path $pidFile) {
                $p=Get-Content $pidFile -raw
                if ($null -ne $p){
                    Write-Host -ForegroundColor green "INFO: Stopping possible daemon pid $p"
                    taskkill -f -t -pid $p
                }
                Remove-Item "$env:TEMP\docker.pid" -force -ErrorAction SilentlyContinue
            }
        }

        Stop-Process -name "cc1" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "link" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "compile" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "ld" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "go" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "git" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "git-remote-https" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "integration-cli.test" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null
        Stop-Process -name "tail" -Force -ErrorAction SilentlyContinue 2>&1 | Out-Null

        # Detach any VHDs
        gwmi msvm_mountedstorageimage -namespace root/virtualization/v2 -ErrorAction SilentlyContinue | foreach-object {$_.DetachVirtualHardDisk() }

        # Stop any compute processes
        Get-ComputeProcess | Stop-ComputeProcess -Force

        # Delete the directory using our dangerous utility unless told not to
        if (Test-Path "$env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR") {
            if (($null -ne $env:SKIP_ZAP_DUT) -or ($null -eq $env:SKIP_ALL_CLEANUP)) {
                Write-Host -ForegroundColor Green "INFO: Nuking $env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR"
                docker-ci-zap "-folder=$env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR"
            } else {
                Write-Host -ForegroundColor Magenta "WARN: Skip nuking $env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR"
            }
        }

        # TODO: This should be able to be removed in August 2017 update. Only needed for RS1  Production Server workaround - Psched
        $reg = "HKLM:\System\CurrentControlSet\Services\Psched\Parameters\NdisAdapters"
        $count=(Get-ChildItem $reg | Measure-Object).Count
        if ($count -gt 0) {
            Write-Warning "There are $count NdisAdapters leaked under Psched\Parameters"
            Write-Warning "Cleaning Psched..."
            Get-ChildItem $reg | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue | Out-Null
        }

        # TODO: This should be able to be removed in August 2017 update. Only needed for RS1
        $reg = "HKLM:\System\CurrentControlSet\Services\WFPLWFS\Parameters\NdisAdapters"
        $count=(Get-ChildItem $reg | Measure-Object).Count
        if ($count -gt 0) {
            Write-Warning "There are $count NdisAdapters leaked under WFPLWFS\Parameters"
            Write-Warning "Cleaning WFPLWFS..."
            Get-ChildItem $reg | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue | Out-Null
        }
    } catch {
        # Don't throw any errors onwards Throw $_
    }
}

Try {
    Write-Host -ForegroundColor Cyan "`nINFO: executeCI.ps1 starting at $(date)`n"
    Write-Host  -ForegroundColor Green "INFO: Script version $SCRIPT_VER"
    Set-PSDebug -Trace 0  # 1 to turn on
    $origPath="$env:PATH"            # so we can restore it at the end
    $origDOCKER_HOST="$DOCKER_HOST"  # So we can restore it at the end
    $origGOROOT="$env:GOROOT"        # So we can restore it at the end
    $origGOPATH="$env:GOPATH"        # So we can restore it at the end

    # Turn off progress bars
	$origProgressPreference=$global:ProgressPreference
	$global:ProgressPreference='SilentlyContinue'

    # Git version
    Write-Host  -ForegroundColor Green "INFO: Running $(git version)"

    # OS Version
    $bl=(Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion"  -Name BuildLabEx).BuildLabEx
    $a=$bl.ToString().Split(".")
    $Branch=$a[3]
    $WindowsBuild=$a[0]+"."+$a[1]+"."+$a[4]
    Write-Host -ForegroundColor green "INFO: Branch:$Branch Build:$WindowsBuild"

    # List the environment variables
    Write-Host -ForegroundColor green "INFO: Environment variables:"
    Get-ChildItem Env: | Out-String

    # PR
    if (-not ($null -eq $env:PR)) { Write-Output "INFO: PR#$env:PR (https://github.com/docker/docker/pull/$env:PR)" }

    # Make sure docker is installed
    if ($null -eq (Get-Command "docker" -ErrorAction SilentlyContinue)) { Throw "ERROR: docker is not installed or not found on path" }

    # Make sure docker-ci-zap is installed
    if ($null -eq (Get-Command "docker-ci-zap" -ErrorAction SilentlyContinue)) { Throw "ERROR: docker-ci-zap is not installed or not found on path" }

    # Make sure Windows Defender is disabled
    $defender = $false
    Try {
      $status = Get-MpComputerStatus
      if ($status) {
        if ($status.RealTimeProtectionEnabled) {
          $defender = $true
        }
      }
    } Catch {}
    if ($defender) { Write-Host -ForegroundColor Magenta "WARN: Windows Defender real time protection is enabled, which may cause some integration tests to fail" }

    # Make sure SOURCES_DRIVE is set
    if ($null -eq $env:SOURCES_DRIVE) { Throw "ERROR: Environment variable SOURCES_DRIVE is not set" }

    # Make sure TESTRUN_DRIVE is set
    if ($null -eq $env:TESTRUN_DRIVE) { Throw "ERROR: Environment variable TESTRUN_DRIVE is not set" }

    # Make sure SOURCES_SUBDIR is set
    if ($null -eq $env:SOURCES_SUBDIR) { Throw "ERROR: Environment variable SOURCES_SUBDIR is not set" }

    # Make sure TESTRUN_SUBDIR is set
    if ($null -eq $env:TESTRUN_SUBDIR) { Throw "ERROR: Environment variable TESTRUN_SUBDIR is not set" }

    # SOURCES_DRIVE\SOURCES_SUBDIR must be a directory and exist
    if (-not (Test-Path -PathType Container "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR")) { Throw "ERROR: $env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR must be an existing directory" }

    # Create the TESTRUN_DRIVE\TESTRUN_SUBDIR if it does not already exist
    New-Item -ItemType Directory -Force -Path "$env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR" -ErrorAction SilentlyContinue | Out-Null

    Write-Host  -ForegroundColor Green "INFO: Sources under $env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\..."
    Write-Host  -ForegroundColor Green "INFO: Test run under $env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR\..."

    # Check the intended source location is a directory
    if (-not (Test-Path -PathType Container "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker" -ErrorAction SilentlyContinue)) {
        Throw "ERROR: $env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker is not a directory!"
    }

    # Make sure we start at the root of the sources
    Set-Location "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker"
    Write-Host  -ForegroundColor Green "INFO: Running in $(Get-Location)"

    # Make sure we are in repo
    if (-not (Test-Path -PathType Leaf -Path ".\Dockerfile.windows")) {
        Throw "$(Get-Location) does not contain Dockerfile.windows!"
    }
    Write-Host  -ForegroundColor Green "INFO: docker/docker repository was found"

    # Make sure microsoft/windowsservercore:latest image is installed in the control daemon. On public CI machines, windowsservercore.tar and nanoserver.tar
    # are pre-baked and tagged appropriately in the c:\baseimages directory, and can be directly loaded. 
    # Note - this script will only work on 10B (Oct 2016) or later machines! Not 9D or previous due to image tagging assumptions.
    #
    # On machines not on Microsoft corpnet, or those which have not been pre-baked, we have to docker pull the image in which case it will
    # will come in directly as microsoft/windowsservercore:latest. The ultimate goal of all this code is to ensure that whatever,
    # we have microsoft/windowsservercore:latest
    #
    # Note we cannot use (as at Oct 2016) nanoserver as the control daemons base image, even if nanoserver is used in the tests themselves.

    $ErrorActionPreference = "SilentlyContinue"
    $ControlDaemonBaseImage="windowsservercore"

    $readBaseFrom="c"
    if ($((docker images --format "{{.Repository}}:{{.Tag}}" | Select-String $("microsoft/"+$ControlDaemonBaseImage+":latest") | Measure-Object -Line).Lines) -eq 0) {
        # Try the internal azure CI image version or Microsoft internal corpnet where the base image is already pre-prepared on the disk,
        # either through Invoke-DockerCI or, in the case of Azure CI servers, baked into the VHD at the same location.
        if (Test-Path $("$env:SOURCES_DRIVE`:\baseimages\"+$ControlDaemonBaseImage+".tar")) {
            # An optimization for CI servers to copy it to the D: drive which is an SSD.
            if ($env:SOURCES_DRIVE -ne $env:TESTRUN_DRIVE) {
                $readBaseFrom=$env:TESTRUN_DRIVE
                if (!(Test-Path "$env:TESTRUN_DRIVE`:\baseimages")) {
                    New-Item "$env:TESTRUN_DRIVE`:\baseimages" -type directory | Out-Null
                }
                if (!(Test-Path "$env:TESTRUN_DRIVE`:\baseimages\windowsservercore.tar")) {
                    if (Test-Path "$env:SOURCES_DRIVE`:\baseimages\windowsservercore.tar") {
                        Write-Host -ForegroundColor Green "INFO: Optimisation - copying $env:SOURCES_DRIVE`:\baseimages\windowsservercore.tar to $env:TESTRUN_DRIVE`:\baseimages"
                        Copy-Item "$env:SOURCES_DRIVE`:\baseimages\windowsservercore.tar" "$env:TESTRUN_DRIVE`:\baseimages"
                    }
                }
                if (!(Test-Path "$env:TESTRUN_DRIVE`:\baseimages\nanoserver.tar")) {
                    if (Test-Path "$env:SOURCES_DRIVE`:\baseimages\nanoserver.tar") {
                        Write-Host -ForegroundColor Green "INFO: Optimisation - copying $env:SOURCES_DRIVE`:\baseimages\nanoserver.tar to $env:TESTRUN_DRIVE`:\baseimages"
                        Copy-Item "$env:SOURCES_DRIVE`:\baseimages\nanoserver.tar" "$env:TESTRUN_DRIVE`:\baseimages"
                    }
                }
                $readBaseFrom=$env:TESTRUN_DRIVE
            }
            Write-Host  -ForegroundColor Green "INFO: Loading"$ControlDaemonBaseImage".tar from disk. This may take some time..."
            $ErrorActionPreference = "SilentlyContinue"
            docker load -i $("$readBaseFrom`:\baseimages\"+$ControlDaemonBaseImage+".tar")
            $ErrorActionPreference = "Stop"
            if (-not $LastExitCode -eq 0) {
                Throw $("ERROR: Failed to load $readBaseFrom`:\baseimages\"+$ControlDaemonBaseImage+".tar")
            }
            Write-Host -ForegroundColor Green "INFO: docker load of"$ControlDaemonBaseImage" completed successfully"
        } else {
            # We need to docker pull it instead. It will come in directly as microsoft/imagename:latest
            Write-Host -ForegroundColor Green $("INFO: Pulling $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG from docker hub. This may take some time...")
            $ErrorActionPreference = "SilentlyContinue"
            docker pull "$($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG"
            $ErrorActionPreference = "Stop"
            if (-not $LastExitCode -eq 0) {
                Throw $("ERROR: Failed to docker pull $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG.")
            }
            Write-Host -ForegroundColor Green $("INFO: docker pull of $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG completed successfully")
            Write-Host -ForegroundColor Green $("INFO: Tagging $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG as microsoft/$ControlDaemonBaseImage")
            docker tag "$($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG" microsoft/$ControlDaemonBaseImage
        }
    } else {
        Write-Host -ForegroundColor Green "INFO: Image"$("microsoft/"+$ControlDaemonBaseImage+":latest")"is already loaded in the control daemon"
    }

    # Inspect the pulled image to get the version directly
    $ErrorActionPreference = "SilentlyContinue"
    $imgVersion = $(docker inspect  $("microsoft/"+$ControlDaemonBaseImage) --format "{{.OsVersion}}")
    $ErrorActionPreference = "Stop"
    Write-Host -ForegroundColor Green $("INFO: Version of microsoft/"+$ControlDaemonBaseImage+":latest is '"+$imgVersion+"'")

    # Provide the docker version for debugging purposes.
    Write-Host  -ForegroundColor Green "INFO: Docker version of control daemon"
    Write-Host
    $ErrorActionPreference = "SilentlyContinue"
    docker version
    $ErrorActionPreference = "Stop"
    if (-not($LastExitCode -eq 0)) {
        Write-Host 
        Write-Host  -ForegroundColor Green "---------------------------------------------------------------------------"
        Write-Host  -ForegroundColor Green " Failed to get a response from the control daemon. It may be down."
        Write-Host  -ForegroundColor Green " Try re-running this CI job, or ask on #docker-maintainers on docker slack"
        Write-Host  -ForegroundColor Green " to see if the daemon is running. Also check the service configuration."
        Write-Host  -ForegroundColor Green " DOCKER_HOST is set to $DOCKER_HOST."
        Write-Host  -ForegroundColor Green "---------------------------------------------------------------------------"
        Write-Host 
        Throw "ERROR: The control daemon does not appear to be running."
    }
    Write-Host

    # Same as above, but docker info
    Write-Host  -ForegroundColor Green "INFO: Docker info of control daemon"
    Write-Host
    $ErrorActionPreference = "SilentlyContinue"
    docker info
    $ErrorActionPreference = "Stop"
    if (-not($LastExitCode -eq 0)) {
        Throw "ERROR: The control daemon does not appear to be running."
    }
    Write-Host

    # Get the commit has and verify we have something
    $ErrorActionPreference = "SilentlyContinue"
    $COMMITHASH=$(git rev-parse --short HEAD)
    $ErrorActionPreference = "Stop"
    if (-not($LastExitCode -eq 0)) {
        Throw "ERROR: Failed to get commit hash. Are you sure this is a docker repository?"
    }
    Write-Host  -ForegroundColor Green "INFO: Commit hash is $COMMITHASH"

    # Nuke everything and go back to our sources after
    Nuke-Everything
    cd "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker"

    # Redirect to a temporary location. 
    $TEMPORIG=$env:TEMP
    if ($null -eq $env:BUILD_NUMBER) {
      $env:TEMP="$env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR\CI-$COMMITHASH"
    } else {
      # individual temporary location per CI build that better matches the BUILD_URL
      $env:TEMP="$env:TESTRUN_DRIVE`:\$env:TESTRUN_SUBDIR\$env:BRANCH_NAME\$env:BUILD_NUMBER"
    }
    $env:LOCALAPPDATA="$env:TEMP\localappdata"
    $errorActionPreference='Stop'
    New-Item -ItemType Directory "$env:TEMP" -ErrorAction SilentlyContinue | Out-Null
    New-Item -ItemType Directory "$env:TEMP\userprofile" -ErrorAction SilentlyContinue  | Out-Null
    New-Item -ItemType Directory "$env:TEMP\testresults" -ErrorAction SilentlyContinue  | Out-Null
    New-Item -ItemType Directory "$env:TEMP\testresults\unittests" -ErrorAction SilentlyContinue  | Out-Null
    New-Item -ItemType Directory "$env:TEMP\localappdata" -ErrorAction SilentlyContinue | Out-Null
    New-Item -ItemType Directory "$env:TEMP\binary" -ErrorAction SilentlyContinue | Out-Null
    New-Item -ItemType Directory "$env:TEMP\installer" -ErrorAction SilentlyContinue | Out-Null
    if ($null -eq $env:SKIP_COPY_GO) {
        # Wipe the previous version of GO - we're going to get it out of the image
        if (Test-Path "$env:TEMP\go") { Remove-Item "$env:TEMP\go" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null }
        New-Item -ItemType Directory "$env:TEMP\go" -ErrorAction SilentlyContinue | Out-Null
    }

    Write-Host -ForegroundColor Green "INFO: Location for testing is $env:TEMP"

    # CI Integrity check - ensure Dockerfile.windows and Dockerfile go versions match
    $goVersionDockerfileWindows=(Select-String -Path ".\Dockerfile.windows" -Pattern "^ARG[\s]+GO_VERSION=(.*)$").Matches.groups[1].Value
    $goVersionDockerfile=(Select-String -Path ".\Dockerfile" -Pattern "^ARG[\s]+GO_VERSION=(.*)$").Matches.groups[1].Value

    if ($null -eq $goVersionDockerfile) {
        Throw "ERROR: Failed to extract golang version from Dockerfile"
    }
    Write-Host  -ForegroundColor Green "INFO: Validating GOLang consistency in Dockerfile.windows..."
    if (-not ($goVersionDockerfile -eq $goVersionDockerfileWindows)) {
        Throw "ERROR: Mismatched GO versions between Dockerfile and Dockerfile.windows. Update your PR to ensure that both files are updated and in sync. $goVersionDockerfile $goVersionDockerfileWindows"
    }

    # Build the image
    if ($null -eq $env:SKIP_IMAGE_BUILD) {
        Write-Host  -ForegroundColor Cyan "`n`nINFO: Building the image from Dockerfile.windows at $(Get-Date)..."
        Write-Host
        $ErrorActionPreference = "SilentlyContinue"
        $Duration=$(Measure-Command { docker build --build-arg=GO_VERSION -t docker -f Dockerfile.windows . | Out-Host })
        $ErrorActionPreference = "Stop"
        if (-not($LastExitCode -eq 0)) {
           Throw "ERROR: Failed to build image from Dockerfile.windows"
        }
        Write-Host  -ForegroundColor Green "INFO: Image build ended at $(Get-Date). Duration`:$Duration"
    } else {
        Write-Host -ForegroundColor Magenta "WARN: Skipping building the docker image"
    }

    # Following at the moment must be docker\docker as it's dictated by dockerfile.Windows
    $contPath="$COMMITHASH`:c`:\gopath\src\github.com\docker\docker\bundles"

    # After https://github.com/docker/docker/pull/30290, .git was added to .dockerignore. Therefore
    # we have to calculate unsupported outside of the container, and pass the commit ID in through
    # an environment variable for the binary build
    $CommitUnsupported=""
    if ($(git status --porcelain --untracked-files=no).Length -ne 0) {
        $CommitUnsupported="-unsupported"
    }

    # Build the binary in a container unless asked to skip it.
    if ($null -eq $env:SKIP_BINARY_BUILD) {
        Write-Host  -ForegroundColor Cyan "`n`nINFO: Building the test binaries at $(Get-Date)..."
        $ErrorActionPreference = "SilentlyContinue"
        docker rm -f $COMMITHASH 2>&1 | Out-Null
        if ($CommitUnsupported -ne "") {
            Write-Host ""
            Write-Warning "This version is unsupported because there are uncommitted file(s)."
            Write-Warning "Either commit these changes, or add them to .gitignore."
            git status --porcelain --untracked-files=no | Write-Warning
             Write-Host ""
        }
        $Duration=$(Measure-Command {docker run --name $COMMITHASH -e DOCKER_GITCOMMIT=$COMMITHASH$CommitUnsupported docker hack\make.ps1 -Daemon -Client | Out-Host })
        $ErrorActionPreference = "Stop"
        if (-not($LastExitCode -eq 0)) {
            Throw "ERROR: Failed to build binary"
        }
        Write-Host  -ForegroundColor Green "INFO: Binaries build ended at $(Get-Date). Duration`:$Duration"

        # Copy the binaries and the generated version_autogen.go out of the container
        $ErrorActionPreference = "SilentlyContinue"
        docker cp "$contPath\docker.exe" $env:TEMP\binary\
        if (-not($LastExitCode -eq 0)) {
            Throw "ERROR: Failed to docker cp the client binary (docker.exe) to $env:TEMP\binary"
        }
        docker cp "$contPath\dockerd.exe" $env:TEMP\binary\
        if (-not($LastExitCode -eq 0)) {
            Throw "ERROR: Failed to docker cp the daemon binary (dockerd.exe) to $env:TEMP\binary"
        }

        docker cp "$COMMITHASH`:c`:\gopath\bin\gotestsum.exe" $env:TEMP\binary\
        if (-not (Test-Path "$env:TEMP\binary\gotestsum.exe")) {
            Throw "ERROR: gotestsum.exe not found...." `
        }

        $ErrorActionPreference = "Stop"

        # Copy the built dockerd.exe to dockerd-$COMMITHASH.exe so that easily spotted in task manager.
        Write-Host -ForegroundColor Green "INFO: Copying the built daemon binary to $env:TEMP\binary\dockerd-$COMMITHASH.exe..."
        Copy-Item $env:TEMP\binary\dockerd.exe $env:TEMP\binary\dockerd-$COMMITHASH.exe -Force -ErrorAction SilentlyContinue

        # Copy the built docker.exe to docker-$COMMITHASH.exe
        Write-Host -ForegroundColor Green "INFO: Copying the built client binary to $env:TEMP\binary\docker-$COMMITHASH.exe..."
        Copy-Item $env:TEMP\binary\docker.exe $env:TEMP\binary\docker-$COMMITHASH.exe -Force -ErrorAction SilentlyContinue

    } else {
        Write-Host -ForegroundColor Magenta "WARN: Skipping building the binaries"
    }

    Write-Host -ForegroundColor Green "INFO: Copying dockerversion from the container..."
    $ErrorActionPreference = "SilentlyContinue"
    docker cp "$contPath\..\dockerversion\version_autogen.go" "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker\dockerversion"
    if (-not($LastExitCode -eq 0)) {
         Throw "ERROR: Failed to docker cp the generated version_autogen.go to $env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker\dockerversion"
    }
    $ErrorActionPreference = "Stop"

    # Grab the golang installer out of the built image. That way, we know we are consistent once extracted and paths set,
    # so there's no need to re-deploy on account of an upgrade to the version of GO being used in docker.
    if ($null -eq $env:SKIP_COPY_GO) {
        Write-Host -ForegroundColor Green "INFO: Copying the golang package from the container to $env:TEMP\installer\go.zip..."
        docker cp "$COMMITHASH`:c`:\go.zip" $env:TEMP\installer\
        if (-not($LastExitCode -eq 0)) {
            Throw "ERROR: Failed to docker cp the golang installer 'go.zip' from container:c:\go.zip to $env:TEMP\installer"
        }
        $ErrorActionPreference = "Stop"

        # Extract the golang installer
        Write-Host -ForegroundColor Green "INFO: Extracting go.zip to $env:TEMP\go"
        $Duration=$(Measure-Command { Expand-Archive $env:TEMP\installer\go.zip $env:TEMP -Force | Out-Null})
        Write-Host  -ForegroundColor Green "INFO: Extraction ended at $(Get-Date). Duration`:$Duration"    
    } else {
        Write-Host -ForegroundColor Magenta "WARN: Skipping copying and extracting golang from the image"
    }

    # Set the GOPATH
    Write-Host -ForegroundColor Green "INFO: Updating the golang and path environment variables"
    $env:GOPATH="$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR"
    Write-Host -ForegroundColor Green "INFO: GOPATH=$env:GOPATH"

    # Set the path to have the version of go from the image at the front
    $env:PATH="$env:TEMP\go\bin;$env:PATH"

    # Set the GOROOT to be our copy of go from the image
    $env:GOROOT="$env:TEMP\go"
    Write-Host -ForegroundColor Green "INFO: $(go version)"
    
    # Work out the -H parameter for the daemon under test (DASHH_DUT) and client under test (DASHH_CUT)
    #$DASHH_DUT="npipe:////./pipe/$COMMITHASH" # Can't do remote named pipe
    #$ip = (resolve-dnsname $env:COMPUTERNAME -type A -NoHostsFile -LlmnrNetbiosOnly).IPAddress # Useful to tie down
    $DASHH_CUT="tcp://127.0.0.1`:2357"    # Not a typo for 2375!
    $DASHH_DUT="tcp://0.0.0.0:2357"       # Not a typo for 2375!

    # Arguments for the daemon under test
    $dutArgs=@()
    $dutArgs += "-H $DASHH_DUT"
    $dutArgs += "--data-root $env:TEMP\daemon"
    $dutArgs += "--pidfile $env:TEMP\docker.pid"

    # Save the PID file so we can nuke it if set
    $pidFile="$env:TEMP\docker.pid"

    # Arguments: Are we starting the daemon under test in debug mode?
    if (-not ("$env:DOCKER_DUT_DEBUG" -eq "")) {
        Write-Host -ForegroundColor Green "INFO: Running the daemon under test in debug mode"
        $dutArgs += "-D"
    }

    # Arguments: Are we starting the daemon under test with Hyper-V containers as the default isolation?
    if (-not ("$env:DOCKER_DUT_HYPERV" -eq "")) {
        Write-Host -ForegroundColor Green "INFO: Running the daemon under test with Hyper-V containers as the default"
        $dutArgs += "--exec-opt isolation=hyperv"
    }

    # Arguments: Allow setting optional storage-driver options
    # example usage: DOCKER_STORAGE_OPTS="lcow.globalmode=false,lcow.kernel=kernel.efi"
    if (-not ("$env:DOCKER_STORAGE_OPTS" -eq "")) {
        Write-Host -ForegroundColor Green "INFO: Running the daemon under test with storage-driver options ${env:DOCKER_STORAGE_OPTS}"
        $env:DOCKER_STORAGE_OPTS.Split(",") | ForEach {
            $dutArgs += "--storage-opt $_"
        }
    }

    # Start the daemon under test, ensuring everything is redirected to folders under $TEMP.
    # Important - we launch the -$COMMITHASH version so that we can kill it without
    # killing the control daemon. 
    Write-Host -ForegroundColor Green "INFO: Starting a daemon under test..."
    Write-Host -ForegroundColor Green "INFO: Args: $dutArgs"
    New-Item -ItemType Directory $env:TEMP\daemon -ErrorAction SilentlyContinue  | Out-Null

    # In LCOW mode, for now we need to set an environment variable before starting the daemon under test
    if (($null -ne $env:LCOW_MODE) -or ($null -ne $env:LCOW_BASIC_MODE)) {
        $env:LCOW_SUPPORTED=1
    }

    # Cannot fathom why, but always writes to stderr....
    Start-Process "$env:TEMP\binary\dockerd-$COMMITHASH" `
                  -ArgumentList $dutArgs `
                  -RedirectStandardOutput "$env:TEMP\dut.out" `
                  -RedirectStandardError "$env:TEMP\dut.err" 
    Write-Host -ForegroundColor Green "INFO: Process started successfully."
    $daemonStarted=1

    # In LCOW mode, turn off that variable
    if (($null -ne $env:LCOW_MODE) -or ($null -ne $env:LCOW_BASIC_MODE)) {
        $env:LCOW_SUPPORTED=""
    }


    # Start tailing the daemon under test if the command is installed
    if ($null -ne (Get-Command "tail" -ErrorAction SilentlyContinue)) {
        Write-Host -ForegroundColor green "INFO: Start tailing logs of the daemon under tests"
        $tail = Start-Process "tail" -ArgumentList "-f $env:TEMP\dut.out" -PassThru -ErrorAction SilentlyContinue
    }

    # Verify we can get the daemon under test to respond 
    $tries=20
    Write-Host -ForegroundColor Green "INFO: Waiting for the daemon under test to start..."
    while ($true) {
        $ErrorActionPreference = "SilentlyContinue"
        & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" version 2>&1 | Out-Null
        $ErrorActionPreference = "Stop"
        if ($LastExitCode -eq 0) {
            break
        }

        $tries--
        if ($tries -le 0) {
            Throw "ERROR: Failed to get a response from the daemon under test"
        }
        Write-Host -NoNewline "."
        sleep 1
    }
    Write-Host -ForegroundColor Green "INFO: Daemon under test started and replied!"

    # Provide the docker version of the daemon under test for debugging purposes.
    Write-Host -ForegroundColor Green "INFO: Docker version of the daemon under test"
    Write-Host 
    $ErrorActionPreference = "SilentlyContinue"
    & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" version
    $ErrorActionPreference = "Stop"
    if ($LastExitCode -ne 0) {
        Throw "ERROR: The daemon under test does not appear to be running."
    }
    Write-Host

    # Same as above but docker info
    Write-Host -ForegroundColor Green "INFO: Docker info of the daemon under test"
    Write-Host 
    $ErrorActionPreference = "SilentlyContinue"
    & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" info
    $ErrorActionPreference = "Stop"
    if ($LastExitCode -ne 0) {
        Throw "ERROR: The daemon under test does not appear to be running."
    }
    Write-Host

    # Same as above but docker images
    Write-Host -ForegroundColor Green "INFO: Docker images of the daemon under test"
    Write-Host 
    $ErrorActionPreference = "SilentlyContinue"
    & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" images
    $ErrorActionPreference = "Stop"
    if ($LastExitCode -ne 0) {
        Throw "ERROR: The daemon under test does not appear to be running."
    }
    Write-Host

    # Don't need Windows images when in LCOW mode.
    if (($null -eq $env:LCOW_MODE) -and ($null -eq $env:LCOW_BASIC_MODE)) {

        # Default to windowsservercore for the base image used for the tests. The "docker" image
        # and the control daemon use microsoft/windowsservercore regardless. This is *JUST* for the tests.
        if ($null -eq $env:WINDOWS_BASE_IMAGE) {
            $env:WINDOWS_BASE_IMAGE="microsoft/windowsservercore"
        }
        if ($null -eq $env:WINDOWS_BASE_IMAGE_TAG) {
            $env:WINDOWS_BASE_IMAGE_TAG="latest"
        }

        # Lowercase and make sure it has a microsoft/ prefix
        $env:WINDOWS_BASE_IMAGE = $env:WINDOWS_BASE_IMAGE.ToLower()
        if (! $($env:WINDOWS_BASE_IMAGE -Split "/")[0] -match "microsoft") {
            Throw "ERROR: WINDOWS_BASE_IMAGE should start microsoft/ or mcr.microsoft.com/"
        }

        Write-Host -ForegroundColor Green "INFO: Base image for tests is $env:WINDOWS_BASE_IMAGE"

        $ErrorActionPreference = "SilentlyContinue"
        if ($((& "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" images --format "{{.Repository}}:{{.Tag}}" | Select-String "$($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG" | Measure-Object -Line).Lines) -eq 0) {
            # Try the internal azure CI image version or Microsoft internal corpnet where the base image is already pre-prepared on the disk,
            # either through Invoke-DockerCI or, in the case of Azure CI servers, baked into the VHD at the same location.
            if (Test-Path $("c:\baseimages\"+$($env:WINDOWS_BASE_IMAGE -Split "/")[1]+".tar")) {
                Write-Host  -ForegroundColor Green "INFO: Loading"$($env:WINDOWS_BASE_IMAGE -Split "/")[1]".tar from disk into the daemon under test. This may take some time..."
                $ErrorActionPreference = "SilentlyContinue"
                & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" load -i $("$readBaseFrom`:\baseimages\"+$($env:WINDOWS_BASE_IMAGE -Split "/")[1]+".tar")
                $ErrorActionPreference = "Stop"
                if (-not $LastExitCode -eq 0) {
                    Throw $("ERROR: Failed to load $readBaseFrom`:\baseimages\"+$($env:WINDOWS_BASE_IMAGE -Split "/")[1]+".tar into daemon under test")
                }
                Write-Host -ForegroundColor Green "INFO: docker load of"$($env:WINDOWS_BASE_IMAGE -Split "/")[1]" into daemon under test completed successfully"
            } else {
                # We need to docker pull it instead. It will come in directly as microsoft/imagename:tagname
                Write-Host -ForegroundColor Green $("INFO: Pulling "+$env:WINDOWS_BASE_IMAGE+":"+$env:WINDOWS_BASE_IMAGE_TAG+" from docker hub into daemon under test. This may take some time...")
                $ErrorActionPreference = "SilentlyContinue"
                & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" pull "$($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG"
                $ErrorActionPreference = "Stop"
                if (-not $LastExitCode -eq 0) {
                    Throw $("ERROR: Failed to docker pull $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG into daemon under test.")
                }
                Write-Host -ForegroundColor Green $("INFO: docker pull of $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG into daemon under test completed successfully")
                Write-Host -ForegroundColor Green $("INFO: Tagging $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG as microsoft/$ControlDaemonBaseImage in daemon under test")
                & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" tag "$($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG" microsoft/$ControlDaemonBaseImage
            }
        } else {
            Write-Host -ForegroundColor Green "INFO: Image $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG is already loaded in the daemon under test"
        }
    
    
        # Inspect the pulled or loaded image to get the version directly
        $ErrorActionPreference = "SilentlyContinue"
        $dutimgVersion = $(&"$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" inspect "$($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG" --format "{{.OsVersion}}")
        $ErrorActionPreference = "Stop"
        Write-Host -ForegroundColor Green $("INFO: Version of $($env:WINDOWS_BASE_IMAGE):$env:WINDOWS_BASE_IMAGE_TAG is '"+$dutimgVersion+"'")
    }

    # Run the validation tests unless SKIP_VALIDATION_TESTS is defined.
    if ($null -eq $env:SKIP_VALIDATION_TESTS) {
        Write-Host -ForegroundColor Cyan "INFO: Running validation tests at $(Get-Date)..."
        $ErrorActionPreference = "SilentlyContinue"
        $Duration=$(Measure-Command { hack\make.ps1 -DCO -GoFormat -PkgImports | Out-Host })
        $ErrorActionPreference = "Stop"
        if (-not($LastExitCode -eq 0)) {
            Throw "ERROR: Validation tests failed"
        }
        Write-Host  -ForegroundColor Green "INFO: Validation tests ended at $(Get-Date). Duration`:$Duration"
    } else {
        Write-Host -ForegroundColor Magenta "WARN: Skipping validation tests"
    }

    # Note the unit tests won't work in LCOW mode as I turned off loading the base images above.
    # Run the unit tests inside a container unless SKIP_UNIT_TESTS is defined
    if (($null -eq $env:LCOW_MODE) -and ($null -eq $env:LCOW_BASIC_MODE)) {
        if ($null -eq $env:SKIP_UNIT_TESTS) {
            $ContainerNameForUnitTests = $COMMITHASH + "_UnitTests"
            Write-Host -ForegroundColor Cyan "INFO: Running unit tests at $(Get-Date)..."
            $ErrorActionPreference = "SilentlyContinue"
            $Duration=$(Measure-Command {docker run --name $ContainerNameForUnitTests -e DOCKER_GITCOMMIT=$COMMITHASH$CommitUnsupported docker hack\make.ps1 -TestUnit | Out-Host })
            $TestRunExitCode = $LastExitCode
            $ErrorActionPreference = "Stop"

            # Saving where jenkins will take a look at.....
            New-Item -Force -ItemType Directory bundles | Out-Null
            $unitTestsContPath="$ContainerNameForUnitTests`:c`:\gopath\src\github.com\docker\docker\bundles"
            $JunitExpectedContFilePath = "$unitTestsContPath\junit-report-unit-tests.xml"
            docker cp $JunitExpectedContFilePath "bundles"
            if (-not($LastExitCode -eq 0)) {
                Throw "ERROR: Failed to docker cp the unit tests report ($JunitExpectedContFilePath) to bundles"
            }

            if (Test-Path "bundles\junit-report-unit-tests.xml") {
                Write-Host -ForegroundColor Magenta "INFO: Unit tests results(bundles\junit-report-unit-tests.xml) exist. pwd=$pwd"
            } else {
                Write-Host -ForegroundColor Magenta "ERROR: Unit tests results(bundles\junit-report-unit-tests.xml) do not exist. pwd=$pwd"
            }

            if (-not($TestRunExitCode -eq 0)) {
                Throw "ERROR: Unit tests failed"
            }
            Write-Host  -ForegroundColor Green "INFO: Unit tests ended at $(Get-Date). Duration`:$Duration"
        } else {
            Write-Host -ForegroundColor Magenta "WARN: Skipping unit tests"
        }
    }

    # Add the Windows busybox image. Needed for WCOW integration tests
    if (($null -eq $env:LCOW_MODE) -and ($null -eq $env:LCOW_BASIC_MODE)) {
        if ($null -eq $env:SKIP_INTEGRATION_TESTS) {
            Write-Host -ForegroundColor Green "INFO: Building busybox"
            $ErrorActionPreference = "SilentlyContinue"
            $(& "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" build  -t busybox --build-arg WINDOWS_BASE_IMAGE --build-arg WINDOWS_BASE_IMAGE_TAG "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker\contrib\busybox\" | Out-Host)
            $ErrorActionPreference = "Stop"
            if (-not($LastExitCode -eq 0)) {
                Throw "ERROR: Failed to build busybox image"
            }

            Write-Host -ForegroundColor Green "INFO: Docker images of the daemon under test"
            Write-Host 
            $ErrorActionPreference = "SilentlyContinue"
            & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" images
            $ErrorActionPreference = "Stop"
            if ($LastExitCode -ne 0) {
                Throw "ERROR: The daemon under test does not appear to be running."
            }
            Write-Host
        }
    }

    # Run the WCOW integration tests unless SKIP_INTEGRATION_TESTS is defined
    if (($null -eq $env:LCOW_MODE) -and ($null -eq $env:LCOW_BASIC_MODE)) {
        if ($null -eq $env:SKIP_INTEGRATION_TESTS) {
            Write-Host -ForegroundColor Cyan "INFO: Running integration tests at $(Get-Date)..."
            $ErrorActionPreference = "SilentlyContinue"
    
            # Location of the daemon under test.
            $env:OrigDOCKER_HOST="$env:DOCKER_HOST"
    
            #https://blogs.technet.microsoft.com/heyscriptingguy/2011/09/20/solve-problems-with-external-command-lines-in-powershell/ is useful to see tokenising
            $jsonFilePath = "..\\bundles\\go-test-report-intcli-tests.json"
            $xmlFilePath = "..\\bundles\\junit-report-intcli-tests.xml"
            $c = "gotestsum --format=standard-verbose --jsonfile=$jsonFilePath --junitfile=$xmlFilePath -- "
            if ($null -ne $env:INTEGRATION_TEST_NAME) { # Makes is quicker for debugging to be able to run only a subset of the integration tests
                $c += "`"-test.run`" "
                $c += "`"$env:INTEGRATION_TEST_NAME`" "
                Write-Host -ForegroundColor Magenta "WARN: Only running integration tests matching $env:INTEGRATION_TEST_NAME"
            }
            $c += "`"-tags`" " + "`"autogen`" "
            $c += "`"-test.timeout`" " + "`"200m`" "
    
            if ($null -ne $env:INTEGRATION_IN_CONTAINER) {
                Write-Host -ForegroundColor Green "INFO: Integration tests being run inside a container"
                # Note we talk back through the containers gateway address
                # And the ridiculous lengths we have to go to get the default gateway address... (GetNetIPConfiguration doesn't work in nanoserver)
                # I just could not get the escaping to work in a single command, so output $c to a file and run that in the container instead...
                # Not the prettiest, but it works.
                $c | Out-File -Force "$env:TEMP\binary\runIntegrationCLI.ps1"
                $Duration= $(Measure-Command { & docker run `
                                                        --rm `
                                                        -e c=$c `
                                                        --workdir "c`:\gopath\src\github.com\docker\docker\integration-cli" `
                                                        -v "$env:TEMP\binary`:c:\target" `
                                                        docker `
                                                        "`$env`:PATH`='c`:\target;'+`$env:PATH`;  `$env:DOCKER_HOST`='tcp`://'+(ipconfig | select -last 1).Substring(39)+'`:2357'; c:\target\runIntegrationCLI.ps1" | Out-Host } )
            } else  {
                $env:DOCKER_HOST=$DASHH_CUT  
                $env:PATH="$env:TEMP\binary;$env:PATH;"  # Force to use the test binaries, not the host ones.
                Write-Host -ForegroundColor Green "INFO: DOCKER_HOST at $DASHH_CUT"

                $ErrorActionPreference = "SilentlyContinue"
                Write-Host -ForegroundColor Cyan "INFO: Integration API tests being run from the host:"
                $start=(Get-Date); Invoke-Expression ".\hack\make.ps1 -TestIntegration"; $Duration=New-Timespan -Start $start -End (Get-Date)
                $IntTestsRunResult = $LastExitCode
                $ErrorActionPreference = "Stop"
                if (-not($IntTestsRunResult -eq 0)) {
                    Throw "ERROR: Integration API tests failed at $(Get-Date). Duration`:$Duration"
                }

                $ErrorActionPreference = "SilentlyContinue"
                Write-Host -ForegroundColor Green "INFO: Integration CLI tests being run from the host:"
                Write-Host -ForegroundColor Green "INFO: $c"
                Set-Location "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker\integration-cli"
                # Explicit to not use measure-command otherwise don't get output as it goes
                $start=(Get-Date); Invoke-Expression $c; $Duration=New-Timespan -Start $start -End (Get-Date)
            }
            $ErrorActionPreference = "Stop"
            if (-not($LastExitCode -eq 0)) {
                Throw "ERROR: Integration CLI tests failed at $(Get-Date). Duration`:$Duration"
            }
            Write-Host  -ForegroundColor Green "INFO: Integration tests ended at $(Get-Date). Duration`:$Duration"
        } else {
            Write-Host -ForegroundColor Magenta "WARN: Skipping integration tests"
        }
    } else {
        # The LCOW version of the tests here
        if ($null -eq $env:SKIP_INTEGRATION_TESTS) {
            Write-Host -ForegroundColor Cyan "INFO: Running LCOW tests at $(Get-Date)..."

            $ErrorActionPreference = "SilentlyContinue"
    
            # Location of the daemon under test.
            $env:OrigDOCKER_HOST="$env:DOCKER_HOST"

            # Make sure we are pointing at the DUT
            $env:DOCKER_HOST=$DASHH_CUT  
            Write-Host -ForegroundColor Green "INFO: DOCKER_HOST at $DASHH_CUT"

            # Force to use the test binaries, not the host ones.
            $env:PATH="$env:TEMP\binary;$env:PATH;"  

            if ($null -ne $env:LCOW_BASIC_MODE) {
                $wc = New-Object net.webclient
                try {
                    Write-Host -ForegroundColor green "INFO: Downloading latest execution script..."
                    $wc.Downloadfile("https://raw.githubusercontent.com/kevpar/docker-w2wCIScripts/master/runCI/lcowbasicvalidation.ps1", "$env:TEMP\binary\lcowbasicvalidation.ps1")
                } 
                catch [System.Net.WebException]
                {
                    Throw ("Failed to download: $_")
                }

                # Explicit to not use measure-command otherwise don't get output as it goes
                $ErrorActionPreference = "Stop"
                $start=(Get-Date); Invoke-Expression "powershell $env:TEMP\binary\lcowbasicvalidation.ps1"; $lec=$lastExitCode; $Duration=New-Timespan -Start $start -End (Get-Date)
                $Duration=New-Timespan -Start $start -End (Get-Date)
                Write-Host  -ForegroundColor Green "INFO: LCOW tests ended at $(Get-Date). Duration`:$Duration"
                if ($lec -ne 0) {
                    Throw "LCOW validation tests failed"
                }
            } else {
                #https://blogs.technet.microsoft.com/heyscriptingguy/2011/09/20/solve-problems-with-external-command-lines-in-powershell/ is useful to see tokenising
                $c = "go test "
                $c += "`"-test.v`" "
                if ($null -ne $env:INTEGRATION_TEST_NAME) { # Makes is quicker for debugging to be able to run only a subset of the integration tests
                    $c += "`"-test.run`" "
                    $c += "`"$env:INTEGRATION_TEST_NAME`" "
                    Write-Host -ForegroundColor Magenta "WARN: Only running LCOW integration tests matching $env:INTEGRATION_TEST_NAME"
                }
                $c += "`"-tags`" " + "`"autogen`" "
                $c += "`"-test.timeout`" " + "`"200m`" "

                Write-Host -ForegroundColor Green "INFO: LCOW Integration tests being run from the host:"
                Set-Location "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker\integration-cli"
                Write-Host -ForegroundColor Green "INFO: $c"
                Write-Host -ForegroundColor Green "INFO: DOCKER_HOST at $DASHH_CUT"
                # Explicit to not use measure-command otherwise don't get output as it goes
                $start=(Get-Date); Invoke-Expression $c; $Duration=New-Timespan -Start $start -End (Get-Date)

            }
            $ErrorActionPreference = "Stop"
            if (-not($LastExitCode -eq 0)) {
                Throw "ERROR: Integration tests failed at $(Get-Date). Duration`:$Duration"
            }
            Write-Host  -ForegroundColor Green "INFO: Integration tests ended at $(Get-Date). Duration`:$Duration"
        } else {
            Write-Host -ForegroundColor Magenta "WARN: Skipping LCOW tests"
        }
    }

    # Docker info now to get counts (after or if jjh/containercounts is merged)
    if ($daemonStarted -eq 1) {
        Write-Host -ForegroundColor Green "INFO: Docker info of the daemon under test at end of run"
        Write-Host 
        $ErrorActionPreference = "SilentlyContinue"
        & "$env:TEMP\binary\docker-$COMMITHASH" "-H=$($DASHH_CUT)" info
        $ErrorActionPreference = "Stop"
        if ($LastExitCode -ne 0) {
            Throw "ERROR: The daemon under test does not appear to be running."
        }
        Write-Host
    }

    # Stop the daemon under test
    if (Test-Path "$env:TEMP\docker.pid") {
        $p=Get-Content "$env:TEMP\docker.pid" -raw
        if (($null -ne $p) -and ($daemonStarted -eq 1)) {
            Write-Host -ForegroundColor green "INFO: Stopping daemon under test"
            taskkill -f -t -pid $p
            #sleep 5
        }
        Remove-Item "$env:TEMP\docker.pid" -force -ErrorAction SilentlyContinue
    }

    # Stop the tail process (if started)
    if ($null -ne $tail) {
        Write-Host -ForegroundColor green "INFO: Stop tailing logs of the daemon under tests"
        Stop-Process -InputObject $tail -Force
    }

    Write-Host -ForegroundColor Green "INFO: executeCI.ps1 Completed successfully at $(Get-Date)."
}
Catch [Exception] {
    $FinallyColour="Red"
    Write-Host -ForegroundColor Red ("`r`n`r`nERROR: Failed '$_' at $(Get-Date)")
    Write-Host -ForegroundColor Red ($_.InvocationInfo.PositionMessage)
    Write-Host "`n`n"

    # Exit to ensure Jenkins captures it. Don't do this in the ISE or interactive Powershell - they will catch the Throw onwards.
    if ( ([bool]([Environment]::GetCommandLineArgs() -Like '*-NonInteractive*')) -and `
         ([bool]([Environment]::GetCommandLineArgs() -NotLike "*Powershell_ISE.exe*"))) {
        exit 1
    }
    Throw $_
}
Finally {
    $ErrorActionPreference="SilentlyContinue"
    $global:ProgressPreference=$origProgressPreference
    Write-Host  -ForegroundColor Green "INFO: Tidying up at end of run"

    # Restore the path
    if ($null -ne $origPath) { $env:PATH=$origPath }

    # Restore the DOCKER_HOST
    if ($null -ne $origDOCKER_HOST) { $env:DOCKER_HOST=$origDOCKER_HOST }

    # Restore the GOROOT and GOPATH variables
    if ($null -ne $origGOROOT) { $env:GOROOT=$origGOROOT }
    if ($null -ne $origGOPATH) { $env:GOPATH=$origGOPATH }

    # Dump the daemon log. This will include any possible panic stack in the .err.
    if (($daemonStarted -eq 1) -and  ($(Get-Item "$env:TEMP\dut.err").Length -gt 0)) {
        Write-Host -ForegroundColor Cyan "----------- DAEMON LOG ------------"
        Get-Content "$env:TEMP\dut.err" -ErrorAction SilentlyContinue | Write-Host -ForegroundColor Cyan
        Write-Host -ForegroundColor Cyan "----------- END DAEMON LOG --------"
    }

    # Save the daemon under test log
    if ($daemonStarted -eq 1) {
        Set-Location "$env:SOURCES_DRIVE`:\$env:SOURCES_SUBDIR\src\github.com\docker\docker"
        Write-Host -ForegroundColor Green "INFO: Saving daemon under test log ($env:TEMP\dut.out) to bundles\CIDUT.out"
        Copy-Item  "$env:TEMP\dut.out" "bundles\CIDUT.out" -Force -ErrorAction SilentlyContinue
        Write-Host -ForegroundColor Green "INFO: Saving daemon under test log ($env:TEMP\dut.err) to bundles\CIDUT.err"
        Copy-Item  "$env:TEMP\dut.err" "bundles\CIDUT.err" -Force -ErrorAction SilentlyContinue
    }

    Set-Location "$env:SOURCES_DRIVE\$env:SOURCES_SUBDIR" -ErrorAction SilentlyContinue
    Nuke-Everything

    # Restore the TEMP path
    if ($null -ne $TEMPORIG) { $env:TEMP="$TEMPORIG" }

<#
.NOTES
    Author:  @jhowardmsft

    Summary: Windows native build script. This is similar to functionality provided
             by hack\make.sh, but uses native Windows PowerShell semantics. It does
             not support the full set of options provided by the Linux counterpart.
             For example:

             - You can't cross-build Linux docker binaries on Windows
             - Hashes aren't generated on binaries
             - 'Releasing' isn't supported.
             - Integration tests. This is because they currently cannot run inside a container,
               and require significant external setup.

             It does however provided the minimum necessary to support parts of local Windows
             development and Windows to Windows CI.

             Usage Examples (run from repo root):
                "hack\make.ps1 -Client" to build docker.exe client 64-bit binary (remote repo)
                "hack\make.ps1 -TestUnit" to run unit tests
                "hack\make.ps1 -Daemon -TestUnit" to build the daemon and run unit tests
                "hack\make.ps1 -All" to run everything this script knows about that can run in a container
                "hack\make.ps1" to build the daemon binary (same as -Daemon)
                "hack\make.ps1 -Binary" shortcut to -Client and -Daemon

.PARAMETER Client
     Builds the client binaries.

.PARAMETER Daemon
     Builds the daemon binary.

.PARAMETER Binary
     Builds the client and daemon binaries. A convenient shortcut to `make.ps1 -Client -Daemon`.

.PARAMETER Race
     Use -race in go build and go test.

.PARAMETER Noisy
     Use -v in go build.

.PARAMETER ForceBuildAll
     Use -a in go build.

.PARAMETER NoOpt
     Use -gcflags -N -l in go build to disable optimisation (can aide debugging).

.PARAMETER CommitSuffix
     Adds a custom string to be appended to the commit ID (spaces are stripped).

.PARAMETER DCO
     Runs the DCO (Developer Certificate Of Origin) test (must be run outside a container).

.PARAMETER PkgImports
     Runs the pkg\ directory imports test (must be run outside a container).

.PARAMETER GoFormat
     Runs the Go formatting test (must be run outside a container).

.PARAMETER TestUnit
     Runs unit tests.

.PARAMETER TestIntegration
     Runs integration tests.

.PARAMETER All
     Runs everything this script knows about that can run in a container.


TODO
- Unify the head commit
- Add golint and other checks (swagger maybe?)

#>


param(
    [Parameter(Mandatory=$False)][switch]$Client,
    [Parameter(Mandatory=$False)][switch]$Daemon,
    [Parameter(Mandatory=$False)][switch]$Binary,
    [Parameter(Mandatory=$False)][switch]$Race,
    [Parameter(Mandatory=$False)][switch]$Noisy,
    [Parameter(Mandatory=$False)][switch]$ForceBuildAll,
    [Parameter(Mandatory=$False)][switch]$NoOpt,
    [Parameter(Mandatory=$False)][string]$CommitSuffix="",
    [Parameter(Mandatory=$False)][switch]$DCO,
    [Parameter(Mandatory=$False)][switch]$PkgImports,
    [Parameter(Mandatory=$False)][switch]$GoFormat,
    [Parameter(Mandatory=$False)][switch]$TestUnit,
    [Parameter(Mandatory=$False)][switch]$TestIntegration,
    [Parameter(Mandatory=$False)][switch]$All
)

$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"
$pushed=$False  # To restore the directory if we have temporarily pushed to one.
Set-Variable GOTESTSUM_LOCATION -option Constant -value "$env:GOPATH/bin/"

# Utility function to get the commit ID of the repository
Function Get-GitCommit() {
    if (-not (Test-Path ".\.git")) {
        # If we don't have a .git directory, but we do have the environment
        # variable DOCKER_GITCOMMIT set, that can override it.
        if ($env:DOCKER_GITCOMMIT.Length -eq 0) {
            Throw ".git directory missing and DOCKER_GITCOMMIT environment variable not specified."
        }
        Write-Host "INFO: Git commit ($env:DOCKER_GITCOMMIT) assumed from DOCKER_GITCOMMIT environment variable"
        return $env:DOCKER_GITCOMMIT
    }
    $gitCommit=$(git rev-parse --short HEAD)
    if ($(git status --porcelain --untracked-files=no).Length -ne 0) {
        $gitCommit="$gitCommit-unsupported"
        Write-Host ""
        Write-Warning "This version is unsupported because there are uncommitted file(s)."
        Write-Warning "Either commit these changes, or add them to .gitignore."
        git status --porcelain --untracked-files=no | Write-Warning
        Write-Host ""
    }
    return $gitCommit
}

# Utility function to determine if we are running in a container or not.
# In Windows, we get this through an environment variable set in `Dockerfile.Windows`
Function Check-InContainer() {
    if ($env:FROM_DOCKERFILE.Length -eq 0) {
        Write-Host ""
        Write-Warning "Not running in a container. The result might be an incorrect build."
        Write-Host ""
        return $False
    }
    return $True
}

# Utility function to warn if the version of go is correct. Used for local builds
# outside of a container where it may be out of date with master.
Function Verify-GoVersion() {
    Try {
        $goVersionDockerfile=(Select-String -Path ".\Dockerfile" -Pattern "^ARG[\s]+GO_VERSION=(.*)$").Matches.groups[1].Value -replace '\.0$',''
        $goVersionInstalled=(go version).ToString().Split(" ")[2].SubString(2)
    }
    Catch [Exception] {
        Throw "Failed to validate go version correctness: $_"
    }
    if (-not($goVersionInstalled -eq $goVersionDockerfile)) {
        Write-Host ""
        Write-Warning "Building with golang version $goVersionInstalled. You should update to $goVersionDockerfile"
        Write-Host ""
    }
}

# Utility function to get the commit for HEAD
Function Get-HeadCommit() {
    $head = Invoke-Expression "git rev-parse --verify HEAD"
    if ($LASTEXITCODE -ne 0) { Throw "Failed getting HEAD commit" }

    return $head
}

# Utility function to get the commit for upstream
Function Get-UpstreamCommit() {
    Invoke-Expression "git fetch -q https://github.com/docker/docker.git refs/heads/master"
    if ($LASTEXITCODE -ne 0) { Throw "Failed fetching" }

    $upstream = Invoke-Expression "git rev-parse --verify FETCH_HEAD"
    if ($LASTEXITCODE -ne 0) { Throw "Failed getting upstream commit" }

    return $upstream
}

# Build a binary (client or daemon)
Function Execute-Build($type, $additionalBuildTags, $directory) {
    # Generate the build flags
    $buildTags = "autogen"
    if ($Noisy)                     { $verboseParm=" -v" }
    if ($Race)                      { Write-Warning "Using race detector"; $raceParm=" -race"}
    if ($ForceBuildAll)             { $allParm=" -a" }
    if ($NoOpt)                     { $optParm=" -gcflags "+""""+"-N -l"+"""" }
    if ($additionalBuildTags -ne "") { $buildTags += $(" " + $additionalBuildTags) }

    # Do the go build in the appropriate directory
    # Note -linkmode=internal is required to be able to debug on Windows.
    # https://github.com/golang/go/issues/14319#issuecomment-189576638
    Write-Host "INFO: Building $type..."
    Push-Location $root\cmd\$directory; $global:pushed=$True
    $buildCommand = "go build" + `
                    $raceParm + `
                    $verboseParm + `
                    $allParm + `
                    $optParm + `
                    " -tags """ + $buildTags + """" + `
                    " -ldflags """ + "-linkmode=internal" + """" + `
                    " -o $root\bundles\"+$directory+".exe"
    Invoke-Expression $buildCommand
    if ($LASTEXITCODE -ne 0) { Throw "Failed to compile $type" }
    Pop-Location; $global:pushed=$False
}


# Validates the DCO marker is present on each commit
Function Validate-DCO($headCommit, $upstreamCommit) {
    Write-Host "INFO: Validating Developer Certificate of Origin..."
    # Username may only contain alphanumeric characters or dashes and cannot begin with a dash
    $usernameRegex='[a-zA-Z0-9][a-zA-Z0-9-]+'

    $dcoPrefix="Signed-off-by:"
    $dcoRegex="^(Docker-DCO-1.1-)?$dcoPrefix ([^<]+) <([^<>@]+@[^<>]+)>( \(github: ($usernameRegex)\))?$"

    $counts = Invoke-Expression "git diff --numstat $upstreamCommit...$headCommit"
    if ($LASTEXITCODE -ne 0) { Throw "Failed git diff --numstat" }

    # Counts of adds and deletes after removing multiple white spaces. AWK anyone? :(
    $adds=0; $dels=0; $($counts -replace '\s+', ' ') | %{ 
        $a=$_.Split(" "); 
        if ($a[0] -ne "-") { $adds+=[int]$a[0] }
        if ($a[1] -ne "-") { $dels+=[int]$a[1] }
    }
    if (($adds -eq 0) -and ($dels -eq 0)) { 
        Write-Warning "DCO validation - nothing to validate!"
        return
    }

    $commits = Invoke-Expression "git log  $upstreamCommit..$headCommit --format=format:%H%n"
    if ($LASTEXITCODE -ne 0) { Throw "Failed git log --format" }
    $commits = $($commits -split '\s+' -match '\S')
    $badCommits=@()
    $commits | ForEach-Object{
        # Skip commits with no content such as merge commits etc
        if ($(git log -1 --format=format: --name-status $_).Length -gt 0) {
            # Ignore exit code on next call - always process regardless
            $commitMessage = Invoke-Expression "git log -1 --format=format:%B --name-status $_"
            if (($commitMessage -match $dcoRegex).Length -eq 0) { $badCommits+=$_ }
        }
    }
    if ($badCommits.Length -eq 0) {
        Write-Host "Congratulations!  All commits are properly signed with the DCO!"
    } else {
        $e = "`nThese commits do not have a proper '$dcoPrefix' marker:`n"
        $badCommits | %{ $e+=" - $_`n"}
        $e += "`nPlease amend each commit to include a properly formatted DCO marker.`n`n"
        $e += "Visit the following URL for information about the Docker DCO:`n"
        $e += "https://github.com/docker/docker/blob/master/CONTRIBUTING.md#sign-your-work`n"
        Throw $e
    }
}

# Validates that .\pkg\... is safely isolated from internal code
Function Validate-PkgImports($headCommit, $upstreamCommit) {
    Write-Host "INFO: Validating pkg import isolation..."

    # Get a list of go source-code files which have changed under pkg\. Ignore exit code on next call - always process regardless
    $files=@(); $files = Invoke-Expression "git diff $upstreamCommit...$headCommit --diff-filter=ACMR --name-only -- `'pkg\*.go`'"
    $badFiles=@(); $files | ForEach-Object{
        $file=$_
        # For the current changed file, get its list of dependencies, sorted and uniqued.
        $imports = Invoke-Expression "go list -e -f `'{{ .Deps }}`' $file"
        if ($LASTEXITCODE -ne 0) { Throw "Failed go list for dependencies on $file" }
        $imports = $imports -Replace "\[" -Replace "\]", "" -Split(" ") | Sort-Object | Get-Unique
        # Filter out what we are looking for
        $imports = @() + $imports -NotMatch "^github.com/docker/docker/pkg/" `
                                  -NotMatch "^github.com/docker/docker/vendor" `
                                  -Match "^github.com/docker/docker" `
                                  -Replace "`n", ""
        $imports | ForEach-Object{ $badFiles+="$file imports $_`n" }
    }
    if ($badFiles.Length -eq 0) {
        Write-Host 'Congratulations!  ".\pkg\*.go" is safely isolated from internal code.'
    } else {
        $e = "`nThese files import internal code: (either directly or indirectly)`n"
        $badFiles | ForEach-Object{ $e+=" - $_"}
        Throw $e
    }
}

# Validates that changed files are correctly go-formatted
Function Validate-GoFormat($headCommit, $upstreamCommit) {
    Write-Host "INFO: Validating go formatting on changed files..."

    # Verify gofmt is installed
    if ($(Get-Command gofmt -ErrorAction SilentlyContinue) -eq $nil) { Throw "gofmt does not appear to be installed" }

    # Get a list of all go source-code files which have changed.  Ignore exit code on next call - always process regardless
    $files=@(); $files = Invoke-Expression "git diff $upstreamCommit...$headCommit --diff-filter=ACMR --name-only -- `'*.go`'"
    $files = $files | Select-String -NotMatch "^vendor/"
    $badFiles=@(); $files | %{
        # Deliberately ignore error on next line - treat as failed
        $content=Invoke-Expression "git show $headCommit`:$_"

        # Next set of hoops are to ensure we have LF not CRLF semantics as otherwise gofmt on Windows will not succeed.
        # Also note that gofmt on Windows does not appear to support stdin piping correctly. Hence go through a temporary file.
        $content=$content -join "`n"
        $content+="`n"
        $outputFile=[System.IO.Path]::GetTempFileName()
        if (Test-Path $outputFile) { Remove-Item $outputFile }
        [System.IO.File]::WriteAllText($outputFile, $content, (New-Object System.Text.UTF8Encoding($False)))
        $currentFile = $_ -Replace("/","\")
        Write-Host Checking $currentFile
        Invoke-Expression "gofmt -s -l $outputFile"
        if ($LASTEXITCODE -ne 0) { $badFiles+=$currentFile }
        if (Test-Path $outputFile) { Remove-Item $outputFile }
    }
    if ($badFiles.Length -eq 0) {
        Write-Host 'Congratulations!  All Go source files are properly formatted.'
    } else {
        $e = "`nThese files are not properly gofmt`'d:`n"
        $badFiles | ForEach-Object{ $e+=" - $_`n"}
        $e+= "`nPlease reformat the above files using `"gofmt -s -w`" and commit the result."
        Throw $e
    }
}

# Run the unit tests
Function Run-UnitTests() {
    Write-Host "INFO: Running unit tests..."
    $testPath="./..."
    $goListCommand = "go list -e -f '{{if ne .Name """ + '\"github.com/docker/docker\"' + """}}{{.ImportPath}}{{end}}' $testPath"
    $pkgList = $(Invoke-Expression $goListCommand)
    if ($LASTEXITCODE -ne 0) { Throw "go list for unit tests failed" }
    $pkgList = $pkgList | Select-String -Pattern "github.com/docker/docker"
    $pkgList = $pkgList | Select-String -NotMatch "github.com/docker/docker/vendor"
    $pkgList = $pkgList | Select-String -NotMatch "github.com/docker/docker/man"
    $pkgList = $pkgList | Select-String -NotMatch "github.com/docker/docker/integration"
    $pkgList = $pkgList -replace "`r`n", " "

    $goTestArg = "--format=standard-verbose --jsonfile=bundles\go-test-report-unit-tests.json --junitfile=bundles\junit-report-unit-tests.xml -- " + $raceParm + " -cover -ldflags -w -a """ + "-test.timeout=10m" + """ $pkgList"
    Write-Host "INFO: Invoking unit tests run with $GOTESTSUM_LOCATION\gotestsum.exe $goTestArg"
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo
    $pinfo.FileName = "$GOTESTSUM_LOCATION\gotestsum.exe"
    $pinfo.WorkingDirectory = "$($PWD.Path)"
    $pinfo.UseShellExecute = $false
    $pinfo.Arguments = $goTestArg
    $p = New-Object System.Diagnostics.Process
    $p.StartInfo = $pinfo
    $p.Start() | Out-Null
    $p.WaitForExit()
    if ($p.ExitCode -ne 0) { Throw "Unit tests failed" }
}

# Run the integration tests
Function Run-IntegrationTests() {
    $escRoot = [Regex]::Escape($root)
    $env:DOCKER_INTEGRATION_DAEMON_DEST = $bundlesDir + "\tmp"
    $dirs = go list -test -f '{{- if ne .ForTest `"`" -}}{{- .Dir -}}{{- end -}}' .\integration\...
    ForEach($dir in $dirs) {
        # Normalize directory name for using in the test results files.
        $normDir = $dir.Trim()
        $normDir = $normDir -replace $escRoot, ""
        $normDir = $normDir -replace "\\", "-"
        $normDir = $normDir -replace "\/", "-"
        $normDir = $normDir -replace "\.", "-"
        if ($normDir.StartsWith("-"))
        {
            $normDir = $normDir.TrimStart("-")
        }
        if ($normDir.EndsWith("-"))
        {
            $normDir = $normDir.TrimEnd("-")
        }
        $jsonFilePath = $bundlesDir + "\go-test-report-int-tests-$normDir" + ".json"
        $xmlFilePath = $bundlesDir + "\junit-report-int-tests-$normDir" + ".xml"
        Set-Location $dir
        Write-Host "Running $($PWD.Path)"
        $pinfo = New-Object System.Diagnostics.ProcessStartInfo
        $pinfo.FileName = "gotestsum.exe"
        $pinfo.WorkingDirectory = "$($PWD.Path)"
        $pinfo.UseShellExecute = $false
        $pinfo.Arguments = "--format=standard-verbose --jsonfile=$jsonFilePath --junitfile=$xmlFilePath -- -test.timeout=60m $env:INTEGRATION_TESTFLAGS"
        $p = New-Object System.Diagnostics.Process
        $p.StartInfo = $pinfo
        $p.Start() | Out-Null
        $p.WaitForExit()
        if ($p.ExitCode -ne 0) { Throw "Integration tests failed" }
    }
}

# Start of main code.
Try {
    Write-Host -ForegroundColor Cyan "INFO: make.ps1 starting at $(Get-Date)"

    # Get to the root of the repo
    $root = $(Split-Path $MyInvocation.MyCommand.Definition -Parent | Split-Path -Parent)
    Push-Location $root

    # Ensure the bundles directory exists
    $bundlesDir = $root + "\bundles"
    Set-Variable bundlesDir -option ReadOnly
    New-Item -Force $bundlesDir -ItemType Directory | Out-Null

    # Handle the "-All" shortcut to turn on all things we can handle.
    # Note we expressly only include the items which can run in a container - the validations tests cannot
    # as they require the .git directory which is excluded from the image by .dockerignore
    if ($All) { $Client=$True; $Daemon=$True; $TestUnit=$True; }

    # Handle the "-Binary" shortcut to build both client and daemon.
    if ($Binary) { $Client = $True; $Daemon = $True }

    # Default to building the daemon if not asked for anything explicitly.
    if (-not($Client) -and -not($Daemon) -and -not($DCO) -and -not($PkgImports) -and -not($GoFormat) -and -not($TestUnit) -and -not($TestIntegration)) { $Daemon=$True }

    # Verify git is installed
    if ($(Get-Command git -ErrorAction SilentlyContinue) -eq $nil) { Throw "Git does not appear to be installed" }

    # Verify go is installed
    if ($(Get-Command go -ErrorAction SilentlyContinue) -eq $nil) { Throw "GoLang does not appear to be installed" }

    # Get the git commit. This will also verify if we are in a repo or not. Then add a custom string if supplied.
    $gitCommit=Get-GitCommit
    if ($CommitSuffix -ne "") { $gitCommit += "-"+$CommitSuffix -Replace ' ', '' }

    # Get the version of docker (eg 17.04.0-dev)
    $dockerVersion="0.0.0-dev"
    # Overwrite dockerVersion if VERSION Environment variable is available
    if (Test-Path Env:\VERSION) { $dockerVersion=$env:VERSION }

    # Give a warning if we are not running in a container and are building binaries or running unit tests.
    # Not relevant for validation tests as these are fine to run outside of a container.
    if ($Client -or $Daemon -or $TestUnit) { $inContainer=Check-InContainer }

    # If we are not in a container, validate the version of GO that is installed.
    if (-not $inContainer) { Verify-GoVersion }

    # Verify GOPATH is set
    if ($env:GOPATH.Length -eq 0) { Throw "Missing GOPATH environment variable. See https://golang.org/doc/code.html#GOPATH" }

    # Run autogen if building binaries or running unit tests.
    if ($Client -or $Daemon -or $TestUnit) {
        Write-Host "INFO: Invoking autogen..."
        Try { .\hack\make\.go-autogen.ps1 -CommitString $gitCommit -DockerVersion $dockerVersion -Platform "$env:PLATFORM" -Product "$env:PRODUCT" }
        Catch [Exception] { Throw $_ }
    }

    # DCO, Package import and Go formatting tests.
    if ($DCO -or $PkgImports -or $GoFormat) {
        # We need the head and upstream commits for these
        $headCommit=Get-HeadCommit
        $upstreamCommit=Get-UpstreamCommit

        # Run DCO validation
        if ($DCO) { Validate-DCO $headCommit $upstreamCommit }

        # Run `gofmt` validation
        if ($GoFormat) { Validate-GoFormat $headCommit $upstreamCommit }

        # Run pkg isolation validation
        if ($PkgImports) { Validate-PkgImports $headCommit $upstreamCommit }
    }

    # Build the binaries
    if ($Client -or $Daemon) {

        # Perform the actual build
        if ($Daemon) { Execute-Build "daemon" "daemon" "dockerd" }
        if ($Client) {
            # Get the Docker channel and version from the environment, or use the defaults.
            if (-not ($channel = $env:DOCKERCLI_CHANNEL)) { $channel = "stable" }
            if (-not ($version = $env:DOCKERCLI_VERSION)) { $version = "17.06.2-ce" }

            # Download the zip file and extract the client executable.
            Write-Host "INFO: Downloading docker/cli version $version from $channel..."
            $url = "https://download.docker.com/win/static/$channel/x86_64/docker-$version.zip"
            Invoke-WebRequest $url -OutFile "docker.zip"
            Try {
                Add-Type -AssemblyName System.IO.Compression.FileSystem
                $zip = [System.IO.Compression.ZipFile]::OpenRead("$PWD\docker.zip")
                Try {
                    if (-not ($entry = $zip.Entries | Where-Object { $_.Name -eq "docker.exe" })) {
                        Throw "Cannot find docker.exe in $url"
                    }
                    [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, "$PWD\bundles\docker.exe", $true)
                }
                Finally {
                    $zip.Dispose()
                }
            }
            Finally {
                Remove-Item -Force "docker.zip"
            }
        }
    }

    # Run unit tests
    if ($TestUnit) { Run-UnitTests }

    # Run integration tests
    if ($TestIntegration) { Run-IntegrationTests }

    # Gratuitous ASCII art.
    if ($Daemon -or $Client) {
        Write-Host
        Write-Host -ForegroundColor Green " ________   ____  __."
        Write-Host -ForegroundColor Green " \_____  \ `|    `|/ _`|"
        Write-Host -ForegroundColor Green " /   `|   \`|      `<"
        Write-Host -ForegroundColor Green " /    `|    \    `|  \"
        Write-Host -ForegroundColor Green " \_______  /____`|__ \"
        Write-Host -ForegroundColor Green "         \/        \/"
        Write-Host
    }
}
Catch [Exception] {
    Write-Host -ForegroundColor Red ("`nERROR: make.ps1 failed:`n$_")
    Write-Host -ForegroundColor Red ($_.InvocationInfo.PositionMessage)

    # More gratuitous ASCII art.
    Write-Host
    Write-Host -ForegroundColor Red  "___________      .__.__             .___"
    Write-Host -ForegroundColor Red  "\_   _____/____  `|__`|  `|   ____   __`| _/"
    Write-Host -ForegroundColor Red  " `|    __) \__  \ `|  `|  `| _/ __ \ / __ `| "
    Write-Host -ForegroundColor Red  " `|     \   / __ \`|  `|  `|_\  ___// /_/ `| "
    Write-Host -ForegroundColor Red  " \___  /  (____  /__`|____/\___  `>____ `| "
    Write-Host -ForegroundColor Red  "     \/        \/             \/     \/ "
    Write-Host

    exit 1
}
Finally {
    Pop-Location # As we pushed to the root of the repo as the very first thing
<#
.NOTES
    Author:  @jhowardmsft

    Summary: Windows native version of .go-autogen which generates the
             .go source code for building, and performs resource compilation.

.PARAMETER CommitString
     The commit string. This is calculated externally to this script.

.PARAMETER DockerVersion
     The version such as 17.04.0-dev. This is calculated externally to this script.
#>

param(
    [Parameter(Mandatory=$true)][string]$CommitString,
    [Parameter(Mandatory=$true)][string]$DockerVersion,
    [Parameter(Mandatory=$false)][string]$Platform,
    [Parameter(Mandatory=$false)][string]$Product,
    [Parameter(Mandatory=$false)][string]$DefaultProductLicense
)

$ErrorActionPreference = "Stop"

# Utility function to get the build date/time in UTC
Function Get-BuildDateTime() {
    return $(Get-Date).ToUniversalTime()
}

try {
    $buildDateTime=Get-BuildDateTime

    if (Test-Path ".\autogen") {
        Remove-Item ".\autogen" -Recurse -Force | Out-Null
    }

    $fileContents = '
// +build autogen

// Package dockerversion is auto-generated at build-time
package dockerversion

// Default build-time variable for library-import.
// This file is overridden on build with build-time information.
const (
	GitCommit             string = "'+$CommitString+'"
	Version               string = "'+$DockerVersion+'"
	BuildTime             string = "'+$buildDateTime+'"
	PlatformName          string = "'+$Platform+'"
	ProductName           string = "'+$Product+'"
	DefaultProductLicense string = "'+$DefaultProductLicense+'"
)

// AUTOGENERATED FILE; see hack\make\.go-autogen.ps1
'

    # Write the file without BOM
    $outputFile="$(Get-Location)\dockerversion\version_autogen.go"
    if (Test-Path $outputFile) { Remove-Item $outputFile }
    [System.IO.File]::WriteAllText($outputFile, $fileContents, (New-Object System.Text.UTF8Encoding($False)))

    New-Item -ItemType Directory -Path "autogen\winresources\tmp" | Out-Null
    New-Item -ItemType Directory -Path "autogen\winresources\dockerd" | Out-Null
    Copy-Item "hack\make\.resources-windows\resources.go" "autogen\winresources\dockerd"

    # Generate a version in the form major,minor,patch,build
    $versionQuad=$DockerVersion -replace "[^0-9.]*" -replace "\.", ","

    # Compile the messages
    windmc hack\make\.resources-windows\event_messages.mc -h autogen\winresources\tmp -r autogen\winresources\tmp
    if ($LASTEXITCODE -ne 0) { Throw "Failed to compile event message resources" }

    # If you really want to understand this madness below, search the Internet for powershell variables after verbatim arguments... Needed to get double-quotes passed through to the compiler options.
    # Generate the .syso files containing all the resources and manifest needed to compile the final docker binaries. Both 32 and 64-bit clients.
    $env:_ag_dockerVersion=$DockerVersion
    $env:_ag_gitCommit=$CommitString

    windres -i hack/make/.resources-windows/dockerd.rc -o autogen/winresources/dockerd/rsrc_amd64.syso -F pe-x86-64 --use-temp-file -I autogen/winresources/tmp -D DOCKER_VERSION_QUAD=$versionQuad --% -D DOCKER_VERSION=\"%_ag_dockerVersion%\" -D DOCKER_COMMIT=\"%_ag_gitCommit%\"
    if ($LASTEXITCODE -ne 0) { Throw "Failed to compile daemon resources" }
}
Catch [Exception] {
    # Throw the error onto the caller to display errors. We don't expect this script to be called directly 
    Throw ".go-autogen.ps1 failed with error $_"
}
Finally {
Function Expand-ZipFile {

    Param(
        [Parameter(Mandatory = $true)] [string] $zipfile,
        [Parameter(Mandatory = $true)] [string] $destination
    )
    # This function unzips a zip file
    # Code obtained from:
    # http://www.howtogeek.com/tips/how-to-extract-zip-files-using-powershell/

    Begin { Write-Host " - Unzipping '$zipfile' to '$destination'" }

    Process {
        # Create a new directory if it doesn't exist
        If (!(Test-Path -Path $destination))
        {
            New-Item -ItemType directory -Path $destination
        }

        # Define Objects
        $objShell = New-Object -Com Shell.Application

        # Open the zip file
        $objZip = $objShell.NameSpace($zipfile)

        # Unzip each item in the zip file
        ForEach ($item in $objZip.Items())
        {
            $objShell.Namespace($destination).CopyHere($item, 0x14)
        }
Function Start_Process_and_test_exitcode {

    # This function is a wrapper for Start-Process that checks the exitcode
    # It receives 3 parameters:
    #    $fun   - the process that shall be started
    #    $args  - the arguments of $fun
    #    $descr - the short description shown in the case of an error

    Param(
        [Parameter(Mandatory=$true)] [String] $fun,
        [Parameter(Mandatory=$true)] [String] $args,
        [Parameter(Mandatory=$true)] [String] $descr
    )

    Begin { Write-Host "Executing Command: $fun $args" }

    Process {
        $p = Start-Process "$fun" -ArgumentList "$args" -Wait -NoNewWindow -PassThru
        If ($p.ExitCode -ne 0) {
            Write-Error "$descr returned exitcode $p.ExitCode."
            exit $p.ExitCode
        }
    }

    End { Write-Host "Finished Executing Command: $fun $args" }
function Get-IsAdministrator
{
    $Identity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $Principal = New-Object System.Security.Principal.WindowsPrincipal($Identity)
    $Principal.IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
}


function Get-IsUacEnabled
{
# Powershell supports only TLS 1.0 by default. Add support up to TLS 1.2
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]'Tls,Tls11,Tls12'

Function DownloadFileWithProgress {

    # Code for this function borrowed from http://poshcode.org/2461
    # Thanks Crazy Dave

    # This function downloads the passed file and shows a progress bar
    # It receives two parameters:
    #    $url - the file source
    #    $localfile - the file destination on the local machine

    param(
        [Parameter(Mandatory=$true)]
        [String] $url,
        [Parameter(Mandatory=$false)]
        [String] $localFile = (Join-Path $pwd.Path $url.SubString($url.LastIndexOf('/')))
    )


    begin {
        Write-Host -ForegroundColor DarkGreen "  download-module.DownloadFileWithProgress  $url"
        $client = New-Object System.Net.WebClient
        $Global:downloadComplete = $false
        $eventDataComplete = Register-ObjectEvent $client DownloadFileCompleted `
            -SourceIdentifier WebClient.DownloadFileComplete `
            -Action {$Global:downloadComplete = $true}
        $eventDataProgress = Register-ObjectEvent $client DownloadProgressChanged `
            -SourceIdentifier WebClient.DownloadProgressChanged `
            -Action { $Global:DPCEventArgs = $EventArgs }
    }
    process {
        Write-Progress -Activity 'Downloading file' -Status $url
        $client.DownloadFileAsync($url, $localFile)

        while (!($Global:downloadComplete)) {
            $pc = $Global:DPCEventArgs.ProgressPercentage
            if ($pc -ne $null) {
                Write-Progress -Activity 'Downloading file' -Status $url -PercentComplete $pc
            }
        }
        Write-Progress -Activity 'Downloading file' -Status $url -Complete
    }

    end {
        Unregister-Event -SourceIdentifier WebClient.DownloadProgressChanged
        Unregister-Event -SourceIdentifier WebClient.DownloadFileComplete
        $client.Dispose()
        $Global:downloadComplete = $null
        $Global:DPCEventArgs = $null
        Remove-Variable client
        Remove-Variable eventDataComplete
        Remove-Variable eventDataProgress
        [GC]::Collect()
        # 2016-07-06  mkr  Errorchecking added. nice-to-have: integration into the above code.
        If (!((Test-Path "$localfile") -and ((Get-Item "$localfile").length -gt 0kb))) {
            Write-Error "Exiting because download missing or zero-length:    $localfile"
            exit 2
        }
Function Get-Settings {

    [CmdletBinding()]
    Param()

    Begin
        {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function started"}

    Process
    {
        Write-Verbose "$($MyInvocation.MyCommand.Name):: Loading Settings"

        $ini = @{}

        If ( -Not (Test-Path env:SrcDir)) {
            $env:SrcDir = $(git rev-parse --show-toplevel).Replace("/", "\")
        }
        If ( -Not (Test-Path env:PyVerMajor)) { $env:PyVerMajor = "3" }
        If ( -Not (Test-Path env:PyVerMinor)) { $env:PyVerMinor = "7" }
        If ( -Not (Test-Path env:PyDir)) { $env:PyDir = "C:\Python37" }

        # Location where the files are kept
        $Settings = @{
            "SrcDir"       = "$env:SrcDir"
            "SaltRepo"     = "https://repo.saltstack.com/windows/dependencies"
            "SaltDir"      = "C:\salt"
            "PyVerMajor"   = "$env:PyVerMajor"
            "PyVerMinor"   = "$env:PyVerMinor"
            "Python3Dir"   = "$env:PyDir"
            "Scripts3Dir"  = "$env:PyDir\Scripts"
            "SitePkgs3Dir" = "$env:PyDir\Lib\site-packages"
            "DownloadDir"  = "$env:Temp\DevSalt"
            }

        $ini.Add("Settings", $Settings)
        Write-Verbose "DownloadDir === $($ini['Settings']['DownloadDir']) ==="

        # Prerequisite software
        $Prerequisites = @{
            "NSIS"             = "nsis-3.03-setup.exe"
            "NSISPluginEnVar"  = "nsis-plugin-envar.zip"
            "NSISPluginUnzipA" = "nsis-plugin-nsisunz.zip"
            "NSISPluginUnzipU" = "nsis-plugin-nsisunzu.zip"
            "VCppBuildTools"   = "visualcppbuildtools_full.exe"
        }
        $ini.Add("Prerequisites", $Prerequisites)

        # Location of programs on 64 bit Windows
        $64bitPaths = @{
            "NSISDir"           = "C:\Program Files (x86)\NSIS"
            "NSISPluginsDirA"   = "C:\Program Files (x86)\NSIS\Plugins\x86-ansi"
            "NSISPluginsDirU"   = "C:\Program Files (x86)\NSIS\Plugins\x86-unicode"
            "VCforPythonDir"    = "C:\Program Files (x86)\Common Files\Microsoft\Visual C++ for Python\9.0"
            "VCppBuildToolsDir" = "C:\Program Files (x86)\Microsoft Visual C++ Build Tools"
        }
        $ini.Add("64bitPaths", $64bitPaths)

        # Location of programs on 32 bit Windows
        $32bitPaths = @{
            "NSISDir"           = "C:\Program Files\NSIS"
            "NSISPluginsDirA"   = "C:\Program Files\NSIS\Plugins\x86-ansi"
            "NSISPluginsDirU"   = "C:\Program Files\NSIS\Plugins\x86-unicode"
            "VCforPythonDir"    = "C:\Program Files\Common Files\Microsoft\Visual C++ for Python\9.0"
            "VCppBuildToolsDir" = "C:\Program Files\Microsoft Visual C++ Build Tools"
        }
        $ini.Add("32bitPaths", $32bitPaths)

        # Filenames for 64 bit Windows
        $64bitPrograms = @{
            "Python3"     = "python-3.7.4-amd64.exe"
            "VCRedist"    = "vcredist_x64_2013.exe"
            "VCRedistReg" = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{53CF6934-A98D-3D84-9146-FC4EDF3D5641}"
        }
        $ini.Add("64bitPrograms", $64bitPrograms)

        # Filenames for 32 bit Windows
        $32bitPrograms = @{
            "Python3"     = "python-3.7.4.exe"
            "VCRedist"    = "vcredist_x86_2013.exe"
            "VCRedistReg" = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{8122DAB1-ED4D-3676-BB0A-CA368196543E}"
        }
        $ini.Add("32bitPrograms", $32bitPrograms)

        # DLL's for 64 bit Windows
        $64bitDLLs = @{
            "Libeay"     = "libeay32.dll"
            "SSLeay"     = "ssleay32.dll"
            "OpenSSLLic" = "OpenSSL_License.txt"
            "Libsodium"  = "libsodium.dll"
        }
        $ini.Add("64bitDLLs", $64bitDLLs)

        # DLL's for 32 bit Windows
        $32bitDLLs = @{
            "Libeay"     = "libeay32.dll"
            "SSLeay"     = "ssleay32.dll"
            "OpenSSLLic" = "OpenSSL_License.txt"
            "Libsodium"  = "libsodium.dll"
        }
        $ini.Add("32bitDLLs", $32bitDLLs)

        Write-Verbose "$($MyInvocation.MyCommand.Name):: Finished Loading Settings"
        Return $ini
    }
    End
#==============================================================================
# You may need to change the execution policy in order to run this script
# Run the following in powershell:
#
# Set-ExecutionPolicy RemoteSigned
#
#==============================================================================
#
#          FILE: dev_env.ps1
#
#   DESCRIPTION: Development Environment Installation for Windows
#
#          BUGS: https://github.com/saltstack/salt-windows-bootstrap/issues
#
#     COPYRIGHT: (c) 2012-2017 by the SaltStack Team, see AUTHORS.rst for more
#                details.
#
#       LICENSE: Apache 2.0
#  ORGANIZATION: SaltStack (saltstack.org)
#       CREATED: 03/10/2017
#==============================================================================

# Load parameters
param(
    [switch]$Silent,
    [switch]$NoPipDependencies
)

#==============================================================================
# Get the Directory of actual script
#==============================================================================
$script_path = dir "$($myInvocation.MyCommand.Definition)"
$script_path = $script_path.DirectoryName

#==============================================================================
# Get the name of actual script
#==============================================================================
$script_name = $MyInvocation.MyCommand.Name

Write-Output "================================================================="
Write-Output ""
Write-Output "               Development Environment Installation"
Write-Output ""
Write-Output "               - Installs All Salt Dependencies"
Write-Output "               - Detects 32/64 bit Architectures"
Write-Output ""
Write-Output "               To run silently add -Silent"
Write-Output "               eg: ${script_name} -Silent"
Write-Output ""
Write-Output "               To run skip installing pip dependencies add -NoPipDependencies"
Write-Output "               eg: ${script_name} -NoPipDependencies"
Write-Output ""
Write-Output "================================================================="
Write-Output ""

#==============================================================================
# Import Modules
#==============================================================================
Import-Module $script_path\Modules\download-module.psm1
Import-Module $script_path\Modules\get-settings.psm1
Import-Module $script_path\Modules\uac-module.psm1
Import-Module $script_path\Modules\zip-module.psm1
Import-Module $script_path\Modules\start-process-and-test-exitcode.psm1
#==============================================================================
# Check for Elevated Privileges
#==============================================================================
If (!(Get-IsAdministrator)) {
    If (Get-IsUacEnabled) {
        # We are not running "as Administrator" - so relaunch as administrator
        # Create a new process object that starts PowerShell
        $newProcess = new-object System.Diagnostics.ProcessStartInfo "PowerShell";

        # Specify the current script path and name as a parameter
        $newProcess.Arguments = $myInvocation.MyCommand.Definition

        # Specify the current working directory
        $newProcess.WorkingDirectory = "$script_path"

        # Indicate that the process should be elevated
        $newProcess.Verb = "runas";

        # Start the new process
        [System.Diagnostics.Process]::Start($newProcess);

        # Exit from the current, unelevated, process
        Exit
    } Else {
        Throw "You must be administrator to run this script"
    }
}

#------------------------------------------------------------------------------
# Load Settings
#------------------------------------------------------------------------------
$ini = Get-Settings

#------------------------------------------------------------------------------
# Create Directories
#------------------------------------------------------------------------------
$p = New-Item $ini['Settings']['DownloadDir'] -ItemType Directory -Force
$p = New-Item "$($ini['Settings']['DownloadDir'])\64" -ItemType Directory -Force
$p = New-Item "$($ini['Settings']['DownloadDir'])\32" -ItemType Directory -Force
$p = New-Item $ini['Settings']['SaltDir'] -ItemType Directory -Force

#------------------------------------------------------------------------------
# Determine Architecture (32 or 64 bit) and assign variables
#------------------------------------------------------------------------------
If ([System.IntPtr]::Size -ne 4) {
    Write-Output "Detected 64bit Architecture..."

    $bitDLLs     = "64bitDLLs"
    $bitPaths    = "64bitPaths"
    $bitPrograms = "64bitPrograms"
    $bitFolder   = "64"
} Else {
    Write-Output "Detected 32bit Architecture"
    $bitDLLs     = "32bitDLLs"
    $bitPaths    = "32bitPaths"
    $bitPrograms = "32bitPrograms"
    $bitFolder   = "32"
}

#------------------------------------------------------------------------------
# Check for installation of NSIS
#------------------------------------------------------------------------------
Write-Output " - Checking for NSIS installation . . ."
If (Test-Path "$($ini[$bitPaths]['NSISDir'])\NSIS.exe") {
    # Found NSIS, do nothing
    Write-Output " - NSIS Found . . ."
} Else {
    # NSIS not found, install
    Write-Output " - NSIS Not Found . . ."
    Write-Output " - Downloading $($ini['Prerequisites']['NSIS']) . . ."
    $file = "$($ini['Prerequisites']['NSIS'])"
    $url  = "$($ini['Settings']['SaltRepo'])/$file"
    $file = "$($ini['Settings']['DownloadDir'])\$file"
    DownloadFileWithProgress $url $file

    # Install NSIS
    Write-Output " - Installing $($ini['Prerequisites']['NSIS']) . . ."
    $file = "$($ini['Settings']['DownloadDir'])\$($ini['Prerequisites']['NSIS'])"
    $p    = Start-Process $file -ArgumentList '/S' -Wait -NoNewWindow -PassThru
}

#------------------------------------------------------------------------------
# Check for installation of NSIS NxS Unzip Plug-in
#------------------------------------------------------------------------------
Write-Output " - Checking for NSIS NxS Unzip (ansi) Plug-in installation . . ."
If (Test-Path "$( $ini[$bitPaths]['NSISPluginsDirA'] )\nsisunz.dll") {
    # Found NSIS NxS Unzip Plug-in, do nothing
    Write-Output " - NSIS NxS Unzip Plugin (ansi) Found . . ."
} Else
{
    # NSIS NxS Unzip Plug-in (ansi) not found, install
    Write-Output " - NSIS NxS Unzip Plugin (ansi) Not Found . . ."
    # Ansi Plugin
    Write-Output " - Downloading $( $ini['Prerequisites']['NSISPluginUnzipA'] ) . . ."
    $file = "$( $ini['Prerequisites']['NSISPluginUnzipA'] )"
    $url  = "$( $ini['Settings']['SaltRepo'] )/$file"
    $file = "$( $ini['Settings']['DownloadDir'] )\$file"
    DownloadFileWithProgress $url $file

    # Extract Ansi Zip file
    Write-Output " - Extracting . . ."
    Expand-ZipFile $file $ini['Settings']['DownloadDir']

    # Copy dll to plugins directory
    Write-Output " - Copying dll to plugins directory . . ."
    Move-Item "$( $ini['Settings']['DownloadDir'] )\nsisunz\Release\nsisunz.dll" "$( $ini[$bitPaths]['NSISPluginsDirA'] )\nsisunz.dll" -Force

    # Remove temp files
    Remove-Item "$( $ini['Settings']['DownloadDir'] )\nsisunz" -Force -Recurse
    Remove-Item "$file" -Force
}

Write-Output " - Checking for NSIS NxS Unzip (unicode) Plug-in installation . . ."
If (Test-Path "$( $ini[$bitPaths]['NSISPluginsDirU'] )\nsisunz.dll") {
    # Found NSIS NxS Unzip Plug-in (unicode), do nothing
    Write-Output " - NSIS NxS Unzip Plugin (unicode) Found . . ."
} Else {
    # Unicode Plugin
    Write-Output " - Downloading $( $ini['Prerequisites']['NSISPluginUnzipU'] ) . . ."
    $file = "$( $ini['Prerequisites']['NSISPluginUnzipU'] )"
    $url  = "$( $ini['Settings']['SaltRepo'] )/$file"
    $file = "$( $ini['Settings']['DownloadDir'] )\$file"
    DownloadFileWithProgress $url $file

    # Extract Unicode Zip file
    Write-Output " - Extracting . . ."
    Expand-ZipFile $file $ini['Settings']['DownloadDir']

    # Copy dll to plugins directory
    Write-Output " - Copying dll to plugins directory . . ."
    Move-Item "$( $ini['Settings']['DownloadDir'] )\NSISunzU\Plugin unicode\nsisunz.dll" "$( $ini[$bitPaths]['NSISPluginsDirU'] )\nsisunz.dll" -Force

    # Remove temp files
    Remove-Item "$( $ini['Settings']['DownloadDir'] )\NSISunzU" -Force -Recurse
    Remove-Item "$file" -Force
}

#------------------------------------------------------------------------------
# Check for installation of EnVar Plugin for NSIS
#------------------------------------------------------------------------------
Write-Output " - Checking for EnVar Plugin of NSIS installation  . . ."
If ( (Test-Path "$($ini[$bitPaths]['NSISPluginsDirA'])\EnVar.dll") -and (Test-Path "$($ini[$bitPaths]['NSISPluginsDirU'])\EnVar.dll") ) {
    # Found EnVar Plugin for NSIS, do nothing
    Write-Output " - EnVar Plugin for NSIS Found . . ."
} Else {
    # EnVar Plugin for NSIS not found, install
    Write-Output " - EnVar Plugin for NSIS Not Found . . ."
    Write-Output " - Downloading $($ini['Prerequisites']['NSISPluginEnVar']) . . ."
    $file = "$($ini['Prerequisites']['NSISPluginEnVar'])"
    $url  = "$($ini['Settings']['SaltRepo'])/$file"
    $file = "$($ini['Settings']['DownloadDir'])\$file"
    DownloadFileWithProgress $url $file

    # Extract Zip File
    Write-Output " - Extracting . . ."
    Expand-ZipFile $file "$($ini['Settings']['DownloadDir'])\nsisenvar"

    # Copy dlls to plugins directory (both ANSI and Unicode)
    Write-Output " - Copying dlls to plugins directory . . ."
    Move-Item "$( $ini['Settings']['DownloadDir'] )\nsisenvar\Plugins\x86-ansi\EnVar.dll" "$( $ini[$bitPaths]['NSISPluginsDirA'] )\EnVar.dll" -Force
    Move-Item "$( $ini['Settings']['DownloadDir'] )\nsisenvar\Plugins\x86-unicode\EnVar.dll" "$( $ini[$bitPaths]['NSISPluginsDirU'] )\EnVar.dll" -Force

    # Remove temp files
    Remove-Item "$( $ini['Settings']['DownloadDir'] )\nsisenvar" -Force -Recurse
    Remove-Item "$file" -Force

}

#------------------------------------------------------------------------------
# Check for installation of Microsoft Visual C++ Build Tools
#------------------------------------------------------------------------------
Write-Output " - Checking for Microsoft Visual C++ Build Tools installation . . ."
If (Test-Path "$($ini[$bitPaths]['VCppBuildToolsDir'])\vcbuildtools.bat") {
    # Found Microsoft Visual C++ Build Tools, do nothing
    Write-Output " - Microsoft Visual C++ Build Tools Found . . ."
} Else {
    # Microsoft Visual C++ Build Tools not found, install
    Write-Output " - Microsoft Visual C++ Build Tools Not Found . . ."
    Write-Output " - Downloading $($ini['Prerequisites']['VCppBuildTools']) . . ."
    $file = "$($ini['Prerequisites']['VCppBuildTools'])"
    $url  = "$($ini['Settings']['SaltRepo'])/$file"
    $file = "$($ini['Settings']['DownloadDir'])\$file"
    DownloadFileWithProgress $url $file

    # Install Microsoft Visual C++ Build Tools
    Write-Output " - Installing $($ini['Prerequisites']['VCppBuildTools']) . . ."
    $file = "$($ini['Settings']['DownloadDir'])\$($ini['Prerequisites']['VCppBuildTools'])"
    $p    = Start-Process $file -ArgumentList '/Quiet' -Wait -NoNewWindow -PassThru
}

#------------------------------------------------------------------------------
# Install Python
#------------------------------------------------------------------------------
Write-Output " - Checking for Python 3 installation . . ."
If (Test-Path "$($ini['Settings']['Python3Dir'])\python.exe") {
    # Found Python 3, do nothing
    Write-Output " - Python 3 Found . . ."
} Else {
    Write-Output " - Downloading $($ini[$bitPrograms]['Python3']) . . ."
    $file = "$($ini[$bitPrograms]['Python3'])"
    $url  = "$($ini['Settings']['SaltRepo'])/$bitFolder/$file"
    $file = "$($ini['Settings']['DownloadDir'])\$bitFolder\$file"
    DownloadFileWithProgress $url $file

    Write-Output " - $script_name :: Installing $($ini[$bitPrograms]['Python3']) . . ."
    $p    = Start-Process $file -ArgumentList "/Quiet InstallAllUsers=1 TargetDir=`"$($ini['Settings']['Python3Dir'])`" Include_doc=0 Include_tcltk=0 Include_test=0 Include_launcher=1 PrependPath=1 Shortcuts=0" -Wait -NoNewWindow -PassThru
}

#------------------------------------------------------------------------------
# Install VCRedist
#------------------------------------------------------------------------------
If (Test-Path "$($ini[$bitPrograms]['VCRedistReg'])") {
    # Found VCRedist 2013, do nothing
    Write-Output " - VCRedist 2013 Found . . ."
} Else {
    Write-Output " - Downloading $($ini[$bitPrograms]['VCRedist']) . . ."
    $file = "$($ini[$bitPrograms]['VCRedist'])"
    $url  = "$($ini['Settings']['SaltRepo'])/$bitFolder/$file"
    $file = "$($ini['Settings']['DownloadDir'])\$bitFolder\$file"
    DownloadFileWithProgress $url $file

    Write-Output " - $script_name :: Installing $($ini[$bitPrograms]['VCRedist']) . . ."
    $p    = Start-Process $file -ArgumentList "/install /quiet /norestart" -Wait -NoNewWindow -PassThru
}

#------------------------------------------------------------------------------
# Update Environment Variables
#------------------------------------------------------------------------------
Write-Output " - Updating Environment Variables . . ."
$Path = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH).Path
If (!($Path.ToLower().Contains("$($ini['Settings']['Scripts3Dir'])".ToLower()))) {
    $newPath  = "$($ini['Settings']['Scripts3Dir']);$Path"
    Set-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH -Value $newPath
    $env:Path = $newPath
}

#==============================================================================
# Update PIP and SetupTools
#==============================================================================
Write-Output " ----------------------------------------------------------------"
Write-Output " - $script_name :: Updating PIP, SetupTools, and Wheel . . ."
Write-Output " ----------------------------------------------------------------"
Start_Process_and_test_exitcode "cmd" "/c $($ini['Settings']['Python3Dir'])\python.exe -m pip --disable-pip-version-check --no-cache-dir install -U pip setuptools wheel" "update pip"


#==============================================================================
# Install pypi resources using pip
#==============================================================================
If ($NoPipDependencies -eq $false) {
  Write-Output " ----------------------------------------------------------------"
  Write-Output " - $script_name :: Installing pypi resources using pip . . ."
  Write-Output " ----------------------------------------------------------------"
  Start_Process_and_test_exitcode "cmd" "/c $($ini['Settings']['Python3Dir'])\python.exe -m pip --disable-pip-version-check --no-cache-dir install -r $($ini['Settings']['SrcDir'])\requirements\static\pkg\py$($ini['Settings']['PyVerMajor']).$($ini['Settings']['PyVerMinor'])\windows.txt" "pip install"
}

If (Test-Path "$($ini['Settings']['SitePkgs3Dir'])\pywin32_system32" -PathType Container )
{
    #==============================================================================
    # Cleaning Up PyWin32
    #==============================================================================
    Write-Output " ----------------------------------------------------------------"
    Write-Output " - $script_name :: Cleaning Up PyWin32 . . ."
    Write-Output " ----------------------------------------------------------------"

    # Move DLL's to Python Root
    # The dlls have to be in Python directory and the site-packages\win32 directory
    Write-Output " - $script_name :: Moving PyWin32 DLLs . . ."
    Copy-Item "$( $ini['Settings']['SitePkgs3Dir'] )\pywin32_system32\*.dll" "$( $ini['Settings']['Python3Dir'] )" -Force
    Move-Item "$( $ini['Settings']['SitePkgs3Dir'] )\pywin32_system32\*.dll" "$( $ini['Settings']['SitePkgs3Dir'] )\win32" -Force

    # Create gen_py directory
    Write-Output " - $script_name :: Creating gen_py Directory . . ."
    New-Item -Path "$( $ini['Settings']['SitePkgs3Dir'] )\win32com\gen_py" -ItemType Directory -Force | Out-Null

    # Remove pywin32_system32 directory
    Write-Output " - $script_name :: Removing pywin32_system32 Directory . . ."
    Remove-Item "$( $ini['Settings']['SitePkgs3Dir'] )\pywin32_system32"

    # Remove PyWin32 PostInstall and testall Scripts
    Write-Output " - $script_name :: Removing PyWin32 scripts . . ."
    Remove-Item "$( $ini['Settings']['Scripts3Dir'] )\pywin32_*" -Force -Recurse
}

#==============================================================================
# Copy DLLs to Python Directory
#==============================================================================
Write-Output " ----------------------------------------------------------------"
Write-Output "   - $script_name :: Copying DLLs . . ."
Write-Output " ----------------------------------------------------------------"
# Architecture Specific DLL's
ForEach($key in $ini[$bitDLLs].Keys) {
    Write-Output "   - $key . . ."
    $file = "$($ini[$bitDLLs][$key])"
    $url  = "$($ini['Settings']['SaltRepo'])/$bitFolder/$file"
    $file = "$($ini['Settings']['DownloadDir'])\$bitFolder\$file"
    DownloadFileWithProgress $url $file
    Copy-Item $file  -destination $($ini['Settings']['Python3Dir'])
}

#------------------------------------------------------------------------------
# Script complete
#------------------------------------------------------------------------------
Write-Output "================================================================="
Write-Output " $script_name :: Salt Stack Dev Environment Script Complete"
Write-Output "================================================================="
Write-Output ""

If (-Not $Silent) {
    Write-Output "Press any key to continue ..."
    $p = $HOST.UI.RawUI.Flushinputbuffer()
    $p = $HOST.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

#------------------------------------------------------------------------------
# Remove the temporary download directory
#------------------------------------------------------------------------------
Write-Output " ----------------------------------------------------------------"
#
# ps1 wrapper for psm1
#
#
Param(
    [Parameter(Mandatory=$true)][string]$url,
    [Parameter(Mandatory=$true)][string]$file
)

Import-Module ./Modules/download-module.psm1
<powershell>
New-NetFirewallRule -Name "SMB445" -DisplayName "SMB445" -Protocol TCP -LocalPort 445
New-NetFirewallRule -Name "WINRM5986" -DisplayName "WINRM5986" -Protocol TCP -LocalPort 5986

winrm quickconfig -q
winrm set winrm/config/winrs '@{MaxMemoryPerShellMB="300"}'
winrm set winrm/config '@{MaxTimeoutms="1800000"}'
winrm set winrm/config/service/auth '@{Basic="true"}'

$SourceStoreScope = 'LocalMachine'
$SourceStorename = 'Remote Desktop'

$SourceStore = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $SourceStorename, $SourceStoreScope
$SourceStore.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadOnly)

$cert = $SourceStore.Certificates | Where-Object -FilterScript {
    $_.subject -like '*'
}

$DestStoreScope = 'LocalMachine'
$DestStoreName = 'My'

$DestStore = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $DestStoreName, $DestStoreScope
$DestStore.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadWrite)
$DestStore.Add($cert)

$SourceStore.Close()
$DestStore.Close()

winrm create winrm/config/listener?Address=*+Transport=HTTPS `@`{CertificateThumbprint=`"($cert.Thumbprint)`"`}
Configuration HelloWorld {

    # Import the module that contains the File resource.
    Import-DscResource -ModuleName PsDesiredStateConfiguration

    # The Node statement specifies which targets to compile MOF files for, when this configuration is executed.
    Node $AllNodes.NodeName {

        # The File resource can ensure the state of files, or copy them from a source to a destination with persistent updates.
        File HelloWorld {
            DestinationPath = "C:\Temp\HelloWorld.txt"
            Ensure = "Present"
            Contents   = "Hello World from DSC!"
        }
    }
@{
    AllNodes = @(
        @{
            NodeName = 'localhost'
            PSDscAllowPlainTextPassword = $true
[CmdLetBinding()]
Param(
  [SecureString] $SecureString
)

if ($env:APPVEYOR_PULL_REQUEST_NUMBER -eq $null)
{
    if ($env:CONFIGURATION -eq "Release")
    {
        & "ShareX.Setup\bin\Release\ShareX.Setup.exe" -AppVeyorRelease
    }
    elseif ($env:APPVEYOR_REPO_TAG -eq $true)
    {
        if ($env:CONFIGURATION -eq "Steam")
        {
            & "ShareX.Setup\bin\Steam\ShareX.Setup.exe" -AppVeyorSteamRelease
        }
        elseif ($env:CONFIGURATION -eq "WindowsStore")
        {
            & "ShareX.Setup\bin\WindowsStore\ShareX.Setup.exe" -AppVeyorWindowsStoreRelease
        }
    }
    elseif ($env:CONFIGURATION -eq "Steam")
    {
        & "ShareX.Setup\bin\Steam\ShareX.Setup.exe" -AppVeyorSteam
    }
    elseif ($env:CONFIGURATION -eq "WindowsStore")
    {
        & "ShareX.Setup\bin\WindowsStore\ShareX.Setup.exe" -AppVeyorWindowsStore
    }
$content = Get-Content "SharedAssemblyInfo.cs"
$match = [regex]::Match($content, 'AssemblyVersion\(\"(.+?)\"\)')
if ($match.Success)
{
    $env:AppVersion = $match.Groups[1].Value
    Update-AppveyorBuild -Version "$env:AppVersion.$env:APPVEYOR_BUILD_NUMBER"
}
else
{
    $env:AppVersion = "1.0.0"
if ($env:APPVEYOR_PULL_REQUEST_NUMBER -eq $null)
{
    Invoke-WebRequest "$env:APIKeys" -OutFile "ShareX.UploadersLib\APIKeys\APIKeysLocal.cs"
}

param(
    [Parameter(Mandatory=$true)][String]$PluginDir
)

$DeinVimRepo = "https://github.com/Shougo/dein.vim"

# Convert the installation directory to absolute path and create plugin directory
$PluginDir = (New-Item -Type Directory -Force $PluginDir).FullName

$InstallDir = Join-Path $PluginDir "repos/github.com/Shougo/dein.vim"
Write-Output "Install to `"$InstallDir`"..."
if (Test-Path $InstallDir) {
    Write-Output "`"$InstallDir`" already exists!"
}

# check git command
if (!(Get-Command git -ErrorAction SilentlyContinue -OutVariable $_)) {
    throw 'Please install git or update your path to include the git executable!'
}
Write-Output ""

# make plugin dir and fetch dein
Write-Output "Begin fetching dein..."
git clone $DeinVimRepo $InstallDir
Write-Output "Done.`n"

Write-Host -ForegroundColor Yellow "Please add the following settings for dein to the top of your vimrc (Vim) or init.vim (NeoVim) file:"

Write-Output ""
Write-Output ""
Write-Output "`"dein Scripts-----------------------------"
Write-Output "if &compatible"
Write-Output "  set nocompatible               `" Be iMproved"
Write-Output "endif"
Write-Output ""
Write-Output "`" Required:"
Write-Output "set runtimepath+=$InstallDir"
Write-Output ""
Write-Output "`" Required:"
Write-Output "if dein#load_state('$PluginDir')"
Write-Output "  call dein#begin('$PluginDir')"
Write-Output ""
Write-Output "  `" Let dein manage dein"
Write-Output "  `" Required:"
Write-Output "  call dein#add('$InstallDir')"
Write-Output ""
Write-Output "  `" Add or remove your plugins here like this:"
Write-Output "  `"call dein#add('Shougo/neosnippet.vim')"
Write-Output "  `"call dein#add('Shougo/neosnippet-snippets')"
Write-Output ""
Write-Output "  `" Required:"
Write-Output "  call dein#end()"
Write-Output "  call dein#save_state()"
Write-Output "endif"
Write-Output ""
Write-Output "`" Required:"
Write-Output "filetype plugin indent on"
Write-Output "syntax enable"
Write-Output ""
Write-Output "`" If you want to install not installed plugins on startup."
Write-Output "`"if dein#check_install()"
Write-Output "`"  call dein#install()"
Write-Output "`"endif"
Write-Output ""
Write-Output "`"End dein Scripts-------------------------"
Write-Output ""
Write-Output ""

Write-Output "Done."

# editorconfig2.ps1: Editorconfig Vimscript core CLI, PowerShell version
# Copyright (c) 2018--2019 Chris White.  All rights reserved.
# Licensed CC-BY-SA, version 3.0 or any later version, at your option.
# Thanks to https://cecs.wright.edu/~pmateti/Courses/233/Labs/Scripting/bashVsPowerShellTable.html
# by Gallagher and Mateti.

#Requires -Version 3

. "$PSScriptRoot\ecvimlib.ps1"

# Argument parsing =================================================== {{{1

$argv = @(de64_args($args))

# Defaults
$report_version = $false
$set_version = ''
$config_name = '.editorconfig'
$extra_info = ''
$files=@()

# Hand-parse - pretend we're sort of like getopt.
$idx = 0
while($idx -lt $argv.count) {
    $a = $argv[$idx]

    switch -CaseSensitive -Regex ($a) {
        '^(-v|--version)$' { $report_version = $true }

        '^--dummy$' {
            # A dummy option so that I can test list-valued EDITORCONFIG_CMD
        }

        '^-f$' {
            if($idx -eq ($argv.count-1)) {
                throw '-f <filename>: no filename provided'
            } else {
                ++$idx
                $config_name = $argv[$idx]
            }
        } #-f

        '^-b$' {
            if($idx -eq ($argv.count-1)) {
                throw '-b <version>: no version provided'
            } else {
                ++$idx
                $set_version = $argv[$idx]
            }
        } #-b

        '^-x$' {
            if($idx -eq ($argv.count-1)) {
                throw '-x <extra info>: no info provided'
            } else {
                ++$idx
                $extra_info = $argv[$idx]
            }
        } #-x

        '^--$' {    # End of options, so capture the rest as filenames
            ++$idx;
            while($idx -lt $argv.count) {
                $files += $argv[$idx]
            }
        }

        default { $files += $a }
    }

    ++$idx
} # end foreach argument

# }}}1
# Argument processing ================================================ {{{1

if($debug) {
    if($extra_info -ne '') {
        echo "--- $extra_info --- "             | D
    }

    echo "Running in       $DIR"                | D
    echo "Vim executable:  $VIM"                | D
    echo "report version?  $report_version"     | D
    echo "set version to:  $set_version"        | D
    echo "config filename: $config_name"        | D
    echo "Filenames:       $files"              | D
    echo "Args:            $args"               | D
    echo "Decoded args:    $argv"               | D
}

if($report_version) {
    echo "EditorConfig VimScript Core Version 0.12.2"
    exit
}

if($files.count -lt 1) {
    exit
}

if($files[0] -eq '-') {
    echo "Reading filenames from stdin not yet supported" # TODO
    exit 1
}

$fn=[System.IO.Path]::GetTempFileName();
    # Vim will write the settings into here.  Sort of like stdout.
$script_output_fn = ''
if($debug) {
    $script_output_fn = [System.IO.Path]::GetTempFileName()
}

# Permit throwing in setup commands
$cmd = ''
if($env:EDITORCONFIG_EXTRA) {
    $cmd += $env:EDITORCONFIG_EXTRA + ' | '
}

# }}}1
# Build Vim command line ============================================= {{{1
$cmd += 'call editorconfig_core#currbuf_cli({'

# Names
$cmd += "'output':" + (vesc($fn)) + ", "
    # filename to put the settings in
if($debug) {
    $cmd += " 'dump':" + (vesc($script_output_fn)) + ", "
    # where to put debug info
}

# Filenames to get the settings for
$cmd += "'target':["
ForEach ($item in $files) {
    $cmd += (vesc($item)) + ", "
}
$cmd += "],"

# Job
$cmd += "}, {"
if($config_name) { $cmd += "'config':" + (vesc($config_name)) + ", " }
    # config name (e.g., .editorconfig)
if($set_version) { $cmd += "'version':" + (vesc($set_version)) + ", " }
    # version number we should behave as
$cmd += "})"

#$cmd =':q!'  # DEBUG
if($debug) { echo "Using Vim command ${cmd}" | D }
$vim_args = @(
    '-c', "set runtimepath+=${DIR}\..\..",
    '-c', $cmd,
    '-c', 'quit!'   # TODO write a wrapper that will cquit on exception
)

# Run editorconfig.  Thanks for options to
# http://vim.wikia.com/wiki/Vim_as_a_system_interpreter_for_vimscript .
# Add -V1 to the below for debugging output.
# Do not output anything to stdout or stderr,
# since it messes up ctest's interpretation
# of the results.

$basic_args = '-nNes','-i','NONE','-u','NONE','-U','NONE'   #, '-V1'

# }}}1
# Run Vim ============================================================ {{{1

if($debug) { echo "Running vim ${VIM}" | D }
$vimstatus = run_process $VIM -stdout $debug -stderr $debug `
    -argv ($basic_args+$vim_args)
if($debug) { echo "Done running vim" | D }

if($vimstatus -eq 0) {
    cat $fn
}

# }}}1
# Produce debug output =============================================== {{{1

# Debug output cannot be included on stdout or stderr, because
# ctest's regex check looks both of those places.  Therefore, dump to a
# separate debugging file.

if($debug) {
    echo "Current directory:" | D
    (get-item -path '.').FullName | D
    echo "Script directory: $DIR" | D
###     echo Vim args: "${vim_args[@]}" >> "$debug"
###     #od -c <<<"${vim_args[@]}" >> "$debug"
    echo "Vim returned $vimstatus" | D
    echo "Vim messages were: " | D
    cat $script_output_fn | D
    echo "Output was:" | D

    # Modified from https://www.itprotoday.com/powershell/get-hex-dumps-files-powershell
    Get-Content $script_output_fn -Encoding Byte -ReadCount 16 | `
    ForEach-Object {
        $output = ""
        $chars = ''
        foreach ( $byte in $_ ) {
            $output += "{0:X2} " -f $byte
            if( ($byte -ge 32) -and ($byte -le 127) ) {
                $chars += [char]$byte
            } else {
                $chars += '.'
            }
        }
        $output + ' ' + $chars
    } | D

    del -Force $script_output_fn
} #endif $debug

# }}}1

del -Force $fn

# ecvimlib.ps1: Editorconfig Vimscript core CLI, PowerShell version,
# library routines.
# Copyright (c) 2018--2019 Chris White.  All rights reserved.
# Licensed CC-BY-SA, version 3.0 or any later version, at your option.
#
# N.B.: debug output uses Warning only because those are displayed by default.

#Requires -Version 3

# Get the directory of this script.  From
# https://stackoverflow.com/a/5466355/2877364 by
# https://stackoverflow.com/users/23283/jaredpar

$global:DIR = $PSScriptRoot

### Set up debugging output ============================================

$global:debug=$env:EDITORCONFIG_DEBUG  # Debug filename

if($global:debug -and ($global:debug -notmatch '^/')) {
    # Relative to this script unless it starts with a slash.  This is because
    # cwd is usually not $DIR when testing.
    $global:debug="${DIR}/${global:debug}"
}

### Process args =======================================================

function de64_args($argv) {
    $argv | % {
        $b64 = $_ -replace '-','=' -replace '_','/' -replace '\.','+'
        [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($b64))
    }
}

### Helpers ============================================================

# Append a string to $debug in UTF-8 rather than the default UTF-16
filter global:D($file = $debug) {
    if($debug) {
        echo $_ | Out-File -FilePath $file -Encoding utf8 -Append
    }
}

# Escape a string for Vim
function global:vesc($str) {
    return "'" + ($str -replace "'","''") + "'"
}

# Escape a string for a command-line argument.
# See https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processstartinfo.arguments?view=netframework-4.7.2
function global:argesc($arg) {
    return '"' + ($arg -replace '"','"""') + '"'
}

### Find the Vim EXE ===================================================

function global:Find-Vim
{
    if($env:VIM_EXE) {
        if($debug) { echo "Using env Vim $($env:VIM_EXE)" | D }
        return $env:VIM_EXE
    }

    $vims = @(get-childitem 'c:\program files*\vim\**\vim.exe' | `
            sort LastWriteTime -Descending)     # @() => always array

    # write-host ($vims | format-table | out-string)    # DEBUG
    # write-host ($vims | get-member | out-string)
    if($vims.count -gt 0) {
        if($debug) { echo "Using found Vim $($vims[0].FullName)" | D }
        return $vims[0].FullName
    }

    throw "Could not find vim.exe.  Please set VIM_EXE to the path to your Vim."
} #Find-Vim

### Runner =============================================================

# Run a process with the given arguments.
function global:run_process
{
    param(
        [Parameter(Mandatory=$true, Position=0)][string]$run,
        [string]$extrapath,
        [string]$stdout,        # Redirect stdout to this file
        [string]$stderr,        # Redirect stderr to this file
        [string[]]$argv         # Arguments to $run
    )
    $si = new-object Diagnostics.ProcessStartInfo
    if($extrapath) {
        $si.EnvironmentVariables['path']+=";${extrapath}"
    }
    $si.FileName=$run

    # Stringify the arguments (blech)
    $argstr = $argv | % { (argesc $_) + ' ' }
    $si.Arguments = $argstr;

    if($debug) { echo "Running process $run with arguments >>$argstr<<" | D }

    $si.UseShellExecute=$false
    # DEBUG  $si.RedirectStandardInput=$true
    if($stdout) {
        if($debug) { echo "Saving stdout to ${stdout}" | D }
        $si.RedirectStandardOutput=$true;
    }
    if($stderr) {
        if($debug) { echo "Saving stderr to ${stderr}" | D }
        $si.RedirectStandardError=$true;
    }

    $p = [Diagnostics.Process]::Start($si)
    # DEBUG $p.StandardInput.Close()        # < /dev/null

    $p.WaitForExit()
    $retval = $p.ExitCode

    if($stdout) {
        echo "Standard output:" | D $stdout
        $p.StandardOutput.ReadToEnd() | `
            Out-File -FilePath $stdout -Encoding utf8 -Append
    }

    if($stderr) {
        echo "Standard error:" | D $stderr
        $p.StandardError.ReadToEnd() | `
            Out-File -FilePath $stderr -Encoding utf8 -Append
    }

    $p.Close()

    return $retval
}

if($debug) {
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
# This script enables you running RocksDB tests by running
# All the tests concurrently and utilizing all the cores
Param(
  [switch]$EnableJE = $false,  # Look for and use test executable, append _je to listed exclusions
  [switch]$RunAll = $false,    # Will attempt discover all *_test[_je].exe binaries and run all
                               # of them as Google suites. I.e. It will run test cases concurrently
                               # except those mentioned as $Run, those will run as individual test cases
                               # And any execlued with $ExcludeExes or $ExcludeCases
                               # It will also not run any individual test cases
                               # excluded but $ExcludeCasese
  [switch]$RunAllExe = $false, # Look for and use test exdcutables, append _je to exclusions automatically
                               # It will attempt to run them in parallel w/o breaking them up on individual
                               # test cases. Those listed with $ExcludeExes will be excluded
  [string]$SuiteRun = "",      # Split test suites in test cases and run in parallel, not compatible with $RunAll
  [string]$Run = "",           # Run specified executables in parallel but do not split to test cases
  [string]$ExcludeCases = "",  # Exclude test cases, expects a comma separated list, no spaces
                               # Takes effect when $RunAll or $SuiteRun is specified. Must have full
                               # Test cases name including a group and a parameter if any
  [string]$ExcludeExes = "",   # Exclude exes from consideration, expects a comma separated list,
                               # no spaces. Takes effect only when $RunAll is specified
  [string]$WorkFolder = "",    # Direct tests to use that folder. SSD or Ram drive are better options.
   # Number of async tasks that would run concurrently. Recommend a number below 64.
   # However, CPU utlization really depends on the storage media. Recommend ram based disk.
   # a value of 1 will run everything serially
  [int]$Concurrency = 8,
  [int]$Limit = -1 # -1 means do not limit for test purposes
)

# Folders and commands must be fullpath to run assuming
# the current folder is at the root of the git enlistment
$StartDate = (Get-Date)
$StartDate


$DebugPreference = "Continue"

# These tests are not google test suites and we should guard
# Against running them as suites
$RunOnly = New-Object System.Collections.Generic.HashSet[string]
$RunOnly.Add("c_test") | Out-Null
$RunOnly.Add("compact_on_deletion_collector_test") | Out-Null
$RunOnly.Add("merge_test") | Out-Null
$RunOnly.Add("stringappend_test") | Out-Null # Apparently incorrectly written
$RunOnly.Add("backupable_db_test") | Out-Null # Disabled
$RunOnly.Add("timer_queue_test") | Out-Null # Not a gtest

if($RunAll -and $SuiteRun -ne "") {
    Write-Error "$RunAll and $SuiteRun are not compatible"
    exit 1
}

if($RunAllExe -and $Run -ne "") {
    Write-Error "$RunAllExe and $Run are not compatible"
    exit 1
}

# If running under Appveyor assume that root
[string]$Appveyor = $Env:APPVEYOR_BUILD_FOLDER
if($Appveyor -ne "") {
    $RootFolder = $Appveyor
} else {
    $RootFolder = $PSScriptRoot -replace '\\build_tools', ''
}

$LogFolder = -Join($RootFolder, "\db_logs\")
$BinariesFolder = -Join($RootFolder, "\build\Debug\")

if($WorkFolder -eq "") {

    # If TEST_TMPDIR is set use it
    [string]$var = $Env:TEST_TMPDIR
    if($var -eq "") {
        $WorkFolder = -Join($RootFolder, "\db_tests\")
        $Env:TEST_TMPDIR = $WorkFolder
    } else {
        $WorkFolder = $var
    }
} else {
# Override from a command line
  $Env:TEST_TMPDIR = $WorkFolder
}

Write-Output "Root: $RootFolder, WorkFolder: $WorkFolder"
Write-Output "BinariesFolder: $BinariesFolder, LogFolder: $LogFolder"

# Create test directories in the current folder
md -Path $WorkFolder -ErrorAction Ignore | Out-Null
md -Path $LogFolder -ErrorAction Ignore | Out-Null


$ExcludeCasesSet = New-Object System.Collections.Generic.HashSet[string]
if($ExcludeCases -ne "") {
    Write-Host "ExcludeCases: $ExcludeCases"
    $l = $ExcludeCases -split ' '
    ForEach($t in $l) {
      $ExcludeCasesSet.Add($t) | Out-Null
    }
}

$ExcludeExesSet = New-Object System.Collections.Generic.HashSet[string]
if($ExcludeExes -ne "") {
    Write-Host "ExcludeExe: $ExcludeExes"
    $l = $ExcludeExes -split ' '
    ForEach($t in $l) {
      $ExcludeExesSet.Add($t) | Out-Null
    }
}


# Extract the names of its tests by running db_test with --gtest_list_tests.
# This filter removes the "#"-introduced comments, and expands to
# fully-qualified names by changing input like this:
#
#   DBTest.
#     Empty
#     WriteEmptyBatch
#   MultiThreaded/MultiThreadedDBTest.
#     MultiThreaded/0  # GetParam() = 0
#     MultiThreaded/1  # GetParam() = 1
#   RibbonTypeParamTest/0.  # TypeParam = struct DefaultTypesAndSettings
#     CompactnessAndBacktrackAndFpRate
#     Extremes
#     FindOccupancyForSuccessRate
#
# into this:
#
#   DBTest.Empty
#   DBTest.WriteEmptyBatch
#   MultiThreaded/MultiThreadedDBTest.MultiThreaded/0
#   MultiThreaded/MultiThreadedDBTest.MultiThreaded/1
#   RibbonTypeParamTest/0.CompactnessAndBacktrackAndFpRate
#   RibbonTypeParamTest/0.Extremes
#   RibbonTypeParamTest/0.FindOccupancyForSuccessRate
#
# Output into the parameter in a form TestName -> Log File Name
function ExtractTestCases([string]$GTestExe, $HashTable) {

    $Tests = @()
# Run db_test to get a list of tests and store it into $a array
    &$GTestExe --gtest_list_tests | tee -Variable Tests | Out-Null

    # Current group
    $Group=""

    ForEach( $l in $Tests) {

      # remove trailing comment if any
      $l = $l -replace '\s+\#.*',''
      # Leading whitespace is fine
      $l = $l -replace '^\s+',''
      # Trailing dot is a test group but no whitespace
      if ($l -match "\.$" -and $l -notmatch "\s+") {
        $Group = $l
      }  else {
        # Otherwise it is a test name, remove leading space
        $test = $l
        # create a log name
        $test = "$Group$test"

        if($ExcludeCasesSet.Contains($test)) {
            Write-Warning "$test case is excluded"
            continue
        }

        $test_log = $test -replace '[\./]','_'
        $test_log += ".log"
        $log_path = -join ($LogFolder, $test_log)

        # Add to a hashtable
        $HashTable.Add($test, $log_path);
      }
    }
}

# The function removes trailing .exe siffix if any,
# creates a name for the log file
# Then adds the test name if it was not excluded into
# a HashTable in a form of test_name -> log_path
function MakeAndAdd([string]$token, $HashTable) {

    $test_name = $token -replace '.exe$', ''
    $log_name =  -join ($test_name, ".log")
    $log_path = -join ($LogFolder, $log_name)
    $HashTable.Add($test_name, $log_path)
}

# This function takes a list of Suites to run
# Lists all the test cases in each of the suite
# and populates HashOfHashes
# Ordered by suite(exe) @{ Exe = @{ TestCase = LogName }}
function ProcessSuites($ListOfSuites, $HashOfHashes) {

  $suite_list = $ListOfSuites
  # Problem: if you run --gtest_list_tests on
  # a non Google Test executable then it will start executing
  # and we will get nowhere
  ForEach($suite in $suite_list) {

    if($RunOnly.Contains($suite)) {
      Write-Warning "$suite is excluded from running as Google test suite"
      continue
    }

    if($EnableJE) {
      $suite += "_je"
    }

    $Cases = [ordered]@{}
    $Cases.Clear()
    $suite_exe = -Join ($BinariesFolder, $suite)
    ExtractTestCases -GTestExe $suite_exe -HashTable $Cases
    if($Cases.Count -gt 0) {
      $HashOfHashes.Add($suite, $Cases);
    }
  }

  # Make logs and run
  if($CasesToRun.Count -lt 1) {
     Write-Error "Failed to extract tests from $SuiteRun"
     exit 1
  }

}

# This will contain all test executables to run

# Hash table that contains all non suite
# Test executable to run
$TestExes = [ordered]@{}

# Check for test exe that are not
# Google Test Suites
# Since this is explicitely mentioned it is not subject
# for exclusions
if($Run -ne "") {

  $test_list = $Run -split ' '
  ForEach($t in $test_list) {

    if($EnableJE) {
      $t += "_je"
    }
    MakeAndAdd -token $t -HashTable $TestExes
  }

  if($TestExes.Count -lt 1) {
     Write-Error "Failed to extract tests from $Run"
     exit 1
  }
} elseif($RunAllExe) {
  # Discover all the test binaries
  if($EnableJE) {
    $pattern = "*_test_je.exe"
  } else {
    $pattern = "*_test.exe"
  }

  $search_path = -join ($BinariesFolder, $pattern)
  Write-Host "Binaries Search Path: $search_path"

  $DiscoveredExe = @()
  dir -Path $search_path | ForEach-Object {
     $DiscoveredExe += ($_.Name)
  }

  # Remove exclusions
  ForEach($e in $DiscoveredExe) {
    $e = $e -replace '.exe$', ''
    $bare_name = $e -replace '_je$', ''

    if($ExcludeExesSet.Contains($bare_name)) {
      Write-Warning "Test $e is excluded"
      continue
    }
    MakeAndAdd -token $e -HashTable $TestExes
  }

  if($TestExes.Count -lt 1) {
     Write-Error "Failed to discover test executables"
     exit 1
  }
}

# Ordered by exe @{ Exe = @{ TestCase = LogName }}
$CasesToRun = [ordered]@{}

if($SuiteRun -ne "") {
  $suite_list = $SuiteRun -split ' '
  ProcessSuites -ListOfSuites $suite_list -HashOfHashes $CasesToRun
} elseif ($RunAll) {
# Discover all the test binaries
  if($EnableJE) {
    $pattern = "*_test_je.exe"
  } else {
    $pattern = "*_test.exe"
  }

  $search_path = -join ($BinariesFolder, $pattern)
  Write-Host "Binaries Search Path: $search_path"

  $ListOfExe = @()
  dir -Path $search_path | ForEach-Object {
     $ListOfExe += ($_.Name)
  }

  # Exclude those in RunOnly from running as suites
  $ListOfSuites = @()
  ForEach($e in $ListOfExe) {

    $e = $e -replace '.exe$', ''
    $bare_name = $e -replace '_je$', ''

    if($ExcludeExesSet.Contains($bare_name)) {
      Write-Warning "Test $e is excluded"
      continue
    }

    if($RunOnly.Contains($bare_name)) {
      MakeAndAdd -token $e -HashTable $TestExes
    } else {
      $ListOfSuites += $bare_name
    }
  }

  ProcessSuites -ListOfSuites $ListOfSuites -HashOfHashes $CasesToRun
}


# Invoke a test with a filter and redirect all output
$InvokeTestCase = {
    param($exe, $test, $log);
    &$exe --gtest_filter=$test > $log 2>&1
}

# Invoke all tests and redirect output
$InvokeTestAsync = {
    param($exe, $log)
    &$exe > $log 2>&1
}

# Hash that contains tests to rerun if any failed
# Those tests will be rerun sequentially
# $Rerun = [ordered]@{}
# Test limiting factor here
[int]$count = 0
# Overall status
[bool]$script:success = $true;

function RunJobs($Suites, $TestCmds, [int]$ConcurrencyVal)
{
    # Array to wait for any of the running jobs
    $jobs = @()
    # Hash JobToLog
    $JobToLog = @{}

    # Wait for all to finish and get the results
    while(($JobToLog.Count -gt 0) -or
          ($TestCmds.Count -gt 0) -or
           ($Suites.Count -gt 0)) {

        # Make sure we have maximum concurrent jobs running if anything
        # and the $Limit either not set or allows to proceed
        while(($JobToLog.Count -lt $ConcurrencyVal) -and
              ((($TestCmds.Count -gt 0) -or ($Suites.Count -gt 0)) -and
              (($Limit -lt 0) -or ($count -lt $Limit)))) {

            # We always favore suites to run if available
            [string]$exe_name = ""
            [string]$log_path = ""
            $Cases = @{}

            if($Suites.Count -gt 0) {
              # Will the first one
              ForEach($e in $Suites.Keys) {
                $exe_name = $e
                $Cases = $Suites[$e]
                break
              }
              [string]$test_case = ""
              [string]$log_path = ""
              ForEach($c in $Cases.Keys) {
                 $test_case = $c
                 $log_path = $Cases[$c]
                 break
              }

              Write-Host "Starting $exe_name::$test_case"
              [string]$Exe =  -Join ($BinariesFolder, $exe_name)
              $job = Start-Job -Name "$exe_name::$test_case" -ArgumentList @($Exe,$test_case,$log_path) -ScriptBlock $InvokeTestCase
              $JobToLog.Add($job, $log_path)

              $Cases.Remove($test_case)
              if($Cases.Count -lt 1) {
                $Suites.Remove($exe_name)
              }

            } elseif ($TestCmds.Count -gt 0) {

               ForEach($e in $TestCmds.Keys) {
                 $exe_name = $e
                 $log_path = $TestCmds[$e]
                 break
               }

              Write-Host "Starting $exe_name"
              [string]$Exe =  -Join ($BinariesFolder, $exe_name)
              $job = Start-Job -Name $exe_name -ScriptBlock $InvokeTestAsync -ArgumentList @($Exe,$log_path)
              $JobToLog.Add($job, $log_path)

              $TestCmds.Remove($exe_name)

            } else {
                Write-Error "In the job loop but nothing to run"
                exit 1
            }

            ++$count
        } # End of Job starting loop

        if($JobToLog.Count -lt 1) {
          break
        }

        $jobs = @()
        foreach($k in $JobToLog.Keys) { $jobs += $k }

        $completed = Wait-Job -Job $jobs -Any
        $log = $JobToLog[$completed]
        $JobToLog.Remove($completed)

        $message = -join @($completed.Name, " State: ", ($completed.State))

        $log_content = @(Get-Content $log)

        if($completed.State -ne "Completed") {
            $script:success = $false
            Write-Warning $message
            $log_content | Write-Warning
        } else {
            # Scan the log. If we find PASSED and no occurrence of FAILED
            # then it is a success
            [bool]$pass_found = $false
            ForEach($l in $log_content) {

                if(($l -match "^\[\s+FAILED") -or
                   ($l -match "Assertion failed:")) {
                    $pass_found = $false
                    break
                }

                if(($l -match "^\[\s+PASSED") -or
                   ($l -match " : PASSED$") -or
                    ($l -match "^PASS$") -or   # Special c_test case
                    ($l -match "Passed all tests!") ) {
                    $pass_found = $true
                }
            }

            if(!$pass_found) {
                $script:success = $false;
                Write-Warning $message
                $log_content | Write-Warning
            } else {
                Write-Host $message
            }
        }

        # Remove cached job info from the system
        # Should be no output
        Receive-Job -Job $completed | Out-Null
    }
}

RunJobs -Suites $CasesToRun -TestCmds $TestExes -ConcurrencyVal $Concurrency

$EndDate = (Get-Date)

New-TimeSpan -Start $StartDate -End $EndDate |
  ForEach-Object {
    "Elapsed time: {0:g}" -f $_
  }


if(!$script:success) {
# This does not succeed killing off jobs quick
# So we simply exit
#    Remove-Job -Job $jobs -Force
# indicate failure using this exit code
    exit 1
# (c) 2018 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

param(
    [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Payload
)

#Requires -Module Ansible.ModuleUtils.AddType
#AnsibleRequires -CSharpUtil Ansible.AccessToken
#AnsibleRequires -CSharpUtil Ansible.Become

$ErrorActionPreference = "Stop"

Write-AnsibleLog "INFO - starting become_wrapper" "become_wrapper"

Function Get-EnumValue($enum, $flag_type, $value) {
    $raw_enum_value = $value.Replace('_', '')
    try {
        $enum_value = [Enum]::Parse($enum, $raw_enum_value, $true)
    } catch [System.ArgumentException] {
        $valid_options = [Enum]::GetNames($enum) | ForEach-Object -Process {
            (($_ -creplace "(.)([A-Z][a-z]+)", '$1_$2') -creplace "([a-z0-9])([A-Z])", '$1_$2').ToString().ToLower()
        }
        throw "become_flags $flag_type value '$value' is not valid, valid values are: $($valid_options -join ", ")"
    }
    return $enum_value
}

Function Get-BecomeFlags($flags) {
    $logon_type = [Ansible.AccessToken.LogonType]::Interactive
    $logon_flags = [Ansible.Become.LogonFlags]::WithProfile

    if ($null -eq $flags -or $flags -eq "") {
        $flag_split = @()
    } elseif ($flags -is [string]) {
        $flag_split = $flags.Split(" ")
    } else {
        throw "become_flags must be a string, was $($flags.GetType())"
    }

    foreach ($flag in $flag_split) {
        $split = $flag.Split("=")
        if ($split.Count -ne 2) {
            throw "become_flags entry '$flag' is in an invalid format, must be a key=value pair"
        }
        $flag_key = $split[0]
        $flag_value = $split[1]
        if ($flag_key -eq "logon_type") {
            $enum_details = @{
                enum = [Ansible.AccessToken.LogonType]
                flag_type = $flag_key
                value = $flag_value
            }
            $logon_type = Get-EnumValue @enum_details
        } elseif ($flag_key -eq "logon_flags") {
            $logon_flag_values = $flag_value.Split(",")
            $logon_flags = 0 -as [Ansible.Become.LogonFlags]
            foreach ($logon_flag_value in $logon_flag_values) {
                if ($logon_flag_value -eq "") {
                    continue
                }
                $enum_details = @{
                    enum = [Ansible.Become.LogonFlags]
                    flag_type = $flag_key
                    value = $logon_flag_value
                }
                $logon_flag = Get-EnumValue @enum_details
                $logon_flags = $logon_flags -bor $logon_flag
            }
        } else {
            throw "become_flags key '$flag_key' is not a valid runas flag, must be 'logon_type' or 'logon_flags'"
        }
    }

    return $logon_type, [Ansible.Become.LogonFlags]$logon_flags
}

Write-AnsibleLog "INFO - loading C# become code" "become_wrapper"
$add_type_b64 = $Payload.powershell_modules["Ansible.ModuleUtils.AddType"]
$add_type = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($add_type_b64))
New-Module -Name Ansible.ModuleUtils.AddType -ScriptBlock ([ScriptBlock]::Create($add_type)) | Import-Module > $null

$new_tmp = [System.Environment]::ExpandEnvironmentVariables($Payload.module_args["_ansible_remote_tmp"])
$access_def = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.csharp_utils["Ansible.AccessToken"]))
$become_def = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.csharp_utils["Ansible.Become"]))
$process_def = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.csharp_utils["Ansible.Process"]))
Add-CSharpType -References $access_def, $become_def, $process_def -TempPath $new_tmp -IncludeDebugInfo

$username = $Payload.become_user
$password = $Payload.become_password
# We need to set password to the value of NullString so a null password is preserved when crossing the .NET
# boundary. If we pass $null it will automatically be converted to "" and we need to keep the distinction for
# accounts that don't have a password and when someone wants to become without knowing the password.
if ($null -eq $password) {
    $password = [NullString]::Value
}

try {
    $logon_type, $logon_flags = Get-BecomeFlags -flags $Payload.become_flags
} catch {
    Write-AnsibleError -Message "internal error: failed to parse become_flags '$($Payload.become_flags)'" -ErrorRecord $_
    $host.SetShouldExit(1)
    return
}
Write-AnsibleLog "INFO - parsed become input, user: '$username', type: '$logon_type', flags: '$logon_flags'" "become_wrapper"

# NB: CreateProcessWithTokenW commandline maxes out at 1024 chars, must
# bootstrap via small wrapper which contains the exec_wrapper passed through the
# stdin pipe. Cannot use 'powershell -' as the $ErrorActionPreference is always
# set to Stop and cannot be changed. Also need to split the payload from the wrapper to prevent potentially
# sensitive content from being logged by the scriptblock logger.
$bootstrap_wrapper = {
    &chcp.com 65001 > $null
    $exec_wrapper_str = [System.Console]::In.ReadToEnd()
    $split_parts = $exec_wrapper_str.Split(@("`0`0`0`0"), 2, [StringSplitOptions]::RemoveEmptyEntries)
    Set-Variable -Name json_raw -Value $split_parts[1]
    $exec_wrapper = [ScriptBlock]::Create($split_parts[0])
    &$exec_wrapper
}
$exec_command = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($bootstrap_wrapper.ToString()))
$lp_command_line = "powershell.exe -NonInteractive -NoProfile -ExecutionPolicy Bypass -EncodedCommand $exec_command"
$lp_current_directory = $env:SystemRoot  # TODO: should this be set to the become user's profile dir?

# pop the become_wrapper action so we don't get stuck in a loop
$Payload.actions = $Payload.actions[1..99]
# we want the output from the exec_wrapper to be base64 encoded to preserve unicode chars
$Payload.encoded_output = $true

$payload_json = ConvertTo-Json -InputObject $Payload -Depth 99 -Compress
# delimit the payload JSON from the wrapper to keep sensitive contents out of scriptblocks (which can be logged)
$exec_wrapper = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.exec_wrapper))
$exec_wrapper += "`0`0`0`0" + $payload_json

try {
    Write-AnsibleLog "INFO - starting become process '$lp_command_line'" "become_wrapper"
    $result = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($username, $password, $logon_flags, $logon_type,
        $null, $lp_command_line,  $lp_current_directory, $null, $exec_wrapper)
    Write-AnsibleLog "INFO - become process complete with rc: $($result.ExitCode)" "become_wrapper"
    $stdout = $result.StandardOut
    try {
        $stdout = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($stdout))
    } catch [FormatException] {
        # output wasn't Base64, ignore as it may contain an error message we want to pass to Ansible
        Write-AnsibleLog "WARN - become process stdout was not base64 encoded as expected: $stdout"
    }

    $host.UI.WriteLine($stdout)
    $host.UI.WriteErrorLine($result.StandardError.Trim())
    $host.SetShouldExit($result.ExitCode)
} catch {
# (c) 2018 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

<#
.SYNOPSIS
Invokes an Ansible module in a new Runspace. This cmdlet will output the
module's output and write any errors to the error stream of the current
host.

.PARAMETER Scripts
[Object[]] String or ScriptBlocks to execute.

.PARAMETER Variables
[System.Collections.ArrayList] The variables to set in the new Pipeline.
Each value is a hashtable that contains the parameters to use with
Set-Variable;
    Name: the name of the variable to set
    Value: the value of the variable to set
    Scope: the scope of the variable

.PARAMETER Environment
[System.Collections.IDictionary] A Dictionary of environment key/values to
set in the new Pipeline.

.PARAMETER Modules
[System.Collections.IDictionary] A Dictionary of PowerShell modules to
import into the new Pipeline. The key is the name of the module and the
value is a base64 string of the module util code.

.PARAMETER ModuleName
[String] The name of the module that is being executed.

.PARAMETER Breakpoints
A list of line breakpoints to add to the runspace debugger. This is used to
track module and module_utils coverage.
#>
param(
    [Object[]]$Scripts,
    [System.Collections.ArrayList][AllowEmptyCollection()]$Variables,
    [System.Collections.IDictionary]$Environment,
    [System.Collections.IDictionary]$Modules,
    [String]$ModuleName,
    [System.Management.Automation.LineBreakpoint[]]$Breakpoints = @()
)

Write-AnsibleLog "INFO - creating new PowerShell pipeline for $ModuleName" "module_wrapper"
$ps = [PowerShell]::Create()

# do not set ErrorActionPreference for script
if ($ModuleName -ne "script") {
    $ps.Runspace.SessionStateProxy.SetVariable("ErrorActionPreference", "Stop")
}

# force input encoding to preamble-free UTF8 so PS sub-processes (eg,
# Start-Job) don't blow up. This is only required for WinRM, a PSRP
# runspace doesn't have a host console and this will bomb out
if ($host.Name -eq "ConsoleHost") {
    Write-AnsibleLog "INFO - setting console input encoding to UTF8 for $ModuleName" "module_wrapper"
    $ps.AddScript('[Console]::InputEncoding = New-Object Text.UTF8Encoding $false').AddStatement() > $null
}

# set the variables
foreach ($variable in $Variables) {
    Write-AnsibleLog "INFO - setting variable '$($variable.Name)' for $ModuleName" "module_wrapper"
    $ps.AddCommand("Set-Variable").AddParameters($variable).AddStatement() > $null
}

# set the environment vars
if ($Environment) {
    # Escaping quotes can be problematic, instead just pass the string to the runspace and set it directly.
    Write-AnsibleLog "INFO - setting environment vars for $ModuleName" "module_wrapper"
    $ps.Runspace.SessionStateProxy.SetVariable("_AnsibleEnvironment", $Environment)
    $ps.AddScript(@'
foreach ($env_kv in $_AnsibleEnvironment.GetEnumerator()) {
    [System.Environment]::SetEnvironmentVariable($env_kv.Key, $env_kv.Value)
}
'@).AddStatement() > $null
}

# import the PS modules
if ($Modules) {
    foreach ($module in $Modules.GetEnumerator()) {
        Write-AnsibleLog "INFO - create module util '$($module.Key)' for $ModuleName" "module_wrapper"
        $module_name = $module.Key
        $module_code = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($module.Value))
        $ps.AddCommand("New-Module").AddParameters(@{Name=$module_name; ScriptBlock=[ScriptBlock]::Create($module_code)}) > $null
        $ps.AddCommand("Import-Module").AddParameter("WarningAction", "SilentlyContinue") > $null
        $ps.AddCommand("Out-Null").AddStatement() > $null
    }
}

# redefine Write-Host to dump to output instead of failing
# lots of scripts still use it
$ps.AddScript('Function Write-Host($msg) { Write-Output -InputObject $msg }').AddStatement() > $null

# add the scripts and run
foreach ($script in $Scripts) {
    $ps.AddScript($script).AddStatement() > $null
}

if ($Breakpoints.Count -gt 0) {
    Write-AnsibleLog "INFO - adding breakpoint to runspace that will run the modules" "module_wrapper"
    if ($PSVersionTable.PSVersion.Major -eq 3) {
        # The SetBreakpoints method was only added in PowerShell v4+. We need to rely on a private method to
        # achieve the same functionality in this older PowerShell version. This should be removed once we drop
        # support for PowerShell v3.
        $set_method = $ps.Runspace.Debugger.GetType().GetMethod(
            'AddLineBreakpoint', [System.Reflection.BindingFlags]'Instance, NonPublic'
        )
        foreach ($b in $Breakpoints) {
            $set_method.Invoke($ps.Runspace.Debugger, [Object[]]@(,$b)) > $null
        }
    } else {
        $ps.Runspace.Debugger.SetBreakpoints($Breakpoints)
    }
}

Write-AnsibleLog "INFO - start module exec with Invoke() - $ModuleName" "module_wrapper"

# temporarily override the stdout stream and create our own in a StringBuilder
# we use this to ensure there's always an Out pipe and that we capture the
# output for things like async or psrp
$orig_out = [System.Console]::Out
$sb = New-Object -TypeName System.Text.StringBuilder
$new_out = New-Object -TypeName System.IO.StringWriter -ArgumentList $sb
try {
    [System.Console]::SetOut($new_out)
    $module_output = $ps.Invoke()
} catch {
    # uncaught exception while executing module, present a prettier error for
    # Ansible to parse
    $error_params = @{
        Message = "Unhandled exception while executing module"
        ErrorRecord = $_
    }

    # Be more defensive when trying to find the InnerException in case it isn't
    # set. This shouldn't ever be the case but if it is then it makes it more
    # difficult to track down the problem.
    if ($_.Exception.PSObject.Properties.Name -contains "InnerException") {
        $inner_exception = $_.Exception.InnerException
        if ($inner_exception.PSObject.Properties.Name -contains "ErrorRecord") {
            $error_params.ErrorRecord = $inner_exception.ErrorRecord
        }
    }

    Write-AnsibleError @error_params
    $host.SetShouldExit(1)
    return
} finally {
    [System.Console]::SetOut($orig_out)
    $new_out.Dispose()
}

# other types of errors may not throw an exception in Invoke but rather just
# set the pipeline state to failed
if ($ps.InvocationStateInfo.State -eq "Failed" -and $ModuleName -ne "script") {
    $reason = $ps.InvocationStateInfo.Reason
    $error_params = @{
        Message = "Unhandled exception while executing module"
    }

    # The error record should always be set on the reason but this does not
    # always happen on Server 2008 R2 for some reason (probably memory hotfix).
    # Be defensive when trying to get the error record and fall back to other
    # options.
    if ($null -eq $reason) {
        $error_params.Message += ": Unknown error"
    } elseif ($reason.PSObject.Properties.Name -contains "ErrorRecord") {
        $error_params.ErrorRecord = $reason.ErrorRecord
    } else {
        $error_params.Message += ": $($reason.ToString())"
    }

    Write-AnsibleError @error_params
    $host.SetShouldExit(1)
    return
}

Write-AnsibleLog "INFO - module exec ended $ModuleName" "module_wrapper"
$stdout = $sb.ToString()
if ($stdout) {
    Write-Output -InputObject $stdout
}
if ($module_output.Count -gt 0) {
    # do not output if empty collection
    Write-AnsibleLog "INFO - using the output stream for module output - $ModuleName" "module_wrapper"
    Write-Output -InputObject ($module_output -join "`r`n")
}

# we attempt to get the return code from the LASTEXITCODE variable
# this is set explicitly in newer style variables when calling
# ExitJson and FailJson. If set we set the current hosts' exit code
# to that same value
$rc = $ps.Runspace.SessionStateProxy.GetVariable("LASTEXITCODE")
if ($null -ne $rc) {
    Write-AnsibleLog "INFO - got an rc of $rc from $ModuleName exec" "module_wrapper"
    $host.SetShouldExit($rc)
}

# PS3 doesn't properly set HadErrors in many cases, inspect the error stream as a fallback
# with the trap handler that's now in place, this should only write to the output if
# $ErrorActionPreference != "Stop", that's ok because this is sent to the stderr output
# for a user to manually debug if something went horribly wrong
if ($ps.HadErrors -or ($PSVersionTable.PSVersion.Major -lt 4 -and $ps.Streams.Error.Count -gt 0)) {
    Write-AnsibleLog "WARN - module had errors, outputting error info $ModuleName" "module_wrapper"
    # if the rc wasn't explicitly set, we return an exit code of 1
    if ($null -eq $rc) {
        $host.SetShouldExit(1)
    }

    # output each error to the error stream of the current pipeline
    foreach ($err in $ps.Streams.Error) {
        $error_msg = Format-AnsibleException -ErrorRecord $err

        # need to use the current hosts's UI class as we may not have
        # a console to write the stderr to, e.g. psrp
        Write-AnsibleLog "WARN - error msg for for $($ModuleName):`r`n$error_msg" "module_wrapper"
        $host.UI.WriteErrorLine($error_msg)
    }
# (c) 2018 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

begin {
    $DebugPreference = "Continue"
    $ProgressPreference = "SilentlyContinue"
    $ErrorActionPreference = "Stop"
    Set-StrictMode -Version 2

    # common functions that are loaded in exec and module context, this is set
    # as a script scoped variable so async_watchdog and module_wrapper can
    # access the functions when creating their Runspaces
    $script:common_functions = {
        Function ConvertFrom-AnsibleJson {
            <#
            .SYNOPSIS
            Converts a JSON string to a Hashtable/Array in the fastest way
            possible. Unfortunately ConvertFrom-Json is still faster but outputs
            a PSCustomObject which is combersone for module consumption.

            .PARAMETER InputObject
            [String] The JSON string to deserialize.
            #>
            param(
                [Parameter(Mandatory=$true, Position=0)][String]$InputObject
            )

            # we can use -AsHashtable to get PowerShell to convert the JSON to
            # a Hashtable and not a PSCustomObject. This was added in PowerShell
            # 6.0, fall back to a manual conversion for older versions
            $cmdlet = Get-Command -Name ConvertFrom-Json -CommandType Cmdlet
            if ("AsHashtable" -in $cmdlet.Parameters.Keys) {
                return ,(ConvertFrom-Json -InputObject $InputObject -AsHashtable)
            } else {
                # get the PSCustomObject and then manually convert from there
                $raw_obj = ConvertFrom-Json -InputObject $InputObject

                Function ConvertTo-Hashtable {
                    param($InputObject)

                    if ($null -eq $InputObject) {
                        return $null
                    }

                    if ($InputObject -is [PSCustomObject]) {
                        $new_value = @{}
                        foreach ($prop in $InputObject.PSObject.Properties.GetEnumerator()) {
                            $new_value.($prop.Name) = (ConvertTo-Hashtable -InputObject $prop.Value)
                        }
                        return ,$new_value
                    } elseif ($InputObject -is [Array]) {
                        $new_value = [System.Collections.ArrayList]@()
                        foreach ($val in $InputObject) {
                            $new_value.Add((ConvertTo-Hashtable -InputObject $val)) > $null
                        }
                        return ,$new_value.ToArray()
                    } else {
                        return ,$InputObject
                    }
                }
                return ,(ConvertTo-Hashtable -InputObject $raw_obj)
            }
        }

        Function Format-AnsibleException {
            <#
            .SYNOPSIS
            Formats a PowerShell ErrorRecord to a string that's fit for human
            consumption.

            .NOTES
            Using Out-String can give us the first part of the exception but it
            also wraps the messages at 80 chars which is not ideal. We also
            append the ScriptStackTrace and the .NET StackTrace if present.
            #>
            param([System.Management.Automation.ErrorRecord]$ErrorRecord)

            $exception = @"
$($ErrorRecord.ToString())
$($ErrorRecord.InvocationInfo.PositionMessage)
    + CategoryInfo          : $($ErrorRecord.CategoryInfo.ToString())
    + FullyQualifiedErrorId : $($ErrorRecord.FullyQualifiedErrorId.ToString())
"@
            # module_common strip comments and empty newlines, need to manually
            # add a preceding newline using `r`n
            $exception += "`r`n`r`nScriptStackTrace:`r`n$($ErrorRecord.ScriptStackTrace)`r`n"

            # exceptions from C# will also have a StackTrace which we
            # append if found
            if ($null -ne $ErrorRecord.Exception.StackTrace) {
                $exception += "`r`n$($ErrorRecord.Exception.ToString())"
            }

            return $exception
        }
    }
    .$common_functions

    # common wrapper functions used in the exec wrappers, this is defined in a
    # script scoped variable so async_watchdog can pass them into the async job
    $script:wrapper_functions = {
        Function Write-AnsibleError {
            <#
            .SYNOPSIS
            Writes an error message to a JSON string in the format that Ansible
            understands. Also optionally adds an exception record if the
            ErrorRecord is passed through.
            #>
            param(
                [Parameter(Mandatory=$true)][String]$Message,
                [System.Management.Automation.ErrorRecord]$ErrorRecord = $null
            )
            $result = @{
                msg = $Message
                failed = $true
            }
            if ($null -ne $ErrorRecord) {
                $result.msg += ": $($ErrorRecord.Exception.Message)"
                $result.exception = (Format-AnsibleException -ErrorRecord $ErrorRecord)
            }
            Write-Output -InputObject (ConvertTo-Json -InputObject $result -Depth 99 -Compress)
        }

        Function Write-AnsibleLog {
            <#
            .SYNOPSIS
            Used as a debugging tool to log events to a file as they run in the
            exec wrappers. By default this is a noop function but the $log_path
            can be manually set to enable it. Manually set ANSIBLE_EXEC_DEBUG as
            an env value on the Windows host that this is run on to enable.
            #>
            param(
                [Parameter(Mandatory=$true, Position=0)][String]$Message,
                [Parameter(Position=1)][String]$Wrapper
            )

            $log_path = $env:ANSIBLE_EXEC_DEBUG
            if ($log_path) {
                $log_path = [System.Environment]::ExpandEnvironmentVariables($log_path)
                $parent_path = [System.IO.Path]::GetDirectoryName($log_path)
                if (Test-Path -LiteralPath $parent_path -PathType Container) {
                    $msg = "{0:u} - {1} - {2} - " -f (Get-Date), $pid, ([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)
                    if ($null -ne $Wrapper) {
                        $msg += "$Wrapper - "
                    }
                    $msg += $Message + "`r`n"
                    $msg_bytes = [System.Text.Encoding]::UTF8.GetBytes($msg)

                    $fs = [System.IO.File]::Open($log_path, [System.IO.FileMode]::Append,
                        [System.IO.FileAccess]::Write, [System.IO.FileShare]::ReadWrite)
                    try {
                        $fs.Write($msg_bytes, 0, $msg_bytes.Length)
                    } finally {
                        $fs.Close()
                    }
                }
            }
        }
    }
    .$wrapper_functions

    # only init and stream in $json_raw if it wasn't set by the enclosing scope
    if (-not $(Get-Variable "json_raw" -ErrorAction SilentlyContinue)) {
        $json_raw = ''
    }
} process {
    $json_raw += [String]$input
} end {
    Write-AnsibleLog "INFO - starting exec_wrapper" "exec_wrapper"
    if (-not $json_raw) {
        Write-AnsibleError -Message "internal error: no input given to PowerShell exec wrapper"
        exit 1
    }

    Write-AnsibleLog "INFO - converting json raw to a payload" "exec_wrapper"
    $payload = ConvertFrom-AnsibleJson -InputObject $json_raw

    # TODO: handle binary modules
    # TODO: handle persistence

    if ($payload.min_os_version) {
        $min_os_version = [Version]$payload.min_os_version
        # Environment.OSVersion.Version is deprecated and may not return the
        # right version
        $actual_os_version = [Version](Get-Item -Path $env:SystemRoot\System32\kernel32.dll).VersionInfo.ProductVersion

        Write-AnsibleLog "INFO - checking if actual os version '$actual_os_version' is less than the min os version '$min_os_version'" "exec_wrapper"
        if ($actual_os_version -lt $min_os_version) {
            Write-AnsibleError -Message "internal error: This module cannot run on this OS as it requires a minimum version of $min_os_version, actual was $actual_os_version"
            exit 1
        }
    }
    if ($payload.min_ps_version) {
        $min_ps_version = [Version]$payload.min_ps_version
        $actual_ps_version = $PSVersionTable.PSVersion

        Write-AnsibleLog "INFO - checking if actual PS version '$actual_ps_version' is less than the min PS version '$min_ps_version'" "exec_wrapper"
        if ($actual_ps_version -lt $min_ps_version) {
            Write-AnsibleError -Message "internal error: This module cannot run as it requires a minimum PowerShell version of $min_ps_version, actual was $actual_ps_version"
            exit 1
        }
    }

    # pop 0th action as entrypoint
    $action = $payload.actions[0]
    Write-AnsibleLog "INFO - running action $action" "exec_wrapper"

    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($payload.($action)))
    $entrypoint = [ScriptBlock]::Create($entrypoint)
    # so we preserve the formatting and don't fall prey to locale issues, some
    # wrappers want the output to be in base64 form, we store the value here in
    # case the wrapper changes the value when they create a payload for their
    # own exec_wrapper
    $encoded_output = $payload.encoded_output

    try {
        $output = &$entrypoint -Payload $payload
        if ($encoded_output -and $null -ne $output) {
            $b64_output = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($output))
            Write-Output -InputObject $b64_output
        } else {
            $output
        }
    } catch {
        Write-AnsibleError -Message "internal error: failed to run exec_wrapper action $action" -ErrorRecord $_
# (c) 2018 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

param(
    [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Payload
)

#AnsibleRequires -Wrapper module_wrapper

$ErrorActionPreference = "Stop"

Write-AnsibleLog "INFO - starting module_powershell_wrapper" "module_powershell_wrapper"

$module_name = $Payload.module_args["_ansible_module_name"]
Write-AnsibleLog "INFO - building module payload for '$module_name'" "module_powershell_wrapper"

# compile any C# module utils passed in from the controller, Add-CSharpType is
# automatically added to the payload manifest if any csharp util is set
$csharp_utils = [System.Collections.ArrayList]@()
foreach ($csharp_util in $Payload.csharp_utils_module) {
    Write-AnsibleLog "INFO - adding $csharp_util to list of C# references to compile" "module_powershell_wrapper"
    $util_code = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.csharp_utils[$csharp_util]))
    $csharp_utils.Add($util_code) > $null
}
if ($csharp_utils.Count -gt 0) {
    $add_type_b64 = $Payload.powershell_modules["Ansible.ModuleUtils.AddType"]
    $add_type = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($add_type_b64))
    New-Module -Name Ansible.ModuleUtils.AddType -ScriptBlock ([ScriptBlock]::Create($add_type)) | Import-Module > $null

    # add any C# references so the module does not have to do so
    $new_tmp = [System.Environment]::ExpandEnvironmentVariables($Payload.module_args["_ansible_remote_tmp"])
    Add-CSharpType -References $csharp_utils -TempPath $new_tmp -IncludeDebugInfo
}

if ($Payload.ContainsKey("coverage") -and $null -ne $host.Runspace -and $null -ne $host.Runspace.Debugger) {
    $entrypoint = $payload.coverage_wrapper

    $params = @{
        Payload = $Payload
    }
} else {
    # get the common module_wrapper code and invoke that to run the module
    $module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.module_entry))
    $variables = [System.Collections.ArrayList]@(@{ Name = "complex_args"; Value = $Payload.module_args; Scope = "Global" })
    $entrypoint = $Payload.module_wrapper

    $params = @{
        Scripts = @($script:common_functions, $module)
        Variables = $variables
        Environment = $Payload.environment
        Modules = $Payload.powershell_modules
        ModuleName = $module_name
    }
}

$entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))
$entrypoint = [ScriptBlock]::Create($entrypoint)

try {
    &$entrypoint @params
} catch {
    # failed to invoke the PowerShell module, capture the exception and
    # output a pretty error for Ansible to parse
    $result = @{
        msg = "Failed to invoke PowerShell module: $($_.Exception.Message)"
        failed = $true
        exception = (Format-AnsibleException -ErrorRecord $_)
    }
    Write-Output -InputObject (ConvertTo-Json -InputObject $result -Depth 99 -Compress)
    $host.SetShouldExit(1)
# (c) 2018 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

param(
    [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Payload
)

# help with debugging errors as we don't have visibility of this running process
trap {
    $watchdog_path = "$($env:TEMP)\ansible-async-watchdog-error-$(Get-Date -Format "yyyy-MM-ddTHH-mm-ss.ffffZ").txt"
    $error_msg = "Error while running the async exec wrapper`r`n$(Format-AnsibleException -ErrorRecord $_)"
    Set-Content -Path $watchdog_path -Value $error_msg
    break
}

$ErrorActionPreference = "Stop"

Write-AnsibleLog "INFO - starting async_watchdog" "async_watchdog"

# pop 0th action as entrypoint
$payload.actions = $payload.actions[1..99]

$actions = $Payload.actions
$entrypoint = $payload.($actions[0])
$entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))

$resultfile_path = $payload.async_results_path
$max_exec_time_sec = $payload.async_timeout_sec

Write-AnsibleLog "INFO - deserializing existing result file args at: '$resultfile_path'" "async_watchdog"
if (-not (Test-Path -Path $resultfile_path)) {
    $msg = "result file at '$resultfile_path' does not exist"
    Write-AnsibleLog "ERROR - $msg" "async_watchdog"
    throw $msg
}
$result_json = Get-Content -Path $resultfile_path -Raw
Write-AnsibleLog "INFO - result file json is: $result_json" "async_watchdog"
$result = ConvertFrom-AnsibleJson -InputObject $result_json

Write-AnsibleLog "INFO - creating async runspace" "async_watchdog"
$rs = [RunspaceFactory]::CreateRunspace()
$rs.Open()

Write-AnsibleLog "INFO - creating async PowerShell pipeline" "async_watchdog"
$ps = [PowerShell]::Create()
$ps.Runspace = $rs

# these functions are set in exec_wrapper
Write-AnsibleLog "INFO - adding global functions to PowerShell pipeline script" "async_watchdog"
$ps.AddScript($script:common_functions).AddStatement() > $null
$ps.AddScript($script:wrapper_functions).AddStatement() > $null
$ps.AddCommand("Set-Variable").AddParameters(@{Name="common_functions"; Value=$script:common_functions; Scope="script"}).AddStatement() > $null

Write-AnsibleLog "INFO - adding $($actions[0]) to PowerShell pipeline script" "async_watchdog"
$ps.AddScript($entrypoint).AddArgument($payload) > $null

Write-AnsibleLog "INFO - async job start, calling BeginInvoke()" "async_watchdog"
$job_async_result = $ps.BeginInvoke()

Write-AnsibleLog "INFO - waiting '$max_exec_time_sec' seconds for async job to complete" "async_watchdog"
$job_async_result.AsyncWaitHandle.WaitOne($max_exec_time_sec * 1000) > $null
$result.finished = 1

if ($job_async_result.IsCompleted) {
    Write-AnsibleLog "INFO - async job completed, calling EndInvoke()" "async_watchdog"

    $job_output = $ps.EndInvoke($job_async_result)
    $job_error = $ps.Streams.Error

    Write-AnsibleLog "INFO - raw module stdout:`r`n$($job_output | Out-String)" "async_watchdog"
    if ($job_error) {
        Write-AnsibleLog "WARN - raw module stderr:`r`n$($job_error | Out-String)" "async_watchdog"
    }

    # write success/output/error to result object
    # TODO: cleanse leading/trailing junk
    try {
        Write-AnsibleLog "INFO - deserializing Ansible stdout" "async_watchdog"
        $module_result = ConvertFrom-AnsibleJson -InputObject $job_output
        # TODO: check for conflicting keys
        $result = $result + $module_result
    } catch {
        $result.failed = $true
        $result.msg = "failed to parse module output: $($_.Exception.Message)"
        # return output back to Ansible to help with debugging errors
        $result.stdout = $job_output | Out-String
        $result.stderr = $job_error | Out-String
    }

    $result_json = ConvertTo-Json -InputObject $result -Depth 99 -Compress
    Set-Content -Path $resultfile_path -Value $result_json

    Write-AnsibleLog "INFO - wrote output to $resultfile_path" "async_watchdog"
} else {
    Write-AnsibleLog "ERROR - reached timeout on async job, stopping job" "async_watchdog"
    $ps.BeginStop($null, $null)  > $null # best effort stop

    # write timeout to result object
    $result.failed = $true
    $result.msg = "timed out waiting for module completion"
    $result_json = ConvertTo-Json -InputObject $result -Depth 99 -Compress
    Set-Content -Path $resultfile_path -Value $result_json

    Write-AnsibleLog "INFO - wrote timeout to '$resultfile_path'" "async_watchdog"
}
&chcp.com 65001 > $null

if ($PSVersionTable.PSVersion -lt [Version]"3.0") {
    '{"failed":true,"msg":"Ansible requires PowerShell v3.0 or newer"}'
    exit 1
}

$exec_wrapper_str = $input | Out-String
$split_parts = $exec_wrapper_str.Split(@("`0`0`0`0"), 2, [StringSplitOptions]::RemoveEmptyEntries)
If (-not $split_parts.Length -eq 2) { throw "invalid payload" }
# (c) 2018 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

param(
    [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Payload
)

#AnsibleRequires -Wrapper module_wrapper

$ErrorActionPreference = "Stop"

Write-AnsibleLog "INFO - starting module_script_wrapper" "module_script_wrapper"

$script = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.module_entry))

# get the common module_wrapper code and invoke that to run the module
$entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($payload.module_wrapper))
$entrypoint = [ScriptBlock]::Create($entrypoint)

&$entrypoint -Scripts $script -Environment $Payload.environment -ModuleName "script"
# (c) 2019 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

param(
    [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Payload
)

#AnsibleRequires -Wrapper module_wrapper

$ErrorActionPreference = "Stop"

Write-AnsibleLog "INFO - starting coverage_wrapper" "coverage_wrapper"

# Required to be set for psrp to we can set a breakpoint in the remote runspace
if ($PSVersionTable.PSVersion -ge [Version]'4.0') {
    $host.Runspace.Debugger.SetDebugMode([System.Management.Automation.DebugModes]::RemoteScript)
}

Function New-CoverageBreakpoint {
    Param (
        [String]$Path,
        [ScriptBlock]$Code,
        [String]$AnsiblePath
    )

    # It is quicker to pass in the code as a string instead of calling ParseFile as we already know the contents
    $predicate = {
        $args[0] -is [System.Management.Automation.Language.CommandBaseAst]
    }
    $script_cmds = $Code.Ast.FindAll($predicate, $true)

    # Create an object that tracks the Ansible path of the file and the breakpoints that have been set in it
    $info = [PSCustomObject]@{
        Path = $AnsiblePath
        Breakpoints = [System.Collections.Generic.List`1[System.Management.Automation.Breakpoint]]@()
    }

    # Keep track of lines that are already scanned. PowerShell can contains multiple commands in 1 line
    $scanned_lines = [System.Collections.Generic.HashSet`1[System.Int32]]@()
    foreach ($cmd in $script_cmds) {
        if (-not $scanned_lines.Add($cmd.Extent.StartLineNumber)) {
            continue
        }

        # Do not add any -Action value, even if it is $null or {}. Doing so will balloon the runtime.
        $params = @{
            Script = $Path
            Line = $cmd.Extent.StartLineNumber
            Column = $cmd.Extent.StartColumnNumber
        }
        $info.Breakpoints.Add((Set-PSBreakpoint @params))
    }

    $info
}

Function Compare-PathFilterPattern {
    Param (
        [String[]]$Patterns,
        [String]$Path
    )

    foreach ($pattern in $Patterns) {
        if ($Path -like $pattern) {
            return $true
        }
    }
    return $false
}

$module_name = $Payload.module_args["_ansible_module_name"]
Write-AnsibleLog "INFO - building coverage payload for '$module_name'" "coverage_wrapper"

# A PS Breakpoint needs an actual path to work properly, we create a temp directory that will store the module and
# module_util code during execution
$temp_path = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath "ansible-coverage-$([System.IO.Path]::GetRandomFileName())"
Write-AnsibleLog "INFO - Creating temp path for coverage files '$temp_path'" "coverage_wrapper"
New-Item -Path $temp_path -ItemType Directory > $null
$breakpoint_info = [System.Collections.Generic.List`1[PSObject]]@()

# Ensures we create files with UTF-8 encoding and a BOM. This is critical to force the powershell engine to read files
# as UTF-8 and not as the system's codepage.
$file_encoding = 'UTF8'

try {
    $scripts = [System.Collections.Generic.List`1[System.Object]]@($script:common_functions)

    $coverage_path_filter = $Payload.coverage.path_filter.Split(":", [StringSplitOptions]::RemoveEmptyEntries)

    # We need to track what utils have already been added to the script for loading. This is because the load
    # order is important and can have module_utils that rely on other utils.
    $loaded_utils = [System.Collections.Generic.HashSet`1[System.String]]@()
    $parse_util = {
        $util_name = $args[0]
        if (-not $loaded_utils.Add($util_name)) {
            return
        }

        $util_code = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.powershell_modules.$util_name))
        $util_sb = [ScriptBlock]::Create($util_code)
        $util_path = Join-Path -Path $temp_path -ChildPath "$($util_name).psm1"

        Write-AnsibleLog "INFO - Outputting module_util $util_name to temp file '$util_path'" "coverage_wrapper"
        Set-Content -LiteralPath $util_path -Value $util_code -Encoding $file_encoding

        $ansible_path = $Payload.coverage.module_util_paths.$util_name
        if ((Compare-PathFilterPattern -Patterns $coverage_path_filter -Path $ansible_path)) {
            $cov_params = @{
                Path = $util_path
                Code = $util_sb
                AnsiblePath = $ansible_path
            }
            $breakpoints = New-CoverageBreakpoint @cov_params
            $breakpoint_info.Add($breakpoints)
        }

        if ($null -ne $util_sb.Ast.ScriptRequirements) {
            foreach ($required_util in $util_sb.Ast.ScriptRequirements.RequiredModules) {
                &$parse_util $required_util.Name
            }
        }
        Write-AnsibleLog "INFO - Adding util $util_name to scripts to run" "coverage_wrapper"
        $scripts.Add("Import-Module -Name '$util_path'")
    }
    foreach ($util in $Payload.powershell_modules.Keys) {
        &$parse_util $util
    }

    $module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.module_entry))
    $module_path = Join-Path -Path $temp_path -ChildPath "$($module_name).ps1"
    Write-AnsibleLog "INFO - Ouputting module $module_name to temp file '$module_path'" "coverage_wrapper"
    Set-Content -LiteralPath $module_path -Value $module -Encoding $file_encoding
    $scripts.Add($module_path)

    $ansible_path = $Payload.coverage.module_path
    if ((Compare-PathFilterPattern -Patterns $coverage_path_filter -Path $ansible_path)) {
        $cov_params = @{
            Path = $module_path
            Code = [ScriptBlock]::Create($module)
            AnsiblePath = $Payload.coverage.module_path
        }
        $breakpoints = New-CoverageBreakpoint @cov_params
        $breakpoint_info.Add($breakpoints)
    }

    $variables = [System.Collections.ArrayList]@(@{ Name = "complex_args"; Value = $Payload.module_args; Scope = "Global" })
    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($payload.module_wrapper))
    $entrypoint = [ScriptBlock]::Create($entrypoint)

    $params = @{
        Scripts = $scripts
        Variables = $variables
        Environment = $Payload.environment
        ModuleName = $module_name
    }
    if ($breakpoint_info) {
        $params.Breakpoints = $breakpoint_info.Breakpoints
    }

    try {
        &$entrypoint @params
    } finally {
        # Processing here is kept to an absolute minimum to make sure each task runtime is kept as small as
        # possible. Once all the tests have been run ansible-test will collect this info and process it locally in
        # one go.
        Write-AnsibleLog "INFO - Creating coverage result output" "coverage_wrapper"
        $coverage_info = @{}
        foreach ($info in $breakpoint_info) {
            $coverage_info.($info.Path) = $info.Breakpoints | Select-Object -Property Line, HitCount
        }

        # The coverage.output value is a filename set by the Ansible controller. We append some more remote side
        # info to the filename to make it unique and identify the remote host a bit more.
        $ps_version = "$($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor)"
        $coverage_output_path = "$($Payload.coverage.output)=powershell-$ps_version=coverage.$($env:COMPUTERNAME).$PID.$(Get-Random)"
        $code_cov_json = ConvertTo-Json -InputObject $coverage_info -Compress

        Write-AnsibleLog "INFO - Outputting coverage json to '$coverage_output_path'" "coverage_wrapper"
        # Ansible controller expects these files to be UTF-8 without a BOM, use .NET for this.
        $utf8_no_bom = New-Object -TypeName System.Text.UTF8Encoding -ArgumentList $false
        [System.IO.File]::WriteAllbytes($coverage_output_path, $utf8_no_bom.GetBytes($code_cov_json))
    }
} finally {
    try {
        if ($breakpoint_info) {
            foreach ($b in $breakpoint_info.Breakpoints) {
                Remove-PSBreakpoint -Breakpoint $b
            }
        }
    } finally {
        Write-AnsibleLog "INFO - Remove temp coverage folder '$temp_path'" "coverage_wrapper"
        Remove-Item -LiteralPath $temp_path -Force -Recurse
    }
}

# (c) 2018 Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

param(
    [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Payload
)

$ErrorActionPreference = "Stop"

Write-AnsibleLog "INFO - starting async_wrapper" "async_wrapper"

if (-not $Payload.environment.ContainsKey("ANSIBLE_ASYNC_DIR")) {
    Write-AnsibleError -Message "internal error: the environment variable ANSIBLE_ASYNC_DIR is not set and is required for an async task"
    $host.SetShouldExit(1)
    return
}
$async_dir = [System.Environment]::ExpandEnvironmentVariables($Payload.environment.ANSIBLE_ASYNC_DIR)

# calculate the result path so we can include it in the worker payload
$jid = $Payload.async_jid
$local_jid = $jid + "." + $pid

$results_path = [System.IO.Path]::Combine($async_dir, $local_jid)

Write-AnsibleLog "INFO - creating async results path at '$results_path'" "async_wrapper"

$Payload.async_results_path = $results_path
[System.IO.Directory]::CreateDirectory([System.IO.Path]::GetDirectoryName($results_path)) > $null

# we use Win32_Process to escape the current process job, CreateProcess with a
# breakaway flag won't work for psrp as the psrp process does not have breakaway
# rights. Unfortunately we can't read/write to the spawned process as we can't
# inherit the handles. We use a locked down named pipe to send the exec_wrapper
# payload. Anonymous pipes won't work as the spawned process will not be a child
# of the current one and will not be able to inherit the handles

# pop the async_wrapper action so we don't get stuck in a loop and create new
# exec_wrapper for our async process
$Payload.actions = $Payload.actions[1..99]
$payload_json = ConvertTo-Json -InputObject $Payload -Depth 99 -Compress

#
$exec_wrapper = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Payload.exec_wrapper))
$exec_wrapper += "`0`0`0`0" + $payload_json
$payload_bytes = [System.Text.Encoding]::UTF8.GetBytes($exec_wrapper)
$pipe_name = "ansible-async-$jid-$([guid]::NewGuid())"

# template the async process command line with the payload details
$bootstrap_wrapper = {
    # help with debugging errors as we loose visibility of the process output
    # from here on
    trap {
        $wrapper_path = "$($env:TEMP)\ansible-async-wrapper-error-$(Get-Date -Format "yyyy-MM-ddTHH-mm-ss.ffffZ").txt"
        $error_msg = "Error while running the async exec wrapper`r`n$($_ | Out-String)`r`n$($_.ScriptStackTrace)"
        Set-Content -Path $wrapper_path -Value $error_msg
        break
    }

    &chcp.com 65001 > $null

    # store the pipe name and no. of bytes to read, these are populated before
    # before the process is created - do not remove or changed
    $pipe_name = ""
    $bytes_length = 0

    $input_bytes = New-Object -TypeName byte[] -ArgumentList $bytes_length
    $pipe = New-Object -TypeName System.IO.Pipes.NamedPipeClientStream -ArgumentList @(
        ".",  # localhost
        $pipe_name,
        [System.IO.Pipes.PipeDirection]::In,
        [System.IO.Pipes.PipeOptions]::None,
        [System.Security.Principal.TokenImpersonationLevel]::Anonymous
    )
    try {
        $pipe.Connect()
        $pipe.Read($input_bytes, 0, $bytes_length) > $null
    } finally {
        $pipe.Close()
    }
    $exec = [System.Text.Encoding]::UTF8.GetString($input_bytes)
    $exec_parts = $exec.Split(@("`0`0`0`0"), 2, [StringSplitOptions]::RemoveEmptyEntries)
    Set-Variable -Name json_raw -Value $exec_parts[1]
    $exec = [ScriptBlock]::Create($exec_parts[0])
    &$exec
}

$bootstrap_wrapper = $bootstrap_wrapper.ToString().Replace('$pipe_name = ""', "`$pipe_name = `"$pipe_name`"")
$bootstrap_wrapper = $bootstrap_wrapper.Replace('$bytes_length = 0', "`$bytes_length = $($payload_bytes.Count)")
$encoded_command = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($bootstrap_wrapper))
$pwsh_path = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
$exec_args = "`"$pwsh_path`" -NonInteractive -NoProfile -ExecutionPolicy Bypass -EncodedCommand $encoded_command"

# create a named pipe that is set to allow only the current user read access
$current_user = ([Security.Principal.WindowsIdentity]::GetCurrent()).User
$pipe_sec = New-Object -TypeName System.IO.Pipes.PipeSecurity
$pipe_ar = New-Object -TypeName System.IO.Pipes.PipeAccessRule -ArgumentList @(
    $current_user,
    [System.IO.Pipes.PipeAccessRights]::Read,
    [System.Security.AccessControl.AccessControlType]::Allow
)
$pipe_sec.AddAccessRule($pipe_ar)

Write-AnsibleLog "INFO - creating named pipe '$pipe_name'" "async_wrapper"
$pipe = New-Object -TypeName System.IO.Pipes.NamedPipeServerStream -ArgumentList @(
    $pipe_name,
    [System.IO.Pipes.PipeDirection]::Out,
    1,
    [System.IO.Pipes.PipeTransmissionMode]::Byte,
    [System.IO.Pipes.PipeOptions]::Asynchronous,
    0,
    0,
    $pipe_sec
)

try {
    Write-AnsibleLog "INFO - creating async process '$exec_args'" "async_wrapper"
    $process = Invoke-CimMethod -ClassName Win32_Process -Name Create -Arguments @{CommandLine=$exec_args}
    $rc = $process.ReturnValue

    Write-AnsibleLog "INFO - return value from async process exec: $rc" "async_wrapper"
    if ($rc -ne 0) {
        $error_msg = switch($rc) {
            2 { "Access denied" }
            3 { "Insufficient privilege" }
            8 { "Unknown failure" }
            9 { "Path not found" }
            21 { "Invalid parameter" }
            default { "Other" }
        }
        throw "Failed to start async process: $rc ($error_msg)"
    }
    $watchdog_pid = $process.ProcessId
    Write-AnsibleLog "INFO - created async process PID: $watchdog_pid" "async_wrapper"

    # populate initial results before we send the async data to avoid result race
    $result = @{
        started = 1;
        finished = 0;
        results_file = $results_path;
        ansible_job_id = $local_jid;
        _ansible_suppress_tmpdir_delete = $true;
        ansible_async_watchdog_pid = $watchdog_pid
    }

    Write-AnsibleLog "INFO - writing initial async results to '$results_path'" "async_wrapper"
    $result_json = ConvertTo-Json -InputObject $result -Depth 99 -Compress
    Set-Content $results_path -Value $result_json

    $np_timeout = $Payload.async_startup_timeout * 1000
    Write-AnsibleLog "INFO - waiting for async process to connect to named pipe for $np_timeout milliseconds" "async_wrapper"
    $wait_async = $pipe.BeginWaitForConnection($null, $null)
    $wait_async.AsyncWaitHandle.WaitOne($np_timeout) > $null
    if (-not $wait_async.IsCompleted) {
        $msg = "Ansible encountered a timeout while waiting for the async task to start and connect to the named"
        $msg += "pipe. This can be affected by the performance of the target - you can increase this timeout using"
        $msg += "WIN_ASYNC_STARTUP_TIMEOUT or just for this host using the win_async_startup_timeout hostvar if "
        $msg += "this keeps happening."
        throw $msg
    }
    $pipe.EndWaitForConnection($wait_async)

    Write-AnsibleLog "INFO - writing exec_wrapper and payload to async process" "async_wrapper"
    $pipe.Write($payload_bytes, 0, $payload_bytes.Count)
    $pipe.Flush()
    $pipe.WaitForPipeDrain()
} finally {
    $pipe.Close()
}

Write-AnsibleLog "INFO - outputting initial async result: $result_json" "async_wrapper"
# Copyright (c) 2019 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

Function Get-AnsibleWebRequest {
    <#
    .SYNOPSIS
    Creates a System.Net.WebRequest object based on common URL module options in Ansible.

    .DESCRIPTION
    Will create a WebRequest based on common input options within Ansible. This can be used manually or with
    Invoke-WithWebRequest.

    .PARAMETER Uri
    The URI to create the web request for.

    .PARAMETER Method
    The protocol method to use, if omitted, will use the default value for the URI protocol specified.

    .PARAMETER FollowRedirects
    Whether to follow redirect reponses. This is only valid when using a HTTP URI.
        all - Will follow all redirects
        none - Will follow no redirects
        safe - Will only follow redirects when GET or HEAD is used as the Method

    .PARAMETER Headers
    A hashtable or dictionary of header values to set on the request. This is only valid for a HTTP URI.

    .PARAMETER HttpAgent
    A string to set for the 'User-Agent' header. This is only valid for a HTTP URI.

    .PARAMETER MaximumRedirection
    The maximum number of redirections that will be followed. This is only valid for a HTTP URI.

    .PARAMETER Timeout
    The timeout in seconds that defines how long to wait until the request times out.

    .PARAMETER ValidateCerts
    Whether to validate SSL certificates, default to True.

    .PARAMETER ClientCert
    The path to PFX file to use for X509 authentication. This is only valid for a HTTP URI. This path can either
    be a filesystem path (C:\folder\cert.pfx) or a PSPath to a credential (Cert:\CurrentUser\My\<thumbprint>).

    .PARAMETER ClientCertPassword
    The password for the PFX certificate if required. This is only valid for a HTTP URI.

    .PARAMETER ForceBasicAuth
    Whether to set the Basic auth header on the first request instead of when required. This is only valid for a
    HTTP URI.

    .PARAMETER UrlUsername
    The username to use for authenticating with the target.

    .PARAMETER UrlPassword
    The password to use for authenticating with the target.

    .PARAMETER UseDefaultCredential
    Whether to use the current user's credentials if available. This will only work when using Become, using SSH with
    password auth, or WinRM with CredSSP or Kerberos with credential delegation.

    .PARAMETER UseProxy
    Whether to use the default proxy defined in IE (WinINet) for the user or set no proxy at all. This should not
    be set to True when ProxyUrl is also defined.

    .PARAMETER ProxyUrl
    An explicit proxy server to use for the request instead of relying on the default proxy in IE. This is only
    valid for a HTTP URI.

    .PARAMETER ProxyUsername
    An optional username to use for proxy authentication.

    .PARAMETER ProxyPassword
    The password for ProxyUsername.

    .PARAMETER ProxyUseDefaultCredential
    Whether to use the current user's credentials for proxy authentication if available. This will only work when
    using Become, using SSH with password auth, or WinRM with CredSSP or Kerberos with credential delegation.

    .PARAMETER Module
    The AnsibleBasic module that can be used as a backup parameter source or a way to return warnings back to the
    Ansible controller.

    .EXAMPLE
    $spec = @{
        options = @{}
    }
    $module = Ansible.Basic.AnsibleModule]::Create($args, $spec, @(Get-AnsibleWebRequestSpec))

    $web_request = Get-AnsibleWebRequest -Module $module
    #>
    [CmdletBinding()]
    [OutputType([System.Net.WebRequest])]
    Param (
        [Alias("url")]
        [System.Uri]
        $Uri,

        [System.String]
        $Method,

        [Alias("follow_redirects")]
        [ValidateSet("all", "none", "safe")]
        [System.String]
        $FollowRedirects = "safe",

        [System.Collections.IDictionary]
        $Headers,

        [Alias("http_agent")]
        [System.String]
        $HttpAgent = "ansible-httpget",

        [Alias("maximum_redirection")]
        [System.Int32]
        $MaximumRedirection = 50,

        [System.Int32]
        $Timeout = 30,

        [Alias("validate_certs")]
        [System.Boolean]
        $ValidateCerts = $true,

        # Credential params
        [Alias("client_cert")]
        [System.String]
        $ClientCert,

        [Alias("client_cert_password")]
        [System.String]
        $ClientCertPassword,

        [Alias("force_basic_auth")]
        [Switch]
        $ForceBasicAuth,

        [Alias("url_username")]
        [System.String]
        $UrlUsername,

        [Alias("url_password")]
        [System.String]
        $UrlPassword,

        [Alias("use_default_credential")]
        [Switch]
        $UseDefaultCredential,

        # Proxy params
        [Alias("use_proxy")]
        [System.Boolean]
        $UseProxy = $true,

        [Alias("proxy_url")]
        [System.String]
        $ProxyUrl,

        [Alias("proxy_username")]
        [System.String]
        $ProxyUsername,

        [Alias("proxy_password")]
        [System.String]
        $ProxyPassword,

        [Alias("proxy_use_default_credential")]
        [Switch]
        $ProxyUseDefaultCredential,

        [ValidateScript({ $_.GetType().FullName -eq 'Ansible.Basic.AnsibleModule' })]
        [System.Object]
        $Module
    )

    # Set module options for parameters unless they were explicitly passed in.
    if ($Module) {
        foreach ($param in $PSCmdlet.MyInvocation.MyCommand.Parameters.GetEnumerator()) {
            if ($PSBoundParameters.ContainsKey($param.Key)) {
                # Was set explicitly we want to use that value
                continue
            }

            foreach ($alias in @($Param.Key) + $param.Value.Aliases) {
                if ($Module.Params.ContainsKey($alias)) {
                    $var_value = $Module.Params.$alias -as $param.Value.ParameterType
                    Set-Variable -Name $param.Key -Value $var_value
                    break
                }
            }
        }
    }

    # Disable certificate validation if requested
    # FUTURE: set this on ServerCertificateValidationCallback of the HttpWebRequest once .NET 4.5 is the minimum
    if (-not $ValidateCerts) {
        [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
    }

    # Enable TLS1.1/TLS1.2 if they're available but disabled (eg. .NET 4.5)
    $security_protocols = [System.Net.ServicePointManager]::SecurityProtocol -bor [System.Net.SecurityProtocolType]::SystemDefault
    if ([System.Net.SecurityProtocolType].GetMember("Tls11").Count -gt 0) {
        $security_protocols = $security_protocols -bor [System.Net.SecurityProtocolType]::Tls11
    }
    if ([System.Net.SecurityProtocolType].GetMember("Tls12").Count -gt 0) {
        $security_protocols = $security_protocols -bor [System.Net.SecurityProtocolType]::Tls12
    }
    [System.Net.ServicePointManager]::SecurityProtocol = $security_protocols

    $web_request = [System.Net.WebRequest]::Create($Uri)
    if ($Method) {
        $web_request.Method = $Method
    }
    $web_request.Timeout = $Timeout * 1000

    if ($UseDefaultCredential -and $web_request -is [System.Net.HttpWebRequest]) {
        $web_request.UseDefaultCredentials = $true
    } elseif ($UrlUsername) {
        if ($ForceBasicAuth) {
            $auth_value = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $UrlUsername, $UrlPassword)))
            $web_request.Headers.Add("Authorization", "Basic $auth_value")
        } else {
            $credential = New-Object -TypeName System.Net.NetworkCredential -ArgumentList $UrlUsername, $UrlPassword
            $web_request.Credentials = $credential
        }
    }

    if ($ClientCert) {
        # Expecting either a filepath or PSPath (Cert:\CurrentUser\My\<thumbprint>)
        $cert = Get-Item -LiteralPath $ClientCert -ErrorAction SilentlyContinue
        if ($null -eq $cert) {
            Write-Error -Message "Client certificate '$ClientCert' does not exist" -Category ObjectNotFound
            return
        }

        $crypto_ns = 'System.Security.Cryptography.X509Certificates'
        if ($cert.PSProvider.Name -ne 'Certificate') {
            try {
                $cert = New-Object -TypeName "$crypto_ns.X509Certificate2" -ArgumentList @(
                    $ClientCert, $ClientCertPassword
                )
            } catch [System.Security.Cryptography.CryptographicException] {
                Write-Error -Message "Failed to read client certificate at '$ClientCert'" -Exception $_.Exception -Category SecurityError
                return
            }
        }
        $web_request.ClientCertificates = New-Object -TypeName "$crypto_ns.X509Certificate2Collection" -ArgumentList @(
            $cert
        )
    }

    if (-not $UseProxy) {
        $proxy = $null
    } elseif ($ProxyUrl) {
        $proxy = New-Object -TypeName System.Net.WebProxy -ArgumentList $ProxyUrl, $true
    } else  {
        $proxy = $web_request.Proxy
    }

    # $web_request.Proxy may return $null for a FTP web request. We only set the credentials if we have an actual
    # proxy to work with, otherwise just ignore the credentials property.
    if ($null -ne $proxy) {
        if ($ProxyUseDefaultCredential) {
            # Weird hack, $web_request.Proxy returns an IWebProxy object which only gurantees the Credentials
            # property. We cannot set UseDefaultCredentials so we just set the Credentials to the
            # DefaultCredentials in the CredentialCache which does the same thing.
            $proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials
        } elseif ($ProxyUsername) {
            $proxy.Credentials = New-Object -TypeName System.Net.NetworkCredential -ArgumentList @(
                $ProxyUsername, $ProxyPassword
            )
        } else {
            $proxy.Credentials = $null
        }
    }

    $web_request.Proxy = $proxy

    # Some parameters only apply when dealing with a HttpWebRequest
    if ($web_request -is [System.Net.HttpWebRequest]) {
        if ($Headers) {
            foreach ($header in $Headers.GetEnumerator()) {
                switch ($header.Key) {
                    Accept { $web_request.Accept = $header.Value }
                    Connection { $web_request.Connection = $header.Value }
                    Content-Length { $web_request.ContentLength = $header.Value }
                    Content-Type { $web_request.ContentType = $header.Value }
                    Expect { $web_request.Expect = $header.Value }
                    Date { $web_request.Date = $header.Value }
                    Host { $web_request.Host = $header.Value }
                    If-Modified-Since { $web_request.IfModifiedSince = $header.Value }
                    Range { $web_request.AddRange($header.Value) }
                    Referer { $web_request.Referer = $header.Value }
                    Transfer-Encoding {
                        $web_request.SendChunked = $true
                        $web_request.TransferEncoding = $header.Value
                    }
                    User-Agent { continue }
                    default { $web_request.Headers.Add($header.Key, $header.Value) }
                }
            }
        }

        # For backwards compatibility we need to support setting the User-Agent if the header was set in the task.
        # We just need to make sure that if an explicit http_agent module was set then that takes priority.
        if ($Headers -and $Headers.ContainsKey("User-Agent")) {
            if ($HttpAgent -eq $ansible_web_request_options.http_agent.default) {
                $HttpAgent = $Headers['User-Agent']
            } elseif ($null -ne $Module) {
                $Module.Warn("The 'User-Agent' header and the 'http_agent' was set, using the 'http_agent' for web request")
            }
        }
        $web_request.UserAgent = $HttpAgent

        switch ($FollowRedirects) {
            none { $web_request.AllowAutoRedirect = $false }
            safe {
                if ($web_request.Method -in @("GET", "HEAD")) {
                    $web_request.AllowAutoRedirect = $true
                } else {
                    $web_request.AllowAutoRedirect = $false
                }
            }
            all { $web_request.AllowAutoRedirect = $true }
        }

        if ($MaximumRedirection -eq 0) {
            $web_request.AllowAutoRedirect = $false
        } else {
            $web_request.MaximumAutomaticRedirections = $MaximumRedirection
        }
    }

    return $web_request
}

Function Invoke-WithWebRequest {
    <#
    .SYNOPSIS
    Invokes a ScriptBlock with the WebRequest.

    .DESCRIPTION
    Invokes the ScriptBlock and handle extra information like accessing the response stream, closing those streams
    safely as well as setting common module return values.

    .PARAMETER Module
    The Ansible.Basic module to set the return values for. This will set the following return values;
        elapsed - The total time, in seconds, that it took to send the web request and process the response
        msg - The human readable description of the response status code
        status_code - An int that is the response status code

    .PARAMETER Request
    The System.Net.WebRequest to call. This can either be manually crafted or created with Get-AnsibleWebRequest.

    .PARAMETER Script
    The ScriptBlock to invoke during the web request. This ScriptBlock should take in the params
        Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

    This scriptblock should manage the response based on what it need to do.

    .PARAMETER Body
    An optional Stream to send to the target during the request.

    .PARAMETER IgnoreBadResponse
    By default a WebException will be raised for a non 2xx status code and the Script will not be invoked. This
    parameter can be set to process all responses regardless of the status code.

    .EXAMPLE Basic module that downloads a file
    $spec = @{
        options = @{
            path = @{ type = "path"; required = $true }
        }
    }
    $module = Ansible.Basic.AnsibleModule]::Create($args, $spec, @(Get-AnsibleWebRequestSpec))

    $web_request = Get-AnsibleWebRequest -Module $module

    Invoke-WithWebRequest -Module $module -Request $web_request -Script {
        Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

        $fs = [System.IO.File]::Create($module.Params.path)
        try {
            $Stream.CopyTo($fs)
            $fs.Flush()
        } finally {
            $fs.Dispose()
        }
    }
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [System.Object]
        [ValidateScript({ $_.GetType().FullName -eq 'Ansible.Basic.AnsibleModule' })]
        $Module,

        [Parameter(Mandatory=$true)]
        [System.Net.WebRequest]
        $Request,

        [Parameter(Mandatory=$true)]
        [ScriptBlock]
        $Script,

        [AllowNull()]
        [System.IO.Stream]
        $Body,

        [Switch]
        $IgnoreBadResponse
    )

    $start = Get-Date
    if ($null -ne $Body) {
        $request_st = $Request.GetRequestStream()
        try {
            $Body.CopyTo($request_st)
            $request_st.Flush()
        } finally {
            $request_st.Close()
        }
    }

    try {
        try {
            $web_response = $Request.GetResponse()
        } catch [System.Net.WebException] {
            # A WebResponse with a status code not in the 200 range will raise a WebException. We check if the
            # exception raised contains the actual response and continue on if IgnoreBadResponse is set. We also
            # make sure we set the status_code return value on the Module object if possible

            if ($_.Exception.PSObject.Properties.Name -match "Response") {
                $web_response = $_.Exception.Response

                if (-not $IgnoreBadResponse -or $null -eq $web_response) {
                    $Module.Result.msg = $_.Exception.StatusDescription
                    $Module.Result.status_code = $_.Exception.Response.StatusCode
                    throw $_
                }
            } else {
                throw $_
            }
        }

        if ($Request.RequestUri.IsFile) {
            # A FileWebResponse won't have these properties set
            $Module.Result.msg = "OK"
            $Module.Result.status_code = 200
        } else {
            $Module.Result.msg = $web_response.StatusDescription
            $Module.Result.status_code = $web_response.StatusCode
        }

        $response_stream = $web_response.GetResponseStream()
        try {
            # Invoke the ScriptBlock and pass in WebResponse and ResponseStream
            &$Script -Response $web_response -Stream $response_stream
        } finally {
            $response_stream.Dispose()
        }
    } finally {
        if ($web_response) {
            $web_response.Close()
        }
        $Module.Result.elapsed = ((Get-date) - $start).TotalSeconds
    }
}

Function Get-AnsibleWebRequestSpec {
    <#
    .SYNOPSIS
    Used by modules to get the argument spec fragment for AnsibleModule.

    .EXAMPLES
    $spec = @{
        options = @{}
    }
    $module = [Ansible.Basic.AnsibleModule]::Create($args, $spec, @(Get-AnsibleWebRequestSpec))
    #>
    @{ options = $ansible_web_request_options }
}

# See lib/ansible/plugins/doc_fragments/url_windows.py
# Kept here for backwards compat as this variable was added in Ansible 2.9. Ultimately this util should be removed
# once the deprecation period has been added.
$ansible_web_request_options = @{
    method = @{ type="str" }
    follow_redirects = @{ type="str"; choices=@("all","none","safe"); default="safe" }
    headers = @{ type="dict" }
    http_agent = @{ type="str"; default="ansible-httpget" }
    maximum_redirection = @{ type="int"; default=50 }
    timeout = @{ type="int"; default=30 }  # Was defaulted to 10 in win_get_url but 30 in win_uri so we use 30
    validate_certs = @{ type="bool"; default=$true }

    # Credential options
    client_cert = @{ type="str" }
    client_cert_password = @{ type="str"; no_log=$true }
    force_basic_auth = @{ type="bool"; default=$false }
    url_username = @{ type="str" }
    url_password = @{ type="str"; no_log=$true }
    use_default_credential = @{ type="bool"; default=$false }

    # Proxy options
    use_proxy = @{ type="bool"; default=$true }
    proxy_url = @{ type="str" }
    proxy_username = @{ type="str" }
    proxy_password = @{ type="str"; no_log=$true }
    proxy_use_default_credential = @{ type="bool"; default=$false }
}

$export_members = @{
# Copyright (c) 2017 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

Function Convert-FromSID($sid) {
    # Converts a SID to a Down-Level Logon name in the form of DOMAIN\UserName
    # If the SID is for a local user or group then DOMAIN would be the server
    # name.

    $account_object = New-Object System.Security.Principal.SecurityIdentifier($sid)
    try {
        $nt_account = $account_object.Translate([System.Security.Principal.NTAccount])
    } catch {
        Fail-Json -obj @{} -message "failed to convert sid '$sid' to a logon name: $($_.Exception.Message)"
    }

    return $nt_account.Value
}

Function Convert-ToSID {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSAvoidUsingEmptyCatchBlock", "", Justification="We don't care if converting to a SID fails, just that it failed or not")]
    param($account_name)
    # Converts an account name to a SID, it can take in the following forms
    # SID: Will just return the SID value that was passed in
    # UPN:
    #   principal@domain (Domain users only)
    # Down-Level Login Name
    #   DOMAIN\principal (Domain)
    #   SERVERNAME\principal (Local)
    #   .\principal (Local)
    #   NT AUTHORITY\SYSTEM (Local Service Accounts)
    # Login Name
    #   principal (Local/Local Service Accounts)

    try {
        $sid = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList $account_name
        return $sid.Value
    } catch {}

    if ($account_name -like "*\*") {
        $account_name_split = $account_name -split "\\"
        if ($account_name_split[0] -eq ".") {
            $domain = $env:COMPUTERNAME
        } else {
            $domain = $account_name_split[0]
        }
        $username = $account_name_split[1]
    } elseif ($account_name -like "*@*") {
        $account_name_split = $account_name -split "@"
        $domain = $account_name_split[1]
        $username = $account_name_split[0]
    } else {
        $domain = $null
        $username = $account_name
    }

    if ($domain) {
        # searching for a local group with the servername prefixed will fail,
        # need to check for this situation and only use NTAccount(String)
        if ($domain -eq $env:COMPUTERNAME) {
            $adsi = [ADSI]("WinNT://$env:COMPUTERNAME,computer")
            $group = $adsi.psbase.children | Where-Object { $_.schemaClassName -eq "group" -and $_.Name -eq $username }
        } else {
            $group = $null
        }
        if ($group) {
            $account = New-Object System.Security.Principal.NTAccount($username)
        } else {
            $account = New-Object System.Security.Principal.NTAccount($domain, $username)
        }
    } else {
        # when in a domain NTAccount(String) will favour domain lookups check
        # if username is a local user and explictly search on the localhost for
        # that account
        $adsi = [ADSI]("WinNT://$env:COMPUTERNAME,computer")
        $user = $adsi.psbase.children | Where-Object { $_.schemaClassName -eq "user" -and $_.Name -eq $username }
        if ($user) {
            $account = New-Object System.Security.Principal.NTAccount($env:COMPUTERNAME, $username)
        } else {
            $account = New-Object System.Security.Principal.NTAccount($username)
        }
    }

    try {
        $account_sid = $account.Translate([System.Security.Principal.SecurityIdentifier])
    } catch {
        Fail-Json @{} "account_name $account_name is not a valid account, cannot get SID: $($_.Exception.Message)"
    }

    return $account_sid.Value
}
# Copyright (c) 2017 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

#Requires -Module Ansible.ModuleUtils.PrivilegeUtil

Function Load-LinkUtils() {
    $link_util = @'
using Microsoft.Win32.SafeHandles;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace Ansible
{
    public enum LinkType
    {
        SymbolicLink,
        JunctionPoint,
        HardLink
    }

    public class LinkUtilWin32Exception : System.ComponentModel.Win32Exception
    {
        private string _msg;

        public LinkUtilWin32Exception(string message) : this(Marshal.GetLastWin32Error(), message) { }

        public LinkUtilWin32Exception(int errorCode, string message) : base(errorCode)
        {
            _msg = String.Format("{0} ({1}, Win32ErrorCode {2})", message, base.Message, errorCode);
        }

        public override string Message { get { return _msg; } }
        public static explicit operator LinkUtilWin32Exception(string message) { return new LinkUtilWin32Exception(message); }
    }

    public class LinkInfo
    {
        public LinkType Type { get; internal set; }
        public string PrintName { get; internal set; }
        public string SubstituteName { get; internal set; }
        public string AbsolutePath { get; internal set; }
        public string TargetPath { get; internal set; }
        public string[] HardTargets { get; internal set; }
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct REPARSE_DATA_BUFFER
    {
        public UInt32 ReparseTag;
        public UInt16 ReparseDataLength;
        public UInt16 Reserved;
        public UInt16 SubstituteNameOffset;
        public UInt16 SubstituteNameLength;
        public UInt16 PrintNameOffset;
        public UInt16 PrintNameLength;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LinkUtil.MAXIMUM_REPARSE_DATA_BUFFER_SIZE)]
        public char[] PathBuffer;
    }

    public class LinkUtil
    {
        public const int MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 1024 * 16;

        private const UInt32 FILE_FLAG_BACKUP_SEMANTICS = 0x02000000;
        private const UInt32 FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;

        private const UInt32 FSCTL_GET_REPARSE_POINT = 0x000900A8;
        private const UInt32 FSCTL_SET_REPARSE_POINT = 0x000900A4;
        private const UInt32 FILE_DEVICE_FILE_SYSTEM = 0x00090000;

        private const UInt32 IO_REPARSE_TAG_MOUNT_POINT = 0xA0000003;
        private const UInt32 IO_REPARSE_TAG_SYMLINK = 0xA000000C;

        private const UInt32 SYMLINK_FLAG_RELATIVE = 0x00000001;

        private const Int64 INVALID_HANDLE_VALUE = -1;

        private const UInt32 SIZE_OF_WCHAR = 2;

        private const UInt32 SYMBOLIC_LINK_FLAG_FILE = 0x00000000;
        private const UInt32 SYMBOLIC_LINK_FLAG_DIRECTORY = 0x00000001;

        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        private static extern SafeFileHandle CreateFile(
            string lpFileName,
            [MarshalAs(UnmanagedType.U4)] FileAccess dwDesiredAccess,
            [MarshalAs(UnmanagedType.U4)] FileShare dwShareMode,
            IntPtr lpSecurityAttributes,
            [MarshalAs(UnmanagedType.U4)] FileMode dwCreationDisposition,
            UInt32 dwFlagsAndAttributes,
            IntPtr hTemplateFile);

        // Used by GetReparsePointInfo()
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool DeviceIoControl(
            SafeFileHandle hDevice,
            UInt32 dwIoControlCode,
            IntPtr lpInBuffer,
            UInt32 nInBufferSize,
            out REPARSE_DATA_BUFFER lpOutBuffer,
            UInt32 nOutBufferSize,
            out UInt32 lpBytesReturned,
            IntPtr lpOverlapped);

        // Used by CreateJunctionPoint()
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool DeviceIoControl(
            SafeFileHandle hDevice,
            UInt32 dwIoControlCode,
            REPARSE_DATA_BUFFER lpInBuffer,
            UInt32 nInBufferSize,
            IntPtr lpOutBuffer,
            UInt32 nOutBufferSize,
            out UInt32 lpBytesReturned,
            IntPtr lpOverlapped);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool GetVolumePathName(
            string lpszFileName,
            StringBuilder lpszVolumePathName,
            ref UInt32 cchBufferLength);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr FindFirstFileNameW(
            string lpFileName,
            UInt32 dwFlags,
            ref UInt32 StringLength,
            StringBuilder LinkName);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool FindNextFileNameW(
            IntPtr hFindStream,
            ref UInt32 StringLength,
            StringBuilder LinkName);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool FindClose(
            IntPtr hFindFile);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool RemoveDirectory(
            string lpPathName);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool DeleteFile(
            string lpFileName);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool CreateSymbolicLink(
            string lpSymlinkFileName,
            string lpTargetFileName,
            UInt32 dwFlags);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern bool CreateHardLink(
            string lpFileName,
            string lpExistingFileName,
            IntPtr lpSecurityAttributes);

        public static LinkInfo GetLinkInfo(string linkPath)
        {
            FileAttributes attr = File.GetAttributes(linkPath);
            if (attr.HasFlag(FileAttributes.ReparsePoint))
                return GetReparsePointInfo(linkPath);

            if (!attr.HasFlag(FileAttributes.Directory))
                return GetHardLinkInfo(linkPath);

            return null;
        }

        public static void DeleteLink(string linkPath)
        {
            bool success;
            FileAttributes attr = File.GetAttributes(linkPath);
            if (attr.HasFlag(FileAttributes.Directory))
            {
                success = RemoveDirectory(linkPath);
            }
            else
            {
                success = DeleteFile(linkPath);
            }

            if (!success)
                throw new LinkUtilWin32Exception(String.Format("Failed to delete link at {0}", linkPath));
        }

        public static void CreateLink(string linkPath, String linkTarget, LinkType linkType)
        {
            switch (linkType)
            {
                case LinkType.SymbolicLink:
                    UInt32 linkFlags;
                    FileAttributes attr = File.GetAttributes(linkTarget);
                    if (attr.HasFlag(FileAttributes.Directory))
                        linkFlags = SYMBOLIC_LINK_FLAG_DIRECTORY;
                    else
                        linkFlags = SYMBOLIC_LINK_FLAG_FILE;

                    if (!CreateSymbolicLink(linkPath, linkTarget, linkFlags))
                        throw new LinkUtilWin32Exception(String.Format("CreateSymbolicLink({0}, {1}, {2}) failed", linkPath, linkTarget, linkFlags));
                    break;
                case LinkType.JunctionPoint:
                    CreateJunctionPoint(linkPath, linkTarget);
                    break;
                case LinkType.HardLink:
                    if (!CreateHardLink(linkPath, linkTarget, IntPtr.Zero))
                        throw new LinkUtilWin32Exception(String.Format("CreateHardLink({0}, {1}) failed", linkPath, linkTarget));
                    break;
            }
        }

        private static LinkInfo GetHardLinkInfo(string linkPath)
        {
            UInt32 maxPath = 260;
            List<string> result = new List<string>();

            StringBuilder sb = new StringBuilder((int)maxPath);
            UInt32 stringLength = maxPath;
            if (!GetVolumePathName(linkPath, sb, ref stringLength))
                throw new LinkUtilWin32Exception("GetVolumePathName() failed");
            string volume = sb.ToString();

            stringLength = maxPath;
            IntPtr findHandle = FindFirstFileNameW(linkPath, 0, ref stringLength, sb);
            if (findHandle.ToInt64() != INVALID_HANDLE_VALUE)
            {
                try
                {
                    do
                    {
                        string hardLinkPath = sb.ToString();
                        if (hardLinkPath.StartsWith("\\"))
                            hardLinkPath = hardLinkPath.Substring(1, hardLinkPath.Length - 1);

                        result.Add(Path.Combine(volume, hardLinkPath));
                        stringLength = maxPath;

                    } while (FindNextFileNameW(findHandle, ref stringLength, sb));
                }
                finally
                {
                    FindClose(findHandle);
                }
            }

            if (result.Count > 1)
                return new LinkInfo
                {
                    Type = LinkType.HardLink,
                    HardTargets = result.ToArray()
                };

            return null;
        }

        private static LinkInfo GetReparsePointInfo(string linkPath)
        {
            SafeFileHandle fileHandle = CreateFile(
                linkPath,
                FileAccess.Read,
                FileShare.None,
                IntPtr.Zero,
                FileMode.Open,
                FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                IntPtr.Zero);

            if (fileHandle.IsInvalid)
                throw new LinkUtilWin32Exception(String.Format("CreateFile({0}) failed", linkPath));

            REPARSE_DATA_BUFFER buffer = new REPARSE_DATA_BUFFER();
            UInt32 bytesReturned;
            try
            {
                if (!DeviceIoControl(
                    fileHandle,
                    FSCTL_GET_REPARSE_POINT,
                    IntPtr.Zero,
                    0,
                    out buffer,
                    MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
                    out bytesReturned,
                    IntPtr.Zero))
                    throw new LinkUtilWin32Exception(String.Format("DeviceIoControl() failed for file at {0}", linkPath));
            }
            finally
            {
                fileHandle.Dispose();
            }

            bool isRelative = false;
            int pathOffset = 0;
            LinkType linkType;
            if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)
            {
                UInt32 bufferFlags = Convert.ToUInt32(buffer.PathBuffer[0]) + Convert.ToUInt32(buffer.PathBuffer[1]);
                if (bufferFlags == SYMLINK_FLAG_RELATIVE)
                    isRelative = true;
                pathOffset = 2;
                linkType = LinkType.SymbolicLink;
            }
            else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
            {
                linkType = LinkType.JunctionPoint;
            }
            else
            {
                string errorMessage = String.Format("Invalid Reparse Tag: {0}", buffer.ReparseTag.ToString());
                throw new Exception(errorMessage);
            }

            string printName = new string(buffer.PathBuffer, (int)(buffer.PrintNameOffset / SIZE_OF_WCHAR) + pathOffset, (int)(buffer.PrintNameLength / SIZE_OF_WCHAR));
            string substituteName = new string(buffer.PathBuffer, (int)(buffer.SubstituteNameOffset / SIZE_OF_WCHAR) + pathOffset, (int)(buffer.SubstituteNameLength / SIZE_OF_WCHAR));

            // TODO: should we check for \?\UNC\server for convert it to the NT style \\server path
            // Remove the leading Windows object directory \?\ from the path if present
            string targetPath = substituteName;
            if (targetPath.StartsWith("\\??\\"))
                targetPath = targetPath.Substring(4, targetPath.Length - 4);

            string absolutePath = targetPath;
            if (isRelative)
                absolutePath = Path.GetFullPath(Path.Combine(new FileInfo(linkPath).Directory.FullName, targetPath));

            return new LinkInfo
            {
                Type = linkType,
                PrintName = printName,
                SubstituteName = substituteName,
                AbsolutePath = absolutePath,
                TargetPath = targetPath
            };
        }

        private static void CreateJunctionPoint(string linkPath, string linkTarget)
        {
            // We need to create the link as a dir beforehand
            Directory.CreateDirectory(linkPath);
            SafeFileHandle fileHandle = CreateFile(
                linkPath,
                FileAccess.Write,
                FileShare.Read | FileShare.Write | FileShare.None,
                IntPtr.Zero,
                FileMode.Open,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
                IntPtr.Zero);

            if (fileHandle.IsInvalid)
                throw new LinkUtilWin32Exception(String.Format("CreateFile({0}) failed", linkPath));

            try
            {
                string substituteName = "\\??\\" + Path.GetFullPath(linkTarget);
                string printName = linkTarget;

                REPARSE_DATA_BUFFER buffer = new REPARSE_DATA_BUFFER();
                buffer.SubstituteNameOffset = 0;
                buffer.SubstituteNameLength = (UInt16)(substituteName.Length * SIZE_OF_WCHAR);
                buffer.PrintNameOffset = (UInt16)(buffer.SubstituteNameLength + 2);
                buffer.PrintNameLength = (UInt16)(printName.Length * SIZE_OF_WCHAR);

                buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
                buffer.ReparseDataLength = (UInt16)(buffer.SubstituteNameLength + buffer.PrintNameLength + 12);
                buffer.PathBuffer = new char[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

                byte[] unicodeBytes = Encoding.Unicode.GetBytes(substituteName + "\0" + printName);
                char[] pathBuffer = Encoding.Unicode.GetChars(unicodeBytes);
                Array.Copy(pathBuffer, buffer.PathBuffer, pathBuffer.Length);

                UInt32 bytesReturned;
                if (!DeviceIoControl(
                    fileHandle,
                    FSCTL_SET_REPARSE_POINT,
                    buffer,
                    (UInt32)(buffer.ReparseDataLength + 8),
                    IntPtr.Zero, 0,
                    out bytesReturned,
                    IntPtr.Zero))
                    throw new LinkUtilWin32Exception(String.Format("DeviceIoControl() failed to create junction point at {0} to {1}", linkPath, linkTarget));
            }
            finally
            {
                fileHandle.Dispose();
            }
        }
    }
}
'@

    # FUTURE: find a better way to get the _ansible_remote_tmp variable
    $original_tmp = $env:TMP

    $remote_tmp = $original_tmp
    $module_params = Get-Variable -Name complex_args -ErrorAction SilentlyContinue
    if ($module_params) {
        if ($module_params.Value.ContainsKey("_ansible_remote_tmp") ) {
            $remote_tmp = $module_params.Value["_ansible_remote_tmp"]
            $remote_tmp = [System.Environment]::ExpandEnvironmentVariables($remote_tmp)
        }
    }

    $env:TMP = $remote_tmp
    Add-Type -TypeDefinition $link_util
    $env:TMP = $original_tmp

    # enable the SeBackupPrivilege if it is disabled
    $state = Get-AnsiblePrivilege -Name SeBackupPrivilege
    if ($state -eq $false) {
        Set-AnsiblePrivilege -Name SeBackupPrivilege -Value $true
    }
}

Function Get-Link($link_path) {
    $link_info = [Ansible.LinkUtil]::GetLinkInfo($link_path)
    return $link_info
}

Function Remove-Link($link_path) {
    [Ansible.LinkUtil]::DeleteLink($link_path)
}

Function New-Link($link_path, $link_target, $link_type) {
    if (-not (Test-Path -LiteralPath $link_target)) {
        throw "link_target '$link_target' does not exist, cannot create link"
    }

    switch($link_type) {
        "link" {
            $type = [Ansible.LinkType]::SymbolicLink
        }
        "junction" {
            if (Test-Path -LiteralPath $link_target -PathType Leaf) {
                throw "cannot set the target for a junction point to a file"
            }
            $type = [Ansible.LinkType]::JunctionPoint
        }
        "hard" {
            if (Test-Path -LiteralPath $link_target -PathType Container) {
                throw "cannot set the target for a hard link to a directory"
            }
            $type = [Ansible.LinkType]::HardLink
        }
        default { throw "invalid link_type option $($link_type): expecting link, junction, hard" }
    }
    [Ansible.LinkUtil]::CreateLink($link_path, $link_target, $type)
# Copyright (c): 2018, Dag Wieers (@dagwieers) <dag@wieers.com>
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

Function Backup-File {
<#
    .SYNOPSIS
    Helper function to make a backup of a file.
    .EXAMPLE
    Backup-File -path $path -WhatIf:$check_mode
#>
    [CmdletBinding(SupportsShouldProcess=$true)]

    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string] $path
    )

    Process {
        $backup_path = $null
        if (Test-Path -LiteralPath $path -PathType Leaf) {
            $backup_path = "$path.$pid." + [DateTime]::Now.ToString("yyyyMMdd-HHmmss") + ".bak";
            Try {
                Copy-Item -LiteralPath $path -Destination $backup_path
            } Catch {
                throw "Failed to create backup file '$backup_path' from '$path'. ($($_.Exception.Message))"
            }
        }
        return $backup_path
    }
}
# Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2014, and others
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

Set-StrictMode -Version 2.0
$ErrorActionPreference = "Stop"

Function Set-Attr($obj, $name, $value)
{
<#
    .SYNOPSIS
    Helper function to set an "attribute" on a psobject instance in PowerShell.
    This is a convenience to make adding Members to the object easier and
    slightly more pythonic
    .EXAMPLE
    Set-Attr $result "changed" $true
#>

    # If the provided $obj is undefined, define one to be nice
    If (-not $obj.GetType)
    {
        $obj = @{ }
    }

    Try
    {
        $obj.$name = $value
    }
    Catch
    {
        $obj | Add-Member -Force -MemberType NoteProperty -Name $name -Value $value
    }
}

Function Exit-Json($obj)
{
<#
    .SYNOPSIS
    Helper function to convert a PowerShell object to JSON and output it, exiting
    the script
    .EXAMPLE
    Exit-Json $result
#>

    # If the provided $obj is undefined, define one to be nice
    If (-not $obj.GetType)
    {
        $obj = @{ }
    }

    if (-not $obj.ContainsKey('changed')) {
        Set-Attr -obj $obj -name "changed" -value $false
    }

    Write-Output $obj | ConvertTo-Json -Compress -Depth 99
    Exit
}

Function Fail-Json($obj, $message = $null)
{
<#
    .SYNOPSIS
    Helper function to add the "msg" property and "failed" property, convert the
    PowerShell Hashtable to JSON and output it, exiting the script
    .EXAMPLE
    Fail-Json $result "This is the failure message"
#>

    if ($obj -is [hashtable] -or $obj -is [psobject]) {
        # Nothing to do
    } elseif ($obj -is [string] -and $null -eq $message) {
        # If we weren't given 2 args, and the only arg was a string,
        # create a new Hashtable and use the arg as the failure message
        $message = $obj
        $obj = @{ }
    } else {
        # If the first argument is undefined or a different type,
        # make it a Hashtable
        $obj = @{ }
    }

    # Still using Set-Attr for PSObject compatibility
    Set-Attr -obj $obj -name "msg" -value $message
    Set-Attr -obj $obj -name "failed" -value $true

    if (-not $obj.ContainsKey('changed')) {
        Set-Attr -obj $obj -name "changed" -value $false
    }

    Write-Output $obj | ConvertTo-Json -Compress -Depth 99
    Exit 1
}

Function Add-Warning($obj, $message)
{
<#
    .SYNOPSIS
    Helper function to add warnings, even if the warnings attribute was
    not already set up. This is a convenience for the module developer
    so they do not have to check for the attribute prior to adding.
#>

    if (-not $obj.ContainsKey("warnings")) {
        $obj.warnings = @()
    } elseif ($obj.warnings -isnot [array]) {
        throw "Add-Warning: warnings attribute is not an array"
    }

    $obj.warnings += $message
}

Function Add-DeprecationWarning($obj, $message, $version = $null)
{
<#
    .SYNOPSIS
    Helper function to add deprecations, even if the deprecations attribute was
    not already set up. This is a convenience for the module developer
    so they do not have to check for the attribute prior to adding.
#>
    if (-not $obj.ContainsKey("deprecations")) {
        $obj.deprecations = @()
    } elseif ($obj.deprecations -isnot [array]) {
        throw "Add-DeprecationWarning: deprecations attribute is not a list"
    }

    $obj.deprecations += @{
        msg = $message
        version = $version
    }
}

Function Expand-Environment($value)
{
<#
    .SYNOPSIS
    Helper function to expand environment variables in values. By default
    it turns any type to a string, but we ensure $null remains $null.
#>
    if ($null -ne $value) {
        [System.Environment]::ExpandEnvironmentVariables($value)
    } else {
        $value
    }
}

Function Get-AnsibleParam($obj, $name, $default = $null, $resultobj = @{}, $failifempty = $false, $emptyattributefailmessage, $ValidateSet, $ValidateSetErrorMessage, $type = $null, $aliases = @())
{
<#
    .SYNOPSIS
    Helper function to get an "attribute" from a psobject instance in PowerShell.
    This is a convenience to make getting Members from an object easier and
    slightly more pythonic
    .EXAMPLE
    $attr = Get-AnsibleParam $response "code" -default "1"
    .EXAMPLE
    Get-AnsibleParam -obj $params -name "State" -default "Present" -ValidateSet "Present","Absent" -resultobj $resultobj -failifempty $true
    Get-AnsibleParam also supports Parameter validation to save you from coding that manually
    Note that if you use the failifempty option, you do need to specify resultobject as well.
#>
    # Check if the provided Member $name or aliases exist in $obj and return it or the default.
    try {

        $found = $null
        # First try to find preferred parameter $name
        $aliases = @($name) + $aliases

        # Iterate over aliases to find acceptable Member $name
        foreach ($alias in $aliases) {
            if ($obj.ContainsKey($alias)) {
                $found = $alias
                break
            }
        }

        if ($null -eq $found) {
            throw
        }
        $name = $found

        if ($ValidateSet) {

            if ($ValidateSet -contains ($obj.$name)) {
                $value = $obj.$name
            } else {
                if ($null -eq $ValidateSetErrorMessage) {
                    #Auto-generated error should be sufficient in most use cases
                    $ValidateSetErrorMessage = "Get-AnsibleParam: Argument $name needs to be one of $($ValidateSet -join ",") but was $($obj.$name)."
                }
                Fail-Json -obj $resultobj -message $ValidateSetErrorMessage
            }
        } else {
            $value = $obj.$name
        }
    } catch {
        if ($failifempty -eq $false) {
            $value = $default
        } else {
            if (-not $emptyattributefailmessage) {
                $emptyattributefailmessage = "Get-AnsibleParam: Missing required argument: $name"
            }
            Fail-Json -obj $resultobj -message $emptyattributefailmessage
        }
    }

    # If $null -eq $value, the parameter was unspecified by the user (deliberately or not)
    # Please leave $null-values intact, modules need to know if a parameter was specified
    if ($null -eq $value) {
        return $null
    }

    if ($type -eq "path") {
        # Expand environment variables on path-type
        $value = Expand-Environment($value)
        # Test if a valid path is provided
        if (-not (Test-Path -IsValid $value)) {
            $path_invalid = $true
            # could still be a valid-shaped path with a nonexistent drive letter
            if ($value -match "^\w:") {
                # rewrite path with a valid drive letter and recheck the shape- this might still fail, eg, a nonexistent non-filesystem PS path
                if (Test-Path -IsValid $(@(Get-PSDrive -PSProvider Filesystem)[0].Name + $value.Substring(1))) {
                    $path_invalid = $false
                }
            }
            if ($path_invalid) {
                Fail-Json -obj $resultobj -message "Get-AnsibleParam: Parameter '$name' has an invalid path '$value' specified."
            }
        }
    } elseif ($type -eq "str") {
        # Convert str types to real Powershell strings
        $value = $value.ToString()
    } elseif ($type -eq "bool") {
        # Convert boolean types to real Powershell booleans
        $value = $value | ConvertTo-Bool
    } elseif ($type -eq "int") {
        # Convert int types to real Powershell integers
        $value = $value -as [int]
    } elseif ($type -eq "float") {
        # Convert float types to real Powershell floats
        $value = $value -as [float]
    } elseif ($type -eq "list") {
        if ($value -is [array]) {
            # Nothing to do
        } elseif ($value -is [string]) {
            # Convert string type to real Powershell array
            $value = $value.Split(",").Trim()
        } elseif ($value -is [int]) {
            $value = @($value)
        } else {
            Fail-Json -obj $resultobj -message "Get-AnsibleParam: Parameter '$name' is not a YAML list."
        }
        # , is not a typo, forces it to return as a list when it is empty or only has 1 entry
        return ,$value
    }

    return $value
}

#Alias Get-attr-->Get-AnsibleParam for backwards compat. Only add when needed to ease debugging of scripts
If (-not(Get-Alias -Name "Get-attr" -ErrorAction SilentlyContinue))
{
    New-Alias -Name Get-attr -Value Get-AnsibleParam
}

Function ConvertTo-Bool
{
<#
    .SYNOPSIS
    Helper filter/pipeline function to convert a value to boolean following current
    Ansible practices
    .EXAMPLE
    $is_true = "true" | ConvertTo-Bool
#>
    param(
        [parameter(valuefrompipeline=$true)]
        $obj
    )

    $boolean_strings = "yes", "on", "1", "true", 1
    $obj_string = [string]$obj

    if (($obj -is [boolean] -and $obj) -or $boolean_strings -contains $obj_string.ToLower()) {
        return $true
    } else {
        return $false
    }
}

Function Parse-Args($arguments, $supports_check_mode = $false)
{
<#
    .SYNOPSIS
    Helper function to parse Ansible JSON arguments from a "file" passed as
    the single argument to the module.
    .EXAMPLE
    $params = Parse-Args $args
#>
    $params = New-Object psobject
    If ($arguments.Length -gt 0)
    {
        $params = Get-Content $arguments[0] | ConvertFrom-Json
    }
    Else {
        $params = $complex_args
    }
    $check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -type "bool" -default $false
    If ($check_mode -and -not $supports_check_mode)
    {
        Exit-Json @{
            skipped = $true
            changed = $false
            msg = "remote module does not support check mode"
        }
    }
    return $params
}


Function Get-FileChecksum($path, $algorithm = 'sha1')
{
<#
    .SYNOPSIS
    Helper function to calculate a hash of a file in a way which PowerShell 3
    and above can handle
#>
    If (Test-Path -LiteralPath $path -PathType Leaf)
    {
        switch ($algorithm)
        {
            'md5' { $sp = New-Object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider }
            'sha1' { $sp = New-Object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider }
            'sha256' { $sp = New-Object -TypeName System.Security.Cryptography.SHA256CryptoServiceProvider }
            'sha384' { $sp = New-Object -TypeName System.Security.Cryptography.SHA384CryptoServiceProvider }
            'sha512' { $sp = New-Object -TypeName System.Security.Cryptography.SHA512CryptoServiceProvider }
            default { Fail-Json @{} "Unsupported hash algorithm supplied '$algorithm'" }
        }

        If ($PSVersionTable.PSVersion.Major -ge 4) {
            $raw_hash = Get-FileHash -LiteralPath $path -Algorithm $algorithm
            $hash = $raw_hash.Hash.ToLower()
        } Else {
            $fp = [System.IO.File]::Open($path, [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite);
            $hash = [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace("-", "").ToLower();
            $fp.Dispose();
        }
    }
    ElseIf (Test-Path -LiteralPath $path -PathType Container)
    {
        $hash = "3";
    }
    Else
    {
        $hash = "1";
    }
    return $hash
}

Function Get-PendingRebootStatus
{
<#
    .SYNOPSIS
    Check if reboot is required, if so notify CA.
    Function returns true if computer has a pending reboot
#>
    $featureData = Invoke-CimMethod -EA Ignore -Name GetServerFeature -Namespace root\microsoft\windows\servermanager -Class MSFT_ServerManagerTasks
    $regData = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" "PendingFileRenameOperations" -EA Ignore
    $CBSRebootStatus = Get-ChildItem "HKLM:\\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing"  -ErrorAction SilentlyContinue| Where-Object {$_.PSChildName -eq "RebootPending"}
    if(($featureData -and $featureData.RequiresReboot) -or $regData -or $CBSRebootStatus)
    {
        return $True
    }
    else
    {
        return $False
    }
}

# Copyright (c) 2017 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

# The rules used in these functions are derived from the below
# https://docs.microsoft.com/en-us/cpp/cpp/parsing-cpp-command-line-arguments
# https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/

Function Escape-Argument($argument, $force_quote=$false) {
    # this converts a single argument to an escaped version, use Join-Arguments
    # instead of this function as this only escapes a single string.

    # check if argument contains a space, \n, \t, \v or "
    if ($force_quote -eq $false -and $argument.Length -gt 0 -and $argument -notmatch "[ \n\t\v`"]") {
        # argument does not need escaping (and we don't want to force it),
        # return as is
        return $argument
    } else {
        # we need to quote the arg so start with "
        $new_argument = '"'

        for ($i = 0; $i -lt $argument.Length; $i++) {
            $num_backslashes = 0

            # get the number of \ from current char until end or not a \
            while ($i -ne ($argument.Length - 1) -and $argument[$i] -eq "\") {
                $num_backslashes++
                $i++
            }

            $current_char = $argument[$i]
            if ($i -eq ($argument.Length -1) -and $current_char -eq "\") {
                # We are at the end of the string so we need to add the same \
                # * 2 as the end char would be a "
                $new_argument += ("\" * ($num_backslashes + 1) * 2)
            } elseif ($current_char -eq '"') {
                # we have a inline ", we need to add the existing \ but * by 2
                # plus another 1
                $new_argument += ("\" * (($num_backslashes * 2) + 1))
                $new_argument += $current_char
            } else {
                # normal character so no need to escape the \ we have counted
                $new_argument += ("\" * $num_backslashes)
                $new_argument += $current_char
            }
        }

        # we need to close the special arg with a "
        $new_argument += '"'
        return $new_argument
    }
}

Function Argv-ToString($arguments, $force_quote=$false) {
    # Takes in a list of un escaped arguments and convert it to a single string
    # that can be used when starting a new process. It will escape the
    # characters as necessary in the list.
    # While there is a CommandLineToArgvW function there is a no
    # ArgvToCommandLineW that we can call to convert a list to an escaped
    # string.
    # You can also pass in force_quote so that each argument is quoted even
    # when not necessary, by default only arguments with certain characters are
    # quoted.
    # TODO: add in another switch which will escape the args for cmd.exe

    $escaped_arguments = @()
    foreach ($argument in $arguments) {
        $escaped_argument = Escape-Argument -argument $argument -force_quote $force_quote
        $escaped_arguments += $escaped_argument
    }

# Copyright (c) 2017 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

# used by Convert-DictToSnakeCase to convert a string in camelCase
# format to snake_case
Function Convert-StringToSnakeCase($string) {
    # cope with pluralized abbreaviations such as TargetGroupARNs
    if ($string -cmatch "[A-Z]{3,}s") {
        $replacement_string = $string -creplace $matches[0], "_$($matches[0].ToLower())"

        # handle when there was nothing before the plural pattern
        if ($replacement_string.StartsWith("_") -and -not $string.StartsWith("_")) {
            $replacement_string = $replacement_string.Substring(1)
        }
        $string = $replacement_string
    }
    $string = $string -creplace "(.)([A-Z][a-z]+)", '$1_$2'
    $string = $string -creplace "([a-z0-9])([A-Z])", '$1_$2'
    $string = $string.ToLower()

    return $string
}

# used by Convert-DictToSnakeCase to covert list entries from camelCase
# to snake_case
Function Convert-ListToSnakeCase($list) {
    $snake_list = [System.Collections.ArrayList]@()
    foreach ($value in $list) {
        if ($value -is [Hashtable]) {
            $new_value = Convert-DictToSnakeCase -dict $value
        } elseif ($value -is [Array] -or $value -is [System.Collections.ArrayList]) {
            $new_value = Convert-ListToSnakeCase -list $value
        } else {
            $new_value = $value
        }
        [void]$snake_list.Add($new_value)
    }

    return ,$snake_list
}

# converts a dict/hashtable keys from camelCase to snake_case
# this is to keep the return values consistent with the Ansible
# way of working.
Function Convert-DictToSnakeCase($dict) {
    $snake_dict = @{}
    foreach ($dict_entry in $dict.GetEnumerator()) {
        $key = $dict_entry.Key
        $snake_key = Convert-StringToSnakeCase -string $key

        $value = $dict_entry.Value
        if ($value -is [Hashtable]) {
            $snake_dict.$snake_key = Convert-DictToSnakeCase -dict $value
        } elseif ($value -is [Array] -or $value -is [System.Collections.ArrayList]) {
            $snake_dict.$snake_key = Convert-ListToSnakeCase -list $value
        } else {
            $snake_dict.$snake_key = $value
        }
    }

# Copyright (c) 2017 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

<#
Test-Path/Get-Item cannot find/return info on files that are locked like
C:\pagefile.sys. These 2 functions are designed to work with these files and
provide similar functionality with the normal cmdlets with as minimal overhead
as possible. They work by using Get-ChildItem with a filter and return the
result from that.
#>

Function Test-AnsiblePath {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true)][string]$Path
    )
    # Replacement for Test-Path
    try {
        $file_attributes = [System.IO.File]::GetAttributes($Path)
    } catch [System.IO.FileNotFoundException], [System.IO.DirectoryNotFoundException] {
        return $false
    } catch [NotSupportedException] {
        # When testing a path like Cert:\LocalMachine\My, System.IO.File will
        # not work, we just revert back to using Test-Path for this
        return Test-Path -Path $Path
    }

    if ([Int32]$file_attributes -eq -1) {
        return $false
    } else {
        return $true
    }
}

Function Get-AnsibleItem {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true)][string]$Path
    )
    # Replacement for Get-Item
    try {
        $file_attributes = [System.IO.File]::GetAttributes($Path)
    } catch {
        # if -ErrorAction SilentlyCotinue is set on the cmdlet and we failed to
        # get the attributes, just return $null, otherwise throw the error
        if ($ErrorActionPreference -ne "SilentlyContinue") {
            throw $_
        }
        return $null
    }
    if ([Int32]$file_attributes -eq -1) {
        throw New-Object -TypeName System.Management.Automation.ItemNotFoundException -ArgumentList "Cannot find path '$Path' because it does not exist."
    } elseif ($file_attributes.HasFlag([System.IO.FileAttributes]::Directory)) {
        return New-Object -TypeName System.IO.DirectoryInfo -ArgumentList $Path
    } else {
# Copyright (c) 2018 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

Function Add-CSharpType {
    <#
    .SYNOPSIS
    Compiles one or more C# scripts similar to Add-Type. This exposes
    more configuration options that are useable within Ansible and it
    also allows multiple C# sources to be compiled together.

    .PARAMETER References
    [String[]] A collection of C# scripts to compile together.

    .PARAMETER IgnoreWarnings
    [Switch] Whether to compile code that contains compiler warnings, by
    default warnings will cause a compiler error.

    .PARAMETER PassThru
    [Switch] Whether to return the loaded Assembly

    .PARAMETER AnsibleModule
    [Ansible.Basic.AnsibleModule] used to derive the TempPath and Debug values.
        TempPath is set to the Tmpdir property of the class
        IncludeDebugInfo is set when the Ansible verbosity is >= 3

    .PARAMETER TempPath
    [String] The temporary directory in which the dynamic assembly is
    compiled to. This file is deleted once compilation is complete.
    Cannot be used when AnsibleModule is set. This is a no-op when
    running on PSCore.

    .PARAMETER IncludeDebugInfo
    [Switch] Whether to include debug information in the compiled
    assembly. Cannot be used when AnsibleModule is set. This is a no-op
    when running on PSCore.

    .PARAMETER CompileSymbols
    [String[]] A list of symbols to be defined during compile time. These are
    added to the existing symbols, 'CORECLR', 'WINDOWS', 'UNIX' that are set
    conditionalls in this cmdlet.

    .NOTES
    The following features were added to control the compiling options from the
    code itself.

    * Predefined compiler SYMBOLS

        * CORECLR - Added when running on PowerShell Core.
        * WINDOWS - Added when running on Windows.
        * UNIX - Added when running on non-Windows.
        * X86 - Added when running on a 32-bit process (Ansible 2.10+)
        * AMD64 - Added when running on a 64-bit process (Ansible 2.10+)

    * Ignore compiler warnings inline with the following comment inline

        //NoWarn -Name <rule code> [-CLR Core|Framework]

    * Specify custom assembly references inline

        //AssemblyReference -Name Dll.Location.dll [-CLR Core|Framework]

        # Added in Ansible 2.10
        //AssemblyReference -Type System.Type.Name [-CLR Core|Framework]

    * Create automatic type accelerators to simplify long namespace names (Ansible 2.9+)

        //TypeAccelerator -Name <AcceleratorName> -TypeName <Name of compiled type>
    #>
    param(
        [Parameter(Mandatory=$true)][AllowEmptyCollection()][String[]]$References,
        [Switch]$IgnoreWarnings,
        [Switch]$PassThru,
        [Parameter(Mandatory=$true, ParameterSetName="Module")][Object]$AnsibleModule,
        [Parameter(ParameterSetName="Manual")][String]$TempPath = $env:TMP,
        [Parameter(ParameterSetName="Manual")][Switch]$IncludeDebugInfo,
        [String[]]$CompileSymbols = @()
    )
    if ($null -eq $References -or $References.Length -eq 0) {
        return
    }

    # define special symbols CORECLR, WINDOWS, UNIX if required
    # the Is* variables are defined on PSCore, if absent we assume an
    # older version of PowerShell under .NET Framework and Windows
    $defined_symbols = [System.Collections.ArrayList]$CompileSymbols

    if ([System.IntPtr]::Size -eq 4) {
        $defined_symbols.Add('X86') > $null
    } else {
        $defined_symbols.Add('AMD64') > $null
    }

    $is_coreclr = Get-Variable -Name IsCoreCLR -ErrorAction SilentlyContinue
    if ($null -ne $is_coreclr) {
        if ($is_coreclr.Value) {
            $defined_symbols.Add("CORECLR") > $null
        }
    }
    $is_windows = Get-Variable -Name IsWindows -ErrorAction SilentlyContinue
    if ($null -ne $is_windows) {
        if ($is_windows.Value) {
            $defined_symbols.Add("WINDOWS") > $null
        } else {
            $defined_symbols.Add("UNIX") > $null
        }
    } else {
        $defined_symbols.Add("WINDOWS") > $null
    }

    # Store any TypeAccelerators shortcuts the util wants us to set
    $type_accelerators = [System.Collections.Generic.List`1[Hashtable]]@()

    # pattern used to find referenced assemblies in the code
    $assembly_pattern = [Regex]"//\s*AssemblyReference\s+-(?<Parameter>(Name)|(Type))\s+(?<Name>[\w.]*)(\s+-CLR\s+(?<CLR>Core|Framework))?"
    $no_warn_pattern = [Regex]"//\s*NoWarn\s+-Name\s+(?<Name>[\w\d]*)(\s+-CLR\s+(?<CLR>Core|Framework))?"
    $type_pattern = [Regex]"//\s*TypeAccelerator\s+-Name\s+(?<Name>[\w.]*)\s+-TypeName\s+(?<TypeName>[\w.]*)"

    # PSCore vs PSDesktop use different methods to compile the code,
    # PSCore uses Roslyn and can compile the code purely in memory
    # without touching the disk while PSDesktop uses CodeDom and csc.exe
    # to compile the code. We branch out here and run each
    # distribution's method to add our C# code.
    if ($is_coreclr) {
        # compile the code using Roslyn on PSCore

        # Include the default assemblies using the logic in Add-Type
        # https://github.com/PowerShell/PowerShell/blob/master/src/Microsoft.PowerShell.Commands.Utility/commands/utility/AddType.cs
        $assemblies = [System.Collections.Generic.HashSet`1[Microsoft.CodeAnalysis.MetadataReference]]@(
            [Microsoft.CodeAnalysis.CompilationReference]::CreateFromFile(([System.Reflection.Assembly]::GetAssembly([PSObject])).Location)
        )
        $netcore_app_ref_folder = [System.IO.Path]::Combine([System.IO.Path]::GetDirectoryName([PSObject].Assembly.Location), "ref")
        $lib_assembly_location = [System.IO.Path]::GetDirectoryName([object].Assembly.Location)
        foreach ($file in [System.IO.Directory]::EnumerateFiles($netcore_app_ref_folder, "*.dll", [System.IO.SearchOption]::TopDirectoryOnly)) {
            $assemblies.Add([Microsoft.CodeAnalysis.MetadataReference]::CreateFromFile($file)) > $null
        }

        # loop through the references, parse as a SyntaxTree and get
        # referenced assemblies
        $ignore_warnings = New-Object -TypeName 'System.Collections.Generic.Dictionary`2[[String], [Microsoft.CodeAnalysis.ReportDiagnostic]]'
        $parse_options = ([Microsoft.CodeAnalysis.CSharp.CSharpParseOptions]::Default).WithPreprocessorSymbols($defined_symbols)
        $syntax_trees = [System.Collections.Generic.List`1[Microsoft.CodeAnalysis.SyntaxTree]]@()
        foreach ($reference in $References) {
            # scan through code and add any assemblies that match
            # //AssemblyReference -Name ... [-CLR Core]
            # //NoWarn -Name ... [-CLR Core]
            # //TypeAccelerator -Name ... -TypeName ...
            $assembly_matches = $assembly_pattern.Matches($reference)
            foreach ($match in $assembly_matches) {
                $clr = $match.Groups["CLR"].Value
                if ($clr -and $clr -ne "Core") {
                    continue
                }

                $parameter_type = $match.Groups["Parameter"].Value
                $assembly_path = $match.Groups["Name"].Value
                if ($parameter_type -eq "Type") {
                    $assembly_path = ([Type]$assembly_path).Assembly.Location
                } else {
                    if (-not ([System.IO.Path]::IsPathRooted($assembly_path))) {
                        $assembly_path = Join-Path -Path $lib_assembly_location -ChildPath $assembly_path
                    }
                }
                $assemblies.Add([Microsoft.CodeAnalysis.MetadataReference]::CreateFromFile($assembly_path)) > $null
            }
            $warn_matches = $no_warn_pattern.Matches($reference)
            foreach ($match in $warn_matches) {
                $clr = $match.Groups["CLR"].Value
                if ($clr -and $clr -ne "Core") {
                    continue
                }
                $ignore_warnings.Add($match.Groups["Name"], [Microsoft.CodeAnalysis.ReportDiagnostic]::Suppress)
            }
            $syntax_trees.Add([Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree]::ParseText($reference, $parse_options)) > $null

            $type_matches = $type_pattern.Matches($reference)
            foreach ($match in $type_matches) {
                $type_accelerators.Add(@{Name=$match.Groups["Name"].Value; TypeName=$match.Groups["TypeName"].Value})
            }
        }

        # Release seems to contain the correct line numbers compared to
        # debug,may need to keep a closer eye on this in the future
        $compiler_options = (New-Object -TypeName Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions -ArgumentList @(
            [Microsoft.CodeAnalysis.OutputKind]::DynamicallyLinkedLibrary
        )).WithOptimizationLevel([Microsoft.CodeAnalysis.OptimizationLevel]::Release)

        # set warnings to error out if IgnoreWarnings is not set
        if (-not $IgnoreWarnings.IsPresent) {
            $compiler_options = $compiler_options.WithGeneralDiagnosticOption([Microsoft.CodeAnalysis.ReportDiagnostic]::Error)
            $compiler_options = $compiler_options.WithSpecificDiagnosticOptions($ignore_warnings)
        }

        # create compilation object
        $compilation = [Microsoft.CodeAnalysis.CSharp.CSharpCompilation]::Create(
            [System.Guid]::NewGuid().ToString(),
            $syntax_trees,
            $assemblies,
            $compiler_options
        )

        # Load the compiled code and pdb info, we do this so we can
        # include line number in a stracktrace
        $code_ms = New-Object -TypeName System.IO.MemoryStream
        $pdb_ms = New-Object -TypeName System.IO.MemoryStream
        try {
            $emit_result = $compilation.Emit($code_ms, $pdb_ms)
            if (-not $emit_result.Success) {
                $errors = [System.Collections.ArrayList]@()

                foreach ($e in $emit_result.Diagnostics) {
                    # builds the error msg, based on logic in Add-Type
                    # https://github.com/PowerShell/PowerShell/blob/master/src/Microsoft.PowerShell.Commands.Utility/commands/utility/AddType.cs#L1239
                    if ($null -eq $e.Location.SourceTree) {
                        $errors.Add($e.ToString()) > $null
                        continue
                    }

                    $cancel_token = New-Object -TypeName System.Threading.CancellationToken -ArgumentList $false
                    $text_lines = $e.Location.SourceTree.GetText($cancel_token).Lines
                    $line_span = $e.Location.GetLineSpan()

                    $diagnostic_message = $e.ToString()
                    $error_line_string = $text_lines[$line_span.StartLinePosition.Line].ToString()
                    $error_position = $line_span.StartLinePosition.Character

                    $sb = New-Object -TypeName System.Text.StringBuilder -ArgumentList ($diagnostic_message.Length + $error_line_string.Length * 2 + 4)
                    $sb.AppendLine($diagnostic_message)
                    $sb.AppendLine($error_line_string)

                    for ($i = 0; $i -lt $error_line_string.Length; $i++) {
                        if ([System.Char]::IsWhiteSpace($error_line_string[$i])) {
                            continue
                        }
                        $sb.Append($error_line_string, 0, $i)
                        $sb.Append(' ', [Math]::Max(0, $error_position - $i))
                        $sb.Append("^")
                        break
                    }

                    $errors.Add($sb.ToString()) > $null
                }

                throw [InvalidOperationException]"Failed to compile C# code:`r`n$($errors -join "`r`n")"
            }

            $code_ms.Seek(0, [System.IO.SeekOrigin]::Begin) > $null
            $pdb_ms.Seek(0, [System.IO.SeekOrigin]::Begin) > $null
            $compiled_assembly = [System.Runtime.Loader.AssemblyLoadContext]::Default.LoadFromStream($code_ms, $pdb_ms)
        } finally {
            $code_ms.Close()
            $pdb_ms.Close()
        }
    } else {
        # compile the code using CodeDom on PSDesktop

        # configure compile options based on input
        if ($PSCmdlet.ParameterSetName -eq "Module") {
            $temp_path = $AnsibleModule.Tmpdir
            $include_debug = $AnsibleModule.Verbosity -ge 3
        } else {
            $temp_path = $TempPath
            $include_debug = $IncludeDebugInfo.IsPresent
        }
        $compiler_options = [System.Collections.ArrayList]@("/optimize")
        if ($defined_symbols.Count -gt 0) {
            $compiler_options.Add("/define:" + ([String]::Join(";", $defined_symbols.ToArray()))) > $null
        }

        $compile_parameters = New-Object -TypeName System.CodeDom.Compiler.CompilerParameters
        $compile_parameters.GenerateExecutable = $false
        $compile_parameters.GenerateInMemory = $true
        $compile_parameters.TreatWarningsAsErrors = (-not $IgnoreWarnings.IsPresent)
        $compile_parameters.IncludeDebugInformation = $include_debug
        $compile_parameters.TempFiles = (New-Object -TypeName System.CodeDom.Compiler.TempFileCollection -ArgumentList $temp_path, $false)

        # Add-Type automatically references System.dll, System.Core.dll,
        # and System.Management.Automation.dll which we replicate here
        $assemblies = [System.Collections.Generic.HashSet`1[String]]@(
            "System.dll",
            "System.Core.dll",
            ([System.Reflection.Assembly]::GetAssembly([PSObject])).Location
        )

        # create a code snippet for each reference and check if we need
        # to reference any extra assemblies
        $ignore_warnings = [System.Collections.ArrayList]@()
        $compile_units = [System.Collections.Generic.List`1[System.CodeDom.CodeSnippetCompileUnit]]@()
        foreach ($reference in $References) {
            # scan through code and add any assemblies that match
            # //AssemblyReference -Name ... [-CLR Framework]
            # //NoWarn -Name ... [-CLR Framework]
            # //TypeAccelerator -Name ... -TypeName ...
            $assembly_matches = $assembly_pattern.Matches($reference)
            foreach ($match in $assembly_matches) {
                $clr = $match.Groups["CLR"].Value
                if ($clr -and $clr -ne "Framework") {
                    continue
                }

                $parameter_type = $match.Groups["Parameter"].Value
                $assembly_path = $match.Groups["Name"].Value
                if ($parameter_type -eq "Type") {
                    $assembly_path = ([Type]$assembly_path).Assembly.Location
                }
                $assemblies.Add($assembly_path) > $null
            }
            $warn_matches = $no_warn_pattern.Matches($reference)
            foreach ($match in $warn_matches) {
                $clr = $match.Groups["CLR"].Value
                if ($clr -and $clr -ne "Framework") {
                    continue
                }
                $warning_id = $match.Groups["Name"].Value
                # /nowarn should only contain the numeric part
                if ($warning_id.StartsWith("CS")) {
                    $warning_id = $warning_id.Substring(2)
                }
                $ignore_warnings.Add($warning_id) > $null
            }
            $compile_units.Add((New-Object -TypeName System.CodeDom.CodeSnippetCompileUnit -ArgumentList $reference)) > $null

            $type_matches = $type_pattern.Matches($reference)
            foreach ($match in $type_matches) {
                $type_accelerators.Add(@{Name=$match.Groups["Name"].Value; TypeName=$match.Groups["TypeName"].Value})
            }
        }
        if ($ignore_warnings.Count -gt 0) {
            $compiler_options.Add("/nowarn:" + ([String]::Join(",", $ignore_warnings.ToArray()))) > $null
        }
        $compile_parameters.ReferencedAssemblies.AddRange($assemblies)
        $compile_parameters.CompilerOptions = [String]::Join(" ", $compiler_options.ToArray())

        # compile the code together and check for errors
        $provider = New-Object -TypeName Microsoft.CSharp.CSharpCodeProvider
        $compile = $provider.CompileAssemblyFromDom($compile_parameters, $compile_units)
        if ($compile.Errors.HasErrors) {
            $msg = "Failed to compile C# code: "
            foreach ($e in $compile.Errors) {
                $msg += "`r`n" + $e.ToString()
            }
            throw [InvalidOperationException]$msg
        }
        $compiled_assembly = $compile.CompiledAssembly
    }

    $type_accelerator = [PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")
    foreach ($accelerator in $type_accelerators) {
        $type_name = $accelerator.TypeName
        $found = $false

        foreach ($assembly_type in $compiled_assembly.GetTypes()) {
            if ($assembly_type.Name -eq $type_name) {
                $type_accelerator::Add($accelerator.Name, $assembly_type)
                $found = $true
                break
            }
        }
        if (-not $found) {
            throw "Failed to find compiled class '$type_name' for custom TypeAccelerator."
        }
    }

    # return the compiled assembly if PassThru is set.
    if ($PassThru) {
        return $compiled_assembly
# Copyright (c) 2018 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

#AnsibleRequires -CSharpUtil Ansible.Privilege

Function Import-PrivilegeUtil {
    <#
    .SYNOPSIS
    No-op, as the C# types are automatically loaded.
    #>
    [CmdletBinding()]
    Param()
    $msg = "Import-PrivilegeUtil is deprecated and no longer needed, this cmdlet will be removed in a future version"
    if ((Get-Command -Name Add-DeprecationWarning -ErrorAction SilentlyContinue) -and (Get-Variable -Name result -ErrorAction SilentlyContinue)) {
        Add-DeprecationWarning -obj $result.Value -message $msg -version 2.12
    } else {
        $module = Get-Variable -Name module -ErrorAction SilentlyContinue
        if ($null -ne $module -and $module.Value.GetType().FullName -eq "Ansible.Basic.AnsibleModule") {
            $module.Value.Deprecate($msg, "2.12")
        }
    }
}

Function Get-AnsiblePrivilege {
    <#
    .SYNOPSIS
    Get the status of a privilege for the current process. This returns
        $true - the privilege is enabled
        $false - the privilege is disabled
        $null - the privilege is removed from the token

    If Name is not a valid privilege name, this will throw an
    ArgumentException.

    .EXAMPLE
    Get-AnsiblePrivilege -Name SeDebugPrivilege
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)][String]$Name
    )

    if (-not [Ansible.Privilege.PrivilegeUtil]::CheckPrivilegeName($Name)) {
        throw [System.ArgumentException] "Invalid privilege name '$Name'"
    }

    $process_token = [Ansible.Privilege.PrivilegeUtil]::GetCurrentProcess()
    $privilege_info = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process_token)
    if ($privilege_info.ContainsKey($Name)) {
        $status = $privilege_info.$Name
        return $status.HasFlag([Ansible.Privilege.PrivilegeAttributes]::Enabled)
    } else {
        return $null
    }
}

Function Set-AnsiblePrivilege {
    <#
    .SYNOPSIS
    Enables/Disables a privilege on the current process' token. If a privilege
    has been removed from the process token, this will throw an
    InvalidOperationException.

    .EXAMPLE
    # enable a privilege
    Set-AnsiblePrivilege -Name SeCreateSymbolicLinkPrivilege -Value $true

    # disable a privilege
    Set-AnsiblePrivilege -Name SeCreateSymbolicLinkPrivilege -Value $false
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory=$true)][String]$Name,
        [Parameter(Mandatory=$true)][bool]$Value
    )

    $action = switch($Value) {
        $true { "Enable" }
        $false { "Disable" }
    }

    $current_state = Get-AnsiblePrivilege -Name $Name
    if ($current_state -eq $Value) {
        return  # no change needs to occur
    } elseif ($null -eq $current_state) {
        # once a privilege is removed from a token we cannot do anything with it
        throw [System.InvalidOperationException] "Cannot $($action.ToLower()) the privilege '$Name' as it has been removed from the token"
    }

    $process_token = [Ansible.Privilege.PrivilegeUtil]::GetCurrentProcess()
    if ($PSCmdlet.ShouldProcess($Name, "$action the privilege $Name")) {
        $new_state = New-Object -TypeName 'System.Collections.Generic.Dictionary`2[[System.String], [System.Nullable`1[System.Boolean]]]'
        $new_state.Add($Name, $Value)
        [Ansible.Privilege.PrivilegeUtil]::SetTokenPrivileges($process_token, $new_state) > $null
    }
# Copyright (c) 2017 Ansible Project
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

#AnsibleRequires -CSharpUtil Ansible.Process

Function Load-CommandUtils {
    <#
    .SYNOPSIS
    No-op, as the C# types are automatically loaded.
    #>
    Param()
    $msg = "Load-CommandUtils is deprecated and no longer needed, this cmdlet will be removed in a future version"
    if ((Get-Command -Name Add-DeprecationWarning -ErrorAction SilentlyContinue) -and (Get-Variable -Name result -ErrorAction SilentlyContinue)) {
        Add-DeprecationWarning -obj $result.Value -message $msg -version 2.12
    } else {
        $module = Get-Variable -Name module -ErrorAction SilentlyContinue
        if ($null -ne $module -and $module.Value.GetType().FullName -eq "Ansible.Basic.AnsibleModule") {
            $module.Value.Deprecate($msg, "2.12")
        }
    }
}

Function Get-ExecutablePath {
    <#
    .SYNOPSIS
    Get's the full path to an executable, will search the directory specified or ones in the PATH env var.

    .PARAMETER executable
    [String]The executable to seach for.

    .PARAMETER directory
    [String] If set, the directory to search in.

    .OUTPUT
    [String] The full path the executable specified.
    #>
    Param(
        [String]$executable,
        [String]$directory = $null
    )

    # we need to add .exe if it doesn't have an extension already
    if (-not [System.IO.Path]::HasExtension($executable)) {
        $executable = "$($executable).exe"
    }
    $full_path = [System.IO.Path]::GetFullPath($executable)

    if ($full_path -ne $executable -and $directory -ne $null) {
        $file = Get-Item -LiteralPath "$directory\$executable" -Force -ErrorAction SilentlyContinue
    } else {
        $file = Get-Item -LiteralPath $executable -Force -ErrorAction SilentlyContinue
    }

    if ($null -ne $file) {
        $executable_path = $file.FullName
    } else {
        $executable_path = [Ansible.Process.ProcessUtil]::SearchPath($executable)
    }
    return $executable_path
}

Function Run-Command {
    <#
    .SYNOPSIS
    Run a command with the CreateProcess API and return the stdout/stderr and return code.

    .PARAMETER command
    The full command, including the executable, to run.

    .PARAMETER working_directory
    The working directory to set on the new process, will default to the current working dir.

    .PARAMETER stdin
    A string to sent over the stdin pipe to the new process.

    .PARAMETER environment
    A hashtable of key/value pairs to run with the command. If set, it will replace all other env vars.

    .PARAMETER output_encoding_override
    The character encoding name for decoding stdout/stderr output of the process.

    .OUTPUT
    [Hashtable]
        [String]executable - The full path to the executable that was run
        [String]stdout - The stdout stream of the process
        [String]stderr - The stderr stream of the process
        [Int32]rc - The return code of the process
    #>
    Param(
        [string]$command,
        [string]$working_directory = $null,
        [string]$stdin = "",
        [hashtable]$environment = @{},
        [string]$output_encoding_override = $null
    )

    # need to validate the working directory if it is set
    if ($working_directory) {
        # validate working directory is a valid path
        if (-not (Test-Path -LiteralPath $working_directory)) {
            throw "invalid working directory path '$working_directory'"
        }
    }

    # lpApplicationName needs to be the full path to an executable, we do this
    # by getting the executable as the first arg and then getting the full path
    $arguments = [Ansible.Process.ProcessUtil]::ParseCommandLine($command)
    $executable = Get-ExecutablePath -executable $arguments[0] -directory $working_directory

    # run the command and get the results
    $command_result = [Ansible.Process.ProcessUtil]::CreateProcess($executable, $command, $working_directory, $environment, $stdin, $output_encoding_override)

    return ,@{
        executable = $executable
        stdout = $command_result.StandardOut
        stderr = $command_result.StandardError
        rc = $command_result.ExitCode
    }
}

#!/usr/bin/env pwsh
param (
    [Switch]
    $IsContainer
)

#Requires -Version 6

Set-StrictMode -Version 2.0
$ErrorActionPreference = "Stop"
$ProgressPreference = 'SilentlyContinue'

Function Install-PSModule {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [String]
        $Name,

        [Parameter(Mandatory=$true)]
        [Version]
        $RequiredVersion
    )

    # In case PSGallery is down we check if the module is already installed.
    $installedModule = Get-Module -Name $Name -ListAvailable | Where-Object Version -eq $RequiredVersion
    if (-not $installedModule) {
        Install-Module -Name $Name -RequiredVersion $RequiredVersion -Scope CurrentUser
   }
}

Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
Install-PSModule -Name PSScriptAnalyzer -RequiredVersion 1.18.0

if ($IsContainer) {
    # PSScriptAnalyzer contain lots of json files for the UseCompatibleCommands check. We don't use this rule so by
    # removing the contents we can save 200MB in the docker image (or more in the future).
    # https://github.com/PowerShell/PSScriptAnalyzer/blob/master/RuleDocumentation/UseCompatibleCommands.md
    $pssaPath = (Get-Module -ListAvailable -Name PSScriptAnalyzer).ModuleBase
    $compatPath = Join-Path -Path $pssaPath -ChildPath compatibility_profiles -AdditionalChildPath '*'
#!/usr/bin/env pwsh
#Requires -Version 6

Set-StrictMode -Version 2.0
$ErrorActionPreference = "Stop"
$WarningPreference = "Stop"

Function Resolve-CircularReference {
    <#
    .SYNOPSIS
    Removes known types that cause a circular reference in their json serialization.

    .PARAMETER Hash
    The hash to scan for circular references
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [System.Collections.IDictionary]
        $Hash
    )

    foreach ($key in [String[]]$Hash.Keys) {
        $value = $Hash[$key]
        if ($value -is [System.Collections.IDictionary]) {
            Resolve-CircularReference -Hash $value
        } elseif ($value -is [Array] -or $value -is [System.Collections.IList]) {
            $values = @(foreach ($v in $value) {
                if ($v -is [System.Collections.IDictionary]) {
                    Resolve-CircularReference -Hash $v
                }
                ,$v
            })
            $Hash[$key] = $values
        } elseif ($value -is [DateTime]) {
            $Hash[$key] = $value.ToString("yyyy-MM-dd")
        } elseif ($value -is [delegate]) {
            # Type can be set to a delegate function which defines it's own type. For the documentation we just
            # reflection that as raw
            if ($key -eq 'type') {
                $Hash[$key] = 'raw'
            } else {
                $Hash[$key] = $value.ToString()  # Shouldn't ever happen but just in case.
            }
        }
    }
}

$manifest = ConvertFrom-Json -InputObject $args[0] -AsHashtable
if (-not $manifest.Contains('module_path') -or -not $manifest.module_path) {
    Write-Error -Message "No module specified."
    exit 1
}
$module_path = $manifest.module_path

# Check if the path is relative and get the full path to the module
if (-not ([System.IO.Path]::IsPathRooted($module_path))) {
    $module_path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($module_path)
}

if (-not (Test-Path -LiteralPath $module_path -PathType Leaf)) {
    Write-Error -Message "The module at '$module_path' does not exist."
    exit 1
}

$module_code = Get-Content -LiteralPath $module_path -Raw

$powershell = [PowerShell]::Create()
$powershell.Runspace.SessionStateProxy.SetVariable("ErrorActionPreference", "Stop")

# Load the PowerShell module utils as the module may be using them to refer to shared module options. Currently we
# can only load the PowerShell utils due to cross platform compatibility issues.
if ($manifest.Contains('ps_utils')) {
    foreach ($util_info in $manifest.ps_utils.GetEnumerator()) {
        $util_name = $util_info.Key
        $util_path = $util_info.Value

        if (-not (Test-Path -LiteralPath $util_path -PathType Leaf)) {
            # Failed to find the util path, just silently ignore for now and hope for the best.
            continue
        }

        $util_sb = [ScriptBlock]::Create((Get-Content -LiteralPath $util_path -Raw))
        $powershell.AddCommand('New-Module').AddParameters(@{
            Name = $util_name
            ScriptBlock = $util_sb
        }) > $null
        $powershell.AddCommand('Import-Module').AddParameter('WarningAction', 'SilentlyContinue') > $null
        $powershell.AddCommand('Out-Null').AddStatement() > $null

        # Also import it into the current runspace in case ps_argspec.ps1 needs to use it.
        $null = New-Module -Name $util_name -ScriptBlock $util_sb | Import-Module -WarningAction SilentlyContinue
    }
}

Add-CSharpType -References @(Get-Content -LiteralPath $manifest.ansible_basic -Raw)
[Ansible.Basic.AnsibleModule]::_DebugArgSpec = $true

$powershell.AddScript($module_code) > $null
$powershell.Invoke() > $null

if ($powershell.HadErrors) {
    $powershell.Streams.Error
    exit 1
}
@{
    ExcludeRules=@(
        'PSUseOutputTypeCorrectly',
        'PSUseShouldProcessForStateChangingFunctions',
        # We send strings as plaintext so will always come across the 3 issues
        'PSAvoidUsingPlainTextForPassword',
        'PSAvoidUsingConvertToSecureStringWithPlainText',
        'PSAvoidUsingUserNameAndPassWordParams',
        # We send the module as a base64 encoded string and a BOM will cause
        # issues here
#!/usr/bin/env pwsh
#Requires -Version 6
#Requires -Modules PSScriptAnalyzer, PSSA-PSCustomUseLiteralPath

Set-StrictMode -Version 2.0
$ErrorActionPreference = "Stop"
$WarningPreference = "Stop"

# Until https://github.com/PowerShell/PSScriptAnalyzer/issues/1217 is fixed we need to import Pester if it's
# available.
if (Get-Module -Name Pester -ListAvailable -ErrorAction SilentlyContinue) {
    Import-Module -Name Pester
}

$LiteralPathRule = Import-Module -Name PSSA-PSCustomUseLiteralPath -PassThru
$LiteralPathRulePath = Join-Path -Path $LiteralPathRule.ModuleBase -ChildPath $LiteralPathRule.RootModule

$PSSAParams = @{
    CustomRulePath = @($LiteralPathRulePath)
    IncludeDefaultRules = $true
    Setting = (Join-Path -Path $PSScriptRoot -ChildPath "settings.psd1")
}

$Results = @()

ForEach ($Path in $Args) {
    $Retries = 3

    Do {
        Try {
            $Results += Invoke-ScriptAnalyzer -Path $Path @PSSAParams 3> $null
            $Retries = 0
        }
        Catch {
            If (--$Retries -le 0) {
                Throw
            }
        }
    }
    Until ($Retries -le 0)
<#
.SYNOPSIS
Designed to set a Windows host to connect to the httptester container running
on the Ansible host. This will setup the Windows host file and forward the
local ports to use this connection. This will continue to run in the background
until the script is deleted.

Run this with SSH with the -R arguments to forward ports 8080, 8443 and 8444 to the
httptester container.

.PARAMETER Hosts
A list of hostnames, delimited by '|', to add to the Windows hosts file for the
httptester container, e.g. 'ansible.host.com|secondary.host.test'.
#>
[CmdletBinding()]
param(
    [Parameter(Mandatory=$true, Position=0)][String]$Hosts
)
$Hosts = $Hosts.Split('|')

$ProgressPreference = "SilentlyContinue"
$ErrorActionPreference = "Stop"
$os_version = [Version](Get-Item -Path "$env:SystemRoot\System32\kernel32.dll").VersionInfo.ProductVersion
Write-Verbose -Message "Configuring HTTP Tester on Windows $os_version for '$($Hosts -join "', '")'"

Function Get-PmapperRuleBytes {
    <#
    .SYNOPSIS
    Create the byte values that configures a rule in the PMapper configuration
    file. This isn't really documented but because PMapper is only used for
    Server 2008 R2 we will stick to 1 version and just live with the legacy
    work for now.

    .PARAMETER ListenPort
    The port to listen on localhost, this will be forwarded to the host defined
    by ConnectAddress and ConnectPort.

    .PARAMETER ConnectAddress
    The hostname or IP to map the traffic to.

    .PARAMETER ConnectPort
    This port of ConnectAddress to map the traffic to.
    #>
    param(
        [Parameter(Mandatory=$true)][UInt16]$ListenPort,
        [Parameter(Mandatory=$true)][String]$ConnectAddress,
        [Parameter(Mandatory=$true)][Int]$ConnectPort
    )

    $connect_field = "$($ConnectAddress):$ConnectPort"
    $connect_bytes = [System.Text.Encoding]::ASCII.GetBytes($connect_field)
    $data_length = [byte]($connect_bytes.Length + 6) # size of payload minus header, length, and footer
    $port_bytes = [System.BitConverter]::GetBytes($ListenPort)

    $payload = [System.Collections.Generic.List`1[Byte]]@()
    $payload.Add([byte]16) > $null # header is \x10, means Configure Mapping rule
    $payload.Add($data_length) > $null
    $payload.AddRange($connect_bytes)
    $payload.AddRange($port_bytes)
    $payload.AddRange([byte[]]@(0, 0)) # 2 extra bytes of padding
    $payload.Add([byte]0) > $null # 0 is TCP, 1 is UDP
    $payload.Add([byte]0) > $null # 0 is Any, 1 is Internet
    $payload.Add([byte]31) > $null # footer is \x1f, means end of Configure Mapping rule

    return ,$payload.ToArray()
}

Write-Verbose -Message "Adding host file entries"
$hosts_file = "$env:SystemRoot\System32\drivers\etc\hosts"
$hosts_file_lines = [System.IO.File]::ReadAllLines($hosts_file)
$changed = $false
foreach ($httptester_host in $Hosts) {
    $host_line = "127.0.0.1 $httptester_host # ansible-test httptester"
    if ($host_line -notin $hosts_file_lines) {
        $hosts_file_lines += $host_line
        $changed = $true
    }
}
if ($changed) {
    Write-Verbose -Message "Host file is missing entries, adding missing entries"
    [System.IO.File]::WriteAllLines($hosts_file, $hosts_file_lines)
}

# forward ports
$forwarded_ports = @{
    80 = 8080
    443 = 8443
    444 = 8444
}
if ($os_version -ge [Version]"6.2") {
    Write-Verbose -Message "Using netsh to configure forwarded ports"
    foreach ($forwarded_port in $forwarded_ports.GetEnumerator()) {
        $port_set = netsh interface portproxy show v4tov4 | `
            Where-Object { $_ -match "127.0.0.1\s*$($forwarded_port.Key)\s*127.0.0.1\s*$($forwarded_port.Value)" }

        if (-not $port_set) {
            Write-Verbose -Message "Adding netsh portproxy rule for $($forwarded_port.Key) -> $($forwarded_port.Value)"
            $add_args = @(
                "interface",
                "portproxy",
                "add",
                "v4tov4",
                "listenaddress=127.0.0.1",
                "listenport=$($forwarded_port.Key)",
                "connectaddress=127.0.0.1",
                "connectport=$($forwarded_port.Value)"
            )
            $null = netsh $add_args 2>&1
        }
    }
} else {
    Write-Verbose -Message "Using Port Mapper to configure forwarded ports"
    # netsh interface portproxy doesn't work on local addresses in older
    # versions of Windows. Use custom application Port Mapper to acheive the
    # same outcome
    # http://www.analogx.com/contents/download/Network/pmapper/Freeware.htm
    $s3_url = "https://ansible-ci-files.s3.amazonaws.com/ansible-test/pmapper-1.04.exe"

    # download the Port Mapper executable to a temporary directory
    $pmapper_folder = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath ([System.IO.Path]::GetRandomFileName())
    $pmapper_exe = Join-Path -Path $pmapper_folder -ChildPath pmapper.exe
    $pmapper_config = Join-Path -Path $pmapper_folder -ChildPath pmapper.dat
    New-Item -Path $pmapper_folder -ItemType Directory > $null

    $stop = $false
    do {
        try {
            Write-Verbose -Message "Attempting download of '$s3_url'"
            (New-Object -TypeName System.Net.WebClient).DownloadFile($s3_url, $pmapper_exe)
            $stop = $true
        } catch { Start-Sleep -Second 5 }
    } until ($stop)

    # create the Port Mapper rule file that contains our forwarded ports
    $fs = [System.IO.File]::Create($pmapper_config)
    try {
        foreach ($forwarded_port in $forwarded_ports.GetEnumerator()) {
            Write-Verbose -Message "Creating forwarded port rule for $($forwarded_port.Key) -> $($forwarded_port.Value)"
            $pmapper_rule = Get-PmapperRuleBytes -ListenPort $forwarded_port.Key -ConnectAddress 127.0.0.1 -ConnectPort $forwarded_port.Value
            $fs.Write($pmapper_rule, 0, $pmapper_rule.Length)
        }
    } finally {
        $fs.Close()
    }

    Write-Verbose -Message "Starting Port Mapper '$pmapper_exe' in the background"
    $start_args = @{
        CommandLine = $pmapper_exe
        CurrentDirectory = $pmapper_folder
    }
    $res = Invoke-CimMethod -ClassName Win32_Process -MethodName Create -Arguments $start_args
    if ($res.ReturnValue -ne 0) {
        $error_msg = switch($res.ReturnValue) {
            2 { "Access denied" }
            3 { "Insufficient privilege" }
            8 { "Unknown failure" }
            9 { "Path not found" }
            21 { "Invalid parameter" }
            default { "Undefined Error: $($res.ReturnValue)" }
        }
        Write-Error -Message "Failed to start pmapper: $error_msg"
    }
    $pmapper_pid = $res.ProcessId
    Write-Verbose -Message "Port Mapper PID: $pmapper_pid"
}

Write-Verbose -Message "Wait for current script at '$PSCommandPath' to be deleted before running cleanup"
$fsw = New-Object -TypeName System.IO.FileSystemWatcher
$fsw.Path = Split-Path -Path $PSCommandPath -Parent
$fsw.Filter = Split-Path -Path $PSCommandPath -Leaf
$fsw.WaitForChanged([System.IO.WatcherChangeTypes]::Deleted, 3600000) > $null
Write-Verbose -Message "Script delete or timeout reached, cleaning up Windows httptester artifacts"

Write-Verbose -Message "Cleanup host file entries"
$hosts_file_lines = [System.IO.File]::ReadAllLines($hosts_file)
$new_lines = [System.Collections.ArrayList]@()
$changed = $false
foreach ($host_line in $hosts_file_lines) {
    if ($host_line.EndsWith("# ansible-test httptester")) {
        $changed = $true
        continue
    }
    $new_lines.Add($host_line) > $null
}
if ($changed) {
    Write-Verbose -Message "Host file has extra entries, removing extra entries"
    [System.IO.File]::WriteAllLines($hosts_file, $new_lines)
}

if ($os_version -ge [Version]"6.2") {
    Write-Verbose -Message "Cleanup of forwarded port configured in netsh"
    foreach ($forwarded_port in $forwarded_ports.GetEnumerator()) {
        $port_set = netsh interface portproxy show v4tov4 | `
            Where-Object { $_ -match "127.0.0.1\s*$($forwarded_port.Key)\s*127.0.0.1\s*$($forwarded_port.Value)" }

        if ($port_set) {
            Write-Verbose -Message "Removing netsh portproxy rule for $($forwarded_port.Key) -> $($forwarded_port.Value)"
            $delete_args = @(
                "interface",
                "portproxy",
                "delete",
                "v4tov4",
                "listenaddress=127.0.0.1",
                "listenport=$($forwarded_port.Key)"
            )
            $null = netsh $delete_args 2>&1
        }
    }
} else {
    Write-Verbose -Message "Stopping Port Mapper executable based on pid $pmapper_pid"
    Stop-Process -Id $pmapper_pid -Force

    # the process may not stop straight away, try multiple times to delete the Port Mapper folder
    $attempts = 1
    do {
        try {
            Write-Verbose -Message "Cleanup temporary files for Port Mapper at '$pmapper_folder' - Attempt: $attempts"
            Remove-Item -Path $pmapper_folder -Force -Recurse
            break
        } catch {
            Write-Verbose -Message "Cleanup temporary files for Port Mapper failed, waiting 5 seconds before trying again:$($_ | Out-String)"
            if ($attempts -ge 5) {
                break
            }
            $attempts += 1
#Requires -Version 3.0

# Configure a Windows host for remote management with Ansible
# -----------------------------------------------------------
#
# This script checks the current WinRM (PS Remoting) configuration and makes
# the necessary changes to allow Ansible to connect, authenticate and
# execute PowerShell commands.
#
# All events are logged to the Windows EventLog, useful for unattended runs.
#
# Use option -Verbose in order to see the verbose output messages.
#
# Use option -CertValidityDays to specify how long this certificate is valid
# starting from today. So you would specify -CertValidityDays 3650 to get
# a 10-year valid certificate.
#
# Use option -ForceNewSSLCert if the system has been SysPreped and a new
# SSL Certificate must be forced on the WinRM Listener when re-running this
# script. This is necessary when a new SID and CN name is created.
#
# Use option -EnableCredSSP to enable CredSSP as an authentication option.
#
# Use option -DisableBasicAuth to disable basic authentication.
#
# Use option -SkipNetworkProfileCheck to skip the network profile check.
# Without specifying this the script will only run if the device's interfaces
# are in DOMAIN or PRIVATE zones.  Provide this switch if you want to enable
# WinRM on a device with an interface in PUBLIC zone.
#
# Use option -SubjectName to specify the CN name of the certificate. This
# defaults to the system's hostname and generally should not be specified.

# Written by Trond Hindenes <trond@hindenes.com>
# Updated by Chris Church <cchurch@ansible.com>
# Updated by Michael Crilly <mike@autologic.cm>
# Updated by Anton Ouzounov <Anton.Ouzounov@careerbuilder.com>
# Updated by Nicolas Simond <contact@nicolas-simond.com>
# Updated by Dag Wiers <dag@wieers.com>
# Updated by Jordan Borean <jborean93@gmail.com>
# Updated by Erwan Qulin <erwan.quelin@gmail.com>
# Updated by David Norman <david@dkn.email>
#
# Version 1.0 - 2014-07-06
# Version 1.1 - 2014-11-11
# Version 1.2 - 2015-05-15
# Version 1.3 - 2016-04-04
# Version 1.4 - 2017-01-05
# Version 1.5 - 2017-02-09
# Version 1.6 - 2017-04-18
# Version 1.7 - 2017-11-23
# Version 1.8 - 2018-02-23
# Version 1.9 - 2018-09-21

# Support -Verbose option
[CmdletBinding()]

Param (
    [string]$SubjectName = $env:COMPUTERNAME,
    [int]$CertValidityDays = 1095,
    [switch]$SkipNetworkProfileCheck,
    $CreateSelfSignedCert = $true,
    [switch]$ForceNewSSLCert,
    [switch]$GlobalHttpFirewallAccess,
    [switch]$DisableBasicAuth = $false,
    [switch]$EnableCredSSP
)

Function Write-Log
{
    $Message = $args[0]
    Write-EventLog -LogName Application -Source $EventSource -EntryType Information -EventId 1 -Message $Message
}

Function Write-VerboseLog
{
    $Message = $args[0]
    Write-Verbose $Message
    Write-Log $Message
}

Function Write-HostLog
{
    $Message = $args[0]
    Write-Output $Message
    Write-Log $Message
}

Function New-LegacySelfSignedCert
{
    Param (
        [string]$SubjectName,
        [int]$ValidDays = 1095
    )

    $hostnonFQDN = $env:computerName
    $hostFQDN = [System.Net.Dns]::GetHostByName(($env:computerName)).Hostname
    $SignatureAlgorithm = "SHA256"

    $name = New-Object -COM "X509Enrollment.CX500DistinguishedName.1"
    $name.Encode("CN=$SubjectName", 0)

    $key = New-Object -COM "X509Enrollment.CX509PrivateKey.1"
    $key.ProviderName = "Microsoft Enhanced RSA and AES Cryptographic Provider"
    $key.KeySpec = 1
    $key.Length = 4096
    $key.SecurityDescriptor = "D:PAI(A;;0xd01f01ff;;;SY)(A;;0xd01f01ff;;;BA)(A;;0x80120089;;;NS)"
    $key.MachineContext = 1
    $key.Create()

    $serverauthoid = New-Object -COM "X509Enrollment.CObjectId.1"
    $serverauthoid.InitializeFromValue("1.3.6.1.5.5.7.3.1")
    $ekuoids = New-Object -COM "X509Enrollment.CObjectIds.1"
    $ekuoids.Add($serverauthoid)
    $ekuext = New-Object -COM "X509Enrollment.CX509ExtensionEnhancedKeyUsage.1"
    $ekuext.InitializeEncode($ekuoids)

    $cert = New-Object -COM "X509Enrollment.CX509CertificateRequestCertificate.1"
    $cert.InitializeFromPrivateKey(2, $key, "")
    $cert.Subject = $name
    $cert.Issuer = $cert.Subject
    $cert.NotBefore = (Get-Date).AddDays(-1)
    $cert.NotAfter = $cert.NotBefore.AddDays($ValidDays)

    $SigOID = New-Object -ComObject X509Enrollment.CObjectId
    $SigOID.InitializeFromValue(([Security.Cryptography.Oid]$SignatureAlgorithm).Value)

    [string[]] $AlternativeName  += $hostnonFQDN
    $AlternativeName += $hostFQDN
    $IAlternativeNames = New-Object -ComObject X509Enrollment.CAlternativeNames

    foreach ($AN in $AlternativeName)
    {
        $AltName = New-Object -ComObject X509Enrollment.CAlternativeName
        $AltName.InitializeFromString(0x3,$AN)
        $IAlternativeNames.Add($AltName)
    }

    $SubjectAlternativeName = New-Object -ComObject X509Enrollment.CX509ExtensionAlternativeNames
    $SubjectAlternativeName.InitializeEncode($IAlternativeNames)

    [String[]]$KeyUsage = ("DigitalSignature", "KeyEncipherment")
    $KeyUsageObj = New-Object -ComObject X509Enrollment.CX509ExtensionKeyUsage
    $KeyUsageObj.InitializeEncode([int][Security.Cryptography.X509Certificates.X509KeyUsageFlags]($KeyUsage))
    $KeyUsageObj.Critical = $true

    $cert.X509Extensions.Add($KeyUsageObj)
    $cert.X509Extensions.Add($ekuext)
    $cert.SignatureInformation.HashAlgorithm = $SigOID
    $CERT.X509Extensions.Add($SubjectAlternativeName)
    $cert.Encode()

    $enrollment = New-Object -COM "X509Enrollment.CX509Enrollment.1"
    $enrollment.InitializeFromRequest($cert)
    $certdata = $enrollment.CreateRequest(0)
    $enrollment.InstallResponse(2, $certdata, 0, "")

    # extract/return the thumbprint from the generated cert
    $parsed_cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
    $parsed_cert.Import([System.Text.Encoding]::UTF8.GetBytes($certdata))

    return $parsed_cert.Thumbprint
}

Function Enable-GlobalHttpFirewallAccess
{
    Write-Verbose "Forcing global HTTP firewall access"
    # this is a fairly naive implementation; could be more sophisticated about rule matching/collapsing
    $fw = New-Object -ComObject HNetCfg.FWPolicy2

    # try to find/enable the default rule first
    $add_rule = $false
    $matching_rules = $fw.Rules | Where-Object  { $_.Name -eq "Windows Remote Management (HTTP-In)" }
    $rule = $null
    If ($matching_rules) {
        If ($matching_rules -isnot [Array]) {
            Write-Verbose "Editing existing single HTTP firewall rule"
            $rule = $matching_rules
        }
        Else {
            # try to find one with the All or Public profile first
            Write-Verbose "Found multiple existing HTTP firewall rules..."
            $rule = $matching_rules | ForEach-Object { $_.Profiles -band 4 }[0]

            If (-not $rule -or $rule -is [Array]) {
                Write-Verbose "Editing an arbitrary single HTTP firewall rule (multiple existed)"
                # oh well, just pick the first one
                $rule = $matching_rules[0]
            }
        }
    }

    If (-not $rule) {
        Write-Verbose "Creating a new HTTP firewall rule"
        $rule = New-Object -ComObject HNetCfg.FWRule
        $rule.Name = "Windows Remote Management (HTTP-In)"
        $rule.Description = "Inbound rule for Windows Remote Management via WS-Management. [TCP 5985]"
        $add_rule = $true
    }

    $rule.Profiles = 0x7FFFFFFF
    $rule.Protocol = 6
    $rule.LocalPorts = 5985
    $rule.RemotePorts = "*"
    $rule.LocalAddresses = "*"
    $rule.RemoteAddresses = "*"
    $rule.Enabled = $true
    $rule.Direction = 1
    $rule.Action = 1
    $rule.Grouping = "Windows Remote Management"

    If ($add_rule) {
        $fw.Rules.Add($rule)
    }

    Write-Verbose "HTTP firewall rule $($rule.Name) updated"
}

# Setup error handling.
Trap
{
    $_
    Exit 1
}
$ErrorActionPreference = "Stop"

# Get the ID and security principal of the current user account
$myWindowsID=[System.Security.Principal.WindowsIdentity]::GetCurrent()
$myWindowsPrincipal=new-object System.Security.Principal.WindowsPrincipal($myWindowsID)

# Get the security principal for the Administrator role
$adminRole=[System.Security.Principal.WindowsBuiltInRole]::Administrator

# Check to see if we are currently running "as Administrator"
if (-Not $myWindowsPrincipal.IsInRole($adminRole))
{
    Write-Output "ERROR: You need elevated Administrator privileges in order to run this script."
    Write-Output "       Start Windows PowerShell by using the Run as Administrator option."
    Exit 2
}

$EventSource = $MyInvocation.MyCommand.Name
If (-Not $EventSource)
{
    $EventSource = "Powershell CLI"
}

If ([System.Diagnostics.EventLog]::Exists('Application') -eq $False -or [System.Diagnostics.EventLog]::SourceExists($EventSource) -eq $False)
{
    New-EventLog -LogName Application -Source $EventSource
}

# Detect PowerShell version.
If ($PSVersionTable.PSVersion.Major -lt 3)
{
    Write-Log "PowerShell version 3 or higher is required."
    Throw "PowerShell version 3 or higher is required."
}

# Find and start the WinRM service.
Write-Verbose "Verifying WinRM service."
If (!(Get-Service "WinRM"))
{
    Write-Log "Unable to find the WinRM service."
    Throw "Unable to find the WinRM service."
}
ElseIf ((Get-Service "WinRM").Status -ne "Running")
{
    Write-Verbose "Setting WinRM service to start automatically on boot."
    Set-Service -Name "WinRM" -StartupType Automatic
    Write-Log "Set WinRM service to start automatically on boot."
    Write-Verbose "Starting WinRM service."
    Start-Service -Name "WinRM" -ErrorAction Stop
    Write-Log "Started WinRM service."

}

# WinRM should be running; check that we have a PS session config.
If (!(Get-PSSessionConfiguration -Verbose:$false) -or (!(Get-ChildItem WSMan:\localhost\Listener)))
{
  If ($SkipNetworkProfileCheck) {
    Write-Verbose "Enabling PS Remoting without checking Network profile."
    Enable-PSRemoting -SkipNetworkProfileCheck -Force -ErrorAction Stop
    Write-Log "Enabled PS Remoting without checking Network profile."
  }
  Else {
    Write-Verbose "Enabling PS Remoting."
    Enable-PSRemoting -Force -ErrorAction Stop
    Write-Log "Enabled PS Remoting."
  }
}
Else
{
    Write-Verbose "PS Remoting is already enabled."
}

# Ensure LocalAccountTokenFilterPolicy is set to 1
# https://github.com/ansible/ansible/issues/42978
$token_path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
$token_prop_name = "LocalAccountTokenFilterPolicy"
$token_key = Get-Item -Path $token_path
$token_value = $token_key.GetValue($token_prop_name, $null)
if ($token_value -ne 1) {
    Write-Verbose "Setting LocalAccountTOkenFilterPolicy to 1"
    if ($null -ne $token_value) {
        Remove-ItemProperty -Path $token_path -Name $token_prop_name
    }
    New-ItemProperty -Path $token_path -Name $token_prop_name -Value 1 -PropertyType DWORD > $null
}

# Make sure there is a SSL listener.
$listeners = Get-ChildItem WSMan:\localhost\Listener
If (!($listeners | Where-Object {$_.Keys -like "TRANSPORT=HTTPS"}))
{
    # We cannot use New-SelfSignedCertificate on 2012R2 and earlier
    $thumbprint = New-LegacySelfSignedCert -SubjectName $SubjectName -ValidDays $CertValidityDays
    Write-HostLog "Self-signed SSL certificate generated; thumbprint: $thumbprint"

    # Create the hashtables of settings to be used.
    $valueset = @{
        Hostname = $SubjectName
        CertificateThumbprint = $thumbprint
    }

    $selectorset = @{
        Transport = "HTTPS"
        Address = "*"
    }

    Write-Verbose "Enabling SSL listener."
    New-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset -ValueSet $valueset
    Write-Log "Enabled SSL listener."
}
Else
{
    Write-Verbose "SSL listener is already active."

    # Force a new SSL cert on Listener if the $ForceNewSSLCert
    If ($ForceNewSSLCert)
    {

        # We cannot use New-SelfSignedCertificate on 2012R2 and earlier
        $thumbprint = New-LegacySelfSignedCert -SubjectName $SubjectName -ValidDays $CertValidityDays
        Write-HostLog "Self-signed SSL certificate generated; thumbprint: $thumbprint"

        $valueset = @{
            CertificateThumbprint = $thumbprint
            Hostname = $SubjectName
        }

        # Delete the listener for SSL
        $selectorset = @{
            Address = "*"
            Transport = "HTTPS"
        }
        Remove-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset

        # Add new Listener with new SSL cert
        New-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset -ValueSet $valueset
    }
}

# Check for basic authentication.
$basicAuthSetting = Get-ChildItem WSMan:\localhost\Service\Auth | Where-Object {$_.Name -eq "Basic"}

If ($DisableBasicAuth)
{
    If (($basicAuthSetting.Value) -eq $true)
    {
        Write-Verbose "Disabling basic auth support."
        Set-Item -Path "WSMan:\localhost\Service\Auth\Basic" -Value $false
        Write-Log "Disabled basic auth support."
    }
    Else
    {
        Write-Verbose "Basic auth is already disabled."
    }
}
Else
{
    If (($basicAuthSetting.Value) -eq $false)
    {
        Write-Verbose "Enabling basic auth support."
        Set-Item -Path "WSMan:\localhost\Service\Auth\Basic" -Value $true
        Write-Log "Enabled basic auth support."
    }
    Else
    {
        Write-Verbose "Basic auth is already enabled."
    }
}

# If EnableCredSSP if set to true
If ($EnableCredSSP)
{
    # Check for CredSSP authentication
    $credsspAuthSetting = Get-ChildItem WSMan:\localhost\Service\Auth | Where-Object {$_.Name -eq "CredSSP"}
    If (($credsspAuthSetting.Value) -eq $false)
    {
        Write-Verbose "Enabling CredSSP auth support."
        Enable-WSManCredSSP -role server -Force
        Write-Log "Enabled CredSSP auth support."
    }
}

If ($GlobalHttpFirewallAccess) {
    Enable-GlobalHttpFirewallAccess
}

# Configure firewall to allow WinRM HTTPS connections.
$fwtest1 = netsh advfirewall firewall show rule name="Allow WinRM HTTPS"
$fwtest2 = netsh advfirewall firewall show rule name="Allow WinRM HTTPS" profile=any
If ($fwtest1.count -lt 5)
{
    Write-Verbose "Adding firewall rule to allow WinRM HTTPS."
    netsh advfirewall firewall add rule profile=any name="Allow WinRM HTTPS" dir=in localport=5986 protocol=TCP action=allow
    Write-Log "Added firewall rule to allow WinRM HTTPS."
}
ElseIf (($fwtest1.count -ge 5) -and ($fwtest2.count -lt 5))
{
    Write-Verbose "Updating firewall rule to allow WinRM HTTPS for any profile."
    netsh advfirewall firewall set rule name="Allow WinRM HTTPS" new profile=any
    Write-Log "Updated firewall rule to allow WinRM HTTPS for any profile."
}
Else
{
    Write-Verbose "Firewall rule already exists to allow WinRM HTTPS."
}

# Test a remoting connection to localhost, which should work.
$httpResult = Invoke-Command -ComputerName "localhost" -ScriptBlock {$env:COMPUTERNAME} -ErrorVariable httpError -ErrorAction SilentlyContinue
$httpsOptions = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck

$httpsResult = New-PSSession -UseSSL -ComputerName "localhost" -SessionOption $httpsOptions -ErrorVariable httpsError -ErrorAction SilentlyContinue

If ($httpResult -and $httpsResult)
{
    Write-Verbose "HTTP: Enabled | HTTPS: Enabled"
}
ElseIf ($httpsResult -and !$httpResult)
{
    Write-Verbose "HTTP: Disabled | HTTPS: Enabled"
}
ElseIf ($httpResult -and !$httpsResult)
{
    Write-Verbose "HTTP: Enabled | HTTPS: Disabled"
}
Else
{
    Write-Log "Unable to establish an HTTP or HTTPS remoting session."
#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -CSharpUtil Ansible.Service
#Requires -Module Ansible.ModuleUtils.ArgvParser
#Requires -Module Ansible.ModuleUtils.CommandUtil

$module = [Ansible.Basic.AnsibleModule]::Create($args, @{})

$path = "$env:SystemRoot\System32\svchost.exe"

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array] -or $Actual -is [System.Collections.IList]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actualValue = $Actual[$i]
            $expectedValue = $Expected[$i]
            Assert-Equals -Actual $actualValue -Expected $expectedValue
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text

        $module.FailJson("AssertionError: actual != expected")
    }
}

Function Invoke-Sc {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [String]
        $Action,

        [Parameter(Mandatory=$true)]
        [String]
        $Name,

        [Object]
        $Arguments
    )

    $commandArgs = [System.Collections.Generic.List[String]]@("sc.exe", $Action, $Name)
    if ($null -ne $Arguments) {
        if ($Arguments -is [System.Collections.IDictionary]) {
            foreach ($arg in $Arguments.GetEnumerator()) {
                $commandArgs.Add("$($arg.Key)=")
                $commandArgs.Add($arg.Value)
            }
        } else {
            foreach ($arg in $Arguments) {
                $commandArgs.Add($arg)
            }
        }
    }

    $command = Argv-ToString -arguments $commandArgs

    $res = Run-Command -command $command
    if ($res.rc -ne 0) {
        $module.Result.rc = $res.rc
        $module.Result.stdout = $res.stdout
        $module.Result.stderr = $res.stderr
        $module.FailJson("Failed to invoke sc with: $command")
    }

    $info = @{ Name = $Name }

    if ($Action -eq 'qtriggerinfo') {
        # qtriggerinfo is in a different format which requires some manual parsing from the norm.
        $info.Triggers = [System.Collections.Generic.List[PSObject]]@()
    }

    $currentKey = $null
    $qtriggerSection = @{}
    $res.stdout -split "`r`n" | Foreach-Object -Process {
        $line = $_.Trim()

        if ($Action -eq 'qtriggerinfo' -and $line -in @('START SERVICE', 'STOP SERVICE')) {
            if ($qtriggerSection.Count -gt 0) {
                $info.Triggers.Add([PSCustomObject]$qtriggerSection)
                $qtriggerSection = @{}
            }

            $qtriggerSection = @{
                Action = $line
            }
        }

        if (-not $line -or (-not $line.Contains(':') -and $null -eq $currentKey)) {
            return
        }

        $lineSplit = $line.Split(':', 2)
        if ($lineSplit.Length -eq 2) {
            $k = $lineSplit[0].Trim()
            if (-not $k) {
                $k = $currentKey
            }

            $v = $lineSplit[1].Trim()
        } else {
            $k = $currentKey
            $v = $line
        }

        if ($qtriggerSection.Count -gt 0) {
            if ($k -eq 'DATA') {
                $qtriggerSection.Data.Add($v)
            } else {
                $qtriggerSection.Type = $k
                $qtriggerSection.SubType = $v
                $qtriggerSection.Data = [System.Collections.Generic.List[String]]@()
            }
        } else {
            if ($info.ContainsKey($k)) {
                if ($info[$k] -isnot [System.Collections.Generic.List[String]]) {
                    $info[$k] = [System.Collections.Generic.List[String]]@($info[$k])
                }
                $info[$k].Add($v)
            } else {
                $currentKey = $k
                $info[$k] = $v
            }
        }
    }

    if ($qtriggerSection.Count -gt 0) {
        $info.Triggers.Add([PSCustomObject]$qtriggerSection)
    }

    [PSCustomObject]$info
}

$tests = [Ordered]@{
    "Props on service created by New-Service" = {
        $actual = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName

        $actual.ServiceName | Assert-Equals -Expected $serviceName
        $actual.ServiceType | Assert-Equals -Expected ([Ansible.Service.ServiceType]::Win32OwnProcess)
        $actual.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::DemandStart)
        $actual.ErrorControl | Assert-Equals -Expected ([Ansible.Service.ErrorControl]::Normal)
        $actual.Path | Assert-Equals -Expected ('"{0}"' -f $path)
        $actual.LoadOrderGroup | Assert-Equals -Expected ""
        $actual.DependentOn.Count | Assert-Equals -Expected 0
        $actual.Account | Assert-Equals -Expected (
            [System.Security.Principal.SecurityIdentifier]'S-1-5-18').Translate([System.Security.Principal.NTAccount]
        )
        $actual.DisplayName | Assert-Equals -Expected $serviceName
        $actual.Description | Assert-Equals -Expected $null
        $actual.FailureActions.ResetPeriod | Assert-Equals -Expected 0
        $actual.FailureActions.RebootMsg | Assert-Equals -Expected $null
        $actual.FailureActions.Command | Assert-Equals -Expected $null
        $actual.FailureActions.Actions.Count | Assert-Equals -Expected 0
        $actual.FailureActionsOnNonCrashFailures | Assert-Equals -Expected $false
        $actual.ServiceSidInfo | Assert-Equals -Expected ([Ansible.Service.ServiceSidInfo]::None)
        $actual.RequiredPrivileges.Count | Assert-Equals -Expected 0
        # Cannot test default values as it differs per OS version
        $null -ne $actual.PreShutdownTimeout | Assert-Equals -Expected $true
        $actual.Triggers.Count | Assert-Equals -Expected 0
        $actual.PreferredNode | Assert-Equals -Expected $null
        if ([Environment]::OSVersion.Version -ge [Version]'6.3') {
            $actual.LaunchProtection | Assert-Equals -Expected ([Ansible.Service.LaunchProtection]::None)
        } else {
            $actual.LaunchProtection | Assert-Equals -Expected $null
        }
        $actual.State | Assert-Equals -Expected ([Ansible.Service.ServiceStatus]::Stopped)
        $actual.Win32ExitCode | Assert-Equals -Expected 1077  # ERROR_SERVICE_NEVER_STARTED
        $actual.ServiceExitCode | Assert-Equals -Expected 0
        $actual.Checkpoint | Assert-Equals -Expected 0
        $actual.WaitHint | Assert-Equals -Expected 0
        $actual.ProcessId | Assert-Equals -Expected 0
        $actual.ServiceFlags | Assert-Equals -Expected ([Ansible.Service.ServiceFlags]::None)
        $actual.DependedBy.Count | Assert-Equals 0
    }

    "Service creation through util" = {
        $testName = "$($serviceName)_2"
        $actual = [Ansible.Service.Service]::Create($testName, '"{0}"' -f $path)

        try {
            $cmdletService = Get-Service -Name $testName -ErrorAction SilentlyContinue
            $null -ne $cmdletService | Assert-Equals -Expected $true

            $actual.ServiceName | Assert-Equals -Expected $testName
            $actual.ServiceType | Assert-Equals -Expected ([Ansible.Service.ServiceType]::Win32OwnProcess)
            $actual.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::DemandStart)
            $actual.ErrorControl | Assert-Equals -Expected ([Ansible.Service.ErrorControl]::Normal)
            $actual.Path | Assert-Equals -Expected ('"{0}"' -f $path)
            $actual.LoadOrderGroup | Assert-Equals -Expected ""
            $actual.DependentOn.Count | Assert-Equals -Expected 0
            $actual.Account | Assert-Equals -Expected (
                [System.Security.Principal.SecurityIdentifier]'S-1-5-18').Translate([System.Security.Principal.NTAccount]
            )
            $actual.DisplayName | Assert-Equals -Expected $testName
            $actual.Description | Assert-Equals -Expected $null
            $actual.FailureActions.ResetPeriod | Assert-Equals -Expected 0
            $actual.FailureActions.RebootMsg | Assert-Equals -Expected $null
            $actual.FailureActions.Command | Assert-Equals -Expected $null
            $actual.FailureActions.Actions.Count | Assert-Equals -Expected 0
            $actual.FailureActionsOnNonCrashFailures | Assert-Equals -Expected $false
            $actual.ServiceSidInfo | Assert-Equals -Expected ([Ansible.Service.ServiceSidInfo]::None)
            $actual.RequiredPrivileges.Count | Assert-Equals -Expected 0
            $null -ne $actual.PreShutdownTimeout | Assert-Equals -Expected $true
            $actual.Triggers.Count | Assert-Equals -Expected 0
            $actual.PreferredNode | Assert-Equals -Expected $null
            if ([Environment]::OSVersion.Version -ge [Version]'6.3') {
                $actual.LaunchProtection | Assert-Equals -Expected ([Ansible.Service.LaunchProtection]::None)
            } else {
                $actual.LaunchProtection | Assert-Equals -Expected $null
            }
            $actual.State | Assert-Equals -Expected ([Ansible.Service.ServiceStatus]::Stopped)
            $actual.Win32ExitCode | Assert-Equals -Expected 1077  # ERROR_SERVICE_NEVER_STARTED
            $actual.ServiceExitCode | Assert-Equals -Expected 0
            $actual.Checkpoint | Assert-Equals -Expected 0
            $actual.WaitHint | Assert-Equals -Expected 0
            $actual.ProcessId | Assert-Equals -Expected 0
            $actual.ServiceFlags | Assert-Equals -Expected ([Ansible.Service.ServiceFlags]::None)
            $actual.DependedBy.Count | Assert-Equals 0
        } finally {
            $actual.Delete()
        }
    }

    "Fail to open non-existing service" = {
        $failed = $false
        try {
            $null = New-Object -TypeName Ansible.Service.Service -ArgumentList 'fake_service'
        } catch [Ansible.Service.ServiceManagerException] {
            # 1060 == ERROR_SERVICE_DOES_NOT_EXIST
            $_.Exception.Message -like '*Win32ErrorCode 1060 - 0x00000424*' | Assert-Equals -Expected $true
            $failed = $true
        }

        $failed | Assert-Equals -Expected $true
    }

    "Open with specific access rights" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList @(
            $serviceName, [Ansible.Service.ServiceRights]'QueryConfig, QueryStatus'
        )

        # QueryStatus can get the status
        $service.State | Assert-Equals -Expected ([Ansible.Service.ServiceStatus]::Stopped)

        # Should fail to get the config because we did not request that right
        $failed = $false
        try {
            $service.Path = 'fail'
        } catch [Ansible.Service.ServiceManagerException] {
            # 5 == ERROR_ACCESS_DENIED
            $_.Exception.Message -like '*Win32ErrorCode 5 - 0x00000005*' | Assert-Equals -Expected $true
            $failed = $true
        }

        $failed | Assert-Equals -Expected $true

    }

    "Modfiy ServiceType" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.ServiceType = [Ansible.Service.ServiceType]::Win32ShareProcess

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.ServiceType | Assert-Equals -Expected ([Ansible.Service.ServiceType]::Win32ShareProcess)
        $actual.TYPE | Assert-Equals -Expected "20  WIN32_SHARE_PROCESS"

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{type="own"}
        $service.Refresh()
        $service.ServiceType | Assert-Equals -Expected ([Ansible.Service.ServiceType]::Win32OwnProcess)
    }

    "Create desktop interactive service" = {
        $service = New-Object -Typename Ansible.Service.Service -ArgumentList $serviceName
        $service.ServiceType = [Ansible.Service.ServiceType]'Win32OwnProcess, InteractiveProcess'

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $actual.TYPE | Assert-Equals -Expected "110  WIN32_OWN_PROCESS (interactive)"
        $service.ServiceType | Assert-Equals -Expected ([Ansible.Service.ServiceType]'Win32OwnProcess, InteractiveProcess')

        # Change back from interactive process
        $service.ServiceType = [Ansible.Service.ServiceType]::Win32OwnProcess

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $actual.TYPE | Assert-Equals -Expected "10  WIN32_OWN_PROCESS"
        $service.ServiceType | Assert-Equals -Expected ([Ansible.Service.ServiceType]::Win32OwnProcess)

        $service.Account = [System.Security.Principal.SecurityIdentifier]'S-1-5-20'

        $failed = $false
        try {
            $service.ServiceType = [Ansible.Service.ServiceType]'Win32OwnProcess, InteractiveProcess'
        } catch [Ansible.Service.ServiceManagerException] {
            $failed = $true
            $_.Exception.NativeErrorCode | Assert-Equals -Expected 87  # ERROR_INVALID_PARAMETER
        }
        $failed | Assert-Equals -Expected $true

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $actual.TYPE | Assert-Equals -Expected "10  WIN32_OWN_PROCESS"
    }

    "Modify StartType" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.StartType = [Ansible.Service.ServiceStartType]::Disabled

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::Disabled)
        $actual.START_TYPE | Assert-Equals -Expected "4   DISABLED"

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{start="demand"}
        $service.Refresh()
        $service.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::DemandStart)
    }

    "Modify StartType auto delayed" = {
        # Delayed start type is a modifier of the AutoStart type. It uses a separate config entry to define and this
        # makes sure the util does that correctly from various types and back.
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.StartType = [Ansible.Service.ServiceStartType]::Disabled  # Start from Disabled

        # Disabled -> Auto Start Delayed
        $service.StartType = [Ansible.Service.ServiceStartType]::AutoStartDelayed

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::AutoStartDelayed)
        $actual.START_TYPE | Assert-Equals -Expected "2   AUTO_START  (DELAYED)"

        # Auto Start Delayed -> Auto Start
        $service.StartType = [Ansible.Service.ServiceStartType]::AutoStart

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::AutoStart)
        $actual.START_TYPE | Assert-Equals -Expected "2   AUTO_START"

        # Auto Start -> Auto Start Delayed
        $service.StartType = [Ansible.Service.ServiceStartType]::AutoStartDelayed

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::AutoStartDelayed)
        $actual.START_TYPE | Assert-Equals -Expected "2   AUTO_START  (DELAYED)"

        # Auto Start Delayed -> Manual
        $service.StartType = [Ansible.Service.ServiceStartType]::DemandStart

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.StartType | Assert-Equals -Expected ([Ansible.Service.ServiceStartType]::DemandStart)
        $actual.START_TYPE | Assert-Equals -Expected "3   DEMAND_START"
    }

    "Modify ErrorControl" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.ErrorControl = [Ansible.Service.ErrorControl]::Severe

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.ErrorControl | Assert-Equals -Expected ([Ansible.Service.ErrorControl]::Severe)
        $actual.ERROR_CONTROL | Assert-Equals -Expected "2   SEVERE"

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{error="ignore"}
        $service.Refresh()
        $service.ErrorControl | Assert-Equals -Expected ([Ansible.Service.ErrorControl]::Ignore)
    }

    "Modify Path" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.Path = "Fake path"

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.Path | Assert-Equals -Expected "Fake path"
        $actual.BINARY_PATH_NAME | Assert-Equals -Expected "Fake path"

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{binpath="other fake path"}
        $service.Refresh()
        $service.Path | Assert-Equals -Expected "other fake path"
    }

    "Modify LoadOrderGroup" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.LoadOrderGroup = "my group"

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.LoadOrderGroup | Assert-Equals -Expected "my group"
        $actual.LOAD_ORDER_GROUP | Assert-Equals -Expected "my group"

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{group=""}
        $service.Refresh()
        $service.LoadOrderGroup | Assert-Equals -Expected ""
    }

    "Modify DependentOn" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.DependentOn = @("HTTP", "WinRM")

        $actual = Invoke-Sc -Action qc -Name $serviceName
        @(,$service.DependentOn) | Assert-Equals -Expected @("HTTP", "WinRM")
        @(,$actual.DEPENDENCIES) | Assert-Equals -Expected @("HTTP", "WinRM")

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{depend=""}
        $service.Refresh()
        $service.DependentOn.Count | Assert-Equals -Expected 0
    }

    "Modify Account - service account" = {
        $systemSid = [System.Security.Principal.SecurityIdentifier]'S-1-5-18'
        $systemName =$systemSid.Translate([System.Security.Principal.NTAccount])
        $localSid = [System.Security.Principal.SecurityIdentifier]'S-1-5-19'
        $localName = $localSid.Translate([System.Security.Principal.NTAccount])
        $networkSid = [System.Security.Principal.SecurityIdentifier]'S-1-5-20'
        $networkName = $networkSid.Translate([System.Security.Principal.NTAccount])

        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.Account = $networkSid

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.Account | Assert-Equals -Expected $networkName
        $actual.SERVICE_START_NAME | Assert-Equals -Expected $networkName.Value

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{obj=$localName.Value}
        $service.Refresh()
        $service.Account | Assert-Equals -Expected $localName

        $service.Account = $systemSid
        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.Account | Assert-Equals -Expected $systemName
        $actual.SERVICE_START_NAME | Assert-Equals -Expected "LocalSystem"
    }

    "Modify Account - user" = {
        $currentSid = [System.Security.Principal.WindowsIdentity]::GetCurrent().User

        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.Account = $currentSid
        $service.Password = 'password'

        $actual = Invoke-Sc -Action qc -Name $serviceName

        # When running tests in CI this seems to become .\Administrator
        if ($service.Account.Value.StartsWith('.\')) {
            $username = $service.Account.Value.Substring(2, $service.Account.Value.Length - 2)
            $actualSid = ([System.Security.Principal.NTAccount]"$env:COMPUTERNAME\$username").Translate(
                [System.Security.Principal.SecurityIdentifier]
            )
        } else {
            $actualSid = $service.Account.Translate([System.Security.Principal.SecurityIdentifier])
        }
        $actualSid.Value | Assert-Equals -Expected $currentSid.Value
        $actual.SERVICE_START_NAME | Assert-Equals -Expected $service.Account.Value

        # Go back to SYSTEM from account
        $systemSid = [System.Security.Principal.SecurityIdentifier]'S-1-5-18'
        $service.Account = $systemSid

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.Account | Assert-Equals -Expected $systemSid.Translate([System.Security.Principal.NTAccount])
        $actual.SERVICE_START_NAME | Assert-Equals -Expected "LocalSystem"
    }

    "Modify Account - virtual account" = {
        $account = [System.Security.Principal.NTAccount]"NT SERVICE\$serviceName"

        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.Account = $account

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.Account | Assert-Equals -Expected $account
        $actual.SERVICE_START_NAME | Assert-Equals -Expected $account.Value
    }

    "Modify Account - gMSA" = {
        # This cannot be tested through CI, only done on manual tests.
        return

        $gmsaName = [System.Security.Principal.NTAccount]'gMSA$@DOMAIN.LOCAL'  # Make sure this is UPN.
        $gmsaSid = $gmsaName.Translate([System.Security.Principal.SecurityIdentifier])
        $gmsaNetlogon = $gmsaSid.Translate([System.Security.Principal.NTAccount])

        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.Account = $gmsaName

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.Account | Assert-Equals -Expected $gmsaName
        $actual.SERVICE_START_NAME | Assert-Equals -Expected $gmsaName

        # Go from gMSA to account and back to verify the Password doesn't matter.
        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().User
        $service.Account = $currentUser
        $service.Password = 'fake password'
        $service.Password = 'fake password2'

        # Now test in the Netlogon format.
        $service.Account = $gmsaSid

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.Account | Assert-Equals -Expected $gmsaNetlogon
        $actual.SERVICE_START_NAME | Assert-Equals -Expected $gmsaNetlogon.Value
    }

    "Modify DisplayName" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.DisplayName = "Custom Service Name"

        $actual = Invoke-Sc -Action qc -Name $serviceName
        $service.DisplayName | Assert-Equals -Expected "Custom Service Name"
        $actual.DISPLAY_NAME | Assert-Equals -Expected "Custom Service Name"

        $null = Invoke-Sc -Action config -Name $serviceName -Arguments @{displayname="New Service Name"}
        $service.Refresh()
        $service.DisplayName | Assert-Equals -Expected "New Service Name"
    }

    "Modify Description" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.Description = "My custom service description"

        $actual = Invoke-Sc -Action qdescription -Name $serviceName
        $service.Description | Assert-Equals -Expected "My custom service description"
        $actual.DESCRIPTION | Assert-Equals -Expected "My custom service description"

        $null = Invoke-Sc -Action description -Name $serviceName -Arguments @(,"new description")
        $service.Description | Assert-Equals -Expected "new description"

        $service.Description = $null

        $actual = Invoke-Sc -Action qdescription -Name $serviceName
        $service.Description | Assert-Equals -Expected $null
        $actual.DESCRIPTION | Assert-Equals -Expected ""
    }

    "Modify FailureActions" = {
        $newAction = [Ansible.Service.FailureActions]@{
            ResetPeriod = 86400
            RebootMsg = 'Reboot msg'
            Command = 'Command line'
            Actions = @(
                [Ansible.Service.Action]@{Type = [Ansible.Service.FailureAction]::RunCommand; Delay = 1000},
                [Ansible.Service.Action]@{Type = [Ansible.Service.FailureAction]::RunCommand; Delay = 2000},
                [Ansible.Service.Action]@{Type = [Ansible.Service.FailureAction]::Restart; Delay = 1000},
                [Ansible.Service.Action]@{Type = [Ansible.Service.FailureAction]::Reboot; Delay = 1000}
            )
        }
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.FailureActions = $newAction

        $actual = Invoke-Sc -Action qfailure -Name $serviceName
        $actual.'RESET_PERIOD (in seconds)' | Assert-Equals -Expected 86400
        $actual.REBOOT_MESSAGE | Assert-Equals -Expected 'Reboot msg'
        $actual.COMMAND_LINE | Assert-Equals -Expected 'Command line'
        $actual.FAILURE_ACTIONS.Count | Assert-Equals -Expected 4
        $actual.FAILURE_ACTIONS[0] | Assert-Equals -Expected "RUN PROCESS -- Delay = 1000 milliseconds."
        $actual.FAILURE_ACTIONS[1] | Assert-Equals -Expected "RUN PROCESS -- Delay = 2000 milliseconds."
        $actual.FAILURE_ACTIONS[2] | Assert-Equals -Expected "RESTART -- Delay = 1000 milliseconds."
        $actual.FAILURE_ACTIONS[3] | Assert-Equals -Expected "REBOOT -- Delay = 1000 milliseconds."
        $service.FailureActions.Actions.Count | Assert-Equals -Expected 4

        # Test that we can change individual settings and it doesn't change all
        $service.FailureActions = [Ansible.Service.FailureActions]@{ResetPeriod = 172800}

        $actual = Invoke-Sc -Action qfailure -Name $serviceName
        $actual.'RESET_PERIOD (in seconds)' | Assert-Equals -Expected 172800
        $actual.REBOOT_MESSAGE | Assert-Equals -Expected 'Reboot msg'
        $actual.COMMAND_LINE | Assert-Equals -Expected 'Command line'
        $actual.FAILURE_ACTIONS.Count | Assert-Equals -Expected 4
        $service.FailureActions.Actions.Count | Assert-Equals -Expected 4

        $service.FailureActions = [Ansible.Service.FailureActions]@{RebootMsg = "New reboot msg"}

        $actual = Invoke-Sc -Action qfailure -Name $serviceName
        $actual.'RESET_PERIOD (in seconds)' | Assert-Equals -Expected 172800
        $actual.REBOOT_MESSAGE | Assert-Equals -Expected 'New reboot msg'
        $actual.COMMAND_LINE | Assert-Equals -Expected 'Command line'
        $actual.FAILURE_ACTIONS.Count | Assert-Equals -Expected 4
        $service.FailureActions.Actions.Count | Assert-Equals -Expected 4

        $service.FailureActions = [Ansible.Service.FailureActions]@{Command = "New command line"}

        $actual = Invoke-Sc -Action qfailure -Name $serviceName
        $actual.'RESET_PERIOD (in seconds)' | Assert-Equals -Expected 172800
        $actual.REBOOT_MESSAGE | Assert-Equals -Expected 'New reboot msg'
        $actual.COMMAND_LINE | Assert-Equals -Expected 'New command line'
        $actual.FAILURE_ACTIONS.Count | Assert-Equals -Expected 4
        $service.FailureActions.Actions.Count | Assert-Equals -Expected 4

        # Test setting both ResetPeriod and Actions together
        $service.FailureActions = [Ansible.Service.FailureActions]@{
            ResetPeriod = 86400
            Actions = @(
                [Ansible.Service.Action]@{Type = [Ansible.Service.FailureAction]::RunCommand; Delay = 5000},
                [Ansible.Service.Action]@{Type = [Ansible.Service.FailureAction]::None; Delay = 0}
            )
        }

        $actual = Invoke-Sc -Action qfailure -Name $serviceName
        $actual.'RESET_PERIOD (in seconds)' | Assert-Equals -Expected 86400
        $actual.REBOOT_MESSAGE | Assert-Equals -Expected 'New reboot msg'
        $actual.COMMAND_LINE | Assert-Equals -Expected 'New command line'
        # sc.exe does not show the None action it just ends the list, so we verify from get_FailureActions
        $actual.FAILURE_ACTIONS | Assert-Equals -Expected "RUN PROCESS -- Delay = 5000 milliseconds."
        $service.FailureActions.Actions.Count | Assert-Equals -Expected 2
        $service.FailureActions.Actions[1].Type | Assert-Equals -Expected ([Ansible.Service.FailureAction]::None)

        # Test setting just Actions without ResetPeriod
        $service.FailureActions = [Ansible.Service.FailureActions]@{
            Actions = [Ansible.Service.Action]@{Type = [Ansible.Service.FailureAction]::RunCommand; Delay = 10000}
        }
        $actual = Invoke-Sc -Action qfailure -Name $serviceName
        $actual.'RESET_PERIOD (in seconds)' | Assert-Equals -Expected 86400
        $actual.REBOOT_MESSAGE | Assert-Equals -Expected 'New reboot msg'
        $actual.COMMAND_LINE | Assert-Equals -Expected 'New command line'
        $actual.FAILURE_ACTIONS | Assert-Equals -Expected "RUN PROCESS -- Delay = 10000 milliseconds."
        $service.FailureActions.Actions.Count | Assert-Equals -Expected 1

        # Test removing all actions
        $service.FailureActions = [Ansible.Service.FailureActions]@{
            Actions = @()
        }
        $actual = Invoke-Sc -Action qfailure -Name $serviceName
        $actual.'RESET_PERIOD (in seconds)' | Assert-Equals -Expected 0  # ChangeServiceConfig2W resets this back to 0.
        $actual.REBOOT_MESSAGE | Assert-Equals -Expected 'New reboot msg'
        $actual.COMMAND_LINE | Assert-Equals -Expected 'New command line'
        $actual.PSObject.Properties.Name.Contains('FAILURE_ACTIONS') | Assert-Equals -Expected $false
        $service.FailureActions.Actions.Count | Assert-Equals -Expected 0

        # Test that we are reading the right values
        $null = Invoke-Sc -Action failure -Name $serviceName -Arguments @{
            reset = 172800
            reboot = "sc reboot msg"
            command = "sc command line"
            actions = "run/5000/reboot/800"
        }

        $actual = $service.FailureActions
        $actual.ResetPeriod | Assert-Equals -Expected 172800
        $actual.RebootMsg | Assert-Equals -Expected "sc reboot msg"
        $actual.Command | Assert-Equals -Expected "sc command line"
        $actual.Actions.Count | Assert-Equals -Expected 2
        $actual.Actions[0].Type | Assert-Equals -Expected ([Ansible.Service.FailureAction]::RunCommand)
        $actual.Actions[0].Delay | Assert-Equals -Expected 5000
        $actual.Actions[1].Type | Assert-Equals -Expected ([Ansible.Service.FailureAction]::Reboot)
        $actual.Actions[1].Delay | Assert-Equals -Expected 800
    }

    "Modify FailureActionsOnNonCrashFailures" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.FailureActionsOnNonCrashFailures = $true

        $actual = Invoke-Sc -Action qfailureflag -Name $serviceName
        $service.FailureActionsOnNonCrashFailures | Assert-Equals -Expected $true
        $actual.FAILURE_ACTIONS_ON_NONCRASH_FAILURES | Assert-Equals -Expected "TRUE"

        $null = Invoke-Sc -Action failureflag -Name $serviceName -Arguments @(,0)
        $service.FailureActionsOnNonCrashFailures | Assert-Equals -Expected $false
    }

    "Modify ServiceSidInfo" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.ServiceSidInfo = [Ansible.Service.ServiceSidInfo]::None

        $actual = Invoke-Sc -Action qsidtype -Name $serviceName
        $service.ServiceSidInfo | Assert-Equals -Expected ([Ansible.Service.ServiceSidInfo]::None)
        $actual.SERVICE_SID_TYPE | Assert-Equals -Expected 'NONE'

        $null = Invoke-Sc -Action sidtype -Name $serviceName -Arguments @(,'unrestricted')
        $service.ServiceSidInfo | Assert-Equals -Expected ([Ansible.Service.ServiceSidInfo]::Unrestricted)

        $service.ServiceSidInfo = [Ansible.Service.ServiceSidInfo]::Restricted

        $actual = Invoke-Sc -Action qsidtype -Name $serviceName
        $service.ServiceSidInfo | Assert-Equals -Expected ([Ansible.Service.ServiceSidInfo]::Restricted)
        $actual.SERVICE_SID_TYPE | Assert-Equals -Expected 'RESTRICTED'
    }

    "Modify RequiredPrivileges" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.RequiredPrivileges = @("SeBackupPrivilege", "SeTcbPrivilege")

        $actual = Invoke-Sc -Action qprivs -Name $serviceName
        ,$service.RequiredPrivileges | Assert-Equals -Expected @("SeBackupPrivilege", "SeTcbPrivilege")
        ,$actual.PRIVILEGES | Assert-Equals -Expected @("SeBackupPrivilege", "SeTcbPrivilege")

        # Ensure setting to $null is the same as an empty array
        $service.RequiredPrivileges = $null

        $actual = Invoke-Sc -Action qprivs -Name $serviceName
        ,$service.RequiredPrivileges | Assert-Equals -Expected @()
        ,$actual.PRIVILEGES | Assert-Equals -Expected @()

        $service.RequiredPrivileges = @("SeBackupPrivilege", "SeTcbPrivilege")
        $service.RequiredPrivileges = @()

        $actual = Invoke-Sc -Action qprivs -Name $serviceName
        ,$service.RequiredPrivileges | Assert-Equals -Expected @()
        ,$actual.PRIVILEGES | Assert-Equals -Expected @()

        $null = Invoke-Sc -Action privs -Name $serviceName -Arguments @(,"SeCreateTokenPrivilege/SeRestorePrivilege")
        ,$service.RequiredPrivileges | Assert-Equals -Expected @("SeCreateTokenPrivilege", "SeRestorePrivilege")
    }

    "Modify PreShutdownTimeout" = {
        $service = New-Object -TypeName Ansible.Service.Service -ArgumentList $serviceName
        $service.PreShutdownTimeout = 60000

        # sc.exe doesn't seem to have a query argument for this, just get it from the registry
        $actual = (
            Get-ItemProperty -LiteralPath "HKLM:\SYSTEM\CurrentControlSet\Services\$serviceName" -Name PreshutdownTimeout
        ).PreshutdownTimeout
        $actual | Assert-Equals -Expected 60000
    }

    "Modify Triggers" = {
        $service = [Ansible.Service.Service]$serviceName
        $service.Triggers = @(
            [Ansible.Service.Trigger]@{
                Type = [Ansible.Service.TriggerType]::DomainJoin
                Action = [Ansible.Service.TriggerAction]::ServiceStop
                SubType = [Guid][Ansible.Service.Trigger]::DOMAIN_JOIN_GUID
            },
            [Ansible.Service.Trigger]@{
                Type = [Ansible.Service.TriggerType]::NetworkEndpoint
                Action = [Ansible.Service.TriggerAction]::ServiceStart
                SubType = [Guid][Ansible.Service.Trigger]::NAMED_PIPE_EVENT_GUID
                DataItems = [Ansible.Service.TriggerItem]@{
                    Type = [Ansible.Service.TriggerDataType]::String
                    Data = 'my named pipe'
                }
            },
            [Ansible.Service.Trigger]@{
                Type = [Ansible.Service.TriggerType]::NetworkEndpoint
                Action = [Ansible.Service.TriggerAction]::ServiceStart
                SubType = [Guid][Ansible.Service.Trigger]::NAMED_PIPE_EVENT_GUID
                DataItems = [Ansible.Service.TriggerItem]@{
                    Type = [Ansible.Service.TriggerDataType]::String
                    Data = 'my named pipe 2'
                }
            },
            [Ansible.Service.Trigger]@{
                Type = [Ansible.Service.TriggerType]::Custom
                Action = [Ansible.Service.TriggerAction]::ServiceStart
                SubType = [Guid]'9bf04e57-05dc-4914-9ed9-84bf992db88c'
                DataItems = @(
                    [Ansible.Service.TriggerItem]@{
                        Type = [Ansible.Service.TriggerDataType]::Binary
                        Data = [byte[]]@(1, 2, 3, 4)
                    },
                    [Ansible.Service.TriggerItem]@{
                        Type = [Ansible.Service.TriggerDataType]::Binary
                        Data = [byte[]]@(5, 6, 7, 8, 9)
                    }
                )
            }
            [Ansible.Service.Trigger]@{
                Type = [Ansible.Service.TriggerType]::Custom
                Action = [Ansible.Service.TriggerAction]::ServiceStart
                SubType = [Guid]'9fbcfc7e-7581-4d46-913b-53bb15c80c51'
                DataItems = @(
                    [Ansible.Service.TriggerItem]@{
                        Type = [Ansible.Service.TriggerDataType]::String
                        Data = 'entry 1'
                    },
                    [Ansible.Service.TriggerItem]@{
                        Type = [Ansible.Service.TriggerDataType]::String
                        Data = 'entry 2'
                    }
                )
            },
            [Ansible.Service.Trigger]@{
                Type = [Ansible.Service.TriggerType]::FirewallPortEvent
                Action = [Ansible.Service.TriggerAction]::ServiceStop
                SubType = [Guid][Ansible.Service.Trigger]::FIREWALL_PORT_CLOSE_GUID
                DataItems = [Ansible.Service.TriggerItem]@{
                    Type = [Ansible.Service.TriggerDataType]::String
                    Data = [System.Collections.Generic.List[String]]@("1234", "tcp", "imagepath", "servicename")
                }
            }
        )

        $actual = Invoke-Sc -Action qtriggerinfo -Name $serviceName

        $actual.Triggers.Count | Assert-Equals -Expected 6
        $actual.Triggers[0].Type | Assert-Equals -Expected 'DOMAIN JOINED STATUS'
        $actual.Triggers[0].Action | Assert-Equals -Expected 'STOP SERVICE'
        $actual.Triggers[0].SubType | Assert-Equals -Expected "$([Ansible.Service.Trigger]::DOMAIN_JOIN_GUID) [DOMAIN JOINED]"
        $actual.Triggers[0].Data.Count | Assert-Equals -Expected 0

        $actual.Triggers[1].Type | Assert-Equals -Expected 'NETWORK EVENT'
        $actual.Triggers[1].Action | Assert-Equals -Expected 'START SERVICE'
        $actual.Triggers[1].SubType | Assert-Equals -Expected "$([Ansible.Service.Trigger]::NAMED_PIPE_EVENT_GUID) [NAMED PIPE EVENT]"
        $actual.Triggers[1].Data.Count | Assert-Equals -Expected 1
        $actual.Triggers[1].Data[0] | Assert-Equals -Expected 'my named pipe'

        $actual.Triggers[2].Type | Assert-Equals -Expected 'NETWORK EVENT'
        $actual.Triggers[2].Action | Assert-Equals -Expected 'START SERVICE'
        $actual.Triggers[2].SubType | Assert-Equals -Expected "$([Ansible.Service.Trigger]::NAMED_PIPE_EVENT_GUID) [NAMED PIPE EVENT]"
        $actual.Triggers[2].Data.Count | Assert-Equals -Expected 1
        $actual.Triggers[2].Data[0] | Assert-Equals -Expected 'my named pipe 2'

        $actual.Triggers[3].Type | Assert-Equals -Expected 'CUSTOM'
        $actual.Triggers[3].Action | Assert-Equals -Expected 'START SERVICE'
        $actual.Triggers[3].SubType | Assert-Equals -Expected '9bf04e57-05dc-4914-9ed9-84bf992db88c [ETW PROVIDER UUID]'
        $actual.Triggers[3].Data.Count | Assert-Equals -Expected 2
        $actual.Triggers[3].Data[0] | Assert-Equals -Expected '01 02 03 04'
        $actual.Triggers[3].Data[1] | Assert-Equals -Expected '05 06 07 08 09'

        $actual.Triggers[4].Type | Assert-Equals -Expected 'CUSTOM'
        $actual.Triggers[4].Action | Assert-Equals -Expected 'START SERVICE'
        $actual.Triggers[4].SubType | Assert-Equals -Expected '9fbcfc7e-7581-4d46-913b-53bb15c80c51 [ETW PROVIDER UUID]'
        $actual.Triggers[4].Data.Count | Assert-Equals -Expected 2
        $actual.Triggers[4].Data[0] | Assert-Equals -Expected "entry 1"
        $actual.Triggers[4].Data[1] | Assert-Equals -Expected "entry 2"

        $actual.Triggers[5].Type | Assert-Equals -Expected 'FIREWALL PORT EVENT'
        $actual.Triggers[5].Action | Assert-Equals -Expected 'STOP SERVICE'
        $actual.Triggers[5].SubType | Assert-Equals -Expected "$([Ansible.Service.Trigger]::FIREWALL_PORT_CLOSE_GUID) [PORT CLOSE]"
        $actual.Triggers[5].Data.Count | Assert-Equals -Expected 1
        $actual.Triggers[5].Data[0] | Assert-Equals -Expected '1234;tcp;imagepath;servicename'

        # Remove trigger with $null
        $service.Triggers = $null

        $actual = Invoke-Sc -Action qtriggerinfo -Name $serviceName
        $actual.Triggers.Count | Assert-Equals -Expected 0

        # Add a single trigger
        $service.Triggers = [Ansible.Service.Trigger]@{
            Type = [Ansible.Service.TriggerType]::GroupPolicy
            Action = [Ansible.Service.TriggerAction]::ServiceStart
            SubType = [Guid][Ansible.Service.Trigger]::MACHINE_POLICY_PRESENT_GUID
        }

        $actual = Invoke-Sc -Action qtriggerinfo -Name $serviceName
        $actual.Triggers.Count | Assert-Equals -Expected 1
        $actual.Triggers[0].Type | Assert-Equals -Expected 'GROUP POLICY'
        $actual.Triggers[0].Action | Assert-Equals -Expected 'START SERVICE'
        $actual.Triggers[0].SubType | Assert-Equals -Expected "$([Ansible.Service.Trigger]::MACHINE_POLICY_PRESENT_GUID) [MACHINE POLICY PRESENT]"
        $actual.Triggers[0].Data.Count | Assert-Equals -Expected 0

        # Remove trigger with empty list
        $service.Triggers = @()

        $actual = Invoke-Sc -Action qtriggerinfo -Name $serviceName
        $actual.Triggers.Count | Assert-Equals -Expected 0

        # Add triggers through sc and check we get the values correctly
        $null = Invoke-Sc -Action triggerinfo -Name $serviceName -Arguments @(
            'start/namedpipe/abc',
            'start/namedpipe/def',
            'start/custom/d4497e12-ac36-4823-af61-92db0dbd4a76/11223344/aabbccdd',
            'start/strcustom/435a1742-22c5-4234-9db3-e32dafde695c/11223344/aabbccdd',
            'stop/portclose/1234;tcp;imagepath;servicename',
            'stop/networkoff'
        )

        $actual = $service.Triggers
        $actual.Count | Assert-Equals -Expected 6

        $actual[0].Type | Assert-Equals -Expected ([Ansible.Service.TriggerType]::NetworkEndpoint)
        $actual[0].Action | Assert-Equals -Expected ([Ansible.Service.TriggerAction]::ServiceStart)
        $actual[0].SubType = [Guid][Ansible.Service.Trigger]::NAMED_PIPE_EVENT_GUID
        $actual[0].DataItems.Count | Assert-Equals -Expected 1
        $actual[0].DataItems[0].Type | Assert-Equals -Expected ([Ansible.Service.TriggerDataType]::String)
        $actual[0].DataItems[0].Data | Assert-Equals -Expected 'abc'

        $actual[1].Type | Assert-Equals -Expected ([Ansible.Service.TriggerType]::NetworkEndpoint)
        $actual[1].Action | Assert-Equals -Expected ([Ansible.Service.TriggerAction]::ServiceStart)
        $actual[1].SubType = [Guid][Ansible.Service.Trigger]::NAMED_PIPE_EVENT_GUID
        $actual[1].DataItems.Count | Assert-Equals -Expected 1
        $actual[1].DataItems[0].Type | Assert-Equals -Expected ([Ansible.Service.TriggerDataType]::String)
        $actual[1].DataItems[0].Data | Assert-Equals -Expected 'def'

        $actual[2].Type | Assert-Equals -Expected ([Ansible.Service.TriggerType]::Custom)
        $actual[2].Action | Assert-Equals -Expected ([Ansible.Service.TriggerAction]::ServiceStart)
        $actual[2].SubType = [Guid]'d4497e12-ac36-4823-af61-92db0dbd4a76'
        $actual[2].DataItems.Count | Assert-Equals -Expected 2
        $actual[2].DataItems[0].Type | Assert-Equals -Expected ([Ansible.Service.TriggerDataType]::Binary)
        ,$actual[2].DataItems[0].Data | Assert-Equals -Expected ([byte[]]@(17, 34, 51, 68))
        $actual[2].DataItems[1].Type | Assert-Equals -Expected ([Ansible.Service.TriggerDataType]::Binary)
        ,$actual[2].DataItems[1].Data | Assert-Equals -Expected ([byte[]]@(170, 187, 204, 221))

        $actual[3].Type | Assert-Equals -Expected ([Ansible.Service.TriggerType]::Custom)
        $actual[3].Action | Assert-Equals -Expected ([Ansible.Service.TriggerAction]::ServiceStart)
        $actual[3].SubType = [Guid]'435a1742-22c5-4234-9db3-e32dafde695c'
        $actual[3].DataItems.Count | Assert-Equals -Expected 2
        $actual[3].DataItems[0].Type | Assert-Equals -Expected ([Ansible.Service.TriggerDataType]::String)
        $actual[3].DataItems[0].Data | Assert-Equals -Expected '11223344'
        $actual[3].DataItems[1].Type | Assert-Equals -Expected ([Ansible.Service.TriggerDataType]::String)
        $actual[3].DataItems[1].Data | Assert-Equals -Expected 'aabbccdd'

        $actual[4].Type | Assert-Equals -Expected ([Ansible.Service.TriggerType]::FirewallPortEvent)
        $actual[4].Action | Assert-Equals -Expected ([Ansible.Service.TriggerAction]::ServiceStop)
        $actual[4].SubType = [Guid][Ansible.Service.Trigger]::FIREWALL_PORT_CLOSE_GUID
        $actual[4].DataItems.Count | Assert-Equals -Expected 1
        $actual[4].DataItems[0].Type | Assert-Equals -Expected ([Ansible.Service.TriggerDataType]::String)
        ,$actual[4].DataItems[0].Data | Assert-Equals -Expected @('1234', 'tcp', 'imagepath', 'servicename')

        $actual[5].Type | Assert-Equals -Expected ([Ansible.Service.TriggerType]::IpAddressAvailability)
        $actual[5].Action | Assert-Equals -Expected ([Ansible.Service.TriggerAction]::ServiceStop)
        $actual[5].SubType = [Guid][Ansible.Service.Trigger]::NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
        $actual[5].DataItems.Count | Assert-Equals -Expected 0
    }

    # Cannot test PreferredNode as we can't guarantee CI is set up with NUMA support.
    # Cannot test LaunchProtection as once set we cannot remove unless rebooting
}

# setup and teardown should favour native tools to create and delete the service and not the util we are testing.
foreach ($testImpl in $tests.GetEnumerator()) {
    $serviceName = "ansible_$([System.IO.Path]::GetRandomFileName())"
    $null = New-Service -Name $serviceName -BinaryPathName ('"{0}"' -f $path) -StartupType Manual

    try {
        $test = $testImpl.Key
        &$testImpl.Value
    } finally {
        $null = Invoke-Sc -Action delete -Name $serviceName
    }
}

#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.ArgvParser

$ErrorActionPreference = 'Continue'

$params = Parse-Args $args
$exe = Get-AnsibleParam -obj $params -name "exe" -type "path" -failifempty $true

Add-Type -TypeDefinition @'
using System.IO;
using System.Threading;

namespace Ansible.Command
{
    public static class NativeUtil
    {
        public static void GetProcessOutput(StreamReader stdoutStream, StreamReader stderrStream, out string stdout, out string stderr)
        {
            var sowait = new EventWaitHandle(false, EventResetMode.ManualReset);
            var sewait = new EventWaitHandle(false, EventResetMode.ManualReset);
            string so = null, se = null;
            ThreadPool.QueueUserWorkItem((s)=>
            {
                so = stdoutStream.ReadToEnd();
                sowait.Set();
            });
            ThreadPool.QueueUserWorkItem((s) =>
            {
                se = stderrStream.ReadToEnd();
                sewait.Set();
            });
            foreach(var wh in new WaitHandle[] { sowait, sewait })
                wh.WaitOne();
            stdout = so;
            stderr = se;
        }
    }
}
'@

Function Invoke-Process($executable, $arguments) {
    $proc = New-Object System.Diagnostics.Process
    $psi = $proc.StartInfo
    $psi.FileName = $executable
    $psi.Arguments = $arguments
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError = $true
    $psi.UseShellExecute = $false

    $proc.Start() > $null # will always return $true for non shell-exec cases
    $stdout = $stderr = [string] $null

    [Ansible.Command.NativeUtil]::GetProcessOutput($proc.StandardOutput, $proc.StandardError, [ref] $stdout, [ref] $stderr) > $null
    $proc.WaitForExit() > $null
    $actual_args = $stdout.Substring(0, $stdout.Length - 2) -split "`r`n"

    return $actual_args
}

$tests = @(
    @('abc', 'd', 'e'),
    @('a\\b', 'de fg', 'h'),
    @('a\"b', 'c', 'd'),
    @('a\\b c', 'd', 'e'),
    @('C:\Program Files\file\', 'arg with " quote'),
    @('ADDLOCAL="a,b,c"', '/s', 'C:\\Double\\Backslash')
)

foreach ($expected in $tests) {
    $joined_string = Argv-ToString -arguments $expected
    # We can't used CommandLineToArgvW to test this out as it seems to mangle
    # \, might be something to do with unicode but not sure...
    $actual = Invoke-Process -executable $exe -arguments $joined_string

    if ($expected.Count -ne $actual.Count) {
        $result.actual = $actual -join "`n"
        $result.expected = $expected -join "`n"
        Fail-Json -obj $result -message "Actual arg count: $($actual.Count) != Expected arg count: $($expected.Count)"
    }
    for ($i = 0; $i -lt $expected.Count; $i++) {
        $expected_arg = $expected[$i]
        $actual_arg = $actual[$i]
        if ($expected_arg -cne $actual_arg) {
            $result.actual = $actual -join "`n"
            $result.expected = $expected -join "`n"
            Fail-Json -obj $result -message "Actual arg: '$actual_arg' != Expected arg: '$expected_arg'"
        }
    }
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.AddType

$ErrorActionPreference = "Stop"

$result = @{
    changed = $false
}

Function Assert-Equals($actual, $expected) {
    if ($actual -cne $expected) {
        $call_stack = (Get-PSCallStack)[1]
        $error_msg = "AssertionError:`r`nActual: `"$actual`" != Expected: `"$expected`"`r`nLine: $($call_stack.ScriptLineNumber), Method: $($call_stack.Position.Text)"
        Fail-Json -obj $result -message $error_msg
    }
}

$code = @'
using System;

namespace Namespace1
{
    public class Class1
    {
        public static string GetString(bool error)
        {
            if (error)
                throw new Exception("error");
            return "Hello World";
        }
    }
}
'@
$res = Add-CSharpType -References $code
Assert-Equals -actual $res -expected $null

$actual = [Namespace1.Class1]::GetString($false)
Assert-Equals $actual -expected "Hello World"

try {
    [Namespace1.Class1]::GetString($true)
} catch {
    Assert-Equals ($_.Exception.ToString().Contains("at Namespace1.Class1.GetString(Boolean error)`r`n")) -expected $true
}

$code_debug = @'
using System;

namespace Namespace2
{
    public class Class2
    {
        public static string GetString(bool error)
        {
            if (error)
                throw new Exception("error");
            return "Hello World";
        }
    }
}
'@
$res = Add-CSharpType -References $code_debug -IncludeDebugInfo
Assert-Equals -actual $res -expected $null

$actual = [Namespace2.Class2]::GetString($false)
Assert-Equals $actual -expected "Hello World"

try {
    [Namespace2.Class2]::GetString($true)
} catch {
    $tmp_path = [System.IO.Path]::GetFullPath($env:TMP).ToLower()
    Assert-Equals ($_.Exception.ToString().ToLower().Contains("at namespace2.class2.getstring(boolean error) in $tmp_path")) -expected $true
    Assert-Equals ($_.Exception.ToString().Contains(".cs:line 10")) -expected $true
}

$code_tmp = @'
using System;

namespace Namespace3
{
    public class Class3
    {
        public static string GetString(bool error)
        {
            if (error)
                throw new Exception("error");
            return "Hello World";
        }
    }
}
'@
$tmp_path = $env:USERPROFILE
$res = Add-CSharpType -References $code_tmp -IncludeDebugInfo -TempPath $tmp_path -PassThru
Assert-Equals -actual $res.GetType().Name -expected "RuntimeAssembly"
Assert-Equals -actual $res.Location -expected ""
Assert-Equals -actual $res.GetTypes().Length -expected 1
Assert-Equals -actual $res.GetTypes()[0].Name -expected "Class3"

$actual = [Namespace3.Class3]::GetString($false)
Assert-Equals $actual -expected "Hello World"

try {
    [Namespace3.Class3]::GetString($true)
} catch {
    Assert-Equals ($_.Exception.ToString().ToLower().Contains("at namespace3.class3.getstring(boolean error) in $($tmp_path.ToLower())")) -expected $true
    Assert-Equals ($_.Exception.ToString().Contains(".cs:line 10")) -expected $true
}

$warning_code = @'
using System;

namespace Namespace4
{
    public class Class4
    {
        public static string GetString(bool test)
        {
            if (test)
            {
                string a = "";
            }

            return "Hello World";
        }
    }
}
'@
$failed = $false
try {
    Add-CSharpType -References $warning_code
} catch {
    $failed = $true
    Assert-Equals -actual ($_.Exception.Message.Contains("error CS0219: Warning as Error: The variable 'a' is assigned but its value is never used")) -expected $true
}
Assert-Equals -actual $failed -expected $true

Add-CSharpType -References $warning_code -IgnoreWarnings
$actual = [Namespace4.Class4]::GetString($true)
Assert-Equals -actual $actual -expected "Hello World"

$reference_1 = @'
using System;
using System.Web.Script.Serialization;

//AssemblyReference -Name System.Web.Extensions.dll

namespace Namespace5
{
    public class Class5
    {
        public static string GetString()
        {
            return "Hello World";
        }
    }
}
'@

$reference_2 = @'
using System;
using Namespace5;
using System.Management.Automation;
using System.Collections;
using System.Collections.Generic;

namespace Namespace6
{
    public class Class6
    {
        public static string GetString()
        {
            Hashtable hash = new Hashtable();
            hash["test"] = "abc";
            return Class5.GetString();
        }
    }
}
'@

Add-CSharpType -References $reference_1, $reference_2
$actual = [Namespace6.Class6]::GetString()
Assert-Equals -actual $actual -expected "Hello World"

$ignored_warning = @'
using System;

//NoWarn -Name CS0219

namespace Namespace7
{
    public class Class7
    {
        public static string GetString()
        {
            string a = "";
            return "abc";
        }
    }
}
'@
Add-CSharpType -References $ignored_warning
$actual = [Namespace7.Class7]::GetString()
Assert-Equals -actual $actual -expected "abc"

$defined_symbol = @'
using System;

namespace Namespace8
{
    public class Class8
    {
        public static string GetString()
        {
#if SYMBOL1
            string a = "symbol";
#else
            string a = "no symbol";
#endif
            return a;
        }
    }
}
'@
Add-CSharpType -References $defined_symbol -CompileSymbols "SYMBOL1"
$actual = [Namespace8.Class8]::GetString()
Assert-Equals -actual $actual -expected "symbol"

$type_accelerator = @'
using System;

//TypeAccelerator -Name AnsibleType -TypeName Class9

namespace Namespace9
{
    public class Class9
    {
        public static string GetString()
        {
            return "a";
        }
    }
}
'@
Add-CSharpType -Reference $type_accelerator
$actual = [AnsibleType]::GetString()
Assert-Equals -actual $actual -expected "a"

$missing_type_class = @'
using System;

//TypeAccelerator -Name AnsibleTypeMissing -TypeName MissingClass

namespace Namespace10
{
    public class Class10
    {
        public static string GetString()
        {
            return "b";
        }
    }
}
'@
$failed = $false
try {
    Add-CSharpType -Reference $missing_type_class
} catch {
    $failed = $true
    Assert-Equals -actual $_.Exception.Message -expected "Failed to find compiled class 'MissingClass' for custom TypeAccelerator."
}
Assert-Equals -actual $failed -expected $true

$arch_class = @'
using System;

namespace Namespace11
{
    public class Class11
    {
        public static int GetIntPtrSize()
        {
#if X86
            return 4;
#elif AMD64
            return 8;
#else
            return 0;
#endif
        }
    }
}
'@
Add-CSharpType -Reference $arch_class
#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic

$module = [Ansible.Basic.AnsibleModule]::Create($args, @{})

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actual_value = $Actual[$i]
            $expected_value = $Expected[$i]
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.failed = $true
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text
        $module.Result.msg = "AssertionError: actual != expected"

        Exit-Module
    }
}

Function Assert-DictionaryEquals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )
    $actual_keys = $Actual.Keys
    $expected_keys = $Expected.Keys

    $actual_keys.Count | Assert-Equals -Expected $expected_keys.Count
    foreach ($actual_entry in $Actual.GetEnumerator()) {
        $actual_key = $actual_entry.Key
        ($actual_key -cin $expected_keys) | Assert-Equals -Expected $true
        $actual_value = $actual_entry.Value
        $expected_value = $Expected.$actual_key

        if ($actual_value -is [System.Collections.IDictionary]) {
            $actual_value | Assert-DictionaryEquals -Expected $expected_value
        } elseif ($actual_value -is [System.Collections.ArrayList] -or $actual_value -is [Array]) {
            for ($i = 0; $i -lt $actual_value.Count; $i++) {
                $actual_entry = $actual_value[$i]
                $expected_entry = $expected_value[$i]
                if ($actual_entry -is [System.Collections.IDictionary]) {
                    $actual_entry | Assert-DictionaryEquals -Expected $expected_entry
                } else {
                    Assert-Equals -Actual $actual_entry -Expected $expected_entry
                }
            }
        } else {
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
    }
    foreach ($expected_key in $expected_keys) {
        ($expected_key -cin $actual_keys) | Assert-Equals -Expected $true
    }
}

Function Exit-Module {
    # Make sure Exit actually calls exit and not our overriden test behaviour
    [Ansible.Basic.AnsibleModule]::Exit = { param([Int32]$rc) exit $rc }
    Write-Output -InputObject (ConvertTo-Json -InputObject $module.Result -Compress -Depth 99)
    $module.ExitJson()
}

$tmpdir = $module.Tmpdir

# Override the Exit and WriteLine behaviour to throw an exception instead of exiting the module
[Ansible.Basic.AnsibleModule]::Exit = {
    param([Int32]$rc)
    $exp = New-Object -TypeName System.Exception -ArgumentList "exit: $rc"
    $exp | Add-Member -Type NoteProperty -Name Output -Value $_test_out
    throw $exp
}
[Ansible.Basic.AnsibleModule]::WriteLine = {
    param([String]$line)
    Set-Variable -Name _test_out -Scope Global -Value $line
}

$tests = @{
    "Empty spec and no options - args file" = {
        $args_file = Join-Path -Path $tmpdir -ChildPath "args-$(Get-Random).json"
        [System.IO.File]::WriteAllText($args_file, '{ "ANSIBLE_MODULE_ARGS": {} }')
        $m = [Ansible.Basic.AnsibleModule]::Create(@($args_file), @{})

        $m.CheckMode | Assert-Equals -Expected $false
        $m.DebugMode | Assert-Equals -Expected $false
        $m.DiffMode | Assert-Equals -Expected $false
        $m.KeepRemoteFiles | Assert-Equals -Expected $false
        $m.ModuleName | Assert-Equals -Expected "undefined win module"
        $m.NoLog | Assert-Equals -Expected $false
        $m.Verbosity | Assert-Equals -Expected 0
        $m.AnsibleVersion | Assert-Equals -Expected $null
    }

    "Empty spec and no options - complex_args" = {
        Set-Variable -Name complex_args -Scope Global -Value @{}
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        $m.CheckMode | Assert-Equals -Expected $false
        $m.DebugMode | Assert-Equals -Expected $false
        $m.DiffMode | Assert-Equals -Expected $false
        $m.KeepRemoteFiles | Assert-Equals -Expected $false
        $m.ModuleName | Assert-Equals -Expected "undefined win module"
        $m.NoLog | Assert-Equals -Expected $false
        $m.Verbosity | Assert-Equals -Expected 0
        $m.AnsibleVersion | Assert-Equals -Expected $null
    }

    "Internal param changes - args file" = {
        $m_tmpdir = Join-Path -Path $tmpdir -ChildPath "moduletmpdir-$(Get-Random)"
        New-Item -Path $m_tmpdir -ItemType Directory > $null
        $args_file = Join-Path -Path $tmpdir -ChildPath "args-$(Get-Random).json"
        [System.IO.File]::WriteAllText($args_file, @"
{
    "ANSIBLE_MODULE_ARGS": {
        "_ansible_check_mode": true,
        "_ansible_debug": true,
        "_ansible_diff": true,
        "_ansible_keep_remote_files": true,
        "_ansible_module_name": "ansible_basic_tests",
        "_ansible_no_log": true,
        "_ansible_remote_tmp": "%TEMP%",
        "_ansible_selinux_special_fs": "ignored",
        "_ansible_shell_executable": "ignored",
        "_ansible_socket": "ignored",
        "_ansible_syslog_facility": "ignored",
        "_ansible_tmpdir": "$($m_tmpdir -replace "\\", "\\")",
        "_ansible_verbosity": 3,
        "_ansible_version": "2.8.0"
    }
}
"@)
        $m = [Ansible.Basic.AnsibleModule]::Create(@($args_file), @{supports_check_mode=$true})
        $m.CheckMode | Assert-Equals -Expected $true
        $m.DebugMode | Assert-Equals -Expected $true
        $m.DiffMode | Assert-Equals -Expected $true
        $m.KeepRemoteFiles | Assert-Equals -Expected $true
        $m.ModuleName | Assert-Equals -Expected "ansible_basic_tests"
        $m.NoLog | Assert-Equals -Expected $true
        $m.Verbosity | Assert-Equals -Expected 3
        $m.AnsibleVersion | Assert-Equals -Expected "2.8.0"
        $m.Tmpdir | Assert-Equals -Expected $m_tmpdir
    }

    "Internal param changes - complex_args" = {
        $m_tmpdir = Join-Path -Path $tmpdir -ChildPath "moduletmpdir-$(Get-Random)"
        New-Item -Path $m_tmpdir -ItemType Directory > $null
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_check_mode = $true
            _ansible_debug = $true
            _ansible_diff = $true
            _ansible_keep_remote_files = $true
            _ansible_module_name = "ansible_basic_tests"
            _ansible_no_log = $true
            _ansible_remote_tmp = "%TEMP%"
            _ansible_selinux_special_fs = "ignored"
            _ansible_shell_executable = "ignored"
            _ansible_socket = "ignored"
            _ansible_syslog_facility = "ignored"
            _ansible_tmpdir = $m_tmpdir.ToString()
            _ansible_verbosity = 3
            _ansible_version = "2.8.0"
        }
        $spec = @{
            supports_check_mode = $true
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        $m.CheckMode | Assert-Equals -Expected $true
        $m.DebugMode | Assert-Equals -Expected $true
        $m.DiffMode | Assert-Equals -Expected $true
        $m.KeepRemoteFiles | Assert-Equals -Expected $true
        $m.ModuleName | Assert-Equals -Expected "ansible_basic_tests"
        $m.NoLog | Assert-Equals -Expected $true
        $m.Verbosity | Assert-Equals -Expected 3
        $m.AnsibleVersion | Assert-Equals -Expected "2.8.0"
        $m.Tmpdir | Assert-Equals -Expected $m_tmpdir
    }

    "Parse complex module options" = {
        $spec = @{
            options = @{
                option_default = @{}
                missing_option_default = @{}
                string_option = @{type = "str"}
                required_option = @{required = $true}
                missing_choices = @{choices = "a", "b"}
                choices = @{choices = "a", "b"}
                one_choice = @{choices = ,"b"}
                choice_with_default = @{choices = "a", "b"; default = "b"}
                alias_direct = @{aliases = ,"alias_direct1"}
                alias_as_alias = @{aliases = "alias_as_alias1", "alias_as_alias2"}
                bool_type = @{type = "bool"}
                bool_from_str = @{type = "bool"}
                dict_type = @{
                    type = "dict"
                    options = @{
                        int_type = @{type = "int"}
                        str_type = @{type = "str"; default = "str_sub_type"}
                    }
                }
                dict_type_missing = @{
                    type = "dict"
                    options = @{
                        int_type = @{type = "int"}
                        str_type = @{type = "str"; default = "str_sub_type"}
                    }
                }
                dict_type_defaults = @{
                    type = "dict"
                    apply_defaults = $true
                    options = @{
                        int_type = @{type = "int"}
                        str_type = @{type = "str"; default = "str_sub_type"}
                    }
                }
                dict_type_json = @{type = "dict"}
                dict_type_str = @{type = "dict"}
                float_type = @{type = "float"}
                int_type = @{type = "int"}
                json_type = @{type = "json"}
                json_type_dict = @{type = "json"}
                list_type = @{type = "list"}
                list_type_str = @{type = "list"}
                list_with_int = @{type = "list"; elements = "int"}
                list_type_single = @{type = "list"}
                list_with_dict = @{
                    type = "list"
                    elements = "dict"
                    options = @{
                        int_type = @{type = "int"}
                        str_type = @{type = "str"; default = "str_sub_type"}
                    }
                }
                path_type = @{type = "path"}
                path_type_nt = @{type = "path"}
                path_type_missing = @{type = "path"}
                raw_type_str = @{type = "raw"}
                raw_type_int = @{type = "raw"}
                sid_type = @{type = "sid"}
                sid_from_name = @{type = "sid"}
                str_type = @{type = "str"}
                delegate_type = @{type = [Func[[Object], [UInt64]]]{ [System.UInt64]::Parse($args[0]) }}
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_default = 1
            string_option = 1
            required_option = "required"
            choices = "a"
            one_choice = "b"
            alias_direct = "a"
            alias_as_alias2 = "a"
            bool_type = $true
            bool_from_str = "false"
            dict_type = @{
                int_type = "10"
            }
            dict_type_json = '{"a":"a","b":1,"c":["a","b"]}'
            dict_type_str = 'a=a b="b 2" c=c'
            float_type = "3.14159"
            int_type = 0
            json_type = '{"a":"a","b":1,"c":["a","b"]}'
            json_type_dict = @{
                a = "a"
                b = 1
                c = @("a", "b")
            }
            list_type = @("a", "b", 1, 2)
            list_type_str = "a, b,1,2 "
            list_with_int = @("1", 2)
            list_type_single = "single"
            list_with_dict = @(
                @{
                    int_type = 2
                    str_type = "dict entry"
                },
                @{ int_type = 1 },
                @{}
            )
            path_type = "%SystemRoot%\System32"
            path_type_nt = "\\?\%SystemRoot%\System32"
            path_type_missing = "T:\missing\path"
            raw_type_str = "str"
            raw_type_int = 1
            sid_type = "S-1-5-18"
            sid_from_name = "SYSTEM"
            str_type = "str"
            delegate_type = "1234"
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $m.Params.option_default | Assert-Equals -Expected "1"
        $m.Params.option_default.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.missing_option_default | Assert-Equals -Expected $null
        $m.Params.string_option | Assert-Equals -Expected "1"
        $m.Params.string_option.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.required_option | Assert-Equals -Expected "required"
        $m.Params.required_option.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.missing_choices | Assert-Equals -Expected $null
        $m.Params.choices | Assert-Equals -Expected "a"
        $m.Params.choices.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.one_choice | Assert-Equals -Expected "b"
        $m.Params.one_choice.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.choice_with_default | Assert-Equals -Expected "b"
        $m.Params.choice_with_default.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.alias_direct | Assert-Equals -Expected "a"
        $m.Params.alias_direct.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.alias_as_alias | Assert-Equals -Expected "a"
        $m.Params.alias_as_alias.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.bool_type | Assert-Equals -Expected $true
        $m.Params.bool_type.GetType().ToString() | Assert-Equals -Expected "System.Boolean"
        $m.Params.bool_from_str | Assert-Equals -Expected $false
        $m.Params.bool_from_str.GetType().ToString() | Assert-Equals -Expected "System.Boolean"
        $m.Params.dict_type | Assert-DictionaryEquals -Expected @{int_type = 10; str_type = "str_sub_type"}
        $m.Params.dict_type.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.Dictionary``2[System.String,System.Object]"
        $m.Params.dict_type.int_type.GetType().ToString() | Assert-Equals -Expected "System.Int32"
        $m.Params.dict_type.str_type.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.dict_type_missing | Assert-Equals -Expected $null
        $m.Params.dict_type_defaults | Assert-DictionaryEquals -Expected @{int_type = $null; str_type = "str_sub_type"}
        $m.Params.dict_type_defaults.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.Dictionary``2[System.String,System.Object]"
        $m.Params.dict_type_defaults.str_type.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.dict_type_json | Assert-DictionaryEquals -Expected @{
            a = "a"
            b = 1
            c = @("a", "b")
        }
        $m.Params.dict_type_json.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.Dictionary``2[System.String,System.Object]"
        $m.Params.dict_type_json.a.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.dict_type_json.b.GetType().ToString() | Assert-Equals -Expected "System.Int32"
        $m.Params.dict_type_json.c.GetType().ToString() | Assert-Equals -Expected "System.Collections.ArrayList"
        $m.Params.dict_type_str | Assert-DictionaryEquals -Expected @{a = "a"; b = "b 2"; c = "c"}
        $m.Params.dict_type_str.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.Dictionary``2[System.String,System.Object]"
        $m.Params.dict_type_str.a.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.dict_type_str.b.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.dict_type_str.c.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.float_type | Assert-Equals -Expected ([System.Single]3.14159)
        $m.Params.float_type.GetType().ToString() | Assert-Equals -Expected "System.Single"
        $m.Params.int_type | Assert-Equals -Expected 0
        $m.Params.int_type.GetType().ToString() | Assert-Equals -Expected "System.Int32"
        $m.Params.json_type | Assert-Equals -Expected '{"a":"a","b":1,"c":["a","b"]}'
        $m.Params.json_type.GetType().ToString() | Assert-Equals -Expected "System.String"
        [Ansible.Basic.AnsibleModule]::FromJson($m.Params.json_type_dict) | Assert-DictionaryEquals -Expected ([Ansible.Basic.AnsibleModule]::FromJson('{"a":"a","b":1,"c":["a","b"]}'))
        $m.Params.json_type_dict.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.list_type.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.List``1[System.Object]"
        $m.Params.list_type.Count | Assert-Equals -Expected 4
        $m.Params.list_type[0] | Assert-Equals -Expected "a"
        $m.Params.list_type[0].GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.list_type[1] | Assert-Equals -Expected "b"
        $m.Params.list_type[1].GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.list_type[2] | Assert-Equals -Expected 1
        $m.Params.list_type[2].GetType().FullName | Assert-Equals -Expected "System.Int32"
        $m.Params.list_type[3] | Assert-Equals -Expected 2
        $m.Params.list_type[3].GetType().FullName | Assert-Equals -Expected "System.Int32"
        $m.Params.list_type_str.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.List``1[System.Object]"
        $m.Params.list_type_str.Count | Assert-Equals -Expected 4
        $m.Params.list_type_str[0] | Assert-Equals -Expected "a"
        $m.Params.list_type_str[0].GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.list_type_str[1] | Assert-Equals -Expected "b"
        $m.Params.list_type_str[1].GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.list_type_str[2] | Assert-Equals -Expected "1"
        $m.Params.list_type_str[2].GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.list_type_str[3] | Assert-Equals -Expected "2"
        $m.Params.list_type_str[3].GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.list_with_int.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.List``1[System.Object]"
        $m.Params.list_with_int.Count | Assert-Equals -Expected 2
        $m.Params.list_with_int[0] | Assert-Equals -Expected 1
        $m.Params.list_with_int[0].GetType().FullName | Assert-Equals -Expected "System.Int32"
        $m.Params.list_with_int[1] | Assert-Equals -Expected 2
        $m.Params.list_with_int[1].GetType().FullName | Assert-Equals -Expected "System.Int32"
        $m.Params.list_type_single.GetType().ToString() | Assert-Equals -Expected "System.Collections.Generic.List``1[System.Object]"
        $m.Params.list_type_single.Count | Assert-Equals -Expected 1
        $m.Params.list_type_single[0] | Assert-Equals -Expected "single"
        $m.Params.list_type_single[0].GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.list_with_dict.GetType().FullName.StartsWith("System.Collections.Generic.List``1[[System.Object") | Assert-Equals -Expected $true
        $m.Params.list_with_dict.Count | Assert-Equals -Expected 3
        $m.Params.list_with_dict[0].GetType().FullName.StartsWith("System.Collections.Generic.Dictionary``2[[System.String") | Assert-Equals -Expected $true
        $m.Params.list_with_dict[0] | Assert-DictionaryEquals -Expected @{int_type = 2; str_type = "dict entry"}
        $m.Params.list_with_dict[0].int_type.GetType().FullName.ToString() | Assert-Equals -Expected "System.Int32"
        $m.Params.list_with_dict[0].str_type.GetType().FullName.ToString() | Assert-Equals -Expected "System.String"
        $m.Params.list_with_dict[1].GetType().FullName.StartsWith("System.Collections.Generic.Dictionary``2[[System.String") | Assert-Equals -Expected $true
        $m.Params.list_with_dict[1] | Assert-DictionaryEquals -Expected @{int_type = 1; str_type = "str_sub_type"}
        $m.Params.list_with_dict[1].int_type.GetType().FullName.ToString() | Assert-Equals -Expected "System.Int32"
        $m.Params.list_with_dict[1].str_type.GetType().FullName.ToString() | Assert-Equals -Expected "System.String"
        $m.Params.list_with_dict[2].GetType().FullName.StartsWith("System.Collections.Generic.Dictionary``2[[System.String") | Assert-Equals -Expected $true
        $m.Params.list_with_dict[2] | Assert-DictionaryEquals -Expected @{int_type = $null; str_type = "str_sub_type"}
        $m.Params.list_with_dict[2].str_type.GetType().FullName.ToString() | Assert-Equals -Expected "System.String"
        $m.Params.path_type | Assert-Equals -Expected "$($env:SystemRoot)\System32"
        $m.Params.path_type.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.path_type_nt | Assert-Equals -Expected "\\?\%SystemRoot%\System32"
        $m.Params.path_type_nt.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.path_type_missing | Assert-Equals -Expected "T:\missing\path"
        $m.Params.path_type_missing.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.raw_type_str | Assert-Equals -Expected "str"
        $m.Params.raw_type_str.GetType().FullName | Assert-Equals -Expected "System.String"
        $m.Params.raw_type_int | Assert-Equals -Expected 1
        $m.Params.raw_type_int.GetType().FullName | Assert-Equals -Expected "System.Int32"
        $m.Params.sid_type | Assert-Equals -Expected (New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList "S-1-5-18")
        $m.Params.sid_type.GetType().ToString() | Assert-Equals -Expected "System.Security.Principal.SecurityIdentifier"
        $m.Params.sid_from_name | Assert-Equals -Expected (New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList "S-1-5-18")
        $m.Params.sid_from_name.GetType().ToString() | Assert-Equals -Expected "System.Security.Principal.SecurityIdentifier"
        $m.Params.str_type | Assert-Equals -Expected "str"
        $m.Params.str_type.GetType().ToString() | Assert-Equals -Expected "System.String"
        $m.Params.delegate_type | Assert-Equals -Expected 1234
        $m.Params.delegate_type.GetType().ToString() | Assert-Equals -Expected "System.UInt64"

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_module_args = @{
            option_default = "1"
            missing_option_default = $null
            string_option = "1"
            required_option = "required"
            missing_choices = $null
            choices = "a"
            one_choice = "b"
            choice_with_default = "b"
            alias_direct = "a"
            alias_as_alias = "a"
            alias_as_alias2 = "a"
            bool_type = $true
            bool_from_str = $false
            dict_type = @{
                int_type = 10
                str_type = "str_sub_type"
            }
            dict_type_missing = $null
            dict_type_defaults = @{
                int_type = $null
                str_type = "str_sub_type"
            }
            dict_type_json = @{
                a = "a"
                b = 1
                c = @("a", "b")
            }
            dict_type_str = @{
                a = "a"
                b = "b 2"
                c = "c"
            }
            float_type = 3.14159
            int_type = 0
            json_type = $m.Params.json_type.ToString()
            json_type_dict = $m.Params.json_type_dict.ToString()
            list_type = @("a", "b", 1, 2)
            list_type_str = @("a", "b", "1", "2")
            list_with_int = @(1, 2)
            list_type_single = @("single")
            list_with_dict = @(
                @{
                    int_type = 2
                    str_type = "dict entry"
                },
                @{
                    int_type = 1
                    str_type = "str_sub_type"
                },
                @{
                    int_type = $null
                    str_type = "str_sub_type"
                }
            )
            path_type = "$($env:SystemRoot)\System32"
            path_type_nt = "\\?\%SystemRoot%\System32"
            path_type_missing = "T:\missing\path"
            raw_type_str = "str"
            raw_type_int = 1
            sid_type = "S-1-5-18"
            sid_from_name = "S-1-5-18"
            str_type = "str"
            delegate_type = 1234
        }
        $actual.Keys.Count | Assert-Equals -Expected 2
        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $expected_module_args}
    }

    "Parse module args with list elements and delegate type" = {
        $spec = @{
            options = @{
                list_delegate_type = @{
                    type = "list"
                    elements = [Func[[Object], [UInt16]]]{ [System.UInt16]::Parse($args[0]) }
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            list_delegate_type = @(
                "1234",
                4321
            )
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        $m.Params.list_delegate_type.GetType().Name | Assert-Equals -Expected 'List`1'
        $m.Params.list_delegate_type[0].GetType().FullName | Assert-Equals -Expected "System.UInt16"
        $m.Params.list_delegate_Type[1].GetType().FullName | Assert-Equals -Expected "System.UInt16"

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_module_args = @{
            list_delegate_type = @(
                1234,
                4321
            )
        }
        $actual.Keys.Count | Assert-Equals -Expected 2
        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $expected_module_args}
    }

    "Parse module args with case insensitive input" = {
        $spec = @{
            options = @{
                option1 = @{ type = "int"; required = $true }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_module_name = "win_test"
            Option1 = "1"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        # Verifies the case of the params key is set to the module spec not actual input
        $m.Params.Keys | Assert-Equals -Expected @("option1")
        $m.Params.option1 | Assert-Equals -Expected 1

        # Verifies the type conversion happens even on a case insensitive match
        $m.Params.option1.GetType().FullName | Assert-Equals -Expected "System.Int32"

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_warnings = "Parameters for (win_test) was a case insensitive match: Option1. "
        $expected_warnings += "Module options will become case sensitive in a future Ansible release. "
        $expected_warnings += "Supported parameters include: option1"

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{
                    option1 = 1
                }
            }
            # We have disabled the warning for now
            #warnings = @($expected_warnings)
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "No log values" = {
        $spec = @{
            options = @{
                username = @{type = "str"}
                password = @{type = "str"; no_log = $true}
                password2 = @{type = "int"; no_log = $true}
                dict = @{type = "dict"}
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_module_name = "test_no_log"
            username = "user - pass - name"
            password = "pass"
            password2 = 1234
            dict = @{
                data = "Oops this is secret: pass"
                dict = @{
                    pass = "plain"
                    hide = "pass"
                    sub_hide = "password"
                    int_hide = 123456
                }
                list = @(
                    "pass",
                    "password",
                    1234567,
                    "pa ss",
                    @{
                        pass = "plain"
                        hide = "pass"
                        sub_hide = "password"
                        int_hide = 123456
                    }
                )
                custom = "pass"
            }
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        $m.Result.data = $complex_args.dict

        # verify params internally aren't masked
        $m.Params.username | Assert-Equals -Expected "user - pass - name"
        $m.Params.password | Assert-Equals -Expected "pass"
        $m.Params.password2 | Assert-Equals -Expected 1234
        $m.Params.dict.custom | Assert-Equals -Expected "pass"

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        # verify no_log params are masked in invocation
        $expected = @{
            invocation = @{
                module_args = @{
                    password2 = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                    dict = @{
                        dict = @{
                            pass = "plain"
                            hide = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                            sub_hide = "********word"
                            int_hide = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                        }
                        custom = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                        list = @(
                            "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER",
                            "********word",
                            "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER",
                            "pa ss",
                            @{
                                pass = "plain"
                                hide = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                                sub_hide = "********word"
                                int_hide = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                            }
                        )
                        data = "Oops this is secret: ********"
                    }
                    username = "user - ******** - name"
                    password = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                }
            }
            changed = $false
            data = $complex_args.dict
        }
        $actual | Assert-DictionaryEquals -Expected $expected

        $expected_event = @'
test_no_log - Invoked with:
  username: user - ******** - name
  dict: dict: sub_hide: ****word
      pass: plain
      int_hide: ********56
      hide: VALUE_SPECIFIED_IN_NO_LOG_PARAMETER
      data: Oops this is secret: ********
      custom: VALUE_SPECIFIED_IN_NO_LOG_PARAMETER
      list:
      - VALUE_SPECIFIED_IN_NO_LOG_PARAMETER
      - ********word
      - ********567
      - pa ss
      - sub_hide: ********word
          pass: plain
          int_hide: ********56
          hide: VALUE_SPECIFIED_IN_NO_LOG_PARAMETER
  password2: VALUE_SPECIFIED_IN_NO_LOG_PARAMETER
  password: VALUE_SPECIFIED_IN_NO_LOG_PARAMETER
'@
        $actual_event = (Get-EventLog -LogName Application -Source Ansible -Newest 1).Message
        $actual_event | Assert-DictionaryEquals -Expected $expected_event
    }

    "No log value with an empty string" = {
        $spec = @{
            options = @{
                password1 = @{type = "str"; no_log = $true}
                password2 = @{type = "str"; no_log = $true}
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_module_name = "test_no_log"
            password1 = ""
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        $m.Result.data = $complex_args.dict

        # verify params internally aren't masked
        $m.Params.password1 | Assert-Equals -Expected ""
        $m.Params.password2 | Assert-Equals -Expected $null

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            invocation = @{
                module_args = @{
                    password1 = ""
                    password2 = $null
                }
            }
            changed = $false
            data = $complex_args.dict
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Removed in version" = {
        $spec = @{
            options = @{
                removed1 = @{removed_in_version = "2.1"}
                removed2 = @{removed_in_version = "2.2"}
                removed3 = @{removed_in_version = "2.3"; removed_from_collection = "ansible.builtin"}
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            removed1 = "value"
            removed3 = "value"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{
                    removed1 = "value"
                    removed2 = $null
                    removed3 = "value"
                }
            }
            deprecations = @(
                @{
                    msg = "Param 'removed3' is deprecated. See the module docs for more information"
                    version = "2.3"
                    collection_name = "ansible.builtin"
                },
                @{
                    msg = "Param 'removed1' is deprecated. See the module docs for more information"
                    version = "2.1"
                    collection_name = $null
                }
            )
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Removed at date" = {
        $spec = @{
            options = @{
                removed1 = @{removed_at_date = [DateTime]"2020-03-10"}
                removed2 = @{removed_at_date = [DateTime]"2020-03-11"}
                removed3 = @{removed_at_date = [DateTime]"2020-06-07"; removed_from_collection = "ansible.builtin"}
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            removed1 = "value"
            removed3 = "value"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{
                    removed1 = "value"
                    removed2 = $null
                    removed3 = "value"
                }
            }
            deprecations = @(
                @{
                    msg = "Param 'removed3' is deprecated. See the module docs for more information"
                    date = "2020-06-07"
                    collection_name = "ansible.builtin"
                },
                @{
                    msg = "Param 'removed1' is deprecated. See the module docs for more information"
                    date = "2020-03-10"
                    collection_name = $null
                }
            )
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Deprecated aliases" = {
        $spec = @{
            options = @{
                option1 = @{ type = "str"; aliases = "alias1"; deprecated_aliases = @(@{name = "alias1"; version = "2.10"}) }
                option2 = @{ type = "str"; aliases = "alias2"; deprecated_aliases = @(@{name = "alias2"; version = "2.11"}) }
                option3 = @{
                    type = "dict"
                    options = @{
                        option1 = @{ type = "str"; aliases = "alias1"; deprecated_aliases = @(@{name = "alias1"; version = "2.10"}) }
                        option2 = @{ type = "str"; aliases = "alias2"; deprecated_aliases = @(@{name = "alias2"; version = "2.11"}) }
                        option3 = @{ type = "str"; aliases = "alias3"; deprecated_aliases = @(@{name = "alias3"; version = "2.12"; collection_name = "ansible.builtin"}) }
                        option4 = @{ type = "str"; aliases = "alias4"; deprecated_aliases = @(@{name = "alias4"; date = [DateTime]"2020-03-11"}) }
                        option5 = @{ type = "str"; aliases = "alias5"; deprecated_aliases = @(@{name = "alias5"; date = [DateTime]"2020-03-09"}) }
                        option6 = @{ type = "str"; aliases = "alias6"; deprecated_aliases = @(@{name = "alias6"; date = [DateTime]"2020-06-01"; collection_name = "ansible.builtin"}) }
                    }
                }
                option4 = @{ type = "str"; aliases = "alias4"; deprecated_aliases = @(@{name = "alias4"; date = [DateTime]"2020-03-10"}) }
                option5 = @{ type = "str"; aliases = "alias5"; deprecated_aliases = @(@{name = "alias5"; date = [DateTime]"2020-03-12"}) }
                option6 = @{ type = "str"; aliases = "alias6"; deprecated_aliases = @(@{name = "alias6"; version = "2.12"; collection_name = "ansible.builtin"}) }
                option7 = @{ type = "str"; aliases = "alias7"; deprecated_aliases = @(@{name = "alias7"; date = [DateTime]"2020-06-07"; collection_name = "ansible.builtin"}) }
            }
        }

        Set-Variable -Name complex_args -Scope Global -Value @{
            alias1 = "alias1"
            option2 = "option2"
            option3 = @{
                option1 = "option1"
                alias2 = "alias2"
                alias3 = "alias3"
                option4 = "option4"
                alias5 = "alias5"
                alias6 = "alias6"
            }
            option4 = "option4"
            alias5 = "alias5"
            alias6 = "alias6"
            alias7 = "alias7"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{
                    alias1 = "alias1"
                    option1 = "alias1"
                    option2 = "option2"
                    option3 = @{
                        option1 = "option1"
                        option2 = "alias2"
                        alias2 = "alias2"
                        option3 = "alias3"
                        alias3 = "alias3"
                        option4 = "option4"
                        option5 = "alias5"
                        alias5 = "alias5"
                        option6 = "alias6"
                        alias6 = "alias6"
                    }
                    option4 = "option4"
                    option5 = "alias5"
                    alias5 = "alias5"
                    option6 = "alias6"
                    alias6 = "alias6"
                    option7 = "alias7"
                    alias7 = "alias7"
                }
            }
            deprecations = @(
                @{
                    msg = "Alias 'alias7' is deprecated. See the module docs for more information"
                    date = "2020-06-07"
                    collection_name = "ansible.builtin"
                },
                @{
                    msg = "Alias 'alias1' is deprecated. See the module docs for more information"
                    version = "2.10"
                    collection_name = $null
                },
                @{
                    msg = "Alias 'alias5' is deprecated. See the module docs for more information"
                    date = "2020-03-12"
                    collection_name = $null
                },
                @{
                    msg = "Alias 'alias6' is deprecated. See the module docs for more information"
                    version = "2.12"
                    collection_name = "ansible.builtin"
                },
                @{
                    msg = "Alias 'alias2' is deprecated. See the module docs for more information - found in option3"
                    version = "2.11"
                    collection_name = $null
                },
                @{
                    msg = "Alias 'alias5' is deprecated. See the module docs for more information - found in option3"
                    date = "2020-03-09"
                    collection_name = $null
                },
                @{
                    msg = "Alias 'alias3' is deprecated. See the module docs for more information - found in option3"
                    version = "2.12"
                    collection_name = "ansible.builtin"
                },
                @{
                    msg = "Alias 'alias6' is deprecated. See the module docs for more information - found in option3"
                    date = "2020-06-01"
                    collection_name = "ansible.builtin"
                }
            )
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Required by - single value" = {
        $spec = @{
            options = @{
                option1 = @{type = "str"}
                option2 = @{type = "str"}
                option3 = @{type = "str"}
            }
            required_by = @{
                option1 = "option2"
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
            option2 = "option2"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{
                    option1 = "option1"
                    option2 = "option2"
                    option3 = $null
                }
            }
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Required by - multiple values" = {
        $spec = @{
            options = @{
                option1 = @{type = "str"}
                option2 = @{type = "str"}
                option3 = @{type = "str"}
            }
            required_by = @{
                option1 = "option2", "option3"
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
            option2 = "option2"
            option3 = "option3"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{
                    option1 = "option1"
                    option2 = "option2"
                    option3 = "option3"
                }
            }
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Required by explicit null" = {
        $spec = @{
            options = @{
                option1 = @{type = "str"}
                option2 = @{type = "str"}
                option3 = @{type = "str"}
            }
            required_by = @{
                option1 = "option2"
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
            option2 = $null
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{
                    option1 = "option1"
                    option2 = $null
                    option3 = $null
                }
            }
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Required by failed - single value" = {
        $spec = @{
            options = @{
                option1 = @{type = "str"}
                option2 = @{type = "str"}
                option3 = @{type = "str"}
            }
            required_by = @{
                option1 = "option2"
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            failed = $true
            invocation = @{
                module_args = @{
                    option1 = "option1"
                }
            }
            msg = "missing parameter(s) required by 'option1': option2"
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Required by failed - multiple values" = {
        $spec = @{
            options = @{
                option1 = @{type = "str"}
                option2 = @{type = "str"}
                option3 = @{type = "str"}
            }
            required_by = @{
                option1 = "option2", "option3"
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            failed = $true
            invocation = @{
                module_args = @{
                    option1 = "option1"
                }
            }
            msg = "missing parameter(s) required by 'option1': option2, option3"
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Debug without debug set" = {
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_debug = $false
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        $m.Debug("debug message")
        $actual_event = (Get-EventLog -LogName Application -Source Ansible -Newest 1).Message
        $actual_event | Assert-Equals -Expected "undefined win module - Invoked with:`r`n  "
    }

    "Debug with debug set" = {
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_debug = $true
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        $m.Debug("debug message")
        $actual_event = (Get-EventLog -LogName Application -Source Ansible -Newest 1).Message
        $actual_event | Assert-Equals -Expected "undefined win module - [DEBUG] debug message"
    }

    "Deprecate and warn with version" = {
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        $m.Deprecate("message", "2.7")
        $actual_deprecate_event_1 = Get-EventLog -LogName Application -Source Ansible -Newest 1
        $m.Deprecate("message w collection", "2.8", "ansible.builtin")
        $actual_deprecate_event_2 = Get-EventLog -LogName Application -Source Ansible -Newest 1
        $m.Warn("warning")
        $actual_warn_event = Get-EventLog -LogName Application -Source Ansible -Newest 1

        $actual_deprecate_event_1.Message | Assert-Equals -Expected "undefined win module - [DEPRECATION WARNING] message 2.7"
        $actual_deprecate_event_2.Message | Assert-Equals -Expected "undefined win module - [DEPRECATION WARNING] message w collection 2.8"
        $actual_warn_event.EntryType | Assert-Equals -Expected "Warning"
        $actual_warn_event.Message | Assert-Equals -Expected "undefined win module - [WARNING] warning"

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{}
            }
            warnings = @("warning")
            deprecations = @(
                @{msg = "message"; version = "2.7"; collection_name = $null},
                @{msg = "message w collection"; version = "2.8"; collection_name = "ansible.builtin"}
            )
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Deprecate and warn with date" = {
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        $m.Deprecate("message", [DateTime]"2020-01-01")
        $actual_deprecate_event_1 = Get-EventLog -LogName Application -Source Ansible -Newest 1
        $m.Deprecate("message w collection", [DateTime]"2020-01-02", "ansible.builtin")
        $actual_deprecate_event_2 = Get-EventLog -LogName Application -Source Ansible -Newest 1
        $m.Warn("warning")
        $actual_warn_event = Get-EventLog -LogName Application -Source Ansible -Newest 1

        $actual_deprecate_event_1.Message | Assert-Equals -Expected "undefined win module - [DEPRECATION WARNING] message 2020-01-01"
        $actual_deprecate_event_2.Message | Assert-Equals -Expected "undefined win module - [DEPRECATION WARNING] message w collection 2020-01-02"
        $actual_warn_event.EntryType | Assert-Equals -Expected "Warning"
        $actual_warn_event.Message | Assert-Equals -Expected "undefined win module - [WARNING] warning"

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{}
            }
            warnings = @("warning")
            deprecations = @(
                @{msg = "message"; date = "2020-01-01"; collection_name = $null},
                @{msg = "message w collection"; date = "2020-01-02"; collection_name = "ansible.builtin"}
            )
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "FailJson with message" = {
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        $failed = $false
        try {
            $m.FailJson("fail message")
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $failed

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{}
            }
            failed = $true
            msg = "fail message"
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "FailJson with Exception" = {
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        try {
            [System.IO.Path]::GetFullPath($null)
        } catch {
            $excp = $_.Exception
        }

        $failed = $false
        try {
            $m.FailJson("fail message", $excp)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $failed

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{}
            }
            failed = $true
            msg = "fail message"
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "FailJson with ErrorRecord" = {
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        try {
            Get-Item -LiteralPath $null
        } catch {
            $error_record = $_
        }

        $failed = $false
        try {
            $m.FailJson("fail message", $error_record)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $failed

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{}
            }
            failed = $true
            msg = "fail message"
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "FailJson with Exception and verbosity 3" = {
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_verbosity = 3
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        try {
            [System.IO.Path]::GetFullPath($null)
        } catch {
            $excp = $_.Exception
        }

        $failed = $false
        try {
            $m.FailJson("fail message", $excp)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $failed

        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = @{}}
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected "fail message"
        $actual.exception.Contains('System.Management.Automation.MethodInvocationException: Exception calling "GetFullPath" with "1" argument(s)') | Assert-Equals -Expected $true
    }

    "FailJson with ErrorRecord and verbosity 3" = {
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_verbosity = 3
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        try {
            Get-Item -LiteralPath $null
        } catch {
            $error_record = $_
        }

        $failed = $false
        try {
            $m.FailJson("fail message", $error_record)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $failed

        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = @{}}
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected "fail message"
        $actual.exception.Contains("Cannot bind argument to parameter 'LiteralPath' because it is null") | Assert-Equals -Expected $true
        $actual.exception.Contains("+             Get-Item -LiteralPath `$null") | Assert-Equals -Expected $true
        $actual.exception.Contains("ScriptStackTrace:") | Assert-Equals -Expected $true
    }

    "Diff entry without diff set" = {
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        $m.Diff.before = @{a = "a"}
        $m.Diff.after = @{b = "b"}

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $failed

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{}
            }
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "Diff entry with diff set" = {
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_diff = $true
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        $m.Diff.before = @{a = "a"}
        $m.Diff.after = @{b = "b"}

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $failed

        $expected = @{
            changed = $false
            invocation = @{
                module_args = @{}
            }
            diff = @{
                before = @{a = "a"}
                after = @{b = "b"}
            }
        }
        $actual | Assert-DictionaryEquals -Expected $expected
    }

    "ParseBool tests" = {
        $mapping = New-Object -TypeName 'System.Collections.Generic.Dictionary`2[[Object], [Bool]]'
        $mapping.Add("y", $true)
        $mapping.Add("Y", $true)
        $mapping.Add("yes", $true)
        $mapping.Add("Yes", $true)
        $mapping.Add("on", $true)
        $mapping.Add("On", $true)
        $mapping.Add("1", $true)
        $mapping.Add(1, $true)
        $mapping.Add("true", $true)
        $mapping.Add("True", $true)
        $mapping.Add("t", $true)
        $mapping.Add("T", $true)
        $mapping.Add("1.0", $true)
        $mapping.Add(1.0, $true)
        $mapping.Add($true, $true)
        $mapping.Add("n", $false)
        $mapping.Add("N", $false)
        $mapping.Add("no", $false)
        $mapping.Add("No", $false)
        $mapping.Add("off", $false)
        $mapping.Add("Off", $false)
        $mapping.Add("0", $false)
        $mapping.Add(0, $false)
        $mapping.Add("false", $false)
        $mapping.Add("False", $false)
        $mapping.Add("f", $false)
        $mapping.Add("F", $false)
        $mapping.Add("0.0", $false)
        $mapping.Add(0.0, $false)
        $mapping.Add($false, $false)

        foreach ($map in $mapping.GetEnumerator()) {
            $expected = $map.Value
            $actual = [Ansible.Basic.AnsibleModule]::ParseBool($map.Key)
            $actual | Assert-Equals -Expected $expected
            $actual.GetType().FullName | Assert-Equals -Expected "System.Boolean"
        }

        $fail_bools = @(
            "falsey",
            "abc",
            2,
            "2",
            -1
        )
        foreach ($fail_bool in $fail_bools) {
            $failed = $false
            try {
                [Ansible.Basic.AnsibleModule]::ParseBool($fail_bool)
            } catch {
                $failed = $true
                $_.Exception.Message.Contains("The value '$fail_bool' is not a valid boolean") | Assert-Equals -Expected $true
            }
            $failed | Assert-Equals -Expected $true
        }
    }

    "Unknown internal key" = {
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_invalid = "invalid"
        }
        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"

            $expected = @{
                invocation = @{
                    module_args = @{
                        _ansible_invalid = "invalid"
                    }
                }
                changed = $false
                failed = $true
                msg = "Unsupported parameters for (undefined win module) module: _ansible_invalid. Supported parameters include: "
            }
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
            $actual | Assert-DictionaryEquals -Expected $expected
        }
        $failed | Assert-Equals -Expected $true
    }

    "Module tmpdir with present remote tmp" = {
        $current_user = [System.Security.Principal.WindowsIdentity]::GetCurrent().User
        $dir_security = New-Object -TypeName System.Security.AccessControl.DirectorySecurity
        $dir_security.SetOwner($current_user)
        $dir_security.SetAccessRuleProtection($true, $false)
        $ace = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList @(
            $current_user, [System.Security.AccessControl.FileSystemRights]::FullControl,
            [System.Security.AccessControl.InheritanceFlags]"ContainerInherit, ObjectInherit",
            [System.Security.AccessControl.PropagationFlags]::None, [System.Security.AccessControl.AccessControlType]::Allow
        )
        $dir_security.AddAccessRule($ace)
        $expected_sd = $dir_security.GetSecurityDescriptorSddlForm("Access, Owner")

        $remote_tmp = Join-Path -Path $tmpdir -ChildPath "moduletmpdir-$(Get-Random)"
        New-Item -Path $remote_tmp -ItemType Directory > $null
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_remote_tmp = $remote_tmp.ToString()
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $true

        $actual_tmpdir = $m.Tmpdir
        $parent_tmpdir = Split-Path -Path $actual_tmpdir -Parent
        $tmpdir_name = Split-Path -Path $actual_tmpdir -Leaf

        $parent_tmpdir | Assert-Equals -Expected $remote_tmp
        $tmpdir_name.StartSwith("ansible-moduletmp-") | Assert-Equals -Expected $true
        (Test-Path -LiteralPath $actual_tmpdir -PathType Container) | Assert-Equals -Expected $true
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $true
        $children = [System.IO.Directory]::EnumerateDirectories($remote_tmp)
        $children.Count | Assert-Equals -Expected 1
        $actual_tmpdir_sd = (Get-Acl -Path $actual_tmpdir).GetSecurityDescriptorSddlForm("Access, Owner")
        $actual_tmpdir_sd | Assert-Equals -Expected $expected_sd

        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $output = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        (Test-Path -LiteralPath $actual_tmpdir -PathType Container) | Assert-Equals -Expected $false
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $true
        $output.warnings.Count | Assert-Equals -Expected 0
    }

    "Module tmpdir with missing remote_tmp" = {
        $current_user = [System.Security.Principal.WindowsIdentity]::GetCurrent().User
        $dir_security = New-Object -TypeName System.Security.AccessControl.DirectorySecurity
        $dir_security.SetOwner($current_user)
        $dir_security.SetAccessRuleProtection($true, $false)
        $ace = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList @(
            $current_user, [System.Security.AccessControl.FileSystemRights]::FullControl,
            [System.Security.AccessControl.InheritanceFlags]"ContainerInherit, ObjectInherit",
            [System.Security.AccessControl.PropagationFlags]::None, [System.Security.AccessControl.AccessControlType]::Allow
        )
        $dir_security.AddAccessRule($ace)
        $expected_sd = $dir_security.GetSecurityDescriptorSddlForm("Access, Owner")

        $remote_tmp = Join-Path -Path $tmpdir -ChildPath "moduletmpdir-$(Get-Random)"
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_remote_tmp = $remote_tmp.ToString()
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $false

        $actual_tmpdir = $m.Tmpdir
        $parent_tmpdir = Split-Path -Path $actual_tmpdir -Parent
        $tmpdir_name = Split-Path -Path $actual_tmpdir -Leaf

        $parent_tmpdir | Assert-Equals -Expected $remote_tmp
        $tmpdir_name.StartSwith("ansible-moduletmp-") | Assert-Equals -Expected $true
        (Test-Path -LiteralPath $actual_tmpdir -PathType Container) | Assert-Equals -Expected $true
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $true
        $children = [System.IO.Directory]::EnumerateDirectories($remote_tmp)
        $children.Count | Assert-Equals -Expected 1
        $actual_remote_sd = (Get-Acl -Path $remote_tmp).GetSecurityDescriptorSddlForm("Access, Owner")
        $actual_tmpdir_sd = (Get-Acl -Path $actual_tmpdir).GetSecurityDescriptorSddlForm("Access, Owner")
        $actual_remote_sd | Assert-Equals -Expected $expected_sd
        $actual_tmpdir_sd | Assert-Equals -Expected $expected_sd

        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $output = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        (Test-Path -LiteralPath $actual_tmpdir -PathType Container) | Assert-Equals -Expected $false
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $true
        $output.warnings.Count | Assert-Equals -Expected 1
        $nt_account = $current_user.Translate([System.Security.Principal.NTAccount])
        $actual_warning = "Module remote_tmp $remote_tmp did not exist and was created with FullControl to $nt_account, "
        $actual_warning += "this may cause issues when running as another user. To avoid this, "
        $actual_warning += "create the remote_tmp dir with the correct permissions manually"
        $actual_warning | Assert-Equals -Expected $output.warnings[0]
    }

    "Module tmp, keep remote files" = {
        $remote_tmp = Join-Path -Path $tmpdir -ChildPath "moduletmpdir-$(Get-Random)"
        New-Item -Path $remote_tmp -ItemType Directory > $null
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_remote_tmp = $remote_tmp.ToString()
            _ansible_keep_remote_files = $true
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        $actual_tmpdir = $m.Tmpdir
        $parent_tmpdir = Split-Path -Path $actual_tmpdir -Parent
        $tmpdir_name = Split-Path -Path $actual_tmpdir -Leaf

        $parent_tmpdir | Assert-Equals -Expected $remote_tmp
        $tmpdir_name.StartSwith("ansible-moduletmp-") | Assert-Equals -Expected $true
        (Test-Path -LiteralPath $actual_tmpdir -PathType Container) | Assert-Equals -Expected $true
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $true

        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $output = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        (Test-Path -LiteralPath $actual_tmpdir -PathType Container) | Assert-Equals -Expected $true
        (Test-Path -LiteralPath $remote_tmp -PathType Container) | Assert-Equals -Expected $true
        $output.warnings.Count | Assert-Equals -Expected 0
        Remove-Item -LiteralPath $actual_tmpdir -Force -Recurse
    }

    "Invalid argument spec key" = {
        $spec = @{
            invalid = $true
        }
        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: argument spec entry contains an invalid key 'invalid', valid keys: apply_defaults, "
        $expected_msg += "aliases, choices, default, deprecated_aliases, elements, mutually_exclusive, no_log, options, "
        $expected_msg += "removed_in_version, removed_at_date, removed_from_collection, required, required_by, required_if, "
        $expected_msg += "required_one_of, required_together, supports_check_mode, type"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Invalid argument spec key - nested" = {
        $spec = @{
            options = @{
                option_key = @{
                    options = @{
                        sub_option_key = @{
                            invalid = $true
                        }
                    }
                }
            }
        }
        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: argument spec entry contains an invalid key 'invalid', valid keys: apply_defaults, "
        $expected_msg += "aliases, choices, default, deprecated_aliases, elements, mutually_exclusive, no_log, options, "
        $expected_msg += "removed_in_version, removed_at_date, removed_from_collection, required, required_by, required_if, "
        $expected_msg += "required_one_of, required_together, supports_check_mode, type - found in option_key -> sub_option_key"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Invalid argument spec value type" = {
        $spec = @{
            apply_defaults = "abc"
        }
        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: argument spec for 'apply_defaults' did not match expected "
        $expected_msg += "type System.Boolean: actual type System.String"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Invalid argument spec option type" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "invalid type"
                }
            }
        }
        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: type 'invalid type' is unsupported - found in option_key. "
        $expected_msg += "Valid types are: bool, dict, float, int, json, list, path, raw, sid, str"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Invalid argument spec option element type" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "list"
                    elements = "invalid type"
                }
            }
        }
        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: elements 'invalid type' is unsupported - found in option_key. "
        $expected_msg += "Valid types are: bool, dict, float, int, json, list, path, raw, sid, str"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Invalid deprecated aliases entry - no version and date" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "str"
                    aliases = ,"alias_name"
                    deprecated_aliases = @(
                        @{name = "alias_name"}
                    )
                }
            }
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: One of version or date is required in a deprecated_aliases entry"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Invalid deprecated aliases entry - no name (nested)" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "dict"
                    options = @{
                        sub_option_key = @{
                            type = "str"
                            aliases = ,"alias_name"
                            deprecated_aliases = @(
                                @{version = "2.10"}
                            )
                        }
                    }
                }
            }
        }

        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = @{
                sub_option_key = "a"
            }
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.ArgumentException] {
            $failed = $true
            $expected_msg = "name is required in a deprecated_aliases entry - found in option_key"
            $_.Exception.Message | Assert-Equals -Expected $expected_msg
        }
        $failed | Assert-Equals -Expected $true
    }

    "Invalid deprecated aliases entry - both version and date" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "str"
                    aliases = ,"alias_name"
                    deprecated_aliases = @(
                        @{
                            name = "alias_name"
                            date = [DateTime]"2020-03-10"
                            version = "2.11"
                        }
                    )
                }
            }
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: Only one of version or date is allowed in a deprecated_aliases entry"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Invalid deprecated aliases entry - wrong date type" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "str"
                    aliases = ,"alias_name"
                    deprecated_aliases = @(
                        @{
                            name = "alias_name"
                            date = "2020-03-10"
                        }
                    )
                }
            }
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: A deprecated_aliases date must be a DateTime object"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Spec required and default set at the same time" = {
        $spec = @{
            options = @{
                option_key = @{
                    required = $true
                    default = "default value"
                }
            }
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: required and default are mutually exclusive for option_key"

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        ("exception" -cin $actual.Keys) | Assert-Equals -Expected $true
    }

    "Unsupported options" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "str"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "abc"
            invalid_key = "def"
            another_key = "ghi"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "Unsupported parameters for (undefined win module) module: another_key, invalid_key. "
        $expected_msg += "Supported parameters include: option_key"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Check mode and module doesn't support check mode" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "str"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_check_mode = $true
            option_key = "abc"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "remote module (undefined win module) does not support check mode"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.skipped | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = @{option_key = "abc"}}
    }

    "Check mode with suboption without supports_check_mode" = {
        $spec = @{
            options = @{
                sub_options = @{
                    # This tests the situation where a sub key doesn't set supports_check_mode, the logic in
                    # Ansible.Basic automatically sets that to $false and we want it to ignore it for a nested check
                    type = "dict"
                    options = @{
                        sub_option = @{ type = "str"; default = "value" }
                    }
                }
            }
            supports_check_mode = $true
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            _ansible_check_mode = $true
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        $m.CheckMode | Assert-Equals -Expected $true
    }

    "Type conversion error" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "int"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "a"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "argument for option_key is of type System.String and we were unable to convert to int: "
        $expected_msg += "Input string was not in a correct format."

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Type conversion error - delegate" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "dict"
                    options = @{
                        sub_option_key = @{
                            type = [Func[[Object], [UInt64]]]{ [System.UInt64]::Parse($args[0]) }
                        }
                    }
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = @{
                sub_option_key = "a"
            }
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "argument for sub_option_key is of type System.String and we were unable to convert to delegate: "
        $expected_msg += "Exception calling `"Parse`" with `"1`" argument(s): `"Input string was not in a correct format.`" "
        $expected_msg += "found in option_key"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Numeric choices" = {
        $spec = @{
            options = @{
                option_key = @{
                    choices = 1, 2, 3
                    type = "int"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "2"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $output = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $output.Keys.Count | Assert-Equals -Expected 2
        $output.changed | Assert-Equals -Expected $false
        $output.invocation | Assert-DictionaryEquals -Expected @{module_args = @{option_key = 2}}
    }

    "Case insensitive choice" = {
        $spec = @{
            options = @{
                option_key = @{
                    choices = "abc", "def"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "ABC"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $output = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $expected_warning = "value of option_key was a case insensitive match of one of: abc, def. "
        $expected_warning += "Checking of choices will be case sensitive in a future Ansible release. "
        $expected_warning += "Case insensitive matches were: ABC"

        $output.invocation | Assert-DictionaryEquals -Expected @{module_args = @{option_key = "ABC"}}
        # We have disabled the warnings for now
        #$output.warnings.Count | Assert-Equals -Expected 1
        #$output.warnings[0] | Assert-Equals -Expected $expected_warning
    }

    "Case insensitive choice no_log" = {
        $spec = @{
            options = @{
                option_key = @{
                    choices = "abc", "def"
                    no_log = $true
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "ABC"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $output = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $expected_warning = "value of option_key was a case insensitive match of one of: abc, def. "
        $expected_warning += "Checking of choices will be case sensitive in a future Ansible release. "
        $expected_warning += "Case insensitive matches were: VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"

        $output.invocation | Assert-DictionaryEquals -Expected @{module_args = @{option_key = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"}}
        # We have disabled the warnings for now
        #$output.warnings.Count | Assert-Equals -Expected 1
        #$output.warnings[0] | Assert-Equals -Expected $expected_warning
    }

    "Case insentitive choice as list" = {
        $spec = @{
            options = @{
                option_key = @{
                    choices = "abc", "def", "ghi", "JKL"
                    type = "list"
                    elements = "str"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "AbC", "ghi", "jkl"
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $output = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $expected_warning = "value of option_key was a case insensitive match of one or more of: abc, def, ghi, JKL. "
        $expected_warning += "Checking of choices will be case sensitive in a future Ansible release. "
        $expected_warning += "Case insensitive matches were: AbC, jkl"

        $output.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
        # We have disabled the warnings for now
        #$output.warnings.Count | Assert-Equals -Expected 1
        #$output.warnings[0] | Assert-Equals -Expected $expected_warning
    }

    "Invalid choice" = {
        $spec = @{
            options = @{
                option_key = @{
                    choices = "a", "b"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "c"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "value of option_key must be one of: a, b. Got no match for: c"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Invalid choice with no_log" = {
        $spec = @{
            options = @{
                option_key = @{
                    choices = "a", "b"
                    no_log = $true
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "abc"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "value of option_key must be one of: a, b. Got no match for: ********"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = @{option_key = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"}}
    }

    "Invalid choice in list" = {
        $spec = @{
            options = @{
                option_key = @{
                    choices = "a", "b"
                    type = "list"
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = "a", "c"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "value of option_key must be one or more of: a, b. Got no match for: c"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Mutually exclusive options" = {
        $spec = @{
            options = @{
                option1 = @{}
                option2 = @{}
            }
            mutually_exclusive = @(,@("option1", "option2"))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "a"
            option2 = "b"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "parameters are mutually exclusive: option1, option2"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Missing required argument" = {
        $spec = @{
            options = @{
                option1 = @{}
                option2 = @{required = $true}
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "a"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "missing required arguments: option2"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Missing required argument subspec - no value defined" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "dict"
                    options = @{
                        sub_option_key = @{
                            required = $true
                        }
                    }
                }
            }
        }

        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.Keys.Count | Assert-Equals -Expected 2
        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Missing required argument subspec" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "dict"
                    options = @{
                        sub_option_key = @{
                            required = $true
                        }
                        another_key = @{}
                    }
                }
            }
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = @{
                another_key = "abc"
            }
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "missing required arguments: sub_option_key found in option_key"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required together not set" = {
        $spec = @{
            options = @{
                option1 = @{}
                option2 = @{}
            }
            required_together = @(,@("option1", "option2"))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "abc"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "parameters are required together: option1, option2"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required together not set - subspec" = {
        $spec = @{
            options = @{
                option_key = @{
                    type = "dict"
                    options = @{
                        option1 = @{}
                        option2 = @{}
                    }
                    required_together = @(,@("option1", "option2"))
                }
                another_option = @{}
            }
            required_together = @(,@("option_key", "another_option"))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option_key = @{
                option1 = "abc"
            }
            another_option = "def"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "parameters are required together: option1, option2 found in option_key"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required one of not set" = {
        $spec = @{
            options = @{
                option1 = @{}
                option2 = @{}
                option3 = @{}
            }
            required_one_of = @(@("option1", "option2"), @("option2", "option3"))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "abc"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "one of the following is required: option2, option3"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required if invalid entries" = {
        $spec = @{
            options = @{
                state = @{choices = "absent", "present"; default = "present"}
                path = @{type = "path"}
            }
            required_if = @(,@("state", "absent"))
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "internal error: invalid required_if value count of 2, expecting 3 or 4 entries"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required if no missing option" = {
        $spec = @{
            options = @{
                state = @{choices = "absent", "present"; default = "present"}
                name = @{}
                path = @{type = "path"}
            }
            required_if = @(,@("state", "absent", @("name", "path")))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            name = "abc"
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.Keys.Count | Assert-Equals -Expected 2
        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required if missing option" = {
        $spec = @{
            options = @{
                state = @{choices = "absent", "present"; default = "present"}
                name = @{}
                path = @{type = "path"}
            }
            required_if = @(,@("state", "absent", @("name", "path")))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            state = "absent"
            name = "abc"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "state is absent but all of the following are missing: path"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required if missing option and required one is set" = {
        $spec = @{
            options = @{
                state = @{choices = "absent", "present"; default = "present"}
                name = @{}
                path = @{type = "path"}
            }
            required_if = @(,@("state", "absent", @("name", "path"), $true))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            state = "absent"
        }

        $failed = $false
        try {
            $null = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $expected_msg = "state is absent but any of the following are missing: name, path"

        $actual.Keys.Count | Assert-Equals -Expected 4
        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected $expected_msg
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Required if missing option but one required set" = {
        $spec = @{
            options = @{
                state = @{choices = "absent", "present"; default = "present"}
                name = @{}
                path = @{type = "path"}
            }
            required_if = @(,@("state", "absent", @("name", "path"), $true))
        }
        Set-Variable -Name complex_args -Scope Global -Value @{
            state = "absent"
            name = "abc"
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.Keys.Count | Assert-Equals -Expected 2
        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "PS Object in return result" = {
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), @{})

        # JavaScriptSerializer struggles with PS Object like PSCustomObject due to circular references, this test makes
        # sure we can handle these types of objects without bombing
        $m.Result.output = [PSCustomObject]@{a = "a"; b = "b"}
        $failed = $true
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.Keys.Count | Assert-Equals -Expected 3
        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = @{}}
        $actual.output | Assert-DictionaryEquals -Expected @{a = "a"; b = "b"}
    }

    "String json array to object" = {
        $input_json = '["abc", "def"]'
        $actual = [Ansible.Basic.AnsibleModule]::FromJson($input_json)
        $actual -is [Array] | Assert-Equals -Expected $true
        $actual.Length | Assert-Equals -Expected 2
        $actual[0] | Assert-Equals -Expected "abc"
        $actual[1] | Assert-Equals -Expected "def"
    }

    "String json array of dictionaries to object" = {
        $input_json = '[{"abc":"def"}]'
        $actual = [Ansible.Basic.AnsibleModule]::FromJson($input_json)
        $actual -is [Array] | Assert-Equals -Expected $true
        $actual.Length | Assert-Equals -Expected 1
        $actual[0] | Assert-DictionaryEquals -Expected @{"abc" = "def"}
    }

    "Spec with fragments" = {
        $spec = @{
            options = @{
                option1 = @{ type = "str" }
            }
        }
        $fragment1 = @{
            options = @{
                option2 = @{ type = "str" }
            }
        }

        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
            option2 = "option2"
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec, @($fragment1))

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{module_args = $complex_args}
    }

    "Fragment spec that with a deprecated alias" = {
        $spec = @{
            options = @{
                option1 = @{
                    aliases = @("alias1_spec")
                    type = "str"
                    deprecated_aliases = @(
                        @{name = "alias1_spec"; version = "2.0"}
                    )
                }
                option2 = @{
                    aliases = @("alias2_spec")
                    deprecated_aliases = @(
                        @{name = "alias2_spec"; version = "2.0"; collection_name = "ansible.builtin"}
                    )
                }
            }
        }
        $fragment1 = @{
            options = @{
                option1 = @{
                    aliases = @("alias1")
                    deprecated_aliases = @()  # Makes sure it doesn't overwrite the spec, just adds to it.
                }
                option2 = @{
                    aliases = @("alias2")
                    deprecated_aliases = @(
                        @{name = "alias2"; version = "2.0"; collection_name = "foo.bar"}
                    )
                    type = "str"
                }
            }
        }

        Set-Variable -Name complex_args -Scope Global -Value @{
            alias1_spec = "option1"
            alias2 = "option2"
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec, @($fragment1))

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.deprecations.Count | Assert-Equals -Expected 2
        $actual.deprecations[0] | Assert-DictionaryEquals -Expected @{
            msg = "Alias 'alias1_spec' is deprecated. See the module docs for more information"; version = "2.0"; collection_name = $null
        }
        $actual.deprecations[1] | Assert-DictionaryEquals -Expected @{
            msg = "Alias 'alias2' is deprecated. See the module docs for more information"; version = "2.0"; collection_name = "foo.bar"
        }
        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{
            module_args = @{
                option1 = "option1"
                alias1_spec = "option1"
                option2 = "option2"
                alias2 = "option2"
            }
        }
    }

    "Fragment spec with mutual args" = {
        $spec = @{
            options = @{
                option1 = @{ type = "str" }
                option2 = @{ type = "str" }
            }
            mutually_exclusive = @(
                ,@('option1', 'option2')
            )
        }
        $fragment1 = @{
            options = @{
                fragment1_1 = @{ type = "str" }
                fragment1_2 = @{ type = "str" }
            }
            mutually_exclusive = @(
                ,@('fragment1_1', 'fragment1_2')
            )
        }
        $fragment2 = @{
            options = @{
                fragment2 = @{ type = "str" }
            }
        }

        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
            fragment1_1 = "fragment1_1"
            fragment1_2 = "fragment1_2"
            fragment2 = "fragment2"
        }

        $failed = $false
        try {
            [Ansible.Basic.AnsibleModule]::Create(@(), $spec, @($fragment1, $fragment2))
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.changed | Assert-Equals -Expected $false
        $actual.failed | Assert-Equals -Expected $true
        $actual.msg | Assert-Equals -Expected "parameters are mutually exclusive: fragment1_1, fragment1_2"
        $actual.invocation | Assert-DictionaryEquals -Expected @{ module_args = $complex_args }
    }

    "Fragment spec with no_log" = {
        $spec = @{
            options = @{
                option1 = @{
                    aliases = @("alias")
                }
            }
        }
        $fragment1 = @{
            options = @{
                option1 = @{
                    no_log = $true  # Makes sure that a value set in the fragment but not in the spec is respected.
                    type = "str"
                }
            }
        }

        Set-Variable -Name complex_args -Scope Global -Value @{
            alias = "option1"
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec, @($fragment1))

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.changed | Assert-Equals -Expected $false
        $actual.invocation | Assert-DictionaryEquals -Expected @{
            module_args = @{
                option1 = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
                alias = "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
            }
        }
    }

    "Catch invalid fragment spec format" = {
        $spec = @{
            options = @{
                option1 = @{ type = "str" }
            }
        }
        $fragment = @{
            options = @{}
            invalid = "will fail"
        }

        Set-Variable -Name complex_args -Scope Global -Value @{
            option1 = "option1"
        }

        $failed = $false
        try {
            [Ansible.Basic.AnsibleModule]::Create(@(), $spec, @($fragment))
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 1"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.failed | Assert-Equals -Expected $true
        $actual.msg.StartsWith("internal error: argument spec entry contains an invalid key 'invalid', valid keys: ") | Assert-Equals -Expected $true
    }

    "Spec with different list types" = {
        $spec = @{
            options = @{
                # Single element of the same list type not in a list
                option1 = @{
                    aliases = "alias1"
                    deprecated_aliases = @{name="alias1";version="2.0";collection_name="foo.bar"}
                }

                # Arrays
                option2 = @{
                    aliases = ,"alias2"
                    deprecated_aliases = ,@{name="alias2";version="2.0";collection_name="foo.bar"}
                }

                # ArrayList
                option3 = @{
                    aliases = [System.Collections.ArrayList]@("alias3")
                    deprecated_aliases = [System.Collections.ArrayList]@(@{name="alias3";version="2.0";collection_name="foo.bar"})
                }

                # Generic.List[Object]
                option4 = @{
                    aliases = [System.Collections.Generic.List[Object]]@("alias4")
                    deprecated_aliases = [System.Collections.Generic.List[Object]]@(@{name="alias4";version="2.0";collection_name="foo.bar"})
                }

                # Generic.List[T]
                option5 = @{
                    aliases = [System.Collections.Generic.List[String]]@("alias5")
                    deprecated_aliases = [System.Collections.Generic.List[Hashtable]]@()
                }
            }
        }
        $spec.options.option5.deprecated_aliases.Add(@{name="alias5";version="2.0";collection_name="foo.bar"})

        Set-Variable -Name complex_args -Scope Global -Value @{
            alias1 = "option1"
            alias2 = "option2"
            alias3 = "option3"
            alias4 = "option4"
            alias5 = "option5"
        }
        $m = [Ansible.Basic.AnsibleModule]::Create(@(), $spec)

        $failed = $false
        try {
            $m.ExitJson()
        } catch [System.Management.Automation.RuntimeException] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "exit: 0"
            $actual = [Ansible.Basic.AnsibleModule]::FromJson($_.Exception.InnerException.Output)
        }
        $failed | Assert-Equals -Expected $true

        $actual.changed | Assert-Equals -Expected $false
        $actual.deprecations.Count | Assert-Equals -Expected 5
        foreach ($dep in $actual.deprecations) {
            $dep.msg -like "Alias 'alias?' is deprecated. See the module docs for more information" | Assert-Equals -Expected $true
            $dep.version | Assert-Equals -Expected '2.0'
            $dep.collection_name | Assert-Equals -Expected 'foo.bar'
        }
        $actual.invocation | Assert-DictionaryEquals -Expected @{
            module_args = @{
                alias1 = "option1"
                option1 = "option1"
                alias2 = "option2"
                option2 = "option2"
                alias3 = "option3"
                option3 = "option3"
                alias4 = "option4"
                option4 = "option4"
                alias5 = "option5"
                option5 = "option5"
            }
        }
    }
}

try {
    foreach ($test_impl in $tests.GetEnumerator()) {
        # Reset the variables before each test
        Set-Variable -Name complex_args -Value @{} -Scope Global

        $test = $test_impl.Key
        &$test_impl.Value
    }
    $module.Result.data = "success"
} catch [System.Management.Automation.RuntimeException] {
    $module.Result.failed = $true
    $module.Result.test = $test
    $module.Result.line = $_.InvocationInfo.ScriptLineNumber
    $module.Result.method = $_.InvocationInfo.Line.Trim()

    if ($_.Exception.Message.StartSwith("exit: ")) {
        # The exception was caused by an unexpected Exit call, log that on the output
        $module.Result.output = (ConvertFrom-Json -InputObject $_.Exception.InnerException.Output)
        $module.Result.msg = "Uncaught AnsibleModule exit in tests, see output"
    } else {
        # Unrelated exception
        $module.Result.exception = $_.Exception.ToString()
        $module.Result.msg = "Uncaught exception: $(($_ | Out-String).ToString())"
    }
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
# Requires -Version 20
# AnsibleRequires -OSVersion 20
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy

$params = Parse-Args $args -supports_check_mode $true

$data = Get-AnsibleParam -obj $params -name "data" -type "str" -default "normal"
$result = @{
    changed = $false
}

<#
This module tests various error events in PowerShell to verify our hidden trap
catches them all and outputs a pretty error message with a traceback to help
users debug the actual issue

normal - normal execution, no errors
fail - Calls Fail-Json like normal
throw - throws an exception
error - Write-Error with ErrorActionPreferenceStop
cmdlet_error - Calls a Cmdlet with an invalid error
dotnet_exception - Calls a .NET function that will throw an error
function_throw - Throws an exception in a function
proc_exit_fine - calls an executable with a non-zero exit code with Exit-Json
proc_exit_fail - calls an executable with a non-zero exit code with Fail-Json
#>

Function Test-ThrowException {
    throw "exception in function"
}

if ($data -eq "normal") {
    Exit-Json -obj $result
} elseif ($data -eq "fail") {
    Fail-Json -obj $result -message "fail message"
} elseif ($data -eq "throw") {
    throw [ArgumentException]"module is thrown"
} elseif ($data -eq "error") {
    Write-Error -Message $data
} elseif ($data -eq "cmdlet_error") {
    Get-Item -Path "fake:\path"
} elseif ($data -eq "dotnet_exception") {
    [System.IO.Path]::GetFullPath($null)
} elseif ($data -eq "function_throw") {
    Test-ThrowException
} elseif ($data -eq "proc_exit_fine") {
    # verifies that if no error was actually fired and we have an output, we
    # don't use the RC to validate if the module failed
    &cmd.exe /c exit 2
    Exit-Json -obj $result
} elseif ($data -eq "proc_exit_fail") {
    &cmd.exe /c exit 2
    Fail-Json -obj $result -message "proc_exit_fail"
}

#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.SID
#Requires -Version 3.0
#AnsibleRequires -OSVersion 6
#AnsibleRequires -Become

$output = &whoami.exe
$sid = Convert-ToSID -account_name $output.Trim()
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy

$ErrorActionPreference = "Stop"

Function Assert-Equals($actual, $expected) {
    if ($actual -cne $expected) {
        $call_stack = (Get-PSCallStack)[1]
        $error_msg = "AssertionError:`r`nActual: `"$actual`" != Expected: `"$expected`"`r`nLine: $($call_stack.ScriptLineNumber), Method: $($call_stack.Position.Text)"
        Fail-Json -obj $result -message $error_msg
    }
}

$result = @{
    changed = $false
}

#ConvertFrom-AnsibleJso
$input_json  = '{"string":"string","float":3.1415926,"dict":{"string":"string","int":1},"list":["entry 1","entry 2"],"null":null,"int":1}'
$actual = ConvertFrom-AnsibleJson -InputObject $input_json
Assert-Equals -actual $actual.GetType() -expected ([Hashtable])
Assert-Equals -actual $actual.string.GetType() -expected ([String])
Assert-Equals -actual $actual.string -expected "string"
Assert-Equals -actual $actual.int.GetType() -expected ([Int32])
Assert-Equals -actual $actual.int -expected 1
Assert-Equals -actual $actual.null -expected $null
Assert-Equals -actual $actual.float.GetType() -expected ([Decimal])
Assert-Equals -actual $actual.float -expected 3.1415926
Assert-Equals -actual $actual.list.GetType() -expected ([Object[]])
Assert-Equals -actual $actual.list.Count -expected 2
Assert-Equals -actual $actual.list[0] -expected "entry 1"
Assert-Equals -actual $actual.list[1] -expected "entry 2"
Assert-Equals -actual $actual.GetType() -expected ([Hashtable])
Assert-Equals -actual $actual.dict.string -expected "string"
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Version 20.0.0.0

#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#AnsibleRequires -OSVersion 20.0

#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.CamelConversion

$ErrorActionPreference = 'Stop'

Function Assert-Equals($actual, $expected) {
    if ($actual -cne $expected) {
        Fail-Json @{} "actual != expected`nActual: $actual`nExpected: $expected"
    }
}

$input_dict = @{
    alllower = 'alllower'
    ALLUPPER = 'allupper'
    camelCase = 'camel_case'
    mixedCase_withCamel = 'mixed_case_with_camel'
    TwoWords = 'two_words'
    AllUpperAtEND = 'all_upper_at_end'
    AllUpperButPLURALs = 'all_upper_but_plurals'
    TargetGroupARNs = 'target_group_arns'
    HTTPEndpoints = 'http_endpoints'
    PLURALs = 'plurals'
    listDict = @(
        @{ entry1 = 'entry1'; entryTwo = 'entry_two' },
        'stringTwo',
        0
    )
    INNERHashTable = @{
        ID = 'id'
        IEnumerable = 'i_enumerable'
    }
    emptyList = @()
    singleList = @("a")
}

$output_dict = Convert-DictToSnakeCase -dict $input_dict
foreach ($entry in $output_dict.GetEnumerator()) {
    $key = $entry.Name
    $value = $entry.Value

    if ($value -is [Hashtable]) {
        Assert-Equals -actual $key -expected "inner_hash_table"
        foreach ($inner_hash in $value.GetEnumerator()) {
            Assert-Equals -actual $inner_hash.Name -expected $inner_hash.Value
        }
    } elseif ($value -is [Array] -or $value -is [System.Collections.ArrayList]) {
        if ($key -eq "list_dict") {
            foreach ($inner_list in $value) {
                if ($inner_list -is [Hashtable]) {
                    foreach ($inner_list_hash in $inner_list.GetEnumerator()) {
                        Assert-Equals -actual $inner_list_hash.Name -expected $inner_list_hash.Value
                    }
                } elseif ($inner_list -is [String]) {
                    # this is not a string key so we need to keep it the same
                    Assert-Equals -actual $inner_list -expected "stringTwo"
                } else {
                    Assert-Equals -actual $inner_list -expected 0
                }
            }
        } elseif ($key -eq "empty_list") {
            Assert-Equals -actual $value.Count -expected 0
        } elseif ($key -eq "single_list") {
            Assert-Equals -actual $value.Count -expected 1
        } else {
            Fail-Json -obj $result -message "invalid key found for list $key"
        }
    } else {
        Assert-Equals -actual $key -expected $value
# Test script to make sure the Ansible script module works when arguments are
# passed to the script.

foreach ($i in $args)
{
Param(
[bool]$boolvariable
)

Write-Output $boolvariable.GetType().FullName
# Test script to make sure we handle non-zero exit codes.

trap
{
    Write-Error -ErrorRecord $_
# Test script to make sure the Ansible script module works when arguments are
# passed via splatting (http://technet.microsoft.com/en-us/magazine/gg675931.aspx)

Write-Host $args.This
Write-Host $args.That
if (Test-Path -Path '{{win_output_dir}}\win_reboot_test') {
    New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager' `
        -Name PendingFileRenameOperations `
        -Value @("\??\{{win_output_dir}}\win_reboot_test`0") `
        -PropertyType MultiString
#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic
#Requires -Module Ansible.ModuleUtils.WebRequest

$spec = @{
    options = @{
        httpbin_host = @{ type = 'str'; required = $true }
    }
}

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

$httpbin_host = $module.Params.httpbin_host

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array] -or $Actual -is [System.Collections.IList]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actualValue = $Actual[$i]
            $expectedValue = $Expected[$i]
            Assert-Equals -Actual $actualValue -Expected $expectedValue
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text

        $module.FailJson("AssertionError: actual != expected")
    }
}

Function Convert-StreamToString {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [System.IO.Stream]
        $Stream
    )

    $ms = New-Object -TypeName System.IO.MemoryStream
    try {
        $Stream.CopyTo($ms)
        [System.Text.Encoding]::UTF8.GetString($ms.ToArray())
    } finally {
        $ms.Dispose()
    }
}

$tests = [Ordered]@{
    'GET request over http' = {
        $r = Get-AnsibleWebRequest -Uri "http://$httpbin_host/get"

        $r.Method | Assert-Equals -Expected 'GET'
        $r.Timeout | Assert-Equals -Expected 30000
        $r.UseDefaultCredentials | Assert-Equals -Expected $false
        $r.Credentials | Assert-Equals -Expected $null
        $r.ClientCertificates.Count | Assert-Equals -Expected 0
        $r.Proxy.Credentials | Assert-Equals -Expected $null
        $r.UserAgent | Assert-Equals -Expected 'ansible-httpget'

        $actual = Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.StatusCode | Assert-Equals -Expected 200
            Convert-StreamToString -Stream $Stream
        } | ConvertFrom-Json

        $actual.headers.'User-Agent' | Assert-Equals -Expected 'ansible-httpget'
        $actual.headers.'Host' | Assert-Equals -Expected $httpbin_host

        $module.Result.msg | Assert-Equals -Expected 'OK'
        $module.Result.status_code | Assert-Equals -Expected 200
        $module.Result.ContainsKey('elapsed') | Assert-Equals -Expected $true
    }

    'GET request over https' = {
        # url is an alias for the -Uri parameter.
        $r = Get-AnsibleWebRequest -url "https://$httpbin_host/get"

        $r.Method | Assert-Equals -Expected 'GET'
        $r.Timeout | Assert-Equals -Expected 30000
        $r.UseDefaultCredentials | Assert-Equals -Expected $false
        $r.Credentials | Assert-Equals -Expected $null
        $r.ClientCertificates.Count | Assert-Equals -Expected 0
        $r.Proxy.Credentials | Assert-Equals -Expected $null
        $r.UserAgent | Assert-Equals -Expected 'ansible-httpget'

        $actual = Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.StatusCode | Assert-Equals -Expected 200
            Convert-StreamToString -Stream $Stream
        } | ConvertFrom-Json

        $actual.headers.'User-Agent' | Assert-Equals -Expected 'ansible-httpget'
        $actual.headers.'Host' | Assert-Equals -Expected $httpbin_host
    }

    'POST request' = {
        $getParams = @{
            Headers = @{
                'Content-Type' = 'application/json'
            }
            Method = 'POST'
            Uri = "https://$httpbin_host/post"
        }
        $r = Get-AnsibleWebRequest @getParams

        $r.Method | Assert-Equals -Expected 'POST'
        $r.Timeout | Assert-Equals -Expected 30000
        $r.UseDefaultCredentials | Assert-Equals -Expected $false
        $r.Credentials | Assert-Equals -Expected $null
        $r.ClientCertificates.Count | Assert-Equals -Expected 0
        $r.Proxy.Credentials | Assert-Equals -Expected $null
        $r.ContentType | Assert-Equals -Expected 'application/json'
        $r.UserAgent | Assert-Equals -Expected 'ansible-httpget'

        $body = New-Object -TypeName System.IO.MemoryStream -ArgumentList @(,
            ([System.Text.Encoding]::UTF8.GetBytes('{"foo":"bar"}'))
        )
        $actual = Invoke-WithWebRequest -Module $module -Request $r -Body $body -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.StatusCode | Assert-Equals -Expected 200
            Convert-StreamToString -Stream $Stream
        } | ConvertFrom-Json

        $actual.headers.'User-Agent' | Assert-Equals -Expected 'ansible-httpget'
        $actual.headers.'Host' | Assert-Equals -Expected $httpbin_host
        $actual.data | Assert-Equals -Expected '{"foo":"bar"}'
    }

    'Safe redirection of GET' = {
        $r = Get-AnsibleWebRequest -Uri "http://$httpbin_host/redirect/2"

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected "http://$httpbin_host/get"
            $Response.StatusCode | Assert-Equals -Expected 200
        }
    }

    'Safe redirection of HEAD' = {
        $r = Get-AnsibleWebRequest -Uri "http://$httpbin_host/redirect/2" -Method HEAD

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected "http://$httpbin_host/get"
            $Response.StatusCode | Assert-Equals -Expected 200
        }
    }

    'Safe redirection of PUT' = {
        $params = @{
            Method = 'PUT'
            Uri = "http://$httpbin_host/redirect-to?url=https://$httpbin_host/put"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected $r.RequestUri
            $Response.StatusCode | Assert-Equals -Expected 302
        }
    }

    'None redirection of GET' = {
        $params = @{
            FollowRedirects = 'None'
            Uri = "http://$httpbin_host/redirect/2"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected $r.RequestUri
            $Response.StatusCode | Assert-Equals -Expected 302
        }
    }

    'None redirection of HEAD' = {
        $params = @{
            follow_redirects = 'None'
            method = 'HEAD'
            Uri = "http://$httpbin_host/redirect/2"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected $r.RequestUri
            $Response.StatusCode | Assert-Equals -Expected 302
        }
    }

    'None redirection of PUT' = {
        $params = @{
            FollowRedirects = 'None'
            Method = 'PUT'
            Uri = "http://$httpbin_host/redirect-to?url=https://$httpbin_host/put"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected $r.RequestUri
            $Response.StatusCode | Assert-Equals -Expected 302
        }
    }

    'All redirection of GET' = {
        $params = @{
            FollowRedirects = 'All'
            Uri = "http://$httpbin_host/redirect/2"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected "http://$httpbin_host/get"
            $Response.StatusCode | Assert-Equals -Expected 200
        }
    }

    'All redirection of HEAD' = {
        $params = @{
            follow_redirects = 'All'
            method = 'HEAD'
            Uri = "http://$httpbin_host/redirect/2"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected "http://$httpbin_host/get"
            $Response.StatusCode | Assert-Equals -Expected 200
        }
    }

    'All redirection of PUT' = {
        $params = @{
            FollowRedirects = 'All'
            Method = 'PUT'
            Uri = "http://$httpbin_host/redirect-to?url=https://$httpbin_host/put"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected "https://$httpbin_host/put"
            $Response.StatusCode | Assert-Equals -Expected 200
        }
    }

    'Exceeds maximum redirection - ignored' = {
        $params = @{
            MaximumRedirection = 4
            Uri = "https://$httpbin_host/redirect/5"
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -IgnoreBadResponse -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected "https://$httpbin_host/relative-redirect/1"
            $Response.StatusCode | Assert-Equals -Expected 302
        }
    }

    'Exceeds maximum redirection - exception' = {
        $params = @{
            MaximumRedirection = 1
            Uri = "https://$httpbin_host/redirect/2"
        }
        $r = Get-AnsibleWebRequest @params

        $failed = $false
        try {
            $null = Invoke-WithWebRequest -Module $module -Request $r -Script {}
        } catch {
            $_.Exception.GetType().Name | Assert-Equals -Expected 'WebException'
            $_.Exception.Message | Assert-Equals -Expected 'Too many automatic redirections were attempted.'
            $failed = $true
        }
        $failed | Assert-Equals -Expected $true
    }

    'Basic auth as Credential' = {
        $params = @{
            Url = "http://$httpbin_host/basic-auth/username/password"
            UrlUsername = 'username'
            UrlPassword = 'password'
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -IgnoreBadResponse -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.StatusCode | Assert-Equals -Expected 200
        }
    }

    'Basic auth as Header' = {
        $params = @{
            Url = "http://$httpbin_host/basic-auth/username/password"
            url_username = 'username'
            url_password = 'password'
            ForceBasicAuth = $true
        }
        $r = Get-AnsibleWebRequest @params

        Invoke-WithWebRequest -Module $module -Request $r -IgnoreBadResponse -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.StatusCode | Assert-Equals -Expected 200
        }
    }

    'Send request with headers' = {
        $params = @{
            Headers = @{
                'Content-Length' = 0
                testingheader = 'testing_header'
                TestHeader = 'test-header'
                'User-Agent' = 'test-agent'
            }
            Url = "https://$httpbin_host/get"
        }
        $r = Get-AnsibleWebRequest @params

        $actual = Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.StatusCode | Assert-Equals -Expected 200
            Convert-StreamToString -Stream $Stream
        } | ConvertFrom-Json

        $actual.headers.'Testheader' | Assert-Equals -Expected 'test-header'
        $actual.headers.'testingheader' | Assert-Equals -Expected 'testing_header'
        $actual.Headers.'User-Agent' | Assert-Equals -Expected 'test-agent'
    }

    'Request with timeout' = {
        $params = @{
            Uri = "https://$httpbin_host/delay/5"
            Timeout = 1
        }
        $r = Get-AnsibleWebRequest @params

        $failed = $false
        try {
            $null = Invoke-WithWebRequest -Module $module -Request $r -Script {}
        } catch {
            $failed = $true
            $_.Exception.GetType().Name | Assert-Equals -Expected WebException
            $_.Exception.Message | Assert-Equals -Expected 'The operation has timed out'
        }
        $failed | Assert-Equals -Expected $true
    }

    'Request with file URI' = {
        $filePath = Join-Path $module.Tmpdir -ChildPath 'test.txt'
        Set-Content -LiteralPath $filePath -Value 'test'

        $r = Get-AnsibleWebRequest -Uri $filePath

        $actual = Invoke-WithWebRequest -Module $module -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ContentLength | Assert-Equals -Expected 6
            Convert-StreamToString -Stream $Stream
        }
        $actual | Assert-Equals -Expected "test`r`n"
        $module.Result.msg | Assert-Equals -Expected "OK"
        $module.Result.status_code | Assert-Equals -Expected 200
    }

    'Web request based on module options' = {
        Set-Variable complex_args -Scope Global -Value @{
            url = "https://$httpbin_host/redirect/2"
            method = 'GET'
            follow_redirects = 'safe'
            headers = @{
                'User-Agent' = 'other-agent'
            }
            http_agent = 'actual-agent'
            maximum_redirection = 2
            timeout = 10
            validate_certs = $false
        }
        $spec = @{
            options = @{
                url = @{ type = 'str'; required = $true }
                test = @{ type = 'str'; choices = 'abc', 'def'}
            }
            mutually_exclusive = @(,@('url', 'test'))
        }

        $testModule = [Ansible.Basic.AnsibleModule]::Create(@(), $spec, @(Get-AnsibleWebRequestSpec))
        $r = Get-AnsibleWebRequest -Url $testModule.Params.url -Module $testModule

        $actual = Invoke-WithWebRequest -Module $testModule -Request $r -Script {
            Param ([System.Net.WebResponse]$Response, [System.IO.Stream]$Stream)

            $Response.ResponseUri | Assert-Equals -Expected "https://$httpbin_host/get"
            Convert-StreamToString -Stream $Stream
        } | ConvertFrom-Json
        $actual.headers.'User-Agent' | Assert-Equals -Expected 'actual-agent'
    }

    'Web request with default proxy' = {
        $params = @{
            Uri = "https://$httpbin_host/get"
        }
        $r = Get-AnsibleWebRequest @params

        $null -ne $r.Proxy | Assert-Equals -Expected $true
    }

    'Web request with no proxy' = {
        $params = @{
            Uri = "https://$httpbin_host/get"
            UseProxy = $false
        }
        $r = Get-AnsibleWebRequest @params

        $null -eq $r.Proxy | Assert-Equals -Expected $true
    }
}

# setup and teardown should favour native tools to create and delete the service and not the util we are testing.
foreach ($testImpl in $tests.GetEnumerator()) {
    Set-Variable -Name complex_args -Scope Global -Value @{}
    $test = $testImpl.Key
    &$testImpl.Value
}

#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

throw

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

$blah = 'I can't quote my strings correctly.'

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
    changed = $false
    ping = "pong"
};

# Test that Set-Attr will replace an existing attribute.
Set-Attr $result "ping" $data

#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

throw "no ping for you"

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

$params = Parse-Args $args $true;

$params.thisPropertyDoesNotExist

$data = Get-Attr $params "data" "pong";

$result = @{
#AnsibleRequires -CSharpUtil .sub_pkg.CSRel4

Function Invoke-FromPSRel3 {
    <#
    .SYNOPSIS
    Test function
    #>
    return "$([CSRel4]::Invoke()) -> Invoke-FromPSRel3"
}

#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -PowerShell ..module_utils.PSRel1

#AnsibleRequires -PowerShell .sub_pkg.PSRel2

Function Invoke-FromPSRel1 {
    <#
    .SYNOPSIS
    Test function
    #>
    return "$(Invoke-FromPSRel2) -> Invoke-FromPSRel1"
}

#AnsibleRequires -PowerShell ansible_collections.my_ns.my_col2.plugins.module_utils.PSRel3

Function Invoke-FromPSRel2 {
    <#
    .SYNOPSIS
    Test function
    #>
    return "$(Invoke-FromPSRel3) -> Invoke-FromPSRel2"
}

#powershell

#Requires -Module Ansible.ModuleUtils.Legacy

$params = Parse-Args $args
#powershell

#Requires -Module Ansible.ModuleUtils.Legacy

$params = Parse-Args $args
$value = Get-AnsibleParam -Obj $params -Name value -Type list

if ($value -isnot [array]) {
    Fail-Json -obj @{} -message "value was not a list but was $($value.GetType().FullName)"
}
#1powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#AnsibleRequires -CSharpUtil Ansible.Test

$result = @{
    res = [Ansible.Test.OutputTest]::GetString()
    changed = $false
}

#!powershell

# use different cases, spacing and plural of 'module' to exercise flexible powershell dialect
#ReQuiReS   -ModUleS    Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.ValidTestModule
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.Recursive3
#Requires -Version 2

$ErrorActionPreference = "Stop"

$result = @{
    changed = $false
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy

Exit-Json @{ data="success" }
#!powershell

# this should fail
#Requires -Module Ansible.ModuleUtils.BogusModule

Function Get-Test1 {
    <#
    .SYNOPSIS
    Test function
    #>
#Requires -Module Ansible.ModuleUtils.Recursive2
#Requires -Version 3.0

Function Get-Test3 {
    <#
    .SYNOPSIS
    Test function
    #>
    return "Get-Test3: 2: $(Get-Test2)"
}

Function Get-NewTest3 {
    <#
    .SYNOPSIS
    Test function
#Requires -Module Ansible.ModuleUtils.Recursive1
#Requires -Module Ansible.ModuleUtils.Recursive3

Function Get-Test2 {
    <#
    .SYNOPSIS
    Test function
    #>
    return "Get-Test2, 1: $(Get-Test1), 3: $(Get-NewTest3)"
}
#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic
#Requires -Module Ansible.ModuleUtils.PrivilegeUtil

$module = [Ansible.Basic.AnsibleModule]::Create($args, @{})

Function Assert-Equals($actual, $expected) {
    if ($actual -cne $expected) {
        $call_stack = (Get-PSCallStack)[1]
        $module.Result.actual = $actual
        $module.Result.expected = $expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text
        $module.FailJson("AssertionError: actual != expected")
    }
}

# taken from https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/privilege-constants
$total_privileges = @(
    "SeAssignPrimaryTokenPrivilege",
    "SeAuditPrivilege",
    "SeBackupPrivilege",
    "SeChangeNotifyPrivilege",
    "SeCreateGlobalPrivilege",
    "SeCreatePagefilePrivilege",
    "SeCreatePermanentPrivilege",
    "SeCreateSymbolicLinkPrivilege",
    "SeCreateTokenPrivilege",
    "SeDebugPrivilege",
    "SeEnableDelegationPrivilege",
    "SeImpersonatePrivilege",
    "SeIncreaseBasePriorityPrivilege",
    "SeIncreaseQuotaPrivilege",
    "SeIncreaseWorkingSetPrivilege",
    "SeLoadDriverPrivilege",
    "SeLockMemoryPrivilege",
    "SeMachineAccountPrivilege",
    "SeManageVolumePrivilege",
    "SeProfileSingleProcessPrivilege",
    "SeRelabelPrivilege",
    "SeRemoteShutdownPrivilege",
    "SeRestorePrivilege",
    "SeSecurityPrivilege",
    "SeShutdownPrivilege",
    "SeSyncAgentPrivilege",
    "SeSystemEnvironmentPrivilege",
    "SeSystemProfilePrivilege",
    "SeSystemtimePrivilege",
    "SeTakeOwnershipPrivilege",
    "SeTcbPrivilege",
    "SeTimeZonePrivilege",
    "SeTrustedCredManAccessPrivilege",
    "SeUndockPrivilege"
)

$raw_privilege_output = &whoami /priv | Where-Object { $_.StartsWith("Se") }
$actual_privileges = @{}
foreach ($raw_privilege in $raw_privilege_output) {
    $split = $raw_privilege.TrimEnd() -split " "
    $actual_privileges."$($split[0])" = ($split[-1] -eq "Enabled")
}
$process = [Ansible.Privilege.PrivilegeUtil]::GetCurrentProcess()

### Test PS cmdlets ###
# test ps Get-AnsiblePrivilege
foreach ($privilege in $total_privileges) {
    $expected = $null
    if ($actual_privileges.ContainsKey($privilege)) {
        $expected = $actual_privileges.$privilege
    }
    $actual = Get-AnsiblePrivilege -Name $privilege
    Assert-Equals -actual $actual -expected $expected
}

# test c# GetAllPrivilegeInfo
$actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
Assert-Equals -actual $actual.GetType().Name -expected 'Dictionary`2'
Assert-Equals -actual $actual.Count -expected $actual_privileges.Count
foreach ($privilege in $total_privileges) {
    if ($actual_privileges.ContainsKey($privilege)) {
        $actual_value = $actual.$privilege
        if ($actual_privileges.$privilege) {
            Assert-Equals -actual $actual_value.HasFlag([Ansible.Privilege.PrivilegeAttributes]::Enabled) -expected $true
        } else {
            Assert-Equals -actual $actual_value.HasFlag([Ansible.Privilege.PrivilegeAttributes]::Enabled) -expected $false
        }
    }
}

# test Set-AnsiblePrivilege
Set-AnsiblePrivilege -Name SeUndockPrivilege -Value $false  # ensure we start with a disabled privilege

Set-AnsiblePrivilege -Name SeUndockPrivilege -Value $true -WhatIf
$actual = Get-AnsiblePrivilege -Name SeUndockPrivilege
Assert-Equals -actual $actual -expected $false

Set-AnsiblePrivilege -Name SeUndockPrivilege -Value $true
$actual = Get-AnsiblePrivilege -Name SeUndockPrivilege
Assert-Equals -actual $actual -expected $true

Set-AnsiblePrivilege -Name SeUndockPrivilege -Value $false -WhatIf
$actual = Get-AnsiblePrivilege -Name SeUndockPrivilege
Assert-Equals -actual $actual -expected $true

Set-AnsiblePrivilege -Name SeUndockPrivilege -Value $false
$actual = Get-AnsiblePrivilege -Name SeUndockPrivilege
Assert-Equals -actual $actual -expected $false

$module.Result.data = "success"
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.FileUtil

$ErrorActionPreference = "Stop"

$result = @{
    changed = $false
}

Function Assert-Equals($actual, $expected) {
    if ($actual -cne $expected) {
        $call_stack = (Get-PSCallStack)[1]
        $error_msg = "AssertionError:`r`nActual: `"$actual`" != Expected: `"$expected`"`r`nLine: $($call_stack.ScriptLineNumber), Method: $($call_stack.Position.Text)"
        Fail-Json -obj $result -message $error_msg
    }
}

Function Get-PagefilePath() {
    $pagefile = $null
    $cs = Get-CimInstance -ClassName Win32_ComputerSystem
    if ($cs.AutomaticManagedPagefile) {
        $pagefile = "$($env:SystemRoot.Substring(0, 1)):\pagefile.sys"
    } else {
        $pf = Get-CimInstance -ClassName Win32_PageFileSetting
        if ($null -ne $pf) {
            $pagefile = $pf[0].Name
        }
    }
    return $pagefile
}

$pagefile = Get-PagefilePath
if ($pagefile) {
    # Test-AnsiblePath Hidden system file
    $actual = Test-AnsiblePath -Path $pagefile
    Assert-Equals -actual $actual -expected $true

    # Get-AnsibleItem file
    $actual = Get-AnsibleItem -Path $pagefile
    Assert-Equals -actual $actual.FullName -expected $pagefile
    Assert-Equals -actual $actual.Attributes.HasFlag([System.IO.FileAttributes]::Directory) -expected $false
    Assert-Equals -actual $actual.Exists -expected $true
}

# Test-AnsiblePath File that doesn't exist
$actual = Test-AnsiblePath -Path C:\fakefile
Assert-Equals -actual $actual -expected $false

# Test-AnsiblePath Directory that doesn't exist
$actual = Test-AnsiblePath -Path C:\fakedirectory
Assert-Equals -actual $actual -expected $false

# Test-AnsiblePath file in non-existant directory
$actual = Test-AnsiblePath -Path C:\fakedirectory\fakefile.txt
Assert-Equals -actual $actual -expected $false

# Test-AnsiblePath Normal directory
$actual = Test-AnsiblePath -Path C:\Windows
Assert-Equals -actual $actual -expected $true

# Test-AnsiblePath Normal file
$actual = Test-AnsiblePath -Path C:\Windows\System32\kernel32.dll
Assert-Equals -actual $actual -expected $true

# Test-AnsiblePath fails with wildcard
$failed = $false
try {
    Test-AnsiblePath -Path C:\Windows\*.exe
} catch {
    $failed = $true
    Assert-Equals -actual $_.Exception.Message -expected "Exception calling `"GetAttributes`" with `"1`" argument(s): `"Illegal characters in path.`""
}
Assert-Equals -actual $failed -expected $true

# Test-AnsiblePath on non file PS Provider object
$actual = Test-AnsiblePath -Path Cert:\LocalMachine\My
Assert-Equals -actual $actual -expected $true

# Test-AnsiblePath on environment variable
$actual = Test-AnsiblePath -Path env:SystemDrive
Assert-Equals -actual $actual -expected $true

# Test-AnsiblePath on environment variable that does not exist
$actual = Test-AnsiblePath -Path env:FakeEnvValue
Assert-Equals -actual $actual -expected $false

# Get-AnsibleItem doesn't exist with -ErrorAction SilentlyContinue param
$actual = Get-AnsibleItem -Path C:\fakefile -ErrorAction SilentlyContinue
Assert-Equals -actual $actual -expected $null

# Get-AnsibleItem directory
$actual = Get-AnsibleItem -Path C:\Windows
Assert-Equals -actual $actual.FullName -expected C:\Windows
Assert-Equals -actual $actual.Attributes.HasFlag([System.IO.FileAttributes]::Directory) -expected $true
Assert-Equals -actual $actual.Exists -expected $true

# ensure Get-AnsibleItem doesn't fail in a try/catch and -ErrorAction SilentlyContinue - stop's a trap from trapping it
try {
    $actual = Get-AnsibleItem -Path C:\fakepath -ErrorAction SilentlyContinue
} catch {
    Fail-Json -obj $result -message "this should not fire"
}
Assert-Equals -actual $actual -expected $null
#Requires -Version 5.0 -Modules CimCmdlets

Function ConvertFrom-CimInstance {
    param(
        [Parameter(Mandatory=$true)][CimInstance]$Instance
    )
    $hashtable = @{
        _cim_instance = $Instance.CimSystemProperties.ClassName
    }
    foreach ($prop in $Instance.CimInstanceProperties) {
        $hashtable."$($prop.Name)" = ConvertTo-OutputValue -Value $prop.Value
    }
    return $hashtable
}

Function ConvertTo-OutputValue {
    param($Value)

    if ($Value -is [DateTime[]]) {
        $Value = $Value | ForEach-Object { $_.ToString("o") }
    } elseif ($Value -is [DateTime]) {
        $Value = $Value.ToString("o")
    } elseif ($Value -is [Double]) {
        $Value = $Value.ToString()  # To avoid Python 2 double parsing issues on test validation
    } elseif ($Value -is [Double[]]) {
        $Value = $Value | ForEach-Object { $_.ToString() }
    } elseif ($Value -is [PSCredential]) {
        $password = $null
        $password_ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($Value.Password)
        try {
            $password = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($password_ptr)
        } finally {
            [System.Runtime.InteropServices.Marshal]::ZeroFreeGlobalAllocUnicode($password_ptr)
        }
        $Value = @{
            username = $Value.Username
            password = $password
        }
    } elseif ($Value -is [CimInstance[]]) {
        $value_list = [System.Collections.Generic.List`1[Hashtable]]@()
        foreach ($cim_instance in $Value) {
            $value_list.Add((ConvertFrom-CimInstance -Instance $cim_instance))
        }
        $Value = $value_list.ToArray()
    } elseif ($Value -is [CimInstance]) {
        $Value = ConvertFrom-CimInstance -Instance $Value
    }

    return ,$Value
}

Function Get-TargetResource
{
    [CmdletBinding()]
    [OutputType([Hashtable])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Present", "Absent")]
        [String] $Ensure = "Present",

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String] $Path
    )
    return @{
        Ensure = $Ensure
        Path = $Path
    }
}

Function Set-TargetResource
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet("Present", "Absent")]
        [String] $Ensure = "Present",

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String] $Path,

        [String] $DefaultParam = "Default",
        [String] $StringParam,
        [String[]] $StringArrayParam,
        [SByte] $Int8Param,
        [SByte[]] $Int8ArrayParam,
        [Byte] $UInt8Param,
        [Byte[]] $UInt8ArrayParam,
        [Int16] $Int16Param,
        [Int16[]] $Int16ArrayParam,
        [UInt16] $UInt16Param,
        [UInt16[]] $UInt16ArrayParam,
        [Int32] $Int32Param,
        [Int32[]] $Int32ArrayParam,
        [UInt32] $UInt32Param,
        [UInt32[]] $UInt32ArrayParam,
        [Int64] $Int64Param,
        [Int64[]] $Int64ArrayParam,
        [UInt64] $UInt64Param,
        [UInt64[]] $UInt64ArrayParam,
        [Bool] $BooleanParam,
        [Bool[]] $BooleanArrayParam,
        [Char] $CharParam,
        [Char[]] $CharArrayParam,
        [Single] $SingleParam,
        [Single[]] $SingleArrayParam,
        [Double] $DoubleParam,
        [Double[]] $DoubleArrayParam,
        [DateTime] $DateTimeParam,
        [DateTime[]] $DateTimeArrayParam,
        [PSCredential] $PSCredentialParam,
        [CimInstance[]] $HashtableParam,
        [CimInstance] $CimInstanceParam,
        [CimInstance[]] $CimInstanceArrayParam,
        [CimInstance] $NestedCimInstanceParam,
        [CimInstance[]] $NestedCimInstanceArrayParam
    )

    $info = @{
        Version = "1.0.1"
        Ensure = @{
            Type = $Ensure.GetType().FullName
            Value = $Ensure
        }
        Path = @{
            Type = $Path.GetType().FullName
            Value = $Path
        }
        DefaultParam = @{
            Type = $DefaultParam.GetType().FullName
            Value = $DefaultParam
        }
    }

    foreach ($kvp in $PSCmdlet.MyInvocation.BoundParameters.GetEnumerator()) {
        $info."$($kvp.Key)" = @{
            Type = $kvp.Value.GetType().FullName
            Value = (ConvertTo-OutputValue -Value $kvp.Value)
        }
    }

    if (Test-Path -Path $Path) {
        Remove-Item -Path $Path -Force > $null
    }
    New-Item -Path $Path -ItemType File > $null
    Set-Content -Path $Path -Value (ConvertTo-Json -InputObject $info -Depth 10) > $null
    Write-Verbose -Message "set verbose"
    Write-Warning -Message "set warning"
}

Function Test-TargetResource
{
    [CmdletBinding()]
    [OutputType([Boolean])]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet("Present", "Absent")]
        [String] $Ensure = "Present",

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String] $Path,

        [String] $DefaultParam = "Default",
        [String] $StringParam,
        [String[]] $StringArrayParam,
        [SByte] $Int8Param,
        [SByte[]] $Int8ArrayParam,
        [Byte] $UInt8Param,
        [Byte[]] $UInt8ArrayParam,
        [Int16] $Int16Param,
        [Int16[]] $Int16ArrayParam,
        [UInt16] $UInt16Param,
        [UInt16[]] $UInt16ArrayParam,
        [Int32] $Int32Param,
        [Int32[]] $Int32ArrayParam,
        [UInt32] $UInt32Param,
        [UInt32[]] $UInt32ArrayParam,
        [Int64] $Int64Param,
        [Int64[]] $Int64ArrayParam,
        [UInt64] $UInt64Param,
        [UInt64[]] $UInt64ArrayParam,
        [Bool] $BooleanParam,
        [Bool[]] $BooleanArrayParam,
        [Char] $CharParam,
        [Char[]] $CharArrayParam,
        [Single] $SingleParam,
        [Single[]] $SingleArrayParam,
        [Double] $DoubleParam,
        [Double[]] $DoubleArrayParam,
        [DateTime] $DateTimeParam,
        [DateTime[]] $DateTimeArrayParam,
        [PSCredential] $PSCredentialParam,
        [CimInstance[]] $HashtableParam,
        [CimInstance] $CimInstanceParam,
        [CimInstance[]] $CimInstanceArrayParam,
        [CimInstance] $NestedCimInstanceParam,
        [CimInstance[]] $NestedCimInstanceArrayParam
    )
    Write-Verbose -Message "test verbose"
    Write-Warning -Message "test warning"
    $exists = Test-Path -LiteralPath $Path -PathType Leaf
    if ($Ensure -eq "Present") {
        $exists
    } else {
        -not $exists
    }
@{
    ModuleVersion = '1.0.1'
    GUID = '80c895c4-de3f-4d6d-8fa4-c504c96b6f22'
    Author = 'Ansible'
    CompanyName = 'Ansible'
    Copyright = '(c) 2019'
    Description = 'Test DSC Resource for Ansible integration tests'
    PowerShellVersion = '5.0'
    CLRVersion = '4.0'
    FunctionsToExport = '*'
#Requires -Version 5.0 -Modules CimCmdlets

Function ConvertFrom-CimInstance {
    param(
        [Parameter(Mandatory=$true)][CimInstance]$Instance
    )
    $hashtable = @{
        _cim_instance = $Instance.CimSystemProperties.ClassName
    }
    foreach ($prop in $Instance.CimInstanceProperties) {
        $hashtable."$($prop.Name)" = ConvertTo-OutputValue -Value $prop.Value
    }
    return $hashtable
}

Function ConvertTo-OutputValue {
    param($Value)

    if ($Value -is [DateTime[]]) {
        $Value = $Value | ForEach-Object { $_.ToString("o") }
    } elseif ($Value -is [DateTime]) {
        $Value = $Value.ToString("o")
    } elseif ($Value -is [Double]) {
        $Value = $Value.ToString()  # To avoid Python 2 double parsing issues on test validation
    } elseif ($Value -is [Double[]]) {
        $Value = $Value | ForEach-Object { $_.ToString() }
    } elseif ($Value -is [PSCredential]) {
        $password = $null
        $password_ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($Value.Password)
        try {
            $password = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($password_ptr)
        } finally {
            [System.Runtime.InteropServices.Marshal]::ZeroFreeGlobalAllocUnicode($password_ptr)
        }
        $Value = @{
            username = $Value.Username
            password = $password
        }
    } elseif ($Value -is [CimInstance[]]) {
        $value_list = [System.Collections.Generic.List`1[Hashtable]]@()
        foreach ($cim_instance in $Value) {
            $value_list.Add((ConvertFrom-CimInstance -Instance $cim_instance))
        }
        $Value = $value_list.ToArray()
    } elseif ($Value -is [CimInstance]) {
        $Value = ConvertFrom-CimInstance -Instance $Value
    }

    return ,$Value
}

Function Get-TargetResource
{
    [CmdletBinding()]
    [OutputType([Hashtable])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Present", "Absent")]
        [String] $Ensure = "Present",

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String] $Path
    )
    return @{
        Ensure = $Ensure
        Path = $Path
    }
}

Function Set-TargetResource
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet("Present", "Absent")]
        [String] $Ensure = "Present",

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String] $Path,

        [String] $DefaultParam = "Default",
        [String] $StringParam,
        [String[]] $StringArrayParam,
        [SByte] $Int8Param,
        [SByte[]] $Int8ArrayParam,
        [Byte] $UInt8Param,
        [Byte[]] $UInt8ArrayParam,
        [Int16] $Int16Param,
        [Int16[]] $Int16ArrayParam,
        [UInt16] $UInt16Param,
        [UInt16[]] $UInt16ArrayParam,
        [Int32] $Int32Param,
        [Int32[]] $Int32ArrayParam,
        [UInt32] $UInt32Param,
        [UInt32[]] $UInt32ArrayParam,
        [Int64] $Int64Param,
        [Int64[]] $Int64ArrayParam,
        [UInt64] $UInt64Param,
        [UInt64[]] $UInt64ArrayParam,
        [Bool] $BooleanParam,
        [Bool[]] $BooleanArrayParam,
        [Char] $CharParam,
        [Char[]] $CharArrayParam,
        [Single] $SingleParam,
        [Single[]] $SingleArrayParam,
        [Double] $DoubleParam,
        [Double[]] $DoubleArrayParam,
        [DateTime] $DateTimeParam,
        [DateTime[]] $DateTimeArrayParam,
        [PSCredential] $PSCredentialParam,
        [CimInstance[]] $HashtableParam,
        [CimInstance] $CimInstanceParam,
        [CimInstance[]] $CimInstanceArrayParam,
        [CimInstance] $NestedCimInstanceParam,
        [CimInstance[]] $NestedCimInstanceArrayParam
    )

    $info = @{
        Version = "1.0.0"
        Ensure = @{
            Type = $Ensure.GetType().FullName
            Value = $Ensure
        }
        Path = @{
            Type = $Path.GetType().FullName
            Value = $Path
        }
        DefaultParam = @{
            Type = $DefaultParam.GetType().FullName
            Value = $DefaultParam
        }
    }

    foreach ($kvp in $PSCmdlet.MyInvocation.BoundParameters.GetEnumerator()) {
        $info."$($kvp.Key)" = @{
            Type = $kvp.Value.GetType().FullName
            Value = (ConvertTo-OutputValue -Value $kvp.Value)
        }
    }

    if (Test-Path -Path $Path) {
        Remove-Item -Path $Path -Force > $null
    }
    New-Item -Path $Path -ItemType File > $null
    Set-Content -Path $Path -Value (ConvertTo-Json -InputObject $info -Depth 10) > $null
    Write-Verbose -Message "set verbose"
    Write-Warning -Message "set warning"
}

Function Test-TargetResource
{
    [CmdletBinding()]
    [OutputType([Boolean])]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet("Present", "Absent")]
        [String] $Ensure = "Present",

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String] $Path,

        [String] $DefaultParam = "Default",
        [String] $StringParam,
        [String[]] $StringArrayParam,
        [SByte] $Int8Param,
        [SByte[]] $Int8ArrayParam,
        [Byte] $UInt8Param,
        [Byte[]] $UInt8ArrayParam,
        [Int16] $Int16Param,
        [Int16[]] $Int16ArrayParam,
        [UInt16] $UInt16Param,
        [UInt16[]] $UInt16ArrayParam,
        [Int32] $Int32Param,
        [Int32[]] $Int32ArrayParam,
        [UInt32] $UInt32Param,
        [UInt32[]] $UInt32ArrayParam,
        [Int64] $Int64Param,
        [Int64[]] $Int64ArrayParam,
        [UInt64] $UInt64Param,
        [UInt64[]] $UInt64ArrayParam,
        [Bool] $BooleanParam,
        [Bool[]] $BooleanArrayParam,
        [Char] $CharParam,
        [Char[]] $CharArrayParam,
        [Single] $SingleParam,
        [Single[]] $SingleArrayParam,
        [Double] $DoubleParam,
        [Double[]] $DoubleArrayParam,
        [DateTime] $DateTimeParam,
        [DateTime[]] $DateTimeArrayParam,
        [PSCredential] $PSCredentialParam,
        [CimInstance[]] $HashtableParam,
        [CimInstance] $CimInstanceParam,
        [CimInstance[]] $CimInstanceArrayParam,
        [CimInstance] $NestedCimInstanceParam,
        [CimInstance[]] $NestedCimInstanceArrayParam
    )
    Write-Verbose -Message "test verbose"
    Write-Warning -Message "test warning"
    $exists = Test-Path -LiteralPath $Path -PathType Leaf
    if ($Ensure -eq "Present") {
        $exists
    } else {
        -not $exists
    }
#Requires -Version 5.0 -Modules CimCmdlets

Function Get-TargetResource
{
    [CmdletBinding()]
    [OutputType([Hashtable])]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [String]$KeyParam
    )
    return @{Value = [bool]$global:DSCMachineStatus}
}

Function Set-TargetResource
{
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [String]$KeyParam,
        [Bool]$Value = $true
    )
    $global:DSCMachineStatus = [int]$Value
}

Function Test-TargetResource
{
    [CmdletBinding()]
    [OutputType([Boolean])]
    param (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [String]$KeyParam,
        [Bool]$Value = $true
    )
    $false
}

Export-ModuleMember -Function *-TargetResource
@{
    ModuleVersion = '1.0.0'
    GUID = '80c895c4-de3f-4d6d-8fa4-c504c96b6f22'
    Author = 'Ansible'
    CompanyName = 'Ansible'
    Copyright = '(c) 2019'
    Description = 'Test DSC Resource for Ansible integration tests'
    PowerShellVersion = '5.0'
    CLRVersion = '4.0'
    FunctionsToExport = '*'
#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -CSharpUtil Ansible.Process

$module = [Ansible.Basic.AnsibleModule]::Create($args, @{})

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actual_value = $Actual[$i]
            $expected_value = $Expected[$i]
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text
        $module.FailJson("AssertionError: actual != expected")
    }
}

$tests = @{
    "ParseCommandLine empty string" = {
        $expected = @((Get-Process -Id $pid).Path)
        $actual = [Ansible.Process.ProcessUtil]::ParseCommandLine("")
        Assert-Equals -Actual $actual -Expected $expected
    }

    "ParseCommandLine single argument" = {
        $expected = @("powershell.exe")
        $actual = [Ansible.Process.ProcessUtil]::ParseCommandLine("powershell.exe")
        Assert-Equals -Actual $actual -Expected $expected
    }

    "ParseCommandLine multiple arguments" = {
        $expected = @("powershell.exe", "-File", "C:\temp\script.ps1")
        $actual = [Ansible.Process.ProcessUtil]::ParseCommandLine("powershell.exe -File C:\temp\script.ps1")
        Assert-Equals -Actual $actual -Expected $expected
    }

    "ParseCommandLine comples arguments" = {
        $expected = @('abc', 'd', 'ef gh', 'i\j', 'k"l', 'm\n op', 'ADDLOCAL=qr, s', 'tuv\', 'w''x', 'yz')
        $actual = [Ansible.Process.ProcessUtil]::ParseCommandLine('abc d "ef gh" i\j k\"l m\\"n op" ADDLOCAL="qr, s" tuv\ w''x yz')
        Assert-Equals -Actual $actual -Expected $expected
    }

    "SearchPath normal" = {
        $expected = "$($env:SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe"
        $actual = [Ansible.Process.ProcessUtil]::SearchPath("powershell.exe")
        $actual | Assert-Equals -Expected $expected
    }

    "SearchPath missing" = {
        $failed = $false
        try {
            [Ansible.Process.ProcessUtil]::SearchPath("fake.exe")
        } catch {
            $failed = $true
            $_.Exception.InnerException.GetType().FullName | Assert-Equals -Expected "System.IO.FileNotFoundException"
            $expected = 'Exception calling "SearchPath" with "1" argument(s): "Could not find file ''fake.exe''."'
            $_.Exception.Message | Assert-Equals -Expected $expected
        }
        $failed | Assert-Equals -Expected $true
    }

    "CreateProcess basic" = {
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess("whoami.exe")
        $actual.GetType().FullName | Assert-Equals -Expected "Ansible.Process.Result"
        $actual.StandardOut | Assert-Equals -Expected "$(&whoami.exe)`r`n"
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess stderr" = {
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess("powershell.exe [System.Console]::Error.WriteLine('hi')")
        $actual.StandardOut | Assert-Equals -Expected ""
        $actual.StandardError | Assert-Equals -Expected "hi`r`n"
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess exit code" = {
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess("powershell.exe exit 10")
        $actual.StandardOut | Assert-Equals -Expected ""
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 10
    }

    "CreateProcess bad executable" = {
        $failed = $false
        try {
            [Ansible.Process.ProcessUtil]::CreateProcess("fake.exe")
        } catch {
            $failed = $true
            $_.Exception.InnerException.GetType().FullName | Assert-Equals -Expected "Ansible.Process.Win32Exception"
            $expected = 'Exception calling "CreateProcess" with "1" argument(s): "CreateProcessW() failed '
            $expected += '(The system cannot find the file specified, Win32ErrorCode 2)"'
            $_.Exception.Message | Assert-Equals -Expected $expected
        }
        $failed | Assert-Equals -Expected $true
    }

    "CreateProcess with unicode" = {
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess("cmd.exe /c echo  caf")
        $actual.StandardOut | Assert-Equals -Expected " caf`r`n"
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, "cmd.exe /c echo  caf", $null, $null)
        $actual.StandardOut | Assert-Equals -Expected " caf`r`n"
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess without working dir" = {
        $expected = $pwd.Path + "`r`n"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'powershell.exe $pwd.Path', $null, $null)
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with working dir" = {
        $expected = "C:\Windows`r`n"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'powershell.exe $pwd.Path', "C:\Windows", $null)
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess without environment" = {
        $expected = "$($env:USERNAME)`r`n"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'powershell.exe $env:TEST; $env:USERNAME', $null, $null)
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with environment" = {
        $env_vars = @{
            TEST = "tesTing"
            TEST2 = "Testing 2"
        }
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'cmd.exe /c set', $null, $env_vars)
        ("TEST=tesTing" -cin $actual.StandardOut.Split("`r`n")) | Assert-Equals -Expected $true
        ("TEST2=Testing 2" -cin $actual.StandardOut.Split("`r`n")) | Assert-Equals -Expected $true
        ("USERNAME=$($env:USERNAME)" -cnotin $actual.StandardOut.Split("`r`n")) | Assert-Equals -Expected $true
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with string stdin" = {
        $expected = "input value`r`n`r`n"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'powershell.exe [System.Console]::In.ReadToEnd()',
            $null, $null, "input value")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with string stdin and newline" = {
        $expected = "input value`r`n`r`n"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'powershell.exe [System.Console]::In.ReadToEnd()',
            $null, $null, "input value`r`n")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with byte stdin" = {
        $expected = "input value`r`n"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'powershell.exe [System.Console]::In.ReadToEnd()',
            $null, $null, [System.Text.Encoding]::UTF8.GetBytes("input value"))
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with byte stdin and newline" = {
        $expected = "input value`r`n`r`n"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, 'powershell.exe [System.Console]::In.ReadToEnd()',
            $null, $null, [System.Text.Encoding]::UTF8.GetBytes("input value`r`n"))
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with lpApplicationName" = {
        $expected = "abc`r`n"
        $full_path = "$($env:SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe"
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($full_path, "Write-Output 'abc'", $null, $null)
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($full_path, "powershell.exe Write-Output 'abc'", $null, $null)
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcess with unicode and us-ascii encoding" = {
        $poop = [System.Char]::ConvertFromUtf32(0xE05A)  # Coverage breaks due to script parsing encoding issues with unicode chars, just use the code point instead
        $actual = [Ansible.Process.ProcessUtil]::CreateProcess($null, "cmd.exe /c echo $poop caf", $null, $null, '', 'us-ascii')
        $actual.StandardOut | Assert-Equals -Expected "??? caf??`r`n"
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }
}

foreach ($test_impl in $tests.GetEnumerator()) {
    $test = $test_impl.Key
    &$test_impl.Value
}

$module.Result.data = "success"
#!powershell

# Copyright: (c) 2019, Dag Wieers (@dagwieers) <dag@wieers.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#Requires -Module Ansible.ModuleUtils.Backup

$module = [Ansible.Basic.AnsibleModule]::Create($args, @{})

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actual_value = $Actual[$i]
            $expected_value = $Expected[$i]
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text
        $module.FailJson("AssertionError: actual != expected")
    }
}

$tmp_dir = $module.Tmpdir

$tests = @{
    "Test backup file with missing file" = {
        $actual = Backup-File -path (Join-Path -Path $tmp_dir -ChildPath "missing")
        $actual | Assert-Equals -Expected $null
    }

    "Test backup file in check mode" = {
        $orig_file = Join-Path -Path $tmp_dir -ChildPath "file-check.txt"
        Set-Content -LiteralPath $orig_file -Value "abc"
        $actual = Backup-File -path $orig_file -WhatIf

        (Test-Path -LiteralPath $actual) | Assert-Equals -Expected $false

        $parent_dir = Split-Path -LiteralPath $actual
        $backup_file = Split-Path -Path $actual -Leaf
        $parent_dir | Assert-Equals -Expected $tmp_dir
        ($backup_file -match "^file-check\.txt\.$pid\.\d{8}-\d{6}\.bak$") | Assert-Equals -Expected $true
    }

    "Test backup file" = {
        $content = "abc"
        $orig_file = Join-Path -Path $tmp_dir -ChildPath "file.txt"
        Set-Content -LiteralPath $orig_file -Value $content
        $actual = Backup-File -path $orig_file

        (Test-Path -LiteralPath $actual) | Assert-Equals -Expected $true

        $parent_dir = Split-Path -LiteralPath $actual
        $backup_file = Split-Path -Path $actual -Leaf
        $parent_dir | Assert-Equals -Expected $tmp_dir
        ($backup_file -match "^file\.txt\.$pid\.\d{8}-\d{6}\.bak$") | Assert-Equals -Expected $true
        (Get-Content -LiteralPath $actual -Raw) | Assert-Equals -Expected "$content`r`n"
    }
}

foreach ($test_impl in $tests.GetEnumerator()) {
    $test = $test_impl.Key
    &$test_impl.Value
}
#!powershell

# WANT_JSON
# POWERSHELL_COMMON

# basic script to get the lsit of users in a particular right
# this is quite complex to put as a simple script so this is
# just a simple module

$ErrorActionPreference = 'Stop'

$params = Parse-Args $args -supports_check_mode $false
$section = Get-AnsibleParam -obj $params -name "section" -type "str" -failifempty $true
$key = Get-AnsibleParam -obj $params -name "key" -type "str" -failifempty $true

$result = @{
    changed = $false
}

Function ConvertFrom-Ini($file_path) {
    $ini = @{}
    switch -Regex -File $file_path {
        "^\[(.+)\]" {
            $section = $matches[1]
            $ini.$section = @{}
        }
        "(.+?)\s*=(.*)" {
            $name = $matches[1].Trim()
            $value = $matches[2].Trim()
            if ($value -match "^\d+$") {
                $value = [int]$value
            } elseif ($value.StartsWith('"') -and $value.EndsWith('"')) {
                $value = $value.Substring(1, $value.Length - 2)
            }

            $ini.$section.$name = $value
        }
    }

    $ini
}

$secedit_ini_path = [IO.Path]::GetTempFileName()
&SecEdit.exe /export /cfg $secedit_ini_path /quiet
$secedit_ini = ConvertFrom-Ini -file_path $secedit_ini_path

if ($secedit_ini.ContainsKey($section)) {
    $result.value = $secedit_ini.$section.$key
} else {
    $result.value = $null
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic

$spec = @{
    options = @{
        data = @{ type = "str"; default = "pong" }
    }
    supports_check_mode = $true
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)
$data = $module.Params.data

if ($data -eq "crash") {
    throw "boom"
}

$module.Result.ping = $data
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -Powershell ansible_collections.testns.testcoll.plugins.module_utils.MyPSMU
#AnsibleRequires -PowerShell ansible_collections.testns.testcoll.plugins.module_utils.subpkg.subps

$spec = @{
    options = @{
        data = @{ type = "str"; default = "called from $(Invoke-FromUserPSMU)" }
    }
    supports_check_mode = $true
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)
$data = $module.Params.data

if ($data -eq "crash") {
    throw "boom"
}
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -CSharpUtil ansible_collections.testns.testcoll.plugins.module_utils.MyCSMU
#AnsibleRequires -CSharpUtil ansible_collections.testns.testcoll.plugins.module_utils.subpkg.subcs

$spec = @{
    options = @{
        data = @{ type = "str"; default = "called from $([ansible_collections.testns.testcoll.plugins.module_utils.MyCSMU.CustomThing]::HelloWorld())" }
    }
    supports_check_mode = $true
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)
$data = $module.Params.data

if ($data -eq "crash") {
    throw "boom"
}

$module.Result.ping = $data
$module.Result.source = "user"
$module.Result.subpkg = [ansible_collections.testns.testcoll.plugins.module_utils.subpkg.subcs.NestedUtil]::HelloWorld()
$module.Result.type_accelerator = "called from $([MyCSMU]::HelloWorld())"
#!powershell

$res = @{
  changed = $false
  source = "user"
Function Invoke-SubUserPSMU {
    <#
    .SYNOPSIS
    Test function
    #>
Function Invoke-FromUserPSMU {
    <#
    .SYNOPSIS
    Test function
    #>
# End of the setup code and start of the module code
#!powershell

#AnsibleRequires -CSharpUtil Ansible.AccessToken
#AnsibleRequires -CSharpUtil Ansible.Basic

$spec = @{
    options = @{
        test_username = @{ type = "str"; required = $true }
        test_password = @{ type = "str"; required = $true; no_log = $true }
    }
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

$test_username = $module.Params.test_username
$test_password = $module.Params.test_password

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actual_value = $Actual[$i]
            $expected_value = $Expected[$i]
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text

        $module.FailJson("AssertionError: actual != expected")
    }
}

$current_user = [System.Security.Principal.WindowsIdentity]::GetCurrent().User

$tests = [Ordered]@{
    "Open process token" = {
        $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess()

        $h_token = [Ansible.AccessToken.TokenUtil]::OpenProcessToken($h_process, "Query")
        try {
            $h_token.IsClosed | Assert-Equals -Expected $false
            $h_token.IsInvalid | Assert-Equals -Expected $false

            $actual_user = [Ansible.AccessToken.TokenUtil]::GetTokenUser($h_token)
            $actual_user | Assert-Equals -Expected $current_user
        } finally {
            $h_token.Dispose()
        }
        $h_token.IsClosed | Assert-Equals -Expected $true
    }

    "Open process token of another process" = {
        $proc_info = Start-Process -FilePath "powershell.exe" -ArgumentList "-Command Start-Sleep -Seconds 60" -WindowStyle Hidden -PassThru
        try {
            $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess($proc_info.Id, "QueryInformation", $false)
            try {
                $h_process.IsClosed | Assert-Equals -Expected $false
                $h_process.IsInvalid | Assert-Equals -Expected $false

                $h_token = [Ansible.AccessToken.TokenUtil]::OpenProcessToken($h_process, "Query")
                try {
                    $actual_user = [Ansible.AccessToken.TokenUtil]::GetTokenUser($h_token)
                    $actual_user | Assert-Equals -Expected $current_user
                } finally {
                    $h_token.Dispose()
                }
            } finally {
                $h_process.Dispose()
            }
            $h_process.IsClosed | Assert-Equals -Expected $true
        } finally {
            $proc_info | Stop-Process
        }
    }

    "Failed to open process token" = {
        $failed = $false
        try {
            $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess(4, "QueryInformation", $false)
            $h_process.Dispose()  # Incase this doesn't fail, make sure we still dispose of it
        } catch [Ansible.AccessToken.Win32Exception] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "Failed to open process 4 with access QueryInformation (Access is denied, Win32ErrorCode 5 - 0x00000005)"
        }
        $failed | Assert-Equals -Expected $true
    }

    "Duplicate access token primary" = {
        $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess()
        $h_token = [Ansible.AccessToken.TokenUtil]::OpenProcessToken($h_process, "Duplicate")
        try {
            $dup_token = [Ansible.AccessToken.TokenUtil]::DuplicateToken($h_token, "Query", "Anonymous", "Primary")
            try {
                $dup_token.IsClosed | Assert-Equals -Expected $false
                $dup_token.IsInvalid | Assert-Equals -Expected $false

                $actual_user = [Ansible.AccessToken.TokenUtil]::GetTokenUser($dup_token)

                $actual_user | Assert-Equals -Expected $current_user
                $actual_stat = [Ansible.AccessToken.TokenUtil]::GetTokenStatistics($dup_token)

                $actual_stat.TokenType | Assert-Equals -Expected ([Ansible.AccessToken.TokenType]::Primary)
                $actual_stat.ImpersonationLevel | Assert-Equals -Expected ([Ansible.AccessToken.SecurityImpersonationLevel]::Anonymous)
            } finally {
                $dup_token.Dispose()
            }

            $dup_token.IsClosed | Assert-Equals -Expected $true
        } finally {
            $h_token.Dispose()
        }
    }

    "Duplicate access token impersonation" = {
        $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess()
        $h_token = [Ansible.AccessToken.TokenUtil]::OpenProcessToken($h_process, "Duplicate")
        try {
            "Anonymous", "Identification", "Impersonation", "Delegation" | ForEach-Object -Process {
                $dup_token = [Ansible.AccessToken.TokenUtil]::DuplicateToken($h_token, "Query", $_, "Impersonation")
                try {
                    $actual_user = [Ansible.AccessToken.TokenUtil]::GetTokenUser($dup_token)

                    $actual_user | Assert-Equals -Expected $current_user
                    $actual_stat = [Ansible.AccessToken.TokenUtil]::GetTokenStatistics($dup_token)

                    $actual_stat.TokenType | Assert-Equals -Expected ([Ansible.AccessToken.TokenType]::Impersonation)
                    $actual_stat.ImpersonationLevel | Assert-Equals -Expected ([Ansible.AccessToken.SecurityImpersonationLevel]"$_")
                } finally {
                    $dup_token.Dispose()
                }
            }
        } finally {
            $h_token.Dispose()
        }
    }

    "Impersonate SYSTEM token" = {
        $system_sid = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList @(
            [System.Security.Principal.WellKnownSidType]::LocalSystemSid,
            $null
        )
        $tested = $false
        foreach ($h_token in [Ansible.AccessToken.TokenUtil]::EnumerateUserTokens($system_sid, "Duplicate, Impersonate, Query")) {
            $actual_user = [Ansible.AccessToken.TokenUtil]::GetTokenUser($h_token)
            $actual_user | Assert-Equals -Expected $system_sid

            [Ansible.AccessToken.TokenUtil]::ImpersonateToken($h_token)
            try {
                $current_sid = [System.Security.Principal.WindowsIdentity]::GetCurrent().User
                $current_sid | Assert-Equals -Expected $system_sid
            } finally {
                [Ansible.AccessToken.TokenUtil]::RevertToSelf()
            }

            $current_sid = [System.Security.Principal.WindowsIdentity]::GetCurrent().User
            $current_sid | Assert-Equals -Expected $current_user

            # Will keep on looping for each SYSTEM token it can retrieve, we only want to test 1
            $tested = $true
            break
        }

        $tested | Assert-Equals -Expected $true
    }

    "Get token privileges" = {
        $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess()
        $h_token = [Ansible.AccessToken.TokenUtil]::OpenProcessToken($h_process, "Query")
        try {
            $priv_info = &whoami.exe /priv | Where-Object { $_.StartsWith("Se") }
            $actual_privs = [Ansible.AccessToken.Tokenutil]::GetTokenPrivileges($h_token)
            $actual_stat = [Ansible.AccessToken.TokenUtil]::GetTokenStatistics($h_token)

            $actual_privs.Count | Assert-Equals -Expected $priv_info.Count
            $actual_privs.Count | Assert-Equals -Expected $actual_stat.PrivilegeCount

            foreach ($info in $priv_info) {
                $info_split = $info.Split(" ", [System.StringSplitOptions]::RemoveEmptyEntries)
                $priv_name = $info_split[0]
                $priv_enabled = $info_split[-1] -eq "Enabled"
                $actual_priv = $actual_privs | Where-Object { $_.Name -eq $priv_name }

                $actual_priv -eq $null | Assert-Equals -Expected $false
                if ($priv_enabled) {
                    $actual_priv.Attributes.HasFlag([Ansible.AccessToken.PrivilegeAttributes]::Enabled) | Assert-Equals -Expected $true
                } else {
                    $actual_priv.Attributes.HasFlag([Ansible.AccessToken.PrivilegeAttributes]::Disabled) | Assert-Equals -Expected $true
                }
            }
        } finally {
            $h_token.Dispose()
        }
    }

    "Get token statistics" = {
        $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess()
        $h_token = [Ansible.AccessToken.TokenUtil]::OpenProcessToken($h_process, "Query")
        try {
            $actual_priv = [Ansible.AccessToken.Tokenutil]::GetTokenPrivileges($h_token)
            $actual_stat = [Ansible.AccessToken.TokenUtil]::GetTokenStatistics($h_token)

            $actual_stat.TokenId.GetType().FullName | Assert-Equals -Expected "Ansible.AccessToken.Luid"
            $actual_stat.AuthenticationId.GetType().FullName | Assert-Equals -Expected "Ansible.AccessToken.Luid"
            $actual_stat.ExpirationTime.GetType().FullName | Assert-Equals -Expected "System.Int64"

            $actual_stat.TokenType | Assert-Equals -Expected ([Ansible.AccessToken.TokenType]::Primary)

            $os_version = [Version](Get-Item -LiteralPath $env:SystemRoot\System32\kernel32.dll).VersionInfo.ProductVersion
            if ($os_version -lt [Version]"6.1") {
                # While the token is a primary token, Server 2008 reports the SecurityImpersonationLevel for a primary token as Impersonation
                $actual_stat.ImpersonationLevel | Assert-Equals -Expected ([Ansible.AccessToken.SecurityImpersonationLevel]::Impersonation)
            } else {
                $actual_stat.ImpersonationLevel | Assert-Equals -Expected ([Ansible.AccessToken.SecurityImpersonationLevel]::Anonymous)
            }
            $actual_stat.DynamicCharged.GetType().FullName | Assert-Equals -Expected "System.UInt32"
            $actual_stat.DynamicAvailable.GetType().FullName | Assert-Equals -Expected "System.UInt32"
            $actual_stat.GroupCount.GetType().FullName | Assert-Equals -Expected "System.UInt32"
            $actual_stat.PrivilegeCount | Assert-Equals -Expected $actual_priv.Count
            $actual_stat.ModifiedId.GetType().FullName | Assert-Equals -Expected "Ansible.AccessToken.Luid"
        } finally {
            $h_token.Dispose()
        }
    }

    "Get token linked token impersonation" = {
        $h_token = [Ansible.AccessToken.TokenUtil]::LogonUser($test_username, $null, $test_password, "Interactive", "Default")
        try {
            $actual_elevation_type = [Ansible.AccessToken.TokenUtil]::GetTokenElevationType($h_token)
            $actual_elevation_type | Assert-Equals -Expected ([Ansible.AccessToken.TokenElevationType]::Limited)

            $actual_linked = [Ansible.AccessToken.TokenUtil]::GetTokenLinkedToken($h_token)
            try {
                $actual_linked.IsClosed | Assert-Equals -Expected $false
                $actual_linked.IsInvalid | Assert-Equals -Expected $false

                $actual_elevation_type = [Ansible.AccessToken.TokenUtil]::GetTokenElevationType($actual_linked)
                $actual_elevation_type | Assert-Equals -Expected ([Ansible.AccessToken.TokenElevationType]::Full)

                $actual_stat = [Ansible.AccessToken.TokenUtil]::GetTokenStatistics($actual_linked)
                $actual_stat.TokenType | Assert-Equals -Expected ([Ansible.AccessToken.TokenType]::Impersonation)
            } finally {
                $actual_linked.Dispose()
            }
            $actual_linked.IsClosed | Assert-Equals -Expected $true
        } finally {
            $h_token.Dispose()
        }
    }

    "Get token linked token primary" = {
        # We need a token with the SeTcbPrivilege for this to work.
        $system_sid = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList @(
            [System.Security.Principal.WellKnownSidType]::LocalSystemSid,
            $null
        )
        $tested = $false
        foreach ($system_token in [Ansible.AccessToken.TokenUtil]::EnumerateUserTokens($system_sid, "Duplicate, Impersonate, Query")) {
            $privileges = [Ansible.AccessToken.TokenUtil]::GetTokenPrivileges($system_token)
            if ($null -eq ($privileges | Where-Object { $_.Name -eq "SeTcbPrivilege" })) {
                continue
            }

            $h_token = [Ansible.AccessToken.TokenUtil]::LogonUser($test_username, $null, $test_password, "Interactive", "Default")
            try {
                [Ansible.AccessToken.TokenUtil]::ImpersonateToken($system_token)
                try {
                    $actual_linked = [Ansible.AccessToken.TokenUtil]::GetTokenLinkedToken($h_token)
                    try {
                        $actual_linked.IsClosed | Assert-Equals -Expected $false
                        $actual_linked.IsInvalid | Assert-Equals -Expected $false

                        $actual_elevation_type = [Ansible.AccessToken.TokenUtil]::GetTokenElevationType($actual_linked)
                        $actual_elevation_type | Assert-Equals -Expected ([Ansible.AccessToken.TokenElevationType]::Full)

                        $actual_stat = [Ansible.AccessToken.TokenUtil]::GetTokenStatistics($actual_linked)
                        $actual_stat.TokenType | Assert-Equals -Expected ([Ansible.AccessToken.TokenType]::Primary)
                    } finally {
                        $actual_linked.Dispose()
                    }
                    $actual_linked.IsClosed | Assert-Equals -Expected $true
                } finally {
                    [Ansible.AccessToken.TokenUtil]::RevertToSelf()
                }
            } finally {
                $h_token.Dispose()
            }

            $tested = $true
            break
        }
        $tested | Assert-Equals -Expected $true
    }

    "Failed to get token information" = {
        $h_process = [Ansible.AccessToken.TokenUtil]::OpenProcess()
        $h_token = [Ansible.AccessToken.TokenUtil]::OpenProcessToken($h_process, 'Duplicate')  # Without Query the below will fail

        $failed = $false
        try {
            [Ansible.AccessToken.TokenUtil]::GetTokenUser($h_token)
        } catch [Ansible.AccessToken.Win32Exception] {
            $failed = $true
            $_.Exception.Message | Assert-Equals -Expected "GetTokenInformation(TokenUser) failed to get buffer length (Access is denied, Win32ErrorCode 5 - 0x00000005)"
        } finally {
            $h_token.Dispose()
        }
        $failed | Assert-Equals -Expected $true
    }

    "Logon with valid credentials" = {
        $expected_user = New-Object -TypeName System.Security.Principal.NTAccount -ArgumentList $test_username
        $expected_sid = $expected_user.Translate([System.Security.Principal.SecurityIdentifier])

        $h_token = [Ansible.AccessToken.TokenUtil]::LogonUser($test_username, $null, $test_password, "Network", "Default")
        try {
            $h_token.IsClosed | Assert-Equals -Expected $false
            $h_token.IsInvalid | Assert-Equals -Expected $false

            $actual_user = [Ansible.AccessToken.TokenUtil]::GetTokenUser($h_token)
            $actual_user | Assert-Equals -Expected $expected_sid
        } finally {
            $h_token.Dispose()
        }
        $h_token.IsClosed | Assert-Equals -Expected $true
    }

    "Logon with invalid credentials" = {
        $failed = $false
        try {
            [Ansible.AccessToken.TokenUtil]::LogonUser("fake-user", $null, "fake-pass", "Network", "Default")
        } catch [Ansible.AccessToken.Win32Exception] {
            $failed = $true
            $_.Exception.Message.Contains("Failed to logon fake-user") | Assert-Equals -Expected $true
            $_.Exception.Message.Contains("Win32ErrorCode 1326 - 0x0000052E)") | Assert-Equals -Expected $true
        }
        $failed | Assert-Equals -Expected $true
    }

    "Logon with invalid credential with domain account" = {
        $failed = $false
        try {
            [Ansible.AccessToken.TokenUtil]::LogonUser("fake-user", "fake-domain", "fake-pass", "Network", "Default")
        } catch [Ansible.AccessToken.Win32Exception] {
            $failed = $true
            $_.Exception.Message.Contains("Failed to logon fake-domain\fake-user") | Assert-Equals -Expected $true
            $_.Exception.Message.Contains("Win32ErrorCode 1326 - 0x0000052E)") | Assert-Equals -Expected $true
        }
        $failed | Assert-Equals -Expected $true
    }
}

foreach ($test_impl in $tests.GetEnumerator()) {
    $test = $test_impl.Key
    &$test_impl.Value
}
#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -CSharpUtil Ansible.Become

$module = [Ansible.Basic.AnsibleModule]::Create($args, @{})

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actual_value = $Actual[$i]
            $expected_value = $Expected[$i]
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text
        $module.FailJson("AssertionError: actual != expected")
    }
}

# Would be great to move win_whomai out into it's own module util and share the
# code here, for now just rely on a cut down version
$test_whoami = {
    Add-Type -TypeDefinition @'
using Microsoft.Win32.SafeHandles;
using System;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;

namespace Ansible
{
    internal class NativeHelpers
    {
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct LSA_UNICODE_STRING
        {
            public UInt16 Length;
            public UInt16 MaximumLength;
            public IntPtr Buffer;

            public override string ToString()
            {
                return Marshal.PtrToStringUni(Buffer, Length / sizeof(char));
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct LUID
        {
            public UInt32 LowPart;
            public Int32 HighPart;

            public static explicit operator UInt64(LUID l)
            {
                return (UInt64)((UInt64)l.HighPart << 32) | (UInt64)l.LowPart;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_LOGON_SESSION_DATA
        {
            public UInt32 Size;
            public LUID LogonId;
            public LSA_UNICODE_STRING UserName;
            public LSA_UNICODE_STRING LogonDomain;
            public LSA_UNICODE_STRING AuthenticationPackage;
            public SECURITY_LOGON_TYPE LogonType;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SID_AND_ATTRIBUTES
        {
            public IntPtr Sid;
            public int Attributes;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct TOKEN_MANDATORY_LABEL
        {
            public SID_AND_ATTRIBUTES Label;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct TOKEN_SOURCE
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)] public char[] SourceName;
            public LUID SourceIdentifier;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct TOKEN_STATISTICS
        {
            public LUID TokenId;
            public LUID AuthenticationId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct TOKEN_USER
        {
            public SID_AND_ATTRIBUTES User;
        }

        public enum SECURITY_LOGON_TYPE
        {
            System = 0, // Used only by the Sytem account
            Interactive = 2,
            Network,
            Batch,
            Service,
            Proxy,
            Unlock,
            NetworkCleartext,
            NewCredentials,
            RemoteInteractive,
            CachedInteractive,
            CachedRemoteInteractive,
            CachedUnlock
        }

        public enum TokenInformationClass
        {
            TokenUser = 1,
            TokenSource = 7,
            TokenStatistics = 10,
            TokenIntegrityLevel = 25,
        }
    }

    internal class NativeMethods
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool CloseHandle(
            IntPtr hObject);

        [DllImport("kernel32.dll")]
        public static extern SafeNativeHandle GetCurrentProcess();

        [DllImport("userenv.dll", SetLastError = true)]
        public static extern bool GetProfileType(
            out UInt32 dwFlags);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool GetTokenInformation(
            SafeNativeHandle TokenHandle,
            NativeHelpers.TokenInformationClass TokenInformationClass,
            SafeMemoryBuffer TokenInformation,
            UInt32 TokenInformationLength,
            out UInt32 ReturnLength);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LookupAccountSid(
            string lpSystemName,
            IntPtr Sid,
            StringBuilder lpName,
            ref UInt32 cchName,
            StringBuilder ReferencedDomainName,
            ref UInt32 cchReferencedDomainName,
            out UInt32 peUse);

        [DllImport("secur32.dll", SetLastError = true)]
        public static extern UInt32 LsaEnumerateLogonSessions(
            out UInt32 LogonSessionCount,
            out SafeLsaMemoryBuffer LogonSessionList);

        [DllImport("secur32.dll", SetLastError = true)]
        public static extern UInt32 LsaFreeReturnBuffer(
            IntPtr Buffer);

        [DllImport("secur32.dll", SetLastError = true)]
        public static extern UInt32 LsaGetLogonSessionData(
            IntPtr LogonId,
            out SafeLsaMemoryBuffer ppLogonSessionData);

        [DllImport("advapi32.dll")]
        public static extern UInt32 LsaNtStatusToWinError(
            UInt32 Status);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool OpenProcessToken(
            SafeNativeHandle ProcessHandle,
            TokenAccessLevels DesiredAccess,
            out SafeNativeHandle TokenHandle);
    }

    internal class SafeLsaMemoryBuffer : SafeHandleZeroOrMinusOneIsInvalid
    {
        public SafeLsaMemoryBuffer() : base(true) { }

        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            UInt32 res = NativeMethods.LsaFreeReturnBuffer(handle);
            return res == 0;
        }
    }

    internal class SafeMemoryBuffer : SafeHandleZeroOrMinusOneIsInvalid
    {
        public SafeMemoryBuffer() : base(true) { }
        public SafeMemoryBuffer(int cb) : base(true)
        {
            base.SetHandle(Marshal.AllocHGlobal(cb));
        }
        public SafeMemoryBuffer(IntPtr handle) : base(true)
        {
            base.SetHandle(handle);
        }

        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            Marshal.FreeHGlobal(handle);
            return true;
        }
    }

    internal class SafeNativeHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        public SafeNativeHandle() : base(true) { }
        public SafeNativeHandle(IntPtr handle) : base(true) { this.handle = handle; }

        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            return NativeMethods.CloseHandle(handle);
        }
    }

    public class Win32Exception : System.ComponentModel.Win32Exception
    {
        private string _msg;

        public Win32Exception(string message) : this(Marshal.GetLastWin32Error(), message) { }
        public Win32Exception(int errorCode, string message) : base(errorCode)
        {
            _msg = String.Format("{0} ({1}, Win32ErrorCode {2})", message, base.Message, errorCode);
        }

        public override string Message { get { return _msg; } }
        public static explicit operator Win32Exception(string message) { return new Win32Exception(message); }
    }

    public class Logon
    {
        public string AuthenticationPackage { get; internal set; }
        public string LogonType { get; internal set; }
        public string MandatoryLabelName { get; internal set; }
        public SecurityIdentifier MandatoryLabelSid { get; internal set; }
        public bool ProfileLoaded { get; internal set; }
        public string SourceName { get; internal set; }
        public string UserName { get; internal set; }
        public SecurityIdentifier UserSid { get; internal set; }

        public Logon()
        {
            using (SafeNativeHandle process = NativeMethods.GetCurrentProcess())
            {
                TokenAccessLevels dwAccess = TokenAccessLevels.Query | TokenAccessLevels.QuerySource;

                SafeNativeHandle hToken;
                NativeMethods.OpenProcessToken(process, dwAccess, out hToken);
                using (hToken)
                {
                    SetLogonSessionData(hToken);
                    SetTokenMandatoryLabel(hToken);
                    SetTokenSource(hToken);
                    SetTokenUser(hToken);
                }
            }
            SetProfileLoaded();
        }

        private void SetLogonSessionData(SafeNativeHandle hToken)
        {
            NativeHelpers.TokenInformationClass tokenClass = NativeHelpers.TokenInformationClass.TokenStatistics;
            UInt32 returnLength;
            NativeMethods.GetTokenInformation(hToken, tokenClass, new SafeMemoryBuffer(IntPtr.Zero), 0, out returnLength);

            UInt64 tokenLuidId;
            using (SafeMemoryBuffer infoPtr = new SafeMemoryBuffer((int)returnLength))
            {
                if (!NativeMethods.GetTokenInformation(hToken, tokenClass, infoPtr, returnLength, out returnLength))
                    throw new Win32Exception("GetTokenInformation(TokenStatistics) failed");

                NativeHelpers.TOKEN_STATISTICS stats = (NativeHelpers.TOKEN_STATISTICS)Marshal.PtrToStructure(
                    infoPtr.DangerousGetHandle(), typeof(NativeHelpers.TOKEN_STATISTICS));
                tokenLuidId = (UInt64)stats.AuthenticationId;
            }

            UInt32 sessionCount;
            SafeLsaMemoryBuffer sessionPtr;
            UInt32 res = NativeMethods.LsaEnumerateLogonSessions(out sessionCount, out sessionPtr);
            if (res != 0)
                throw new Win32Exception((int)NativeMethods.LsaNtStatusToWinError(res), "LsaEnumerateLogonSession() failed");
            using (sessionPtr)
            {
                IntPtr currentSession = sessionPtr.DangerousGetHandle();
                for (UInt32 i = 0; i < sessionCount; i++)
                {
                    SafeLsaMemoryBuffer sessionDataPtr;
                    res = NativeMethods.LsaGetLogonSessionData(currentSession, out sessionDataPtr);
                    if (res != 0)
                    {
                        currentSession = IntPtr.Add(currentSession, Marshal.SizeOf(typeof(NativeHelpers.LUID)));
                        continue;
                    }
                    using (sessionDataPtr)
                    {
                        NativeHelpers.SECURITY_LOGON_SESSION_DATA sessionData = (NativeHelpers.SECURITY_LOGON_SESSION_DATA)Marshal.PtrToStructure(
                            sessionDataPtr.DangerousGetHandle(), typeof(NativeHelpers.SECURITY_LOGON_SESSION_DATA));
                        UInt64 sessionId = (UInt64)sessionData.LogonId;
                        if (sessionId == tokenLuidId)
                        {
                            AuthenticationPackage = sessionData.AuthenticationPackage.ToString();
                            LogonType = sessionData.LogonType.ToString();
                            break;
                        }
                    }

                    currentSession = IntPtr.Add(currentSession, Marshal.SizeOf(typeof(NativeHelpers.LUID)));
                }
            }
        }

        private void SetTokenMandatoryLabel(SafeNativeHandle hToken)
        {
            NativeHelpers.TokenInformationClass tokenClass = NativeHelpers.TokenInformationClass.TokenIntegrityLevel;
            UInt32 returnLength;
            NativeMethods.GetTokenInformation(hToken, tokenClass, new SafeMemoryBuffer(IntPtr.Zero), 0, out returnLength);
            using (SafeMemoryBuffer infoPtr = new SafeMemoryBuffer((int)returnLength))
            {
                if (!NativeMethods.GetTokenInformation(hToken, tokenClass, infoPtr, returnLength, out returnLength))
                    throw new Win32Exception("GetTokenInformation(TokenIntegrityLevel) failed");
                NativeHelpers.TOKEN_MANDATORY_LABEL label = (NativeHelpers.TOKEN_MANDATORY_LABEL)Marshal.PtrToStructure(
                    infoPtr.DangerousGetHandle(), typeof(NativeHelpers.TOKEN_MANDATORY_LABEL));
                MandatoryLabelName = LookupSidName(label.Label.Sid);
                MandatoryLabelSid = new SecurityIdentifier(label.Label.Sid);
            }
        }

        private void SetTokenSource(SafeNativeHandle hToken)
        {
            NativeHelpers.TokenInformationClass tokenClass = NativeHelpers.TokenInformationClass.TokenSource;
            UInt32 returnLength;
            NativeMethods.GetTokenInformation(hToken, tokenClass, new SafeMemoryBuffer(IntPtr.Zero), 0, out returnLength);
            using (SafeMemoryBuffer infoPtr = new SafeMemoryBuffer((int)returnLength))
            {
                if (!NativeMethods.GetTokenInformation(hToken, tokenClass, infoPtr, returnLength, out returnLength))
                    throw new Win32Exception("GetTokenInformation(TokenSource) failed");
                NativeHelpers.TOKEN_SOURCE source = (NativeHelpers.TOKEN_SOURCE)Marshal.PtrToStructure(
                    infoPtr.DangerousGetHandle(), typeof(NativeHelpers.TOKEN_SOURCE));
                SourceName = new string(source.SourceName).Replace('\0', ' ').TrimEnd();
            }
        }

        private void SetTokenUser(SafeNativeHandle hToken)
        {
            NativeHelpers.TokenInformationClass tokenClass = NativeHelpers.TokenInformationClass.TokenUser;
            UInt32 returnLength;
            NativeMethods.GetTokenInformation(hToken, tokenClass, new SafeMemoryBuffer(IntPtr.Zero), 0, out returnLength);
            using (SafeMemoryBuffer infoPtr = new SafeMemoryBuffer((int)returnLength))
            {
                if (!NativeMethods.GetTokenInformation(hToken, tokenClass, infoPtr, returnLength, out returnLength))
                    throw new Win32Exception("GetTokenInformation(TokenSource) failed");
                NativeHelpers.TOKEN_USER user = (NativeHelpers.TOKEN_USER)Marshal.PtrToStructure(
                    infoPtr.DangerousGetHandle(), typeof(NativeHelpers.TOKEN_USER));
                UserName = LookupSidName(user.User.Sid);
                UserSid = new SecurityIdentifier(user.User.Sid);
            }
        }

        private void SetProfileLoaded()
        {
            UInt32 flags;
            ProfileLoaded = NativeMethods.GetProfileType(out flags);
        }

        private static string LookupSidName(IntPtr pSid)
        {
            StringBuilder name = new StringBuilder(0);
            StringBuilder domain = new StringBuilder(0);
            UInt32 nameLength = 0;
            UInt32 domainLength = 0;
            UInt32 peUse;
            NativeMethods.LookupAccountSid(null, pSid, name, ref nameLength, domain, ref domainLength, out peUse);
            name.EnsureCapacity((int)nameLength);
            domain.EnsureCapacity((int)domainLength);

            if (!NativeMethods.LookupAccountSid(null, pSid, name, ref nameLength, domain, ref domainLength, out peUse))
                throw new Win32Exception("LookupAccountSid() failed");

            return String.Format("{0}\\{1}", domain.ToString(), name.ToString());
        }
    }
}
'@
    $logon = New-Object -TypeName Ansible.Logon
    ConvertTo-Json -InputObject $logon
}.ToString()

$current_user_raw = [Ansible.Process.ProcessUtil]::CreateProcess($null, "powershell.exe -NoProfile -", $null, $null, $test_whoami + "`r`n")
$current_user = ConvertFrom-Json -InputObject $current_user_raw.StandardOut

$adsi = [ADSI]"WinNT://$env:COMPUTERNAME"

$standard_user = "become_standard"
$admin_user = "become_admin"
$become_pass = "password123!$([System.IO.Path]::GetRandomFileName())"
$medium_integrity_sid = "S-1-16-8192"
$high_integrity_sid = "S-1-16-12288"
$system_integrity_sid = "S-1-16-16384"

$tests = @{
    "Runas standard user" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass,
            "powershell.exe -NoProfile -ExecutionPolicy ByPass -File $tmp_script")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Interactive"
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
    }

    "Runas admin user" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass,
            "powershell.exe -NoProfile -ExecutionPolicy ByPass -File $tmp_script")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Interactive"
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
    }

    "Runas SYSTEM" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("SYSTEM", $null,
            "powershell.exe -NoProfile -ExecutionPolicy ByPass -File $tmp_script")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "System"
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.UserSid.Value | Assert-Equals -Expected "S-1-5-18"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $system_integrity_sid

        $with_domain = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("NT AUTHORITY\System", $null, "whoami.exe")
        $with_domain.StandardOut | Assert-Equals -Expected "nt authority\system`r`n"
    }

    "Runas LocalService" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("LocalService", $null,
            "powershell.exe -NoProfile -ExecutionPolicy ByPass -File $tmp_script")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Service"
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.UserSid.Value | Assert-Equals -Expected "S-1-5-19"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $system_integrity_sid

        $with_domain = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("NT AUTHORITY\LocalService", $null, "whoami.exe")
        $with_domain.StandardOut | Assert-Equals -Expected "nt authority\local service`r`n"
    }

    "Runas NetworkService" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("NetworkService", $null,
            "powershell.exe -NoProfile -ExecutionPolicy ByPass -File $tmp_script")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Service"
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.UserSid.Value | Assert-Equals -Expected "S-1-5-20"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $system_integrity_sid

        $with_domain = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("NT AUTHORITY\NetworkService", $null, "whoami.exe")
        $with_domain.StandardOut | Assert-Equals -Expected "nt authority\network service`r`n"
    }

    "Runas without working dir set" = {
        $expected = "$env:SystemRoot\system32`r`n"
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass, 0, "Interactive", $null,
            'powershell.exe $pwd.Path', $null, $null, "")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "Runas with working dir set" = {
        $expected = "$env:SystemRoot`r`n"
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass, 0, "Interactive", $null,
            'powershell.exe $pwd.Path', $env:SystemRoot, $null, "")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "Runas without environment set" = {
        $expected = "Windows_NT`r`n"
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass, 0, "Interactive", $null,
            'powershell.exe $env:TEST; $env:OS', $null, $null, "")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "Runas with environment set" = {
        $env_vars = @{
            TEST = "tesTing"
            TEST2 = "Testing 2"
        }
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, 0, "Interactive", $null,
            'cmd.exe /c set', $null, $env_vars, "")
        ("TEST=tesTing" -cin $actual.StandardOut.Split("`r`n")) | Assert-Equals -Expected $true
        ("TEST2=Testing 2" -cin $actual.StandardOut.Split("`r`n")) | Assert-Equals -Expected $true
        ("OS=Windows_NT" -cnotin $actual.StandardOut.Split("`r`n")) | Assert-Equals -Expected $true
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "Runas with string stdin" = {
        $expected = "input value`r`n`r`n"
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, 0, "Interactive", $null,
            'powershell.exe [System.Console]::In.ReadToEnd()', $null, $null, "input value")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "Runas with string stdin and newline" = {
        $expected = "input value`r`n`r`n"
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, 0, "Interactive", $null,
            'powershell.exe [System.Console]::In.ReadToEnd()', $null, $null, "input value`r`n")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "Runas with byte stdin" = {
        $expected = "input value`r`n"
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, 0, "Interactive", $null,
            'powershell.exe [System.Console]::In.ReadToEnd()', $null, $null, [System.Text.Encoding]::UTF8.GetBytes("input value"))
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "Missing executable" = {
        $failed = $false
        try {
            [Ansible.Become.BecomeUtil]::CreateProcessAsUser("SYSTEM", $null, "fake.exe")
        } catch {
            $failed = $true
            $_.Exception.InnerException.GetType().FullName | Assert-Equals -Expected "Ansible.Process.Win32Exception"
            $expected = 'Exception calling "CreateProcessAsUser" with "3" argument(s): "CreateProcessWithTokenW() failed '
            $expected += '(The system cannot find the file specified, Win32ErrorCode 2)"'
            $_.Exception.Message | Assert-Equals -Expected $expected
        }
        $failed | Assert-Equals -Expected $true
    }

    "CreateProcessAsUser with lpApplicationName" = {
        $expected = "abc`r`n"
        $full_path = "$($env:SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe"
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("SYSTEM", $null, 0, "Interactive", $full_path,
            "Write-Output 'abc'", $null, $null, "")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("SYSTEM", $null, 0, "Interactive", $full_path,
            "powershell.exe Write-Output 'abc'", $null, $null, "")
        $actual.StandardOut | Assert-Equals -Expected $expected
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcessAsUser with stderr" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("SYSTEM", $null, 0, "Interactive", $null,
            "powershell.exe [System.Console]::Error.WriteLine('hi')", $null, $null, "")
        $actual.StandardOut | Assert-Equals -Expected ""
        $actual.StandardError | Assert-Equals -Expected "hi`r`n"
        $actual.ExitCode | Assert-Equals -Expected 0
    }

    "CreateProcessAsUser with exit code" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("SYSTEM", $null, 0, "Interactive", $null,
            "powershell.exe exit 10", $null, $null, "")
        $actual.StandardOut | Assert-Equals -Expected ""
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 10
    }

    "Local account with computer name" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("$env:COMPUTERNAME\$standard_user", $become_pass,
            "powershell.exe -NoProfile -ExecutionPolicy ByPass -File $tmp_script")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Interactive"
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
    }

    "Local account with computer as period" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser(".\$standard_user", $become_pass,
            "powershell.exe -NoProfile -ExecutionPolicy ByPass -File $tmp_script")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Interactive"
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
    }

    "Local account with invalid password" = {
        $failed = $false
        try {
            [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, "incorrect", "powershell.exe Write-Output abc")
        } catch {
            $failed = $true
            $_.Exception.InnerException.GetType().FullName | Assert-Equals -Expected "Ansible.AccessToken.Win32Exception"
            # Server 2008 has a slightly different error msg, just assert we get the error 1326
            ($_.Exception.Message.Contains("Win32ErrorCode 1326")) | Assert-Equals -Expected $true
        }
        $failed | Assert-Equals -Expected $true
    }

    "Invalid account" = {
        $failed = $false
        try {
            [Ansible.Become.BecomeUtil]::CreateProcessAsUser("incorrect", "incorrect", "powershell.exe Write-Output abc")
        } catch {
            $failed = $true
            $_.Exception.InnerException.GetType().FullName | Assert-Equals -Expected "System.Security.Principal.IdentityNotMappedException"
            $expected = 'Exception calling "CreateProcessAsUser" with "3" argument(s): "Some or all '
            $expected += 'identity references could not be translated."'
            $_.Exception.Message | Assert-Equals -Expected $expected
        }
        $failed | Assert-Equals -Expected $true
    }

    "Interactive logon with standard" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass, "WithProfile",
            "Interactive", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Interactive"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
    }

    "Batch logon with standard" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass, "WithProfile",
            "Batch", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Batch"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
    }

    "Network logon with standard" = {
        # Server 2008 will not work with become to Network or Network Credentials
        if ([System.Environment]::OSVersion.Version -lt [Version]"6.1") {
            continue
        }
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass, "WithProfile",
            "Network", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Network"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
    }

    "Network with cleartext logon with standard" = {
        # Server 2008 will not work with become to Network or Network Cleartext
        if ([System.Environment]::OSVersion.Version -lt [Version]"6.1") {
            continue
        }
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, $become_pass, "WithProfile",
            "NetworkCleartext", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "NetworkCleartext"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
    }

    "Logon without password with standard" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, [NullString]::Value, "WithProfile",
            "Interactive", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        # Too unstable, there might be another process still lingering which causes become to steal instead of using
        # S4U. Just don't check the type and source to verify we can become without a password
        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        # $stdout.LogonType | Assert-Equals -Expected "Batch"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        # $stdout.SourceName | Assert-Equals -Expected "ansible"
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
    }

    "Logon without password and network type with standard" = {
        # Server 2008 will not work with become to Network or Network Cleartext
        if ([System.Environment]::OSVersion.Version -lt [Version]"6.1") {
            continue
        }
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($standard_user, [NullString]::Value, "WithProfile",
            "Network", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        # Too unstable, there might be another process still lingering which causes become to steal instead of using
        # S4U. Just don't check the type and source to verify we can become without a password
        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        # $stdout.LogonType | Assert-Equals -Expected "Network"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $medium_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        # $stdout.SourceName | Assert-Equals -Expected "ansible"
        $stdout.UserSid.Value | Assert-Equals -Expected $standard_user_sid
    }

    "Interactive logon with admin" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, "WithProfile",
            "Interactive", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Interactive"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
    }

    "Batch logon with admin" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, "WithProfile",
            "Batch", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Batch"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
    }

    "Network logon with admin" = {
        # Server 2008 will not work with become to Network or Network Credentials
        if ([System.Environment]::OSVersion.Version -lt [Version]"6.1") {
            continue
        }
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, "WithProfile",
            "Network", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Network"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
    }

    "Network with cleartext logon with admin" = {
        # Server 2008 will not work with become to Network or Network Credentials
        if ([System.Environment]::OSVersion.Version -lt [Version]"6.1") {
            continue
        }
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, "WithProfile",
            "NetworkCleartext", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "NetworkCleartext"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
    }

    "Fail to logon with null or empty password" = {
        $failed = $false
        try {
            # Having $null or an empty string means we are trying to become a user with a blank password and not
            # become without setting the password. This is confusing as $null gets converted to "" and we need to
            # use [NullString]::Value instead if we want that behaviour. This just tests to see that an empty
            # string won't go the S4U route.
            [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $null, "WithProfile",
                    "Interactive", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        } catch {
            $failed = $true
            $_.Exception.InnerException.GetType().FullName | Assert-Equals -Expected "Ansible.AccessToken.Win32Exception"
            # Server 2008 has a slightly different error msg, just assert we get the error 1326
            ($_.Exception.Message.Contains("Win32ErrorCode 1326")) | Assert-Equals -Expected $true
        }
        $failed | Assert-Equals -Expected $true
    }

    "Logon without password with admin" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, [NullString]::Value, "WithProfile",
            "Interactive", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        # Too unstable, there might be another process still lingering which causes become to steal instead of using
        # S4U. Just don't check the type and source to verify we can become without a password
        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        # $stdout.LogonType | Assert-Equals -Expected "Batch"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        # $stdout.SourceName | Assert-Equals -Expected "ansible"
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
    }

    "Logon without password and network type with admin" = {
        # become network doesn't work on Server 2008
        if ([System.Environment]::OSVersion.Version -lt [Version]"6.1") {
            continue
        }
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, [NullString]::Value, "WithProfile",
            "Network", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        # Too unstable, there might be another process still lingering which causes become to steal instead of using
        # S4U. Just don't check the type and source to verify we can become without a password
        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        # $stdout.LogonType | Assert-Equals -Expected "Network"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $true
        # $stdout.SourceName | Assert-Equals -Expected "ansible"
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
    }

    "Logon without profile with admin" = {
        # Server 2008 and 2008 R2 does not support running without the profile being set
        if ([System.Environment]::OSVersion.Version -lt [Version]"6.2") {
            continue
        }

        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser($admin_user, $become_pass, 0,
            "Interactive", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "Interactive"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $high_integrity_sid
        $stdout.ProfileLoaded | Assert-Equals -Expected $false
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $admin_user_sid
    }

    "Logon with network credentials and no profile" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("fakeuser", "fakepassword", "NetcredentialsOnly",
            "NewCredentials", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "NewCredentials"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $current_user.MandatoryLabelSid.Value

        # while we didn't set WithProfile, the new process is based on the current process
        $stdout.ProfileLoaded | Assert-Equals -Expected $current_user.ProfileLoaded
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $current_user.UserSid.Value
    }

    "Logon with network credentials and with profile" = {
        $actual = [Ansible.Become.BecomeUtil]::CreateProcessAsUser("fakeuser", "fakepassword", "NetcredentialsOnly, WithProfile",
            "NewCredentials", $null, "powershell.exe -NoProfile -", $tmp_dir, $null, $test_whoami + "`r`n")
        $actual.StandardError | Assert-Equals -Expected ""
        $actual.ExitCode | Assert-Equals -Expected 0

        $stdout = ConvertFrom-Json -InputObject $actual.StandardOut
        $stdout.LogonType | Assert-Equals -Expected "NewCredentials"
        $stdout.MandatoryLabelSid.Value | Assert-Equals -Expected $current_user.MandatoryLabelSid.Value
        $stdout.ProfileLoaded | Assert-Equals -Expected $current_user.ProfileLoaded
        $stdout.SourceName | Assert-Equals -Expected "Advapi"
        $stdout.UserSid.Value | Assert-Equals -Expected $current_user.UserSid.Value
    }
}

try {
    $tmp_dir = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath ([System.IO.Path]::GetRandomFileName())
    New-Item -Path $tmp_dir -ItemType Directory > $null
    $acl = Get-Acl -Path $tmp_dir
    $ace = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList @(
        New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList ([System.Security.Principal.WellKnownSidType]::WorldSid, $null)
        [System.Security.AccessControl.FileSystemRights]::FullControl,
        [System.Security.AccessControl.InheritanceFlags]"ContainerInherit, ObjectInherit",
        [System.Security.AccessControl.PropagationFlags]::None,
        [System.Security.AccessControl.AccessControlType]::Allow
    )
    $acl.AddAccessRule($ace)
    Set-Acl -Path $tmp_dir -AclObject $acl

    $tmp_script = Join-Path -Path $tmp_dir -ChildPath "whoami.ps1"
    Set-Content -LiteralPath $tmp_script -Value $test_whoami

    foreach ($user in $standard_user, $admin_user) {
        $user_obj = $adsi.Children | Where-Object { $_.SchemaClassName -eq "User" -and $_.Name -eq $user }
        if ($null -eq $user_obj) {
            $user_obj = $adsi.Create("User", $user)
            $user_obj.SetPassword($become_pass)
            $user_obj.SetInfo()
        } else {
            $user_obj.SetPassword($become_pass)
        }
        $user_obj.RefreshCache()

        if ($user -eq $standard_user) {
            $standard_user_sid = (New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList @($user_obj.ObjectSid.Value, 0)).Value
            $group = [System.Security.Principal.WellKnownSidType]::BuiltinUsersSid
        } else {
            $admin_user_sid = (New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList @($user_obj.ObjectSid.Value, 0)).Value
            $group = [System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid
        }
        $group = (New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList $group, $null).Value
        [string[]]$current_groups = $user_obj.Groups() | ForEach-Object {
            New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList @($_.GetType().InvokeMember("objectSID", "GetProperty", $null, $_, $null), 0)
        }
        if ($current_groups -notcontains $group) {
            $group_obj = $adsi.Children | Where-Object {
                if ($_.SchemaClassName -eq "Group") {
                    $group_sid = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList @($_.objectSID.Value, 0)
                    $group_sid -eq $group
                }
            }
            $group_obj.Add($user_obj.Path)
        }
    }
    foreach ($test_impl in $tests.GetEnumerator()) {
        $test = $test_impl.Key
        &$test_impl.Value
    }
} finally {
    Remove-Item -LiteralPath $tmp_dir -Force -Recurse
    foreach ($user in $standard_user, $admin_user) {
        $user_obj = $adsi.Children | Where-Object { $_.SchemaClassName -eq "User" -and $_.Name -eq $user }
        $adsi.Delete("User", $user_obj.Name.Value)
    }
}

#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.LinkUtil
#Requires -Module Ansible.ModuleUtils.CommandUtil

$ErrorActionPreference = 'Stop'

$path = Join-Path -Path ([System.IO.Path]::GetFullPath($env:TEMP)) -ChildPath '.ansible . [$!@^&test(;)]'

$folder_target = "$path\folder"
$file_target = "$path\file"
$symlink_file_path = "$path\file-symlink"
$symlink_folder_path = "$path\folder-symlink"
$hardlink_path = "$path\hardlink"
$hardlink_path_2 = "$path\hardlink2"
$junction_point_path = "$path\junction"

if (Test-Path -LiteralPath $path) {
    # Remove-Item struggles with broken symlinks, rely on trusty rmdir instead
    Run-Command -command "cmd.exe /c rmdir /S /Q `"$path`"" > $null
}
New-Item -Path $path -ItemType Directory | Out-Null
New-Item -Path $folder_target -ItemType Directory | Out-Null
New-Item -Path $file_target -ItemType File | Out-Null
Set-Content -LiteralPath $file_target -Value "a"

Function Assert-Equals($actual, $expected) {
    if ($actual -ne $expected) {
        Fail-Json @{} "actual != expected`nActual: $actual`nExpected: $expected"
    }
}

Function Assert-True($expression, $message) {
    if ($expression -ne $true) {
        Fail-Json @{} $message
    }
}

# need to manually set this
Load-LinkUtils

# path is not a link
$no_link_result = Get-Link -link_path $path
Assert-True -expression ($null -eq $no_link_result) -message "did not return null result for a non link"

# fail to create hard link pointed to a directory
try {
    New-Link -link_path "$path\folder-hard" -link_target $folder_target -link_type "hard"
    Assert-True -expression $false -message "creation of hard link should have failed if target was a directory"
} catch {
    Assert-Equals -actual $_.Exception.Message -expected "cannot set the target for a hard link to a directory"
}

# fail to create a junction point pointed to a file
try {
    New-Link -link_path "$path\junction-fail" -link_target $file_target -link_type "junction"
    Assert-True -expression $false -message "creation of junction point should have failed if target was a file"
} catch {
    Assert-Equals -actual $_.Exception.Message -expected "cannot set the target for a junction point to a file"
}

# fail to create a symbolic link with non-existent target
try {
    New-Link -link_path "$path\symlink-fail" -link_target "$path\fake-folder" -link_type "link"
    Assert-True -expression $false -message "creation of symbolic link should have failed if target did not exist"
} catch {
    Assert-Equals -actual $_.Exception.Message -expected "link_target '$path\fake-folder' does not exist, cannot create link"
}

# create recursive symlink
Run-Command -command "cmd.exe /c mklink /D symlink-rel folder" -working_directory $path | Out-Null
$rel_link_result = Get-Link -link_path "$path\symlink-rel"
Assert-Equals -actual $rel_link_result.Type -expected "SymbolicLink"
Assert-Equals -actual $rel_link_result.SubstituteName -expected "folder"
Assert-Equals -actual $rel_link_result.PrintName -expected "folder"
Assert-Equals -actual $rel_link_result.TargetPath -expected "folder"
Assert-Equals -actual $rel_link_result.AbsolutePath -expected $folder_target
Assert-Equals -actual $rel_link_result.HardTargets -expected $null

# create a symbolic file test
New-Link -link_path $symlink_file_path -link_target $file_target -link_type "link"
$file_link_result = Get-Link -link_path $symlink_file_path
Assert-Equals -actual $file_link_result.Type -expected "SymbolicLink"
Assert-Equals -actual $file_link_result.SubstituteName -expected "\??\$file_target"
Assert-Equals -actual $file_link_result.PrintName -expected $file_target
Assert-Equals -actual $file_link_result.TargetPath -expected $file_target
Assert-Equals -actual $file_link_result.AbsolutePath -expected $file_target
Assert-Equals -actual $file_link_result.HardTargets -expected $null

# create a symbolic link folder test
New-Link -link_path $symlink_folder_path -link_target $folder_target -link_type "link"
$folder_link_result = Get-Link -link_path $symlink_folder_path
Assert-Equals -actual $folder_link_result.Type -expected "SymbolicLink"
Assert-Equals -actual $folder_link_result.SubstituteName -expected "\??\$folder_target"
Assert-Equals -actual $folder_link_result.PrintName -expected $folder_target
Assert-Equals -actual $folder_link_result.TargetPath -expected $folder_target
Assert-Equals -actual $folder_link_result.AbsolutePath -expected $folder_target
Assert-Equals -actual $folder_link_result.HardTargets -expected $null

# create a junction point test
New-Link -link_path $junction_point_path -link_target $folder_target -link_type "junction"
$junction_point_result = Get-Link -link_path $junction_point_path
Assert-Equals -actual $junction_point_result.Type -expected "JunctionPoint"
Assert-Equals -actual $junction_point_result.SubstituteName -expected "\??\$folder_target"
Assert-Equals -actual $junction_point_result.PrintName -expected $folder_target
Assert-Equals -actual $junction_point_result.TargetPath -expected $folder_target
Assert-Equals -actual $junction_point_result.AbsolutePath -expected $folder_target
Assert-Equals -actual $junction_point_result.HardTargets -expected $null

# create a hard link test
New-Link -link_path $hardlink_path -link_target $file_target -link_type "hard"
$hardlink_result = Get-Link -link_path $hardlink_path
Assert-Equals -actual $hardlink_result.Type -expected "HardLink"
Assert-Equals -actual $hardlink_result.SubstituteName -expected $null
Assert-Equals -actual $hardlink_result.PrintName -expected $null
Assert-Equals -actual $hardlink_result.TargetPath -expected $null
Assert-Equals -actual $hardlink_result.AbsolutePath -expected $null
if ($hardlink_result.HardTargets[0] -ne $hardlink_path -and $hardlink_result.HardTargets[1] -ne $hardlink_path) {
    Assert-True -expression $false -message "file $hardlink_path is not a target of the hard link"
}
if ($hardlink_result.HardTargets[0] -ne $file_target -and $hardlink_result.HardTargets[1] -ne $file_target) {
    Assert-True -expression $false -message "file $file_target is not a target of the hard link"
}
Assert-equals -actual (Get-Content -LiteralPath $hardlink_path -Raw) -expected (Get-Content -LiteralPath $file_target -Raw)

# create a new hard link and verify targets go to 3
New-Link -link_path $hardlink_path_2 -link_target $file_target -link_type "hard"
$hardlink_result_2 = Get-Link -link_path $hardlink_path
Assert-True -expression ($hardlink_result_2.HardTargets.Count -eq 3) -message "did not return 3 targets for the hard link, actual $($hardlink_result_2.Targets.Count)"

# check if broken symbolic link still works
Remove-Item -LiteralPath $folder_target -Force | Out-Null
$broken_link_result = Get-Link -link_path $symlink_folder_path
Assert-Equals -actual $broken_link_result.Type -expected "SymbolicLink"
Assert-Equals -actual $broken_link_result.SubstituteName -expected "\??\$folder_target"
Assert-Equals -actual $broken_link_result.PrintName -expected $folder_target
Assert-Equals -actual $broken_link_result.TargetPath -expected $folder_target
Assert-Equals -actual $broken_link_result.AbsolutePath -expected $folder_target
Assert-Equals -actual $broken_link_result.HardTargets -expected $null

# check if broken junction point still works
$broken_junction_result = Get-Link -link_path $junction_point_path
Assert-Equals -actual $broken_junction_result.Type -expected "JunctionPoint"
Assert-Equals -actual $broken_junction_result.SubstituteName -expected "\??\$folder_target"
Assert-Equals -actual $broken_junction_result.PrintName -expected $folder_target
Assert-Equals -actual $broken_junction_result.TargetPath -expected $folder_target
Assert-Equals -actual $broken_junction_result.AbsolutePath -expected $folder_target
Assert-Equals -actual $broken_junction_result.HardTargets -expected $null

# delete file symbolic link
Remove-Link -link_path $symlink_file_path
Assert-True -expression (-not (Test-Path -LiteralPath $symlink_file_path)) -message "failed to delete file symbolic link"

# delete folder symbolic link
Remove-Link -link_path $symlink_folder_path
Assert-True -expression (-not (Test-Path -LiteralPath $symlink_folder_path)) -message "failed to delete folder symbolic link"

# delete junction point
Remove-Link -link_path $junction_point_path
Assert-True -expression (-not (Test-Path -LiteralPath $junction_point_path)) -message "failed to delete junction point"

# delete hard link
Remove-Link -link_path $hardlink_path
Assert-True -expression (-not (Test-Path -LiteralPath $hardlink_path)) -message "failed to delete hard link"
#!powershell

# Copyright (c) 2020 Ansible Project
# # GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -PowerShell ..module_utils.PSUtil

$spec = @{
    options = @{
      my_opt = @{ type = "str"; required = $true }
    }
}

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec, @(Get-PSUtilSpec))
# Copyright (c) 2020 Ansible Project
# # Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

Function Get-PSUtilSpec {
    <#
    .SYNOPSIS
    Shared util spec test
    #>
    @{
        options = @{
          option1 = @{ type = 'str'; required = $true; aliases = 'alias1' }
        }
    }
}

#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.SID

$params = Parse-Args $args
$sid_account = Get-AnsibleParam -obj $params -name "sid_account" -type "str" -failifempty $true

Function Assert-Equals($actual, $expected) {
    if ($actual -ne $expected) {
        Fail-Json @{} "actual != expected`nActual: $actual`nExpected: $expected"
    }
}

Function Get-ComputerSID() {
    # find any local user and trim off the final UID
    $luser_sid = (Get-CimInstance Win32_UserAccount -Filter "Domain='$env:COMPUTERNAME'")[0].SID

    return $luser_sid -replace '(S-1-5-21-\d+-\d+-\d+)-\d+', '$1'
}

$local_sid = Get-ComputerSID

# most machines should have a -500 Administrator account, but it may have been renamed. Look it up by SID
$default_admin = Get-CimInstance Win32_UserAccount -Filter "SID='$local_sid-500'"

# this group is called Administrators by default on English Windows, but could named something else. Look it up by SID
$default_admin_group = Get-CimInstance Win32_Group -Filter "SID='S-1-5-32-544'"

if (@($default_admin).Length -ne 1) {
    Fail-Json @{} "could not find a local admin account with SID ending in -500"
}

### Set this to the NETBIOS name of the domain you wish to test, not set for shippable ###
$test_domain = $null

$tests = @(
    # Local Users
    @{ sid = "S-1-1-0"; full_name = "Everyone"; names = @("Everyone") },
    @{ sid = "S-1-5-18"; full_name = "NT AUTHORITY\SYSTEM"; names = @("NT AUTHORITY\SYSTEM", "SYSTEM") },
    @{ sid = "S-1-5-20"; full_name = "NT AUTHORITY\NETWORK SERVICE"; names = @("NT AUTHORITY\NETWORK SERVICE", "NETWORK SERVICE") },
    @{ sid = "$($default_admin.SID)"; full_name = "$($default_admin.FullName)"; names = @("$env:COMPUTERNAME\$($default_admin.Name)", "$($default_admin.Name)", ".\$($default_admin.Name)") },

    # Local Groups
    @{ sid = "$($default_admin_group.SID)"; full_name = "BUILTIN\$($default_admin_group.Name)"; names = @("BUILTIN\$($default_admin_group.Name)", "$($default_admin_group.Name)", ".\$($default_admin_group.Name)") }
)

# Add domain tests if the domain name has been set
if ($null -ne $test_domain) {
    Import-Module ActiveDirectory
    $domain_info = Get-ADDomain -Identity $test_domain
    $domain_sid = $domain_info.DomainSID
    $domain_netbios = $domain_info.NetBIOSName
    $domain_upn = $domain_info.Forest

    $tests += @{
        sid = "$domain_sid-512"
        full_name = "$domain_netbios\Domain Admins"
        names = @("$domain_netbios\Domain Admins", "Domain Admins@$domain_upn", "Domain Admins")
    }

    $tests += @{
        sid = "$domain_sid-500"
        full_name = "$domain_netbios\Administrator"
        names = @("$domain_netbios\Administrator", "Administrator@$domain_upn")
    }
}

foreach ($test in $tests) {
    $actual_account_name = Convert-FromSID -sid $test.sid
    # renamed admins may have an empty FullName; skip comparison in that case
    if ($test.full_name) {
        Assert-Equals -actual $actual_account_name -expected $test.full_name
    }

    foreach ($test_name in $test.names) {
        $actual_sid = Convert-ToSID -account_name $test_name
        Assert-Equals -actual $actual_sid -expected $test.sid
    }
}

# the account to SID test is run outside of the normal run as we can't test it
# in the normal test suite
# Calling Convert-ToSID with a string like a SID should return that SID back
$actual = Convert-ToSID -account_name $sid_account
Assert-Equals -actual $actual -expected $sid_account

# Calling COnvert-ToSID with a string prefixed with .\ should return the SID
# for a user that is called that SID and not the SID passed in
$actual = Convert-ToSID -account_name ".\$sid_account"
#!powershell

#AnsibleRequires -CSharpUtil Ansible.Basic
#Ansiblerequires -CSharpUtil Ansible.Privilege

$module = [Ansible.Basic.AnsibleModule]::Create($args, @{})

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actual_value = $Actual[$i]
            $expected_value = $Expected[$i]
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text
        $module.FailJson("AssertionError: actual != expected")
    }
}

Function Assert-DictionaryEquals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )
    $actual_keys = $Actual.Keys
    $expected_keys = $Expected.Keys

    $actual_keys.Count | Assert-Equals -Expected $expected_keys.Count
    foreach ($actual_entry in $Actual.GetEnumerator()) {
        $actual_key = $actual_entry.Key
        ($actual_key -cin $expected_keys) | Assert-Equals -Expected $true
        $actual_value = $actual_entry.Value
        $expected_value = $Expected.$actual_key

        if ($actual_value -is [System.Collections.IDictionary]) {
            $actual_value | Assert-DictionaryEquals -Expected $expected_value
        } elseif ($actual_value -is [System.Collections.ArrayList]) {
            for ($i = 0; $i -lt $actual_value.Count; $i++) {
                $actual_entry = $actual_value[$i]
                $expected_entry = $expected_value[$i]
                if ($actual_entry -is [System.Collections.IDictionary]) {
                    $actual_entry | Assert-DictionaryEquals -Expected $expected_entry
                } else {
                    Assert-Equals -Actual $actual_entry -Expected $expected_entry
                }
            }
        } else {
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
    }
    foreach ($expected_key in $expected_keys) {
        ($expected_key -cin $actual_keys) | Assert-Equals -Expected $true
    }
}

Function Assert-Equals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )

    $matched = $false
    if ($Actual -is [System.Collections.ArrayList] -or $Actual -is [Array]) {
        $Actual.Count | Assert-Equals -Expected $Expected.Count
        for ($i = 0; $i -lt $Actual.Count; $i++) {
            $actual_value = $Actual[$i]
            $expected_value = $Expected[$i]
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
        $matched = $true
    } else {
        $matched = $Actual -ceq $Expected
    }

    if (-not $matched) {
        if ($Actual -is [PSObject]) {
            $Actual = $Actual.ToString()
        }

        $call_stack = (Get-PSCallStack)[1]
        $module.Result.test = $test
        $module.Result.actual = $Actual
        $module.Result.expected = $Expected
        $module.Result.line = $call_stack.ScriptLineNumber
        $module.Result.method = $call_stack.Position.Text
        $module.FailJson("AssertionError: actual != expected")
    }
}

Function Assert-DictionaryEquals {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][AllowNull()]$Actual,
        [Parameter(Mandatory=$true, Position=0)][AllowNull()]$Expected
    )
    $actual_keys = $Actual.Keys
    $expected_keys = $Expected.Keys

    $actual_keys.Count | Assert-Equals -Expected $expected_keys.Count
    foreach ($actual_entry in $Actual.GetEnumerator()) {
        $actual_key = $actual_entry.Key
        ($actual_key -cin $expected_keys) | Assert-Equals -Expected $true
        $actual_value = $actual_entry.Value
        $expected_value = $Expected.$actual_key

        if ($actual_value -is [System.Collections.IDictionary]) {
            $actual_value | Assert-DictionaryEquals -Expected $expected_value
        } elseif ($actual_value -is [System.Collections.ArrayList]) {
            for ($i = 0; $i -lt $actual_value.Count; $i++) {
                $actual_entry = $actual_value[$i]
                $expected_entry = $expected_value[$i]
                if ($actual_entry -is [System.Collections.IDictionary]) {
                    $actual_entry | Assert-DictionaryEquals -Expected $expected_entry
                } else {
                    Assert-Equals -Actual $actual_entry -Expected $expected_entry
                }
            }
        } else {
            Assert-Equals -Actual $actual_value -Expected $expected_value
        }
    }
    foreach ($expected_key in $expected_keys) {
        ($expected_key -cin $actual_keys) | Assert-Equals -Expected $true
    }
}

$process = [Ansible.Privilege.PrivilegeUtil]::GetCurrentProcess()

$tests = @{
    "Check valid privilege name" = {
        $actual = [Ansible.Privilege.PrivilegeUtil]::CheckPrivilegeName("SeTcbPrivilege")
        $actual | Assert-Equals -Expected $true
    }

    "Check invalid privilege name" = {
        $actual = [Ansible.Privilege.PrivilegeUtil]::CheckPrivilegeName("SeFake")
        $actual | Assert-Equals -Expected $false
    }

    "Disable a privilege" = {
        # Ensure the privilege is enabled at the start
        [Ansible.Privilege.PrivilegeUtil]::EnablePrivilege($process, "SeTimeZonePrivilege") > $null

        $actual = [Ansible.Privilege.PrivilegeUtil]::DisablePrivilege($process, "SeTimeZonePrivilege")
        $actual.GetType().Name | Assert-Equals -Expected 'Dictionary`2'
        $actual.Count | Assert-Equals -Expected 1
        $actual.SeTimeZonePrivilege | Assert-Equals -Expected $true

        # Disable again
        $actual = [Ansible.Privilege.PrivilegeUtil]::DisablePrivilege($process, "SeTimeZonePrivilege")
        $actual.GetType().Name | Assert-Equals -Expected 'Dictionary`2'
        $actual.Count | Assert-Equals -Expected 0
    }

    "Enable a privilege" = {
        # Ensure the privilege is disabled at the start
        [Ansible.Privilege.PrivilegeUtil]::DisablePrivilege($process, "SeTimeZonePrivilege") > $null

        $actual = [Ansible.Privilege.PrivilegeUtil]::EnablePrivilege($process, "SeTimeZonePrivilege")
        $actual.GetType().Name | Assert-Equals -Expected 'Dictionary`2'
        $actual.Count | Assert-Equals -Expected 1
        $actual.SeTimeZonePrivilege | Assert-Equals -Expected $false

        # Disable again
        $actual = [Ansible.Privilege.PrivilegeUtil]::EnablePrivilege($process, "SeTimeZonePrivilege")
        $actual.GetType().Name | Assert-Equals -Expected 'Dictionary`2'
        $actual.Count | Assert-Equals -Expected 0
    }

    "Disable and revert privileges" = {
        $current_state = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)

        $previous_state = [Ansible.Privilege.PrivilegeUtil]::DisableAllPrivileges($process)
        $previous_state.GetType().Name | Assert-Equals -Expected 'Dictionary`2'
        foreach ($previous_state_entry in $previous_state.GetEnumerator()) {
            $previous_state_entry.Value | Assert-Equals -Expected $true
        }

        # Disable again
        $previous_state2 = [Ansible.Privilege.PrivilegeUtil]::DisableAllPrivileges($process)
        $previous_state2.Count | Assert-Equals -Expected 0

        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        foreach ($actual_entry in $actual.GetEnumerator()) {
            $actual_entry.Value -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        }

        [Ansible.Privilege.PrivilegeUtil]::SetTokenPrivileges($process, $previous_state) > $null
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual | Assert-DictionaryEquals -Expected $current_state
    }

    "Remove a privilege" = {
        [Ansible.Privilege.PrivilegeUtil]::RemovePrivilege($process, "SeUndockPrivilege") > $null
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual.ContainsKey("SeUndockPrivilege") | Assert-Equals -Expected $false
    }

    "Test Enabler" = {
        # Disable privilege at the start
        $new_state = @{
             SeTimeZonePrivilege = $false
             SeShutdownPrivilege = $false
             SeIncreaseWorkingSetPrivilege = $false
        }
        [Ansible.Privilege.PrivilegeUtil]::SetTokenPrivileges($process, $new_state) > $null
        $check_state = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $check_state.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        $check_state.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        $check_state.SeIncreaseWorkingSetPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0

        # Check that strict = false won't validate privileges not held but activates the ones we want
        $enabler = New-Object -TypeName Ansible.Privilege.PrivilegeEnabler -ArgumentList $false, "SeTimeZonePrivilege", "SeShutdownPrivilege", "SeTcbPrivilege"
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)
        $actual.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)
        $actual.SeIncreaseWorkingSetPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        $actual.ContainsKey("SeTcbPrivilege") | Assert-Equals -Expected $false

        # Now verify a no-op enabler will not rever back to disabled
        $enabler2 = New-Object -TypeName Ansible.Privilege.PrivilegeEnabler -ArgumentList $false, "SeTimeZonePrivilege", "SeShutdownPrivilege", "SeTcbPrivilege"
        $enabler2.Dispose()
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)
        $actual.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)

        # Verify that when disposing the object the privileges are reverted
        $enabler.Dispose()
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        $actual.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
    }

    "Test Enabler strict" = {
        # Disable privilege at the start
        $new_state = @{
             SeTimeZonePrivilege = $false
             SeShutdownPrivilege = $false
             SeIncreaseWorkingSetPrivilege = $false
        }
        [Ansible.Privilege.PrivilegeUtil]::SetTokenPrivileges($process, $new_state) > $null
        $check_state = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $check_state.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        $check_state.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        $check_state.SeIncreaseWorkingSetPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0

        # Check that strict = false won't validate privileges not held but activates the ones we want
        $enabler = New-Object -TypeName Ansible.Privilege.PrivilegeEnabler -ArgumentList $true, "SeTimeZonePrivilege", "SeShutdownPrivilege"
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)
        $actual.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)
        $actual.SeIncreaseWorkingSetPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0

        # Now verify a no-op enabler will not rever back to disabled
        $enabler2 = New-Object -TypeName Ansible.Privilege.PrivilegeEnabler -ArgumentList $true, "SeTimeZonePrivilege", "SeShutdownPrivilege"
        $enabler2.Dispose()
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)
        $actual.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected ([Ansible.Privilege.PrivilegeAttributes]::Enabled)

        # Verify that when disposing the object the privileges are reverted
        $enabler.Dispose()
        $actual = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $actual.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
        $actual.SeShutdownPrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0
    }

    "Test Enabler invalid privilege" = {
        $failed = $false
        try {
            New-Object -TypeName Ansible.Privilege.PrivilegeEnabler -ArgumentList $false, "SeTimeZonePrivilege", "SeFake"
        } catch {
            $failed = $true
            $_.Exception.InnerException.Message | Assert-Equals -Expected "Failed to enable privilege(s) SeTimeZonePrivilege, SeFake (A specified privilege does not exist, Win32ErrorCode 1313)"
        }
        $failed | Assert-Equals -Expected $true
    }

    "Test Enabler strict failure" = {
        # Start disabled
        [Ansible.Privilege.PrivilegeUtil]::DisablePrivilege($process, "SeTimeZonePrivilege") > $null
        $check_state = [Ansible.Privilege.PrivilegeUtil]::GetAllPrivilegeInfo($process)
        $check_state.SeTimeZonePrivilege -band [Ansible.Privilege.PrivilegeAttributes]::Enabled | Assert-Equals -Expected 0

        $failed = $false
        try {
            New-Object -TypeName Ansible.Privilege.PrivilegeEnabler -ArgumentList $true, "SeTimeZonePrivilege", "SeTcbPrivilege"
        } catch {
            $failed = $true
            $_.Exception.InnerException.Message | Assert-Equals -Expected "Failed to enable privilege(s) SeTimeZonePrivilege, SeTcbPrivilege (Not all privileges or groups referenced are assigned to the caller, Win32ErrorCode 1300)"
        }
        $failed | Assert-Equals -Expected $true
    }
}

foreach ($test_impl in $tests.GetEnumerator()) {
    $test = $test_impl.Key
    &$test_impl.Value
}
#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

throw

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic

$spec = @{
    options = @{
        data = @{ type = "str"; default = "pong" }
    }
    supports_check_mode = $true
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)
$data = $module.Params.data

if ($data -eq "crash") {
    throw "boom"
}

$module.Result.ping = $data
#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

$blah = 'I can't quote my strings correctly.'

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
    changed = $false
    ping = "pong"
};

# Test that Set-Attr will replace an existing attribute.
Set-Attr $result "ping" $data

#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

throw "no ping for you"

$params = Parse-Args $args $true;

$data = Get-Attr $params "data" "pong";

$result = @{
#!powershell
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# POWERSHELL_COMMON

$params = Parse-Args $args $true;

$params.thisPropertyDoesNotExist

$data = Get-Attr $params "data" "pong";

$result = @{
#!powershell

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.CommandUtil

$ErrorActionPreference = 'Stop'

$params = Parse-Args $args
$exe = Get-AnsibleParam -obj $params -name "exe" -type "path" -failifempty $true

$result = @{
    changed = $false
}

$exe_directory = Split-Path -Path $exe -Parent
$exe_filename = Split-Path -Path $exe -Leaf
$test_name = $null

Function Assert-Equals($actual, $expected) {
    if ($actual -cne $expected) {
        Fail-Json -obj $result -message "Test $test_name failed`nActual: '$actual' != Expected: '$expected'"
    }
}

$test_name = "full exe path"
$actual = Run-Command -command "`"$exe`" arg1 arg2 `"arg 3`""
Assert-Equals -actual $actual.rc -expected 0
Assert-Equals -actual $actual.stdout -expected "arg1`r`narg2`r`narg 3`r`n"
Assert-Equals -actual $actual.stderr -expected ""
Assert-Equals -actual $actual.executable -expected $exe

$test_name = "exe in special char dir"
$tmp_dir = Join-Path -Path $env:TEMP -ChildPath "ansible . [$!@^&test(;)]"
try {
    New-Item -Path $tmp_dir -ItemType Directory > $null
    $exe_special = Join-Path $tmp_dir -ChildPath "PrintArgv.exe"
    Copy-Item -LiteralPath $exe -Destination $exe_special
    $actual = Run-Command -command "`"$exe_special`" arg1 arg2 `"arg 3`""
} finally {
    Remove-Item -LiteralPath $tmp_dir -Force -Recurse
}
Assert-Equals -actual $actual.rc -expected 0
Assert-Equals -actual $actual.stdout -expected "arg1`r`narg2`r`narg 3`r`n"
Assert-Equals -actual $actual.stderr -expected ""
Assert-Equals -actual $actual.executable -expected $exe_special

$test_name = "invalid exe path"
try {
    $actual = Run-Command -command "C:\fakepath\$exe_filename arg1"
    Fail-Json -obj $result -message "Test $test_name failed`nCommand should have thrown an exception"
} catch {
    Assert-Equals -actual $_.Exception.Message -expected "Exception calling `"SearchPath`" with `"1`" argument(s): `"Could not find file 'C:\fakepath\$exe_filename'.`""
}

$test_name = "exe in current folder"
$actual = Run-Command -command "$exe_filename arg1" -working_directory $exe_directory
Assert-Equals -actual $actual.rc -expected 0
Assert-Equals -actual $actual.stdout -expected "arg1`r`n"
Assert-Equals -actual $actual.stderr -expected ""
Assert-Equals -actual $actual.executable -expected $exe

$test_name = "no working directory set"
$actual = Run-Command -command "cmd.exe /c cd"
Assert-Equals -actual $actual.rc -expected 0
Assert-Equals -actual $actual.stdout -expected "$($pwd.Path)`r`n"
Assert-Equals -actual $actual.stderr -expected ""
Assert-Equals -actual $actual.executable.ToUpper() -expected "$env:SystemRoot\System32\cmd.exe".ToUpper()

$test_name = "working directory override"
$actual = Run-Command -command "cmd.exe /c cd" -working_directory $env:SystemRoot
Assert-Equals -actual $actual.rc -expected 0
Assert-Equals -actual $actual.stdout -expected "$env:SystemRoot`r`n"
Assert-Equals -actual $actual.stderr -expected ""
Assert-Equals -actual $actual.executable.ToUpper() -expected "$env:SystemRoot\System32\cmd.exe".ToUpper()

$test_name = "working directory invalid path"
try {
    $actual = Run-Command -command "doesn't matter" -working_directory "invalid path here"
    Fail-Json -obj $result -message "Test $test_name failed`nCommand should have thrown an exception"
} catch {
    Assert-Equals -actual $_.Exception.Message -expected "invalid working directory path 'invalid path here'"
}

$test_name = "invalid arguments"
$actual = Run-Command -command "ipconfig.exe /asdf"
Assert-Equals -actual $actual.rc -expected 1

$test_name = "test stdout and stderr streams"
$actual = Run-Command -command "cmd.exe /c echo stdout && echo stderr 1>&2"
Assert-Equals -actual $actual.rc -expected 0
Assert-Equals -actual $actual.stdout -expected "stdout `r`n"
Assert-Equals -actual $actual.stderr -expected "stderr `r`n"

$test_name = "Test UTF8 output from stdout stream"
$actual = Run-Command -command "powershell.exe -ExecutionPolicy ByPass -Command `"Write-Host ''`""
Assert-Equals -actual $actual.rc -expected 0
Assert-Equals -actual $actual.stdout -expected "`n"
Assert-Equals -actual $actual.stderr -expected ""

$test_name = "test default environment variable"
Set-Item -LiteralPath env:TESTENV -Value "test"
$actual = Run-Command -command "cmd.exe /c set"
$env_present = $actual.stdout -split "`r`n" | Where-Object { $_ -eq "TESTENV=test" }
if ($null -eq $env_present) {
    Fail-Json -obj $result -message "Test $test_name failed`nenvironment variable TESTENV not found in stdout`n$($actual.stdout)"
}

$test_name = "test custom environment variable1"
$actual = Run-Command -command "cmd.exe /c set" -environment @{ TESTENV2 = "testing" }
$env_not_present = $actual.stdout -split "`r`n" | Where-Object { $_ -eq "TESTENV=test" }
$env_present = $actual.stdout -split "`r`n" | Where-Object { $_ -eq "TESTENV2=testing" }
if ($null -ne $env_not_present) {
    Fail-Json -obj $result -message "Test $test_name failed`nenvironment variabel TESTENV found in stdout when it should be`n$($actual.stdout)"
}
if ($null -eq $env_present) {
    Fail-json -obj $result -message "Test $test_name failed`nenvironment variable TESTENV2 not found in stdout`n$($actual.stdout)"
}

$test_name = "input test"
$wrapper = @"
begin {
    `$string = ""
} process {
    `$current_input = [string]`$input
    `$string += `$current_input
} end {
    Write-Host `$string
}
"@
$encoded_wrapper = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($wrapper))
#!powershell

# Copyright: (c) 2018, Ansible Project

#Requires -Module Ansible.ModuleUtils.Legacy

$parsed_args = Parse-Args $args

$sleep_delay_sec = Get-AnsibleParam -obj $parsed_args -name "sleep_delay_sec" -type "int" -default 0
$fail_mode = Get-AnsibleParam -obj $parsed_args -name "fail_mode" -type "str" -default "success" -validateset "success","graceful","exception"

If($fail_mode -isnot [array]) {
    $fail_mode = @($fail_mode)
}

$result = @{
    changed = $true
    module_pid = $pid
    module_tempdir = $PSScriptRoot
}

If($sleep_delay_sec -gt 0) {
    Sleep -Seconds $sleep_delay_sec
    $result["slept_sec"] = $sleep_delay_sec
}

If($fail_mode -contains "leading_junk") {
    Write-Output "leading junk before module output"
}

If($fail_mode -contains "graceful") {
    Fail-Json $result "failed gracefully"
}

Try {

    If($fail_mode -contains "exception") {
        Throw "failing via exception"
    }

    Exit-Json $result
}
Finally
{
    If($fail_mode -contains "trailing_junk") {
#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#Requires -Module Ansible.ModuleUtils.FileUtil
#Requires -Module Ansible.ModuleUtils.LinkUtil

function ConvertTo-Timestamp($start_date, $end_date) {
    if ($start_date -and $end_date) {
        return (New-TimeSpan -Start $start_date -End $end_date).TotalSeconds
    }
}

function Get-FileChecksum($path, $algorithm) {
    switch ($algorithm) {
        'md5' { $sp = New-Object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider }
        'sha1' { $sp = New-Object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider }
        'sha256' { $sp = New-Object -TypeName System.Security.Cryptography.SHA256CryptoServiceProvider }
        'sha384' { $sp = New-Object -TypeName System.Security.Cryptography.SHA384CryptoServiceProvider }
        'sha512' { $sp = New-Object -TypeName System.Security.Cryptography.SHA512CryptoServiceProvider }
        default { Fail-Json -obj $result -message "Unsupported hash algorithm supplied '$algorithm'" }
    }

    $fp = [System.IO.File]::Open($path, [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
    try {
        $hash = [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace("-", "").ToLower()
    } finally {
        $fp.Dispose()
    }

    return $hash
}

function Get-FileInfo {
    param([String]$Path, [Switch]$Follow)

    $info = Get-AnsibleItem -Path $Path -ErrorAction SilentlyContinue
    $link_info = $null
    if ($null -ne $info) {
        try {
            $link_info = Get-Link -link_path $info.FullName
        } catch {
            $module.Warn("Failed to check/get link info for file: $($_.Exception.Message)")
        }

        # If follow=true we want to follow the link all the way back to root object
        if ($Follow -and $null -ne $link_info -and $link_info.Type -in @("SymbolicLink", "JunctionPoint")) {
            $info, $link_info = Get-FileInfo -Path $link_info.AbsolutePath -Follow
        }
    }

    return $info, $link_info
}

$spec = @{
    options = @{
        path = @{ type='path'; required=$true; aliases=@( 'dest', 'name' ) }
        get_checksum = @{ type='bool'; default=$true }
        checksum_algorithm = @{ type='str'; default='sha1'; choices=@( 'md5', 'sha1', 'sha256', 'sha384', 'sha512' ) }
        follow = @{ type='bool'; default=$false }
    }
    supports_check_mode = $true
}

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

$path = $module.Params.path
$get_checksum = $module.Params.get_checksum
$checksum_algorithm = $module.Params.checksum_algorithm
$follow = $module.Params.follow

$module.Result.stat = @{ exists=$false }

Load-LinkUtils
$info, $link_info = Get-FileInfo -Path $path -Follow:$follow
If ($null -ne $info) {
    $epoch_date = Get-Date -Date "01/01/1970"
    $attributes = @()
    foreach ($attribute in ($info.Attributes -split ',')) {
        $attributes += $attribute.Trim()
    }

    # default values that are always set, specific values are set below this
    # but are kept commented for easier readability
    $stat = @{
        exists = $true
        attributes = $info.Attributes.ToString()
        isarchive = ($attributes -contains "Archive")
        isdir = $false
        ishidden = ($attributes -contains "Hidden")
        isjunction = $false
        islnk = $false
        isreadonly = ($attributes -contains "ReadOnly")
        isreg = $false
        isshared = $false
        nlink = 1  # Number of links to the file (hard links), overriden below if islnk
        # lnk_target = islnk or isjunction Target of the symlink. Note that relative paths remain relative
        # lnk_source = islnk os isjunction Target of the symlink normalized for the remote filesystem
        hlnk_targets = @()
        creationtime = (ConvertTo-Timestamp -start_date $epoch_date -end_date $info.CreationTime)
        lastaccesstime = (ConvertTo-Timestamp -start_date $epoch_date -end_date $info.LastAccessTime)
        lastwritetime = (ConvertTo-Timestamp -start_date $epoch_date -end_date $info.LastWriteTime)
        # size = a file and directory - calculated below
        path = $info.FullName
        filename = $info.Name
        # extension = a file
        # owner = set outsite this dict in case it fails
        # sharename = a directory and isshared is True
        # checksum = a file and get_checksum: True
    }
    try {
        $stat.owner = $info.GetAccessControl().Owner
    } catch {
        # may not have rights, historical behaviour was to just set to $null
        # due to ErrorActionPreference being set to "Continue"
        $stat.owner = $null
    }

    # values that are set according to the type of file
    if ($info.Attributes.HasFlag([System.IO.FileAttributes]::Directory)) {
        $stat.isdir = $true
        $share_info = Get-CimInstance -ClassName Win32_Share -Filter "Path='$($stat.path -replace '\\', '\\')'"
        if ($null -ne $share_info) {
            $stat.isshared = $true
            $stat.sharename = $share_info.Name
        }

        try {
            $size = 0
            foreach ($file in $info.EnumerateFiles("*", [System.IO.SearchOption]::AllDirectories)) {
                $size += $file.Length
            }
            $stat.size = $size
        } catch {
            $stat.size = 0
        }
    } else {
        $stat.extension = $info.Extension
        $stat.isreg = $true
        $stat.size = $info.Length

        if ($get_checksum) {
            try {
                $stat.checksum = Get-FileChecksum -path $path -algorithm $checksum_algorithm
            } catch {
                $module.FailJson("Failed to get hash of file, set get_checksum to False to ignore this error: $($_.Exception.Message)", $_)
            }
        }
    }

    # Get symbolic link, junction point, hard link info
    if ($null -ne $link_info) {
        switch ($link_info.Type) {
            "SymbolicLink" {
                $stat.islnk = $true
                $stat.isreg = $false
                $stat.lnk_target = $link_info.TargetPath
                $stat.lnk_source = $link_info.AbsolutePath
                break
            }
            "JunctionPoint" {
                $stat.isjunction = $true
                $stat.isreg = $false
                $stat.lnk_target = $link_info.TargetPath
                $stat.lnk_source = $link_info.AbsolutePath
                break
            }
            "HardLink" {
                $stat.lnk_type = "hard"
                $stat.nlink = $link_info.HardTargets.Count

                # remove current path from the targets
                $hlnk_targets = $link_info.HardTargets | Where-Object { $_ -ne $stat.path }
                $stat.hlnk_targets = @($hlnk_targets)
                break
            }
        }
    }

    $module.Result.stat = $stat
}

$module.ExitJson()
#!powershell

# Copyright: (c) 2015, Phil Schwartz <schwartzmx@gmail.com>
# Copyright: (c) 2015, Trond Hindenes
# Copyright: (c) 2015, Hans-Joachim Kliemeck <git@kliemeck.de>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.PrivilegeUtil
#Requires -Module Ansible.ModuleUtils.SID

$ErrorActionPreference = "Stop"

# win_acl module (File/Resources Permission Additions/Removal)

#Functions
function Get-UserSID {
    param(
        [String]$AccountName
    )

    $userSID = $null
    $searchAppPools = $false

    if ($AccountName.Split("\").Count -gt 1) {
        if ($AccountName.Split("\")[0] -eq "IIS APPPOOL") {
            $searchAppPools = $true
            $AccountName = $AccountName.Split("\")[1]
        }
    }

    if ($searchAppPools) {
        Import-Module -Name WebAdministration
        $testIISPath = Test-Path -LiteralPath "IIS:"
        if ($testIISPath) {
            $appPoolObj = Get-ItemProperty -LiteralPath "IIS:\AppPools\$AccountName"
            $userSID = $appPoolObj.applicationPoolSid
        }
    }
    else {
        $userSID = Convert-ToSID -account_name $AccountName
    }

    return $userSID
}

$params = Parse-Args $args

Function SetPrivilegeTokens() {
    # Set privilege tokens only if admin.
    # Admins would have these privs or be able to set these privs in the UI Anyway

    $adminRole=[System.Security.Principal.WindowsBuiltInRole]::Administrator
    $myWindowsID=[System.Security.Principal.WindowsIdentity]::GetCurrent()
    $myWindowsPrincipal=new-object System.Security.Principal.WindowsPrincipal($myWindowsID)


    if ($myWindowsPrincipal.IsInRole($adminRole)) {
        # Need to adjust token privs when executing Set-ACL in certain cases.
        # e.g. d:\testdir is owned by group in which current user is not a member and no perms are inherited from d:\
        # This also sets us up for setting the owner as a feature.
        # See the following for details of each privilege
        # https://msdn.microsoft.com/en-us/library/windows/desktop/bb530716(v=vs.85).aspx
        $privileges = @(
            "SeRestorePrivilege",  # Grants all write access control to any file, regardless of ACL.
            "SeBackupPrivilege",  # Grants all read access control to any file, regardless of ACL.
            "SeTakeOwnershipPrivilege"  # Grants ability to take owernship of an object w/out being granted discretionary access
        )
        foreach ($privilege in $privileges) {
            $state = Get-AnsiblePrivilege -Name $privilege
            if ($state -eq $false) {
                Set-AnsiblePrivilege -Name $privilege -Value $true
            }
        }
    }
}


$result = @{
    changed = $false
}

$path = Get-AnsibleParam -obj $params -name "path" -type "str" -failifempty $true
$user = Get-AnsibleParam -obj $params -name "user" -type "str" -failifempty $true
$rights = Get-AnsibleParam -obj $params -name "rights" -type "str" -failifempty $true

$type = Get-AnsibleParam -obj $params -name "type" -type "str" -failifempty $true -validateset "allow","deny"
$state = Get-AnsibleParam -obj $params -name "state" -type "str" -default "present" -validateset "absent","present"

$inherit = Get-AnsibleParam -obj $params -name "inherit" -type "str"
$propagation = Get-AnsibleParam -obj $params -name "propagation" -type "str" -default "None" -validateset "InheritOnly","None","NoPropagateInherit"

# We mount the HKCR, HKU, and HKCC registry hives so PS can access them.
# Network paths have no qualifiers so we use -EA SilentlyContinue to ignore that
$path_qualifier = Split-Path -Path $path -Qualifier -ErrorAction SilentlyContinue
if ($path_qualifier -eq "HKCR:" -and (-not (Test-Path -LiteralPath HKCR:\))) {
    New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT > $null
}
if ($path_qualifier -eq "HKU:" -and (-not (Test-Path -LiteralPath HKU:\))) {
    New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS > $null
}
if ($path_qualifier -eq "HKCC:" -and (-not (Test-Path -LiteralPath HKCC:\))) {
    New-PSDrive -Name HKCC -PSProvider Registry -Root HKEY_CURRENT_CONFIG > $null
}

If (-Not (Test-Path -LiteralPath $path)) {
    Fail-Json -obj $result -message "$path file or directory does not exist on the host"
}

# Test that the user/group is resolvable on the local machine
$sid = Get-UserSID -AccountName $user
if (!$sid) {
    Fail-Json -obj $result -message "$user is not a valid user or group on the host machine or domain"
}

If (Test-Path -LiteralPath $path -PathType Leaf) {
    $inherit = "None"
}
ElseIf ($null -eq $inherit) {
    $inherit = "ContainerInherit, ObjectInherit"
}

# Bug in Set-Acl, Get-Acl where -LiteralPath only works for the Registry provider if the location is in that root
# qualifier. We also don't have a qualifier for a network path so only change if not null
if ($null -ne $path_qualifier) {
    Push-Location -LiteralPath $path_qualifier
}

Try {
    SetPrivilegeTokens
    $path_item = Get-Item -LiteralPath $path -Force
    If ($path_item.PSProvider.Name -eq "Registry") {
        $colRights = [System.Security.AccessControl.RegistryRights]$rights
    }
    Else {
        $colRights = [System.Security.AccessControl.FileSystemRights]$rights
    }

    $InheritanceFlag = [System.Security.AccessControl.InheritanceFlags]$inherit
    $PropagationFlag = [System.Security.AccessControl.PropagationFlags]$propagation

    If ($type -eq "allow") {
        $objType =[System.Security.AccessControl.AccessControlType]::Allow
    }
    Else {
        $objType =[System.Security.AccessControl.AccessControlType]::Deny
    }

    $objUser = New-Object System.Security.Principal.SecurityIdentifier($sid)
    If ($path_item.PSProvider.Name -eq "Registry") {
        $objACE = New-Object System.Security.AccessControl.RegistryAccessRule ($objUser, $colRights, $InheritanceFlag, $PropagationFlag, $objType)
    }
    Else {
        $objACE = New-Object System.Security.AccessControl.FileSystemAccessRule ($objUser, $colRights, $InheritanceFlag, $PropagationFlag, $objType)
    }
    $objACL = Get-ACL -LiteralPath $path

    # Check if the ACE exists already in the objects ACL list
    $match = $false

    ForEach($rule in $objACL.GetAccessRules($true, $true, [System.Security.Principal.SecurityIdentifier])){

        If ($path_item.PSProvider.Name -eq "Registry") {
            If (($rule.RegistryRights -eq $objACE.RegistryRights) -And ($rule.AccessControlType -eq $objACE.AccessControlType) -And ($rule.IdentityReference -eq $objACE.IdentityReference) -And ($rule.IsInherited -eq $objACE.IsInherited) -And ($rule.InheritanceFlags -eq $objACE.InheritanceFlags) -And ($rule.PropagationFlags -eq $objACE.PropagationFlags)) {
                $match = $true
                Break
            }
        } else {
            If (($rule.FileSystemRights -eq $objACE.FileSystemRights) -And ($rule.AccessControlType -eq $objACE.AccessControlType) -And ($rule.IdentityReference -eq $objACE.IdentityReference) -And ($rule.IsInherited -eq $objACE.IsInherited) -And ($rule.InheritanceFlags -eq $objACE.InheritanceFlags) -And ($rule.PropagationFlags -eq $objACE.PropagationFlags)) {
                $match = $true
                Break
            }
        }
    }

    If ($state -eq "present" -And $match -eq $false) {
        Try {
            $objACL.AddAccessRule($objACE)
            If ($path_item.PSProvider.Name -eq "Registry") {
                Set-ACL -LiteralPath $path -AclObject $objACL
            } else {
                (Get-Item -LiteralPath $path).SetAccessControl($objACL)
            }
            $result.changed = $true
        }
        Catch {
            Fail-Json -obj $result -message "an exception occurred when adding the specified rule - $($_.Exception.Message)"
        }
    }
    ElseIf ($state -eq "absent" -And $match -eq $true) {
        Try {
            $objACL.RemoveAccessRule($objACE)
            If ($path_item.PSProvider.Name -eq "Registry") {
                Set-ACL -LiteralPath $path -AclObject $objACL
            } else {
                (Get-Item -LiteralPath $path).SetAccessControl($objACL)
            }
            $result.changed = $true
        }
        Catch {
            Fail-Json -obj $result -message "an exception occurred when removing the specified rule - $($_.Exception.Message)"
        }
    }
    Else {
        # A rule was attempting to be added but already exists
        If ($match -eq $true) {
            Exit-Json -obj $result -message "the specified rule already exists"
        }
        # A rule didn't exist that was trying to be removed
        Else {
            Exit-Json -obj $result -message "the specified rule does not exist"
        }
    }
}
Catch {
    Fail-Json -obj $result -message "an error occurred when attempting to $state $rights permission(s) on $path for $user - $($_.Exception.Message)"
}
Finally {
    # Make sure we revert the location stack to the original path just for cleanups sake
    if ($null -ne $path_qualifier) {
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy

$results = @{changed=$false}

$parsed_args = Parse-Args $args
$jid = Get-AnsibleParam $parsed_args "jid" -failifempty $true -resultobj $results
$mode = Get-AnsibleParam $parsed_args "mode" -Default "status" -ValidateSet "status","cleanup"

# parsed in from the async_status action plugin
$async_dir = Get-AnsibleParam $parsed_args "_async_dir" -type "path" -failifempty $true

$log_path = [System.IO.Path]::Combine($async_dir, $jid)

If(-not $(Test-Path $log_path))
{
    Fail-Json @{ansible_job_id=$jid; started=1; finished=1} "could not find job at '$async_dir'"
}

If($mode -eq "cleanup") {
    Remove-Item $log_path -Recurse
    Exit-Json @{ansible_job_id=$jid; erased=$log_path}
}

# NOT in cleanup mode, assume regular status mode
# no remote kill mode currently exists, but probably should
# consider log_path + ".pid" file and also unlink that above

$data = $null
Try {
    $data_raw = Get-Content $log_path

    # TODO: move this into module_utils/powershell.ps1?
    $jss = New-Object System.Web.Script.Serialization.JavaScriptSerializer
    $data = $jss.DeserializeObject($data_raw)
}
Catch {
    If(-not $data_raw) {
        # file not written yet?  That means it is running
        Exit-Json @{results_file=$log_path; ansible_job_id=$jid; started=1; finished=0}
    }
    Else {
        Fail-Json @{ansible_job_id=$jid; results_file=$log_path; started=1; finished=1} "Could not parse job output: $data"
    }
}

If (-not $data.ContainsKey("started")) {
    $data['finished'] = 1
    $data['ansible_job_id'] = $jid
}
ElseIf (-not $data.ContainsKey("finished")) {
    $data['finished'] = 0
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy

Set-StrictMode -Version 2
$ErrorActionPreference = "Stop"

$system_path = "System\CurrentControlSet\Control\Session Manager\Environment"
$user_path = "Environment"

# list/arraylist methods don't allow IEqualityComparer override for case/backslash/quote-insensitivity, roll our own search
Function Get-IndexOfPathElement ($list, [string]$value) {
    $idx = 0
    $value = $value.Trim('"').Trim('\')
    ForEach($el in $list) {
        If ([string]$el.Trim('"').Trim('\') -ieq $value) {
            return $idx
        }

        $idx++
    }

    return -1
}

# alters list in place, returns true if at least one element was added
Function Add-Elements ($existing_elements, $elements_to_add) {
    $last_idx = -1
    $changed = $false

    ForEach($el in $elements_to_add) {
        $idx = Get-IndexOfPathElement $existing_elements $el

        # add missing elements at the end
        If ($idx -eq -1) {
            $last_idx = $existing_elements.Add($el)
            $changed = $true
        }
        ElseIf ($idx -lt $last_idx) {
            $existing_elements.RemoveAt($idx) | Out-Null
            $existing_elements.Add($el) | Out-Null
            $last_idx = $existing_elements.Count - 1
            $changed = $true
        }
        Else {
            $last_idx = $idx
        }
    }

    return $changed
}

# alters list in place, returns true if at least one element was removed
Function Remove-Elements ($existing_elements, $elements_to_remove) {
    $count = $existing_elements.Count

    ForEach($el in $elements_to_remove) {
        $idx = Get-IndexOfPathElement $existing_elements $el
        $result.removed_idx = $idx
        If ($idx -gt -1) {
            $existing_elements.RemoveAt($idx)
        }
    }

    return $count -ne $existing_elements.Count
}

# PS registry provider doesn't allow access to unexpanded REG_EXPAND_SZ; fall back to .NET
Function Get-RawPathVar ($scope) {
    If ($scope -eq "user") {
        $env_key = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($user_path)
    }
    ElseIf ($scope -eq "machine") {
        $env_key = [Microsoft.Win32.Registry]::LocalMachine.OpenSubKey($system_path)
    }

    return $env_key.GetValue($var_name, "", [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames)
}

Function Set-RawPathVar($path_value, $scope) {
    If ($scope -eq "user") {
        $var_path = "HKCU:\" + $user_path
    }
    ElseIf ($scope -eq "machine") {
        $var_path = "HKLM:\" + $system_path
    }

    Set-ItemProperty $var_path -Name $var_name -Value $path_value -Type ExpandString | Out-Null

    return $path_value
}

$parsed_args = Parse-Args $args -supports_check_mode $true

$result = @{changed=$false}

$var_name = Get-AnsibleParam $parsed_args "name" -Default "PATH"
$elements = Get-AnsibleParam $parsed_args "elements" -FailIfEmpty $result
$state = Get-AnsibleParam $parsed_args "state" -Default "present" -ValidateSet "present","absent"
$scope = Get-AnsibleParam $parsed_args "scope" -Default "machine" -ValidateSet "machine","user"

$check_mode = Get-AnsibleParam $parsed_args "_ansible_check_mode" -Default $false

If ($elements -is [string]) {
    $elements = @($elements)
}

If ($elements -isnot [Array]) {
    Fail-Json $result "elements must be a string or list of path strings"
}

$current_value = Get-RawPathVar $scope
$result.path_value = $current_value

# TODO: test case-canonicalization on wacky unicode values (eg turkish i)
# TODO: detect and warn/fail on unparseable path? (eg, unbalanced quotes, invalid path chars)
# TODO: detect and warn/fail if system path and Powershell isn't on it?

$existing_elements = New-Object System.Collections.ArrayList

# split on semicolons, accounting for quoted values with embedded semicolons (which may or may not be wrapped in whitespace)
$pathsplit_re = [regex] '((?<q>\s*"[^"]+"\s*)|(?<q>[^;]+))(;$|$|;)'

ForEach ($m in $pathsplit_re.Matches($current_value)) {
    $existing_elements.Add($m.Groups['q'].Value) | Out-Null
}

If ($state -eq "absent") {
    $result.changed = Remove-Elements $existing_elements $elements
}
ElseIf ($state -eq "present") {
    $result.changed = Add-Elements $existing_elements $elements
}

# calculate the new path value from the existing elements
$path_value = [String]::Join(";", $existing_elements.ToArray())
$result.path_value = $path_value

#!powershell

# Copyright: (c) 2017, Jordan Borean <jborean93@gmail.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy

$ErrorActionPreference = 'Stop'

$params = Parse-Args $args -supports_check_mode $true
$check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -type "bool" -default $false
$diff_mode = Get-AnsibleParam -obj $Params -name "_ansible_diff" -type "bool" -default $false

$section = Get-AnsibleParam -obj $params -name "section" -type "str" -failifempty $true
$key = Get-AnsibleParam -obj $params -name "key" -type "str" -failifempty $true
$value = Get-AnsibleParam -obj $params -name "value" -failifempty $true

$result = @{
    changed = $false
    section = $section
    key = $key
    value = $value
}

if ($diff_mode) {
    $result.diff = @{}
}

Function Run-SecEdit($arguments) {
    $stdout = $null
    $stderr = $null
    $log_path = [IO.Path]::GetTempFileName()
    $arguments = $arguments + @("/log", $log_path)

    try {
        $stdout = &SecEdit.exe $arguments | Out-String
    } catch {
        $stderr = $_.Exception.Message
    }
    $log = Get-Content -Path $log_path
    Remove-Item -Path $log_path -Force

    $return = @{
        log = ($log -join "`n").Trim()
        stdout = $stdout
        stderr = $stderr
        rc = $LASTEXITCODE
    }

    return $return
}

Function Export-SecEdit() {
    $secedit_ini_path = [IO.Path]::GetTempFileName()
    # while this will technically make a change to the system in check mode by
    # creating a new file, we need these values to be able to do anything
    # substantial in check mode
    $export_result = Run-SecEdit -arguments @("/export", "/cfg", $secedit_ini_path, "/quiet")

    # check the return code and if the file has been populated, otherwise error out
    if (($export_result.rc -ne 0) -or ((Get-Item -Path $secedit_ini_path).Length -eq 0)) {
        Remove-Item -Path $secedit_ini_path -Force
        $result.rc = $export_result.rc
        $result.stdout = $export_result.stdout
        $result.stderr = $export_result.stderr
        Fail-Json $result "Failed to export secedit.ini file to $($secedit_ini_path)"
    }
    $secedit_ini = ConvertFrom-Ini -file_path $secedit_ini_path

    return $secedit_ini
}

Function Import-SecEdit($ini) {
    $secedit_ini_path = [IO.Path]::GetTempFileName()
    $secedit_db_path = [IO.Path]::GetTempFileName()
    Remove-Item -Path $secedit_db_path -Force # needs to be deleted for SecEdit.exe /import to work

    $ini_contents = ConvertTo-Ini -ini $ini
    Set-Content -Path $secedit_ini_path -Value $ini_contents
    $result.changed = $true

    $import_result = Run-SecEdit -arguments @("/configure", "/db", $secedit_db_path, "/cfg", $secedit_ini_path, "/quiet")
    $result.import_log = $import_result.log
    Remove-Item -Path $secedit_ini_path -Force
    if ($import_result.rc -ne 0) {
        $result.rc = $import_result.rc
        $result.stdout = $import_result.stdout
        $result.stderr = $import_result.stderr
        Fail-Json $result "Failed to import secedit.ini file from $($secedit_ini_path)"
    }
}

Function ConvertTo-Ini($ini) {
    $content = @()
    foreach ($key in $ini.GetEnumerator()) {
        $section = $key.Name
        $values = $key.Value

        $content += "[$section]"
        foreach ($value in $values.GetEnumerator()) {
            $value_key = $value.Name
            $value_value = $value.Value

            if ($null -ne $value_value) {
                $content += "$value_key = $value_value"
            }
        }
    }

    return $content -join "`r`n"
}

Function ConvertFrom-Ini($file_path) {
    $ini = @{}
    switch -Regex -File $file_path {
        "^\[(.+)\]" {
            $section = $matches[1]
            $ini.$section = @{}
        }
        "(.+?)\s*=(.*)" {
            $name = $matches[1].Trim()
            $value = $matches[2].Trim()
            if ($value -match "^\d+$") {
                $value = [int]$value
            } elseif ($value.StartsWith('"') -and $value.EndsWith('"')) {
                $value = $value.Substring(1, $value.Length - 2)
            }

            $ini.$section.$name = $value
        }
    }

    return $ini
}

if ($section -eq "Privilege Rights") {
    Add-Warning -obj $result -message "Using this module to edit rights and privileges is error-prone, use the win_user_right module instead"
}

$will_change = $false
$secedit_ini = Export-SecEdit
if (-not ($secedit_ini.ContainsKey($section))) {
    Fail-Json $result "The section '$section' does not exist in SecEdit.exe output ini"
}

if ($secedit_ini.$section.ContainsKey($key)) {
    $current_value = $secedit_ini.$section.$key

    if ($current_value -cne $value) {
        if ($diff_mode) {
            $result.diff.prepared = @"
[$section]
-$key = $current_value
+$key = $value
"@
        }

        $secedit_ini.$section.$key = $value
        $will_change = $true
    }
} elseif ([string]$value -eq "") {
      # Value is requested to be removed, and has already been removed, do nothing
} else {
    if ($diff_mode) {
        $result.diff.prepared = @"
[$section]
+$key = $value
"@
    }
    $secedit_ini.$section.$key = $value
    $will_change = $true
}

if ($will_change -eq $true) {
    $result.changed = $true
    if (-not $check_mode) {
        Import-SecEdit -ini $secedit_ini

        # secedit doesn't error out on improper entries, re-export and verify
        # the changes occurred
        $verification_ini = Export-SecEdit
        $new_section_values = $verification_ini.$section
        if ($new_section_values.ContainsKey($key)) {
            $new_value = $new_section_values.$key
            if ($new_value -cne $value) {
                Fail-Json $result "Failed to change the value for key '$key' in section '$section', the value is still $new_value"
            }
        } elseif ([string]$value -eq "") {
            # Value was empty, so OK if no longer in the result
        } else {
            Fail-Json $result "The key '$key' in section '$section' is not a valid key, cannot set this value"
        }
    }
}

#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic

$spec = @{
    options = @{
        data = @{ type = "str"; default = "pong" }
    }
    supports_check_mode = $true
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)
$data = $module.Params.data

if ($data -eq "crash") {
    throw "boom"
}

$module.Result.ping = $data
#!powershell

# Copyright: (c) 2015, Jon Hawkesworth (@jhawkesworth) <figs@unity.demon.co.uk>
# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.Backup

$ErrorActionPreference = 'Stop'

$params = Parse-Args -arguments $args -supports_check_mode $true
$check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -type "bool" -default $false
$diff_mode = Get-AnsibleParam -obj $params -name "_ansible_diff" -type "bool" -default $false

# there are 4 modes to win_copy which are driven by the action plugins:
#   explode: src is a zip file which needs to be extracted to dest, for use with multiple files
#   query: win_copy action plugin wants to get the state of remote files to check whether it needs to send them
#   remote: all copy action is happening remotely (remote_src=True)
#   single: a single file has been copied, also used with template
$copy_mode = Get-AnsibleParam -obj $params -name "_copy_mode" -type "str" -default "single" -validateset "explode","query","remote","single"

# used in explode, remote and single mode
$src = Get-AnsibleParam -obj $params -name "src" -type "path" -failifempty ($copy_mode -in @("explode","process","single"))
$dest = Get-AnsibleParam -obj $params -name "dest" -type "path" -failifempty $true
$backup = Get-AnsibleParam -obj $params -name "backup" -type "bool" -default $false

# used in single mode
$original_basename = Get-AnsibleParam -obj $params -name "_original_basename" -type "str"

# used in query and remote mode
$force = Get-AnsibleParam -obj $params -name "force" -type "bool" -default $true

# used in query mode, contains the local files/directories/symlinks that are to be copied
$files = Get-AnsibleParam -obj $params -name "files" -type "list"
$directories = Get-AnsibleParam -obj $params -name "directories" -type "list"

$result = @{
    changed = $false
}

if ($diff_mode) {
    $result.diff = @{}
}

Function Copy-File($source, $dest) {
    $diff = ""
    $copy_file = $false
    $source_checksum = $null
    if ($force) {
        $source_checksum = Get-FileChecksum -path $source
    }

    if (Test-Path -LiteralPath $dest -PathType Container) {
        Fail-Json -obj $result -message "cannot copy file from '$source' to '$dest': dest is already a folder"
    } elseif (Test-Path -LiteralPath $dest -PathType Leaf) {
        if ($force) {
            $target_checksum = Get-FileChecksum -path $dest
            if ($source_checksum -ne $target_checksum) {
                $copy_file = $true
            }
        }
    } else {
        $copy_file = $true
    }

    if ($copy_file) {
        $file_dir = [System.IO.Path]::GetDirectoryName($dest)
        # validate the parent dir is not a file and that it exists
        if (Test-Path -LiteralPath $file_dir -PathType Leaf) {
            Fail-Json -obj $result -message "cannot copy file from '$source' to '$dest': object at dest parent dir is not a folder"
        } elseif (-not (Test-Path -LiteralPath $file_dir)) {
            # directory doesn't exist, need to create
            New-Item -Path $file_dir -ItemType Directory -WhatIf:$check_mode | Out-Null
            $diff += "+$file_dir\`n"
        }

        if ($backup) {
            $result.backup_file = Backup-File -path $dest -WhatIf:$check_mode
        }

        if (Test-Path -LiteralPath $dest -PathType Leaf) {
            Remove-Item -LiteralPath $dest -Force -Recurse -WhatIf:$check_mode | Out-Null
            $diff += "-$dest`n"
        }

        if (-not $check_mode) {
            # cannot run with -WhatIf:$check_mode as if the parent dir didn't
            # exist and was created above would still not exist in check mode
            Copy-Item -LiteralPath $source -Destination $dest -Force | Out-Null
        }
        $diff += "+$dest`n"

        $result.changed = $true
    }

    # ugly but to save us from running the checksum twice, let's return it for
    # the main code to add it to $result
    return ,@{ diff = $diff; checksum = $source_checksum }
}

Function Copy-Folder($source, $dest) {
    $diff = ""

    if (-not (Test-Path -LiteralPath $dest -PathType Container)) {
        $parent_dir = [System.IO.Path]::GetDirectoryName($dest)
        if (Test-Path -LiteralPath $parent_dir -PathType Leaf) {
            Fail-Json -obj $result -message "cannot copy file from '$source' to '$dest': object at dest parent dir is not a folder"
        }
        if (Test-Path -LiteralPath $dest -PathType Leaf) {
            Fail-Json -obj $result -message "cannot copy folder from '$source' to '$dest': dest is already a file"
        }

        New-Item -Path $dest -ItemType Container -WhatIf:$check_mode | Out-Null
        $diff += "+$dest\`n"
        $result.changed = $true
    }

    $child_items = Get-ChildItem -LiteralPath $source -Force
    foreach ($child_item in $child_items) {
        $dest_child_path = Join-Path -Path $dest -ChildPath $child_item.Name
        if ($child_item.PSIsContainer) {
            $diff += (Copy-Folder -source $child_item.Fullname -dest $dest_child_path)
        } else {
            $diff += (Copy-File -source $child_item.Fullname -dest $dest_child_path).diff
        }
    }

    return $diff
}

Function Get-FileSize($path) {
    $file = Get-Item -LiteralPath $path -Force
    if ($file.PSIsContainer) {
        $size = (Get-ChildItem -Literalpath $file.FullName -Recurse -Force | `
            Where-Object { $_.PSObject.Properties.Name -contains 'Length' } | `
            Measure-Object -Property Length -Sum).Sum
        if ($null -eq $size) {
            $size = 0
        }
    } else {
        $size = $file.Length
    }

    $size
}

Function Extract-Zip($src, $dest) {
    $archive = [System.IO.Compression.ZipFile]::Open($src, [System.IO.Compression.ZipArchiveMode]::Read, [System.Text.Encoding]::UTF8)
    foreach ($entry in $archive.Entries) {
        $archive_name = $entry.FullName

        # FullName may be appended with / or \, determine if it is padded and remove it
        $padding_length = $archive_name.Length % 4
        if ($padding_length -eq 0) {
            $is_dir = $false
            $base64_name = $archive_name
        } elseif ($padding_length -eq 1) {
            $is_dir = $true
            if ($archive_name.EndsWith("/") -or $archive_name.EndsWith("`\")) {
                $base64_name = $archive_name.Substring(0, $archive_name.Length - 1)
            } else {
                throw "invalid base64 archive name '$archive_name'"
            }
        } else {
            throw "invalid base64 length '$archive_name'"
        }

        # to handle unicode character, win_copy action plugin has encoded the filename
        $decoded_archive_name = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($base64_name))
        # re-add the / to the entry full name if it was a directory
        if ($is_dir) {
            $decoded_archive_name = "$decoded_archive_name/"
        }
        $entry_target_path = [System.IO.Path]::Combine($dest, $decoded_archive_name)
        $entry_dir = [System.IO.Path]::GetDirectoryName($entry_target_path)

        if (-not (Test-Path -LiteralPath $entry_dir)) {
            New-Item -Path $entry_dir -ItemType Directory -WhatIf:$check_mode | Out-Null
        }

        if ($is_dir -eq $false) {
            if (-not $check_mode) {
                [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $entry_target_path, $true)
            }
        }
    }
    $archive.Dispose()  # release the handle of the zip file
}

Function Extract-ZipLegacy($src, $dest) {
    if (-not (Test-Path -LiteralPath $dest)) {
        New-Item -Path $dest -ItemType Directory -WhatIf:$check_mode | Out-Null
    }
    $shell = New-Object -ComObject Shell.Application
    $zip = $shell.NameSpace($src)
    $dest_path = $shell.NameSpace($dest)

    foreach ($entry in $zip.Items()) {
        $is_dir = $entry.IsFolder
        $encoded_archive_entry = $entry.Name
        # to handle unicode character, win_copy action plugin has encoded the filename
        $decoded_archive_entry = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encoded_archive_entry))
        if ($is_dir) {
            $decoded_archive_entry = "$decoded_archive_entry/"
        }

        $entry_target_path = [System.IO.Path]::Combine($dest, $decoded_archive_entry)
        $entry_dir = [System.IO.Path]::GetDirectoryName($entry_target_path)

        if (-not (Test-Path -LiteralPath $entry_dir)) {
            New-Item -Path $entry_dir -ItemType Directory -WhatIf:$check_mode | Out-Null
        }

        if ($is_dir -eq $false -and (-not $check_mode)) {
            # https://msdn.microsoft.com/en-us/library/windows/desktop/bb787866.aspx
            # From Folder.CopyHere documentation, 1044 means:
            #  - 1024: do not display a user interface if an error occurs
            #  -   16: respond with "yes to all" for any dialog box that is displayed
            #  -    4: do not display a progress dialog box
            $dest_path.CopyHere($entry, 1044)

            # once file is extraced, we need to rename it with non base64 name
            $combined_encoded_path = [System.IO.Path]::Combine($dest, $encoded_archive_entry)
            Move-Item -LiteralPath $combined_encoded_path -Destination $entry_target_path -Force | Out-Null
        }
    }
}

if ($copy_mode -eq "query") {
    # we only return a list of files/directories that need to be copied over
    # the source of the local file will be the key used
    $changed_files = @()
    $changed_directories = @()
    $changed_symlinks = @()

    foreach ($file in $files) {
        $filename = $file.dest
        $local_checksum = $file.checksum

        $filepath = Join-Path -Path $dest -ChildPath $filename
        if (Test-Path -LiteralPath $filepath -PathType Leaf) {
            if ($force) {
                $checksum = Get-FileChecksum -path $filepath
                if ($checksum -ne $local_checksum) {
                    $changed_files += $file
                }
            }
        } elseif (Test-Path -LiteralPath $filepath -PathType Container) {
            Fail-Json -obj $result -message "cannot copy file to dest '$filepath': object at path is already a directory"
        } else {
            $changed_files += $file
        }
    }

    foreach ($directory in $directories) {
        $dirname = $directory.dest

        $dirpath = Join-Path -Path $dest -ChildPath $dirname
        $parent_dir = [System.IO.Path]::GetDirectoryName($dirpath)
        if (Test-Path -LiteralPath $parent_dir -PathType Leaf) {
            Fail-Json -obj $result -message "cannot copy folder to dest '$dirpath': object at parent directory path is already a file"
        }
        if (Test-Path -LiteralPath $dirpath -PathType Leaf) {
            Fail-Json -obj $result -message "cannot copy folder to dest '$dirpath': object at path is already a file"
        } elseif (-not (Test-Path -LiteralPath $dirpath -PathType Container)) {
            $changed_directories += $directory
        }
    }

    # TODO: Handle symlinks

    $result.files = $changed_files
    $result.directories = $changed_directories
    $result.symlinks = $changed_symlinks
} elseif ($copy_mode -eq "explode") {
    # a single zip file containing the files and directories needs to be
    # expanded this will always result in a change as the calculation is done
    # on the win_copy action plugin and is only run if a change needs to occur
    if (-not (Test-Path -LiteralPath $src -PathType Leaf)) {
        Fail-Json -obj $result -message "Cannot expand src zip file: '$src' as it does not exist"
    }

    # Detect if the PS zip assemblies are available or whether to use Shell
    $use_legacy = $false
    try {
        Add-Type -AssemblyName System.IO.Compression.FileSystem | Out-Null
        Add-Type -AssemblyName System.IO.Compression | Out-Null
    } catch {
        $use_legacy = $true
    }
    if ($use_legacy) {
        Extract-ZipLegacy -src $src -dest $dest
    } else {
        Extract-Zip -src $src -dest $dest
    }

    $result.changed = $true
} elseif ($copy_mode -eq "remote") {
    # all copy actions are happening on the remote side (windows host), need
    # too copy source and dest using PS code
    $result.src = $src
    $result.dest = $dest

    if (-not (Test-Path -LiteralPath $src)) {
        Fail-Json -obj $result -message "Cannot copy src file: '$src' as it does not exist"
    }

    if (Test-Path -LiteralPath $src -PathType Container) {
        # we are copying a directory or the contents of a directory
        $result.operation = 'folder_copy'
        if ($src.EndsWith("/") -or $src.EndsWith("`\")) {
            # copying the folder's contents to dest
            $diff = ""
            $child_files = Get-ChildItem -LiteralPath $src -Force
            foreach ($child_file in $child_files) {
                $dest_child_path = Join-Path -Path $dest -ChildPath $child_file.Name
                if ($child_file.PSIsContainer) {
                    $diff += Copy-Folder -source $child_file.FullName -dest $dest_child_path
                } else {
                    $diff += (Copy-File -source $child_file.FullName -dest $dest_child_path).diff
                }
            }
        } else {
            # copying the folder and it's contents to dest
            $dest = Join-Path -Path $dest -ChildPath (Get-Item -LiteralPath $src -Force).Name
            $result.dest = $dest
            $diff = Copy-Folder -source $src -dest $dest
        }
    } else {
        # we are just copying a single file to dest
        $result.operation = 'file_copy'

        $source_basename = (Get-Item -LiteralPath $src -Force).Name
        $result.original_basename = $source_basename

        if ($dest.EndsWith("/") -or $dest.EndsWith("`\")) {
            $dest = Join-Path -Path $dest -ChildPath (Get-Item -LiteralPath $src -Force).Name
            $result.dest = $dest
        } else {
            # check if the parent dir exists, this is only done if src is a
            # file and dest if the path to a file (doesn't end with \ or /)
            $parent_dir = Split-Path -LiteralPath $dest
            if (Test-Path -LiteralPath $parent_dir -PathType Leaf) {
                Fail-Json -obj $result -message "object at destination parent dir '$parent_dir' is currently a file"
            } elseif (-not (Test-Path -LiteralPath $parent_dir -PathType Container)) {
                Fail-Json -obj $result -message "Destination directory '$parent_dir' does not exist"
            }
        }
        $copy_result = Copy-File -source $src -dest $dest
        $diff = $copy_result.diff
        $result.checksum = $copy_result.checksum
    }

    # the file might not exist if running in check mode
    if (-not $check_mode -or (Test-Path -LiteralPath $dest -PathType Leaf)) {
        $result.size = Get-FileSize -path $dest
    } else {
        $result.size = $null
    }
    if ($diff_mode) {
        $result.diff.prepared = $diff
    }
} elseif ($copy_mode -eq "single") {
    # a single file is located in src and we need to copy to dest, this will
    # always result in a change as the calculation is done on the Ansible side
    # before this is run. This should also never run in check mode
    if (-not (Test-Path -LiteralPath $src -PathType Leaf)) {
        Fail-Json -obj $result -message "Cannot copy src file: '$src' as it does not exist"
    }

    # the dest parameter is a directory, we need to append original_basename
    if ($dest.EndsWith("/") -or $dest.EndsWith("`\") -or (Test-Path -LiteralPath $dest -PathType Container)) {
        $remote_dest = Join-Path -Path $dest -ChildPath $original_basename
        $parent_dir = Split-Path -LiteralPath $remote_dest

        # when dest ends with /, we need to create the destination directories
        if (Test-Path -LiteralPath $parent_dir -PathType Leaf) {
            Fail-Json -obj $result -message "object at destination parent dir '$parent_dir' is currently a file"
        } elseif (-not (Test-Path -LiteralPath $parent_dir -PathType Container)) {
            New-Item -Path $parent_dir -ItemType Directory | Out-Null
        }
    } else {
        $remote_dest = $dest
        $parent_dir = Split-Path -LiteralPath $remote_dest

        # check if the dest parent dirs exist, need to fail if they don't
        if (Test-Path -LiteralPath $parent_dir -PathType Leaf) {
            Fail-Json -obj $result -message "object at destination parent dir '$parent_dir' is currently a file"
        } elseif (-not (Test-Path -LiteralPath $parent_dir -PathType Container)) {
            Fail-Json -obj $result -message "Destination directory '$parent_dir' does not exist"
        }
    }

    if ($backup) {
        $result.backup_file = Backup-File -path $remote_dest -WhatIf:$check_mode
    }

    Copy-Item -LiteralPath $src -Destination $remote_dest -Force | Out-Null
    $result.changed = $true
#!powershell

# Copyright: (c) 2018, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy

Function Get-CustomFacts {
  [cmdletBinding()]
  param (
    [Parameter(mandatory=$false)]
    $factpath = $null
  )

  if (Test-Path -Path $factpath) {
    $FactsFiles = Get-ChildItem -Path $factpath | Where-Object -FilterScript {($PSItem.PSIsContainer -eq $false) -and ($PSItem.Extension -eq '.ps1')}

    foreach ($FactsFile in $FactsFiles) {
        $out = & $($FactsFile.FullName)
        $result.ansible_facts.Add("ansible_$(($FactsFile.Name).Split('.')[0])", $out)
    }
  }
  else
  {
        Add-Warning $result "Non existing path was set for local facts - $factpath"
  }
}

Function Get-MachineSid {
    # The Machine SID is stored in HKLM:\SECURITY\SAM\Domains\Account and is
    # only accessible by the Local System account. This method get's the local
    # admin account (ends with -500) and lops it off to get the machine sid.

    $machine_sid = $null

    try {
        $admins_sid = "S-1-5-32-544"
    $admin_group = ([Security.Principal.SecurityIdentifier]$admins_sid).Translate([Security.Principal.NTAccount]).Value

        Add-Type -AssemblyName System.DirectoryServices.AccountManagement
        $principal_context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine)
        $group_principal = New-Object -TypeName System.DirectoryServices.AccountManagement.GroupPrincipal($principal_context, $admin_group)
        $searcher = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalSearcher($group_principal)
        $groups = $searcher.FindOne()

        foreach ($user in $groups.Members) {
            $user_sid = $user.Sid
            if ($user_sid.Value.EndsWith("-500")) {
                $machine_sid = $user_sid.AccountDomainSid.Value
                break
            }
        }
    } catch {
        #can fail for any number of reasons, if it does just return the original null
        Add-Warning -obj $result -message "Error during machine sid retrieval: $($_.Exception.Message)"
    }

    return $machine_sid
}

$cim_instances = @{}

Function Get-LazyCimInstance([string]$instance_name, [string]$namespace="Root\CIMV2") {
    if(-not $cim_instances.ContainsKey($instance_name)) {
        $cim_instances[$instance_name] = $(Get-CimInstance -Namespace $namespace -ClassName $instance_name)
    }

    return $cim_instances[$instance_name]
}

$result = @{
    ansible_facts = @{ }
    changed = $false
}

$grouped_subsets = @{
    min=[System.Collections.Generic.List[string]]@('date_time','distribution','dns','env','local','platform','powershell_version','user')
    network=[System.Collections.Generic.List[string]]@('all_ipv4_addresses','all_ipv6_addresses','interfaces','windows_domain', 'winrm')
    hardware=[System.Collections.Generic.List[string]]@('bios','memory','processor','uptime','virtual')
    external=[System.Collections.Generic.List[string]]@('facter')
}

# build "all" set from everything mentioned in the group- this means every value must be in at least one subset to be considered legal
$all_set = [System.Collections.Generic.HashSet[string]]@()

foreach($kv in $grouped_subsets.GetEnumerator()) {
    [void] $all_set.UnionWith($kv.Value)
}

# dynamically create an "all" subset now that we know what should be in it
$grouped_subsets['all'] = [System.Collections.Generic.List[string]]$all_set

# start with all, build up gather and exclude subsets
$gather_subset = [System.Collections.Generic.HashSet[string]]$grouped_subsets.all
$explicit_subset = [System.Collections.Generic.HashSet[string]]@()
$exclude_subset = [System.Collections.Generic.HashSet[string]]@()

$params = Parse-Args $args -supports_check_mode $true
$factpath = Get-AnsibleParam -obj $params -name "fact_path" -type "path"
$gather_subset_source = Get-AnsibleParam -obj $params -name "gather_subset" -type "list" -default "all"

foreach($item in $gather_subset_source) {
    if(([string]$item).StartsWith("!")) {
        $item = ([string]$item).Substring(1)
        if($item -eq "all") {
            $all_minus_min = [System.Collections.Generic.HashSet[string]]@($all_set)
            [void] $all_minus_min.ExceptWith($grouped_subsets.min)
            [void] $exclude_subset.UnionWith($all_minus_min)
        }
        elseif($grouped_subsets.ContainsKey($item)) {
            [void] $exclude_subset.UnionWith($grouped_subsets[$item])
        }
        elseif($all_set.Contains($item)) {
            [void] $exclude_subset.Add($item)
        }
        # NB: invalid exclude values are ignored, since that's what posix setup does
    }
    else {
        if($grouped_subsets.ContainsKey($item)) {
            [void] $explicit_subset.UnionWith($grouped_subsets[$item])
        }
        elseif($all_set.Contains($item)) {
            [void] $explicit_subset.Add($item)
        }
        else {
            # NB: POSIX setup fails on invalid value; we warn, because we don't implement the same set as POSIX
            # and we don't have platform-specific config for this...
            Add-Warning $result "invalid value $item specified in gather_subset"
        }
    }
}

[void] $gather_subset.ExceptWith($exclude_subset)
[void] $gather_subset.UnionWith($explicit_subset)

$ansible_facts = @{
    gather_subset=@($gather_subset_source)
    module_setup=$true
}

$osversion = [Environment]::OSVersion

if ($osversion.Version -lt [version]"6.2") {
    # Server 2008, 2008 R2, and Windows 7 are not tested in CI and we want to let customers know about it before
    # removing support altogether.
    $version_string = "{0}.{1}" -f ($osversion.Version.Major, $osversion.Version.Minor)
    $msg = "Windows version '$version_string' will no longer be supported or tested in the next Ansible release"
    Add-DeprecationWarning -obj $result -message $msg -version "2.11"
}

if($gather_subset.Contains('all_ipv4_addresses') -or $gather_subset.Contains('all_ipv6_addresses')) {
    $netcfg = Get-LazyCimInstance Win32_NetworkAdapterConfiguration

    # TODO: split v4/v6 properly, return in separate keys
    $ips = @()
    Foreach ($ip in $netcfg.IPAddress) {
        If ($ip) {
            $ips += $ip
        }
    }

    $ansible_facts += @{
        ansible_ip_addresses = $ips
    }
}

if($gather_subset.Contains('bios')) {
    $win32_bios = Get-LazyCimInstance Win32_Bios
    $win32_cs = Get-LazyCimInstance Win32_ComputerSystem
    $ansible_facts += @{
        ansible_bios_date = $win32_bios.ReleaseDate.ToString("MM/dd/yyyy")
        ansible_bios_version = $win32_bios.SMBIOSBIOSVersion
        ansible_product_name = $win32_cs.Model.Trim()
        ansible_product_serial = $win32_bios.SerialNumber
        # ansible_product_version = ([string] $win32_cs.SystemFamily)
    }
}

if($gather_subset.Contains('date_time')) {
    $datetime = (Get-Date)
    $datetime_utc = $datetime.ToUniversalTime()
    $date = @{
        date = $datetime.ToString("yyyy-MM-dd")
        day = $datetime.ToString("dd")
        epoch = (Get-Date -UFormat "%s")
        hour = $datetime.ToString("HH")
        iso8601 = $datetime_utc.ToString("yyyy-MM-ddTHH:mm:ssZ")
        iso8601_basic = $datetime.ToString("yyyyMMddTHHmmssffffff")
        iso8601_basic_short = $datetime.ToString("yyyyMMddTHHmmss")
        iso8601_micro = $datetime_utc.ToString("yyyy-MM-ddTHH:mm:ss.ffffffZ")
        minute = $datetime.ToString("mm")
        month = $datetime.ToString("MM")
        second = $datetime.ToString("ss")
        time = $datetime.ToString("HH:mm:ss")
        tz = ([System.TimeZoneInfo]::Local.Id)
        tz_offset = $datetime.ToString("zzzz")
        # Ensure that the weekday is in English
        weekday = $datetime.ToString("dddd", [System.Globalization.CultureInfo]::InvariantCulture)
        weekday_number = (Get-Date -UFormat "%w")
        weeknumber = (Get-Date -UFormat "%W")
        year = $datetime.ToString("yyyy")
    }

    $ansible_facts += @{
        ansible_date_time = $date
    }
}

if($gather_subset.Contains('distribution')) {
    $win32_os = Get-LazyCimInstance Win32_OperatingSystem
    $product_type = switch($win32_os.ProductType) {
        1 { "workstation" }
        2 { "domain_controller" }
        3 { "server" }
        default { "unknown" }
    }

    $installation_type = $null
    $current_version_path = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
    if (Test-Path -LiteralPath $current_version_path) {
        $install_type_prop = Get-ItemProperty -LiteralPath $current_version_path -ErrorAction SilentlyContinue
        $installation_type = [String]$install_type_prop.InstallationType
    }

    $ansible_facts += @{
        ansible_distribution = $win32_os.Caption
        ansible_distribution_version = $osversion.Version.ToString()
        ansible_distribution_major_version = $osversion.Version.Major.ToString()
        ansible_os_family = "Windows"
        ansible_os_name = ($win32_os.Name.Split('|')[0]).Trim()
        ansible_os_product_type = $product_type
        ansible_os_installation_type = $installation_type
    }
}

if($gather_subset.Contains('env')) {
    $env_vars = @{ }
    foreach ($item in Get-ChildItem Env:) {
        $name = $item | Select-Object -ExpandProperty Name
        # Powershell ConvertTo-Json fails if string ends with \
        $value = ($item | Select-Object -ExpandProperty Value).TrimEnd("\")
        $env_vars.Add($name, $value)
    }

    $ansible_facts += @{
        ansible_env = $env_vars
    }
}

if($gather_subset.Contains('facter')) {
    # See if Facter is on the System Path
    Try {
        Get-Command facter -ErrorAction Stop > $null
        $facter_installed = $true
    } Catch {
        $facter_installed = $false
    }

    # Get JSON from Facter, and parse it out.
    if ($facter_installed) {
        &facter -j | Tee-Object  -Variable facter_output > $null
        $facts = "$facter_output" | ConvertFrom-Json
        ForEach($fact in $facts.PSObject.Properties) {
            $fact_name = $fact.Name
            $ansible_facts.Add("facter_$fact_name", $fact.Value)
        }
    }
}

if($gather_subset.Contains('interfaces')) {
    $netcfg = Get-LazyCimInstance Win32_NetworkAdapterConfiguration
    $ActiveNetcfg = @()
    $ActiveNetcfg += $netcfg | Where-Object {$_.ipaddress -ne $null}

    $namespaces = Get-LazyCimInstance __Namespace -namespace root
    if ($namespaces | Where-Object { $_.Name -eq "StandardCimv" }) {
        $net_adapters = Get-LazyCimInstance MSFT_NetAdapter -namespace Root\StandardCimv2
        $guid_key = "InterfaceGUID"
        $name_key = "Name"
    } else {
        $net_adapters = Get-LazyCimInstance Win32_NetworkAdapter
        $guid_key = "GUID"
        $name_key = "NetConnectionID"
    }

    $formattednetcfg = @()
    foreach ($adapter in $ActiveNetcfg)
    {
        $thisadapter = @{
            default_gateway = $null
            connection_name = $null
            dns_domain = $adapter.dnsdomain
            interface_index = $adapter.InterfaceIndex
            interface_name = $adapter.description
            macaddress = $adapter.macaddress
        }

        if ($adapter.defaultIPGateway)
        {
            $thisadapter.default_gateway = $adapter.DefaultIPGateway[0].ToString()
        }
        $net_adapter = $net_adapters | Where-Object { $_.$guid_key -eq $adapter.SettingID }
        if ($net_adapter) {
            $thisadapter.connection_name = $net_adapter.$name_key
        }

        $formattednetcfg += $thisadapter
    }

    $ansible_facts += @{
        ansible_interfaces = $formattednetcfg
    }
}

if ($gather_subset.Contains("local") -and $null -ne $factpath) {
    # Get any custom facts; results are updated in the
    Get-CustomFacts -factpath $factpath
}

if($gather_subset.Contains('memory')) {
    $win32_cs = Get-LazyCimInstance Win32_ComputerSystem
    $win32_os = Get-LazyCimInstance Win32_OperatingSystem
    $ansible_facts += @{
        # Win32_PhysicalMemory is empty on some virtual platforms
        ansible_memtotal_mb = ([math]::ceiling($win32_cs.TotalPhysicalMemory / 1024 / 1024))
        ansible_memfree_mb = ([math]::ceiling($win32_os.FreePhysicalMemory / 1024))
        ansible_swaptotal_mb = ([math]::round($win32_os.TotalSwapSpaceSize / 1024))
        ansible_pagefiletotal_mb = ([math]::round($win32_os.SizeStoredInPagingFiles / 1024))
        ansible_pagefilefree_mb = ([math]::round($win32_os.FreeSpaceInPagingFiles / 1024))
    }
}


if($gather_subset.Contains('platform')) {
    $win32_cs = Get-LazyCimInstance Win32_ComputerSystem
    $win32_os = Get-LazyCimInstance Win32_OperatingSystem
    $domain_suffix = $win32_cs.Domain.Substring($win32_cs.Workgroup.length)
    $fqdn = $win32_cs.DNSHostname

    if( $domain_suffix -ne "")
    {
        $fqdn = $win32_cs.DNSHostname + "." + $domain_suffix
    }

    try {
        $ansible_reboot_pending = Get-PendingRebootStatus
    } catch {
        # fails for non-admin users, set to null in this case
        $ansible_reboot_pending = $null
    }

    $ansible_facts += @{
        ansible_architecture = $win32_os.OSArchitecture
        ansible_domain = $domain_suffix
        ansible_fqdn = $fqdn
        ansible_hostname = $win32_cs.DNSHostname
        ansible_netbios_name = $win32_cs.Name
        ansible_kernel = $osversion.Version.ToString()
        ansible_nodename = $fqdn
        ansible_machine_id = Get-MachineSid
        ansible_owner_contact = ([string] $win32_cs.PrimaryOwnerContact)
        ansible_owner_name = ([string] $win32_cs.PrimaryOwnerName)
        # FUTURE: should this live in its own subset?
        ansible_reboot_pending = $ansible_reboot_pending
        ansible_system = $osversion.Platform.ToString()
        ansible_system_description = ([string] $win32_os.Description)
        ansible_system_vendor = $win32_cs.Manufacturer
    }
}

if($gather_subset.Contains('powershell_version')) {
    $ansible_facts += @{
        ansible_powershell_version = ($PSVersionTable.PSVersion.Major)
    }
}

if($gather_subset.Contains('processor')) {
    $win32_cs = Get-LazyCimInstance Win32_ComputerSystem
    $win32_cpu = Get-LazyCimInstance Win32_Processor
    if ($win32_cpu -is [array]) {
        # multi-socket, pick first
        $win32_cpu = $win32_cpu[0]
    }

    $cpu_list = @( )
    for ($i=1; $i -le $win32_cs.NumberOfLogicalProcessors; $i++) {
        $cpu_list += $win32_cpu.Manufacturer
        $cpu_list += $win32_cpu.Name
    }

    $ansible_facts += @{
        ansible_processor = $cpu_list
        ansible_processor_cores = $win32_cpu.NumberOfCores
        ansible_processor_count = $win32_cs.NumberOfProcessors
        ansible_processor_threads_per_core = ($win32_cpu.NumberOfLogicalProcessors / $win32_cpu.NumberofCores)
        ansible_processor_vcpus = $win32_cs.NumberOfLogicalProcessors
    }
}

if($gather_subset.Contains('uptime')) {
    $win32_os = Get-LazyCimInstance Win32_OperatingSystem
    $ansible_facts += @{
        ansible_lastboot = $win32_os.lastbootuptime.ToString("u")
        ansible_uptime_seconds = $([System.Convert]::ToInt64($(Get-Date).Subtract($win32_os.lastbootuptime).TotalSeconds))
    }
}

if($gather_subset.Contains('user')) {
    $user = [Security.Principal.WindowsIdentity]::GetCurrent()
    $ansible_facts += @{
        ansible_user_dir = $env:userprofile
        # Win32_UserAccount.FullName is probably the right thing here, but it can be expensive to get on large domains
        ansible_user_gecos = ""
        ansible_user_id = $env:username
        ansible_user_sid = $user.User.Value
    }
}

if($gather_subset.Contains('windows_domain')) {
    $win32_cs = Get-LazyCimInstance Win32_ComputerSystem
    $domain_roles = @{
        0 = "Stand-alone workstation"
        1 = "Member workstation"
        2 = "Stand-alone server"
        3 = "Member server"
        4 = "Backup domain controller"
        5 = "Primary domain controller"
    }

    $domain_role = $domain_roles.Get_Item([Int32]$win32_cs.DomainRole)

    $ansible_facts += @{
        ansible_windows_domain = $win32_cs.Domain
        ansible_windows_domain_member = $win32_cs.PartOfDomain
        ansible_windows_domain_role = $domain_role
    }
}

if($gather_subset.Contains('winrm')) {

    $winrm_https_listener_parent_paths = Get-ChildItem -Path WSMan:\localhost\Listener -Recurse -ErrorAction SilentlyContinue | `
        Where-Object {$_.PSChildName -eq "Transport" -and $_.Value -eq "HTTPS"} | Select-Object PSParentPath
    if ($winrm_https_listener_parent_paths -isnot [array]) {
       $winrm_https_listener_parent_paths = @($winrm_https_listener_parent_paths)
    }

    $winrm_https_listener_paths = @()
    foreach ($winrm_https_listener_parent_path in $winrm_https_listener_parent_paths) {
        $winrm_https_listener_paths += $winrm_https_listener_parent_path.PSParentPath.Substring($winrm_https_listener_parent_path.PSParentPath.LastIndexOf("\"))
    }

    $https_listeners = @()
    foreach ($winrm_https_listener_path in $winrm_https_listener_paths) {
        $https_listeners += Get-ChildItem -Path "WSMan:\localhost\Listener$winrm_https_listener_path"
    }

    $winrm_cert_thumbprints = @()
    foreach ($https_listener in $https_listeners) {
        $winrm_cert_thumbprints += $https_listener | Where-Object {$_.Name -EQ "CertificateThumbprint" } | Select-Object Value
    }

    $winrm_cert_expiry = @()
    foreach ($winrm_cert_thumbprint in $winrm_cert_thumbprints) {
        Try {
            $winrm_cert_expiry += Get-ChildItem -Path Cert:\LocalMachine\My | Where-Object Thumbprint -EQ $winrm_cert_thumbprint.Value.ToString().ToUpper() | Select-Object NotAfter
        } Catch {
            Add-Warning -obj $result -message "Error during certificate expiration retrieval: $($_.Exception.Message)"
        }
    }

    $winrm_cert_expirations = $winrm_cert_expiry | Sort-Object NotAfter
    if ($winrm_cert_expirations) {
        # this fact was renamed from ansible_winrm_certificate_expires due to collision with ansible_winrm_X connection var pattern
        $ansible_facts.Add("ansible_win_rm_certificate_expires", $winrm_cert_expirations[0].NotAfter.ToString("yyyy-MM-dd HH:mm:ss"))
    }
}

if($gather_subset.Contains('virtual')) {
    $machine_info = Get-LazyCimInstance Win32_ComputerSystem

    switch ($machine_info.model) {
        "Virtual Machine" {
            $machine_type="Hyper-V"
            $machine_role="guest"
        }

        "VMware Virtual Platform" {
            $machine_type="VMware"
            $machine_role="guest"
        }

        "VirtualBox" {
            $machine_type="VirtualBox"
            $machine_role="guest"
        }

        "HVM domU" {
            $machine_type="Xen"
            $machine_role="guest"
        }

        default {
            $machine_type="NA"
            $machine_role="NA"
        }
    }

    $ansible_facts += @{
        ansible_virtualization_role = $machine_role
        ansible_virtualization_type = $machine_type
    }
}

$result.ansible_facts += $ansible_facts

#!powershell

# Copyright: 2019, rnsc(@rnsc) <github@rnsc.be>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -OSVersion 6.3

$spec = @{
    options = @{
        drive_letter = @{ type = "str"; required = $true }
        state = @{ type = "str"; choices = "absent", "present"; default = "present"; }
        settings = @{
            type = "dict"
            required = $false
            options = @{
                minimum_file_size = @{ type = "int"; default = 32768 }
                minimum_file_age_days = @{ type = "int"; default = 2 }
                no_compress = @{ type = "bool"; required = $false; default = $false }
                optimize_in_use_files = @{ type = "bool"; required = $false; default = $false }
                verify = @{ type = "bool"; required = $false; default = $false }
            }
        }
    }
    supports_check_mode = $true
}

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

$drive_letter = $module.Params.drive_letter
$state = $module.Params.state
$settings = $module.Params.settings

$module.Result.changed = $false
$module.Result.reboot_required = $false
$module.Result.msg = ""

function Set-DataDeduplication($volume, $state, $settings, $dedup_job) {

  $current_state = 'absent'

  try {
    $dedup_info = Get-DedupVolume -Volume "$($volume.DriveLetter):"
  } catch {
    $dedup_info = $null
  }

  if ($dedup_info.Enabled) {
    $current_state = 'present'
  }

  if ( $state -ne $current_state ) {
    if( -not $module.CheckMode) {
      if($state -eq 'present') {
        # Enable-DedupVolume -Volume <String>
        Enable-DedupVolume -Volume "$($volume.DriveLetter):"
      } elseif ($state -eq 'absent') {
        Disable-DedupVolume -Volume "$($volume.DriveLetter):"
      }
    }
    $module.Result.changed = $true
  }

  if ($state -eq 'present') {
    if ($null -ne $settings) {
      Set-DataDedupJobSettings -volume $volume -settings $settings
    }
  }
}

function Set-DataDedupJobSettings ($volume, $settings) {

  try {
    $dedup_info = Get-DedupVolume -Volume "$($volume.DriveLetter):"
  } catch {
    $dedup_info = $null
  }

  ForEach ($key in $settings.keys) {

    # See Microsoft documentation:
    # https://docs.microsoft.com/en-us/powershell/module/deduplication/set-dedupvolume?view=win10-ps

    $update_key = $key
    $update_value = $settings.$($key)
    # Transform Ansible style options to Powershell params
    $update_key = $update_key -replace('_', '')

    if ($update_key -eq "MinimumFileSize" -and $update_value -lt 32768) {
      $update_value = 32768
    }

    $current_value = ($dedup_info | Select-Object -ExpandProperty $update_key)

    if ($update_value -ne $current_value) {
      $command_param = @{
        $($update_key) = $update_value
      }

      # Set-DedupVolume -Volume <String>`
      #                 -NoCompress <bool> `
      #                 -MinimumFileAgeDays <UInt32> `
      #                 -MinimumFileSize <UInt32> (minimum 32768)
      if( -not $module.CheckMode ) {
        Set-DedupVolume -Volume "$($volume.DriveLetter):" @command_param
      }

      $module.Result.changed = $true
    }
  }

}

# Install required feature
$feature_name = "FS-Data-Deduplication"
if( -not $module.CheckMode) {
  $feature = Install-WindowsFeature -Name $feature_name

  if ($feature.RestartNeeded -eq 'Yes') {
    $module.Result.reboot_required = $true
    $module.FailJson("$feature_name was installed but requires Windows to be rebooted to work.")
  }
}

$volume = Get-Volume -DriveLetter $drive_letter
#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.CommandUtil
#Requires -Module Ansible.ModuleUtils.FileUtil

# TODO: add check mode support

Set-StrictMode -Version 2
$ErrorActionPreference = "Stop"

# Cleanse CLIXML from stderr (sift out error stream data, discard others for now)
Function Cleanse-Stderr($raw_stderr) {
    Try {
        # NB: this regex isn't perfect, but is decent at finding CLIXML amongst other stderr noise
        If($raw_stderr -match "(?s)(?<prenoise1>.*)#< CLIXML(?<prenoise2>.*)(?<clixml><Objs.+</Objs>)(?<postnoise>.*)") {
            $clixml = [xml]$matches["clixml"]

            $merged_stderr = "{0}{1}{2}{3}" -f @(
               $matches["prenoise1"],
               $matches["prenoise2"],
               # filter out just the Error-tagged strings for now, and zap embedded CRLF chars
               ($clixml.Objs.ChildNodes | Where-Object  { $_.Name -eq 'S' } | Where-Object { $_.S -eq 'Error' } | ForEach-Object { $_.'#text'.Replace('_x000D__x000A_','') } | Out-String),
               $matches["postnoise"]) | Out-String

            return $merged_stderr.Trim()

            # FUTURE: parse/return other streams
        }
        Else {
            $raw_stderr
        }
    }
    Catch {
        "***EXCEPTION PARSING CLIXML: $_***" + $raw_stderr
    }
}

$params = Parse-Args $args -supports_check_mode $false

$raw_command_line = Get-AnsibleParam -obj $params -name "_raw_params" -type "str" -failifempty $true
$chdir = Get-AnsibleParam -obj $params -name "chdir" -type "path"
$executable = Get-AnsibleParam -obj $params -name "executable" -type "path"
$creates = Get-AnsibleParam -obj $params -name "creates" -type "path"
$removes = Get-AnsibleParam -obj $params -name "removes" -type "path"
$stdin = Get-AnsibleParam -obj $params -name "stdin" -type "str"
$no_profile = Get-AnsibleParam -obj $params -name "no_profile" -type "bool" -default $false
$output_encoding_override = Get-AnsibleParam -obj $params -name "output_encoding_override" -type "str"

$raw_command_line = $raw_command_line.Trim()

$result = @{
    changed = $true
    cmd = $raw_command_line
}

if ($creates -and $(Test-AnsiblePath -Path $creates)) {
    Exit-Json @{msg="skipped, since $creates exists";cmd=$raw_command_line;changed=$false;skipped=$true;rc=0}
}

if ($removes -and -not $(Test-AnsiblePath -Path $removes)) {
    Exit-Json @{msg="skipped, since $removes does not exist";cmd=$raw_command_line;changed=$false;skipped=$true;rc=0}
}

$exec_args = $null
If(-not $executable -or $executable -eq "powershell") {
    $exec_application = "powershell.exe"

    # force input encoding to preamble-free UTF8 so PS sub-processes (eg, Start-Job) don't blow up
    $raw_command_line = "[Console]::InputEncoding = New-Object Text.UTF8Encoding `$false; " + $raw_command_line

    # Base64 encode the command so we don't have to worry about the various levels of escaping
    $encoded_command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($raw_command_line))

    if ($stdin) {
        $exec_args = "-encodedcommand $encoded_command"
    } else {
        $exec_args = "-noninteractive -encodedcommand $encoded_command"
    }

    if ($no_profile) {
        $exec_args = "-noprofile $exec_args"
    }
}
Else {
    # FUTURE: support arg translation from executable (or executable_args?) to process arguments for arbitrary interpreter?
    $exec_application = $executable
    if (-not ($exec_application.EndsWith(".exe"))) {
        $exec_application = "$($exec_application).exe"
    }
    $exec_args = "/c $raw_command_line"
}

$command = "`"$exec_application`" $exec_args"
$run_command_arg = @{
    command = $command
}
if ($chdir) {
    $run_command_arg['working_directory'] = $chdir
}
if ($stdin) {
    $run_command_arg['stdin'] = $stdin
}
if ($output_encoding_override) {
    $run_command_arg['output_encoding_override'] = $output_encoding_override
}

$start_datetime = [DateTime]::UtcNow
try {
    $command_result = Run-Command @run_command_arg
} catch {
    $result.changed = $false
    try {
        $result.rc = $_.Exception.NativeErrorCode
    } catch {
        $result.rc = 2
    }
    Fail-Json -obj $result -message $_.Exception.Message
}

# TODO: decode CLIXML stderr output (and other streams?)
$result.stdout = $command_result.stdout
$result.stderr = Cleanse-Stderr $command_result.stderr
$result.rc = $command_result.rc

$end_datetime = [DateTime]::UtcNow
$result.start = $start_datetime.ToString("yyyy-MM-dd hh:mm:ss.ffffff")
$result.end = $end_datetime.ToString("yyyy-MM-dd hh:mm:ss.ffffff")
$result.delta = $($end_datetime - $start_datetime).ToString("h\:mm\:ss\.ffffff")

If ($result.rc -ne 0) {
    Fail-Json -obj $result -message "non-zero return code"
#!powershell

# Copyright: (c) 2016, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#Requires -Module Ansible.ModuleUtils.LinkUtil

$spec = @{
    options = @{
        paths = @{ type = "list"; elements = "str"; required = $true }
        age = @{ type = "str" }
        age_stamp = @{ type = "str"; default = "mtime"; choices = "mtime", "ctime", "atime" }
        file_type = @{ type = "str"; default = "file"; choices = "file", "directory" }
        follow = @{ type = "bool"; default = $false }
        hidden = @{ type = "bool"; default = $false }
        patterns = @{ type = "list"; elements = "str"; aliases = "regex", "regexp" }
        recurse = @{ type = "bool"; default = $false }
        size = @{ type = "str" }
        use_regex = @{ type = "bool"; default = $false }
        get_checksum = @{ type = "bool"; default = $true }
        checksum_algorithm = @{ type = "str"; default = "sha1"; choices = "md5", "sha1", "sha256", "sha384", "sha512" }
    }
    supports_check_mode = $true
}

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

$paths = $module.Params.paths
$age = $module.Params.age
$age_stamp = $module.Params.age_stamp
$file_type = $module.Params.file_type
$follow = $module.Params.follow
$hidden = $module.Params.hidden
$patterns = $module.Params.patterns
$recurse = $module.Params.recurse
$size = $module.Params.size
$use_regex = $module.Params.use_regex
$get_checksum = $module.Params.get_checksum
$checksum_algorithm = $module.Params.checksum_algorithm

$module.Result.examined = 0
$module.Result.files = @()
$module.Result.matched = 0

Load-LinkUtils

Function Assert-Age {
    Param (
        [System.IO.FileSystemInfo]$File,
        [System.Int64]$Age,
        [System.String]$AgeStamp
    )

    $actual_age = switch ($AgeStamp) {
        mtime { $File.LastWriteTime.Ticks }
        ctime { $File.CreationTime.Ticks }
        atime { $File.LastAccessTime.Ticks }
    }

    if ($Age -ge 0) {
        return $Age -ge $actual_age
    } else {
        return ($Age * -1) -le $actual_age
    }
}

Function Assert-FileType {
    Param (
        [System.IO.FileSystemInfo]$File,
        [System.String]$FileType
    )

    $is_dir = $File.Attributes.HasFlag([System.IO.FileAttributes]::Directory)
    return ($FileType -eq 'directory' -and $is_dir) -or ($FileType -eq 'file' -and -not $is_dir)
}

Function Assert-FileHidden {
    Param (
        [System.IO.FileSystemInfo]$File,
        [Switch]$IsHidden
    )

    $file_is_hidden = $File.Attributes.HasFlag([System.IO.FileAttributes]::Hidden)
    return $IsHidden.IsPresent -eq $file_is_hidden
}


Function Assert-FileNamePattern {
    Param (
        [System.IO.FileSystemInfo]$File,
        [System.String[]]$Patterns,
        [Switch]$UseRegex
    )

    $valid_match = $false
    foreach ($pattern in $Patterns) {
        if ($UseRegex) {
            if ($File.Name -match $pattern) {
                $valid_match = $true
                break
            }
        } else {
            if ($File.Name -like $pattern) {
                $valid_match = $true
                break
            }
        }
    }
    return $valid_match
}

Function Assert-FileSize {
    Param (
        [System.IO.FileSystemInfo]$File,
        [System.Int64]$Size
    )

    if ($Size -ge 0) {
        return $File.Length -ge $Size
    } else {
        return $File.Length -le ($Size * -1)
    }
}

Function Get-FileChecksum {
    Param (
        [System.String]$Path,
        [System.String]$Algorithm
    )

    $sp = switch ($algorithm) {
        'md5' { New-Object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider }
        'sha1' { New-Object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider }
        'sha256' { New-Object -TypeName System.Security.Cryptography.SHA256CryptoServiceProvider }
        'sha384' { New-Object -TypeName System.Security.Cryptography.SHA384CryptoServiceProvider }
        'sha512' { New-Object -TypeName System.Security.Cryptography.SHA512CryptoServiceProvider }
    }

    $fp = [System.IO.File]::Open($Path, [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
    try {
        $hash = [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace("-", "").ToLower()
    } finally {
        $fp.Dispose()
    }

    return $hash
}

Function Search-Path {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory=$true)]
        [System.String]
        $Path,

        [Parameter(Mandatory=$true)]
        [AllowEmptyCollection()]
        [System.Collections.Generic.HashSet`1[System.String]]
        $CheckedPaths,

        [Parameter(Mandatory=$true)]
        [Object]
        $Module,

        [System.Int64]
        $Age,

        [System.String]
        $AgeStamp,

        [System.String]
        $FileType,

        [Switch]
        $Follow,

        [Switch]
        $GetChecksum,

        [Switch]
        $IsHidden,

        [System.String[]]
        $Patterns,

        [Switch]
        $Recurse,

        [System.Int64]
        $Size,

        [Switch]
        $UseRegex
    )

    $dir_obj = New-Object -TypeName System.IO.DirectoryInfo -ArgumentList $Path
    if ([Int32]$dir_obj.Attributes -eq -1) {
        $Module.Warn("Argument path '$Path' does not exist, skipping")
        return
    } elseif (-not $dir_obj.Attributes.HasFlag([System.IO.FileAttributes]::Directory)) {
        $Module.Warn("Argument path '$Path' is a file not a directory, skipping")
        return
    }

    $dir_files = @()
    try {
        $dir_files = $dir_obj.EnumerateFileSystemInfos("*", [System.IO.SearchOption]::TopDirectoryOnly)
    } catch [System.IO.DirectoryNotFoundException] { # Broken ReparsePoint/Symlink, cannot enumerate
    } catch [System.UnauthorizedAccessException] {}  # No ListDirectory permissions, Get-ChildItem ignored this

    foreach ($dir_child in $dir_files) {
        if ($dir_child.Attributes.HasFlag([System.IO.FileAttributes]::Directory) -and $Recurse) {
            if ($Follow -or -not $dir_child.Attributes.HasFlag([System.IO.FileAttributes]::ReparsePoint)) {
                $PSBoundParameters.Remove('Path') > $null
                Search-Path -Path $dir_child.FullName @PSBoundParameters
            }
        }

        # Check to see if we've already encountered this path and skip if we have.
        if (-not $CheckedPaths.Add($dir_child.FullName.ToLowerInvariant())) {
            continue
        }

        $Module.Result.examined++

        if ($PSBoundParameters.ContainsKey('Age')) {
            $age_match = Assert-Age -File $dir_child -Age $Age -AgeStamp $AgeStamp
        } else {
            $age_match = $true
        }

        $file_type_match = Assert-FileType -File $dir_child -FileType $FileType
        $hidden_match = Assert-FileHidden -File $dir_child -IsHidden:$IsHidden

        if ($PSBoundParameters.ContainsKey('Patterns')) {
            $pattern_match = Assert-FileNamePattern -File $dir_child -Patterns $Patterns -UseRegex:$UseRegex.IsPresent
        } else {
            $pattern_match = $true
        }

        if ($PSBoundParameters.ContainsKey('Size')) {
            $size_match = Assert-FileSize -File $dir_child -Size $Size
        } else {
            $size_match = $true
        }

        if (-not ($age_match -and $file_type_match -and $hidden_match -and $pattern_match -and $size_match)) {
            continue
        }

        # It passed all our filters so add it
        $module.Result.matched++

        # TODO: Make this generic so it can be shared with win_find and win_stat.
        $epoch = New-Object -Type System.DateTime -ArgumentList 1970, 1, 1, 0, 0, 0, 0
        $file_info = @{
            attributes = $dir_child.Attributes.ToString()
            checksum = $null
            creationtime = (New-TimeSpan -Start $epoch -End $dir_child.CreationTime).TotalSeconds
            exists = $true
            extension = $null
            filename = $dir_child.Name
            isarchive = $dir_child.Attributes.HasFlag([System.IO.FileAttributes]::Archive)
            isdir = $dir_child.Attributes.HasFlag([System.IO.FileAttributes]::Directory)
            ishidden = $dir_child.Attributes.HasFlag([System.IO.FileAttributes]::Hidden)
            isreadonly = $dir_child.Attributes.HasFlag([System.IO.FileAttributes]::ReadOnly)
            isreg = $false
            isshared = $false
            lastaccesstime = (New-TimeSpan -Start $epoch -End $dir_child.LastAccessTime).TotalSeconds
            lastwritetime = (New-TimeSpan -Start $epoch -End $dir_child.LastWriteTime).TotalSeconds
            owner = $null
            path = $dir_child.FullName
            sharename = $null
            size = $null
        }

        try {
            $file_info.owner = $dir_child.GetAccessControl().Owner
        } catch {}  # May not have rights to get the Owner, historical behaviour is to ignore.

        if ($dir_child.Attributes.HasFlag([System.IO.FileAttributes]::Directory)) {
            $share_info = Get-CimInstance -ClassName Win32_Share -Filter "Path='$($dir_child.FullName -replace '\\', '\\')'"
            if ($null -ne $share_info) {
                $file_info.isshared = $true
                $file_info.sharename = $share_info.Name
            }
        } else {
            $file_info.extension = $dir_child.Extension
            $file_info.isreg = $true
            $file_info.size = $dir_child.Length

            if ($GetChecksum) {
                try {
                    $file_info.checksum = Get-FileChecksum -Path $dir_child.FullName -Algorithm $checksum_algorithm
                } catch {}  # Just keep the checksum as $null in the case of a failure.
            }
        }

        # Append the link information if the path is a link
        $link_info = @{
            isjunction = $false
            islnk = $false
            nlink = 1
            lnk_source = $null
            lnk_target = $null
            hlnk_targets = @()
        }
        $link_stat = Get-Link -link_path $dir_child.FullName
        if ($null -ne $link_stat) {
            switch ($link_stat.Type) {
                "SymbolicLink" {
                    $link_info.islnk = $true
                    $link_info.isreg = $false
                    $link_info.lnk_source = $link_stat.AbsolutePath
                    $link_info.lnk_target = $link_stat.TargetPath
                    break
                }
                "JunctionPoint" {
                    $link_info.isjunction = $true
                    $link_info.isreg = $false
                    $link_info.lnk_source = $link_stat.AbsolutePath
                    $link_info.lnk_target = $link_stat.TargetPath
                    break
                }
                "HardLink" {
                    $link_info.nlink = $link_stat.HardTargets.Count

                    # remove current path from the targets
                    $hlnk_targets = $link_info.HardTargets | Where-Object { $_ -ne $dir_child.FullName }
                    $link_info.hlnk_targets = @($hlnk_targets)
                    break
                }
            }
        }
        foreach ($kv in $link_info.GetEnumerator()) {
            $file_info.$($kv.Key) = $kv.Value
        }

        # Output the file_info object
        $file_info
    }
}

$search_params = @{
    CheckedPaths = [System.Collections.Generic.HashSet`1[System.String]]@()
    GetChecksum = $get_checksum
    Module = $module
    FileType = $file_type
    Follow = $follow
    IsHidden = $hidden
    Recurse = $recurse
}

if ($null -ne $age) {
    $seconds_per_unit = @{'s'=1; 'm'=60; 'h'=3600; 'd'=86400; 'w'=604800}
    $seconds_pattern = '^(-?\d+)(s|m|h|d|w)?$'
    $match = $age -match $seconds_pattern
    if ($Match) {
        $specified_seconds = [Int64]$Matches[1]
        if ($null -eq $Matches[2]) {
            $chosen_unit = 's'
        } else {
            $chosen_unit = $Matches[2]
        }

        $total_seconds = $specified_seconds * ($seconds_per_unit.$chosen_unit)

        if ($total_seconds -ge 0) {
            $search_params.Age = (Get-Date).AddSeconds($total_seconds * -1).Ticks
        } else {
            # Make sure we add the positive value of seconds to current time then make it negative for later comparisons.
            $age = (Get-Date).AddSeconds($total_seconds).Ticks
            $search_params.Age = $age * -1
        }
        $search_params.AgeStamp = $age_stamp
    } else {
        $module.FailJson("Invalid age pattern specified")
    }
}

if ($null -ne $patterns) {
    $search_params.Patterns = $patterns
    $search_params.UseRegex = $use_regex
}

if ($null -ne $size) {
    $bytes_per_unit = @{'b'=1; 'k'=1KB; 'm'=1MB; 'g'=1GB;'t'=1TB}
    $size_pattern = '^(-?\d+)(b|k|m|g|t)?$'
    $match = $size -match $size_pattern
    if ($Match) {
        $specified_size = [Int64]$Matches[1]
        if ($null -eq $Matches[2]) {
            $chosen_byte = 'b'
        } else {
            $chosen_byte = $Matches[2]
        }

        $search_params.Size = $specified_size * ($bytes_per_unit.$chosen_byte)
    } else {
        $module.FailJson("Invalid size pattern specified")
    }
}

$matched_files = foreach ($path in $paths) {
    # Ensure we pass in an absolute path. We use the ExecutionContext as this is based on the PSProvider path not the
    # process location which can be different.
    $abs_path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($path)
    Search-Path -Path $abs_path @search_params
}

# Make sure we sort the files in alphabetical order.
$module.Result.files = @() + ($matched_files | Sort-Object -Property {$_.path})

$module.ExitJson()
#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.FileUtil

$ErrorActionPreference = "Stop"

$params = Parse-Args -arguments $args -supports_check_mode $true

$connect_timeout = Get-AnsibleParam -obj $params -name "connect_timeout" -type "int" -default 5
$delay = Get-AnsibleParam -obj $params -name "delay" -type "int"
$exclude_hosts = Get-AnsibleParam -obj $params -name "exclude_hosts" -type "list"
$hostname = Get-AnsibleParam -obj $params -name "host" -type "str" -default "127.0.0.1"
$path = Get-AnsibleParam -obj $params -name "path" -type "path"
$port = Get-AnsibleParam -obj $params -name "port" -type "int"
$regex = Get-AnsibleParam -obj $params -name "regex" -type "str" -aliases "search_regex","regexp"
$sleep = Get-AnsibleParam -obj $params -name "sleep" -type "int" -default 1
$state = Get-AnsibleParam -obj $params -name "state" -type "str" -default "started" -validateset "present","started","stopped","absent","drained"
$timeout = Get-AnsibleParam -obj $params -name "timeout" -type "int" -default 300

$result = @{
    changed = $false
    elapsed = 0
}

# validate the input with the various options
if ($null -ne $port -and $null -ne $path) {
    Fail-Json $result "port and path parameter can not both be passed to win_wait_for"
}
if ($null -ne $exclude_hosts -and $state -ne "drained") {
    Fail-Json $result "exclude_hosts should only be with state=drained"
}
if ($null -ne $path) {
    if ($state -in @("stopped","drained")) {
        Fail-Json $result "state=$state should only be used for checking a port in the win_wait_for module"
    }

    if ($null -ne $exclude_hosts) {
        Fail-Json $result "exclude_hosts should only be used when checking a port and state=drained in the win_wait_for module"
    }
}

if ($null -ne $port) {
    if ($null -ne $regex) {
        Fail-Json $result "regex should by used when checking a string in a file in the win_wait_for module"
    }

    if ($null -ne $exclude_hosts -and $state -ne "drained") {
        Fail-Json $result "exclude_hosts should be used when state=drained in the win_wait_for module"
    }
}

Function Test-Port($hostname, $port) {
    $timeout = $connect_timeout * 1000
    $socket = New-Object -TypeName System.Net.Sockets.TcpClient
    $connect = $socket.BeginConnect($hostname, $port, $null, $null)
    $wait = $connect.AsyncWaitHandle.WaitOne($timeout, $false)

    if ($wait) {
        try {
            $socket.EndConnect($connect) | Out-Null
            $valid = $true
        } catch {
            $valid = $false
        }
    } else {
        $valid = $false
    }

    $socket.Close()
    $socket.Dispose()

    $valid
}

Function Get-PortConnections($hostname, $port) {
    $connections = @()

    $conn_info = [Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties()
    if ($hostname -eq "0.0.0.0") {
        $active_connections = $conn_info.GetActiveTcpConnections() | Where-Object { $_.LocalEndPoint.Port -eq $port }
    } else {
        $active_connections = $conn_info.GetActiveTcpConnections() | Where-Object { $_.LocalEndPoint.Address -eq $hostname -and $_.LocalEndPoint.Port -eq $port }
    }

    if ($null -ne $active_connections) {
        foreach ($active_connection in $active_connections) {
            $connections += $active_connection.RemoteEndPoint.Address
        }
    }

    $connections
}

$module_start = Get-Date

if ($null -ne $delay) {
    Start-Sleep -Seconds $delay
}

$attempts = 0
if ($null -eq $path -and $null -eq $port -and $state -ne "drained") {
    Start-Sleep -Seconds $timeout
} elseif ($null -ne $path) {
    if ($state -in @("present", "started")) {
        # check if the file exists or string exists in file
        $start_time = Get-Date
        $complete = $false
        while (((Get-Date) - $start_time).TotalSeconds -lt $timeout) {
            $attempts += 1
            if (Test-AnsiblePath -Path $path) {
                if ($null -eq $regex) {
                    $complete = $true
                    break
                } else {
                    $file_contents = Get-Content -Path $path -Raw
                    if ($file_contents -match $regex) {
                        $complete = $true
                        break
                    }
                }
            }
            Start-Sleep -Seconds $sleep
        }

        if ($complete -eq $false) {
            $result.elapsed = ((Get-Date) - $module_start).TotalSeconds
            $result.wait_attempts = $attempts
            if ($null -eq $regex) {
                Fail-Json $result "timeout while waiting for file $path to be present"
            } else {
                Fail-Json $result "timeout while waiting for string regex $regex in file $path to match"
            }
        }
    } elseif ($state -in @("absent")) {
        # check if the file is deleted or string doesn't exist in file
        $start_time = Get-Date
        $complete = $false
        while (((Get-Date) - $start_time).TotalSeconds -lt $timeout) {
            $attempts += 1
            if (Test-AnsiblePath -Path $path) {
                if ($null -ne $regex) {
                    $file_contents = Get-Content -Path $path -Raw
                    if ($file_contents -notmatch $regex) {
                        $complete = $true
                        break
                    }
                }
            } else {
                $complete = $true
                break
            }

            Start-Sleep -Seconds $sleep
        }

        if ($complete -eq $false) {
            $result.elapsed = ((Get-Date) - $module_start).TotalSeconds
            $result.wait_attempts = $attempts
            if ($null -eq $regex) {
                Fail-Json $result "timeout while waiting for file $path to be absent"
            } else {
                Fail-Json $result "timeout while waiting for string regex $regex in file $path to not match"
            }
        }
    }
} elseif ($null -ne $port) {
    if ($state -in @("started","present")) {
        # check that the port is online and is listening
        $start_time = Get-Date
        $complete = $false
        while (((Get-Date) - $start_time).TotalSeconds -lt $timeout) {
            $attempts += 1
            $port_result = Test-Port -hostname $hostname -port $port
            if ($port_result -eq $true) {
                $complete = $true
                break
            }

            Start-Sleep -Seconds $sleep
        }

        if ($complete -eq $false) {
            $result.elapsed = ((Get-Date) - $module_start).TotalSeconds
            $result.wait_attempts = $attempts
            Fail-Json $result "timeout while waiting for $($hostname):$port to start listening"
        }
    } elseif ($state -in @("stopped","absent")) {
        # check that the port is offline and is not listening
        $start_time = Get-Date
        $complete = $false
        while (((Get-Date) - $start_time).TotalSeconds -lt $timeout) {
            $attempts += 1
            $port_result = Test-Port -hostname $hostname -port $port
            if ($port_result -eq $false) {
                $complete = $true
                break
            }

            Start-Sleep -Seconds $sleep
        }

        if ($complete -eq $false) {
            $result.elapsed = ((Get-Date) - $module_start).TotalSeconds
            $result.wait_attempts = $attempts
            Fail-Json $result "timeout while waiting for $($hostname):$port to stop listening"
        }
    } elseif ($state -eq "drained") {
        # check that the local port is online but has no active connections
        $start_time = Get-Date
        $complete = $false
        while (((Get-Date) - $start_time).TotalSeconds -lt $timeout) {
            $attempts += 1
            $active_connections = Get-PortConnections -hostname $hostname -port $port
            if ($null -eq $active_connections) {
                $complete = $true
                break
            } elseif ($active_connections.Count -eq 0) {
                # no connections on port
                $complete = $true
                break
            } else {
                # there are listeners, check if we should ignore any hosts
                if ($null -ne $exclude_hosts) {
                    $connection_info = $active_connections
                    foreach ($exclude_host in $exclude_hosts) {
                        try {
                            $exclude_ips = [System.Net.Dns]::GetHostAddresses($exclude_host) | ForEach-Object { Write-Output $_.IPAddressToString }
                            $connection_info = $connection_info | Where-Object { $_ -notin $exclude_ips }
                        } catch { # ignore invalid hostnames
                            Add-Warning -obj $result -message "Invalid hostname specified $exclude_host"
                        }
                    }

                    if ($connection_info.Count -eq 0) {
                        $complete = $true
                        break
                    }
                }
            }

            Start-Sleep -Seconds $sleep
        }

        if ($complete -eq $false) {
            $result.elapsed = ((Get-Date) - $module_start).TotalSeconds
            $result.wait_attempts = $attempts
            Fail-Json $result "timeout while waiting for $($hostname):$port to drain"
        }
    }
}

#!powershell

# Copyright: (c) 2019, Varun Chopra (@chopraaa) <v@chopraaa.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#AnsibleRequires -OSVersion 6.2

Set-StrictMode -Version 2

$ErrorActionPreference = "Stop"

$spec = @{
    options = @{
        drive_letter = @{ type = "str" }
        path = @{ type = "str" }
        label = @{ type = "str" }
        new_label = @{ type = "str" }
        file_system = @{ type = "str"; choices = "ntfs", "refs", "exfat", "fat32", "fat" }
        allocation_unit_size = @{ type = "int" }
        large_frs = @{ type = "bool" }
        full = @{ type = "bool"; default = $false }
        compress = @{ type = "bool" }
        integrity_streams = @{ type = "bool" }
        force = @{ type = "bool"; default = $false }
    }
    mutually_exclusive = @(
        ,@('drive_letter', 'path', 'label')
    )
    required_one_of = @(
        ,@('drive_letter', 'path', 'label')
    )
    supports_check_mode = $true
}

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

$drive_letter = $module.Params.drive_letter
$path = $module.Params.path
$label = $module.Params.label
$new_label = $module.Params.new_label
$file_system = $module.Params.file_system
$allocation_unit_size = $module.Params.allocation_unit_size
$large_frs = $module.Params.large_frs
$full_format = $module.Params.full
$compress_volume = $module.Params.compress
$integrity_streams = $module.Params.integrity_streams
$force_format = $module.Params.force

# Some pre-checks
if ($null -ne $drive_letter -and $drive_letter -notmatch "^[a-zA-Z]$") {
    $module.FailJson("The parameter drive_letter should be a single character A-Z")
}
if ($integrity_streams -eq $true -and $file_system -ne "refs") {
    $module.FailJson("Integrity streams can be enabled only on ReFS volumes. You specified: $($file_system)")
}
if ($compress_volume -eq $true) {
    if ($file_system -eq "ntfs") {
        if ($null -ne $allocation_unit_size -and $allocation_unit_size -gt 4096) {
            $module.FailJson("NTFS compression is not supported for allocation unit sizes above 4096")
        }
    }
    else {
        $module.FailJson("Compression can be enabled only on NTFS volumes. You specified: $($file_system)")
    }
}

function Get-AnsibleVolume {
    param(
        $DriveLetter,
        $Path,
        $Label
    )

    if ($null -ne $DriveLetter) {
        try {
            $volume = Get-Volume -DriveLetter $DriveLetter
        } catch {
            $module.FailJson("There was an error retrieving the volume using drive_letter $($DriveLetter): $($_.Exception.Message)", $_)
        }
    }
    elseif ($null -ne $Path) {
        try {
            $volume = Get-Volume -Path $Path
        } catch {
            $module.FailJson("There was an error retrieving the volume using path $($Path): $($_.Exception.Message)", $_)
        }
    }
    elseif ($null -ne $Label) {
        try {
            $volume = Get-Volume -FileSystemLabel $Label
        } catch {
            $module.FailJson("There was an error retrieving the volume using label $($Label): $($_.Exception.Message)", $_)
        }
    }
    else {
        $module.FailJson("Unable to locate volume: drive_letter, path and label were not specified")
    }

    return $volume
}

function Format-AnsibleVolume {
    param(
        $Path,
        $Label,
        $FileSystem,
        $Full,
        $UseLargeFRS,
        $Compress,
        $SetIntegrityStreams,
        $AllocationUnitSize
    )
    $parameters = @{
        Path = $Path
        Full = $Full
    }
    if ($null -ne $UseLargeFRS) {
        $parameters.Add("UseLargeFRS", $UseLargeFRS)
    }
    if ($null -ne $SetIntegrityStreams) {
        $parameters.Add("SetIntegrityStreams", $SetIntegrityStreams)
    }
    if ($null -ne $Compress){
        $parameters.Add("Compress", $Compress)
    }
    if ($null -ne $Label) {
        $parameters.Add("NewFileSystemLabel", $Label)
    }
    if ($null -ne $FileSystem) {
        $parameters.Add("FileSystem", $FileSystem)
    }
    if ($null -ne $AllocationUnitSize) {
        $parameters.Add("AllocationUnitSize", $AllocationUnitSize)
    }

    Format-Volume @parameters -Confirm:$false | Out-Null

}

$ansible_volume = Get-AnsibleVolume -DriveLetter $drive_letter -Path $path -Label $label
$ansible_file_system = $ansible_volume.FileSystem
$ansible_volume_size = $ansible_volume.Size
$ansible_volume_alu = (Get-CimInstance -ClassName Win32_Volume -Filter "DeviceId = '$($ansible_volume.path.replace('\','\\'))'" -Property BlockSize).BlockSize

$ansible_partition = Get-Partition -Volume $ansible_volume

if (-not $force_format -and $null -ne $allocation_unit_size -and $ansible_volume_alu -ne 0 -and $null -ne $ansible_volume_alu -and $allocation_unit_size -ne $ansible_volume_alu) {
        $module.FailJson("Force format must be specified since target allocation unit size: $($allocation_unit_size) is different from the current allocation unit size of the volume: $($ansible_volume_alu)")
}

foreach ($access_path in $ansible_partition.AccessPaths) {
    if ($access_path -ne $Path) {
        if ($null -ne $file_system -and
            -not [string]::IsNullOrEmpty($ansible_file_system) -and
            $file_system -ne $ansible_file_system)
        {
            if (-not $force_format)
            {
                $no_files_in_volume = (Get-ChildItem -LiteralPath $access_path -ErrorAction SilentlyContinue | Measure-Object).Count -eq 0
                if($no_files_in_volume)
                {
                    $module.FailJson("Force format must be specified since target file system: $($file_system) is different from the current file system of the volume: $($ansible_file_system.ToLower())")
                }
                else
                {
                    $module.FailJson("Force format must be specified to format non-pristine volumes")
                }
            }
        }
        else
        {
            $pristine = -not $force_format
        }
    }
}

if ($force_format) {
    if (-not $module.CheckMode) {
        Format-AnsibleVolume -Path $ansible_volume.Path -Full $full_format -Label $new_label -FileSystem $file_system -SetIntegrityStreams $integrity_streams -UseLargeFRS $large_frs -Compress $compress_volume -AllocationUnitSize $allocation_unit_size
    }
    $module.Result.changed = $true
}
else {
    if ($pristine) {
        if ($null -eq $new_label) {
            $new_label = $ansible_volume.FileSystemLabel
        }
        # Conditions for formatting
        if ($ansible_volume_size -eq 0 -or
            $ansible_volume.FileSystemLabel -ne $new_label) {
            if (-not $module.CheckMode) {
                Format-AnsibleVolume -Path $ansible_volume.Path -Full $full_format -Label $new_label -FileSystem $file_system -SetIntegrityStreams $integrity_streams -UseLargeFRS $large_frs -Compress $compress_volume -AllocationUnitSize $allocation_unit_size
            }
            $module.Result.changed = $true
#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.CommandUtil
#Requires -Module Ansible.ModuleUtils.FileUtil

# TODO: add check mode support

Set-StrictMode -Version 2
$ErrorActionPreference = 'Stop'

$params = Parse-Args $args -supports_check_mode $false

$raw_command_line = Get-AnsibleParam -obj $params -name "_raw_params" -type "str" -failifempty $true
$chdir = Get-AnsibleParam -obj $params -name "chdir" -type "path"
$creates = Get-AnsibleParam -obj $params -name "creates" -type "path"
$removes = Get-AnsibleParam -obj $params -name "removes" -type "path"
$stdin = Get-AnsibleParam -obj $params -name "stdin" -type "str"
$output_encoding_override = Get-AnsibleParam -obj $params -name "output_encoding_override" -type "str"

$raw_command_line = $raw_command_line.Trim()

$result = @{
    changed = $true
    cmd = $raw_command_line
}

if ($creates -and $(Test-AnsiblePath -Path $creates)) {
    Exit-Json @{msg="skipped, since $creates exists";cmd=$raw_command_line;changed=$false;skipped=$true;rc=0}
}

if ($removes -and -not $(Test-AnsiblePath -Path $removes)) {
    Exit-Json @{msg="skipped, since $removes does not exist";cmd=$raw_command_line;changed=$false;skipped=$true;rc=0}
}

$command_args = @{
    command = $raw_command_line
}
if ($chdir) {
    $command_args['working_directory'] = $chdir
}
if ($stdin) {
    $command_args['stdin'] = $stdin
}
if ($output_encoding_override) {
    $command_args['output_encoding_override'] = $output_encoding_override
}

$start_datetime = [DateTime]::UtcNow
try {
    $command_result = Run-Command @command_args
} catch {
    $result.changed = $false
    try {
        $result.rc = $_.Exception.NativeErrorCode
    } catch {
        $result.rc = 2
    }
    Fail-Json -obj $result -message $_.Exception.Message
}

$result.stdout = $command_result.stdout
$result.stderr = $command_result.stderr
$result.rc = $command_result.rc

$end_datetime = [DateTime]::UtcNow
$result.start = $start_datetime.ToString("yyyy-MM-dd hh:mm:ss.ffffff")
$result.end = $end_datetime.ToString("yyyy-MM-dd hh:mm:ss.ffffff")
$result.delta = $($end_datetime - $start_datetime).ToString("h\:mm\:ss\.ffffff")

If ($result.rc -ne 0) {
    Fail-Json -obj $result -message "non-zero return code"
#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.SID

$ErrorActionPreference = 'Stop'

$params = Parse-Args $args -supports_check_mode $true
$check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -type "bool" -default $false
$diff_mode = Get-AnsibleParam -obj $params -name "_ansible_diff" -type "bool" -default $false
$_remote_tmp = Get-AnsibleParam $params "_ansible_remote_tmp" -type "path" -default $env:TMP

$name = Get-AnsibleParam -obj $params -name "name" -type "str" -failifempty $true
$users = Get-AnsibleParam -obj $params -name "users" -type "list" -failifempty $true
$action = Get-AnsibleParam -obj $params -name "action" -type "str" -default "set" -validateset "add","remove","set"

$result = @{
    changed = $false
    added = @()
    removed = @()
}

if ($diff_mode) {
    $result.diff = @{}
}

$sec_helper_util = @"
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace Ansible
{
    public class LsaRightHelper : IDisposable
    {
        // Code modified from https://gallery.technet.microsoft.com/scriptcenter/Grant-Revoke-Query-user-26e259b0

        enum Access : int
        {
            POLICY_READ = 0x20006,
            POLICY_ALL_ACCESS = 0x00F0FFF,
            POLICY_EXECUTE = 0X20801,
            POLICY_WRITE = 0X207F8
        }

        IntPtr lsaHandle;

        const string LSA_DLL = "advapi32.dll";
        const CharSet DEFAULT_CHAR_SET = CharSet.Unicode;

        const uint STATUS_NO_MORE_ENTRIES = 0x8000001a;
        const uint STATUS_NO_SUCH_PRIVILEGE = 0xc0000060;

        internal sealed class Sid : IDisposable
        {
            public IntPtr pSid = IntPtr.Zero;
            public SecurityIdentifier sid = null;

            public Sid(string sidString)
            {
                try
                {
                    sid = new SecurityIdentifier(sidString);
                } catch
                {
                    throw new ArgumentException(String.Format("SID string {0} could not be converted to SecurityIdentifier", sidString));
                }

                Byte[] buffer = new Byte[sid.BinaryLength];
                sid.GetBinaryForm(buffer, 0);

                pSid = Marshal.AllocHGlobal(sid.BinaryLength);
                Marshal.Copy(buffer, 0, pSid, sid.BinaryLength);
            }

            public void Dispose()
            {
                if (pSid != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(pSid);
                    pSid = IntPtr.Zero;
                }
                GC.SuppressFinalize(this);
            }
            ~Sid() { Dispose(); }
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct LSA_OBJECT_ATTRIBUTES
        {
            public int Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName;
            public int Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = DEFAULT_CHAR_SET)]
        private struct LSA_UNICODE_STRING
        {
            public ushort Length;
            public ushort MaximumLength;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string Buffer;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct LSA_ENUMERATION_INFORMATION
        {
            public IntPtr Sid;
        }

        [DllImport(LSA_DLL, CharSet = DEFAULT_CHAR_SET, SetLastError = true)]
        private static extern uint LsaOpenPolicy(
            LSA_UNICODE_STRING[] SystemName,
            ref LSA_OBJECT_ATTRIBUTES ObjectAttributes,
            int AccessMask,
            out IntPtr PolicyHandle
        );

        [DllImport(LSA_DLL, CharSet = DEFAULT_CHAR_SET, SetLastError = true)]
        private static extern uint LsaAddAccountRights(
            IntPtr PolicyHandle,
            IntPtr pSID,
            LSA_UNICODE_STRING[] UserRights,
            int CountOfRights
        );

        [DllImport(LSA_DLL, CharSet = DEFAULT_CHAR_SET, SetLastError = true)]
        private static extern uint LsaRemoveAccountRights(
            IntPtr PolicyHandle,
            IntPtr pSID,
            bool AllRights,
            LSA_UNICODE_STRING[] UserRights,
            int CountOfRights
        );

        [DllImport(LSA_DLL, CharSet = DEFAULT_CHAR_SET, SetLastError = true)]
        private static extern uint LsaEnumerateAccountsWithUserRight(
            IntPtr PolicyHandle,
            LSA_UNICODE_STRING[] UserRights,
            out IntPtr EnumerationBuffer,
            out ulong CountReturned
        );

        [DllImport(LSA_DLL)]
        private static extern int LsaNtStatusToWinError(int NTSTATUS);

        [DllImport(LSA_DLL)]
        private static extern int LsaClose(IntPtr PolicyHandle);

        [DllImport(LSA_DLL)]
        private static extern int LsaFreeMemory(IntPtr Buffer);

        public LsaRightHelper()
        {
            LSA_OBJECT_ATTRIBUTES lsaAttr;
            lsaAttr.RootDirectory = IntPtr.Zero;
            lsaAttr.ObjectName = IntPtr.Zero;
            lsaAttr.Attributes = 0;
            lsaAttr.SecurityDescriptor = IntPtr.Zero;
            lsaAttr.SecurityQualityOfService = IntPtr.Zero;
            lsaAttr.Length = Marshal.SizeOf(typeof(LSA_OBJECT_ATTRIBUTES));

            lsaHandle = IntPtr.Zero;

            LSA_UNICODE_STRING[] system = new LSA_UNICODE_STRING[1];
            system[0] = InitLsaString("");

            uint ret = LsaOpenPolicy(system, ref lsaAttr, (int)Access.POLICY_ALL_ACCESS, out lsaHandle);
            if (ret != 0)
                throw new Win32Exception(LsaNtStatusToWinError((int)ret));
        }

        public void AddPrivilege(string sidString, string privilege)
        {
            uint ret = 0;
            using (Sid sid = new Sid(sidString))
            {
                LSA_UNICODE_STRING[] privileges = new LSA_UNICODE_STRING[1];
                privileges[0] = InitLsaString(privilege);
                ret = LsaAddAccountRights(lsaHandle, sid.pSid, privileges, 1);
            }
            if (ret != 0)
                throw new Win32Exception(LsaNtStatusToWinError((int)ret));
        }

        public void RemovePrivilege(string sidString, string privilege)
        {
            uint ret = 0;
            using (Sid sid = new Sid(sidString))
            {
                LSA_UNICODE_STRING[] privileges = new LSA_UNICODE_STRING[1];
                privileges[0] = InitLsaString(privilege);
                ret = LsaRemoveAccountRights(lsaHandle, sid.pSid, false, privileges, 1);
            }
            if (ret != 0)
                throw new Win32Exception(LsaNtStatusToWinError((int)ret));
        }

        public string[] EnumerateAccountsWithUserRight(string privilege)
        {
            uint ret = 0;
            ulong count = 0;
            LSA_UNICODE_STRING[] rights = new LSA_UNICODE_STRING[1];
            rights[0] = InitLsaString(privilege);
            IntPtr buffer = IntPtr.Zero;

            ret = LsaEnumerateAccountsWithUserRight(lsaHandle, rights, out buffer, out count);
            switch (ret)
            {
                case 0:
                    string[] accounts = new string[count];
                    for (int i = 0; i < (int)count; i++)
                    {
                        LSA_ENUMERATION_INFORMATION LsaInfo = (LSA_ENUMERATION_INFORMATION)Marshal.PtrToStructure(
                            IntPtr.Add(buffer, i * Marshal.SizeOf(typeof(LSA_ENUMERATION_INFORMATION))),
                            typeof(LSA_ENUMERATION_INFORMATION));

                        accounts[i] = new SecurityIdentifier(LsaInfo.Sid).ToString();
                    }
                    LsaFreeMemory(buffer);
                    return accounts;

                case STATUS_NO_MORE_ENTRIES:
                    return new string[0];

                case STATUS_NO_SUCH_PRIVILEGE:
                    throw new ArgumentException(String.Format("Invalid privilege {0} not found in LSA database", privilege));

                default:
                    throw new Win32Exception(LsaNtStatusToWinError((int)ret));
            }
        }

        static LSA_UNICODE_STRING InitLsaString(string s)
        {
            // Unicode strings max. 32KB
            if (s.Length > 0x7ffe)
                throw new ArgumentException("String too long");

            LSA_UNICODE_STRING lus = new LSA_UNICODE_STRING();
            lus.Buffer = s;
            lus.Length = (ushort)(s.Length * sizeof(char));
            lus.MaximumLength = (ushort)(lus.Length + sizeof(char));

            return lus;
        }

        public void Dispose()
        {
            if (lsaHandle != IntPtr.Zero)
            {
                LsaClose(lsaHandle);
                lsaHandle = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }
        ~LsaRightHelper() { Dispose(); }
    }
}
"@

$original_tmp = $env:TMP
$env:TMP = $_remote_tmp
Add-Type -TypeDefinition $sec_helper_util
$env:TMP = $original_tmp

Function Compare-UserList($existing_users, $new_users) {
    $added_users = [String[]]@()
    $removed_users = [String[]]@()
    if ($action -eq "add") {
        $added_users = [Linq.Enumerable]::Except($new_users, $existing_users)
    } elseif ($action -eq "remove") {
        $removed_users = [Linq.Enumerable]::Intersect($new_users, $existing_users)
    } else {
        $added_users = [Linq.Enumerable]::Except($new_users, $existing_users)
        $removed_users = [Linq.Enumerable]::Except($existing_users, $new_users)
    }

    $change_result = @{
        added = $added_users
        removed = $removed_users
    }

    return $change_result
}

# C# class we can use to enumerate/add/remove rights
$lsa_helper = New-Object -TypeName Ansible.LsaRightHelper

$new_users = [System.Collections.ArrayList]@()
foreach ($user in $users) {
    $user_sid = Convert-ToSID -account_name $user
    $new_users.Add($user_sid) > $null
}
$new_users = [String[]]$new_users.ToArray()
try {
    $existing_users = $lsa_helper.EnumerateAccountsWithUserRight($name)
} catch [ArgumentException] {
    Fail-Json -obj $result -message "the specified right $name is not a valid right"
} catch {
    Fail-Json -obj $result -message "failed to enumerate existing accounts with right: $($_.Exception.Message)"
}

$change_result = Compare-UserList -existing_users $existing_users -new_user $new_users
if (($change_result.added.Length -gt 0) -or ($change_result.removed.Length -gt 0)) {
    $result.changed = $true
    $diff_text = "[$name]`n"

    # used in diff mode calculation
    $new_user_list = [System.Collections.ArrayList]$existing_users
    foreach ($user in $change_result.removed) {
        if (-not $check_mode) {
            $lsa_helper.RemovePrivilege($user, $name)
        }
        $user_name = Convert-FromSID -sid $user
        $result.removed += $user_name
        $diff_text += "-$user_name`n"
        $new_user_list.Remove($user) > $null
    }
    foreach ($user in $change_result.added) {
        if (-not $check_mode) {
            $lsa_helper.AddPrivilege($user, $name)
        }
        $user_name = Convert-FromSID -sid $user
        $result.added += $user_name
        $diff_text += "+$user_name`n"
        $new_user_list.Add($user) > $null
    }

    if ($diff_mode) {
        if ($new_user_list.Count -eq 0) {
            $diff_text = "-$diff_text"
        } else {
            if ($existing_users.Count -eq 0) {
                $diff_text = "+$diff_text"
            }
        }
        $result.diff.prepared = $diff_text
#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.CamelConversion

$ErrorActionPreference = "Stop"

$params = Parse-Args $args -supports_check_mode $true
$_remote_tmp = Get-AnsibleParam $params "_ansible_remote_tmp" -type "path" -default $env:TMP

$session_util = @'
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;

namespace Ansible
{
    public class SessionInfo
    {
        // SECURITY_LOGON_SESSION_DATA
        public UInt64 LogonId { get; internal set; }
        public Sid Account { get; internal set; }
        public string LoginDomain { get; internal set; }
        public string AuthenticationPackage { get; internal set; }
        public SECURITY_LOGON_TYPE LogonType { get; internal set; }
        public string LoginTime { get; internal set; }
        public string LogonServer { get; internal set; }
        public string DnsDomainName { get; internal set; }
        public string Upn { get; internal set; }
        public ArrayList UserFlags { get; internal set; }

        // TOKEN_STATISTICS
        public SECURITY_IMPERSONATION_LEVEL ImpersonationLevel { get; internal set; }
        public TOKEN_TYPE TokenType { get; internal set; }

        // TOKEN_GROUPS
        public ArrayList Groups { get; internal set; }
        public ArrayList Rights { get; internal set; }

        // TOKEN_MANDATORY_LABEL
        public Sid Label { get; internal set; }

        // TOKEN_PRIVILEGES
        public Hashtable Privileges { get; internal set; }
    }

    public class Win32Exception : System.ComponentModel.Win32Exception
    {
        private string _msg;
        public Win32Exception(string message) : this(Marshal.GetLastWin32Error(), message) { }
        public Win32Exception(int errorCode, string message) : base(errorCode)
        {
            _msg = String.Format("{0} ({1}, Win32ErrorCode {2})", message, base.Message, errorCode);
        }
        public override string Message { get { return _msg; } }
        public static explicit operator Win32Exception(string message) { return new Win32Exception(message); }
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct LSA_UNICODE_STRING
    {
        public UInt16 Length;
        public UInt16 MaximumLength;
        public IntPtr buffer;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct LUID
    {
        public UInt32 LowPart;
        public Int32 HighPart;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct SECURITY_LOGON_SESSION_DATA
    {
        public UInt32 Size;
        public LUID LogonId;
        public LSA_UNICODE_STRING Username;
        public LSA_UNICODE_STRING LoginDomain;
        public LSA_UNICODE_STRING AuthenticationPackage;
        public SECURITY_LOGON_TYPE LogonType;
        public UInt32 Session;
        public IntPtr Sid;
        public UInt64 LoginTime;
        public LSA_UNICODE_STRING LogonServer;
        public LSA_UNICODE_STRING DnsDomainName;
        public LSA_UNICODE_STRING Upn;
        public UInt32 UserFlags;
        public LSA_LAST_INTER_LOGON_INFO LastLogonInfo;
        public LSA_UNICODE_STRING LogonScript;
        public LSA_UNICODE_STRING ProfilePath;
        public LSA_UNICODE_STRING HomeDirectory;
        public LSA_UNICODE_STRING HomeDirectoryDrive;
        public UInt64 LogoffTime;
        public UInt64 KickOffTime;
        public UInt64 PasswordLastSet;
        public UInt64 PasswordCanChange;
        public UInt64 PasswordMustChange;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct LSA_LAST_INTER_LOGON_INFO
    {
        public UInt64 LastSuccessfulLogon;
        public UInt64 LastFailedLogon;
        public UInt32 FailedAttemptCountSinceLastSuccessfulLogon;
    }

    public enum TOKEN_TYPE
    {
        TokenPrimary = 1,
        TokenImpersonation
    }

    public enum SECURITY_IMPERSONATION_LEVEL
    {
        SecurityAnonymous,
        SecurityIdentification,
        SecurityImpersonation,
        SecurityDelegation
    }

    public enum SECURITY_LOGON_TYPE
    {
        System = 0, // Used only by the Sytem account
        Interactive = 2,
        Network,
        Batch,
        Service,
        Proxy,
        Unlock,
        NetworkCleartext,
        NewCredentials,
        RemoteInteractive,
        CachedInteractive,
        CachedRemoteInteractive,
        CachedUnlock
    }

    [Flags]
    public enum TokenGroupAttributes : uint
    {
        SE_GROUP_ENABLED = 0x00000004,
        SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002,
        SE_GROUP_INTEGRITY = 0x00000020,
        SE_GROUP_INTEGRITY_ENABLED = 0x00000040,
        SE_GROUP_LOGON_ID = 0xC0000000,
        SE_GROUP_MANDATORY = 0x00000001,
        SE_GROUP_OWNER = 0x00000008,
        SE_GROUP_RESOURCE = 0x20000000,
        SE_GROUP_USE_FOR_DENY_ONLY = 0x00000010,
    }

    [Flags]
    public enum UserFlags : uint
    {
        LOGON_OPTIMIZED = 0x4000,
        LOGON_WINLOGON = 0x8000,
        LOGON_PKINIT = 0x10000,
        LOGON_NOT_OPTMIZED = 0x20000,
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct SID_AND_ATTRIBUTES
    {
        public IntPtr Sid;
        public UInt32 Attributes;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct LUID_AND_ATTRIBUTES
    {
        public LUID Luid;
        public UInt32 Attributes;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_GROUPS
    {
        public UInt32 GroupCount;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public SID_AND_ATTRIBUTES[] Groups;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_MANDATORY_LABEL
    {
        public SID_AND_ATTRIBUTES Label;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_STATISTICS
    {
        public LUID TokenId;
        public LUID AuthenticationId;
        public UInt64 ExpirationTime;
        public TOKEN_TYPE TokenType;
        public SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
        public UInt32 DynamicCharged;
        public UInt32 DynamicAvailable;
        public UInt32 GroupCount;
        public UInt32 PrivilegeCount;
        public LUID ModifiedId;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_PRIVILEGES
    {
        public UInt32 PrivilegeCount;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public LUID_AND_ATTRIBUTES[] Privileges;
    }

    public class AccessToken : IDisposable
    {
        public enum TOKEN_INFORMATION_CLASS
        {
            TokenUser = 1,
            TokenGroups,
            TokenPrivileges,
            TokenOwner,
            TokenPrimaryGroup,
            TokenDefaultDacl,
            TokenSource,
            TokenType,
            TokenImpersonationLevel,
            TokenStatistics,
            TokenRestrictedSids,
            TokenSessionId,
            TokenGroupsAndPrivileges,
            TokenSessionReference,
            TokenSandBoxInert,
            TokenAuditPolicy,
            TokenOrigin,
            TokenElevationType,
            TokenLinkedToken,
            TokenElevation,
            TokenHasRestrictions,
            TokenAccessInformation,
            TokenVirtualizationAllowed,
            TokenVirtualizationEnabled,
            TokenIntegrityLevel,
            TokenUIAccess,
            TokenMandatoryPolicy,
            TokenLogonSid,
            TokenIsAppContainer,
            TokenCapabilities,
            TokenAppContainerSid,
            TokenAppContainerNumber,
            TokenUserClaimAttributes,
            TokenDeviceClaimAttributes,
            TokenRestrictedUserClaimAttributes,
            TokenRestrictedDeviceClaimAttributes,
            TokenDeviceGroups,
            TokenRestrictedDeviceGroups,
            TokenSecurityAttributes,
            TokenIsRestricted,
            MaxTokenInfoClass
        }

        public IntPtr hToken = IntPtr.Zero;

        [DllImport("kernel32.dll")]
        private static extern IntPtr GetCurrentProcess();

        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool OpenProcessToken(
            IntPtr ProcessHandle,
            TokenAccessLevels DesiredAccess,
            out IntPtr TokenHandle);

        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool GetTokenInformation(
            IntPtr TokenHandle,
            TOKEN_INFORMATION_CLASS TokenInformationClass,
            IntPtr TokenInformation,
            UInt32 TokenInformationLength,
            out UInt32 ReturnLength);

        public AccessToken(TokenAccessLevels tokenAccessLevels)
        {
            IntPtr currentProcess = GetCurrentProcess();
            if (!OpenProcessToken(currentProcess, tokenAccessLevels, out hToken))
                throw new Win32Exception("OpenProcessToken() for current process failed");
        }

        public IntPtr GetTokenInformation<T>(out T tokenInformation, TOKEN_INFORMATION_CLASS tokenClass)
        {
            UInt32 tokenLength = 0;
            GetTokenInformation(hToken, tokenClass, IntPtr.Zero, 0, out tokenLength);

            IntPtr infoPtr = Marshal.AllocHGlobal((int)tokenLength);

            if (!GetTokenInformation(hToken, tokenClass, infoPtr, tokenLength, out tokenLength))
                throw new Win32Exception(String.Format("GetTokenInformation() data for {0} failed", tokenClass.ToString()));

            tokenInformation = (T)Marshal.PtrToStructure(infoPtr, typeof(T));
            return infoPtr;
        }

        public void Dispose()
        {
            GC.SuppressFinalize(this);
        }

        ~AccessToken() { Dispose(); }
    }

    public class LsaHandle : IDisposable
    {
        [Flags]
        public enum DesiredAccess : uint
        {
            POLICY_VIEW_LOCAL_INFORMATION = 0x00000001,
            POLICY_VIEW_AUDIT_INFORMATION = 0x00000002,
            POLICY_GET_PRIVATE_INFORMATION = 0x00000004,
            POLICY_TRUST_ADMIN = 0x00000008,
            POLICY_CREATE_ACCOUNT = 0x00000010,
            POLICY_CREATE_SECRET = 0x00000020,
            POLICY_CREATE_PRIVILEGE = 0x00000040,
            POLICY_SET_DEFAULT_QUOTA_LIMITS = 0x00000080,
            POLICY_SET_AUDIT_REQUIREMENTS = 0x00000100,
            POLICY_AUDIT_LOG_ADMIN = 0x00000200,
            POLICY_SERVER_ADMIN = 0x00000400,
            POLICY_LOOKUP_NAMES = 0x00000800,
            POLICY_NOTIFICATION = 0x00001000
        }

        public IntPtr handle = IntPtr.Zero;

        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern uint LsaOpenPolicy(
            LSA_UNICODE_STRING[] SystemName,
            ref LSA_OBJECT_ATTRIBUTES ObjectAttributes,
            DesiredAccess AccessMask,
            out IntPtr PolicyHandle);

        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern uint LsaClose(
            IntPtr ObjectHandle);

        [DllImport("advapi32.dll", SetLastError = false)]
        private static extern int LsaNtStatusToWinError(
            uint Status);

        [StructLayout(LayoutKind.Sequential)]
        public struct LSA_OBJECT_ATTRIBUTES
        {
            public int Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName;
            public int Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }

        public LsaHandle(DesiredAccess desiredAccess)
        {
            LSA_OBJECT_ATTRIBUTES lsaAttr;
            lsaAttr.RootDirectory = IntPtr.Zero;
            lsaAttr.ObjectName = IntPtr.Zero;
            lsaAttr.Attributes = 0;
            lsaAttr.SecurityDescriptor = IntPtr.Zero;
            lsaAttr.SecurityQualityOfService = IntPtr.Zero;
            lsaAttr.Length = Marshal.SizeOf(typeof(LSA_OBJECT_ATTRIBUTES));
            LSA_UNICODE_STRING[] system = new LSA_UNICODE_STRING[1];
            system[0].buffer = IntPtr.Zero;

            uint res = LsaOpenPolicy(system, ref lsaAttr, desiredAccess, out handle);
            if (res != 0)
                throw new Win32Exception(LsaNtStatusToWinError(res), "LsaOpenPolicy() failed");
        }

        public void Dispose()
        {
            if (handle != IntPtr.Zero)
            {
                LsaClose(handle);
                handle = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }

        ~LsaHandle() { Dispose(); }
    }

    public class Sid
    {
        public string SidString { get; internal set; }
        public string DomainName { get; internal set; }
        public string AccountName { get; internal set; }
        public SID_NAME_USE SidType { get; internal set; }

        public enum SID_NAME_USE
        {
            SidTypeUser = 1,
            SidTypeGroup,
            SidTypeDomain,
            SidTypeAlias,
            SidTypeWellKnownGroup,
            SidTypeDeletedAccount,
            SidTypeInvalid,
            SidTypeUnknown,
            SidTypeComputer,
            SidTypeLabel,
            SidTypeLogon,
        }

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern bool LookupAccountSid(
            string lpSystemName,
            [MarshalAs(UnmanagedType.LPArray)]
            byte[] Sid,
            StringBuilder lpName,
            ref UInt32 cchName,
            StringBuilder ReferencedDomainName,
            ref UInt32 cchReferencedDomainName,
            out SID_NAME_USE peUse);

        public Sid(IntPtr sidPtr)
        {
            SecurityIdentifier sid;
            try
            {
                sid = new SecurityIdentifier(sidPtr);
            }
            catch (Exception e)
            {
                throw new ArgumentException(String.Format("Failed to cast IntPtr to SecurityIdentifier: {0}", e));
            }

            SetSidInfo(sid);
        }

        public Sid(SecurityIdentifier sid)
        {
            SetSidInfo(sid);
        }

        public override string ToString()
        {
            return SidString;
        }

        private void SetSidInfo(SecurityIdentifier sid)
        {
            byte[] sidBytes = new byte[sid.BinaryLength];
            sid.GetBinaryForm(sidBytes, 0);

            StringBuilder lpName = new StringBuilder();
            UInt32 cchName = 0;
            StringBuilder referencedDomainName = new StringBuilder();
            UInt32 cchReferencedDomainName = 0;
            SID_NAME_USE peUse;
            LookupAccountSid(null, sidBytes, lpName, ref cchName, referencedDomainName, ref cchReferencedDomainName, out peUse);

            lpName.EnsureCapacity((int)cchName);
            referencedDomainName.EnsureCapacity((int)cchReferencedDomainName);

            SidString = sid.ToString();
            if (!LookupAccountSid(null, sidBytes, lpName, ref cchName, referencedDomainName, ref cchReferencedDomainName, out peUse))
            {
                int lastError = Marshal.GetLastWin32Error();

                if (lastError != 1332 && lastError != 1789) // Fails to lookup Logon Sid
                {
                    throw new Win32Exception(lastError, String.Format("LookupAccountSid() failed for SID: {0} {1}", sid.ToString(), lastError));
                }
                else if (SidString.StartsWith("S-1-5-5-"))
                {
                    AccountName = String.Format("LogonSessionId_{0}", SidString.Substring(8));
                    DomainName = "NT AUTHORITY";
                    SidType = SID_NAME_USE.SidTypeLogon;
                }
                else
                {
                    AccountName = null;
                    DomainName = null;
                    SidType = SID_NAME_USE.SidTypeUnknown;
                }
            }
            else
            {
                AccountName = lpName.ToString();
                DomainName = referencedDomainName.ToString();
                SidType = peUse;
            }
        }
    }

    public class SessionUtil
    {
        [DllImport("secur32.dll", SetLastError = false)]
        private static extern uint LsaFreeReturnBuffer(
            IntPtr Buffer);

        [DllImport("secur32.dll", SetLastError = false)]
        private static extern uint LsaEnumerateLogonSessions(
            out UInt64 LogonSessionCount,
            out IntPtr LogonSessionList);

        [DllImport("secur32.dll", SetLastError = false)]
        private static extern uint LsaGetLogonSessionData(
            IntPtr LogonId,
            out IntPtr ppLogonSessionData);

        [DllImport("advapi32.dll", SetLastError = false)]
        private static extern int LsaNtStatusToWinError(
            uint Status);

        [DllImport("advapi32", SetLastError = true)]
        private static extern uint LsaEnumerateAccountRights(
            IntPtr PolicyHandle,
            IntPtr AccountSid,
            out IntPtr UserRights,
            out UInt64 CountOfRights);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern bool LookupPrivilegeName(
            string lpSystemName,
            ref LUID lpLuid,
            StringBuilder lpName,
            ref UInt32 cchName);

        private const UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001;
        private const UInt32 SE_PRIVILEGE_ENABLED = 0x00000002;
        private const UInt32 STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
        private const UInt32 STATUS_ACCESS_DENIED = 0xC0000022;

        public static SessionInfo GetSessionInfo()
        {
            AccessToken accessToken = new AccessToken(TokenAccessLevels.Query);

            // Get Privileges
            Hashtable privilegeInfo = new Hashtable();
            TOKEN_PRIVILEGES privileges;
            IntPtr privilegesPtr = accessToken.GetTokenInformation(out privileges, AccessToken.TOKEN_INFORMATION_CLASS.TokenPrivileges);
            LUID_AND_ATTRIBUTES[] luidAndAttributes = new LUID_AND_ATTRIBUTES[privileges.PrivilegeCount];
            try
            {
                PtrToStructureArray(luidAndAttributes, privilegesPtr.ToInt64() + Marshal.SizeOf(privileges.PrivilegeCount));
            }
            finally
            {
                Marshal.FreeHGlobal(privilegesPtr);
            }
            foreach (LUID_AND_ATTRIBUTES luidAndAttribute in luidAndAttributes)
            {
                LUID privLuid = luidAndAttribute.Luid;
                UInt32 privNameLen = 0;
                StringBuilder privName = new StringBuilder();
                LookupPrivilegeName(null, ref privLuid, null, ref privNameLen);
                privName.EnsureCapacity((int)(privNameLen + 1));
                if (!LookupPrivilegeName(null, ref privLuid, privName, ref privNameLen))
                    throw new Win32Exception("LookupPrivilegeName() failed");

                string state = "disabled";
                if ((luidAndAttribute.Attributes & SE_PRIVILEGE_ENABLED) == SE_PRIVILEGE_ENABLED)
                    state = "enabled";
                if ((luidAndAttribute.Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT) == SE_PRIVILEGE_ENABLED_BY_DEFAULT)
                    state = "enabled-by-default";
                privilegeInfo.Add(privName.ToString(), state);
            }

            // Get Current Process LogonSID, User Rights and Groups
            ArrayList userRights = new ArrayList();
            ArrayList userGroups = new ArrayList();
            TOKEN_GROUPS groups;
            IntPtr groupsPtr = accessToken.GetTokenInformation(out groups, AccessToken.TOKEN_INFORMATION_CLASS.TokenGroups);
            SID_AND_ATTRIBUTES[] sidAndAttributes = new SID_AND_ATTRIBUTES[groups.GroupCount];
            LsaHandle lsaHandle = null;
            // We can only get rights if we are an admin
            if (new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator))
                lsaHandle = new LsaHandle(LsaHandle.DesiredAccess.POLICY_LOOKUP_NAMES);
            try
            {
                PtrToStructureArray(sidAndAttributes, groupsPtr.ToInt64() + IntPtr.Size);
                foreach (SID_AND_ATTRIBUTES sidAndAttribute in sidAndAttributes)
                {
                    TokenGroupAttributes attributes = (TokenGroupAttributes)sidAndAttribute.Attributes;
                    if (attributes.HasFlag(TokenGroupAttributes.SE_GROUP_ENABLED) && lsaHandle != null)
                    {
                        ArrayList rights = GetAccountRights(lsaHandle.handle, sidAndAttribute.Sid);
                        foreach (string right in rights)
                        {
                            // Includes both Privileges and Account Rights, only add the ones with Logon in the name
                            // https://msdn.microsoft.com/en-us/library/windows/desktop/bb545671(v=vs.85).aspx
                            if (!userRights.Contains(right) && right.Contains("Logon"))
                                userRights.Add(right);
                        }
                    }
                    // Do not include the Logon SID in the groups category
                    if (!attributes.HasFlag(TokenGroupAttributes.SE_GROUP_LOGON_ID))
                    {
                        Hashtable groupInfo = new Hashtable();
                        Sid group = new Sid(sidAndAttribute.Sid);
                        ArrayList groupAttributes = new ArrayList();
                        foreach (TokenGroupAttributes attribute in Enum.GetValues(typeof(TokenGroupAttributes)))
                        {
                            if (attributes.HasFlag(attribute))
                            {
                                string attributeName = attribute.ToString().Substring(9);
                                attributeName = attributeName.Replace('_', ' ');
                                attributeName = attributeName.First().ToString().ToUpper() + attributeName.Substring(1).ToLower();
                                groupAttributes.Add(attributeName);
                            }
                        }
                        // Using snake_case here as I can't generically convert all dict keys in PS (see Privileges)
                        groupInfo.Add("sid", group.SidString);
                        groupInfo.Add("domain_name", group.DomainName);
                        groupInfo.Add("account_name", group.AccountName);
                        groupInfo.Add("type", group.SidType);
                        groupInfo.Add("attributes", groupAttributes);
                        userGroups.Add(groupInfo);
                    }
                }
            }
            finally
            {
                Marshal.FreeHGlobal(groupsPtr);
                if (lsaHandle != null)
                    lsaHandle.Dispose();
            }

            // Get Integrity Level
            Sid integritySid = null;
            TOKEN_MANDATORY_LABEL mandatoryLabel;
            IntPtr mandatoryLabelPtr = accessToken.GetTokenInformation(out mandatoryLabel, AccessToken.TOKEN_INFORMATION_CLASS.TokenIntegrityLevel);
            Marshal.FreeHGlobal(mandatoryLabelPtr);
            integritySid = new Sid(mandatoryLabel.Label.Sid);

            // Get Token Statistics
            TOKEN_STATISTICS tokenStats;
            IntPtr tokenStatsPtr = accessToken.GetTokenInformation(out tokenStats, AccessToken.TOKEN_INFORMATION_CLASS.TokenStatistics);
            Marshal.FreeHGlobal(tokenStatsPtr);

            SessionInfo sessionInfo = GetSessionDataForLogonSession(tokenStats.AuthenticationId);
            sessionInfo.Groups = userGroups;
            sessionInfo.Label = integritySid;
            sessionInfo.ImpersonationLevel = tokenStats.ImpersonationLevel;
            sessionInfo.TokenType = tokenStats.TokenType;
            sessionInfo.Privileges = privilegeInfo;
            sessionInfo.Rights = userRights;
            return sessionInfo;
        }

        private static ArrayList GetAccountRights(IntPtr lsaHandle, IntPtr sid)
        {
            UInt32 res;
            ArrayList rights = new ArrayList();
            IntPtr userRightsPointer = IntPtr.Zero;
            UInt64 countOfRights = 0;

            res = LsaEnumerateAccountRights(lsaHandle, sid, out userRightsPointer, out countOfRights);
            if (res != 0 && res != STATUS_OBJECT_NAME_NOT_FOUND)
                throw new Win32Exception(LsaNtStatusToWinError(res), "LsaEnumerateAccountRights() failed");
            else if (res != STATUS_OBJECT_NAME_NOT_FOUND)
            {
                LSA_UNICODE_STRING[] userRights = new LSA_UNICODE_STRING[countOfRights];
                PtrToStructureArray(userRights, userRightsPointer.ToInt64());
                rights = new ArrayList();
                foreach (LSA_UNICODE_STRING right in userRights)
                    rights.Add(Marshal.PtrToStringUni(right.buffer));
            }

            return rights;
        }

        private static SessionInfo GetSessionDataForLogonSession(LUID logonSession)
        {
            uint res;
            UInt64 count = 0;
            IntPtr luidPtr = IntPtr.Zero;
            SessionInfo sessionInfo = null;
            UInt64 processDataId = ConvertLuidToUint(logonSession);

            res = LsaEnumerateLogonSessions(out count, out luidPtr);
            if (res != 0)
                throw new Win32Exception(LsaNtStatusToWinError(res), "LsaEnumerateLogonSessions() failed");
            Int64 luidAddr = luidPtr.ToInt64();

            try
            {
                for (UInt64 i = 0; i < count; i++)
                {
                    IntPtr dataPointer = IntPtr.Zero;
                    res = LsaGetLogonSessionData(luidPtr, out dataPointer);
                    if (res == STATUS_ACCESS_DENIED) // Non admins won't be able to get info for session's that are not their own
                    {
                        luidPtr = new IntPtr(luidPtr.ToInt64() + Marshal.SizeOf(typeof(LUID)));
                        continue;
                    }
                    else if (res != 0)
                        throw new Win32Exception(LsaNtStatusToWinError(res), String.Format("LsaGetLogonSessionData() failed {0}", res));

                    SECURITY_LOGON_SESSION_DATA sessionData = (SECURITY_LOGON_SESSION_DATA)Marshal.PtrToStructure(dataPointer, typeof(SECURITY_LOGON_SESSION_DATA));
                    UInt64 sessionDataid = ConvertLuidToUint(sessionData.LogonId);

                    if (sessionDataid == processDataId)
                    {
                        ArrayList userFlags = new ArrayList();
                        UserFlags flags = (UserFlags)sessionData.UserFlags;
                        foreach (UserFlags flag in Enum.GetValues(typeof(UserFlags)))
                        {
                            if (flags.HasFlag(flag))
                            {
                                string flagName = flag.ToString().Substring(6);
                                flagName = flagName.Replace('_', ' ');
                                flagName = flagName.First().ToString().ToUpper() + flagName.Substring(1).ToLower();
                                userFlags.Add(flagName);
                            }
                        }

                        sessionInfo = new SessionInfo()
                        {
                            AuthenticationPackage = Marshal.PtrToStringUni(sessionData.AuthenticationPackage.buffer),
                            DnsDomainName = Marshal.PtrToStringUni(sessionData.DnsDomainName.buffer),
                            LoginDomain = Marshal.PtrToStringUni(sessionData.LoginDomain.buffer),
                            LoginTime = ConvertIntegerToDateString(sessionData.LoginTime),
                            LogonId = ConvertLuidToUint(sessionData.LogonId),
                            LogonServer = Marshal.PtrToStringUni(sessionData.LogonServer.buffer),
                            LogonType = sessionData.LogonType,
                            Upn = Marshal.PtrToStringUni(sessionData.Upn.buffer),
                            UserFlags = userFlags,
                            Account = new Sid(sessionData.Sid)
                        };
                        break;
                    }
                    luidPtr = new IntPtr(luidPtr.ToInt64() + Marshal.SizeOf(typeof(LUID)));
                }
            }
            finally
            {
                LsaFreeReturnBuffer(new IntPtr(luidAddr));
            }

            if (sessionInfo == null)
                throw new Exception(String.Format("Could not find the data for logon session {0}", processDataId));
            return sessionInfo;
        }

        private static string ConvertIntegerToDateString(UInt64 time)
        {
            if (time == 0)
                return null;
            if (time > (UInt64)DateTime.MaxValue.ToFileTime())
                return null;

            DateTime dateTime = DateTime.FromFileTime((long)time);
            return dateTime.ToString("o");
        }

        private static UInt64 ConvertLuidToUint(LUID luid)
        {
            UInt32 low = luid.LowPart;
            UInt64 high = (UInt64)luid.HighPart;
            high = high << 32;
            UInt64 uintValue = (high | (UInt64)low);
            return uintValue;
        }

        private static void PtrToStructureArray<T>(T[] array, Int64 pointerAddress)
        {
            Int64 pointerOffset = pointerAddress;
            for (int i = 0; i < array.Length; i++, pointerOffset += Marshal.SizeOf(typeof(T)))
                array[i] = (T)Marshal.PtrToStructure(new IntPtr(pointerOffset), typeof(T));
        }

        public static IEnumerable<T> GetValues<T>()
        {
            return Enum.GetValues(typeof(T)).Cast<T>();
        }
    }
}
'@

$original_tmp = $env:TMP
$env:TMP = $_remote_tmp
Add-Type -TypeDefinition $session_util
$env:TMP = $original_tmp

$session_info = [Ansible.SessionUtil]::GetSessionInfo()

Function Convert-Value($value) {
    $new_value = $value
    if ($value -is [System.Collections.ArrayList]) {
        $new_value = [System.Collections.ArrayList]@()
        foreach ($list_value in $value) {
            $new_list_value = Convert-Value -value $list_value
            [void]$new_value.Add($new_list_value)
        }
    } elseif ($value -is [Hashtable]) {
        $new_value = @{}
        foreach ($entry in $value.GetEnumerator()) {
            $entry_value = Convert-Value -value $entry.Value
            # manually convert Sid type entry to remove the SidType prefix
            if ($entry.Name -eq "type") {
                $entry_value = $entry_value.Replace("SidType", "")
            }
            $new_value[$entry.Name] = $entry_value
        }
    } elseif ($value -is [Ansible.Sid]) {
        $new_value = @{
            sid = $value.SidString
            account_name = $value.AccountName
            domain_name = $value.DomainName
            type = $value.SidType.ToString().Replace("SidType", "")
        }
    } elseif ($value -is [Enum]) {
        $new_value = $value.ToString()
    }

    return ,$new_value
}

$result = @{
    changed = $false
}

$properties = [type][Ansible.SessionInfo]
foreach ($property in $properties.DeclaredProperties) {
    $property_name = $property.Name
    $property_value = $session_info.$property_name
    $snake_name = Convert-StringToSnakeCase -string $property_name

    $result.$snake_name = Convert-Value -value $property_value
}
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy

$params = Parse-Args $args -supports_check_mode $true;
$src = Get-AnsibleParam -obj $params -name "src" -type "path" -aliases "path" -failifempty $true;

$result = @{
    changed = $false;
}

If (Test-Path -LiteralPath $src -PathType Leaf)
{
    $bytes = [System.IO.File]::ReadAllBytes($src);
    $result.content = [System.Convert]::ToBase64String($bytes);
    $result.encoding = "base64";
    Exit-Json $result;
}
ElseIf (Test-Path -LiteralPath $src -PathType Container)
{
    Fail-Json $result "Path $src is a directory";
}
Else
#!powershell

# Copyright: (c) 2014, Paul Durivage <paul.durivage@rackspace.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.AccessToken
#Requires -Module Ansible.ModuleUtils.Legacy

########
$ADS_UF_PASSWD_CANT_CHANGE = 64
$ADS_UF_DONT_EXPIRE_PASSWD = 65536

$adsi = [ADSI]"WinNT://$env:COMPUTERNAME"

function Get-User($user) {
    $adsi.Children | Where-Object {$_.SchemaClassName -eq 'user' -and $_.Name -eq $user }
    return
}

function Get-UserFlag($user, $flag) {
    If ($user.UserFlags[0] -band $flag) {
        $true
    }
    Else {
        $false
    }
}

function Set-UserFlag($user, $flag) {
    $user.UserFlags = ($user.UserFlags[0] -BOR $flag)
}

function Clear-UserFlag($user, $flag) {
    $user.UserFlags = ($user.UserFlags[0] -BXOR $flag)
}

function Get-Group($grp) {
    $adsi.Children | Where-Object { $_.SchemaClassName -eq 'Group' -and $_.Name -eq $grp }
    return
}

Function Test-LocalCredential {
    param([String]$Username, [String]$Password)

    try {
        $handle = [Ansible.AccessToken.TokenUtil]::LogonUser($Username, $null, $Password, "Network", "Default")
        $handle.Dispose()
        $valid_credentials = $true
    } catch [Ansible.AccessToken.Win32Exception] {
        # following errors indicate the creds are correct but the user was
        # unable to log on for other reasons, which we don't care about
        $success_codes = @(
            0x0000052F,  # ERROR_ACCOUNT_RESTRICTION
            0x00000530,  # ERROR_INVALID_LOGON_HOURS
            0x00000531,  # ERROR_INVALID_WORKSTATION
            0x00000569  # ERROR_LOGON_TYPE_GRANTED
        )

        if ($_.Exception.NativeErrorCode -eq 0x0000052E) {
            # ERROR_LOGON_FAILURE - the user or pass was incorrect
            $valid_credentials = $false
        } elseif ($_.Exception.NativeErrorCode -in $success_codes) {
            $valid_credentials = $true
        } else {
            # an unknown failure, reraise exception
            throw $_
        }
    }
    return $valid_credentials
}

########

$params = Parse-Args $args;

$result = @{
    changed = $false
};

$username = Get-AnsibleParam -obj $params -name "name" -type "str" -failifempty $true
$fullname = Get-AnsibleParam -obj $params -name "fullname" -type "str"
$description = Get-AnsibleParam -obj $params -name "description" -type "str"
$password = Get-AnsibleParam -obj $params -name "password" -type "str"
$state = Get-AnsibleParam -obj $params -name "state" -type "str" -default "present" -validateset "present","absent","query"
$update_password = Get-AnsibleParam -obj $params -name "update_password" -type "str" -default "always" -validateset "always","on_create"
$password_expired = Get-AnsibleParam -obj $params -name "password_expired" -type "bool"
$password_never_expires = Get-AnsibleParam -obj $params -name "password_never_expires" -type "bool"
$user_cannot_change_password = Get-AnsibleParam -obj $params -name "user_cannot_change_password" -type "bool"
$account_disabled = Get-AnsibleParam -obj $params -name "account_disabled" -type "bool"
$account_locked = Get-AnsibleParam -obj $params -name "account_locked" -type "bool"
$groups = Get-AnsibleParam -obj $params -name "groups"
$groups_action = Get-AnsibleParam -obj $params -name "groups_action" -type "str" -default "replace" -validateset "add","remove","replace"

If ($null -ne $account_locked -and $account_locked) {
    Fail-Json $result "account_locked must be set to 'no' if provided"
}

If ($null -ne $groups) {
    If ($groups -is [System.String]) {
        [string[]]$groups = $groups.Split(",")
    }
    ElseIf ($groups -isnot [System.Collections.IList]) {
        Fail-Json $result "groups must be a string or array"
    }
    $groups = $groups | ForEach-Object { ([string]$_).Trim() } | Where-Object { $_ }
    If ($null -eq $groups) {
        $groups = @()
    }
}

$user_obj = Get-User $username

If ($state -eq 'present') {
    # Add or update user
    try {
        If (-not $user_obj) {
            $user_obj = $adsi.Create("User", $username)
            If ($null -ne $password) {
                $user_obj.SetPassword($password)
            }
            $user_obj.SetInfo()
            $result.changed = $true
        }
        ElseIf (($null -ne $password) -and ($update_password -eq 'always')) {
            # ValidateCredentials will fail if either of these are true- just force update...
            If($user_obj.AccountDisabled -or $user_obj.PasswordExpired) {
                $password_match = $false
            }
            Else {
                try {
                    $password_match = Test-LocalCredential -Username $username -Password $password
                } catch [System.ComponentModel.Win32Exception] {
                    Fail-Json -obj $result -message "Failed to validate the user's credentials: $($_.Exception.Message)"
                }
            }

            If (-not $password_match) {
                $user_obj.SetPassword($password)
                $result.changed = $true
            }
        }
        If (($null -ne $fullname) -and ($fullname -ne $user_obj.FullName[0])) {
            $user_obj.FullName = $fullname
            $result.changed = $true
        }
        If (($null -ne $description) -and ($description -ne $user_obj.Description[0])) {
            $user_obj.Description = $description
            $result.changed = $true
        }
        If (($null -ne $password_expired) -and ($password_expired -ne ($user_obj.PasswordExpired | ConvertTo-Bool))) {
            $user_obj.PasswordExpired = If ($password_expired) { 1 } Else { 0 }
            $result.changed = $true
        }
        If (($null -ne $password_never_expires) -and ($password_never_expires -ne (Get-UserFlag $user_obj $ADS_UF_DONT_EXPIRE_PASSWD))) {
            If ($password_never_expires) {
                Set-UserFlag $user_obj $ADS_UF_DONT_EXPIRE_PASSWD
            }
            Else {
                Clear-UserFlag $user_obj $ADS_UF_DONT_EXPIRE_PASSWD
            }
            $result.changed = $true
        }
        If (($null -ne $user_cannot_change_password) -and ($user_cannot_change_password -ne (Get-UserFlag $user_obj $ADS_UF_PASSWD_CANT_CHANGE))) {
            If ($user_cannot_change_password) {
                Set-UserFlag $user_obj $ADS_UF_PASSWD_CANT_CHANGE
            }
            Else {
                Clear-UserFlag $user_obj $ADS_UF_PASSWD_CANT_CHANGE
            }
            $result.changed = $true
        }
        If (($null -ne $account_disabled) -and ($account_disabled -ne $user_obj.AccountDisabled)) {
            $user_obj.AccountDisabled = $account_disabled
            $result.changed = $true
        }
        If (($null -ne $account_locked) -and ($account_locked -ne $user_obj.IsAccountLocked)) {
            $user_obj.IsAccountLocked = $account_locked
            $result.changed = $true
        }
        If ($result.changed) {
            $user_obj.SetInfo()
        }
        If ($null -ne $groups) {
            [string[]]$current_groups = $user_obj.Groups() | ForEach-Object { $_.GetType().InvokeMember("Name", "GetProperty", $null, $_, $null) }
            If (($groups_action -eq "remove") -or ($groups_action -eq "replace")) {
                ForEach ($grp in $current_groups) {
                    If ((($groups_action -eq "remove") -and ($groups -contains $grp)) -or (($groups_action -eq "replace") -and ($groups -notcontains $grp))) {
                        $group_obj = Get-Group $grp
                        If ($group_obj) {
                            $group_obj.Remove($user_obj.Path)
                            $result.changed = $true
                        }
                        Else {
                            Fail-Json $result "group '$grp' not found"
                        }
                    }
                }
            }
            If (($groups_action -eq "add") -or ($groups_action -eq "replace")) {
                ForEach ($grp in $groups) {
                    If ($current_groups -notcontains $grp) {
                        $group_obj = Get-Group $grp
                        If ($group_obj) {
                            $group_obj.Add($user_obj.Path)
                            $result.changed = $true
                        }
                        Else {
                            Fail-Json $result "group '$grp' not found"
                        }
                    }
                }
            }
        }
    }
    catch {
        Fail-Json $result $_.Exception.Message
    }
}
ElseIf ($state -eq 'absent') {
    # Remove user
    try {
        If ($user_obj) {
            $username = $user_obj.Name.Value
            $adsi.delete("User", $user_obj.Name.Value)
            $result.changed = $true
            $result.msg = "User '$username' deleted successfully"
            $user_obj = $null
        } else {
            $result.msg = "User '$username' was not found"
        }
    }
    catch {
        Fail-Json $result $_.Exception.Message
    }
}

try {
    If ($user_obj -and $user_obj -is [System.DirectoryServices.DirectoryEntry]) {
        $user_obj.RefreshCache()
        $result.name = $user_obj.Name[0]
        $result.fullname = $user_obj.FullName[0]
        $result.path = $user_obj.Path
        $result.description = $user_obj.Description[0]
        $result.password_expired = ($user_obj.PasswordExpired | ConvertTo-Bool)
        $result.password_never_expires = (Get-UserFlag $user_obj $ADS_UF_DONT_EXPIRE_PASSWD)
        $result.user_cannot_change_password = (Get-UserFlag $user_obj $ADS_UF_PASSWD_CANT_CHANGE)
        $result.account_disabled = $user_obj.AccountDisabled
        $result.account_locked = $user_obj.IsAccountLocked
        $result.sid = (New-Object System.Security.Principal.SecurityIdentifier($user_obj.ObjectSid.Value, 0)).Value
        $user_groups = @()
        ForEach ($grp in $user_obj.Groups()) {
            $group_result = @{
                name = $grp.GetType().InvokeMember("Name", "GetProperty", $null, $grp, $null)
                path = $grp.GetType().InvokeMember("ADsPath", "GetProperty", $null, $grp, $null)
            }
            $user_groups += $group_result;
        }
        $result.groups = $user_groups
        $result.state = "present"
    }
    Else {
        $result.name = $username
        if ($state -eq 'query') {
            $result.msg = "User '$username' was not found"
        }
        $result.state = "absent"
    }
}
catch {
    Fail-Json $result $_.Exception.Message
#!powershell

# Copyright: (c) 2015, Paul Durivage <paul.durivage@rackspace.com>
# Copyright: (c) 2015, Tal Auslander <tal@cloudshare.com>
# Copyright: (c) 2017, Dag Wieers <dag@wieers.com>
# Copyright: (c) 2019, Viktor Utkin <viktor_utkin@epam.com>
# Copyright: (c) 2019, Uladzimir Klybik <uladzimir_klybik@epam.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#Requires -Module Ansible.ModuleUtils.FileUtil
#Requires -Module Ansible.ModuleUtils.WebRequest

$spec = @{
    options = @{
        url = @{ type="str"; required=$true }
        dest = @{ type='path'; required=$true }
        force = @{ type='bool'; default=$true }
        checksum = @{ type='str' }
        checksum_algorithm = @{ type='str'; default='sha1'; choices = @("md5", "sha1", "sha256", "sha384", "sha512") }
        checksum_url = @{ type='str' }

       # Defined for the alias backwards compatibility, remove once aliases are removed
       url_username = @{
           aliases = @("user", "username")
           deprecated_aliases = @(
               @{ name = "user"; version = "2.14" },
               @{ name = "username"; version = "2.14" }
           )
       }
       url_password = @{
           aliases = @("password")
           deprecated_aliases = @(
               @{ name = "password"; version = "2.14" }
           )
       }
    }
    mutually_exclusive = @(
        ,@('checksum', 'checksum_url')
    )
    supports_check_mode = $true
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec, @(Get-AnsibleWebRequestSpec))

$url = $module.Params.url
$dest = $module.Params.dest
$force = $module.Params.force
$checksum = $module.Params.checksum
$checksum_algorithm = $module.Params.checksum_algorithm
$checksum_url = $module.Params.checksum_url

$module.Result.elapsed = 0
$module.Result.url = $url

Function Get-ChecksumFromUri {
    param(
        [Parameter(Mandatory=$true)][Ansible.Basic.AnsibleModule]$Module,
        [Parameter(Mandatory=$true)][Uri]$Uri,
        [Uri]$SourceUri
    )

    $script = {
        param($Response, $Stream)

        $read_stream = New-Object -TypeName System.IO.StreamReader -ArgumentList $Stream
        $web_checksum = $read_stream.ReadToEnd()
        $basename = (Split-Path -Path $SourceUri.LocalPath -Leaf)
        $basename = [regex]::Escape($basename)
        $web_checksum_str = $web_checksum -split '\r?\n' | Select-String -Pattern $("\s+\.?\/?\\?" + $basename + "\s*$")
        if (-not $web_checksum_str) {
            $Module.FailJson("Checksum record not found for file name '$basename' in file from url: '$Uri'")
        }

        $web_checksum_str_splitted = $web_checksum_str[0].ToString().split(" ", 2)
        $hash_from_file = $web_checksum_str_splitted[0].Trim()
        # Remove any non-alphanumeric characters
        $hash_from_file = $hash_from_file -replace '\W+', ''

        Write-Output -InputObject $hash_from_file
    }
    $web_request = Get-AnsibleWebRequest -Uri $Uri -Module $Module

    try {
        Invoke-WithWebRequest -Module $Module -Request $web_request -Script $script
    } catch {
        $Module.FailJson("Error when getting the remote checksum from '$Uri'. $($_.Exception.Message)", $_)
    }
}

Function Compare-ModifiedFile {
    <#
    .SYNOPSIS
    Compares the remote URI resource against the local Dest resource. Will
    return true if the LastWriteTime/LastModificationDate of the remote is
    newer than the local resource date.
    #>
    param(
        [Parameter(Mandatory=$true)][Ansible.Basic.AnsibleModule]$Module,
        [Parameter(Mandatory=$true)][Uri]$Uri,
        [Parameter(Mandatory=$true)][String]$Dest
    )

    $dest_last_mod = (Get-AnsibleItem -Path $Dest).LastWriteTimeUtc

    # If the URI is a file we don't need to go through the whole WebRequest
    if ($Uri.IsFile) {
        $src_last_mod = (Get-AnsibleItem -Path $Uri.AbsolutePath).LastWriteTimeUtc
    } else {
        $web_request = Get-AnsibleWebRequest -Uri $Uri -Module $Module
        $web_request.Method = switch ($web_request.GetType().Name) {
            FtpWebRequest { [System.Net.WebRequestMethods+Ftp]::GetDateTimestamp }
            HttpWebRequest { [System.Net.WebRequestMethods+Http]::Head }
        }
        $script = { param($Response, $Stream); $Response.LastModified }

        try {
            $src_last_mod = Invoke-WithWebRequest -Module $Module -Request $web_request -Script $script
        } catch {
            $Module.FailJson("Error when requesting 'Last-Modified' date from '$Uri'. $($_.Exception.Message)", $_)
        }
    }

    # Return $true if the Uri LastModification date is newer than the Dest LastModification date
    ((Get-Date -Date $src_last_mod).ToUniversalTime() -gt $dest_last_mod)
}

Function Get-Checksum {
    param(
        [Parameter(Mandatory=$true)][String]$Path,
        [String]$Algorithm = "sha1"
    )

    switch ($Algorithm) {
        'md5' { $sp = New-Object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider }
        'sha1' { $sp = New-Object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider }
        'sha256' { $sp = New-Object -TypeName System.Security.Cryptography.SHA256CryptoServiceProvider }
        'sha384' { $sp = New-Object -TypeName System.Security.Cryptography.SHA384CryptoServiceProvider }
        'sha512' { $sp = New-Object -TypeName System.Security.Cryptography.SHA512CryptoServiceProvider }
    }

    $fs = [System.IO.File]::Open($Path, [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read,
        [System.IO.FileShare]::ReadWrite)
    try {
        $hash = [System.BitConverter]::ToString($sp.ComputeHash($fs)).Replace("-", "").ToLower()
    } finally {
        $fs.Dispose()
    }
    return $hash
}

Function Invoke-DownloadFile {
    param(
        [Parameter(Mandatory=$true)][Ansible.Basic.AnsibleModule]$Module,
        [Parameter(Mandatory=$true)][Uri]$Uri,
        [Parameter(Mandatory=$true)][String]$Dest,
        [String]$Checksum,
        [String]$ChecksumAlgorithm
    )

    # Check $dest parent folder exists before attempting download, which avoids unhelpful generic error message.
    $dest_parent = Split-Path -LiteralPath $Dest
    if (-not (Test-Path -LiteralPath $dest_parent -PathType Container)) {
        $module.FailJson("The path '$dest_parent' does not exist for destination '$Dest', or is not visible to the current user.  Ensure download destination folder exists (perhaps using win_file state=directory) before win_get_url runs.")
    }

    $download_script = {
        param($Response, $Stream)

        # Download the file to a temporary directory so we can compare it
        $tmp_dest = Join-Path -Path $Module.Tmpdir -ChildPath ([System.IO.Path]::GetRandomFileName())
        $fs = [System.IO.File]::Create($tmp_dest)
        try {
            $Stream.CopyTo($fs)
            $fs.Flush()
        } finally {
            $fs.Dispose()
        }
        $tmp_checksum = Get-Checksum -Path $tmp_dest -Algorithm $ChecksumAlgorithm
        $Module.Result.checksum_src = $tmp_checksum

        # If the checksum has been set, verify the checksum of the remote against the input checksum.
        if ($Checksum -and $Checksum -ne $tmp_checksum) {
            $Module.FailJson(("The checksum for {0} did not match '{1}', it was '{2}'" -f $Uri, $Checksum, $tmp_checksum))
        }

        $download = $true
        if (Test-Path -LiteralPath $Dest) {
            # Validate the remote checksum against the existing downloaded file
            $dest_checksum = Get-Checksum -Path $Dest -Algorithm $ChecksumAlgorithm

            # If we don't need to download anything, save the dest checksum so we don't waste time calculating it
            # again at the end of the script
            if ($dest_checksum -eq $tmp_checksum) {
                $download = $false
                $Module.Result.checksum_dest = $dest_checksum
                $Module.Result.size = (Get-AnsibleItem -Path $Dest).Length
            }
        }

        if ($download) {
            Copy-Item -LiteralPath $tmp_dest -Destination $Dest -Force -WhatIf:$Module.CheckMode > $null
            $Module.Result.changed = $true
        }
    }
    $web_request = Get-AnsibleWebRequest -Uri $Uri -Module $Module

    try {
        Invoke-WithWebRequest -Module $Module -Request $web_request -Script $download_script
    } catch {
        $Module.FailJson("Error downloading '$Uri' to '$Dest': $($_.Exception.Message)", $_)
    }
}

# Use last part of url for dest file name if a directory is supplied for $dest
if (Test-Path -LiteralPath $dest -PathType Container) {
    $uri = [System.Uri]$url
    $basename = Split-Path -Path $uri.LocalPath -Leaf
    if ($uri.LocalPath -and $uri.LocalPath -ne '/' -and $basename) {
        $url_basename = Split-Path -Path $uri.LocalPath -Leaf
        $dest = Join-Path -Path $dest -ChildPath $url_basename
    } else {
        $dest = Join-Path -Path $dest -ChildPath $uri.Host
    }

    # Ensure we have a string instead of a PS object to avoid serialization issues
    $dest = $dest.ToString()
} elseif (([System.IO.Path]::GetFileName($dest)) -eq '') {
    # We have a trailing path separator
    $module.FailJson("The destination path '$dest' does not exist, or is not visible to the current user.  Ensure download destination folder exists (perhaps using win_file state=directory) before win_get_url runs.")
}

$module.Result.dest = $dest

if ($checksum) {
    $checksum = $checksum.Trim().ToLower()
}
if ($checksum_algorithm) {
    $checksum_algorithm = $checksum_algorithm.Trim().ToLower()
}
if ($checksum_url) {
    $checksum_url = $checksum_url.Trim()
}

# Check for case $checksum variable contain url. If yes, get file data from url and replace original value in $checksum
if ($checksum_url) {
    $checksum_uri = [System.Uri]$checksum_url
    if ($checksum_uri.Scheme -notin @("file", "ftp", "http", "https")) {
        $module.FailJson("Unsupported 'checksum_url' value for '$dest': '$checksum_url'")
    }

    $checksum = Get-ChecksumFromUri -Module $Module -Uri $checksum_uri -SourceUri $url
}

if ($force -or -not (Test-Path -LiteralPath $dest)) {
    # force=yes or dest does not exist, download the file
    # Note: Invoke-DownloadFile will compare the checksums internally if dest exists
    Invoke-DownloadFile -Module $module -Uri $url -Dest $dest -Checksum $checksum `
        -ChecksumAlgorithm $checksum_algorithm
} else {
    # force=no, we want to check the last modified dates and only download if they don't match
    $is_modified = Compare-ModifiedFile -Module $module -Uri $url -Dest $dest
    if ($is_modified) {
        Invoke-DownloadFile -Module $module -Uri $url -Dest $dest -Checksum $checksum `
            -ChecksumAlgorithm $checksum_algorithm
   }
}

if ((-not $module.Result.ContainsKey("checksum_dest")) -and (Test-Path -LiteralPath $dest)) {
    # Calculate the dest file checksum if it hasn't already been done
    $module.Result.checksum_dest = Get-Checksum -Path $dest -Algorithm $checksum_algorithm
#!powershell

# Copyright: (c) 2015, Trond Hindenes <trond@hindenes.com>, and others
# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic
#Requires -Version 5

Function ConvertTo-ArgSpecType {
    <#
    .SYNOPSIS
    Converts the DSC parameter type to the arg spec type required for Ansible.
    #>
    param(
        [Parameter(Mandatory=$true)][String]$CimType
    )

    $arg_type = switch($CimType) {
        Boolean { "bool" }
        Char16 { [Func[[Object], [Char]]]{ [System.Char]::Parse($args[0].ToString()) } }
        DateTime { [Func[[Object], [DateTime]]]{ [System.DateTime]($args[0].ToString()) } }
        Instance { "dict" }
        Real32 { "float" }
        Real64 { [Func[[Object], [Double]]]{ [System.Double]::Parse($args[0].ToString()) } }
        Reference { "dict" }
        SInt16 { [Func[[Object], [Int16]]]{ [System.Int16]::Parse($args[0].ToString()) } }
        SInt32 { "int" }
        SInt64 { [Func[[Object], [Int64]]]{ [System.Int64]::Parse($args[0].ToString()) } }
        SInt8 { [Func[[Object], [SByte]]]{ [System.SByte]::Parse($args[0].ToString()) } }
        String { "str" }
        UInt16 { [Func[[Object], [UInt16]]]{ [System.UInt16]::Parse($args[0].ToString()) } }
        UInt32 { [Func[[Object], [UInt32]]]{ [System.UInt32]::Parse($args[0].ToString()) } }
        UInt64 { [Func[[Object], [UInt64]]]{ [System.UInt64]::Parse($args[0].ToString()) } }
        UInt8 { [Func[[Object], [Byte]]]{ [System.Byte]::Parse($args[0].ToString()) } }
        Unknown { "raw" }
        default { "raw" }
    }
    return $arg_type
}

Function Get-DscCimClassProperties {
    <#
    .SYNOPSIS
    Get's a list of CimProperties of a CIM Class. It filters out any magic or
    read only properties that we don't need to know about.
    #>
    param([Parameter(Mandatory=$true)][String]$ClassName)

    $resource = Get-CimClass -ClassName $ClassName -Namespace root\Microsoft\Windows\DesiredStateConfiguration

    # Filter out any magic properties that are used internally on an OMI_BaseResource
    # https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/DscSupport/CimDSCParser.cs#L1203
    $magic_properties = @("ResourceId", "SourceInfo", "ModuleName", "ModuleVersion", "ConfigurationName")
    $properties = $resource.CimClassProperties | Where-Object {

        ($resource.CimSuperClassName -ne "OMI_BaseResource" -or $_.Name -notin $magic_properties) -and
        -not $_.Flags.HasFlag([Microsoft.Management.Infrastructure.CimFlags]::ReadOnly)
    }

    return ,$properties
}

Function Add-PropertyOption {
    <#
    .SYNOPSIS
    Adds the spec for the property type to the existing module specification.
    #>
    param(
        [Parameter(Mandatory=$true)][Hashtable]$Spec,
        [Parameter(Mandatory=$true)]
        [Microsoft.Management.Infrastructure.CimPropertyDeclaration]$Property
    )

    $option = @{
        required = $false
    }
    $property_name = $Property.Name
    $property_type = $Property.CimType.ToString()

    if ($Property.Flags.HasFlag([Microsoft.Management.Infrastructure.CimFlags]::Key) -or
        $Property.Flags.HasFlag([Microsoft.Management.Infrastructure.CimFlags]::Required)) {
        $option.required = $true
    }

    if ($null -ne $Property.Qualifiers['Values']) {
        $option.choices = [System.Collections.Generic.List`1[Object]]$Property.Qualifiers['Values'].Value
    }

    if ($property_name -eq "Name") {
        # For backwards compatibility we support specifying the Name DSC property as item_name
        $option.aliases = @("item_name")
    } elseif ($property_name -ceq "key") {
        # There seems to be a bug in the CIM property parsing when the property name is 'Key'. The CIM instance will
        # think the name is 'key' when the MOF actually defines it as 'Key'. We set the proper casing so the module arg
        # validator won't fire a case sensitive warning
        $property_name = "Key"
    }

    if ($Property.ReferenceClassName -eq "MSFT_Credential") {
        # Special handling for the MSFT_Credential type (PSCredential), we handle this with having 2 options that
        # have the suffix _username and _password.
        $option_spec_pass = @{
            type = "str"
            required = $option.required
            no_log = $true
        }
        $Spec.options."$($property_name)_password" = $option_spec_pass
        $Spec.required_together.Add(@("$($property_name)_username", "$($property_name)_password")) > $null

        $property_name = "$($property_name)_username"
        $option.type = "str"
    } elseif ($Property.ReferenceClassName -eq "MSFT_KeyValuePair") {
        $option.type = "dict"
    } elseif ($property_type.EndsWith("Array")) {
        $option.type = "list"
        $option.elements = ConvertTo-ArgSpecType -CimType $property_type.Substring(0, $property_type.Length - 5)
    } else {
        $option.type = ConvertTo-ArgSpecType -CimType $property_type
    }

    if (($option.type -eq "dict" -or ($option.type -eq "list" -and $option.elements -eq "dict")) -and
            $Property.ReferenceClassName -ne "MSFT_KeyValuePair") {
        # Get the sub spec if the type is a Instance (CimInstance/dict)
        $sub_option_spec = Get-OptionSpec -ClassName $Property.ReferenceClassName
        $option += $sub_option_spec
    }

    $Spec.options.$property_name = $option
}

Function Get-OptionSpec {
    <#
    .SYNOPSIS
    Generates the specifiec used in AnsibleModule for a CIM MOF resource name.

    .NOTES
    This won't be able to retrieve the default values for an option as that is not defined in the MOF for a resource.
    Default values are still preserved in the DSC engine if we don't pass in the property at all, we just can't report
    on what they are automatically.
    #>
    param(
        [Parameter(Mandatory=$true)][String]$ClassName
    )

    $spec = @{
        options = @{}
        required_together = [System.Collections.ArrayList]@()
    }
    $properties = Get-DscCimClassProperties -ClassName $ClassName
    foreach ($property in $properties) {
        Add-PropertyOption -Spec $spec -Property $property
    }

    return $spec
}

Function ConvertTo-CimInstance {
    <#
    .SYNOPSIS
    Converts a dict to a CimInstance of the specified Class. Also provides a
    better error message if this fails that contains the option name that failed.
    #>
    param(
        [Parameter(Mandatory=$true)][String]$Name,
        [Parameter(Mandatory=$true)][String]$ClassName,
        [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Value,
        [Parameter(Mandatory=$true)][Ansible.Basic.AnsibleModule]$Module,
        [Switch]$Recurse
    )

    $properties = @{}
    foreach ($value_info in $Value.GetEnumerator()) {
        # Need to remove all null values from existing dict so the conversion works
        if ($null -eq $value_info.Value) {
            continue
        }
        $properties.($value_info.Key) = $value_info.Value
    }

    if ($Recurse) {
        # We want to validate and convert and values to what's required by DSC
        $properties = ConvertTo-DscProperty -ClassName $ClassName -Params $properties -Module $Module
    }

    try {
        return (New-CimInstance -ClassName $ClassName -Property $properties -ClientOnly)
    } catch {
        # New-CimInstance raises a poor error message, make sure we mention what option it is for
        $Module.FailJson("Failed to cast dict value for option '$Name' to a CimInstance: $($_.Exception.Message)", $_)
    }
}

Function ConvertTo-DscProperty {
    <#
    .SYNOPSIS
    Converts the input module parameters that have been validated and casted
    into the types expected by the DSC engine. This is mostly done to deal with
    types like PSCredential and Dictionaries.
    #>
    param(
        [Parameter(Mandatory=$true)][String]$ClassName,
        [Parameter(Mandatory=$true)][System.Collections.IDictionary]$Params,
        [Parameter(Mandatory=$true)][Ansible.Basic.AnsibleModule]$Module
    )
    $properties = Get-DscCimClassProperties -ClassName $ClassName

    $dsc_properties = @{}
    foreach ($property in $properties) {
        $property_name = $property.Name
        $property_type = $property.CimType.ToString()

        if ($property.ReferenceClassName -eq "MSFT_Credential") {
            $username = $Params."$($property_name)_username"
            $password = $Params."$($property_name)_password"

            # No user set == No option set in playbook, skip this property
            if ($null -eq $username) {
                continue
            }
            $sec_password = ConvertTo-SecureString -String $password -AsPlainText -Force
            $value = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $username, $sec_password
        } else {
            $value = $Params.$property_name

            # The actual value wasn't set, skip adding this property
            if ($null -eq $value) {
                continue
            }

            if ($property.ReferenceClassName -eq "MSFT_KeyValuePair") {
                $key_value_pairs = [System.Collections.Generic.List`1[CimInstance]]@()
                foreach ($value_info in $value.GetEnumerator()) {
                    $kvp = @{Key = $value_info.Key; Value = $value_info.Value.ToString()}
                    $cim_instance = ConvertTo-CimInstance -Name $property_name -ClassName MSFT_KeyValuePair `
                        -Value $kvp -Module $Module
                    $key_value_pairs.Add($cim_instance) > $null
                }
                $value = $key_value_pairs.ToArray()
            } elseif ($null -ne $property.ReferenceClassName) {
                # Convert the dict to a CimInstance (or list of CimInstances)
                $convert_args = @{
                    ClassName = $property.ReferenceClassName
                    Module = $Module
                    Name = $property_name
                    Recurse = $true
                }
                if ($property_type.EndsWith("Array")) {
                    $value = [System.Collections.Generic.List`1[CimInstance]]@()
                    foreach ($raw in $Params.$property_name.GetEnumerator()) {
                        $cim_instance = ConvertTo-CimInstance -Value $raw @convert_args
                        $value.Add($cim_instance) > $null
                    }
                    $value = $value.ToArray()  # Need to make sure we are dealing with an Array not a List
                } else {
                    $value = ConvertTo-CimInstance -Value $value @convert_args
                }
            }
        }
        $dsc_properties.$property_name = $value
    }

    return $dsc_properties
}

Function Invoke-DscMethod {
    <#
    .SYNOPSIS
    Invokes the DSC Resource Method specified in another PS pipeline. This is
    done so we can retrieve the Verbose stream and return it back to the user
    for futher debugging.
    #>
    param(
        [Parameter(Mandatory=$true)][Ansible.Basic.AnsibleModule]$Module,
        [Parameter(Mandatory=$true)][String]$Method,
        [Parameter(Mandatory=$true)][Hashtable]$Arguments
    )

    # Invoke the DSC resource in a separate runspace so we can capture the Verbose output
    $ps = [PowerShell]::Create()
    $ps.AddCommand("Invoke-DscResource").AddParameter("Method", $Method) > $null
    $ps.AddParameters($Arguments) > $null

    $result = $ps.Invoke()

    # Pass the warnings through to the AnsibleModule return result
    foreach ($warning in $ps.Streams.Warning) {
        $Module.Warn($warning.Message)
    }

    # If running at a high enough verbosity, add the verbose output to the AnsibleModule return result
    if ($Module.Verbosity -ge 3) {
        $verbose_logs = [System.Collections.Generic.List`1[String]]@()
        foreach ($verbosity in $ps.Streams.Verbose) {
            $verbose_logs.Add($verbosity.Message) > $null
        }
        $Module.Result."verbose_$($Method.ToLower())" = $verbose_logs
    }

    if ($ps.HadErrors) {
        # Cannot pass in the ErrorRecord as it's a RemotingErrorRecord and doesn't contain the ScriptStackTrace
        # or other info that would be useful
        $Module.FailJson("Failed to invoke DSC $Method method: $($ps.Streams.Error[0].Exception.Message)")
    }

    return $result
}

# win_dsc is unique in that is builds the arg spec based on DSC Resource input. To get this info
# we need to read the resource_name and module_version value which is done outside of Ansible.Basic
if ($args.Length -gt 0) {
    $params = Get-Content -Path $args[0] | ConvertFrom-Json
} else {
    $params = $complex_args
}
if (-not $params.ContainsKey("resource_name")) {
    $res = @{
        msg = "missing required argument: resource_name"
        failed = $true
    }
    Write-Output -InputObject (ConvertTo-Json -Compress -InputObject $res)
    exit 1
}
$resource_name = $params.resource_name

if ($params.ContainsKey("module_version")) {
    $module_version = $params.module_version
} else {
    $module_version = "latest"
}

$module_versions = (Get-DscResource -Name $resource_name -ErrorAction SilentlyContinue | Sort-Object -Property Version)
$resource = $null
if ($module_version -eq "latest" -and $null -ne $module_versions) {
    $resource = $module_versions[-1]
} elseif ($module_version -ne "latest") {
    $resource = $module_versions | Where-Object { $_.Version -eq $module_version }
}

if (-not $resource) {
    if ($module_version -eq "latest") {
        $msg = "Resource '$resource_name' not found."
    } else {
        $msg = "Resource '$resource_name' with version '$module_version' not found."
        $msg += " Versions installed: '$($module_versions.Version -join "', '")'."
    }

    Write-Output -InputObject (ConvertTo-Json -Compress -InputObject @{ failed = $true; msg = $msg })
    exit 1
}

# Build the base args for the DSC Invocation based on the resource selected
$dsc_args = @{
    Name = $resource.Name
}

# Binary resources are not working very well with that approach - need to guesstimate module name/version
$module_version = $null
if ($resource.Module) {
    $dsc_args.ModuleName = @{
        ModuleName = $resource.Module.Name
        ModuleVersion = $resource.Module.Version
    }
    $module_version = $resource.Module.Version.ToString()
} else {
    $dsc_args.ModuleName = "PSDesiredStateConfiguration"
}

# To ensure the class registered with CIM is the one based on our version, we want to run the Get method so the DSC
# engine updates the metadata propery. We don't care about any errors here
try {
    Invoke-DscResource -Method Get -Property @{Fake="Fake"} @dsc_args > $null
} catch {}

# Dynamically build the option spec based on the resource_name specified and create the module object
$spec = Get-OptionSpec -ClassName $resource.ResourceType
$spec.supports_check_mode = $true
$spec.options.module_version = @{ type = "str"; default = "latest" }
$spec.options.resource_name = @{ type = "str"; required = $true }

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)
$module.Result.reboot_required = $false
$module.Result.module_version = $module_version

# Build the DSC invocation arguments and invoke the resource
$dsc_args.Property = ConvertTo-DscProperty -ClassName $resource.ResourceType -Module $module -Params $Module.Params
$dsc_args.Verbose = $true

$test_result = Invoke-DscMethod -Module $module -Method Test -Arguments $dsc_args
if ($test_result.InDesiredState -ne $true) {
    if (-not $module.CheckMode) {
        $result = Invoke-DscMethod -Module $module -Method Set -Arguments $dsc_args
        $module.Result.reboot_required = $result.RebootRequired
    }
    $module.Result.changed = $true
#!powershell

# Copyright: (c) 2014, Paul Durivage <paul.durivage@rackspace.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy

Import-Module -Name ServerManager

$result = @{
    changed = $false
}

$params = Parse-Args $args -supports_check_mode $true
$check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -type "bool" -default $false

$name = Get-AnsibleParam -obj $params -name "name" -type "list" -failifempty $true
$state = Get-AnsibleParam -obj $params -name "state" -type "str" -default "present" -validateset "present","absent"

$include_sub_features = Get-AnsibleParam -obj $params -name "include_sub_features" -type "bool" -default $false
$include_management_tools = Get-AnsibleParam -obj $params -name "include_management_tools" -type "bool" -default $false
$source = Get-AnsibleParam -obj $params -name "source" -type "str"

$install_cmdlet = $false
if (Get-Command -Name Install-WindowsFeature -ErrorAction SilentlyContinue) {
    Set-Alias -Name Install-AnsibleWindowsFeature -Value Install-WindowsFeature
    Set-Alias -Name Uninstall-AnsibleWindowsFeature -Value Uninstall-WindowsFeature
    $install_cmdlet = $true
} elseif (Get-Command -Name Add-WindowsFeature -ErrorAction SilentlyContinue) {
    Set-Alias -Name Install-AnsibleWindowsFeature -Value Add-WindowsFeature
    Set-Alias -Name Uninstall-AnsibleWindowsFeature -Value Remove-WindowsFeature
} else {
    Fail-Json -obj $result -message "This version of Windows does not support the cmdlets Install-WindowsFeature or Add-WindowsFeature"
}

if ($state -eq "present") {
    $install_args = @{
        Name = $name
        IncludeAllSubFeature = $include_sub_features
        Restart = $false
        WhatIf = $check_mode
        ErrorAction = "Stop"
    }

    if ($install_cmdlet) {
        $install_args.IncludeManagementTools = $include_management_tools
        $install_args.Confirm = $false
        if ($source) {
            if (-not (Test-Path -Path $source)) {
                Fail-Json -obj $result -message "Failed to find source path $source for feature install"
            }
            $install_args.Source = $source
        }
    }

    try {
        $action_results = Install-AnsibleWindowsFeature @install_args
    } catch {
        Fail-Json -obj $result -message "Failed to install Windows Feature: $($_.Exception.Message)"
    }
} else {
    $uninstall_args = @{
        Name = $name
        Restart = $false
        WhatIf = $check_mode
        ErrorAction = "Stop"
    }
    if ($install_cmdlet) {
        $uninstall_args.IncludeManagementTools = $include_management_tools
    }

    try {
        $action_results = Uninstall-AnsibleWindowsFeature @uninstall_args
    } catch {
        Fail-Json -obj $result -message "Failed to uninstall Windows Feature: $($_.Exception.Message)"
    }
}

# Loop through results and create a hash containing details about
# each role/feature that is installed/removed
# $action_results.FeatureResult is not empty if anything was changed
$feature_results = @()
foreach ($action_result in $action_results.FeatureResult) {
    $message = @()
    foreach ($msg in $action_result.Message) {
        $message += @{
            message_type = $msg.MessageType.ToString()
            error_code = $msg.ErrorCode
            text = $msg.Text
        }
    }

    $feature_results += @{
        id = $action_result.Id
        display_name = $action_result.DisplayName
        message = $message
        reboot_required = ConvertTo-Bool -obj $action_result.RestartNeeded
        skip_reason = $action_result.SkipReason.ToString()
        success = ConvertTo-Bool -obj $action_result.Success
        restart_needed = ConvertTo-Bool -obj $action_result.RestartNeeded
    }
    $result.changed = $true
}
$result.feature_result = $feature_results
$result.success = ConvertTo-Bool -obj $action_results.Success
$result.exitcode = $action_results.ExitCode.ToString()
$result.reboot_required = ConvertTo-Bool -obj $action_results.RestartNeeded
# controls whether Ansible will fail or not
$result.failed = (-not $action_results.Success)

#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy

$ErrorActionPreference = "Stop"

$params = Parse-Args $args -supports_check_mode $true

$check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -default $false
$_remote_tmp = Get-AnsibleParam $params "_ansible_remote_tmp" -type "path" -default $env:TMP

$path = Get-AnsibleParam -obj $params -name "path" -type "path" -failifempty $true -aliases "dest","name"
$state = Get-AnsibleParam -obj $params -name "state" -type "str" -validateset "absent","directory","file","touch"

# used in template/copy when dest is the path to a dir and source is a file
$original_basename = Get-AnsibleParam -obj $params -name "_original_basename" -type "str"
if ((Test-Path -LiteralPath $path -PathType Container) -and ($null -ne $original_basename)) {
    $path = Join-Path -Path $path -ChildPath $original_basename
}

$result = @{
    changed = $false
}

# Used to delete symlinks as powershell cannot delete broken symlinks
$symlink_util = @"
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;

namespace Ansible.Command {
    public class SymLinkHelper {
        [DllImport("kernel32.dll", CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern bool DeleteFileW(string lpFileName);

        [DllImport("kernel32.dll", CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern bool RemoveDirectoryW(string lpPathName);

        public static void DeleteDirectory(string path) {
            if (!RemoveDirectoryW(path))
                throw new Exception(String.Format("RemoveDirectoryW({0}) failed: {1}", path, new Win32Exception(Marshal.GetLastWin32Error()).Message));
        }

        public static void DeleteFile(string path) {
            if (!DeleteFileW(path))
                throw new Exception(String.Format("DeleteFileW({0}) failed: {1}", path, new Win32Exception(Marshal.GetLastWin32Error()).Message));
        }
    }
}
"@
$original_tmp = $env:TMP
$env:TMP = $_remote_tmp
Add-Type -TypeDefinition $symlink_util
$env:TMP = $original_tmp

# Used to delete directories and files with logic on handling symbolic links
function Remove-File($file, $checkmode) {
    try {
        if ($file.Attributes -band [System.IO.FileAttributes]::ReparsePoint) {
            # Bug with powershell, if you try and delete a symbolic link that is pointing
            # to an invalid path it will fail, using Win32 API to do this instead
            if ($file.PSIsContainer) {
                if (-not $checkmode) {
                    [Ansible.Command.SymLinkHelper]::DeleteDirectory($file.FullName)
                }
            } else {
                if (-not $checkmode) {
                    [Ansible.Command.SymlinkHelper]::DeleteFile($file.FullName)
                }
            }
        } elseif ($file.PSIsContainer) {
            Remove-Directory -directory $file -checkmode $checkmode
        } else {
            Remove-Item -LiteralPath $file.FullName -Force -WhatIf:$checkmode
        }
    } catch [Exception] {
        Fail-Json $result "Failed to delete $($file.FullName): $($_.Exception.Message)"
    }
}

function Remove-Directory($directory, $checkmode) {
    foreach ($file in Get-ChildItem -LiteralPath $directory.FullName) {
        Remove-File -file $file -checkmode $checkmode
    }
    Remove-Item -LiteralPath $directory.FullName -Force -Recurse -WhatIf:$checkmode
}


if ($state -eq "touch") {
    if (Test-Path -LiteralPath $path) {
        if (-not $check_mode) {
            (Get-ChildItem -LiteralPath $path).LastWriteTime = Get-Date
        }
        $result.changed = $true
    } else {
        Write-Output $null | Out-File -LiteralPath $path -Encoding ASCII -WhatIf:$check_mode
        $result.changed = $true
    }
}

if (Test-Path -LiteralPath $path) {
    $fileinfo = Get-Item -LiteralPath $path -Force
    if ($state -eq "absent") {
        Remove-File -file $fileinfo -checkmode $check_mode
        $result.changed = $true
    } else {
        if ($state -eq "directory" -and -not $fileinfo.PsIsContainer) {
            Fail-Json $result "path $path is not a directory"
        }

        if ($state -eq "file" -and $fileinfo.PsIsContainer) {
            Fail-Json $result "path $path is not a file"
        }
    }

} else {

    # If state is not supplied, test the $path to see if it looks like
    # a file or a folder and set state to file or folder
    if ($null -eq $state) {
        $basename = Split-Path -Path $path -Leaf
        if ($basename.length -gt 0) {
           $state = "file"
        } else {
           $state = "directory"
        }
    }

    if ($state -eq "directory") {
        try {
            New-Item -Path $path -ItemType Directory -WhatIf:$check_mode | Out-Null
        } catch {
            if ($_.CategoryInfo.Category -eq "ResourceExists") {
                $fileinfo = Get-Item -LiteralPath $_.CategoryInfo.TargetName
                if ($state -eq "directory" -and -not $fileinfo.PsIsContainer) {
                    Fail-Json $result "path $path is not a directory"
                }
            } else {
                Fail-Json $result $_.Exception.Message
            }
        }
        $result.changed = $true
    } elseif ($state -eq "file") {
        Fail-Json $result "path $path will not be created"
    }

}
#!powershell

# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.Backup

function WriteLines($outlines, $path, $linesep, $encodingobj, $validate, $check_mode) {
	Try {
		$temppath = [System.IO.Path]::GetTempFileName();
	}
	Catch {
		Fail-Json @{} "Cannot create temporary file! ($($_.Exception.Message))";
	}
	$joined = $outlines -join $linesep;
	[System.IO.File]::WriteAllText($temppath, $joined, $encodingobj);

	If ($validate) {

		If (-not ($validate -like "*%s*")) {
			Fail-Json @{} "validate must contain %s: $validate";
		}

		$validate = $validate.Replace("%s", $temppath);

		$parts = [System.Collections.ArrayList] $validate.Split(" ");
		$cmdname = $parts[0];

		$cmdargs = $validate.Substring($cmdname.Length + 1);

		$process = [Diagnostics.Process]::Start($cmdname, $cmdargs);
		$process.WaitForExit();

		If ($process.ExitCode -ne 0) {
			[string] $output = $process.StandardOutput.ReadToEnd();
			[string] $error = $process.StandardError.ReadToEnd();
			Remove-Item $temppath -force;
			Fail-Json @{} "failed to validate $cmdname $cmdargs with error: $output $error";
		}

	}

	# Commit changes to the path
	$cleanpath = $path.Replace("/", "\");
	Try {
		Copy-Item -Path $temppath -Destination $cleanpath -Force -WhatIf:$check_mode;
	}
	Catch {
		Fail-Json @{} "Cannot write to: $cleanpath ($($_.Exception.Message))";
	}

	Try {
		Remove-Item -Path $temppath -Force -WhatIf:$check_mode;
	}
	Catch {
		Fail-Json @{} "Cannot remove temporary file: $temppath ($($_.Exception.Message))";
	}

	return $joined;

}


# Implement the functionality for state == 'present'
function Present($path, $regex, $line, $insertafter, $insertbefore, $create, $backup, $backrefs, $validate, $encodingobj, $linesep, $check_mode, $diff_support) {

	# Note that we have to clean up the path because ansible wants to treat / and \ as
	# interchangeable in windows pathnames, but .NET framework internals do not support that.
	$cleanpath = $path.Replace("/", "\");

	# Check if path exists. If it does not exist, either create it if create == "yes"
	# was specified or fail with a reasonable error message.
	If (-not (Test-Path -LiteralPath $path)) {
		If (-not $create) {
			Fail-Json @{} "Path $path does not exist !";
		}
		# Create new empty file, using the specified encoding to write correct BOM
		[System.IO.File]::WriteAllLines($cleanpath, "", $encodingobj);
	}

	# Initialize result information
	$result = @{
		backup = "";
		changed = $false;
		msg = "";
	}

	# Read the dest file lines using the indicated encoding into a mutable ArrayList.
	$before = [System.IO.File]::ReadAllLines($cleanpath, $encodingobj)
	If ($null -eq $before) {
		$lines = New-Object System.Collections.ArrayList;
	}
	Else {
		$lines = [System.Collections.ArrayList] $before;
	}

	if ($diff_support) {
		$result.diff = @{
			before = $before -join $linesep;
		}
	}

	# Compile the regex specified, if provided
	$mre = $null;
	If ($regex) {
		$mre = New-Object Regex $regex, 'Compiled';
	}

	# Compile the regex for insertafter or insertbefore, if provided
	$insre = $null;
	If ($insertafter -and $insertafter -ne "BOF" -and $insertafter -ne "EOF") {
		$insre = New-Object Regex $insertafter, 'Compiled';
	}
	ElseIf ($insertbefore -and $insertbefore -ne "BOF") {
		$insre = New-Object Regex $insertbefore, 'Compiled';
	}

	# index[0] is the line num where regex has been found
	# index[1] is the line num where insertafter/insertbefore has been found
	$index = -1, -1;
	$lineno = 0;

	# The latest match object and matched line
	$matched_line = "";

	# Iterate through the lines in the file looking for matches
	Foreach ($cur_line in $lines) {
		If ($regex) {
			$m = $mre.Match($cur_line);
			$match_found = $m.Success;
			If ($match_found) {
				$matched_line = $cur_line;
			}
		}
		Else {
			$match_found = $line -ceq $cur_line;
		}
		If ($match_found) {
			$index[0] = $lineno;
		}
		ElseIf ($insre -and $insre.Match($cur_line).Success) {
			If ($insertafter) {
				$index[1] = $lineno + 1;
			}
			If ($insertbefore) {
				$index[1] = $lineno;
			}
		}
		$lineno = $lineno + 1;
	}

	If ($index[0] -ne -1) {
		If ($backrefs) {
		    $new_line = [regex]::Replace($matched_line, $regex, $line);
		}
		Else {
			$new_line = $line;
		}
		If ($lines[$index[0]] -cne $new_line) {
			$lines[$index[0]] = $new_line;
			$result.changed = $true;
			$result.msg = "line replaced";
		}
	}
	ElseIf ($backrefs) {
		# No matches - no-op
	}
	ElseIf ($insertbefore -eq "BOF" -or $insertafter -eq "BOF") {
		$lines.Insert(0, $line);
		$result.changed = $true;
		$result.msg = "line added";
	}
	ElseIf ($insertafter -eq "EOF" -or $index[1] -eq -1) {
		$lines.Add($line) > $null;
		$result.changed = $true;
		$result.msg = "line added";
	}
	Else {
		$lines.Insert($index[1], $line);
		$result.changed = $true;
		$result.msg = "line added";
	}

	# Write changes to the path if changes were made
	If ($result.changed) {

		# Write backup file if backup == "yes"
		If ($backup) {
			$result.backup_file = Backup-File -path $path -WhatIf:$check_mode
			# Ensure backward compatibility (deprecate in future)
			$result.backup = $result.backup_file
		}

		$writelines_params = @{
			outlines = $lines
			path = $path
			linesep = $linesep
			encodingobj = $encodingobj
			validate = $validate
			check_mode = $check_mode
		}
		$after = WriteLines @writelines_params;

		if ($diff_support) {
			$result.diff.after = $after;
		}
	}

	$result.encoding = $encodingobj.WebName;

	Exit-Json $result;
}


# Implement the functionality for state == 'absent'
function Absent($path, $regex, $line, $backup, $validate, $encodingobj, $linesep, $check_mode, $diff_support) {

	# Check if path exists. If it does not exist, fail with a reasonable error message.
	If (-not (Test-Path -LiteralPath $path)) {
		Fail-Json @{} "Path $path does not exist !";
	}

	# Initialize result information
	$result = @{
		backup = "";
		changed = $false;
		msg = "";
	}

	# Read the dest file lines using the indicated encoding into a mutable ArrayList. Note
	# that we have to clean up the path because ansible wants to treat / and \ as
	# interchangeable in windows pathnames, but .NET framework internals do not support that.
	$cleanpath = $path.Replace("/", "\");
	$before = [System.IO.File]::ReadAllLines($cleanpath, $encodingobj);
	If ($null -eq $before) {
		$lines = New-Object System.Collections.ArrayList;
	}
	Else {
		$lines = [System.Collections.ArrayList] $before;
	}

	if ($diff_support) {
		$result.diff = @{
			before = $before -join $linesep;
		}
	}

	# Compile the regex specified, if provided
	$cre = $null;
	If ($regex) {
		$cre = New-Object Regex $regex, 'Compiled';
	}

	$found = New-Object System.Collections.ArrayList;
	$left = New-Object System.Collections.ArrayList;

	Foreach ($cur_line in $lines) {
		If ($regex) {
			$m = $cre.Match($cur_line);
			$match_found = $m.Success;
		}
		Else {
			$match_found = $line -ceq $cur_line;
		}
		If ($match_found) {
			$found.Add($cur_line) > $null;
			$result.changed = $true;
		}
		Else {
			$left.Add($cur_line) > $null;
		}
	}

	# Write changes to the path if changes were made
	If ($result.changed) {

		# Write backup file if backup == "yes"
		If ($backup) {
			$result.backup_file = Backup-File -path $path -WhatIf:$check_mode
			# Ensure backward compatibility (deprecate in future)
			$result.backup = $result.backup_file
		}

		$writelines_params = @{
			outlines = $left
			path = $path
			linesep = $linesep
			encodingobj = $encodingobj
			validate = $validate
			check_mode = $check_mode
		}
		$after = WriteLines @writelines_params;

		if ($diff_support) {
			$result.diff.after = $after;
		}
	}

	$result.encoding = $encodingobj.WebName;
	$result.found = $found.Count;
	$result.msg = "$($found.Count) line(s) removed";

	Exit-Json $result;
}


# Parse the parameters file dropped by the Ansible machinery
$params = Parse-Args $args -supports_check_mode $true;
$check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -type "bool" -default $false;
$diff_support = Get-AnsibleParam -obj $params -name "_ansible_diff" -type "bool" -default $false;

# Initialize defaults for input parameters.
$path = Get-AnsibleParam -obj $params -name "path" -type "path" -failifempty $true -aliases "dest","destfile","name";
$regex = Get-AnsibleParam -obj $params -name "regex" -type "str" -aliases "regexp";
$state = Get-AnsibleParam -obj $params -name "state" -type "str" -default "present" -validateset "present","absent";
$line = Get-AnsibleParam -obj $params -name "line" -type "str";
$backrefs = Get-AnsibleParam -obj $params -name "backrefs" -type "bool" -default $false;
$insertafter = Get-AnsibleParam -obj $params -name "insertafter" -type "str";
$insertbefore = Get-AnsibleParam -obj $params -name "insertbefore" -type "str";
$create = Get-AnsibleParam -obj $params -name "create" -type "bool" -default $false;
$backup = Get-AnsibleParam -obj $params -name "backup" -type "bool" -default $false;
$validate = Get-AnsibleParam -obj $params -name "validate" -type "str";
$encoding = Get-AnsibleParam -obj $params -name "encoding" -type "str" -default "auto";
$newline = Get-AnsibleParam -obj $params -name "newline" -type "str" -default "windows" -validateset "unix","windows";

# Fail if the path is not a file
If (Test-Path -LiteralPath $path -PathType "container") {
	Fail-Json @{} "Path $path is a directory";
}

# Default to windows line separator - probably most common
$linesep = "`r`n"
If ($newline -eq "unix") {
	$linesep = "`n";
}

# Figure out the proper encoding to use for reading / writing the target file.

# The default encoding is UTF-8 without BOM
$encodingobj = [System.Text.UTF8Encoding] $false;

# If an explicit encoding is specified, use that instead
If ($encoding -ne "auto") {
	$encodingobj = [System.Text.Encoding]::GetEncoding($encoding);
}

# Otherwise see if we can determine the current encoding of the target file.
# If the file doesn't exist yet (create == 'yes') we use the default or
# explicitly specified encoding set above.
ElseIf (Test-Path -LiteralPath $path) {

	# Get a sorted list of encodings with preambles, longest first
	$max_preamble_len = 0;
	$sortedlist = New-Object System.Collections.SortedList;
	Foreach ($encodinginfo in [System.Text.Encoding]::GetEncodings()) {
		$encoding = $encodinginfo.GetEncoding();
		$plen = $encoding.GetPreamble().Length;
		If ($plen -gt $max_preamble_len) {
			$max_preamble_len = $plen;
		}
		If ($plen -gt 0) {
			$sortedlist.Add(-($plen * 1000000 + $encoding.CodePage), $encoding) > $null;
		}
	}

	# Get the first N bytes from the file, where N is the max preamble length we saw
	[Byte[]]$bom = Get-Content -Encoding Byte -ReadCount $max_preamble_len -TotalCount $max_preamble_len -LiteralPath $path;

	# Iterate through the sorted encodings, looking for a full match.
	$found = $false;
	Foreach ($encoding in $sortedlist.GetValueList()) {
		$preamble = $encoding.GetPreamble();
		If ($preamble -and $bom) {
			Foreach ($i in 0..($preamble.Length - 1)) {
				If ($i -ge $bom.Length) {
					break;
				}
				If ($preamble[$i] -ne $bom[$i]) {
					break;
				}
				ElseIf ($i + 1 -eq $preamble.Length) {
					$encodingobj = $encoding;
					$found = $true;
				}
			}
			If ($found) {
				break;
			}
		}
	}
}


# Main dispatch - based on the value of 'state', perform argument validation and
# call the appropriate handler function.
If ($state -eq "present") {

	If ($backrefs -and -not $regex) {
	    Fail-Json @{} "regexp= is required with backrefs=true";
	}

	If (-not $line) {
		Fail-Json @{} "line= is required with state=present";
	}

	If ($insertbefore -and $insertafter) {
		Add-Warning $result "Both insertbefore and insertafter parameters found, ignoring `"insertafter=$insertafter`""
	}

	If (-not $insertbefore -and -not $insertafter) {
		$insertafter = "EOF";
	}

	$present_params = @{
		path = $path
		regex = $regex
		line = $line
		insertafter = $insertafter
		insertbefore = $insertbefore
		create = $create
		backup = $backup
		backrefs = $backrefs
		validate = $validate
		encodingobj = $encodingobj
		linesep = $linesep
		check_mode = $check_mode
		diff_support = $diff_support
	}
	Present @present_params;

}
ElseIf ($state -eq "absent") {

	If (-not $regex -and -not $line) {
		Fail-Json @{} "one of line= or regexp= is required with state=absent";
	}

	$absent_params = @{
		path = $path
		regex = $regex
		line = $line
		backup = $backup
		validate = $validate
		encodingobj = $encodingobj
		linesep = $linesep
#!powershell

# Copyright: (c) 2017, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic

$store_name_values = ([System.Security.Cryptography.X509Certificates.StoreName]).GetEnumValues() | ForEach-Object { $_.ToString() }
$store_location_values = ([System.Security.Cryptography.X509Certificates.StoreLocation]).GetEnumValues() | ForEach-Object { $_.ToString() }

$spec = @{
    options = @{
        state = @{ type = "str"; default = "present"; choices = "absent", "exported", "present" }
        path = @{ type = "path" }
        thumbprint = @{ type = "str" }
        store_name = @{ type = "str"; default = "My"; choices = $store_name_values }
        store_location = @{ type = "str"; default = "LocalMachine"; choices = $store_location_values }
        password = @{ type = "str"; no_log = $true }
        key_exportable = @{ type = "bool"; default = $true }
        key_storage = @{ type = "str"; default = "default"; choices = "default", "machine", "user" }
        file_type = @{ type = "str"; default = "der"; choices = "der", "pem", "pkcs12" }
    }
    required_if = @(
        @("state", "absent", @("path", "thumbprint"), $true),
        @("state", "exported", @("path", "thumbprint")),
        @("state", "present", @("path"))
    )
    supports_check_mode = $true
}
$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

Function Get-CertFile($module, $path, $password, $key_exportable, $key_storage) {
    # parses a certificate file and returns X509Certificate2Collection
    if (-not (Test-Path -LiteralPath $path -PathType Leaf)) {
        $module.FailJson("File at '$path' either does not exist or is not a file")
    }

    # must set at least the PersistKeySet flag so that the PrivateKey
    # is stored in a permanent container and not deleted once the handle
    # is gone.
    $store_flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet

    $key_storage = $key_storage.substring(0,1).ToUpper() + $key_storage.substring(1).ToLower()
    $store_flags = $store_flags -bor [Enum]::Parse([System.Security.Cryptography.X509Certificates.X509KeyStorageFlags], "$($key_storage)KeySet")
    if ($key_exportable) {
        $store_flags = $store_flags -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
    }

    # TODO: If I'm feeling adventurours, write code to parse PKCS#12 PEM encoded
    # file as .NET does not have an easy way to import this
    $certs = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2Collection

    try {
        $certs.Import($path, $password, $store_flags)
    } catch {
        $module.FailJson("Failed to load cert from file: $($_.Exception.Message)", $_)
    }

    return $certs
}

Function New-CertFile($module, $cert, $path, $type, $password) {
    $content_type = switch ($type) {
        "pem" { [System.Security.Cryptography.X509Certificates.X509ContentType]::Cert }
        "der" { [System.Security.Cryptography.X509Certificates.X509ContentType]::Cert }
        "pkcs12" { [System.Security.Cryptography.X509Certificates.X509ContentType]::Pkcs12 }
    }
    if ($type -eq "pkcs12") {
        $missing_key = $false
        if ($null -eq $cert.PrivateKey) {
            $missing_key = $true
        } elseif ($cert.PrivateKey.CspKeyContainerInfo.Exportable -eq $false) {
            $missing_key = $true
        }
        if ($missing_key) {
            $module.FailJson("Cannot export cert with key as PKCS12 when the key is not marked as exportable or not accessible by the current user")
        }
    }

    if (Test-Path -LiteralPath $path) {
        Remove-Item -LiteralPath $path -Force
        $module.Result.changed = $true
    }
    try {
        $cert_bytes = $cert.Export($content_type, $password)
    } catch {
        $module.FailJson("Failed to export certificate as bytes: $($_.Exception.Message)", $_)
    }

    # Need to manually handle a PEM file
    if ($type -eq "pem") {
        $cert_content = "-----BEGIN CERTIFICATE-----`r`n"
        $base64_string = [System.Convert]::ToBase64String($cert_bytes, [System.Base64FormattingOptions]::InsertLineBreaks)
        $cert_content += $base64_string
        $cert_content += "`r`n-----END CERTIFICATE-----"
        $file_encoding = [System.Text.Encoding]::ASCII
        $cert_bytes = $file_encoding.GetBytes($cert_content)
    } elseif ($type -eq "pkcs12") {
        $module.Result.key_exported = $false
        if ($null -ne $cert.PrivateKey) {
            $module.Result.key_exportable = $cert.PrivateKey.CspKeyContainerInfo.Exportable
        }
    }

    if (-not $module.CheckMode) {
        try {
            [System.IO.File]::WriteAllBytes($path, $cert_bytes)
        } catch [System.ArgumentNullException] {
            $module.FailJson("Failed to write cert to file, cert was null: $($_.Exception.Message)", $_)
        } catch [System.IO.IOException] {
            $module.FailJson("Failed to write cert to file due to IO Exception: $($_.Exception.Message)", $_)
        } catch [System.UnauthorizedAccessException] {
            $module.FailJson("Failed to write cert to file due to permissions: $($_.Exception.Message)", $_)
        } catch {
            $module.FailJson("Failed to write cert to file: $($_.Exception.Message)", $_)
        }
    }
    $module.Result.changed = $true
}

Function Get-CertFileType($path, $password) {
    $certs = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2Collection
    try {
        $certs.Import($path, $password, 0)
    } catch [System.Security.Cryptography.CryptographicException] {
        # the file is a pkcs12 we just had the wrong password
        return "pkcs12"
    } catch {
        return "unknown"
    }

    $file_contents = Get-Content -LiteralPath $path -Raw
    if ($file_contents.StartsWith("-----BEGIN CERTIFICATE-----")) {
        return "pem"
    } elseif ($file_contents.StartsWith("-----BEGIN PKCS7-----")) {
        return "pkcs7-ascii"
    } elseif ($certs.Count -gt 1) {
        # multiple certs must be pkcs7
        return "pkcs7-binary"
    } elseif ($certs[0].HasPrivateKey) {
        return "pkcs12"
    } elseif ($path.EndsWith(".pfx") -or $path.EndsWith(".p12")) {
        # no way to differenciate a pfx with a der file so we must rely on the
        # extension
        return "pkcs12"
    } else {
        return "der"
    }
}

$state = $module.Params.state
$path = $module.Params.path
$thumbprint = $module.Params.thumbprint
$store_name = [System.Security.Cryptography.X509Certificates.StoreName]"$($module.Params.store_name)"
$store_location = [System.Security.Cryptography.X509Certificates.Storelocation]"$($module.Params.store_location)"
$password = $module.Params.password
$key_exportable = $module.Params.key_exportable
$key_storage = $module.Params.key_storage
$file_type = $module.Params.file_type

$module.Result.thumbprints = @()

$store = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $store_name, $store_location
try {
    $store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadWrite)
} catch [System.Security.Cryptography.CryptographicException] {
    $module.FailJson("Unable to open the store as it is not readable: $($_.Exception.Message)", $_)
} catch [System.Security.SecurityException] {
    $module.FailJson("Unable to open the store with the current permissions: $($_.Exception.Message)", $_)
} catch {
    $module.FailJson("Unable to open the store: $($_.Exception.Message)", $_)
}
$store_certificates = $store.Certificates

try {
    if ($state -eq "absent") {
        $cert_thumbprints = @()

        if ($null -ne $path) {
            $certs = Get-CertFile -module $module -path $path -password $password -key_exportable $key_exportable -key_storage $key_storage
            foreach ($cert in $certs) {
                $cert_thumbprints += $cert.Thumbprint
            }
        } elseif ($null -ne $thumbprint) {
            $cert_thumbprints += $thumbprint
        }

        foreach ($cert_thumbprint in $cert_thumbprints) {
            $module.Result.thumbprints += $cert_thumbprint
            $found_certs = $store_certificates.Find([System.Security.Cryptography.X509Certificates.X509FindType]::FindByThumbprint, $cert_thumbprint, $false)
            if ($found_certs.Count -gt 0) {
                foreach ($found_cert in $found_certs) {
                    try {
                        if (-not $module.CheckMode) {
                            $store.Remove($found_cert)
                        }
                    } catch [System.Security.SecurityException] {
                        $module.FailJson("Unable to remove cert with thumbprint '$cert_thumbprint' with current permissions: $($_.Exception.Message)", $_)
                    } catch {
                        $module.FailJson("Unable to remove cert with thumbprint '$cert_thumbprint': $($_.Exception.Message)", $_)
                    }
                    $module.Result.changed = $true
                }
            }
        }
    } elseif ($state -eq "exported") {
        # TODO: Add support for PKCS7 and exporting a cert chain
        $module.Result.thumbprints += $thumbprint
        $export = $true
        if (Test-Path -LiteralPath $path -PathType Container) {
            $module.FailJson("Cannot export cert to path '$path' as it is a directory")
        } elseif (Test-Path -LiteralPath $path -PathType Leaf) {
            $actual_cert_type = Get-CertFileType -path $path -password $password
            if ($actual_cert_type -eq $file_type) {
                try {
                    $certs = Get-CertFile -module $module -path $path -password $password -key_exportable $key_exportable -key_storage $key_storage
                } catch {
                    # failed to load the file so we set the thumbprint to something
                    # that will fail validation
                    $certs = @{Thumbprint = $null}
                }

                if ($certs.Thumbprint -eq $thumbprint) {
                    $export = $false
                }
            }
        }

        if ($export) {
            $found_certs = $store_certificates.Find([System.Security.Cryptography.X509Certificates.X509FindType]::FindByThumbprint, $thumbprint, $false)
            if ($found_certs.Count -ne 1) {
                $module.FailJson("Found $($found_certs.Count) certs when only expecting 1")
            }

            New-CertFile -module $module -cert $found_certs -path $path -type $file_type -password $password
        }
    } else {
        $certs = Get-CertFile -module $module -path $path -password $password -key_exportable $key_exportable -key_storage $key_storage
        foreach ($cert in $certs) {
            $module.Result.thumbprints += $cert.Thumbprint
            $found_certs = $store_certificates.Find([System.Security.Cryptography.X509Certificates.X509FindType]::FindByThumbprint, $cert.Thumbprint, $false)
            if ($found_certs.Count -eq 0) {
                try {
                    if (-not $module.CheckMode) {
                        $store.Add($cert)
                    }
                } catch [System.Security.Cryptography.CryptographicException] {
                    $module.FailJson("Unable to import certificate with thumbprint '$($cert.Thumbprint)' with the current permissions: $($_.Exception.Message)", $_)
                } catch {
                    $module.FailJson("Unable to import certificate with thumbprint '$($cert.Thumbprint)': $($_.Exception.Message)", $_)
                }
                $module.Result.changed = $true
            }
        }
    }
#!powershell

# Copyright: (c) 2017, Dag Wieers (@dagwieers) <dag@wieers.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#AnsibleRequires -CSharpUtil Ansible.Basic

Function New-TempFile {
    Param ([string]$path, [string]$prefix, [string]$suffix, [string]$type, [bool]$checkmode)
    $temppath = $null
    $curerror = $null
    $attempt = 0

    # Since we don't know if the file already exists, we try 5 times with a random name
    do {
        $attempt += 1
        $randomname = [System.IO.Path]::GetRandomFileName()
        $temppath = (Join-Path -Path $path -ChildPath "$prefix$randomname$suffix")
        Try {
            $file = New-Item -Path $temppath -ItemType $type -WhatIf:$checkmode
            # Makes sure we get the full absolute path of the created temp file and not a relative or DOS 8.3 dir
            if (-not $checkmode) {
                $temppath = $file.FullName
            } else {
                # Just rely on GetFulLpath for check mode
                $temppath = [System.IO.Path]::GetFullPath($temppath)
            }
        } Catch {
            $temppath = $null
            $curerror = $_
        }
    } until (($null -ne $temppath) -or ($attempt -ge 5))

    # If it fails 5 times, something is wrong and we have to report the details
    if ($null -eq $temppath) {
        $module.FailJson("No random temporary file worked in $attempt attempts. Error: $($curerror.Exception.Message)", $curerror)
    }

    return $temppath.ToString()
}

$spec = @{
    options = @{
        path = @{ type='path'; default='%TEMP%'; aliases=@( 'dest' ) }
        state = @{ type='str'; default='file'; choices=@( 'directory', 'file') }
        prefix = @{ type='str'; default='ansible.' }
        suffix = @{ type='str' }
    }
    supports_check_mode = $true
}

$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)

$path = $module.Params.path
$state = $module.Params.state
$prefix = $module.Params.prefix
$suffix = $module.Params.suffix

# Expand environment variables on non-path types
if ($null -ne $prefix) {
    $prefix = [System.Environment]::ExpandEnvironmentVariables($prefix)
}
if ($null -ne $suffix) {
    $suffix = [System.Environment]::ExpandEnvironmentVariables($suffix)
}

$module.Result.changed = $true
$module.Result.state = $state

$module.Result.path = New-TempFile -Path $path -Prefix $prefix -Suffix $suffix -Type $state -CheckMode $module.CheckMode
#!powershell

# Copyright: (c) 2015, Adam Keech <akeech@chathamfinancial.com>
# Copyright: (c) 2015, Josh Ludwig <jludwig@chathamfinancial.com>
# Copyright: (c) 2017, Jordan Borean <jborean93@gmail.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

#Requires -Module Ansible.ModuleUtils.Legacy
#Requires -Module Ansible.ModuleUtils.PrivilegeUtil

$params = Parse-Args -arguments $args -supports_check_mode $true
$check_mode = Get-AnsibleParam -obj $params -name "_ansible_check_mode" -type "bool" -default $false
$diff_mode = Get-AnsibleParam -obj $params -name "_ansible_diff" -type "bool" -default $false
$_remote_tmp = Get-AnsibleParam $params "_ansible_remote_tmp" -type "path" -default $env:TMP

$path = Get-AnsibleParam -obj $params -name "path" -type "str" -failifempty $true -aliases "key"
$name = Get-AnsibleParam -obj $params -name "name" -type "str" -aliases "entry","value"
$data = Get-AnsibleParam -obj $params -name "data"
$type = Get-AnsibleParam -obj $params -name "type" -type "str" -default "string" -validateset "none","binary","dword","expandstring","multistring","string","qword" -aliases "datatype"
$state = Get-AnsibleParam -obj $params -name "state" -type "str" -default "present" -validateset "present","absent"
$delete_key = Get-AnsibleParam -obj $params -name "delete_key" -type "bool" -default $true
$hive = Get-AnsibleParam -obj $params -name "hive" -type "path"

$result = @{
    changed = $false
    data_changed = $false
    data_type_changed = $false
}

if ($diff_mode) {
    $result.diff = @{
        before = ""
        after = ""
    }
}

$registry_util = @'
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace Ansible.WinRegedit
{
    internal class NativeMethods
    {
        [DllImport("advapi32.dll", CharSet = CharSet.Unicode)]
        public static extern int RegLoadKeyW(
            UInt32 hKey,
            string lpSubKey,
            string lpFile);

        [DllImport("advapi32.dll", CharSet = CharSet.Unicode)]
        public static extern int RegUnLoadKeyW(
            UInt32 hKey,
            string lpSubKey);
    }

    public class Win32Exception : System.ComponentModel.Win32Exception
    {
        private string _msg;
        public Win32Exception(string message) : this(Marshal.GetLastWin32Error(), message) { }
        public Win32Exception(int errorCode, string message) : base(errorCode)
        {
            _msg = String.Format("{0} ({1}, Win32ErrorCode {2})", message, base.Message, errorCode);
        }
        public override string Message { get { return _msg; } }
        public static explicit operator Win32Exception(string message) { return new Win32Exception(message); }
    }

    public class Hive : IDisposable
    {
        private const UInt32 SCOPE = 0x80000002;  // HKLM
        private string hiveKey;
        private bool loaded = false;

        public Hive(string hiveKey, string hivePath)
        {
            this.hiveKey = hiveKey;
            int ret = NativeMethods.RegLoadKeyW(SCOPE, hiveKey, hivePath);
            if (ret != 0)
                throw new Win32Exception(ret, String.Format("Failed to load registry hive at {0}", hivePath));
            loaded = true;
        }

        public static void UnloadHive(string hiveKey)
        {
            int ret = NativeMethods.RegUnLoadKeyW(SCOPE, hiveKey);
            if (ret != 0)
                throw new Win32Exception(ret, String.Format("Failed to unload registry hive at {0}", hiveKey));
        }

        public void Dispose()
        {
            if (loaded)
            {
                // Make sure the garbage collector disposes all unused handles and waits until it is complete
                GC.Collect();
                GC.WaitForPendingFinalizers();

                UnloadHive(hiveKey);
                loaded = false;
            }
            GC.SuppressFinalize(this);
        }
        ~Hive() { this.Dispose(); }
    }
}
'@

# fire a warning if the property name isn't specified, the (Default) key ($null) can only be a string
if ($null -eq $name -and $type -ne "string") {
    Add-Warning -obj $result -message "the data type when name is not specified can only be 'string', the type has automatically been converted"
    $type = "string"
}

# Check that the registry path is in PSDrive format: HKCC, HKCR, HKCU, HKLM, HKU
if ($path -notmatch "^HK(CC|CR|CU|LM|U):\\") {
    Fail-Json $result "path: $path is not a valid powershell path, see module documentation for examples."
}

# Add a warning if the path does not contains a \ and is not the leaf path
$registry_path = (Split-Path -Path $path -NoQualifier).Substring(1)  # removes the hive: and leading \
$registry_leaf = Split-Path -Path $path -Leaf
if ($registry_path -ne $registry_leaf -and -not $registry_path.Contains('\')) {
    $msg = "path is not using '\' as a separator, support for '/' as a separator will be removed in a future Ansible version"
    Add-DeprecationWarning -obj $result -message $msg -version 2.12
    $registry_path = $registry_path.Replace('/', '\')
}

# Simplified version of Convert-HexStringToByteArray from
# https://cyber-defense.sans.org/blog/2010/02/11/powershell-byte-array-hex-convert
# Expects a hex in the format you get when you run reg.exe export,
# and converts to a byte array so powershell can modify binary registry entries
# import format is like 'hex:be,ef,be,ef,be,ef,be,ef,be,ef'
Function Convert-RegExportHexStringToByteArray($string) {
    # Remove 'hex:' from the front of the string if present
    $string = $string.ToLower() -replace '^hex\:',''

    # Remove whitespace and any other non-hex crud.
    $string = $string -replace '[^a-f0-9\\,x\-\:]',''

    # Turn commas into colons
    $string = $string -replace ',',':'

    # Maybe there's nothing left over to convert...
    if ($string.Length -eq 0) {
        return ,@()
    }

    # Split string with or without colon delimiters.
    if ($string.Length -eq 1) {
        return ,@([System.Convert]::ToByte($string,16))
    } elseif (($string.Length % 2 -eq 0) -and ($string.IndexOf(":") -eq -1)) {
        return ,@($string -split '([a-f0-9]{2})' | foreach-object { if ($_) {[System.Convert]::ToByte($_,16)}})
    } elseif ($string.IndexOf(":") -ne -1) {
        return ,@($string -split ':+' | foreach-object {[System.Convert]::ToByte($_,16)})
    } else {
        return ,@()
    }
}

Function Compare-RegistryProperties($existing, $new) {
    # Outputs $true if the property values don't match
    if ($existing -is [Array]) {
        (Compare-Object -ReferenceObject $existing -DifferenceObject $new -SyncWindow 0).Length -ne 0
    } else {
        $existing -cne $new
    }
}

Function Get-DiffValue {
    param(
        [Parameter(Mandatory=$true)][Microsoft.Win32.RegistryValueKind]$Type,
        [Parameter(Mandatory=$true)][Object]$Value
    )

    $diff = @{ type = $Type.ToString(); value = $Value }

    $enum = [Microsoft.Win32.RegistryValueKind]
    if ($Type -in @($enum::Binary, $enum::None)) {
        $diff.value = [System.Collections.Generic.List`1[String]]@()
        foreach ($dec_value in $Value) {
            $diff.value.Add("0x{0:x2}" -f $dec_value)
        }
    } elseif ($Type -eq $enum::DWord) {
        $diff.value = "0x{0:x8}" -f $Value
    } elseif ($Type -eq $enum::QWord) {
        $diff.value = "0x{0:x16}" -f $Value
    }

    return $diff
}

Function Set-StateAbsent {
    param(
        # Used for diffs and exception messages to match up against Ansible input
        [Parameter(Mandatory=$true)][String]$PrintPath,
        [Parameter(Mandatory=$true)][Microsoft.Win32.RegistryKey]$Hive,
        [Parameter(Mandatory=$true)][String]$Path,
        [String]$Name,
        [Switch]$DeleteKey
    )

    $key = $Hive.OpenSubKey($Path, $true)
    if ($null -eq $key) {
        # Key does not exist, no need to delete anything
        return
    }

    try {
        if ($DeleteKey -and -not $Name) {
            # delete_key=yes is set and name is null/empty, so delete the entire key
            $key.Dispose()
            $key = $null
            if (-not $check_mode) {
                try {
                    $Hive.DeleteSubKeyTree($Path, $false)
                } catch {
                    Fail-Json -obj $result -message "failed to delete registry key at $($PrintPath): $($_.Exception.Message)"
                }
            }
            $result.changed = $true

            if ($diff_mode) {
                $result.diff.before = @{$PrintPath = @{}}
                $result.diff.after = @{}
            }
        } else {
            # delete_key=no or name is not null/empty, delete the property not the full key
            $property = $key.GetValue($Name)
            if ($null -eq $property) {
                # property does not exist
                return
            }
            $property_type = $key.GetValueKind($Name)  # used for the diff

            if (-not $check_mode) {
                try {
                    $key.DeleteValue($Name)
                } catch {
                    Fail-Json -obj $result -message "failed to delete registry property '$Name' at $($PrintPath): $($_.Exception.Message)"
                }
            }

            $result.changed = $true
            if ($diff_mode) {
                $diff_value = Get-DiffValue -Type $property_type -Value $property
                $result.diff.before = @{ $PrintPath = @{ $Name = $diff_value } }
                $result.diff.after = @{ $PrintPath = @{} }
            }
        }
    } finally {
        if ($key) {
            $key.Dispose()
        }
    }
}

Function Set-StatePresent {
    param(
        [Parameter(Mandatory=$true)][String]$PrintPath,
        [Parameter(Mandatory=$true)][Microsoft.Win32.RegistryKey]$Hive,
        [Parameter(Mandatory=$true)][String]$Path,
        [String]$Name,
        [Object]$Data,
        [Microsoft.Win32.RegistryValueKind]$Type
    )

    $key = $Hive.OpenSubKey($Path, $true)
    try {
        if ($null -eq $key) {
            # the key does not exist, create it so the next steps work
            if (-not $check_mode) {
                try {
                    $key = $Hive.CreateSubKey($Path)
                } catch {
                    Fail-Json -obj $result -message "failed to create registry key at $($PrintPath): $($_.Exception.Message)"
                }
            }
            $result.changed = $true

            if ($diff_mode) {
                $result.diff.before = @{}
                $result.diff.after = @{$PrintPath = @{}}
            }
        } elseif ($diff_mode) {
            # Make sure the diff is in an expected state for the key
            $result.diff.before = @{$PrintPath = @{}}
            $result.diff.after = @{$PrintPath = @{}}
        }

        if ($null -eq $key -or $null -eq $Data) {
            # Check mode and key was created above, we cannot do any more work, or $Data is $null which happens when
            # we create a new key but haven't explicitly set the data
            return
        }

        $property = $key.GetValue($Name, $null, [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames)
        if ($null -ne $property) {
            # property exists, need to compare the values and type
            $existing_type = $key.GetValueKind($name)
            $change_value = $false

            if ($Type -ne $existing_type) {
                $change_value = $true
                $result.data_type_changed = $true
                $data_mismatch = Compare-RegistryProperties -existing $property -new $Data
                if ($data_mismatch) {
                    $result.data_changed = $true
                }
            } else {
                $data_mismatch = Compare-RegistryProperties -existing $property -new $Data
                if ($data_mismatch) {
                    $change_value = $true
                    $result.data_changed = $true
                }
            }

            if ($change_value) {
                if (-not $check_mode) {
                    try {
                        $key.SetValue($Name, $Data, $Type)
                    } catch {
                        Fail-Json -obj $result -message "failed to change registry property '$Name' at $($PrintPath): $($_.Exception.Message)"
                    }
                }
                $result.changed = $true

                if ($diff_mode) {
                    $result.diff.before.$PrintPath.$Name = Get-DiffValue -Type $existing_type -Value $property
                    $result.diff.after.$PrintPath.$Name = Get-DiffValue -Type $Type -Value $Data
                }
            } elseif ($diff_mode) {
                $diff_value = Get-DiffValue -Type $existing_type -Value $property
                $result.diff.before.$PrintPath.$Name = $diff_value
                $result.diff.after.$PrintPath.$Name = $diff_value
            }
        } else {
            # property doesn't exist just create a new one
            if (-not $check_mode) {
                try {
                    $key.SetValue($Name, $Data, $Type)
                } catch {
                    Fail-Json -obj $result -message "failed to create registry property '$Name' at $($PrintPath): $($_.Exception.Message)"
                }
            }
            $result.changed = $true

            if ($diff_mode) {
                $result.diff.after.$PrintPath.$Name = Get-DiffValue -Type $Type -Value $Data
            }
        }
    } finally {
        if ($key) {
            $key.Dispose()
        }
    }
}

# convert property names "" to $null as "" refers to (Default)
if ($name -eq "") {
    $name = $null
}

# convert the data to the required format
if ($type -in @("binary", "none")) {
    if ($null -eq $data) {
        $data = ""
    }

    # convert the data from string to byte array if in hex: format
    if ($data -is [String]) {
        $data = [byte[]](Convert-RegExportHexStringToByteArray -string $data)
    } elseif ($data -is [Int]) {
        if ($data -gt 255) {
            Fail-Json $result "cannot convert binary data '$data' to byte array, please specify this value as a yaml byte array or a comma separated hex value string"
        }
        $data = [byte[]]@([byte]$data)
    } elseif ($data -is [Array]) {
        $data = [byte[]]$data
    }
} elseif ($type -in @("dword", "qword")) {
    # dword's and dword's don't allow null values, set to 0
    if ($null -eq $data) {
        $data = 0
    }

    if ($data -is [String]) {
        # if the data is a string we need to convert it to an unsigned int64
        # it needs to be unsigned as Ansible passes in an unsigned value while
        # powershell uses a signed data type. The value will then be converted
        # below
        $data = [UInt64]$data
    }

    if ($type -eq "dword") {
        if ($data -gt [UInt32]::MaxValue) {
            Fail-Json $result "data cannot be larger than 0xffffffff when type is dword"
        } elseif ($data -gt [Int32]::MaxValue) {
            # when dealing with larger int32 (> 2147483647 or 0x7FFFFFFF) powershell
            # automatically converts it to a signed int64. We need to convert this to
            # signed int32 by parsing the hex string value.
            $data = "0x$("{0:x}" -f $data)"
        }
        $data = [Int32]$data
    } else {
        if ($data -gt [UInt64]::MaxValue) {
            Fail-Json $result "data cannot be larger than 0xffffffffffffffff when type is qword"
        } elseif ($data -gt [Int64]::MaxValue) {
            $data = "0x$("{0:x}" -f $data)"
        }
        $data = [Int64]$data
    }
} elseif ($type -in @("string", "expandstring") -and $name) {
    # a null string or expandstring must be empty quotes
    # Only do this if $name has been defined (not the default key)
    if ($null -eq $data) {
        $data = ""
    }
} elseif ($type -eq "multistring") {
    # convert the data for a multistring to a String[] array
    if ($null -eq $data) {
        $data = [String[]]@()
    } elseif ($data -isnot [Array]) {
        $new_data = New-Object -TypeName String[] -ArgumentList 1
        $new_data[0] = $data.ToString([CultureInfo]::InvariantCulture)
        $data = $new_data
    } else {
        $new_data = New-Object -TypeName String[] -ArgumentList $data.Count
        foreach ($entry in $data) {
            $new_data[$data.IndexOf($entry)] = $entry.ToString([CultureInfo]::InvariantCulture)
        }
        $data = $new_data
    }
}

# convert the type string to the .NET class
$type = [System.Enum]::Parse([Microsoft.Win32.RegistryValueKind], $type, $true)

$registry_hive = switch(Split-Path -Path $path -Qualifier) {
    "HKCR:" { [Microsoft.Win32.Registry]::ClassesRoot }
    "HKCC:" { [Microsoft.Win32.Registry]::CurrentConfig }
    "HKCU:" { [Microsoft.Win32.Registry]::CurrentUser }
    "HKLM:" { [Microsoft.Win32.Registry]::LocalMachine }
    "HKU:" { [Microsoft.Win32.Registry]::Users }
}
$loaded_hive = $null
try {
    if ($hive) {
        if (-not (Test-Path -LiteralPath $hive)) {
            Fail-Json -obj $result -message "hive at path '$hive' is not valid or accessible, cannot load hive"
        }

        $original_tmp = $env:TMP
        $env:TMP = $_remote_tmp
        Add-Type -TypeDefinition $registry_util
        $env:TMP = $original_tmp

        try {
            Set-AnsiblePrivilege -Name SeBackupPrivilege -Value $true
            Set-AnsiblePrivilege -Name SeRestorePrivilege -Value $true
        } catch [System.ComponentModel.Win32Exception] {
            Fail-Json -obj $result -message "failed to enable SeBackupPrivilege and SeRestorePrivilege for the current process: $($_.Exception.Message)"
        }

        if (Test-Path -Path HKLM:\ANSIBLE) {
            Add-Warning -obj $result -message "hive already loaded at HKLM:\ANSIBLE, had to unload hive for win_regedit to continue"
            try {
                [Ansible.WinRegedit.Hive]::UnloadHive("ANSIBLE")
            } catch [System.ComponentModel.Win32Exception] {
                Fail-Json -obj $result -message "failed to unload registry hive HKLM:\ANSIBLE from $($hive): $($_.Exception.Message)"
            }
        }

        try {
            $loaded_hive = New-Object -TypeName Ansible.WinRegedit.Hive -ArgumentList "ANSIBLE", $hive
        } catch [System.ComponentModel.Win32Exception] {
            Fail-Json -obj $result -message "failed to load registry hive from '$hive' to HKLM:\ANSIBLE: $($_.Exception.Message)"
        }
    }

    if ($state -eq "present") {
        Set-StatePresent -PrintPath $path -Hive $registry_hive -Path $registry_path -Name $name -Data $data -Type $type
    } else {
        Set-StateAbsent -PrintPath $path -Hive $registry_hive -Path $registry_path -Name $name -DeleteKey:$delete_key
    }
} finally {
    $registry_hive.Dispose()
    if ($loaded_hive) {
        $loaded_hive.Dispose()
#Requires -Version 3.0

# Configure a Windows host for remote management with Ansible
# -----------------------------------------------------------
#
# This script checks the current WinRM (PS Remoting) configuration and makes
# the necessary changes to allow Ansible to connect, authenticate and
# execute PowerShell commands.
#
# All events are logged to the Windows EventLog, useful for unattended runs.
#
# Use option -Verbose in order to see the verbose output messages.
#
# Use option -CertValidityDays to specify how long this certificate is valid
# starting from today. So you would specify -CertValidityDays 3650 to get
# a 10-year valid certificate.
#
# Use option -ForceNewSSLCert if the system has been SysPreped and a new
# SSL Certificate must be forced on the WinRM Listener when re-running this
# script. This is necessary when a new SID and CN name is created.
#
# Use option -EnableCredSSP to enable CredSSP as an authentication option.
#
# Use option -DisableBasicAuth to disable basic authentication.
#
# Use option -SkipNetworkProfileCheck to skip the network profile check.
# Without specifying this the script will only run if the device's interfaces
# are in DOMAIN or PRIVATE zones.  Provide this switch if you want to enable
# WinRM on a device with an interface in PUBLIC zone.
#
# Use option -SubjectName to specify the CN name of the certificate. This
# defaults to the system's hostname and generally should not be specified.

# Written by Trond Hindenes <trond@hindenes.com>
# Updated by Chris Church <cchurch@ansible.com>
# Updated by Michael Crilly <mike@autologic.cm>
# Updated by Anton Ouzounov <Anton.Ouzounov@careerbuilder.com>
# Updated by Nicolas Simond <contact@nicolas-simond.com>
# Updated by Dag Wiers <dag@wieers.com>
# Updated by Jordan Borean <jborean93@gmail.com>
# Updated by Erwan Qulin <erwan.quelin@gmail.com>
# Updated by David Norman <david@dkn.email>
#
# Version 1.0 - 2014-07-06
# Version 1.1 - 2014-11-11
# Version 1.2 - 2015-05-15
# Version 1.3 - 2016-04-04
# Version 1.4 - 2017-01-05
# Version 1.5 - 2017-02-09
# Version 1.6 - 2017-04-18
# Version 1.7 - 2017-11-23
# Version 1.8 - 2018-02-23
# Version 1.9 - 2018-09-21

# Support -Verbose option
[CmdletBinding()]

Param (
    [string]$SubjectName = $env:COMPUTERNAME,
    [int]$CertValidityDays = 1095,
    [switch]$SkipNetworkProfileCheck,
    $CreateSelfSignedCert = $true,
    [switch]$ForceNewSSLCert,
    [switch]$GlobalHttpFirewallAccess,
    [switch]$DisableBasicAuth = $false,
    [switch]$EnableCredSSP
)

Function Write-Log
{
    $Message = $args[0]
    Write-EventLog -LogName Application -Source $EventSource -EntryType Information -EventId 1 -Message $Message
}

Function Write-VerboseLog
{
    $Message = $args[0]
    Write-Verbose $Message
    Write-Log $Message
}

Function Write-HostLog
{
    $Message = $args[0]
    Write-Output $Message
    Write-Log $Message
}

Function New-LegacySelfSignedCert
{
    Param (
        [string]$SubjectName,
        [int]$ValidDays = 1095
    )

    $hostnonFQDN = $env:computerName
    $hostFQDN = [System.Net.Dns]::GetHostByName(($env:computerName)).Hostname
    $SignatureAlgorithm = "SHA256"

    $name = New-Object -COM "X509Enrollment.CX500DistinguishedName.1"
    $name.Encode("CN=$SubjectName", 0)

    $key = New-Object -COM "X509Enrollment.CX509PrivateKey.1"
    $key.ProviderName = "Microsoft Enhanced RSA and AES Cryptographic Provider"
    $key.KeySpec = 1
    $key.Length = 4096
    $key.SecurityDescriptor = "D:PAI(A;;0xd01f01ff;;;SY)(A;;0xd01f01ff;;;BA)(A;;0x80120089;;;NS)"
    $key.MachineContext = 1
    $key.Create()

    $serverauthoid = New-Object -COM "X509Enrollment.CObjectId.1"
    $serverauthoid.InitializeFromValue("1.3.6.1.5.5.7.3.1")
    $ekuoids = New-Object -COM "X509Enrollment.CObjectIds.1"
    $ekuoids.Add($serverauthoid)
    $ekuext = New-Object -COM "X509Enrollment.CX509ExtensionEnhancedKeyUsage.1"
    $ekuext.InitializeEncode($ekuoids)

    $cert = New-Object -COM "X509Enrollment.CX509CertificateRequestCertificate.1"
    $cert.InitializeFromPrivateKey(2, $key, "")
    $cert.Subject = $name
    $cert.Issuer = $cert.Subject
    $cert.NotBefore = (Get-Date).AddDays(-1)
    $cert.NotAfter = $cert.NotBefore.AddDays($ValidDays)

    $SigOID = New-Object -ComObject X509Enrollment.CObjectId
    $SigOID.InitializeFromValue(([Security.Cryptography.Oid]$SignatureAlgorithm).Value)

    [string[]] $AlternativeName  += $hostnonFQDN
    $AlternativeName += $hostFQDN
    $IAlternativeNames = New-Object -ComObject X509Enrollment.CAlternativeNames

    foreach ($AN in $AlternativeName)
    {
        $AltName = New-Object -ComObject X509Enrollment.CAlternativeName
        $AltName.InitializeFromString(0x3,$AN)
        $IAlternativeNames.Add($AltName)
    }

    $SubjectAlternativeName = New-Object -ComObject X509Enrollment.CX509ExtensionAlternativeNames
    $SubjectAlternativeName.InitializeEncode($IAlternativeNames)

    [String[]]$KeyUsage = ("DigitalSignature", "KeyEncipherment")
    $KeyUsageObj = New-Object -ComObject X509Enrollment.CX509ExtensionKeyUsage
    $KeyUsageObj.InitializeEncode([int][Security.Cryptography.X509Certificates.X509KeyUsageFlags]($KeyUsage))
    $KeyUsageObj.Critical = $true

    $cert.X509Extensions.Add($KeyUsageObj)
    $cert.X509Extensions.Add($ekuext)
    $cert.SignatureInformation.HashAlgorithm = $SigOID
    $CERT.X509Extensions.Add($SubjectAlternativeName)
    $cert.Encode()

    $enrollment = New-Object -COM "X509Enrollment.CX509Enrollment.1"
    $enrollment.InitializeFromRequest($cert)
    $certdata = $enrollment.CreateRequest(0)
    $enrollment.InstallResponse(2, $certdata, 0, "")

    # extract/return the thumbprint from the generated cert
    $parsed_cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
    $parsed_cert.Import([System.Text.Encoding]::UTF8.GetBytes($certdata))

    return $parsed_cert.Thumbprint
}

Function Enable-GlobalHttpFirewallAccess
{
    Write-Verbose "Forcing global HTTP firewall access"
    # this is a fairly naive implementation; could be more sophisticated about rule matching/collapsing
    $fw = New-Object -ComObject HNetCfg.FWPolicy2

    # try to find/enable the default rule first
    $add_rule = $false
    $matching_rules = $fw.Rules | Where-Object  { $_.Name -eq "Windows Remote Management (HTTP-In)" }
    $rule = $null
    If ($matching_rules) {
        If ($matching_rules -isnot [Array]) {
            Write-Verbose "Editing existing single HTTP firewall rule"
            $rule = $matching_rules
        }
        Else {
            # try to find one with the All or Public profile first
            Write-Verbose "Found multiple existing HTTP firewall rules..."
            $rule = $matching_rules | ForEach-Object { $_.Profiles -band 4 }[0]

            If (-not $rule -or $rule -is [Array]) {
                Write-Verbose "Editing an arbitrary single HTTP firewall rule (multiple existed)"
                # oh well, just pick the first one
                $rule = $matching_rules[0]
            }
        }
    }

    If (-not $rule) {
        Write-Verbose "Creating a new HTTP firewall rule"
        $rule = New-Object -ComObject HNetCfg.FWRule
        $rule.Name = "Windows Remote Management (HTTP-In)"
        $rule.Description = "Inbound rule for Windows Remote Management via WS-Management. [TCP 5985]"
        $add_rule = $true
    }

    $rule.Profiles = 0x7FFFFFFF
    $rule.Protocol = 6
    $rule.LocalPorts = 5985
    $rule.RemotePorts = "*"
    $rule.LocalAddresses = "*"
    $rule.RemoteAddresses = "*"
    $rule.Enabled = $true
    $rule.Direction = 1
    $rule.Action = 1
    $rule.Grouping = "Windows Remote Management"

    If ($add_rule) {
        $fw.Rules.Add($rule)
    }

    Write-Verbose "HTTP firewall rule $($rule.Name) updated"
}

# Setup error handling.
Trap
{
    $_
    Exit 1
}
$ErrorActionPreference = "Stop"

# Get the ID and security principal of the current user account
$myWindowsID=[System.Security.Principal.WindowsIdentity]::GetCurrent()
$myWindowsPrincipal=new-object System.Security.Principal.WindowsPrincipal($myWindowsID)

# Get the security principal for the Administrator role
$adminRole=[System.Security.Principal.WindowsBuiltInRole]::Administrator

# Check to see if we are currently running "as Administrator"
if (-Not $myWindowsPrincipal.IsInRole($adminRole))
{
    Write-Output "ERROR: You need elevated Administrator privileges in order to run this script."
    Write-Output "       Start Windows PowerShell by using the Run as Administrator option."
    Exit 2
}

$EventSource = $MyInvocation.MyCommand.Name
If (-Not $EventSource)
{
    $EventSource = "Powershell CLI"
}

If ([System.Diagnostics.EventLog]::Exists('Application') -eq $False -or [System.Diagnostics.EventLog]::SourceExists($EventSource) -eq $False)
{
    New-EventLog -LogName Application -Source $EventSource
}

# Detect PowerShell version.
If ($PSVersionTable.PSVersion.Major -lt 3)
{
    Write-Log "PowerShell version 3 or higher is required."
    Throw "PowerShell version 3 or higher is required."
}

# Find and start the WinRM service.
Write-Verbose "Verifying WinRM service."
If (!(Get-Service "WinRM"))
{
    Write-Log "Unable to find the WinRM service."
    Throw "Unable to find the WinRM service."
}
ElseIf ((Get-Service "WinRM").Status -ne "Running")
{
    Write-Verbose "Setting WinRM service to start automatically on boot."
    Set-Service -Name "WinRM" -StartupType Automatic
    Write-Log "Set WinRM service to start automatically on boot."
    Write-Verbose "Starting WinRM service."
    Start-Service -Name "WinRM" -ErrorAction Stop
    Write-Log "Started WinRM service."

}

# WinRM should be running; check that we have a PS session config.
If (!(Get-PSSessionConfiguration -Verbose:$false) -or (!(Get-ChildItem WSMan:\localhost\Listener)))
{
  If ($SkipNetworkProfileCheck) {
    Write-Verbose "Enabling PS Remoting without checking Network profile."
    Enable-PSRemoting -SkipNetworkProfileCheck -Force -ErrorAction Stop
    Write-Log "Enabled PS Remoting without checking Network profile."
  }
  Else {
    Write-Verbose "Enabling PS Remoting."
    Enable-PSRemoting -Force -ErrorAction Stop
    Write-Log "Enabled PS Remoting."
  }
}
Else
{
    Write-Verbose "PS Remoting is already enabled."
}

# Ensure LocalAccountTokenFilterPolicy is set to 1
# https://github.com/ansible/ansible/issues/42978
$token_path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
$token_prop_name = "LocalAccountTokenFilterPolicy"
$token_key = Get-Item -Path $token_path
$token_value = $token_key.GetValue($token_prop_name, $null)
if ($token_value -ne 1) {
    Write-Verbose "Setting LocalAccountTOkenFilterPolicy to 1"
    if ($null -ne $token_value) {
        Remove-ItemProperty -Path $token_path -Name $token_prop_name
    }
    New-ItemProperty -Path $token_path -Name $token_prop_name -Value 1 -PropertyType DWORD > $null
}

# Make sure there is a SSL listener.
$listeners = Get-ChildItem WSMan:\localhost\Listener
If (!($listeners | Where-Object {$_.Keys -like "TRANSPORT=HTTPS"}))
{
    # We cannot use New-SelfSignedCertificate on 2012R2 and earlier
    $thumbprint = New-LegacySelfSignedCert -SubjectName $SubjectName -ValidDays $CertValidityDays
    Write-HostLog "Self-signed SSL certificate generated; thumbprint: $thumbprint"

    # Create the hashtables of settings to be used.
    $valueset = @{
        Hostname = $SubjectName
        CertificateThumbprint = $thumbprint
    }

    $selectorset = @{
        Transport = "HTTPS"
        Address = "*"
    }

    Write-Verbose "Enabling SSL listener."
    New-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset -ValueSet $valueset
    Write-Log "Enabled SSL listener."
}
Else
{
    Write-Verbose "SSL listener is already active."

    # Force a new SSL cert on Listener if the $ForceNewSSLCert
    If ($ForceNewSSLCert)
    {

        # We cannot use New-SelfSignedCertificate on 2012R2 and earlier
        $thumbprint = New-LegacySelfSignedCert -SubjectName $SubjectName -ValidDays $CertValidityDays
        Write-HostLog "Self-signed SSL certificate generated; thumbprint: $thumbprint"

        $valueset = @{
            CertificateThumbprint = $thumbprint
            Hostname = $SubjectName
        }

        # Delete the listener for SSL
        $selectorset = @{
            Address = "*"
            Transport = "HTTPS"
        }
        Remove-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset

        # Add new Listener with new SSL cert
        New-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset -ValueSet $valueset
    }
}

# Check for basic authentication.
$basicAuthSetting = Get-ChildItem WSMan:\localhost\Service\Auth | Where-Object {$_.Name -eq "Basic"}

If ($DisableBasicAuth)
{
    If (($basicAuthSetting.Value) -eq $true)
    {
        Write-Verbose "Disabling basic auth support."
        Set-Item -Path "WSMan:\localhost\Service\Auth\Basic" -Value $false
        Write-Log "Disabled basic auth support."
    }
    Else
    {
        Write-Verbose "Basic auth is already disabled."
    }
}
Else
{
    If (($basicAuthSetting.Value) -eq $false)
    {
        Write-Verbose "Enabling basic auth support."
        Set-Item -Path "WSMan:\localhost\Service\Auth\Basic" -Value $true
        Write-Log "Enabled basic auth support."
    }
    Else
    {
        Write-Verbose "Basic auth is already enabled."
    }
}

# If EnableCredSSP if set to true
If ($EnableCredSSP)
{
    # Check for CredSSP authentication
    $credsspAuthSetting = Get-ChildItem WSMan:\localhost\Service\Auth | Where-Object {$_.Name -eq "CredSSP"}
    If (($credsspAuthSetting.Value) -eq $false)
    {
        Write-Verbose "Enabling CredSSP auth support."
        Enable-WSManCredSSP -role server -Force
        Write-Log "Enabled CredSSP auth support."
    }
}

If ($GlobalHttpFirewallAccess) {
    Enable-GlobalHttpFirewallAccess
}

# Configure firewall to allow WinRM HTTPS connections.
$fwtest1 = netsh advfirewall firewall show rule name="Allow WinRM HTTPS"
$fwtest2 = netsh advfirewall firewall show rule name="Allow WinRM HTTPS" profile=any
If ($fwtest1.count -lt 5)
{
    Write-Verbose "Adding firewall rule to allow WinRM HTTPS."
    netsh advfirewall firewall add rule profile=any name="Allow WinRM HTTPS" dir=in localport=5986 protocol=TCP action=allow
    Write-Log "Added firewall rule to allow WinRM HTTPS."
}
ElseIf (($fwtest1.count -ge 5) -and ($fwtest2.count -lt 5))
{
    Write-Verbose "Updating firewall rule to allow WinRM HTTPS for any profile."
    netsh advfirewall firewall set rule name="Allow WinRM HTTPS" new profile=any
    Write-Log "Updated firewall rule to allow WinRM HTTPS for any profile."
}
Else
{
    Write-Verbose "Firewall rule already exists to allow WinRM HTTPS."
}

# Test a remoting connection to localhost, which should work.
$httpResult = Invoke-Command -ComputerName "localhost" -ScriptBlock {$env:COMPUTERNAME} -ErrorVariable httpError -ErrorAction SilentlyContinue
$httpsOptions = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck

$httpsResult = New-PSSession -UseSSL -ComputerName "localhost" -SessionOption $httpsOptions -ErrorVariable httpsError -ErrorAction SilentlyContinue

If ($httpResult -and $httpsResult)
{
    Write-Verbose "HTTP: Enabled | HTTPS: Enabled"
}
ElseIf ($httpsResult -and !$httpResult)
{
    Write-Verbose "HTTP: Disabled | HTTPS: Enabled"
}
ElseIf ($httpResult -and !$httpsResult)
{
    Write-Verbose "HTTP: Enabled | HTTPS: Disabled"
}
Else
{
    Write-Log "Unable to establish an HTTP or HTTPS remoting session."

# Powershell script to upgrade a PowerShell 2.0 system to PowerShell 3.0
# based on http://occasionalutility.blogspot.com/2013/11/everyday-powershell-part-7-powershell.html
#
# some Ansible modules that may use Powershell 3 features, so systems may need
# to be upgraded.  This may be used by a sample playbook.  Refer to the windows
# documentation on docs.ansible.com for details.
#
# - hosts: windows
#   tasks:
#     - script: upgrade_to_ps3.ps1

# Get version of OS

# 6.0 is 2008
# 6.1 is 2008 R2
# 6.2 is 2012
# 6.3 is 2012 R2


if ($PSVersionTable.psversion.Major -ge 3)
{
    Write-Output "Powershell 3 Installed already; You don't need this"
    Exit
}

$powershellpath = "C:\powershell"

function download-file
{
    param ([string]$path, [string]$local)
    $client = new-object system.net.WebClient
    $client.Headers.Add("user-agent", "PowerShell")
    $client.downloadfile($path, $local)
}

if (!(test-path $powershellpath))
{
    New-Item -ItemType directory -Path $powershellpath
}


# .NET Framework 4.0 is necessary.

#if (($PSVersionTable.CLRVersion.Major) -lt 2)
#{
#    $DownloadUrl = "http://download.microsoft.com/download/B/A/4/BA4A7E71-2906-4B2D-A0E1-80CF16844F5F/dotNetFx45_Full_x86_x64.exe"
#    $FileName = $DownLoadUrl.Split('/')[-1]
#    download-file $downloadurl "$powershellpath\$filename"
#    ."$powershellpath\$filename" /quiet /norestart
#}

#You may need to reboot after the .NET install if so just run the script again.

# If the Operating System is above 6.2, then you already have PowerShell Version > 3
if ([Environment]::OSVersion.Version.Major -gt 6)
{
    Write-Output "OS is new; upgrade not needed."
    Exit
}


$osminor = [environment]::OSVersion.Version.Minor

$architecture = $ENV:PROCESSOR_ARCHITECTURE

if ($architecture -eq "AMD64")
{
    $architecture = "x64"
}
else
{
    $architecture = "x86"
}

if ($osminor -eq 1)
{
    $DownloadUrl = "http://download.microsoft.com/download/E/7/6/E76850B8-DA6E-4FF5-8CCE-A24FC513FD16/Windows6.1-KB2506143-" + $architecture + ".msu"
}
elseif ($osminor -eq 0)
{
    $DownloadUrl = "http://download.microsoft.com/download/E/7/6/E76850B8-DA6E-4FF5-8CCE-A24FC513FD16/Windows6.0-KB2506146-" + $architecture + ".msu"
}
else
{
    # Nothing to do; In theory this point will never be reached.
    Exit
}

$FileName = $DownLoadUrl.Split('/')[-1]
param([string]$gomaDir=$PWD)
$cmdPath = Join-Path -Path $gomaDir -ChildPath "goma_ctl.py" 
Start-Process -FilePath cmd -ArgumentList "/C", "python", "$cmdPath", "ensure_start"
$timedOut = $false; $waitTime = 0; $waitIncrement = 5; $timeout=120;
Do { sleep $waitIncrement; $timedOut = (($waitTime+=$waitIncrement) -gt $timeout); iex "$gomaDir\gomacc.exe port 2" > $null; } Until(($LASTEXITCODE -eq 0) -or $timedOut) 
# Sample script to install Miniconda under Windows
# Authors: Olivier Grisel, Jonathan Helmus and Kyle Kastner, Robert McGibbon
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

$MINICONDA_URL = "https://repo.continuum.io/miniconda/"


function DownloadMiniconda ($python_version, $platform_suffix) {
    $webclient = New-Object System.Net.WebClient
    if ($python_version -match "3.[4-6]") {
        $filename = "Miniconda3-4.3.30-Windows-" + $platform_suffix + ".exe"
    } else {
        $filename = "Miniconda2-4.3.30-Windows-" + $platform_suffix + ".exe"
    }
    $url = $MINICONDA_URL + $filename

    $basedir = $pwd.Path + "\"
    $filepath = $basedir + $filename
    if (Test-Path $filename) {
        Write-Host "Reusing" $filepath
        return $filepath
    }

    # Download and retry up to 3 times in case of network transient errors.
    Write-Host "Downloading" $filename "from" $url
    $retry_attempts = 2
    for($i=0; $i -lt $retry_attempts; $i++){
        try {
            $webclient.DownloadFile($url, $filepath)
            break
        }
        Catch [Exception]{
            Write-Host "Exception downloading" $filename ":" $_.Exception.ToString()
            Write-Host "Retrying in 1 second."
            Start-Sleep 1
        }
   }
   if (!(Test-Path $filepath) -or ($i -ge $retry_attempts)) {
       # Retry once to get the error message if any at the last try
       $webclient.DownloadFile($url, $filepath)
   }
   Write-Host "File saved at" $filepath
   return $filepath
}


function InstallMiniconda ($python_version, $architecture, $python_home) {
    Write-Host "Installing Python" $python_version "for" $architecture "bit architecture to" $python_home
    if (Test-Path $python_home) {
        Write-Host $python_home "already exists, skipping."
        return $false
    }
    if ($architecture -match "32") {
        $platform_suffix = "x86"
    } else {
        $platform_suffix = "x86_64"
    }

    $filepath = DownloadMiniconda $python_version $platform_suffix
    Write-Host "Installing" $filepath "to" $python_home
    $install_log = $python_home + ".log"
    $args = "/S /D=$python_home"
    Write-Host $filepath $args
    Start-Process -FilePath $filepath -ArgumentList $args -Wait -Passthru
    if (Test-Path $python_home) {
        Write-Host "Python $python_version ($architecture) installation complete"
    } else {
        Write-Host "Failed to install Python in $python_home"
        Get-Content -Path $install_log
        Exit 1
    }
}


function InstallCondaPackages ($python_home, $spec) {
    $conda_path = $python_home + "\Scripts\conda.exe"
    $args = "install --yes " + $spec
    Write-Host ("conda " + $args)
    Start-Process -FilePath "$conda_path" -ArgumentList $args -Wait -Passthru
}

function UpdateConda ($python_home) {
    $conda_path = $python_home + "\Scripts\conda.exe"
    Write-Host "Updating conda..."
    $args = "update --yes conda"
    Write-Host $conda_path $args
    Start-Process -FilePath "$conda_path" -ArgumentList $args -Wait -Passthru
}


function main () {
    InstallMiniconda $env:CONDA_ROOT_PYTHON_VERSION $env:PYTHON_ARCH $env:PYTHON
    # UpdateConda $env:PYTHON
    # InstallCondaPackages $env:PYTHON "conda-build jinja2 anaconda-client"
}
param(
  [string]$protoc,
  [string]$srcdir,
  [string]$unprocessed,
  [string]$processed,
  [string]$out
)
$ErrorActionPreference = "Stop"
Get-Content $unprocessed | % {$_ -Replace "caffe2/proto/caffe2.proto", "caffe2.proto"} | Set-Content $processed
Add-Content -Path $processed -Value "option optimize_for = LITE_RUNTIME;`n" -NoNewline
$dir = (Get-Item $processed).DirectoryName

copy $srcdir/caffe2/proto/caffe2.proto $srcdir/caffe2.proto
Add-Content -Path $srcdir/caffe2.proto -Value "option optimize_for = LITE_RUNTIME;`n" -NoNewline

$ErrorActionPreference = 'Stop';
$packageArgs = @{
  packageName   = $env:ChocolateyPackageName
  softwareName  = 'responsively*'
  fileType      = 'EXE'
  silentArgs    = "/S"
  validExitCodes= @(0, 3010, 1605, 1614, 1641)
}

$uninstalled = $false
[array]$key = Get-UninstallRegistryKey -SoftwareName $packageArgs['softwareName']

if ($key.Count -eq 1) {
  $key | % { 
    $packageArgs['file'] = "$($_.UninstallString)"
    
    if ($packageArgs['fileType'] -eq 'MSI') {
      $packageArgs['silentArgs'] = "$($_.PSChildName) $($packageArgs['silentArgs'])"
      $packageArgs['file'] = ''
    } else {

    }

    Uninstall-ChocolateyPackage @packageArgs
  }
} elseif ($key.Count -eq 0) {
  Write-Warning "$packageName has already been uninstalled by other means."
} elseif ($key.Count -gt 1) {
  Write-Warning "$($key.Count) matches found!"
  Write-Warning "To prevent accidental data loss, no programs will be uninstalled."
$ErrorActionPreference = 'Stop';

$toolsDir   = "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
$url        = 'https://github.com/responsively-org/responsively-app/releases/download/v#VERSION#/ResponsivelyApp-Setup-#VERSION#.exe'
$url64      = 'https://github.com/responsively-org/responsively-app/releases/download/v#VERSION#/ResponsivelyApp-Setup-#VERSION#.exe'

$packageArgs = @{
  packageName   = $env:ChocolateyPackageName
  unzipLocation = $toolsDir
  fileType      = 'exe'
  url           = $url
  url64bit      = $url64

  softwareName  = 'responsively*'
  checksum      = '#CHECKSUM#'
  checksumType  = 'sha512'
  checksum64    = '#CHECKSUM#'
  checksumType64= 'sha512'

  silentArgs    = "/S"
# Copyright 2021 The Kubernetes Authors All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

Get-Process "*Docker Desktop*" | Stop-Process

$attempt = 1
while($attempt -le 10) {
  Write-Host "Attempt ", $attempt
  Write-Host "Wait for 2 minutes"
  & "C:\Program Files\Docker\Docker\Docker Desktop.exe"
  Start-Sleep 120
  $dockerInfo = docker info
  Write-Host "Docker Info ", $dockerInfo
  $serverVersion = $dockerInfo | Where-Object {$_ -Match "Server Version"}
  Write-Host "Server Version ", $serverVersion
  if (![System.String]::IsNullOrEmpty($serverVersion)) {
    Write-Host "Docker successfully started!"
    exit 0
  }
# Copyright 2019 The Kubernetes Authors All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

mkdir -p out

(New-Object Net.WebClient).DownloadFile("https://github.com/medyagh/gopogh/releases/download/v0.6.0/gopogh.exe", "C:\Go\bin\gopogh.exe")

gsutil.cmd -m cp gs://minikube-builds/$env:MINIKUBE_LOCATION/minikube-windows-amd64.exe out/
gsutil.cmd -m cp gs://minikube-builds/$env:MINIKUBE_LOCATION/e2e-windows-amd64.exe out/
gsutil.cmd -m cp -r gs://minikube-builds/$env:MINIKUBE_LOCATION/testdata .
gsutil.cmd -m cp -r gs://minikube-builds/$env:MINIKUBE_LOCATION/setup_docker_desktop_windows.ps1 out/

./out/setup_docker_desktop_windows.ps1
If ($lastexitcode -gt 0) {
	echo "Docker failed to start, exiting."
	Exit $lastexitcode
}


./out/minikube-windows-amd64.exe delete --all

docker ps -aq | ForEach -Process {docker rm -fv $_}

$started=Get-Date -UFormat %s

out/e2e-windows-amd64.exe --minikube-start-args="--driver=docker" --binary=out/minikube-windows-amd64.exe --test.v --test.timeout=180m | Tee-Object -FilePath testout.txt
$env:result=$lastexitcode
# If the last exit code was 0->success, x>0->error
If($env:result -eq 0){
	$env:status="success"
	echo "minikube: SUCCESS"
} Else {
	$env:status="failure"
	echo "minikube: FAIL"
}

$ended=Get-Date -UFormat %s
$elapsed=$ended-$started
$elapsed=$elapsed/60
$elapsed=[math]::Round($elapsed, 2)

Get-Content testout.txt -Encoding ASCII | go tool test2json -t | Out-File -FilePath testout.json -Encoding ASCII

$gopogh_status=gopogh --in testout.json --out_html testout.html --out_summary testout_summary.json --name "Docker_Windows" -pr $env:MINIKUBE_LOCATION --repo github.com/kubernetes/minikube/ --details $env:COMMIT

$failures=echo $gopogh_status | jq '.NumberOfFail'
$tests=echo $gopogh_status | jq '.NumberOfTests'
$bad_status="$failures / $tests failures"

$description="$status in $elapsed minute(s)."
If($env:status -eq "failure") {
	$description="completed with $bad_status in $elapsed minute(s)."
}
echo $description

$env:SHORT_COMMIT=$env:COMMIT.substring(0, 7)
$gcs_bucket="minikube-builds/logs/$env:MINIKUBE_LOCATION/$env:SHORT_COMMIT"
$env:target_url="https://storage.googleapis.com/$gcs_bucket/Docker_Windows.html"

#Upload logs to gcs
gsutil -qm cp testout.txt gs://$gcs_bucket/Docker_Windowsout.txt
gsutil -qm cp testout.json gs://$gcs_bucket/Docker_Windows.json
gsutil -qm cp testout.html gs://$gcs_bucket/Docker_Windows.html
gsutil -qm cp testout_summary.json gs://$gcs_bucket/Docker_Windows_summary.json


# Update the PR with the new info
$json = "{`"state`": `"$env:status`", `"description`": `"Jenkins: $description`", `"target_url`": `"$env:target_url`", `"context`": `"Docker_Windows`"}"
Invoke-WebRequest -Uri "https://api.github.com/repos/kubernetes/minikube/statuses/$env:COMMIT`?access_token=$env:access_token" -Body $json -ContentType "application/json" -Method Post -usebasicparsing
function Jenkins {
	Get-Process e2e-windows-amd64 2>$NULL
	if ($?) {
		return $TRUE
	}
	return $FALSE
}

if (Jenkins) {
	exit 0
}
echo "waiting to see if any jobs are coming in..."
timeout 30
if (Jenkins) {
	exit 0
}
echo "doing it"
taskkill /IM putty.exe
taskkill /F /IM java.exe
Get-VM | Where-Object {$_.Name -ne "DockerDesktopVM"} | Foreach {
	C:\var\jenkins\workspace\Hyper-V_Windows_integration\out\minikube-windows-amd64.exe delete -p $_.Name
	Suspend-VM $_.Name
	Stop-VM $_.Name -Force
	Remove-VM $_.Name -Force
}
# Copyright 2019 The Kubernetes Authors All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

(New-Object Net.WebClient).DownloadFile("https://github.com/medyagh/gopogh/releases/download/v0.6.0/gopogh.exe", "C:\Go\bin\gopogh.exe")

mkdir -p out
gsutil.cmd -m cp gs://minikube-builds/$env:MINIKUBE_LOCATION/minikube-windows-amd64.exe out/
gsutil.cmd -m cp gs://minikube-builds/$env:MINIKUBE_LOCATION/e2e-windows-amd64.exe out/
gsutil.cmd -m cp -r gs://minikube-builds/$env:MINIKUBE_LOCATION/testdata .

./out/minikube-windows-amd64.exe delete --all

out/e2e-windows-amd64.exe -minikube-start-args="--driver=hyperv" -binary=out/minikube-windows-amd64.exe -test.v -test.timeout=65m
$env:result=$lastexitcode
# If the last exit code was 0->success, x>0->error
If($env:result -eq 0){$env:status="success"}
Else {$env:status="failure"}

# $env:SHORT_COMMIT=$env:COMMIT.substring(0, 7)
# to be used later to implement https://github.com/kubernetes/minikube/issues/6593
$env:target_url="https://storage.googleapis.com/minikube-builds/logs/$env:MINIKUBE_LOCATION/Hyper-V_Windows.txt"
$json = "{`"state`": `"$env:status`", `"description`": `"Jenkins`", `"target_url`": `"$env:target_url`", `"context`": `"Hyper-V_Windows`"}"
Invoke-WebRequest -Uri "https://api.github.com/repos/kubernetes/minikube/statuses/$env:COMMIT`?access_token=$env:access_token" -Body $json -ContentType "application/json" -Method Post -usebasicparsing

# Copyright 2016 The Kubernetes Authors All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

(New-Object Net.WebClient).DownloadFile("https://github.com/medyagh/gopogh/releases/download/v0.6.0/gopogh.exe", "C:\Go\bin\gopogh.exe")


mkdir -p out
gsutil.cmd -m cp gs://minikube-builds/$env:MINIKUBE_LOCATION/minikube-windows-amd64.exe out/
gsutil.cmd -m cp gs://minikube-builds/$env:MINIKUBE_LOCATION/e2e-windows-amd64.exe out/
gsutil.cmd -m cp -r gs://minikube-builds/$env:MINIKUBE_LOCATION/testdata .

./out/minikube-windows-amd64.exe delete

out/e2e-windows-amd64.exe -minikube-start-args="--driver=virtualbox" -binary=out/minikube-windows-amd64.exe -test.v -test.timeout=30m
$env:result=$lastexitcode
# If the last exit code was 0->success, x>0->error
If($env:result -eq 0){$env:status="success"}
Else {$env:status="failure"}

# $env:SHORT_COMMIT=$env:COMMIT.substring(0, 7)
# to be used later 
$env:target_url="https://storage.googleapis.com/minikube-builds/logs/$env:MINIKUBE_LOCATION/VirtualBox_Windows.txt"
$json = "{`"state`": `"$env:status`", `"description`": `"Jenkins`", `"target_url`": `"$env:target_url`", `"context`": `"VirtualBox_Windows`"}"
Invoke-WebRequest -Uri "https://api.github.com/repos/kubernetes/minikube/statuses/$env:COMMIT`?access_token=$env:access_token" -Body $json -ContentType "application/json" -Method Post -usebasicparsing
function Jenkins {
	Get-Process e2e-windows-amd64 2>$NULL
	if ($?) {
		return $TRUE
	}
	return $FALSE
}

if (Jenkins) {
	exit 0
}

echo "waiting to see if any jobs are coming in..."
timeout 30
if (Jenkins) {
	exit 0
}

echo "doing it"
taskkill /IM putty.exe
taskkill /F /IM java.exe

VBoxManage list vms | Foreach {
	$m = $_.Substring(1, $_.LastIndexOf('"')-1)
	VBoxManage controlvm $m poweroff
<#
	.DESCRIPTION
    This script is used to add/remove the installation path of Minikube in the PATH Environment variable as part of installation/uninstallation of Minikube.
    The script assumes that the PATH exists before running.
    
    .PARAMETER Add
    This is a Switch parameter which tells the script to ADD the path supplied to the System's PATH Environment variable.
    
    .PARAMETER Remove
    This is a Switch parameter which tells the script to REMOVE the path supplied from the System's PATH Environment variable.

    .PARAMETER Path
    This parameter accepts a string which needs to be added/removed from the System's PATH Environment Variable.
#>

param(
    [cmdletbinding()]
    
    # This parameter dictates if the path needs to be added 
    [Parameter(Mandatory=$false,ParameterSetName="EnvironmentVariableAddOperation")]
    [switch]
    $Add,

    # This parameter dictates if the path needs to be removed 
    [Parameter(Mandatory=$false,ParameterSetName="EnvironmentVariableRemoveOperation")]
    [switch]
    $Remove,

    # This parameter tells us the path inside the $PATH Environment Variable for which the operation needs to be performed
    [Parameter(Mandatory=$true)]
    [string]
    $Path
)

$currentSystemPath = [Environment]::GetEnvironmentVariable("Path", [EnvironmentVariableTarget]::Machine)

try {
    if ($Add) {
        Write-Output "Path needs to be added."
        Write-Output "Checking if the given path already exists or not"

        if ($currentSystemPath -match [Regex]::Escape($Path)) {
            Write-Output "The provided path already exists in the system. Exiting now."
        } else {
            Write-Output "The given path was not found. Adding it now."
            if ($currentSystemPath.EndsWith(";")) {
                $newSystemPath = $currentSystemPath + $Path.Trim() + ";"
            } else {
                $newSystemPath = $currentSystemPath + ";" + $Path.Trim() + ";"
            }
            [Environment]::SetEnvironmentVariable("Path", $newSystemPath, [EnvironmentVariableTarget]::Machine)
            Write-Output "Path has been added successfully."
        }
    } else {
        Write-Output "Path needs to be added."
        Write-Output "Checking if the given path already exists or not"

        if ($currentSystemPath -match [Regex]::Escape($Path)) {
            Write-Output "The provided path exists in the system. Removing now."
            $newSystemPath = $currentSystemPath.Replace(($Path.Trim() + ";"), "")
            [Environment]::SetEnvironmentVariable("Path", $newSystemPath, [EnvironmentVariableTarget]::Machine)
        } else {
            Write-Output "The given path was not found. Exiting now."
        }
    }
# Copyright 2019 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

Param(
  [string]$FileName = $(throw "-FileName is required.")
 )


# read = read data | read attributes
$READ_PERMISSIONS = 0x0001 -bor 0x0080

# write = write data | append data | write attributes | write EA
$WRITE_PERMISSIONS = 0x0002 -bor 0x0004 -bor 0x0100 -bor  0x0010

# execute = read data | file execute
$EXECUTE_PERMISSIONS = 0x0001 -bor 0x0020


function GetFilePermissions($path) {
    $fileAcl = Get-Acl -Path $path
    $fileOwner = $fileAcl.Owner
    $fileGroup = $fileAcl.Group

    $userMask = 0
    $groupMask = 0
    $otherMask = 0

    foreach ($rule in $fileAcl.Access) {
        if ($rule.AccessControlType -ne [Security.AccessControl.AccessControlType]::Allow) {
            # not an allow rule, skipping.
            continue
        }

        $mask = 0
        $rights = $rule.FileSystemRights.value__
        # convert mask.
        if ( ($rights -band $READ_PERMISSIONS) -eq $READ_PERMISSIONS ) {
            $mask = $mask -bor 4
        }
        if ( ($rights -band $WRITE_PERMISSIONS) -eq $WRITE_PERMISSIONS ) {
            $mask = $mask -bor 2
        }
        if ( ($rights -band $EXECUTE_PERMISSIONS) -eq $EXECUTE_PERMISSIONS ) {
            $mask = $mask -bor 1
        }

        # detect mask type.
        if ($rule.IdentityReference.Value.Equals($fileOwner)) {
            $userMask = $mask
        }
        if ($rule.IdentityReference.Value.Equals($fileGroup)) {
            $groupMask = $mask
        }
        if ($rule.IdentityReference.Value.ToLower().Contains("users")) {
            $otherMask = $mask
        }
    }

    return "$userMask$groupMask$otherMask"
}

$mask = GetFilePermissions($FileName)
if (-not $?) {
    exit 1
# Requirements so far:
# dockerd running
#  - image microsoft/nanoserver (matching host base image)  docker load -i c:\baseimages\nanoserver.tar
#  - image alpine (linux) docker pull --platform=linux alpine


# TODO: Add this a parameter for debugging. ie "functional-tests -debug=$true"
#$env:HCSSHIM_FUNCTIONAL_TESTS_DEBUG="yes please"

#pushd uvm
# Copyright 2019 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

<#
.SYNOPSIS
  Library for installing and running Win64-OpenSSH. NOT FOR PRODUCTION USE.

.NOTES
  This module depends on common.psm1. This module depends on third-party code
  which has not been security-reviewed, so it should only be used for test
  clusters. DO NOT USE THIS MODULE FOR PRODUCTION.
#>

# IMPORTANT PLEASE NOTE:
# Any time the file structure in the `windows` directory changes, `windows/BUILD`
# and `k8s.io/release/lib/releaselib.sh` must be manually updated with the changes.
# We HIGHLY recommend not changing the file structure, because consumers of
# Kubernetes releases depend on the release structure remaining stable.

Import-Module -Force C:\common.psm1

$OPENSSH_ROOT = 'C:\Program Files\OpenSSH'
$USER_PROFILE_MODULE = 'C:\user-profile.psm1'
$WRITE_SSH_KEYS_SCRIPT = 'C:\write-ssh-keys.ps1'

# Starts the Win64-OpenSSH services and configures them to automatically start
# on subsequent boots.
function Start_OpenSshServices {
  ForEach ($service in ("sshd", "ssh-agent")) {
    net start ${service}
    Set-Service ${service} -StartupType Automatic
  }
}

# Installs open-ssh using the instructions in
# https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH.
#
# After installation run StartProcess-WriteSshKeys to fetch ssh keys from the
# metadata server.
function InstallAndStart-OpenSsh {
  if (-not (ShouldWrite-File $OPENSSH_ROOT)) {
    Log-Output "Starting already-installed OpenSSH services"
    Start_OpenSshServices
    return
  }
  elseif (Test-Path $OPENSSH_ROOT) {
    Log-Output ("OpenSSH directory already exists, attempting to run its " +
                "uninstaller before reinstalling")
    powershell.exe `
        -ExecutionPolicy Bypass `
        -File "$OPENSSH_ROOT\OpenSSH-Win64\uninstall-sshd.ps1"
    rm -Force -Recurse $OPENSSH_ROOT\OpenSSH-Win64
  }

  # Download open-ssh.
  # Use TLS 1.2: needed for Invoke-WebRequest downloads from github.com.
  [Net.ServicePointManager]::SecurityProtocol = `
      [Net.SecurityProtocolType]::Tls12
  $url = ("https://github.com/PowerShell/Win32-OpenSSH/releases/download/" +
          "v7.9.0.0p1-Beta/OpenSSH-Win64.zip")
  $ProgressPreference = 'SilentlyContinue'
  Invoke-WebRequest $url -OutFile C:\openssh-win64.zip

  # Unzip and install open-ssh
  Expand-Archive -Force C:\openssh-win64.zip -DestinationPath $OPENSSH_ROOT
  powershell.exe `
      -ExecutionPolicy Bypass `
      -File "$OPENSSH_ROOT\OpenSSH-Win64\install-sshd.ps1"

  # Disable password-based authentication.
  $sshd_config_default = "$OPENSSH_ROOT\OpenSSH-Win64\sshd_config_default"
  $sshd_config = 'C:\ProgramData\ssh\sshd_config'
  New-Item -Force -ItemType Directory -Path "C:\ProgramData\ssh\" | Out-Null
  # SSH config files must be UTF-8 encoded:
  # https://github.com/PowerShell/Win32-OpenSSH/issues/862
  # https://github.com/PowerShell/Win32-OpenSSH/wiki/Various-Considerations
  (Get-Content $sshd_config_default).`
      replace('#PasswordAuthentication yes', 'PasswordAuthentication no') |
      Set-Content -Encoding UTF8 $sshd_config

  # Configure the firewall to allow inbound SSH connections
  if (Get-NetFirewallRule -ErrorAction SilentlyContinue sshd) {
    Get-NetFirewallRule sshd | Remove-NetFirewallRule
  }
  New-NetFirewallRule `
      -Name sshd `
      -DisplayName 'OpenSSH Server (sshd)' `
      -Enabled True `
      -Direction Inbound `
      -Protocol TCP `
      -Action Allow `
      -LocalPort 22

  Start_OpenSshServices
}

function Setup_WriteSshKeysScript {
  if (-not (ShouldWrite-File $WRITE_SSH_KEYS_SCRIPT)) {
    return
  }

  # Fetch helper module for manipulating Windows user profiles.
  if (ShouldWrite-File $USER_PROFILE_MODULE) {
    $module = Get-InstanceMetadataAttribute 'user-profile-psm1'
    New-Item -ItemType file -Force $USER_PROFILE_MODULE | Out-Null
    Set-Content $USER_PROFILE_MODULE $module
  }

  # TODO(pjh): check if we still need to write authorized_keys to users-specific
  # directories, or if just writing to the centralized keys file for
  # Administrators on the system is sufficient (does our log-dump user have
  # Administrator rights?).
  New-Item -Force -ItemType file ${WRITE_SSH_KEYS_SCRIPT} | Out-Null
  Set-Content ${WRITE_SSH_KEYS_SCRIPT} `
'Import-Module -Force USER_PROFILE_MODULE
# For [System.Web.Security.Membership]::GeneratePassword():
Add-Type -AssemblyName System.Web

$poll_interval = 10

while($true) {
  $r1 = ""
  $r2 = ""
  # Try both the new "ssh-keys" and the legacy "sshSkeys" attributes for
  # compatibility. The Invoke-RestMethods calls will fail when these attributes
  # do not exist, or they may fail when the connection to the metadata server
  # gets disrupted while we set up container networking on the node.
  try {
    $r1 = Invoke-RestMethod -Headers @{"Metadata-Flavor"="Google"} -Uri `
        "http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys"
  } catch {}
  try {
    $r2 = Invoke-RestMethod -Headers @{"Metadata-Flavor"="Google"} -Uri `
        "http://metadata.google.internal/computeMetadata/v1/project/attributes/sshKeys"
  } catch {}
  $response= $r1 + $r2

  # Split the response into lines; handle both \r\n and \n line breaks.
  $tuples = $response -split "\r?\n"

  $users_to_keys = @{}
  foreach($line in $tuples) {
    if ([string]::IsNullOrEmpty($line)) {
      continue
    }
    # The final parameter to -Split is the max number of strings to return, so
    # this only splits on the first colon.
    $username, $key = $line -Split ":",2

    # Detect and skip keys without associated usernames, which may come back
    # from the legacy sshKeys metadata.
    if (($username -like "ssh-*") -or ($username -like "ecdsa-*")) {
      Write-Error "Skipping key without username: $username"
      continue
    }
    if (-not $users_to_keys.ContainsKey($username)) {
      $users_to_keys[$username] = @($key)
    }
    else {
      $keyList = $users_to_keys[$username]
      $users_to_keys[$username] = $keyList + $key
    }
  }
  $users_to_keys.GetEnumerator() | ForEach-Object {
    $username = $_.key

    # We want to create an authorized_keys file in the user profile directory
    # for each user, but if we create the directory before that user profile
    # has been created first by Windows, then Windows will create a different
    # user profile directory that looks like "<user>.KUBERNETES-MINI" and sshd
    # will look for the authorized_keys file in THAT directory. In other words,
    # we need to create the user first before we can put the authorized_keys
    # file in that user profile directory. The user-profile.psm1 module (NOT
    # FOR PRODUCTION USE!) has Create-NewProfile which achieves this.
    #
    # Run "Get-Command -Module Microsoft.PowerShell.LocalAccounts" to see the
    # build-in commands for users and groups. For some reason the New-LocalUser
    # command does not create the user profile directory, so we use the
    # auxiliary user-profile.psm1 instead.

    $pw = [System.Web.Security.Membership]::GeneratePassword(16,2)
    try {
      # Create-NewProfile will throw this when the user profile already exists:
      #   Create-NewProfile : Exception calling "SetInfo" with "0" argument(s):
      #   "The account already exists."
      # Just catch it and ignore it.
      Create-NewProfile $username $pw -ErrorAction Stop

      # Add the user to the Administrators group, otherwise we will not have
      # privilege when we ssh.
      Add-LocalGroupMember -Group Administrators -Member $username
    } catch {}

    $user_dir = "C:\Users\" + $username
    if (-not (Test-Path $user_dir)) {
      # If for some reason Create-NewProfile failed to create the user profile
      # directory just continue on to the next user.
      return
    }

    # NOTE: there is a race condition here where someone could try to ssh to
    # this node in-between when we clear out the authorized_keys file and when
    # we write keys to it. Oh well.
    $user_keys_file = -join($user_dir, "\.ssh\authorized_keys")
    New-Item -ItemType file -Force $user_keys_file | Out-Null

    # New for v7.9.0.0: administrators_authorized_keys file. For permission
    # information see
    # https://github.com/PowerShell/Win32-OpenSSH/wiki/Security-protection-of-various-files-in-Win32-OpenSSH#administrators_authorized_keys.
    $administrator_keys_file = ${env:ProgramData} + `
        "\ssh\administrators_authorized_keys"
    New-Item -ItemType file -Force $administrator_keys_file | Out-Null
    icacls $administrator_keys_file /inheritance:r | Out-Null
    icacls $administrator_keys_file /grant SYSTEM:`(F`) | Out-Null
    icacls $administrator_keys_file /grant BUILTIN\Administrators:`(F`) | `
        Out-Null

    ForEach ($ssh_key in $_.value) {
      # authorized_keys and other ssh config files must be UTF-8 encoded:
      # https://github.com/PowerShell/Win32-OpenSSH/issues/862
      # https://github.com/PowerShell/Win32-OpenSSH/wiki/Various-Considerations
      Add-Content -Encoding UTF8 $user_keys_file $ssh_key
      Add-Content -Encoding UTF8 $administrator_keys_file $ssh_key
    }
  }
  Start-Sleep -sec $poll_interval
}'.replace('USER_PROFILE_MODULE', $USER_PROFILE_MODULE)
  Log-Output ("${WRITE_SSH_KEYS_SCRIPT}:`n" +
              "$(Get-Content -Raw ${WRITE_SSH_KEYS_SCRIPT})")
}

# Starts a background process that retrieves ssh keys from the metadata server
# and writes them to user-specific directories. Intended for use only by test
# clusters!!
#
# While this is running it should be possible to SSH to the Windows node using:
#   gcloud compute ssh <username>@<instance> --zone=<zone>
# or:
#   ssh -i ~/.ssh/google_compute_engine -o 'IdentitiesOnly yes' \
#     <username>@<instance_external_ip>
# or copy files using:
#   gcloud compute scp <username>@<instance>:C:\\path\\to\\file.txt \
#     path/to/destination/ --zone=<zone>
#
# If the username you're using does not already have a project-level SSH key
# (run "gcloud compute project-info describe --flatten
# commonInstanceMetadata.items.ssh-keys" to check), run gcloud compute ssh with
# that username once to add a new project-level SSH key, wait one minute for
# StartProcess-WriteSshKeys to pick it up, then try to ssh/scp again.
function StartProcess-WriteSshKeys {
  Setup_WriteSshKeysScript

  # TODO(pjh): check if such a process is already running before starting
  # another one.
  $write_keys_process = Start-Process `
      -FilePath "powershell.exe" `
      -ArgumentList @("-Command", ${WRITE_SSH_KEYS_SCRIPT}) `
      -WindowStyle Hidden -PassThru `
      -RedirectStandardOutput "NUL" `
      -RedirectStandardError C:\write-ssh-keys.err
  Log-Output "Started background process to write SSH keys"
  Log-Output "$(${write_keys_process} | Out-String)"
}


<#
.Synopsis
   Rough PS functions to create new user profiles
.DESCRIPTION
   Call the Create-NewProfile function directly to create a new profile
.EXAMPLE
   Create-NewProfile -Username 'testUser1' -Password 'testUser1'
.NOTES
   Created by: Josh Rickard (@MS_dministrator) and Thom Schumacher (@driberif)
   Forked by: @crshnbrn66, then @pjh (2018-11-08). See
     https://gist.github.com/pjh/9753cd14400f4e3d4567f4553ba75f1d/revisions
   Date: 24MAR2017
   Location: https://gist.github.com/crshnbrn66/7e81bf20408c05ddb2b4fdf4498477d8

   Contact: https://github.com/MSAdministrator
            MSAdministrator.com
            https://github.com/crshnbrn66
            powershellposse.com
#>

# IMPORTANT PLEASE NOTE:
# Any time the file structure in the `windows` directory changes, `windows/BUILD`
# and `k8s.io/release/lib/releaselib.sh` must be manually updated with the changes.
# We HIGHLY recommend not changing the file structure, because consumers of
# Kubernetes releases depend on the release structure remaining stable.


#Function to create the new local user first
function New-LocalUser
{
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param
    (
        # Param1 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        $userName,
        # Param2 help description
        [string]
        $password
    )
 
    $system = [ADSI]"WinNT://$env:COMPUTERNAME";
    $user = $system.Create("user",$userName);
    $user.SetPassword($password);
    $user.SetInfo();
 
    $flag=$user.UserFlags.value -bor 0x10000;
    $user.put("userflags",$flag);
    $user.SetInfo();
 
    $group = [ADSI]("WinNT://$env:COMPUTERNAME/Users");
    $group.PSBase.Invoke("Add", $user.PSBase.Path);
}

#function to register a native method
function Register-NativeMethod
{
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param
    (
        # Param1 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [string]$dll,
 
        # Param2 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=1)]
        [string]
        $methodSignature
    )
 
    $script:nativeMethods += [PSCustomObject]@{ Dll = $dll; Signature = $methodSignature; }
}
function Get-Win32LastError
{
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param($typeName = 'LastError')
 if (-not ([System.Management.Automation.PSTypeName]$typeName).Type)
    {
    $lasterrorCode = $script:lasterror | ForEach-Object{
        '[DllImport("kernel32.dll", SetLastError = true)]
         public static extern uint GetLastError();'
    }
        Add-Type @"
        using System;
        using System.Text;
        using System.Runtime.InteropServices;
        public static class $typeName {
            $lasterrorCode
        }
"@
    }
}
#function to add native method
function Add-NativeMethods
{
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param($typeName = 'NativeMethods')
 
    $nativeMethodsCode = $script:nativeMethods | ForEach-Object { "
        [DllImport(`"$($_.Dll)`")]
        public static extern $($_.Signature);
    " }
 
    Add-Type @"
        using System;
        using System.Text;
        using System.Runtime.InteropServices;
        public static class $typeName {
            $nativeMethodsCode
        }
"@
}

#Main function to create the new user profile
function Create-NewProfile {
 
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param
    (
        # Param1 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [string]$UserName,
 
        # Param2 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=1)]
        [string]
        $Password
    )
  
    Write-Verbose "Creating local user $Username";
  
    try
    {
        New-LocalUser -username $UserName -password $Password;
    }
    catch
    {
        Write-Error $_.Exception.Message;
        break;
    }
    $methodName = 'UserEnvCP'
    $script:nativeMethods = @();
 
    if (-not ([System.Management.Automation.PSTypeName]$MethodName).Type)
    {
        Register-NativeMethod "userenv.dll" "int CreateProfile([MarshalAs(UnmanagedType.LPWStr)] string pszUserSid,`
         [MarshalAs(UnmanagedType.LPWStr)] string pszUserName,`
         [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszProfilePath, uint cchProfilePath)";
 
        Add-NativeMethods -typeName $MethodName;
    }
 
    $localUser = New-Object System.Security.Principal.NTAccount("$UserName");
    $userSID = $localUser.Translate([System.Security.Principal.SecurityIdentifier]);
    $sb = new-object System.Text.StringBuilder(260);
    $pathLen = $sb.Capacity;
 
    Write-Verbose "Creating user profile for $Username";
 
    try
    {
        [UserEnvCP]::CreateProfile($userSID.Value, $Username, $sb, $pathLen) | Out-Null;
    }
    catch
    {
        Write-Error $_.Exception.Message;
        break;
    }
}

function New-ProfileFromSID {
 
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param
    (
        # Param1 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [string]$UserName,
        [string]$domain = 'PHCORP'
    )
    $methodname = 'UserEnvCP2'
    $script:nativeMethods = @();
    
    if (-not ([System.Management.Automation.PSTypeName]$methodname).Type)
    {
        Register-NativeMethod "userenv.dll" "int CreateProfile([MarshalAs(UnmanagedType.LPWStr)] string pszUserSid,`
         [MarshalAs(UnmanagedType.LPWStr)] string pszUserName,`
         [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszProfilePath, uint cchProfilePath)";
 
        Add-NativeMethods -typeName $methodname;
    }
 
    $sb = new-object System.Text.StringBuilder(260);
    $pathLen = $sb.Capacity;
 
    Write-Verbose "Creating user profile for $Username";
    #$SID= ((get-aduser -id $UserName -ErrorAction Stop).sid.value)
  if($domain)
   {
        $objUser = New-Object System.Security.Principal.NTAccount($domain, $UserName)
        $strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
        $SID = $strSID.Value
   }
   else 
   {
       $objUser = New-Object System.Security.Principal.NTAccount($UserName)
       $strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
       $SID = $strSID.Value
   }
    Write-Verbose "$UserName SID: $SID"
    try
    {
       $result = [UserEnvCP2]::CreateProfile($SID, $Username, $sb, $pathLen) 
       if($result -eq '-2147024713')
       {
           $status = "$userName already exists"
           write-verbose "$username Creation Result: $result"
        }
        elseif($result -eq '-2147024809')
        {
            $staus = "$username Not Found"
            write-verbose "$username creation result: $result"
        }
       elseif($result -eq 0)
       {
           $status = "$username Profile has been created"
           write-verbose "$username Creation Result: $result"
       }
       else
       {
          $status = "$UserName unknown return result: $result"
       }
    }
    catch
    {
        Write-Error $_.Exception.Message;
        break;
    }
    $status
}
Function Remove-Profile {
 
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param
    (
        # Param1 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [string]$UserName,
        [string]$ProfilePath,
        [string]$domain = 'PHCORP'
    )
    $methodname = 'userenvDP'
    $script:nativeMethods = @();
 
    if (-not ([System.Management.Automation.PSTypeName]"$methodname.profile").Type)
    {
      add-type @"
using System.Runtime.InteropServices;

namespace $typename
{
    public static class UserEnv
    {
        [DllImport("userenv.dll", CharSet = CharSet.Unicode, ExactSpelling = false, SetLastError = true)]
        public static extern bool DeleteProfile(string sidString, string profilePath, string computerName);

        [DllImport("kernel32.dll")]
        public static extern uint GetLastError();
    }

    public static class Profile
    {
        public static uint Delete(string sidString)
        { //Profile path and computer name are optional
            if (!UserEnv.DeleteProfile(sidString, null, null))
            {
                return UserEnv.GetLastError();
            }

            return 0;
        }
    }
}
"@
    }

   #$SID= ((get-aduser -id $UserName -ErrorAction Stop).sid.value)
   if($domain)
   {
        $objUser = New-Object System.Security.Principal.NTAccount($domain, $UserName)
        $strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
        $SID = $strSID.Value
   }
   else 
   {
       $objUser = New-Object System.Security.Principal.NTAccount($UserName)
       $strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
       $SID = $strSID.Value
   }
    Write-Verbose "$UserName SID: $SID"
    try
    {
        #http://stackoverflow.com/questions/31949002/c-sharp-delete-user-profile
       $result = [userenvDP.Profile]::Delete($SID)
    }
    catch
    {
        Write-Error $_.Exception.Message;
        break;
    }
    $LastError
# Copyright 2019 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

<#
.SYNOPSIS
  Top-level script that runs on Windows nodes to join them to the K8s cluster.
#>

# IMPORTANT PLEASE NOTE:
# Any time the file structure in the `windows` directory changes, `windows/BUILD`
# and `k8s.io/release/lib/releaselib.sh` must be manually updated with the changes.
# We HIGHLY recommend not changing the file structure, because consumers of
# Kubernetes releases depend on the release structure remaining stable.

$ErrorActionPreference = 'Stop'

# Turn on tracing to debug
# Set-PSDebug -Trace 1

# Update TLS setting to enable Github downloads and disable progress bar to
# increase download speed.
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$ProgressPreference = 'SilentlyContinue'

# Returns the GCE instance metadata value for $Key where key is an "attribute"
# of the instance. If the key is not present in the instance metadata returns
# $Default if set, otherwise returns $null.
function Get-InstanceMetadataAttribute {
  param (
    [parameter(Mandatory=$true)] [string]$Key,
    [parameter(Mandatory=$false)] [string]$Default
  )

  $url = ("http://metadata.google.internal/computeMetadata/v1/instance/" +
          "attributes/$Key")
  try {
    $client = New-Object Net.WebClient
    $client.Headers.Add('Metadata-Flavor', 'Google')
    return ($client.DownloadString($url)).Trim()
  }
  catch [System.Net.WebException] {
    if ($Default) {
      return $Default
    }
    else {
      Write-Host "Failed to retrieve value for $Key."
      return $null
    }
  }
}

# Fetches the value of $MetadataKey, saves it to C:\$Filename and imports it as
# a PowerShell module.
#
# Note: this function depends on common.psm1.
function FetchAndImport-ModuleFromMetadata {
  param (
    [parameter(Mandatory=$true)] [string]$MetadataKey,
    [parameter(Mandatory=$true)] [string]$Filename
  )

  $module = Get-InstanceMetadataAttribute $MetadataKey
  if (Test-Path C:\$Filename) {
    if (-not $REDO_STEPS) {
      Log-Output "Skip: C:\$Filename already exists, not overwriting"
      Import-Module -Force C:\$Filename
      return
    }
    Log-Output "Warning: C:\$Filename already exists, will overwrite it."
  }
  New-Item -ItemType file -Force C:\$Filename | Out-Null
  Set-Content C:\$Filename $module
  Import-Module -Force C:\$Filename
}

# Returns true if the ENABLE_STACKDRIVER_WINDOWS or ENABLE_NODE_LOGGING field in kube_env is true.
# $KubeEnv is a hash table containing the kube-env metadata keys+values.
# ENABLE_NODE_LOGGING is used for legacy Stackdriver Logging, and will be deprecated (always set to False)
# soon. ENABLE_STACKDRIVER_WINDOWS is added to indicate whether logging is enabled for windows nodes.
function IsLoggingEnabled {
  param (
    [parameter(Mandatory=$true)] [hashtable]$KubeEnv
  )

  if ($KubeEnv.Contains('ENABLE_STACKDRIVER_WINDOWS') -and `
      ($KubeEnv['ENABLE_STACKDRIVER_WINDOWS'] -eq 'true')) {
    return $true
  } elseif ($KubeEnv.Contains('ENABLE_NODE_LOGGING') -and `
      ($KubeEnv['ENABLE_NODE_LOGGING'] -eq 'true')) {
    return $true
  }
  return $false
}

try {
  # Don't use FetchAndImport-ModuleFromMetadata for common.psm1 - the common
  # module includes variables and functions that any other function may depend
  # on.
  $module = Get-InstanceMetadataAttribute 'common-psm1'
  New-Item -ItemType file -Force C:\common.psm1 | Out-Null
  Set-Content C:\common.psm1 $module
  Import-Module -Force C:\common.psm1

  # TODO(pjh): update the function to set $Filename automatically from the key,
  # then put these calls into a loop over a list of XYZ-psm1 keys.
  FetchAndImport-ModuleFromMetadata 'k8s-node-setup-psm1' 'k8s-node-setup.psm1'

  Dump-DebugInfoToConsole

  if (-not (Test-ContainersFeatureInstalled)) {
    Install-ContainersFeature
    Log-Output 'Restarting computer after enabling Windows Containers feature'
    Restart-Computer -Force
    # Restart-Computer does not stop the rest of the script from executing.
    exit 0
  }

  if (-not (Test-DockerIsInstalled)) {
    Install-Docker
  }
  # For some reason the docker service may not be started automatically on the
  # first reboot, although it seems to work fine on subsequent reboots.
  Restart-Service docker
  Start-Sleep 5
  if (-not (Test-DockerIsRunning)) {
      throw "docker service failed to start or stay running"
  }

  Set-PrerequisiteOptions
  $kube_env = Fetch-KubeEnv

  if (Test-IsTestCluster $kube_env) {
    Log-Output 'Test cluster detected, installing OpenSSH.'
    FetchAndImport-ModuleFromMetadata 'install-ssh-psm1' 'install-ssh.psm1'
    InstallAndStart-OpenSsh
    StartProcess-WriteSshKeys
  }

  Set-EnvironmentVars
  Create-Directories
  Download-HelperScripts

  DownloadAndInstall-Crictl
  Configure-Crictl
  Setup-ContainerRuntime
  DownloadAndInstall-AuthPlugin
  DownloadAndInstall-KubernetesBinaries
  DownloadAndInstall-CSIProxyBinaries
  Start-CSIProxy
  Create-NodePki
  Create-KubeletKubeconfig
  Create-KubeproxyKubeconfig
  Set-PodCidr
  Configure-HostNetworkingService
  Prepare-CniNetworking
  Configure-HostDnsConf
  Configure-GcePdTools
  Configure-Kubelet

  # Even if Logging agent is already installed, the function will still [re]start the service.
  if (IsLoggingEnabled $kube_env) {
    Install-LoggingAgent
    Configure-LoggingAgent
    Restart-LoggingAgent
  }
  # Flush cache to disk before starting kubelet & kube-proxy services
  # to make metadata server route and stackdriver service more persistent.
  Write-Volumecache C -PassThru
  Start-WorkerServices
  Log-Output 'Waiting 15 seconds for node to join cluster.'
  Start-Sleep 15
  Verify-WorkerServices

  $config = New-FileRotationConfig
  # TODO(random-liu): Generate containerd log into the log directory.
  Schedule-LogRotation -Pattern '.*\.log$' -Path ${env:LOGS_DIR} -RepetitionInterval $(New-Timespan -Hour 1) -Config $config

  Pull-InfraContainer
  # Flush cache to disk to persist the setup status
  Write-Volumecache C -PassThru
}
catch {
  Write-Host 'Exception caught in script:'
  Write-Host $_.InvocationInfo.PositionMessage
# Copyright 2019 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

<#
.SYNOPSIS
  Library for configuring Windows nodes and joining them to the cluster.

.NOTES
  This module depends on common.psm1.

  Some portions copied / adapted from
  https://github.com/Microsoft/SDN/blob/master/Kubernetes/windows/start-kubelet.ps1.

.EXAMPLE
  Suggested usage for dev/test:
    [Net.ServicePointManager]::SecurityProtocol = `
        [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest `
        https://github.com/kubernetes/kubernetes/raw/master/cluster/gce/windows/k8s-node-setup.psm1 `
        -OutFile C:\k8s-node-setup.psm1
    Invoke-WebRequest `
        https://github.com/kubernetes/kubernetes/raw/master/cluster/gce/windows/configure.ps1 `
        -OutFile C:\configure.ps1
    Import-Module -Force C:\k8s-node-setup.psm1  # -Force to override existing
    # Execute functions manually or run configure.ps1.
#>

# IMPORTANT PLEASE NOTE:
# Any time the file structure in the `windows` directory changes, `windows/BUILD`
# and `k8s.io/release/lib/releaselib.sh` must be manually updated with the changes.
# We HIGHLY recommend not changing the file structure, because consumers of
# Kubernetes releases depend on the release structure remaining stable.

# TODO: update scripts for these style guidelines:
#  - Remove {} around variable references unless actually needed for clarity.
#  - Always use single-quoted strings unless actually interpolating variables
#    or using escape characters.
#  - Use "approved verbs":
#    https://docs.microsoft.com/en-us/powershell/developer/cmdlet/approved-verbs-for-windows-powershell-commands
#  - Document functions using proper syntax:
#    https://technet.microsoft.com/en-us/library/hh847834(v=wps.620).aspx

$GCE_METADATA_SERVER = "169.254.169.254"
# The "management" interface is used by the kubelet and by Windows pods to talk
# to the rest of the Kubernetes cluster *without NAT*. This interface does not
# exist until an initial HNS network has been created on the Windows node - see
# Add_InitialHnsNetwork().
$MGMT_ADAPTER_NAME = "vEthernet (Ethernet*"
$CRICTL_VERSION = 'v1.20.0'
$CRICTL_SHA256 = 'cc909108ee84d39b2e9d7ac0cb9599b6fa7fc51f5a7da7014052684cd3e3f65e'

Import-Module -Force C:\common.psm1

# Writes a TODO with $Message to the console.
function Log_Todo {
  param (
    [parameter(Mandatory=$true)] [string]$Message
  )
  Log-Output "TODO: ${Message}"
}

# Writes a not-implemented warning with $Message to the console and exits the
# script.
function Log_NotImplemented {
  param (
    [parameter(Mandatory=$true)] [string]$Message
  )
  Log-Output "Not implemented yet: ${Message}" -Fatal
}

# Fails and exits if the route to the GCE metadata server is not present,
# otherwise does nothing and emits nothing.
function Verify_GceMetadataServerRouteIsPresent {
  Try {
    Get-NetRoute `
        -ErrorAction "Stop" `
        -AddressFamily IPv4 `
        -DestinationPrefix ${GCE_METADATA_SERVER}/32 | Out-Null
  } Catch [Microsoft.PowerShell.Cmdletization.Cim.CimJobException] {
    Log-Output -Fatal `
        ("GCE metadata server route is not present as expected.`n" +
         "$(Get-NetRoute -AddressFamily IPv4 | Out-String)")
  }
}

# Checks if the route to the GCE metadata server is present. Returns when the
# route is NOT present or after a timeout has expired.
function WaitFor_GceMetadataServerRouteToBeRemoved {
  $elapsed = 0
  $timeout = 60
  Log-Output ("Waiting up to ${timeout} seconds for GCE metadata server " +
              "route to be removed")
  while (${elapsed} -lt ${timeout}) {
    Try {
      Get-NetRoute `
          -ErrorAction "Stop" `
          -AddressFamily IPv4 `
          -DestinationPrefix ${GCE_METADATA_SERVER}/32 | Out-Null
    } Catch [Microsoft.PowerShell.Cmdletization.Cim.CimJobException] {
      break
    }
    $sleeptime = 2
    Start-Sleep ${sleeptime}
    ${elapsed} += ${sleeptime}
  }
}

# Adds a route to the GCE metadata server to every network interface.
function Add_GceMetadataServerRoute {
  # Before setting up HNS the Windows VM has a "vEthernet (nat)" interface and
  # a "Ethernet" interface, and the route to the metadata server exists on the
  # Ethernet interface. After adding the HNS network a "vEthernet (Ethernet)"
  # interface is added, and it seems to subsume the routes of the "Ethernet"
  # interface (trying to add routes on the Ethernet interface at this point just
  # results in "New-NetRoute : Element not found" errors). I don't know what's
  # up with that, but since it's hard to know what's the right thing to do here
  # we just try to add the route on all of the network adapters.
  Get-NetAdapter | ForEach-Object {
    $adapter_index = $_.InterfaceIndex
    New-NetRoute `
        -ErrorAction Ignore `
        -DestinationPrefix "${GCE_METADATA_SERVER}/32" `
        -InterfaceIndex ${adapter_index} | Out-Null
  }
}

# Returns a PowerShell object representing the Windows version.
function Get_WindowsVersion {
  # Unlike checking `[System.Environment]::OSVersion.Version`, this long-winded
  # approach gets the OS revision/patch number correctly
  # (https://superuser.com/a/1160428/652018).
  $win_ver = New-Object -TypeName PSObject
  $win_ver | Add-Member -MemberType NoteProperty -Name Major -Value $(Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion' CurrentMajorVersionNumber).CurrentMajorVersionNumber
  $win_ver | Add-Member -MemberType NoteProperty -Name Minor -Value $(Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion' CurrentMinorVersionNumber).CurrentMinorVersionNumber
  $win_ver | Add-Member -MemberType NoteProperty -Name Build -Value $(Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion' CurrentBuild).CurrentBuild
  $win_ver | Add-Member -MemberType NoteProperty -Name Revision -Value $(Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion' UBR).UBR
  return $win_ver
}

# Writes debugging information, such as Windows version and patch info, to the
# console.
function Dump-DebugInfoToConsole {
  Try {
    $version = Get_WindowsVersion | Out-String
    $hotfixes = "$(Get-Hotfix | Out-String)"
    $image = "$(Get-InstanceMetadata 'image' | Out-String)"
    Log-Output "Windows version:`n$version"
    Log-Output "Installed hotfixes:`n$hotfixes"
    Log-Output "GCE Windows image:`n$image"
  } Catch { }
}

# Configures Window Defender preferences
function Configure-WindowsDefender {
  if ((Get-WindowsFeature -Name 'Windows-Defender').Installed) {
    Log-Output "Configuring Windows Defender preferences"
    Set-MpPreference -SubmitSamplesConsent NeverSend
    Log-Output "Disabling Windows Defender sample submission"
    Set-MpPreference -MAPSReporting Disabled
    Log-Output "Disabling Windows Defender Microsoft Active Protection Service Reporting"

    Log-Output "Defender Preferences"
    Get-MpPreference
  }
}

# Converts the kube-env string in Yaml
#
# Returns: a PowerShell Hashtable object containing the key-value pairs from
#   kube-env.
function ConvertFrom_Yaml_KubeEnv {
  param (
    [parameter(Mandatory=$true)] [string]$kube_env_str
  )
  $kube_env_table = @{}
  $currentLine = $null
  switch -regex (${kube_env_str} -split '\r?\n') {
      '^(\S.*)' {
          # record start pattern, line that doesn't start with a whitespace
          if ($null -ne $currentLine) {
              $key, $val = $currentLine -split ":",2
              $kube_env_table[$key] = $val.Trim("'", " ", "`"")
          }
          $currentLine = $matches.1
          continue
      }

      '^(\s+.*)' {
          # line that start with whitespace
          $currentLine += $matches.1
          continue
      }
  }

  # Handle the last line if any
  if ($currentLine) {
      $key, $val = $currentLine -split ":",2
      $kube_env_table[$key] = $val.Trim("'", " ", "`"")
  }

  return ${kube_env_table}
}

# Fetches the kube-env from the instance metadata.
#
# Returns: a PowerShell Hashtable object containing the key-value pairs from
#   kube-env.
function Fetch-KubeEnv {
  # Testing / debugging:
  # First:
  #   ${kube_env} = Get-InstanceMetadataAttribute 'kube-env'
  # or:
  #   ${kube_env} = [IO.File]::ReadAllText(".\kubeEnv.txt")
  # ${kube_env_table} = ConvertFrom_Yaml_KubeEnv ${kube_env}
  # ${kube_env_table}
  # ${kube_env_table}.GetType()

  # The type of kube_env is a powershell String.
  $kube_env = Get-InstanceMetadataAttribute 'kube-env'
  $kube_env_table = ConvertFrom_Yaml_KubeEnv ${kube_env}
  return ${kube_env_table}
}

# Sets the environment variable $Key to $Value at the Machine scope (will
# be present in the environment for all new shells after a reboot).
function Set_MachineEnvironmentVar {
  param (
    [parameter(Mandatory=$true)] [string]$Key,
    [parameter(Mandatory=$true)] [AllowEmptyString()] [string]$Value
  )
  [Environment]::SetEnvironmentVariable($Key, $Value, "Machine")
}

# Sets the environment variable $Key to $Value in the current shell.
function Set_CurrentShellEnvironmentVar {
  param (
    [parameter(Mandatory=$true)] [string]$Key,
    [parameter(Mandatory=$true)] [AllowEmptyString()] [string]$Value
  )
  $expression = '$env:' + $Key + ' = "' + $Value + '"'
  Invoke-Expression ${expression}
}

# Sets environment variables used by Kubernetes binaries and by other functions
# in this module. Depends on numerous ${kube_env} keys.
function Set-EnvironmentVars {
  if ($kube_env.ContainsKey('WINDOWS_CONTAINER_RUNTIME')) {
      $container_runtime = ${kube_env}['WINDOWS_CONTAINER_RUNTIME']
      $container_runtime_endpoint = ${kube_env}['WINDOWS_CONTAINER_RUNTIME_ENDPOINT']
  } else {
      Log-Output "ERROR: WINDOWS_CONTAINER_RUNTIME not set in kube-env, falling back in CONTAINER_RUNTIME"
      $container_runtime = ${kube_env}['CONTAINER_RUNTIME']
      $container_runtime_endpoint = ${kube_env}['CONTAINER_RUNTIME_ENDPOINT']
  }
  # Turning the kube-env values into environment variables is not required but
  # it makes debugging this script easier, and it also makes the syntax a lot
  # easier (${env:K8S_DIR} can be expanded within a string but
  # ${kube_env}['K8S_DIR'] cannot be afaik).
  $env_vars = @{
    "K8S_DIR" = ${kube_env}['K8S_DIR']
    # Typically 'C:\etc\kubernetes\node\bin' (not just 'C:\etc\kubernetes\node')
    "NODE_DIR" = ${kube_env}['NODE_DIR']
    "CNI_DIR" = ${kube_env}['CNI_DIR']
    "CNI_CONFIG_DIR" = ${kube_env}['CNI_CONFIG_DIR']
    "WINDOWS_CNI_STORAGE_PATH" = ${kube_env}['WINDOWS_CNI_STORAGE_PATH']
    "WINDOWS_CNI_VERSION" = ${kube_env}['WINDOWS_CNI_VERSION']
    "CSI_PROXY_STORAGE_PATH" = ${kube_env}['CSI_PROXY_STORAGE_PATH']
    "CSI_PROXY_VERSION" = ${kube_env}['CSI_PROXY_VERSION']
    "ENABLE_CSI_PROXY" = ${kube_env}['ENABLE_CSI_PROXY']
    "PKI_DIR" = ${kube_env}['PKI_DIR']
    "CA_FILE_PATH" = ${kube_env}['CA_FILE_PATH']
    "KUBELET_CONFIG" = ${kube_env}['KUBELET_CONFIG_FILE']
    "BOOTSTRAP_KUBECONFIG" = ${kube_env}['BOOTSTRAP_KUBECONFIG_FILE']
    "KUBECONFIG" = ${kube_env}['KUBECONFIG_FILE']
    "KUBEPROXY_KUBECONFIG" = ${kube_env}['KUBEPROXY_KUBECONFIG_FILE']
    "LOGS_DIR" = ${kube_env}['LOGS_DIR']
    "MANIFESTS_DIR" = ${kube_env}['MANIFESTS_DIR']
    "INFRA_CONTAINER" = ${kube_env}['WINDOWS_INFRA_CONTAINER']
    "WINDOWS_ENABLE_PIGZ" = ${kube_env}['WINDOWS_ENABLE_PIGZ']

    "Path" = ${env:Path} + ";" + ${kube_env}['NODE_DIR']
    "KUBE_NETWORK" = "l2bridge".ToLower()
    "KUBELET_CERT_PATH" = ${kube_env}['PKI_DIR'] + '\kubelet.crt'
    "KUBELET_KEY_PATH" = ${kube_env}['PKI_DIR'] + '\kubelet.key'

    "CONTAINER_RUNTIME" = $container_runtime
    "CONTAINER_RUNTIME_ENDPOINT" = $container_runtime_endpoint

    'LICENSE_DIR' = 'C:\Program Files\Google\Compute Engine\THIRD_PARTY_NOTICES'
  }

  # Set the environment variables in two ways: permanently on the machine (only
  # takes effect after a reboot), and in the current shell.
  $env_vars.GetEnumerator() | ForEach-Object{
    $message = "Setting environment variable: " + $_.key + " = " + $_.value
    Log-Output ${message}
    Set_MachineEnvironmentVar $_.key $_.value
    Set_CurrentShellEnvironmentVar $_.key $_.value
  }
}

# Configures various settings and prerequisites needed for the rest of the
# functions in this module and the Kubernetes binaries to operate properly.
function Set-PrerequisiteOptions {
  # Windows updates cause the node to reboot at arbitrary times.
  Log-Output "Disabling Windows Update service"
  & sc.exe config wuauserv start=disabled
  & sc.exe stop wuauserv

  # Use TLS 1.2: needed for Invoke-WebRequest downloads from github.com.
  [Net.ServicePointManager]::SecurityProtocol = `
      [Net.SecurityProtocolType]::Tls12

  Configure-WindowsDefender
}

# Creates directories where other functions in this module will read and write
# data.
# Note: C:\tmp is required for running certain kubernetes tests.
#       C:\var\log is used by kubelet to stored container logs and also
#       hard-coded in the fluentd/stackdriver config for log collection.
function Create-Directories {
  Log-Output "Creating ${env:K8S_DIR} and its subdirectories."
  ForEach ($dir in ("${env:K8S_DIR}", "${env:NODE_DIR}", "${env:LOGS_DIR}",
    "${env:CNI_DIR}", "${env:CNI_CONFIG_DIR}", "${env:MANIFESTS_DIR}",
    "${env:PKI_DIR}", "${env:LICENSE_DIR}"), "C:\tmp", "C:\var\log") {
    mkdir -Force $dir
  }
}

# Downloads some external helper scripts needed by other functions in this
# module.
function Download-HelperScripts {
  if (ShouldWrite-File ${env:K8S_DIR}\hns.psm1) {
    MustDownload-File `
        -OutFile ${env:K8S_DIR}\hns.psm1 `
        -URLs 'https://storage.googleapis.com/gke-release/winnode/config/sdn/master/hns.psm1'
  }
}

# Downloads the gke-exec-auth-plugin for TPM-based authentication to the
# master, if auth plugin support has been requested for this node (see
# Test-NodeUsesAuthPlugin).
# https://github.com/kubernetes/cloud-provider-gcp/tree/master/cmd/gke-exec-auth-plugin
#
# Required ${kube_env} keys:
#   EXEC_AUTH_PLUGIN_LICENSE_URL
#   EXEC_AUTH_PLUGIN_HASH
#   EXEC_AUTH_PLUGIN_URL
function DownloadAndInstall-AuthPlugin {
  if (-not (Test-NodeUsesAuthPlugin ${kube_env})) {
    Log-Output 'Skipping download of auth plugin'
    return
  }
  if (-not (ShouldWrite-File "${env:NODE_DIR}\gke-exec-auth-plugin.exe")) {
    return
  }

  if (-not ($kube_env.ContainsKey('EXEC_AUTH_PLUGIN_LICENSE_URL') -and
            $kube_env.ContainsKey('EXEC_AUTH_PLUGIN_HASH') -and
            $kube_env.ContainsKey('EXEC_AUTH_PLUGIN_URL'))) {
    Log-Output -Fatal ("Missing one or more kube-env keys needed for " +
                       "downloading auth plugin: $(Out-String $kube_env)")
  }
  MustDownload-File `
      -URLs ${kube_env}['EXEC_AUTH_PLUGIN_URL'] `
      -Hash ${kube_env}['EXEC_AUTH_PLUGIN_HASH'] `
      -OutFile "${env:NODE_DIR}\gke-exec-auth-plugin.exe"
  MustDownload-File `
      -URLs ${kube_env}['EXEC_AUTH_PLUGIN_LICENSE_URL'] `
      -OutFile "${env:LICENSE_DIR}\LICENSE_gke-exec-auth-plugin.txt"
}

# Downloads the Kubernetes binaries from kube-env's NODE_BINARY_TAR_URL and
# puts them in a subdirectory of $env:K8S_DIR.
#
# Required ${kube_env} keys:
#   NODE_BINARY_TAR_URL
function DownloadAndInstall-KubernetesBinaries {
  # Assume that presence of kubelet.exe indicates that the kubernetes binaries
  # were already previously downloaded to this node.
  if (-not (ShouldWrite-File ${env:NODE_DIR}\kubelet.exe)) {
    return
  }

  $tmp_dir = 'C:\k8s_tmp'
  New-Item -Force -ItemType 'directory' $tmp_dir | Out-Null

  $urls = ${kube_env}['NODE_BINARY_TAR_URL'].Split(",")
  $filename = Split-Path -leaf $urls[0]
  $hash = $null
  if ($kube_env.ContainsKey('NODE_BINARY_TAR_HASH')) {
    $hash = ${kube_env}['NODE_BINARY_TAR_HASH']
  }
  MustDownload-File -Hash $hash -OutFile $tmp_dir\$filename -URLs $urls

  tar xzvf $tmp_dir\$filename -C $tmp_dir
  Move-Item -Force $tmp_dir\kubernetes\node\bin\* ${env:NODE_DIR}\
  Move-Item -Force `
      $tmp_dir\kubernetes\LICENSES ${env:LICENSE_DIR}\LICENSES_kubernetes

  # Clean up the temporary directory
  Remove-Item -Force -Recurse $tmp_dir
}

# Downloads the csi-proxy binaries from kube-env's CSI_PROXY_STORAGE_PATH and
# CSI_PROXY_VERSION, and then puts them in a subdirectory of $env:NODE_DIR.
# Note: for now the installation is skipped for non-test clusters. Will be
# installed for all cluster after tests pass.
# Required ${kube_env} keys:
#   CSI_PROXY_STORAGE_PATH and CSI_PROXY_VERSION
function DownloadAndInstall-CSIProxyBinaries {
  if ("${env:ENABLE_CSI_PROXY}" -eq "true") {
    if (ShouldWrite-File ${env:NODE_DIR}\csi-proxy.exe) {
      $tmp_dir = 'C:\k8s_tmp'
      New-Item -Force -ItemType 'directory' $tmp_dir | Out-Null
      $filename = 'csi-proxy.exe'
      $urls = "${env:CSI_PROXY_STORAGE_PATH}/${env:CSI_PROXY_VERSION}/$filename"
      MustDownload-File -OutFile $tmp_dir\$filename -URLs $urls
      Move-Item -Force $tmp_dir\$filename ${env:NODE_DIR}\$filename
      # Clean up the temporary directory
      Remove-Item -Force -Recurse $tmp_dir
    }
  }
}

function Start-CSIProxy {
  if ("${env:ENABLE_CSI_PROXY}" -eq "true") {
    Log-Output "Creating CSI Proxy Service"
    $flags = "-windows-service -log_file=${env:LOGS_DIR}\csi-proxy.log -logtostderr=false"
    & sc.exe create csiproxy binPath= "${env:NODE_DIR}\csi-proxy.exe $flags"
    & sc.exe failure csiproxy reset= 0 actions= restart/10000
    Log-Output "Starting CSI Proxy Service"
    & sc.exe start csiproxy
  }
}

# TODO(pjh): this is copied from
# https://github.com/Microsoft/SDN/blob/master/Kubernetes/windows/start-kubelet.ps1#L98.
# See if there's a way to fetch or construct the "management subnet" so that
# this is not needed.
function ConvertTo_DecimalIP
{
  param(
    [parameter(Mandatory = $true, Position = 0)]
    [Net.IPAddress] $IPAddress
  )

  $i = 3; $decimal_ip = 0;
  $IPAddress.GetAddressBytes() | % {
    $decimal_ip += $_ * [Math]::Pow(256, $i); $i--
  }
  return [UInt32]$decimal_ip
}

# TODO(pjh): this is copied from
# https://github.com/Microsoft/SDN/blob/master/Kubernetes/windows/start-kubelet.ps1#L98.
# See if there's a way to fetch or construct the "management subnet" so that
# this is not needed.
function ConvertTo_DottedDecimalIP
{
  param(
    [parameter(Mandatory = $true, Position = 0)]
    [Uint32] $IPAddress
  )

  $dotted_ip = $(for ($i = 3; $i -gt -1; $i--) {
    $remainder = $IPAddress % [Math]::Pow(256, $i)
    ($IPAddress - $remainder) / [Math]::Pow(256, $i)
    $IPAddress = $remainder
  })
  return [String]::Join(".", $dotted_ip)
}

# TODO(pjh): this is copied from
# https://github.com/Microsoft/SDN/blob/master/Kubernetes/windows/start-kubelet.ps1#L98.
# See if there's a way to fetch or construct the "management subnet" so that
# this is not needed.
function ConvertTo_MaskLength
{
  param(
    [parameter(Mandatory = $True, Position = 0)]
    [Net.IPAddress] $SubnetMask
  )

  $bits = "$($SubnetMask.GetAddressBytes() | % {
    [Convert]::ToString($_, 2)
  } )" -replace "[\s0]"
  return $bits.Length
}

# Returns a network adapter object for the "management" interface via which the
# Windows pods+kubelet will communicate with the rest of the Kubernetes cluster.
#
# This function will fail if Add_InitialHnsNetwork() has not been called first.
function Get_MgmtNetAdapter {
  $net_adapter = Get-NetAdapter | Where-Object Name -like ${MGMT_ADAPTER_NAME}
  if (-not ${net_adapter}) {
    Throw ("Failed to find a suitable network adapter, check your network " +
           "settings.")
  }

  return $net_adapter
}

# Decodes the base64 $Data string and writes it as binary to $File. Does
# nothing if $File already exists and $REDO_STEPS is not set.
function Write_PkiData {
  param (
    [parameter(Mandatory=$true)] [string] $Data,
    [parameter(Mandatory=$true)] [string] $File
  )

  if (-not (ShouldWrite-File $File)) {
    return
  }

  # This command writes out a PEM certificate file, analogous to "base64
  # --decode" on Linux. See https://stackoverflow.com/a/51914136/1230197.
  [IO.File]::WriteAllBytes($File, [Convert]::FromBase64String($Data))
  Log_Todo ("need to set permissions correctly on ${File}; not sure what the " +
            "Windows equivalent of 'umask 077' is")
  # Linux: owned by root, rw by user only.
  #   -rw------- 1 root root 1.2K Oct 12 00:56 ca-certificates.crt
  #   -rw------- 1 root root 1.3K Oct 12 00:56 kubelet.crt
  #   -rw------- 1 root root 1.7K Oct 12 00:56 kubelet.key
  # Windows:
  #   https://docs.microsoft.com/en-us/dotnet/api/system.io.fileattributes
  #   https://docs.microsoft.com/en-us/dotnet/api/system.io.fileattributes
}

# Creates the node PKI files in $env:PKI_DIR.
#
# Required ${kube_env} keys:
#   CA_CERT
# ${kube_env} keys that can be omitted for nodes that do not use an
# authentication plugin:
#   KUBELET_CERT
#   KUBELET_KEY
function Create-NodePki {
  Log-Output 'Creating node pki files'

  if ($kube_env.ContainsKey('CA_CERT')) {
    $CA_CERT_BUNDLE = ${kube_env}['CA_CERT']
    Write_PkiData "${CA_CERT_BUNDLE}" ${env:CA_FILE_PATH}
  }
  else {
    Log-Output -Fatal 'CA_CERT not present in kube-env'
  }

  # On nodes that use a plugin to support authentication, KUBELET_CERT and
  # KUBELET_KEY will not be present - TPM_BOOTSTRAP_CERT and TPM_BOOTSTRAP_KEY
  # should be set instead.
  if (Test-NodeUsesAuthPlugin ${kube_env}) {
    Log-Output ('Skipping KUBELET_CERT and KUBELET_KEY, plugin will be used ' +
                'for authentication')
    return
  }

  if ($kube_env.ContainsKey('KUBELET_CERT')) {
    $KUBELET_CERT = ${kube_env}['KUBELET_CERT']
    Write_PkiData "${KUBELET_CERT}" ${env:KUBELET_CERT_PATH}
  }
  else {
    Log-Output -Fatal 'KUBELET_CERT not present in kube-env'
  }
  if ($kube_env.ContainsKey('KUBELET_KEY')) {
    $KUBELET_KEY = ${kube_env}['KUBELET_KEY']
    Write_PkiData "${KUBELET_KEY}" ${env:KUBELET_KEY_PATH}
  }
  else {
    Log-Output -Fatal 'KUBELET_KEY not present in kube-env'
  }

  Get-ChildItem ${env:PKI_DIR}
}

# Creates the bootstrap kubelet kubeconfig at $env:BOOTSTRAP_KUBECONFIG.
# https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/
#
# Create-NodePki() must be called first.
#
# Required ${kube_env} keys:
#   KUBERNETES_MASTER_NAME: the apiserver IP address.
function Write_BootstrapKubeconfig {
  if (-not (ShouldWrite-File ${env:BOOTSTRAP_KUBECONFIG})) {
    return
  }

  # TODO(mtaufen): is user "kubelet" correct? Other examples use e.g.
  # "system:node:$(hostname)".

  $apiserverAddress = ${kube_env}['KUBERNETES_MASTER_NAME']
  New-Item -Force -ItemType file ${env:BOOTSTRAP_KUBECONFIG} | Out-Null
  Set-Content ${env:BOOTSTRAP_KUBECONFIG} `
'apiVersion: v1
kind: Config
users:
- name: kubelet
  user:
    client-certificate: KUBELET_CERT_PATH
    client-key: KUBELET_KEY_PATH
clusters:
- name: local
  cluster:
    server: https://APISERVER_ADDRESS
    certificate-authority: CA_FILE_PATH
contexts:
- context:
    cluster: local
    user: kubelet
  name: service-account-context
current-context: service-account-context'.`
    replace('KUBELET_CERT_PATH', ${env:KUBELET_CERT_PATH}).`
    replace('KUBELET_KEY_PATH', ${env:KUBELET_KEY_PATH}).`
    replace('APISERVER_ADDRESS', ${apiserverAddress}).`
    replace('CA_FILE_PATH', ${env:CA_FILE_PATH})
  Log-Output ("kubelet bootstrap kubeconfig:`n" +
              "$(Get-Content -Raw ${env:BOOTSTRAP_KUBECONFIG})")
}

# Fetches the kubelet kubeconfig from the metadata server and writes it to
# $env:KUBECONFIG.
#
# Create-NodePki() must be called first.
function Write_KubeconfigFromMetadata {
  if (-not (ShouldWrite-File ${env:KUBECONFIG})) {
    return
  }

  $kubeconfig = Get-InstanceMetadataAttribute 'kubeconfig'
  if ($kubeconfig -eq $null) {
    Log-Output `
        "kubeconfig metadata key not found, can't write ${env:KUBECONFIG}" `
        -Fatal
  }
  Set-Content ${env:KUBECONFIG} $kubeconfig
  Log-Output ("kubelet kubeconfig from metadata (non-bootstrap):`n" +
              "$(Get-Content -Raw ${env:KUBECONFIG})")
}

# Creates the kubelet kubeconfig at $env:KUBECONFIG for nodes that use an
# authentication plugin, or at $env:BOOTSTRAP_KUBECONFIG for nodes that do not.
#
# Create-NodePki() must be called first.
#
# Required ${kube_env} keys:
#   KUBERNETES_MASTER_NAME: the apiserver IP address.
function Create-KubeletKubeconfig {
  if (Test-NodeUsesAuthPlugin ${kube_env}) {
    Write_KubeconfigFromMetadata
  } else {
    Write_BootstrapKubeconfig
  }
}

# Creates the kube-proxy user kubeconfig file at $env:KUBEPROXY_KUBECONFIG.
#
# Create-NodePki() must be called first.
#
# Required ${kube_env} keys:
#   CA_CERT
#   KUBE_PROXY_TOKEN
function Create-KubeproxyKubeconfig {
  if (-not (ShouldWrite-File ${env:KUBEPROXY_KUBECONFIG})) {
    return
  }

  New-Item -Force -ItemType file ${env:KUBEPROXY_KUBECONFIG} | Out-Null

  # In configure-helper.sh kubelet kubeconfig uses certificate-authority while
  # kubeproxy kubeconfig uses certificate-authority-data, ugh. Does it matter?
  # Use just one or the other for consistency?
  Set-Content ${env:KUBEPROXY_KUBECONFIG} `
'apiVersion: v1
kind: Config
users:
- name: kube-proxy
  user:
    token: KUBEPROXY_TOKEN
clusters:
- name: local
  cluster:
    server: https://APISERVER_ADDRESS
    certificate-authority-data: CA_CERT
contexts:
- context:
    cluster: local
    user: kube-proxy
  name: service-account-context
current-context: service-account-context'.`
    replace('KUBEPROXY_TOKEN', ${kube_env}['KUBE_PROXY_TOKEN']).`
    replace('CA_CERT', ${kube_env}['CA_CERT']).`
    replace('APISERVER_ADDRESS', ${kube_env}['KUBERNETES_MASTER_NAME'])

  Log-Output ("kubeproxy kubeconfig:`n" +
              "$(Get-Content -Raw ${env:KUBEPROXY_KUBECONFIG})")
}

# Returns the IP alias range configured for this GCE instance.
function Get_IpAliasRange {
  $url = ("http://${GCE_METADATA_SERVER}/computeMetadata/v1/instance/" +
          "network-interfaces/0/ip-aliases/0")
  $client = New-Object Net.WebClient
  $client.Headers.Add('Metadata-Flavor', 'Google')
  return ($client.DownloadString($url)).Trim()
}

# Retrieves the pod CIDR and sets it in $env:POD_CIDR.
function Set-PodCidr {
  while($true) {
    $pod_cidr = Get_IpAliasRange
    if (-not $?) {
      Log-Output ${pod_cIDR}
      Log-Output "Retrying Get_IpAliasRange..."
      Start-Sleep -sec 1
      continue
    }
    break
  }

  Log-Output "fetched pod CIDR (same as IP alias range): ${pod_cidr}"
  Set_MachineEnvironmentVar "POD_CIDR" ${pod_cidr}
  Set_CurrentShellEnvironmentVar "POD_CIDR" ${pod_cidr}
}

# Adds an initial HNS network on the Windows node which forces the creation of
# a virtual switch and the "management" interface that will be used to
# communicate with the rest of the Kubernetes cluster without NAT.
#
# Note that adding the initial HNS network may cause connectivity to the GCE
# metadata server to be lost due to a Windows bug.
# Configure-HostNetworkingService() restores connectivity, look there for
# details.
#
# Download-HelperScripts() must have been called first.
function Add_InitialHnsNetwork {
  $INITIAL_HNS_NETWORK = 'External'

  # This comes from
  # https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/start.ps1#L74
  # (or
  # https://github.com/Microsoft/SDN/blob/master/Kubernetes/windows/start-kubelet.ps1#L206).
  #
  # daschott noted on Slack: "L2bridge networks require an external vSwitch.
  # The first network ("External") with hardcoded values in the script is just
  # a placeholder to create an external vSwitch. This is purely for convenience
  # to be able to remove/modify the actual HNS network ("cbr0") or rejoin the
  # nodes without a network blip. Creating a vSwitch takes time, causes network
  # blips, and it makes it more likely to hit the issue where flanneld is
  # stuck, so we want to do this as rarely as possible."
  $hns_network = Get-HnsNetwork | Where-Object Name -eq $INITIAL_HNS_NETWORK
  if ($hns_network) {
    if ($REDO_STEPS) {
      Log-Output ("Warning: initial '$INITIAL_HNS_NETWORK' HNS network " +
                  "already exists, removing it and recreating it")
      $hns_network | Remove-HnsNetwork
      $hns_network = $null
    }
    else {
      Log-Output ("Skip: initial '$INITIAL_HNS_NETWORK' HNS network " +
                  "already exists, not recreating it")
      return
    }
  }
  Log-Output ("Creating initial HNS network to force creation of " +
              "${MGMT_ADAPTER_NAME} interface")
  # Note: RDP connection will hiccup when running this command.
  New-HNSNetwork `
      -Type "L2Bridge" `
      -AddressPrefix "192.168.255.0/30" `
      -Gateway "192.168.255.1" `
      -Name $INITIAL_HNS_NETWORK `
      -Verbose
}

# Get the network in uint32 for the given cidr
function Get_NetworkDecimal_From_CIDR([string] $cidr) {
  $network, [int]$subnetlen = $cidr.Split('/')
  $decimal_network = ConvertTo_DecimalIP($network)
  return $decimal_network
}

# Get gateway ip string (the first address) based on pod cidr.
# For Windows nodes the pod gateway IP address is the first address in the pod
# CIDR for the host.
function Get_Gateway_From_CIDR([string] $cidr) {
  $network=Get_NetworkDecimal_From_CIDR($cidr)
  $gateway=ConvertTo_DottedDecimalIP($network+1)
  return $gateway
}

# Get endpoint gateway ip string (the second address) based on pod cidr.
# For Windows nodes the pod gateway IP address is the first address in the pod
# CIDR for the host, but from inside containers it's the second address.
function Get_Endpoint_Gateway_From_CIDR([string] $cidr) {
  $network=Get_NetworkDecimal_From_CIDR($cidr)
  $gateway=ConvertTo_DottedDecimalIP($network+2)
  return $gateway
}

# Get pod IP range start based (the third address) on pod cidr
# We reserve the first two in the cidr range for gateways. Start the cidr
# range from the third so that IPAM does not allocate those IPs to pods.
function Get_PodIP_Range_Start([string] $cidr) {
  $network=Get_NetworkDecimal_From_CIDR($cidr)
  $start=ConvertTo_DottedDecimalIP($network+3)
  return $start
}

# Configures HNS on the Windows node to enable Kubernetes networking:
#   - Creates the "management" interface associated with an initial HNS network.
#   - Creates the HNS network $env:KUBE_NETWORK for pod networking.
#   - Creates an HNS endpoint for pod networking.
#   - Adds necessary routes on the management interface.
#   - Verifies that the GCE metadata server connection remains intact.
#
# Prerequisites:
#   $env:POD_CIDR is set (by Set-PodCidr).
#   Download-HelperScripts() has been called.
function Configure-HostNetworkingService {
  Import-Module -Force ${env:K8S_DIR}\hns.psm1

  Add_InitialHnsNetwork

  $pod_gateway = Get_Gateway_From_CIDR(${env:POD_CIDR})
  $pod_endpoint_gateway = Get_Endpoint_Gateway_From_CIDR(${env:POD_CIDR})
  Log-Output ("Setting up Windows node HNS networking: " +
              "podCidr = ${env:POD_CIDR}, podGateway = ${pod_gateway}, " +
              "podEndpointGateway = ${pod_endpoint_gateway}")

  $hns_network = Get-HnsNetwork | Where-Object Name -eq ${env:KUBE_NETWORK}
  if ($hns_network) {
    if ($REDO_STEPS) {
      Log-Output ("Warning: ${env:KUBE_NETWORK} HNS network already exists, " +
                  "removing it and recreating it")
      $hns_network | Remove-HnsNetwork
      $hns_network = $null
    }
    else {
      Log-Output "Skip: ${env:KUBE_NETWORK} HNS network already exists"
    }
  }
  $created_hns_network = $false
  if (-not $hns_network) {
    # Note: RDP connection will hiccup when running this command.
    $hns_network = New-HNSNetwork `
        -Type "L2Bridge" `
        -AddressPrefix ${env:POD_CIDR} `
        -Gateway ${pod_gateway} `
        -Name ${env:KUBE_NETWORK} `
        -Verbose
    $created_hns_network = $true
  }

  $endpoint_name = "cbr0"
  $vnic_name = "vEthernet (${endpoint_name})"

  $hns_endpoint = Get-HnsEndpoint | Where-Object Name -eq $endpoint_name
  # Note: we don't expect to ever enter this block currently - while the HNS
  # network does seem to persist across reboots, the HNS endpoints do not.
  if ($hns_endpoint) {
    if ($REDO_STEPS) {
      Log-Output ("Warning: HNS endpoint $endpoint_name already exists, " +
                  "removing it and recreating it")
      $hns_endpoint | Remove-HnsEndpoint
      $hns_endpoint = $null
    }
    else {
      Log-Output "Skip: HNS endpoint $endpoint_name already exists"
    }
  }
  if (-not $hns_endpoint) {
    $hns_endpoint = New-HnsEndpoint `
        -NetworkId ${hns_network}.Id `
        -Name ${endpoint_name} `
        -IPAddress ${pod_endpoint_gateway} `
        -Gateway "0.0.0.0" `
        -Verbose
    # TODO(pjh): find out: why is this always CompartmentId 1?
    Attach-HnsHostEndpoint `
        -EndpointID ${hns_endpoint}.Id `
        -CompartmentID 1 `
        -Verbose
    netsh interface ipv4 set interface "${vnic_name}" forwarding=enabled
  }

  Try {
    Get-HNSPolicyList | Remove-HnsPolicyList
  } Catch { }

  # Add a route from the management NIC to the pod CIDR.
  #
  # When a packet from a Kubernetes service backend arrives on the destination
  # Windows node, the reverse SNAT will be applied and the source address of
  # the packet gets replaced from the pod IP to the service VIP. The packet
  # will then leave the VM and return back through hairpinning.
  #
  # When IP alias is enabled, IP forwarding is disabled for anti-spoofing;
  # the packet with the service VIP will get blocked and be lost. With this
  # route, the packet will be routed to the pod subnetwork, and not leave the
  # VM.
  $mgmt_net_adapter = Get_MgmtNetAdapter
  New-NetRoute `
      -ErrorAction Ignore `
      -InterfaceAlias ${mgmt_net_adapter}.ifAlias `
      -DestinationPrefix ${env:POD_CIDR} `
      -NextHop "0.0.0.0" `
      -Verbose

  if ($created_hns_network) {
    # There is an HNS bug where the route to the GCE metadata server will be
    # removed when the HNS network is created:
    # https://github.com/Microsoft/hcsshim/issues/299#issuecomment-425491610.
    # The behavior here is very unpredictable: the route may only be removed
    # after some delay, or it may appear to be removed then you'll add it back
    # but then it will be removed once again. So, we first wait a long
    # unfortunate amount of time to ensure that things have quiesced, then we
    # wait until we're sure the route is really gone before re-adding it again.
    Log-Output "Waiting 45 seconds for host network state to quiesce"
    Start-Sleep 45
    WaitFor_GceMetadataServerRouteToBeRemoved
    Log-Output "Re-adding the GCE metadata server route"
    Add_GceMetadataServerRoute
  }
  Verify_GceMetadataServerRouteIsPresent

  Log-Output "Host network setup complete"
}

function Configure-GcePdTools {
  if (ShouldWrite-File ${env:K8S_DIR}\GetGcePdName.dll) {
    MustDownload-File -OutFile ${env:K8S_DIR}\GetGcePdName.dll `
      -URLs "https://storage.googleapis.com/gke-release/winnode/config/gce-tools/master/GetGcePdName/GetGcePdName.dll"
  }
  if (-not (Test-Path $PsHome\profile.ps1)) {
    New-Item -path $PsHome\profile.ps1 -type file
  }

  Add-Content $PsHome\profile.ps1 `
  '$modulePath = "K8S_DIR\GetGcePdName.dll"
  Unblock-File $modulePath
  Import-Module -Name $modulePath'.replace('K8S_DIR', ${env:K8S_DIR})
}

# Setup cni network. This function supports both Docker and containerd.
function Prepare-CniNetworking {
  if (${env:CONTAINER_RUNTIME} -eq "containerd") {
    # For containerd the CNI binaries have already been installed along with
    # the runtime.
    Configure_Containerd_CniNetworking
  } else {
    Install_Cni_Binaries
    Configure_Dockerd_CniNetworking
  }
}

# Downloads the Windows CNI binaries and puts them in $env:CNI_DIR.
function Install_Cni_Binaries {
  if (-not (ShouldWrite-File ${env:CNI_DIR}\win-bridge.exe) -and
      -not (ShouldWrite-File ${env:CNI_DIR}\host-local.exe)) {
    return
  }

  $tmp_dir = 'C:\cni_tmp'
  New-Item $tmp_dir -ItemType 'directory' -Force | Out-Null

  $release_url = "${env:WINDOWS_CNI_STORAGE_PATH}/${env:WINDOWS_CNI_VERSION}/"
  $tgz_url = ($release_url +
              "cni-plugins-windows-amd64-${env:WINDOWS_CNI_VERSION}.tgz")
  $sha_url = ($tgz_url + ".sha512")
  MustDownload-File -URLs $sha_url -OutFile $tmp_dir\cni-plugins.sha512
  $sha512_val = ($(Get-Content $tmp_dir\cni-plugins.sha512) -split ' ',2)[0]
  MustDownload-File `
      -URLs $tgz_url `
      -OutFile $tmp_dir\cni-plugins.tgz `
      -Hash $sha512_val

  tar xzvf $tmp_dir\cni-plugins.tgz -C $tmp_dir
  Move-Item -Force $tmp_dir\host-local.exe ${env:CNI_DIR}\
  Move-Item -Force $tmp_dir\win-bridge.exe ${env:CNI_DIR}\
  Remove-Item -Force -Recurse $tmp_dir

  if (-not ((Test-Path ${env:CNI_DIR}\win-bridge.exe) -and `
            (Test-Path ${env:CNI_DIR}\host-local.exe))) {
    Log-Output `
        "win-bridge.exe and host-local.exe not found in ${env:CNI_DIR}" `
        -Fatal
  }
}

# Writes a CNI config file under $env:CNI_CONFIG_DIR.
#
# Prerequisites:
#   $env:POD_CIDR is set (by Set-PodCidr).
#   The "management" interface exists (Configure-HostNetworkingService).
#   The HNS network for pod networking has been configured
#     (Configure-HostNetworkingService).
#
# Required ${kube_env} keys:
#   DNS_SERVER_IP
#   DNS_DOMAIN
#   SERVICE_CLUSTER_IP_RANGE
function Configure_Dockerd_CniNetworking {
  $l2bridge_conf = "${env:CNI_CONFIG_DIR}\l2bridge.conf"
  if (-not (ShouldWrite-File ${l2bridge_conf})) {
    return
  }

  $mgmt_ip = (Get_MgmtNetAdapter |
              Get-NetIPAddress -AddressFamily IPv4).IPAddress

  $cidr_range_start = Get_PodIP_Range_Start(${env:POD_CIDR})

  # Explanation of the CNI config values:
  #   POD_CIDR: the pod CIDR assigned to this node.
  #   CIDR_RANGE_START: start of the pod CIDR range.
  #   MGMT_IP: the IP address assigned to the node's primary network interface
  #     (i.e. the internal IP of the GCE VM).
  #   SERVICE_CIDR: the CIDR used for kubernetes services.
  #   DNS_SERVER_IP: the cluster's DNS server IP address.
  #   DNS_DOMAIN: the cluster's DNS domain, e.g. "cluster.local".
  #
  # OutBoundNAT ExceptionList: No SNAT for CIDRs in the list, the same as default GKE non-masquerade destination ranges listed at https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#default-non-masq-dests

  New-Item -Force -ItemType file ${l2bridge_conf} | Out-Null
  Set-Content ${l2bridge_conf} `
'{
  "cniVersion":  "0.2.0",
  "name":  "l2bridge",
  "type":  "win-bridge",
  "capabilities":  {
    "portMappings":  true,
    "dns": true
  },
  "ipam":  {
    "type": "host-local",
    "subnet": "POD_CIDR",
    "rangeStart": "CIDR_RANGE_START"
  },
  "dns":  {
    "Nameservers":  [
      "DNS_SERVER_IP"
    ],
    "Search": [
      "DNS_DOMAIN"
    ]
  },
  "Policies":  [
    {
      "Name":  "EndpointPolicy",
      "Value":  {
        "Type":  "OutBoundNAT",
        "ExceptionList":  [
          "169.254.0.0/16",
          "10.0.0.0/8",
          "172.16.0.0/12",
          "192.168.0.0/16",
          "100.64.0.0/10",
          "192.0.0.0/24",
          "192.0.2.0/24",
          "192.88.99.0/24",
          "198.18.0.0/15",
          "198.51.100.0/24",
          "203.0.113.0/24",
          "240.0.0.0/4"
        ]
      }
    },
    {
      "Name":  "EndpointPolicy",
      "Value":  {
        "Type":  "ROUTE",
        "DestinationPrefix":  "SERVICE_CIDR",
        "NeedEncap":  true
      }
    },
    {
      "Name":  "EndpointPolicy",
      "Value":  {
        "Type":  "ROUTE",
        "DestinationPrefix":  "MGMT_IP/32",
        "NeedEncap":  true
      }
    }
  ]
}'.replace('POD_CIDR', ${env:POD_CIDR}).`
  replace('CIDR_RANGE_START', ${cidr_range_start}).`
  replace('DNS_SERVER_IP', ${kube_env}['DNS_SERVER_IP']).`
  replace('DNS_DOMAIN', ${kube_env}['DNS_DOMAIN']).`
  replace('MGMT_IP', ${mgmt_ip}).`
  replace('SERVICE_CIDR', ${kube_env}['SERVICE_CLUSTER_IP_RANGE'])

  Log-Output "CNI config:`n$(Get-Content -Raw ${l2bridge_conf})"
}

# Obtain the host dns conf and save it to a file so that kubelet/CNI
# can use it to configure dns suffix search list for pods.
# The value of DNS server is ignored right now because the pod will
# always only use cluster DNS service, but for consistency, we still
# parsed them here in the same format as Linux resolv.conf.
# This function must be called after Configure-HostNetworkingService.
function Configure-HostDnsConf {
  $net_adapter = Get_MgmtNetAdapter
  $server_ips = (Get-DnsClientServerAddress `
          -InterfaceAlias ${net_adapter}.Name).ServerAddresses
  $search_list = (Get-DnsClient).ConnectionSpecificSuffixSearchList
  $conf = ""
  ForEach ($ip in $server_ips)  {
    $conf = $conf + "nameserver $ip`r`n"
  }
  $conf = $conf + "search $search_list"
  # Do not put hostdns.conf into the CNI config directory so as to
  # avoid the container runtime treating it as CNI config.
  $hostdns_conf = "${env:CNI_DIR}\hostdns.conf"
  New-Item -Force -ItemType file ${hostdns_conf} | Out-Null
  Set-Content ${hostdns_conf} $conf
  Log-Output "HOST dns conf:`n$(Get-Content -Raw ${hostdns_conf})"
}

# Fetches the kubelet config from the instance metadata and puts it at
# $env:KUBELET_CONFIG.
function Configure-Kubelet {
  if (-not (ShouldWrite-File ${env:KUBELET_CONFIG})) {
    return
  }

  # The Kubelet config is built by build-kubelet-config() in
  # cluster/gce/util.sh, and stored in the metadata server under the
  # 'kubelet-config' key.
  $kubelet_config = Get-InstanceMetadataAttribute 'kubelet-config'
  Set-Content ${env:KUBELET_CONFIG} $kubelet_config
  Log-Output "Kubelet config:`n$(Get-Content -Raw ${env:KUBELET_CONFIG})"
}

# Sets up the kubelet and kube-proxy arguments and starts them as native
# Windows services.
#
# Required ${kube_env} keys:
#   KUBELET_ARGS
#   KUBEPROXY_ARGS
#   CLUSTER_IP_RANGE
function Start-WorkerServices {
  # Compute kubelet args
  $kubelet_args_str = ${kube_env}['KUBELET_ARGS']
  $kubelet_args = $kubelet_args_str.Split(" ")
  Log-Output "kubelet_args from metadata: ${kubelet_args}"

  # To join GCE instances to AD, we need to shorten their names, as NetBIOS name
  # must be <= 15 characters, and GKE generated names are longer than that.
  # To perform the join in an automated way, it's preferable to apply the rename
  # and domain join in the GCESysprep step. However, after sysprep is complete
  # and the machine restarts, kubelet bootstrapping should not use the shortened
  # computer name, and instead use the instance's name by using --hostname-override,
  # otherwise kubelet and kube-proxy will not be able to run properly.
  $instance_name = "$(Get-InstanceMetadata 'name' | Out-String)"
  $default_kubelet_args = @(`
      "--pod-infra-container-image=${env:INFRA_CONTAINER}",
      "--hostname-override=${instance_name}"
  )

  $kubelet_args = ${default_kubelet_args} + ${kubelet_args}
  if (-not (Test-NodeUsesAuthPlugin ${kube_env})) {
    Log-Output 'Using bootstrap kubeconfig for authentication'
    $kubelet_args = (${kubelet_args} +
                     "--bootstrap-kubeconfig=${env:BOOTSTRAP_KUBECONFIG}")
  }
  Log-Output "Final kubelet_args: ${kubelet_args}"

  # Compute kube-proxy args
  $kubeproxy_args_str = ${kube_env}['KUBEPROXY_ARGS']
  $kubeproxy_args = $kubeproxy_args_str.Split(" ")
  Log-Output "kubeproxy_args from metadata: ${kubeproxy_args}"

  # kubeproxy is started on Linux nodes using
  # kube-manifests/kubernetes/gci-trusty/kube-proxy.manifest, which is
  # generated by start-kube-proxy in configure-helper.sh and contains e.g.:
  #   kube-proxy --master=https://35.239.84.171
  #   --kubeconfig=/var/lib/kube-proxy/kubeconfig --cluster-cidr=10.64.0.0/14
  #   --oom-score-adj=-998 --v=2
  #   --iptables-sync-period=1m --iptables-min-sync-period=10s
  #   --ipvs-sync-period=1m --ipvs-min-sync-period=10s
  # And also with various volumeMounts and "securityContext: privileged: true".
  $default_kubeproxy_args = @(`
      "--kubeconfig=${env:KUBEPROXY_KUBECONFIG}",
      "--cluster-cidr=$(${kube_env}['CLUSTER_IP_RANGE'])",
      "--hostname-override=${instance_name}"
  )

  $kubeproxy_args = ${default_kubeproxy_args} + ${kubeproxy_args}
  Log-Output "Final kubeproxy_args: ${kubeproxy_args}"

  # TODO(pjh): kubelet is emitting these messages:
  # I1023 23:44:11.761915    2468 kubelet.go:274] Adding pod path:
  # C:\etc\kubernetes
  # I1023 23:44:11.775601    2468 file.go:68] Watching path
  # "C:\\etc\\kubernetes"
  # ...
  # E1023 23:44:31.794327    2468 file.go:182] Can't process manifest file
  # "C:\\etc\\kubernetes\\hns.psm1": C:\etc\kubernetes\hns.psm1: couldn't parse
  # as pod(yaml: line 10: did not find expected <document start>), please check
  # config file.
  #
  # Figure out how to change the directory that the kubelet monitors for new
  # pod manifests.

  # We configure the service to restart on failure, after 10s wait. We reset
  # the restart count to 0 each time, so we re-use our restart/10000 action on
  # each failure. Note it currently restarts even when explicitly stopped, you
  # have to delete the service entry to *really* kill it (e.g. `sc.exe delete
  # kubelet`). See issue #72900.
  if (Get-Process | Where-Object Name -eq "kubelet") {
    Log-Output -Fatal `
        "A kubelet process is already running, don't know what to do"
  }
  Log-Output "Creating kubelet service"
  & sc.exe create kubelet binPath= "${env:NODE_DIR}\kubelet.exe ${kubelet_args}" start= demand
  & sc.exe failure kubelet reset= 0 actions= restart/10000
  Log-Output "Starting kubelet service"
  & sc.exe start kubelet

  Log-Output "Waiting 10 seconds for kubelet to stabilize"
  Start-Sleep 10

  if (Get-Process | Where-Object Name -eq "kube-proxy") {
    Log-Output -Fatal `
        "A kube-proxy process is already running, don't know what to do"
  }
  Log-Output "Creating kube-proxy service"
  & sc.exe create kube-proxy binPath= "${env:NODE_DIR}\kube-proxy.exe ${kubeproxy_args}" start= demand
  & sc.exe failure kube-proxy reset= 0 actions= restart/10000
  Log-Output "Starting kube-proxy service"
  & sc.exe start kube-proxy

  # F1020 23:08:52.000083    9136 server.go:361] unable to load in-cluster
  # configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be
  # defined
  # TODO(pjh): still getting errors like these in kube-proxy log:
  # E1023 04:03:58.143449    4840 reflector.go:205] k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion/factory.go:129: Failed to list *core.Endpoints: Get https://35.239.84.171/api/v1/endpoints?limit=500&resourceVersion=0: dial tcp 35.239.84.171:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.
  # E1023 04:03:58.150266    4840 reflector.go:205] k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion/factory.go:129: Failed to list *core.Service: Get https://35.239.84.171/api/v1/services?limit=500&resourceVersion=0: dial tcp 35.239.84.171:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.
  WaitFor_KubeletAndKubeProxyReady
  Verify_GceMetadataServerRouteIsPresent
  Log-Output "Kubernetes components started successfully"
}

# Wait for kubelet and kube-proxy to be ready within 10s.
function WaitFor_KubeletAndKubeProxyReady {
  $waited = 0
  $timeout = 10
  while (((Get-Service kube-proxy).Status -ne 'Running' -or (Get-Service kubelet).Status -ne 'Running') -and $waited -lt $timeout) {
    Start-Sleep 1
    $waited++
  }

  # Timeout occurred
  if ($waited -ge $timeout) {
    Log-Output "$(Get-Service kube* | Out-String)"
    Throw ("Timeout while waiting ${timeout} seconds for kubelet and kube-proxy services to start")
  }
}

# Runs 'kubectl get nodes'.
# TODO(pjh): run more verification commands.
function Verify-WorkerServices {
  Log-Output ("kubectl get nodes:`n" +
              $(& "${env:NODE_DIR}\kubectl.exe" get nodes | Out-String))
  Verify_GceMetadataServerRouteIsPresent
  Log_Todo "run more verification commands."
}

# Downloads the Windows crictl package and installs its contents (e.g.
# crictl.exe) in $env:NODE_DIR.
function DownloadAndInstall-Crictl {
  if (-not (ShouldWrite-File ${env:NODE_DIR}\crictl.exe)) {
    return
  }
  $CRI_TOOLS_GCS_BUCKET = 'k8s-artifacts-cri-tools'
  $url = ('https://storage.googleapis.com/' + $CRI_TOOLS_GCS_BUCKET +
          '/release/' + $CRICTL_VERSION + '/crictl-' + $CRICTL_VERSION +
          '-windows-amd64.tar.gz')
  MustDownload-File `
      -URLs $url `
      -OutFile ${env:NODE_DIR}\crictl.tar.gz `
      -Hash $CRICTL_SHA256 `
      -Algorithm SHA256
  tar xzvf ${env:NODE_DIR}\crictl.tar.gz -C ${env:NODE_DIR}
}

# Sets crictl configuration values.
function Configure-Crictl {
  if (${env:CONTAINER_RUNTIME_ENDPOINT}) {
    & "${env:NODE_DIR}\crictl.exe" config runtime-endpoint `
        ${env:CONTAINER_RUNTIME_ENDPOINT}
  }
}

# Pulls the infra/pause container image onto the node so that it will be
# immediately available when the kubelet tries to run pods.
# TODO(pjh): downloading the container container image may take a few minutes;
# figure out how to run this in the background while perform the rest of the
# node startup steps!
# Pull-InfraContainer must be called AFTER Verify-WorkerServices.
function Pull-InfraContainer {
  $name, $label = ${env:INFRA_CONTAINER} -split ':',2
  if (-not ("$(& crictl images)" -match "$name.*$label")) {
    & crictl pull ${env:INFRA_CONTAINER}
    if (!$?) {
      throw "Error running 'crictl pull ${env:INFRA_CONTAINER}'"
    }
  }
  $inspect = "$(& crictl inspecti ${env:INFRA_CONTAINER} | Out-String)"
  Log-Output "Infra/pause container:`n$inspect"
}

# Setup the container runtime on the node. It supports both
# Docker and containerd.
function Setup-ContainerRuntime {
  Install-Pigz
  if (${env:CONTAINER_RUNTIME} -eq "containerd") {
    Install_Containerd
    Configure_Containerd
    Start_Containerd
  } else {
    Create_DockerRegistryKey
    Configure_Dockerd
  }
}

function Test-ContainersFeatureInstalled {
  return (Get-WindowsFeature Containers).Installed
}

# After this function returns, the computer must be restarted to complete
# the installation!
function Install-ContainersFeature {
  Log-Output "Installing Windows 'Containers' feature"
  Install-WindowsFeature Containers
}

function Test-DockerIsInstalled {
  return ((Get-Package `
               -ProviderName DockerMsftProvider `
               -ErrorAction SilentlyContinue |
           Where-Object Name -eq 'docker') -ne $null)
}

function Test-DockerIsRunning {
  return ((Get-Service docker).Status -eq 'Running')
}

# Installs Docker EE via the DockerMsftProvider. Ensure that the Windows
# Containers feature is installed before calling this function; otherwise,
# a restart may be needed after this function returns.
function Install-Docker {
  Log-Output 'Installing NuGet module'
  Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force

  Log-Output 'Installing DockerMsftProvider module'
  Install-Module -Name DockerMsftProvider -Repository PSGallery -Force

  Log-Output "Installing latest Docker EE version"
  Install-Package `
      -Name docker `
      -ProviderName DockerMsftProvider `
      -Force `
      -Verbose
}

# Add a registry key for docker in EventLog so that log messages are mapped
# correctly. This is a workaround since the key is missing in the base image.
# https://github.com/MicrosoftDocs/Virtualization-Documentation/pull/503
# TODO: Fix this in the base image.
# TODO(random-liu): Figure out whether we need this for containerd.
function Create_DockerRegistryKey {
  $tmp_dir = 'C:\tmp_docker_reg'
  New-Item -Force -ItemType 'directory' ${tmp_dir} | Out-Null
  $reg_file = 'docker.reg'
  Set-Content ${tmp_dir}\${reg_file} `
'Windows Registry Editor Version 5.00
 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\Application\docker]
"CustomSource"=dword:00000001
"EventMessageFile"="C:\\Program Files\\docker\\dockerd.exe"
"TypesSupported"=dword:00000007'

  Log-Output "Importing registry key for Docker"
  reg import ${tmp_dir}\${reg_file}
  Remove-Item -Force -Recurse ${tmp_dir}
}

# Configure Docker daemon and restart the service.
function Configure_Dockerd {
  Set-Content "C:\ProgramData\docker\config\daemon.json" @'
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "1m",
    "max-file": "5"
  }
}
'@

 Restart-Service Docker
}

# Writes a CNI config file under $env:CNI_CONFIG_DIR for containerd.
#
# Prerequisites:
#   $env:POD_CIDR is set (by Set-PodCidr).
#   The "management" interface exists (Configure-HostNetworkingService).
#   The HNS network for pod networking has been configured
#     (Configure-HostNetworkingService).
#   Containerd is installed (Install_Containerd).
#
# Required ${kube_env} keys:
#   DNS_SERVER_IP
#   DNS_DOMAIN
#   SERVICE_CLUSTER_IP_RANGE
function Configure_Containerd_CniNetworking {
  $l2bridge_conf = "${env:CNI_CONFIG_DIR}\l2bridge.conf"
  if (-not (ShouldWrite-File ${l2bridge_conf})) {
    return
  }

  $mgmt_ip = (Get_MgmtNetAdapter |
              Get-NetIPAddress -AddressFamily IPv4).IPAddress

  $pod_gateway = Get_Endpoint_Gateway_From_CIDR(${env:POD_CIDR})

  # Explanation of the CNI config values:
  #   POD_CIDR: the pod CIDR assigned to this node.
  #   POD_GATEWAY: the gateway IP.
  #   MGMT_IP: the IP address assigned to the node's primary network interface
  #     (i.e. the internal IP of the GCE VM).
  #   SERVICE_CIDR: the CIDR used for kubernetes services.
  #   DNS_SERVER_IP: the cluster's DNS server IP address.
  #   DNS_DOMAIN: the cluster's DNS domain, e.g. "cluster.local".
  #
  # OutBoundNAT ExceptionList: No SNAT for CIDRs in the list, the same as default GKE non-masquerade destination ranges listed at https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#default-non-masq-dests

  New-Item -Force -ItemType file ${l2bridge_conf} | Out-Null
  Set-Content ${l2bridge_conf} `
'{
  "cniVersion":  "0.2.0",
  "name":  "l2bridge",
  "type":  "sdnbridge",
  "master": "Ethernet",
  "capabilities":  {
    "portMappings":  true,
    "dns": true
  },
  "ipam":  {
    "subnet": "POD_CIDR",
    "routes": [
      {
        "GW": "POD_GATEWAY"
      }
    ]
  },
  "dns":  {
    "Nameservers":  [
      "DNS_SERVER_IP"
    ],
    "Search": [
      "DNS_DOMAIN"
    ]
  },
  "AdditionalArgs": [
    {
      "Name":  "EndpointPolicy",
      "Value":  {
        "Type":  "OutBoundNAT",
        "Settings": {
          "Exceptions":  [
            "169.254.0.0/16",
            "10.0.0.0/8",
            "172.16.0.0/12",
            "192.168.0.0/16",
            "100.64.0.0/10",
            "192.0.0.0/24",
            "192.0.2.0/24",
            "192.88.99.0/24",
            "198.18.0.0/15",
            "198.51.100.0/24",
            "203.0.113.0/24",
            "240.0.0.0/4"
          ]
        }
      }
    },
    {
      "Name":  "EndpointPolicy",
      "Value":  {
        "Type":  "SDNRoute",
        "Settings": {
          "DestinationPrefix":  "SERVICE_CIDR",
          "NeedEncap":  true
        }
      }
    },
    {
      "Name":  "EndpointPolicy",
      "Value":  {
        "Type":  "SDNRoute",
        "Settings": {
          "DestinationPrefix":  "MGMT_IP/32",
          "NeedEncap":  true
        }
      }
    }
  ]
}'.replace('POD_CIDR', ${env:POD_CIDR}).`
  replace('POD_GATEWAY', ${pod_gateway}).`
  replace('DNS_SERVER_IP', ${kube_env}['DNS_SERVER_IP']).`
  replace('DNS_DOMAIN', ${kube_env}['DNS_DOMAIN']).`
  replace('MGMT_IP', ${mgmt_ip}).`
  replace('SERVICE_CIDR', ${kube_env}['SERVICE_CLUSTER_IP_RANGE'])

  Log-Output "containerd CNI config:`n$(Get-Content -Raw ${l2bridge_conf})"
}

# Download and install containerd and CNI binaries into $env:NODE_DIR.
function Install_Containerd {
  # Assume that presence of containerd.exe indicates that all containerd
  # binaries were already previously downloaded to this node.
  if (-not (ShouldWrite-File ${env:NODE_DIR}\containerd.exe)) {
    return
  }

  # TODO(random-liu): Change this to official release path after testing.
  $CONTAINERD_GCS_BUCKET = "cri-containerd-staging/windows"

  $tmp_dir = 'C:\containerd_tmp'
  New-Item $tmp_dir -ItemType 'directory' -Force | Out-Null

  $version_url = "https://storage.googleapis.com/$CONTAINERD_GCS_BUCKET/latest"
  MustDownload-File -URLs $version_url -OutFile $tmp_dir\version
  $version = $(Get-Content $tmp_dir\version)

  $tar_url = ("https://storage.googleapis.com/$CONTAINERD_GCS_BUCKET/" +
              "cri-containerd-cni-$version.windows-amd64.tar.gz")
  $sha_url = $tar_url + ".sha256"
  MustDownload-File -URLs $sha_url -OutFile $tmp_dir\sha256
  $sha = $(Get-Content $tmp_dir\sha256)

  MustDownload-File `
      -URLs $tar_url `
      -OutFile $tmp_dir\containerd.tar.gz `
      -Hash $sha `
      -Algorithm SHA256

  tar xzvf $tmp_dir\containerd.tar.gz -C $tmp_dir
  Move-Item -Force $tmp_dir\cni\*.exe ${env:CNI_DIR}\
  Move-Item -Force $tmp_dir\*.exe ${env:NODE_DIR}\
  Remove-Item -Force -Recurse $tmp_dir
}

# Generates the containerd config.toml file.
function Configure_Containerd {
  $config_dir = 'C:\Program Files\containerd'
  New-Item $config_dir -ItemType 'directory' -Force | Out-Null
  Set-Content "$config_dir\config.toml" @"
[plugins.cri]
  sandbox_image = 'INFRA_CONTAINER_IMAGE'
[plugins.cri.cni]
  bin_dir = 'CNI_BIN_DIR'
  conf_dir = 'CNI_CONF_DIR'
"@.replace('INFRA_CONTAINER_IMAGE', ${env:INFRA_CONTAINER}).`
    replace('CNI_BIN_DIR', ${env:CNI_DIR}).`
    replace('CNI_CONF_DIR', ${env:CNI_CONFIG_DIR})
}

# Register and start containerd service.
function Start_Containerd {
  Log-Output "Creating containerd service"
  & containerd.exe --register-service --log-file ${env:LOGS_DIR}/containerd.log
  Log-Output "Starting containerd service"
  Start-Service containerd
}

# Pigz Resources
$PIGZ_ROOT = 'C:\pigz'
$PIGZ_VERSION = '2.3.1'
$PIGZ_TAR_URL = "https://storage.googleapis.com/gke-release/winnode/pigz/prod/gke_windows/pigz/release/5/20201104-134221/pigz-$PIGZ_VERSION.zip"
$PIGZ_TAR_HASH = '5a6f8f5530acc85ea51797f58c1409e5af6b69e55da243ffc608784cf14fec0cd16f74cc61c564d69e1a267750aecfc1e4c53b5219ff5f893b42a7576306f34c'

# Install Pigz (https://github.com/madler/pigz) into Windows for improved image
# extraction performance.
function Install-Pigz {
  if ("${env:WINDOWS_ENABLE_PIGZ}" -eq "true") {
    if (-not (Test-Path $PIGZ_ROOT)) {
      Log-Output "Installing Pigz $PIGZ_VERSION"
      New-Item -Path $PIGZ_ROOT -ItemType Directory
      MustDownload-File `
        -Url $PIGZ_TAR_URL `
        -OutFile "$PIGZ_ROOT\pigz-$PIGZ_VERSION.zip" `
        -Hash $PIGZ_TAR_HASH `
        -Algorithm SHA512
      Expand-Archive -Path "$PIGZ_ROOT\pigz-$PIGZ_VERSION.zip" `
        -DestinationPath $PIGZ_ROOT
      Remove-Item -Path "$PIGZ_ROOT\pigz-$PIGZ_VERSION.zip"
      # Docker and Containerd search for unpigz.exe on the first container image
      # pull request after the service is started. If unpigz.exe is in the
      # Windows path it'll use it instead of the default unzipper.
      # See: https://github.com/containerd/containerd/issues/1896
      Add-MachineEnvironmentPath -Path $PIGZ_ROOT
      Log-Output "Installed Pigz $PIGZ_VERSION"
    } else {
      Log-Output "Pigz already installed."
    }
  }
}

# TODO(pjh): move the logging agent code below into a separate
# module; it was put here temporarily to avoid disrupting the file layout in
# the K8s release machinery.
$LOGGINGAGENT_VERSION = '1.6.0'
$LOGGINGAGENT_ROOT = 'C:\fluent-bit'
$LOGGINGAGENT_SERVICE = 'fluent-bit'
$LOGGINGAGENT_CMDLINE = '*fluent-bit.exe*'

$LOGGINGEXPORTER_VERSION = 'v0.10.3'
$LOGGINGEXPORTER_ROOT = 'C:\flb-exporter'
$LOGGINGEXPORTER_SERVICE = 'flb-exporter'
$LOGGINGEXPORTER_CMDLINE = '*flb-exporter.exe*'

# Restart Logging agent or starts it if it is not currently running
function Restart-LoggingAgent {
  if (IsStackdriverAgentInstalled) {
      Restart-StackdriverAgent
      return
  }

   Restart-LogService $LOGGINGEXPORTER_SERVICE $LOGGINGEXPORTER_CMDLINE
   Restart-LogService $LOGGINGAGENT_SERVICE $LOGGINGAGENT_CMDLINE
}

# Restarts the service, or starts it if it is not currently
# running. A standard `Restart-Service` may fail because
# the process is sometimes unstoppable, so this function works around it
# by killing the processes.
function Restart-LogService([string]$service, [string]$cmdline) {
  Stop-Service -NoWait -ErrorAction Ignore $service

  # Wait (if necessary) for service to stop.
  $timeout = 10
  $stopped = (Get-service $service).Status -eq 'Stopped'
  for ($i = 0; $i -lt $timeout -and !($stopped); $i++) {
      Start-Sleep 1
      $stopped = (Get-service $service).Status -eq 'Stopped'
  }

  if ((Get-service $service).Status -ne 'Stopped') {
    # Force kill the processes.
    Stop-Process -Force -PassThru -Id (Get-WmiObject win32_process |
      Where CommandLine -Like $cmdline).ProcessId

    # Wait until process has stopped.
    $waited = 0
    $log_period = 10
    $timeout = 60
    while ((Get-service $service).Status -ne 'Stopped' -and $waited -lt $timeout) {
      Start-Sleep 1
      $waited++

      if ($waited % $log_period -eq 0) {
        Log-Output "Waiting for ${service} service to stop"
      }
    }

    # Timeout occurred
    if ($waited -ge $timeout) {
      Throw ("Timeout while waiting for ${service} service to stop")
    }
  }

  Start-Service $service
}

# Check whether the logging agent is installed by whether it's registered as service
function IsLoggingAgentInstalled {
  $logging_status = (Get-Service $LOGGINGAGENT_SERVICE -ErrorAction Ignore).Status
  return -not [string]::IsNullOrEmpty($logging_status)
}

# Installs the logging agent according to https://docs.fluentbit.io/manual/installation/windows#
# Also installs fluent bit stackdriver exporter
function Install-LoggingAgent {
  if (IsStackdriverAgentInstalled) {
    # Remove the existing storage.json file if it exists. This is a workaround
    # for the bug where the logging agent cannot start up if the file is
    # corrupted.
    Remove-Item `
      -Force `
      -ErrorAction Ignore `
      ("$STACKDRIVER_ROOT\LoggingAgent\Main\pos\winevtlog.pos\worker0\" +
       "storage.json")
    Log-Output ("Skip: Stackdriver logging agent is already installed")
    return
  }

  if (IsLoggingAgentInstalled) {
    # Note: we should reinstall the agent if $REDO_STEPS is true
    # here, but we don't know how to run the installer without it prompting
    # when logging agent is already installed. We dumped the strings in the
    # installer binary and searched for flags to do this but found nothing. Oh
    # well.
    Log-Output ("Skip: Fluentbit logging agent is already installed")
    return
  }

  DownloadAndInstall-LoggingAgents
  Create-LoggingAgentServices
}

function DownloadAndInstall-LoggingAgents {
  # Install Logging agent if not present
  if (ShouldWrite-File $LOGGINGAGENT_ROOT\td-agent-bit-${LOGGINGAGENT_VERSION}-win64) {
      $install_dir = 'C:\flb-installers'
      $url = ("https://storage.googleapis.com/gke-release/winnode/fluentbit/td-agent-bit-${LOGGINGAGENT_VERSION}-win64.zip")

      Log-Output 'Downloading Logging agent'
      New-Item $install_dir -ItemType 'directory' -Force | Out-Null
      MustDownload-File -OutFile $install_dir\td.zip -URLs $url

      cd $install_dir
      Log-Output 'Extracting Logging agent'
      Expand-Archive td.zip
      mv .\td\td-agent-bit-${LOGGINGAGENT_VERSION}-win64\ $LOGGINGAGENT_ROOT
      cd C:\
      Remove-Item -Force -Recurse $install_dir
  }

  # Download Logging exporter if needed
  if (ShouldWrite-File $LOGGINGEXPORTER_ROOT\flb-exporter.exe) {
      $url = ("https://storage.googleapis.com/gke-release/winnode/fluentbit-exporter/${LOGGINGEXPORTER_VERSION}/flb-exporter-${LOGGINGEXPORTER_VERSION}.exe")
      Log-Output 'Downloading logging exporter'
      New-Item $LOGGINGEXPORTER_ROOT -ItemType 'directory' -Force | Out-Null
      MustDownload-File `
          -OutFile $LOGGINGEXPORTER_ROOT\flb-exporter.exe -URLs $url
  }
}

function Create-LoggingAgentServices {
  cd $LOGGINGAGENT_ROOT

  Log-Output 'Creating service: ${LOGGINGAGENT_SERVICE}'
  sc.exe create $LOGGINGAGENT_SERVICE binpath= "${LOGGINGAGENT_ROOT}\bin\fluent-bit.exe -c \fluent-bit\conf\fluent-bit.conf"
  sc.exe failure $LOGGINGAGENT_SERVICE reset= 30 actions= restart/5000
  sc.exe query $LOGGINGAGENT_SERVICE

  Log-Output 'Creating service: ${LOGGINGEXPORTER_SERVICE}'
  sc.exe create  $LOGGINGEXPORTER_SERVICE  binpath= "${LOGGINGEXPORTER_ROOT}\flb-exporter.exe --kubernetes-separator=_ --stackdriver-resource-model=k8s --enable-pod-label-discovery --logtostderr --winsvc  --pod-label-dot-replacement=_"
  sc.exe failure $LOGGINGEXPORTER_SERVICE reset= 30 actions= restart/5000
  sc.exe query $LOGGINGEXPORTER_SERVICE
}

# Writes the logging configuration file for Logging agent. Restart-LoggingAgent
# should then be called to pick up the new configuration.
function Configure-LoggingAgent {
  if (IsStackdriverAgentInstalled) {
      Configure-StackdriverAgent
      return
  }

  $fluentbit_config_file = "$LOGGINGAGENT_ROOT\conf\fluent-bit.conf"
  $FLUENTBIT_CONFIG | Out-File -FilePath $fluentbit_config_file -Encoding ASCII
  Log-Output "Wrote logging config to $fluentbit_config_file"

  $fluentbit_parser_file = "$LOGGINGAGENT_ROOT\conf\parsers.conf"
  $PARSERS_CONFIG | Out-File -FilePath $fluentbit_parser_file -Encoding ASCII
  Log-Output "Wrote logging config to $fluentbit_parser_file"
}

# Fluentbit main config file
$FLUENTBIT_CONFIG = @'
[SERVICE]
    Flush         5
    Grace         120
    Log_Level     debug
    Log_File      /var/log/fluentbit.log
    Daemon        off
    Parsers_File  parsers.conf
    HTTP_Server   off
    HTTP_Listen   0.0.0.0
    HTTP_PORT     2020
    plugins_file plugins.conf

    # Storage
    # =======
    # Fluent Bit can use memory and filesystem buffering based mechanisms
    #
    # - https://docs.fluentbit.io/manual/administration/buffering-and-storage
    #
    # storage metrics
    # ---------------
    # publish storage pipeline metrics in '/api/v1/storage'. The metrics are
    # exported only if the 'http_server' option is enabled.
    #
    # storage.metrics on

    # storage.path
    # ------------
    # absolute file system path to store filesystem data buffers (chunks).
    #
    # storage.path /tmp/storage

    # storage.sync
    # ------------
    # configure the synchronization mode used to store the data into the
    # filesystem. It can take the values normal or full.
    #
    # storage.sync normal

    # storage.checksum
    # ----------------
    # enable the data integrity check when writing and reading data from the
    # filesystem. The storage layer uses the CRC32 algorithm.
    #
    # storage.checksum off

    # storage.backlog.mem_limit
    # -------------------------
    # if storage.path is set, Fluent Bit will look for data chunks that were
    # not delivered and are still in the storage layer, these are called
    # backlog data. This option configure a hint of maximum value of memory
    # to use when processing these records.
    #
    # storage.backlog.mem_limit 5M


[INPUT]
    Name         winlog
    Interval_Sec 2
    # Channels Setup,Windows PowerShell
    Channels     application,system,security
    Tag          winevent.raw
    DB           winlog.sqlite   #


# Json Log Example:
# {"log":"[info:2016-02-16T16:04:05.930-08:00] Some log text here\n","stream":"stdout","time":"2016-02-17T00:04:05.931087621Z"}
[INPUT]
    Name             tail
    Alias            kube_containers
    Tag              kube_<namespace_name>_<pod_name>_<container_name>
    Tag_Regex        (?<pod_name>[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)_(?<namespace_name>[^_]+)_(?<container_name>.+)-
    Path             /var/log/containers/*.log
    Mem_Buf_Limit    5MB
    Skip_Long_Lines  On
    Refresh_Interval 5
    DB               flb_kube.db

    # Settings from fluentd missing here.
    # tag reform.*
    # format json
    # time_key time
    # time_format %Y-%m-%dT%H:%M:%S.%NZ


# Example:
# I0204 07:32:30.020537    3368 server.go:1048] POST /stats/container/: (13.972191ms) 200 [[Go-http-client/1.1] 10.244.1.3:40537]
[INPUT]
    Name             tail
    Alias            kubelet
    Tag              kubelet
    #Multiline        on
    #Multiline_Flush  5
    Mem_Buf_Limit    5MB
    Skip_Long_Lines  On
    Refresh_Interval 5
    Path /etc/kubernetes/logs/kubelet.log
    DB               /etc/kubernetes/logs/gcp-kubelet.db

    # Copied from fluentbit config. How is this used ? In match stages ?
    Parser_Firstline /^\w\d{4}/
    Parser_1         ^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/

    # missing from fluentbit
    #   time_format %m%d %H:%M:%S.%N


# Example:
# I0928 03:15:50.440223    4880 main.go:51] Starting CSI-Proxy Server ...
[INPUT]
    Name             tail
    Alias            csi-proxy
    Tag              csi-proxy
    #Multiline        on
    #Multiline_Flush  5
    Mem_Buf_Limit    5MB
    Skip_Long_Lines  On
    Refresh_Interval 5
    Path             /etc/kubernetes/logs/csi-proxy.log
    DB               /etc/kubernetes/logs/gcp-csi-proxy.db

    # Copied from fluentbit config. How is this used ? In match stages ?
    Parser_Firstline /^\w\d{4}/
    Parser_1         ^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/

    # missing from fluentbit
    #   time_format %m%d %H:%M:%S.%N

# Example:
# time="2019-12-10T21:27:59.836946700Z" level=info msg="loading plugin \"io.containerd.grpc.v1.cri\"..." type=io.containerd.grpc.v1
[INPUT]
    Name             tail
    Alias            container-runtime
    Tag container-runtime
    #Multiline        on
    #Multiline_Flush  5
    Mem_Buf_Limit    5MB
    Skip_Long_Lines  On
    Refresh_Interval 5
    Path             /etc/kubernetes/logs/containerd.log
    DB               /etc/kubernetes/logs/gcp-containerd.log.pos

    # Copied from fluentbit config. How is this used ? In match stages ?
    Parser_Firstline /^\w\d{4}/
    Parser_1         ^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/

    # missing from fluentbit
    #   time_format %m%d %H:%M:%S.%N


# I1118 21:26:53.975789       6 proxier.go:1096] Port "nodePort for kube-system/default-http-backend:http" (:31429/tcp) was open before and is still needed
[INPUT]
    Name             tail
    Alias            kube-proxy
    Tag              kube-proxy
    #Multiline        on
    #Multiline_Flush  5
    Mem_Buf_Limit    5MB
    Skip_Long_Lines  On
    Refresh_Interval 5
    Path             /etc/kubernetes/logs/kube-proxy.log
    DB               /etc/kubernetes/logs/gcp-kubeproxy.db

    # Copied from fluentbit config. How is this used ? In match stages ?
    Parser_Firstline /^\w\d{4}/
    Parser_1         ^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/

    # missing from fluentbit
    #   time_format %m%d %H:%M:%S.%N

[FILTER]
    Name        modify
    Match       *
    Hard_rename log message

# [OUTPUT]
#    Name        http
#    Match       *
#    Host        127.0.0.1
#    Port        2021
#    URI         /logs
#    header_tag  FLUENT-TAG
#    Format      msgpack
#    Retry_Limit 2

[OUTPUT]
    name  stackdriver
    match *
'@

# Fluentbit parsers config file
$PARSERS_CONFIG = @'

[PARSER]
    Name        docker
    Format      json
    Time_Key    time
    Time_Format %Y-%m-%dT%H:%M:%S.%L%z

[PARSER]
    Name        containerd
    Format      regex
    Regex       ^(?<time>.+) (?<stream>stdout|stderr) [^ ]* (?<log>.*)$
    Time_Key    time
    Time_Format %Y-%m-%dT%H:%M:%S.%L%z

[PARSER]
    Name        json
    Format      json

[PARSER]
    Name        syslog
    Format      regex
    Regex       ^\<(?<pri>[0-9]+)\>(?<time>[^ ]* {1,2}[^ ]* [^ ]*) (?<host>[^ ]*) (?<ident>[a-zA-Z0-9_\/\.\-]*)(?:\[(?<pid>[0-9]+)\])?(?:[^\:]*\:)? *(?<message>.*)$
    Time_Key    time
    Time_Format %b %d %H:%M:%S

[PARSER]
    Name        glog
    Format      regex
    Regex       ^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source_file>[^ \]]+)\:(?<source_line>\d+)\]\s(?<message>.*)$
    Time_Key    time
    Time_Format %m%d %H:%M:%S.%L

[PARSER]
    Name        network-log
    Format      json
    Time_Key    timestamp
    Time_Format %Y-%m-%dT%H:%M:%S.%L%z

# ----------

[PARSER]
    Name   json
    Format json
    Time_Key time
    Time_Format %d/%b/%Y:%H:%M:%S %z

[PARSER]
    Name         docker
    Format       json
    Time_Key     time
    Time_Format  %Y-%m-%dT%H:%M:%S.%L
    Time_Keep    On


[PARSER]
    Name        syslog-rfc5424
    Format      regex
    Regex       ^\<(?<pri>[0-9]{1,5})\>1 (?<time>[^ ]+) (?<host>[^ ]+) (?<ident>[^ ]+) (?<pid>[-0-9]+) (?<msgid>[^ ]+) (?<extradata>(\[(.*?)\]|-)) (?<message>.+)$
    Time_Key    time
    Time_Format %Y-%m-%dT%H:%M:%S.%L%z
    Time_Keep   On

[PARSER]
    Name        syslog-rfc3164-local
    Format      regex
    Regex       ^\<(?<pri>[0-9]+)\>(?<time>[^ ]* {1,2}[^ ]* [^ ]*) (?<ident>[a-zA-Z0-9_\/\.\-]*)(?:\[(?<pid>[0-9]+)\])?(?:[^\:]*\:)? *(?<message>.*)$
    Time_Key    time
    Time_Format %b %d %H:%M:%S
    Time_Keep   On

[PARSER]
    Name        syslog-rfc3164
    Format      regex
    Regex       /^\<(?<pri>[0-9]+)\>(?<time>[^ ]* {1,2}[^ ]* [^ ]*) (?<host>[^ ]*) (?<ident>[a-zA-Z0-9_\/\.\-]*)(?:\[(?<pid>[0-9]+)\])?(?:[^\:]*\:)? *(?<message>.*)$/
    Time_Key    time
    Time_Format %b %d %H:%M:%S
    Time_Keep   On

[PARSER]
    Name    kube-custom
    Format  regex
    Regex   (?<tag>[^.]+)?\.?(?<pod_name>[a-z0-9](?:[-a-z0-9]*[a-z0-9])?(?:\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)_(?<namespace_name>[^_]+)_(?<container_name>.+)-(?<docker_id>[a-z0-9]{64})\.log$
'@


# ----------- Stackdriver logging setup --------------------------
# This section would be deprecated soon
#

$STACKDRIVER_VERSION = 'v1-11'
$STACKDRIVER_ROOT = 'C:\Program Files (x86)\Stackdriver'

# Restarts the Stackdriver logging agent, or starts it if it is not currently
# running. A standard `Restart-Service StackdriverLogging` may fail because
# StackdriverLogging sometimes is unstoppable, so this function works around it
# by killing the processes.
function Restart-StackdriverAgent {
  Stop-Service -NoWait -ErrorAction Ignore StackdriverLogging

  # Wait (if necessary) for service to stop.
  $timeout = 10
  $stopped = (Get-service StackdriverLogging).Status -eq 'Stopped'
  for ($i = 0; $i -lt $timeout -and !($stopped); $i++) {
      Start-Sleep 1
      $stopped = (Get-service StackdriverLogging).Status -eq 'Stopped'
  }

  if ((Get-service StackdriverLogging).Status -ne 'Stopped') {
    # Force kill the processes.
    Stop-Process -Force -PassThru -Id (Get-WmiObject win32_process |
      Where CommandLine -Like '*Stackdriver/logging*').ProcessId

    # Wait until process has stopped.
    $waited = 0
    $log_period = 10
    $timeout = 60
    while ((Get-service StackdriverLogging).Status -ne 'Stopped' -and $waited -lt $timeout) {
      Start-Sleep 1
      $waited++

      if ($waited % $log_period -eq 0) {
        Log-Output "Waiting for StackdriverLogging service to stop"
      }
    }

    # Timeout occurred
    if ($waited -ge $timeout) {
      Throw ("Timeout while waiting for StackdriverLogging service to stop")
    }
  }

  Start-Service StackdriverLogging
}

# Check whether the logging agent is installed by whether it's registered as service
function IsStackdriverAgentInstalled {
  $stackdriver_status = (Get-Service StackdriverLogging -ErrorAction Ignore).Status
  return -not [string]::IsNullOrEmpty($stackdriver_status)
}

# Writes the logging configuration file for Stackdriver. Restart-LoggingAgent
# should then be called to pick up the new configuration.
function Configure-StackdriverAgent {
  $fluentd_config_dir = "$STACKDRIVER_ROOT\LoggingAgent\config.d"
  $fluentd_config_file = "$fluentd_config_dir\k8s_containers.conf"

  # Create a configuration file for kubernetes containers.
  # The config.d directory should have already been created automatically, but
  # try creating again just in case.
  New-Item $fluentd_config_dir -ItemType 'directory' -Force | Out-Null

  $config = $FLUENTD_CONFIG.replace('NODE_NAME', (hostname))
  $config | Out-File -FilePath $fluentd_config_file -Encoding ASCII
  Log-Output "Wrote fluentd logging config to $fluentd_config_file"

  # Configure StackdriverLogging to automatically restart on failure after 10
  # seconds. The logging agent may die die to various disruptions but can be
  # resumed.
  sc.exe failure StackdriverLogging reset= 0 actions= restart/1000/restart/10000
}

# The NODE_NAME placeholder must be replaced with the node's name (hostname).
$FLUENTD_CONFIG = @'
# This configuration file for Fluentd is used to watch changes to kubernetes
# container logs in the directory /var/lib/docker/containers/ and submit the
# log records to Google Cloud Logging using the cloud-logging plugin.
#
# Example
# =======
# A line in the Docker log file might look like this JSON:
#
# {"log":"2014/09/25 21:15:03 Got request with path wombat\\n",
#  "stream":"stderr",
#   "time":"2014-09-25T21:15:03.499185026Z"}
#
# The original tag is derived from the log file's location.
# For example a Docker container's logs might be in the directory:
#  /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b
# and in the file:
#  997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
# where 997599971ee6... is the Docker ID of the running container.
# The Kubernetes kubelet makes a symbolic link to this file on the host
# machine in the /var/log/containers directory which includes the pod name,
# the namespace name and the Kubernetes container name:
#    synthetic-logger-0.25lps-pod_default_synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
#    ->
#    /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
# The /var/log directory on the host is mapped to the /var/log directory in the container
# running this instance of Fluentd and we end up collecting the file:
#   /var/log/containers/synthetic-logger-0.25lps-pod_default_synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
# This results in the tag:
#  var.log.containers.synthetic-logger-0.25lps-pod_default_synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
# where 'synthetic-logger-0.25lps-pod' is the pod name, 'default' is the
# namespace name, 'synth-lgr' is the container name and '997599971ee6..' is
# the container ID.
# The record reformer is used to extract pod_name, namespace_name and
# container_name from the tag and set them in a local_resource_id in the
# format of:
# 'k8s_container.<NAMESPACE_NAME>.<POD_NAME>.<CONTAINER_NAME>'.
# The reformer also changes the tags to 'stderr' or 'stdout' based on the
# value of 'stream'.
# local_resource_id is later used by google_cloud plugin to determine the
# monitored resource to ingest logs against.
# Json Log Example:
# {"log":"[info:2016-02-16T16:04:05.930-08:00] Some log text here\n","stream":"stdout","time":"2016-02-17T00:04:05.931087621Z"}
# CRI Log Example:
# 2016-02-17T00:04:05.931087621Z stdout F [info:2016-02-16T16:04:05.930-08:00] Some log text here
<source>
  @type tail
  path /var/log/containers/*.log
  pos_file /var/log/gcp-containers.log.pos
  # Tags at this point are in the format of:
  # reform.var.log.containers.<POD_NAME>_<NAMESPACE_NAME>_<CONTAINER_NAME>-<CONTAINER_ID>.log
  tag reform.*
  read_from_head true
  <parse>
    @type multi_format
    <pattern>
      format json
      time_key time
      time_format %Y-%m-%dT%H:%M:%S.%NZ
      keep_time_key
    </pattern>
    <pattern>
      format /^(?<time>.+) (?<stream>stdout|stderr) [^ ]* (?<log>.*)$/
      time_format %Y-%m-%dT%H:%M:%S.%N%:z
    </pattern>
  </parse>
</source>
# Example:
# I0204 07:32:30.020537    3368 server.go:1048] POST /stats/container/: (13.972191ms) 200 [[Go-http-client/1.1] 10.244.1.3:40537]
<source>
  @type tail
  format multiline
  multiline_flush_interval 5s
  format_firstline /^\w\d{4}/
  format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
  time_format %m%d %H:%M:%S.%N
  path /etc/kubernetes/logs/kubelet.log
  pos_file /etc/kubernetes/logs/gcp-kubelet.log.pos
  tag kubelet
</source>
# Example:
# I1118 21:26:53.975789       6 proxier.go:1096] Port "nodePort for kube-system/default-http-backend:http" (:31429/tcp) was open before and is still needed
<source>
  @type tail
  format multiline
  multiline_flush_interval 5s
  format_firstline /^\w\d{4}/
  format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
  time_format %m%d %H:%M:%S.%N
  path /etc/kubernetes/logs/kube-proxy.log
  pos_file /etc/kubernetes/logs/gcp-kube-proxy.log.pos
  tag kube-proxy
</source>
# Example:
# I0928 03:15:50.440223    4880 main.go:51] Starting CSI-Proxy Server ...
<source>
  @type tail
  format multiline
  multiline_flush_interval 5s
  format_firstline /^\w\d{4}/
  format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
  time_format %m%d %H:%M:%S.%N
  path /etc/kubernetes/logs/csi-proxy.log
  pos_file /etc/kubernetes/logs/gcp-csi-proxy.log.pos
  tag csi-proxy
</source>
# Example:
# time="2019-12-10T21:27:59.836946700Z" level=info msg="loading plugin \"io.containerd.grpc.v1.cri\"..." type=io.containerd.grpc.v1
<source>
  @type tail
  format multiline
  multiline_flush_interval 5s
  format_firstline /^time=/
  format1 /^time="(?<time>[^ ]*)" level=(?<severity>\w*) (?<message>.*)/
  time_format %Y-%m-%dT%H:%M:%S.%N%z
  path /etc/kubernetes/logs/containerd.log
  pos_file /etc/kubernetes/logs/gcp-containerd.log.pos
  tag container-runtime
</source>
<match reform.**>
  @type record_reformer
  enable_ruby true
  <record>
    # Extract local_resource_id from tag for 'k8s_container' monitored
    # resource. The format is:
    # 'k8s_container.<namespace_name>.<pod_name>.<container_name>'.
    "logging.googleapis.com/local_resource_id" ${"k8s_container.#{tag_suffix[4].rpartition('.')[0].split('_')[1]}.#{tag_suffix[4].rpartition('.')[0].split('_')[0]}.#{tag_suffix[4].rpartition('.')[0].split('_')[2].rpartition('-')[0]}"}
    # Rename the field 'log' to a more generic field 'message'. This way the
    # fluent-plugin-google-cloud knows to flatten the field as textPayload
    # instead of jsonPayload after extracting 'time', 'severity' and
    # 'stream' from the record.
    message ${record['log']}
    # If 'severity' is not set, assume stderr is ERROR and stdout is INFO.
    severity ${record['severity'] || if record['stream'] == 'stderr' then 'ERROR' else 'INFO' end}
  </record>
  tag ${if record['stream'] == 'stderr' then 'raw.stderr' else 'raw.stdout' end}
  remove_keys stream,log
</match>
# TODO: detect exceptions and forward them as one log entry using the
# detect_exceptions plugin
# This section is exclusive for k8s_container logs. These logs come with
# 'raw.stderr' or 'raw.stdout' tags.
<match {raw.stderr,raw.stdout}>
  @type google_cloud
  # Try to detect JSON formatted log entries.
  detect_json true
  # Allow log entries from multiple containers to be sent in the same request.
  split_logs_by_tag false
  # Set the buffer type to file to improve the reliability and reduce the memory consumption
  buffer_type file
  buffer_path /var/log/fluentd-buffers/kubernetes.containers.buffer
  # Set queue_full action to block because we want to pause gracefully
  # in case of the off-the-limits load instead of throwing an exception
  buffer_queue_full_action block
  # Set the chunk limit conservatively to avoid exceeding the recommended
  # chunk size of 5MB per write request.
  buffer_chunk_limit 512k
  # Cap the combined memory usage of this buffer and the one below to
  # 512KiB/chunk * (6 + 2) chunks = 4 MiB
  buffer_queue_limit 6
  # Never wait more than 5 seconds before flushing logs in the non-error case.
  flush_interval 5s
  # Never wait longer than 30 seconds between retries.
  max_retry_wait 30
  # Disable the limit on the number of retries (retry forever).
  disable_retry_limit
  # Use multiple threads for processing.
  num_threads 2
  use_grpc true
  # Skip timestamp adjustment as this is in a controlled environment with
  # known timestamp format. This helps with CPU usage.
  adjust_invalid_timestamps false
</match>
# Attach local_resource_id for 'k8s_node' monitored resource.
<filter **>
  @type record_transformer
  enable_ruby true
  <record>
    "logging.googleapis.com/local_resource_id" ${"k8s_node.NODE_NAME"}
  </record>
</filter>
# Copyright 2019 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

<#
.SYNOPSIS
  Library containing common variables and code used by other PowerShell modules
  and scripts for configuring Windows nodes.
#>

# IMPORTANT PLEASE NOTE:
# Any time the file structure in the `windows` directory changes,
# `windows/BUILD` and `k8s.io/release/lib/releaselib.sh` must be manually
# updated with the changes.
# We HIGHLY recommend not changing the file structure, because consumers of
# Kubernetes releases depend on the release structure remaining stable.

# Disable progress bar to increase download speed.
$ProgressPreference = 'SilentlyContinue'

# REDO_STEPS affects the behavior of a node that is rebooted after initial
# bringup. When true, on a reboot the scripts will redo steps that were
# determined to have already been completed once (e.g. to overwrite
# already-existing config files). When false the scripts will perform the
# minimum required steps to re-join this node to the cluster.
$REDO_STEPS = $false
Export-ModuleMember -Variable REDO_STEPS

# Writes $Message to the console. Terminates the script if $Fatal is set.
function Log-Output {
  param (
    [parameter(Mandatory=$true)] [string]$Message,
    [switch]$Fatal
  )
  Write-Host "${Message}"
  if (${Fatal}) {
    Exit 1
  }
}

# Checks if a file should be written or overwritten by testing if it already
# exists and checking the value of the global $REDO_STEPS variable. Emits an
# informative message if the file already exists.
#
# Returns $true if the file does not exist, or if it does but the global
# $REDO_STEPS variable is set to $true. Returns $false if the file exists and
# the caller should not overwrite it.
function ShouldWrite-File {
  param (
    [parameter(Mandatory=$true)] [string]$Filename
  )
  if (Test-Path $Filename) {
    if ($REDO_STEPS) {
      Log-Output "Warning: $Filename already exists, will overwrite it"
      return $true
    }
    Log-Output "Skip: $Filename already exists, not overwriting it"
    return $false
  }
  return $true
}

# Returns the GCE instance metadata value for $Key. If the key is not present
# in the instance metadata returns $Default if set, otherwise returns $null.
function Get-InstanceMetadata {
  param (
    [parameter(Mandatory=$true)] [string]$Key,
    [parameter(Mandatory=$false)] [string]$Default
  )

  $url = "http://metadata.google.internal/computeMetadata/v1/instance/$Key"
  try {
    $client = New-Object Net.WebClient
    $client.Headers.Add('Metadata-Flavor', 'Google')
    return ($client.DownloadString($url)).Trim()
  }
  catch [System.Net.WebException] {
    if ($Default) {
      return $Default
    }
    else {
      Log-Output "Failed to retrieve value for $Key."
      return $null
    }
  }
}

# Returns the GCE instance metadata value for $Key where key is an "attribute"
# of the instance. If the key is not present in the instance metadata returns
# $Default if set, otherwise returns $null.
function Get-InstanceMetadataAttribute {
  param (
    [parameter(Mandatory=$true)] [string]$Key,
    [parameter(Mandatory=$false)] [string]$Default
  )

  return Get-InstanceMetadata "attributes/$Key" $Default
}

function Validate-SHA {
  param(
    [parameter(Mandatory=$true)] [string]$Hash,
    [parameter(Mandatory=$true)] [string]$Path,
    [parameter(Mandatory=$true)] [string]$Algorithm
  )
  $actual = Get-FileHash -Path $Path -Algorithm $Algorithm
  # Note: Powershell string comparisons are case-insensitive by default, and this
  # is important here because Linux shell scripts produce lowercase hashes but
  # Powershell Get-FileHash produces uppercase hashes. This must be case-insensitive
  # to work.
  if ($actual.Hash -ne $Hash) {
    Log-Output "$Path corrupted, $Algorithm $actual doesn't match expected $Hash"
    Throw ("$Path corrupted, $Algorithm $actual doesn't match expected $Hash")
  }
}

# Attempts to download the file from URLs, trying each URL until it succeeds.
# It will loop through the URLs list forever until it has a success. If
# successful, it will write the file to OutFile. You can optionally provide a
# Hash argument with an optional Algorithm, in which case it will attempt to
# validate the downloaded file against the hash. SHA512 will be used if
# -Algorithm is not provided.
# This function is idempotent, if OutFile already exists and has the correct Hash
# then the download will be skipped. If the Hash is incorrect, the file will be
# overwritten.
function MustDownload-File {
  param (
    [parameter(Mandatory = $false)] [string]$Hash,
    [parameter(Mandatory = $false)] [string]$Algorithm = 'SHA512',
    [parameter(Mandatory = $true)] [string]$OutFile,
    [parameter(Mandatory = $true)] [System.Collections.Generic.List[String]]$URLs,
    [parameter(Mandatory = $false)] [System.Collections.IDictionary]$Headers = @{},
    [parameter(Mandatory = $false)] [int]$Attempts = 0
  )

  # If the file is already downloaded and matches the expected hash, skip the download.
  if ((Test-Path -Path $OutFile) -And -Not [string]::IsNullOrEmpty($Hash)) {
    try {
      Validate-SHA -Hash $Hash -Path $OutFile -Algorithm $Algorithm
      Log-Output "Skip download of ${OutFile}, it already exists with expected hash."
      return
    }
    catch {
      # The hash does not match the file on disk.
      # Proceed with the download and overwrite the file.
      Log-Output "${OutFile} exists but had wrong hash. Redownloading."
    }
  }

  $currentAttempt = 0
  while ($true) {
    foreach ($url in $URLs) {
      if (($Attempts -ne 0) -And ($currentAttempt -Gt 5)) {
        throw "Attempted to download ${url} ${currentAttempt} times. Giving up."
      }
      $currentAttempt++
      try {
        Get-RemoteFile -OutFile $OutFile -Url $url -Headers $Headers
      }
      catch {
        $message = $_.Exception.ToString()
        Log-Output "Failed to download file from ${Url}. Will retry. Error: ${message}"
        continue
      }
      # Attempt to validate the hash
      if (-Not [string]::IsNullOrEmpty($Hash)) {
        try {
          Validate-SHA -Hash $Hash -Path $OutFile -Algorithm $Algorithm
        }
        catch {
          $message = $_.Exception.ToString()
          Log-Output "Hash validation of ${url} failed. Will retry. Error: ${message}"
          continue
        }
        Log-Output "Downloaded ${url} (${Algorithm} = ${Hash})"
        return
      }
      Log-Output "Downloaded ${url}"
      return
    }
  }
}

# Downloads a file via HTTP/HTTPS.
# If the file is stored in GCS and this is running on a GCE node with a service account
# with credentials that have the devstore.read_only auth scope the bearer token will be
# automatically added to download the file.
function Get-RemoteFile {
  param (
    [parameter(Mandatory = $true)] [string]$OutFile,
    [parameter(Mandatory = $true)] [string]$Url,
    [parameter(Mandatory = $false)] [System.Collections.IDictionary]$Headers = @{}
  )

  # Load the System.Net.Http assembly if it's not loaded yet.
  if ("System.Net.Http.HttpClient" -as [type]) {} else {
    Add-Type -AssemblyName System.Net.Http
  }

  $timeout = New-TimeSpan -Minutes 5

  try {
    # Use HttpClient in favor of WebClient.
    # https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient?view=net-5.0#remarks
    $httpClient = New-Object -TypeName System.Net.Http.HttpClient
    $httpClient.Timeout = $timeout
    foreach ($key in $Headers.Keys) {
      $httpClient.DefaultRequestHeaders.Add($key, $Headers[$key])
    }
    # If the URL is for GCS and the node has dev storage scope, add the
    # service account OAuth2 bearer token to the request headers.
    # https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#applications
    if (($Url -match "^https://storage`.googleapis`.com.*") -and $(Check-StorageScope)) {
      $httpClient.DefaultRequestHeaders.Add("Authorization", "Bearer $(Get-Credentials)")
    }

    # Attempt to download the file
    $httpResponseMessage = $httpClient.GetAsync([System.Uri]::new($Url))
    $httpResponseMessage.Wait()
    if (-not $httpResponseMessage.IsCanceled) {
      # Check if the request was successful.
      # 
      # DO NOT replace with EnsureSuccessStatusCode(), it prints the
      # OAuth2 bearer token.
      if (-not $httpResponseMessage.Result.IsSuccessStatusCode) {
        $statusCode = $httpResponseMessage.Result.StatusCode
        throw "Downloading ${Url} returned status code ${statusCode}, retrying."
      }
      try {
        $outFileStream = [System.IO.FileStream]::new($OutFile, [System.IO.FileMode]::Create, [System.IO.FileAccess]::Write)
        $copyResult = $httpResponseMessage.Result.Content.CopyToAsync($outFileStream)
        $copyResult.Wait()
        $outFileStream.Close()
        if ($null -ne $copyResult.Exception) {
          throw $copyResult.Exception
        }
      }
      finally {
        if ($null -ne $outFileStream) {
          $outFileStream.Dispose()
        }
      }
    }
  }
  finally {
    if ($null -ne $httpClient) {
      $httpClient.Dispose()
    }
  }
}

# Returns the default service account token for the VM, retrieved from
# the instance metadata.
function Get-Credentials {
  While($true) {
    $data = Get-InstanceMetadata -Key "service-accounts/default/token"
    if ($data) {
      return ($data | ConvertFrom-Json).access_token
    }
    Start-Sleep -Seconds 1
  }
}

# Returns True if the VM has the dev storage scope, False otherwise.
function Check-StorageScope {
  While($true) {
    $data = Get-InstanceMetadata -Key "service-accounts/default/scopes"
    if ($data) {
      return ($data -match "auth/devstorage")
    }
    Start-Sleep -Seconds 1
  }
}

# This compiles some C# code that can make syscalls, and pulls the
# result into our powershell environment so we can make syscalls from this script.
# We make syscalls directly, because whatever the powershell cmdlets do under the hood,
# they can't seem to open the log files concurrently with writers.
# See https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-data-with-platform-invoke
# for details on which unmanaged types map to managed types.
$SyscallDefinitions = @'
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
public static extern IntPtr CreateFileW(
  String lpFileName,
  UInt32 dwDesiredAccess,
  UInt32 dwShareMode,
  IntPtr lpSecurityAttributes,
  UInt32 dwCreationDisposition,
  UInt32 dwFlagsAndAttributes,
  IntPtr hTemplateFile
);

[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
public static extern bool SetFilePointer(
  IntPtr hFile,
  Int32  lDistanceToMove,
  IntPtr lpDistanceToMoveHigh,
  UInt32 dwMoveMethod
);

[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
public static extern bool SetEndOfFile(
  IntPtr hFile
);

[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
public static extern bool CloseHandle(
  IntPtr hObject
);
'@
$Kernel32 = Add-Type -MemberDefinition $SyscallDefinitions -Name 'Kernel32' -Namespace 'Win32' -PassThru

# Close-Handle closes the specified open file handle.
# On failure, throws an exception.
function Close-Handle {
  param (
    [parameter(Mandatory=$true)] [System.IntPtr]$Handle
  )
  $ret = $Kernel32::CloseHandle($Handle)
  $err = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
  if (-not $ret) {
    throw "Failed to close open file handle ${Handle}, system error code: ${err}"
  }
}

# Open-File tries to open the file at the specified path with ReadWrite access mode and ReadWrite file share mode.
# On success, returns an open file handle.
# On failure, throws an exception.
function Open-File {
  param (
    [parameter(Mandatory=$true)] [string]$Path
  )

  $lpFileName = $Path
  $dwDesiredAccess = [System.IO.FileAccess]::ReadWrite
  $dwShareMode = [System.IO.FileShare]::ReadWrite # Fortunately golang also passes these same flags when it creates the log files, so we can open it concurrently.
  $lpSecurityAttributes = [System.IntPtr]::Zero
  $dwCreationDisposition = [System.IO.FileMode]::Open
  $dwFlagsAndAttributes = [System.IO.FileAttributes]::Normal
  $hTemplateFile = [System.IntPtr]::Zero

  $handle = $Kernel32::CreateFileW($lpFileName, $dwDesiredAccess, $dwShareMode, $lpSecurityAttributes, $dwCreationDisposition, $dwFlagsAndAttributes, $hTemplateFile)
  $err = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
  if ($handle -eq -1) {
    throw "Failed to open file ${Path}, system error code: ${err}"
  }

  return $handle
}

# Truncate-File truncates the file in-place by opening it, moving the file pointer to the beginning,
# and setting the end of file to the file pointer's location.
# On failure, throws an exception.
# The file must have been originally created with FILE_SHARE_WRITE for this to be possible.
# Fortunately Go creates files with FILE_SHARE_READ|FILE_SHARE_WRITE by for all os.Open calls,
# so our log writers should be doing the right thing.
function Truncate-File {
  param (
    [parameter(Mandatory=$true)] [string]$Path
  )
  $INVALID_SET_FILE_POINTER = 0xffffffff
  $NO_ERROR = 0
  $FILE_BEGIN = 0

  $handle = Open-File -Path $Path

  # https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfilepointer
  # Docs: Because INVALID_SET_FILE_POINTER is a valid value for the low-order DWORD of the new file pointer,
  # you must check both the return value of the function and the error code returned by GetLastError to
  # determine whether or not an error has occurred. If an error has occurred, the return value of SetFilePointer
  # is INVALID_SET_FILE_POINTER and GetLastError returns a value other than NO_ERROR.
  $ret = $Kernel32::SetFilePointer($handle, 0, [System.IntPtr]::Zero, $FILE_BEGIN)
  $err = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
  if ($ret -eq $INVALID_SET_FILE_POINTER -and $err -ne $NO_ERROR) {
    Close-Handle -Handle $handle
    throw "Failed to set file pointer for handle ${handle}, system error code: ${err}"
  }

  $ret = $Kernel32::SetEndOfFile($handle)
  $err = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
  if ($ret -eq 0) {
    Close-Handle -Handle $handle
    throw "Failed to set end of file for handle ${handle}, system error code: ${err}"
  }
  Close-Handle -Handle $handle
}

# FileRotationConfig defines the common options for file rotation.
class FileRotationConfig {
  # Force rotation, ignoring $MaxBackupInterval and $MaxSize criteria.
  [bool]$Force
  # Maximum time since last backup, after which file will be rotated.
  # When no backups exist, Rotate-File acts as if -MaxBackupInterval has not elapsed,
  # instead relying on the other criteria.
  [TimeSpan]$MaxBackupInterval
  # Maximum file size, after which file will be rotated.
  [int]$MaxSize
  # Maximum number of backup archives to maintain.
  [int]$MaxBackups
}

# New-FileRotationConfig constructs a FileRotationConfig with default options.
function New-FileRotationConfig {
  param (
    # Force rotation, ignoring $MaxBackupInterval and $MaxSize criteria.
    [parameter(Mandatory=$false)] [switch]$Force,
    # Maximum time since last backup, after which file will be rotated.
    # When no backups exist, Rotate-File acts as if -MaxBackupInterval has not elapsed,
    # instead relying on the other criteria.
    # Defaults to daily rotations.
    [parameter(Mandatory=$false)] [TimeSpan]$MaxBackupInterval = $(New-TimeSpan -Day 1),
    # Maximum file size, after which file will be rotated.
    [parameter(Mandatory=$false)] [int]$MaxSize = 100mb,
    # Maximum number of backup archives to maintain.
    [parameter(Mandatory=$false)] [int]$MaxBackups = 5
  )
  $config = [FileRotationConfig]::new()
  $config.Force = $Force
  $config.MaxBackupInterval = $MaxBackupInterval
  $config.MaxSize = $MaxSize
  $config.MaxBackups = $MaxBackups
  return $config
}

# Get-Backups returns a list of paths to backup files for the original file path -Path,
# assuming that backup files are in the same directory, with a prefix matching
# the original file name and a .zip suffix.
function Get-Backups {
  param (
    # Original path of the file for which backups were created (no suffix).
    [parameter(Mandatory=$true)] [string]$Path
  )
  $parent = Split-Path -Parent -Path $Path
  $leaf = Split-Path -Leaf -Path $Path
  $files = Get-ChildItem -File -Path $parent |
           Where-Object Name -like "${leaf}*.zip"
  return $files
}

# Trim-Backups deletes old backups for the log file identified by -Path until only -Count remain.
# Deletes backups with the oldest CreationTime first.
function Trim-Backups {
  param (
    [parameter(Mandatory=$true)] [int]$Count,
    [parameter(Mandatory=$true)] [string]$Path
  )
  if ($Count -lt 0) {
    $Count = 0
  }
  # If creating a new backup will exceed $Count, delete the oldest files
  # until we have one less than $Count, leaving room for the new one.
  # If the pipe results in zero items, $backups is $null, and if it results
  # in only one item, PowerShell doesn't wrap in an array, so we check both cases.
  # In the latter case, this actually caused it to often trim all backups, because
  # .Length is also a property of FileInfo (size of the file)!
  $backups = Get-Backups -Path $Path | Sort-Object -Property CreationTime
  if ($backups -and $backups.GetType() -eq @().GetType() -and $backups.Length -gt $Count) {
    $num = $backups.Length - $Count
    $rmFiles = $backups | Select-Object -First $num
    ForEach ($file in $rmFiles) {
      Remove-Item $file.FullName
    }
  }
}

# Backup-File creates a copy of the file at -Path.
# The name of the backup is the same as the file,
# with the suffix "-%Y%m%d-%s" to identify the time of the backup.
# Returns the path to the backup file.
function Backup-File {
  param (
    [parameter(Mandatory=$true)] [string]$Path
  )
  $date = Get-Date -UFormat "%Y%m%d-%s"
  $dest = "${Path}-${date}"
  Copy-Item -Path $Path -Destination $dest
  return $dest
}

# Compress-BackupFile creates a compressed archive containing the file
# at -Path and subsequently deletes the file at -Path. We split backup
# and compression steps to minimize time between backup and truncation,
# which helps minimize log loss.
function Compress-BackupFile {
  param (
    [parameter(Mandatory=$true)] [string]$Path
  )
  Compress-Archive -Path $Path -DestinationPath "${Path}.zip"
  Remove-Item -Path $Path
}

# Rotate-File rotates the log file at -Path by first making a compressed copy of the original
# log file with the suffix "-%Y%m%d-%s" to identify the time of the backup, then truncating
# the original file in-place. Rotation is performed according to the options in -Config.
function Rotate-File {
  param (
    # Path to the log file to rotate.
    [parameter(Mandatory=$true)] [string]$Path,
    # Config for file rotation.
    [parameter(Mandatory=$true)] [FileRotationConfig]$Config
  )
  function rotate {
    # If creating a new backup will exceed $MaxBackups, delete the oldest files
    # until we have one less than $MaxBackups, leaving room for the new one.
    Trim-Backups -Count ($Config.MaxBackups - 1) -Path $Path

    $backupPath = Backup-File -Path $Path
    Truncate-File -Path $Path
    Compress-BackupFile -Path $backupPath
  }

  # Check Force
  if ($Config.Force) {
    rotate
    return
  }

  # Check MaxSize.
  $file = Get-Item $Path
  if ($file.Length -gt $Config.MaxSize) {
    rotate
    return
  }

  # Check MaxBackupInterval.
  $backups = Get-Backups -Path $Path | Sort-Object -Property CreationTime
  if ($backups.Length -ge 1) {
    $lastBackupTime = $backups[0].CreationTime
    $now = Get-Date
    if ($now - $lastBackupTime -gt $Config.MaxBackupInterval) {
      rotate
      return
    }
  }
}

# Rotate-Files rotates the log files in directory -Path that match -Pattern.
# Rotation is performed by Rotate-File, according to -Config.
function Rotate-Files {
  param (
    # Pattern that file names must match to be rotated. Does not include parent path.
    [parameter(Mandatory=$true)] [string]$Pattern,
    # Path to the log directory containing files to rotate.
    [parameter(Mandatory=$true)] [string]$Path,
    # Config for file rotation.
    [parameter(Mandatory=$true)] [FileRotationConfig]$Config

  )
  $files = Get-ChildItem -File -Path $Path | Where-Object Name -match $Pattern
  ForEach ($file in $files) {
    try {
      Rotate-File -Path $file.FullName -Config $Config
    } catch {
      Log-Output "Caught exception rotating $($file.FullName): $($_.Exception)"
    }
  }
}

# Schedule-LogRotation schedules periodic log rotation with the Windows Task Scheduler.
# Rotation is performed by Rotate-Files, according to -Pattern and -Config.
# The system will check whether log files need to be rotated at -RepetitionInterval.
function Schedule-LogRotation {
  param (
    # Pattern that file names must match to be rotated. Does not include parent path.
    [parameter(Mandatory=$true)] [string]$Pattern,
    # Path to the log directory containing files to rotate.
    [parameter(Mandatory=$true)] [string]$Path,
    # Interval at which to check logs against rotation criteria.
    # Minimum 1 minute, maximum 31 days (see https://docs.microsoft.com/en-us/windows/desktop/taskschd/taskschedulerschema-interval-repetitiontype-element).
    [parameter(Mandatory=$true)] [TimeSpan]$RepetitionInterval,
    # Config for file rotation.
    [parameter(Mandatory=$true)] [FileRotationConfig]$Config
  )
  # Write a powershell script to a file that imports this module ($PSCommandPath)
  # and calls Rotate-Files with the configured arguments.
  $scriptPath = "C:\rotate-kube-logs.ps1"
  New-Item -Force -ItemType file -Path $scriptPath | Out-Null
  Set-Content -Path $scriptPath @"
`$ErrorActionPreference = 'Stop'
Import-Module -Force ${PSCommandPath}
`$maxBackupInterval = New-Timespan -Days $($Config.MaxBackupInterval.Days) -Hours $($Config.MaxBackupInterval.Hours) -Minutes $($Config.MaxBackupInterval.Minutes) -Seconds $($Config.MaxBackupInterval.Seconds)
`$config = New-FileRotationConfig -Force:`$$($Config.Force) -MaxBackupInterval `$maxBackupInterval -MaxSize $($Config.MaxSize) -MaxBackups $($Config.MaxBackups)
Rotate-Files -Pattern '${Pattern}' -Path '${Path}' -Config `$config
"@
  # The task will execute the rotate-kube-logs.ps1 script created above.
  # We explicitly set -WorkingDirectory to $Path for safety's sake, otherwise
  # it runs in %windir%\system32 by default, which sounds dangerous.
  $action = New-ScheduledTaskAction -Execute "powershell" -Argument "-NoLogo -NonInteractive -File ${scriptPath}" -WorkingDirectory $Path
  # Start the task immediately, and trigger the task once every $RepetitionInterval.
  $trigger = New-ScheduledTaskTrigger -Once -At $(Get-Date) -RepetitionInterval $RepetitionInterval
  # Run the task as the same user who is currently running this script.
  $principal = New-ScheduledTaskPrincipal $([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)
  # Just use the default task settings.
  $settings = New-ScheduledTaskSettingsSet
  # Create the ScheduledTask object from the above parameters.
  $task = New-ScheduledTask -Action $action -Principal $principal -Trigger $trigger -Settings $settings -Description "Rotate Kubernetes logs"
  # Register the new ScheduledTask with the Task Scheduler.
  # Always try to unregister and re-register, in case it already exists (e.g. across reboots).
  $name = "RotateKubeLogs"
  try {
    Unregister-ScheduledTask -Confirm:$false -TaskName $name
  } catch {} finally {
    Register-ScheduledTask -TaskName $name -InputObject $task
  }
}

# Returns true if this node is part of a test cluster (see
# cluster/gce/config-test.sh). $KubeEnv is a hash table containing the kube-env
# metadata keys+values.
function Test-IsTestCluster {
  param (
    [parameter(Mandatory=$true)] [hashtable]$KubeEnv
  )

  if ($KubeEnv.Contains('TEST_CLUSTER') -and `
      ($KubeEnv['TEST_CLUSTER'] -eq 'true')) {
    return $true
  }
  return $false
}

# Returns true if this node uses a plugin to support authentication to the
# master, e.g. for TPM-based authentication. $KubeEnv is a hash table
# containing the kube-env metadata keys+values.
function Test-NodeUsesAuthPlugin {
  param (
    [parameter(Mandatory=$true)] [hashtable]$KubeEnv
  )

  return $KubeEnv.Contains('EXEC_AUTH_PLUGIN_URL')
}

# Permanently adds a directory to the $env:PATH environment variable.
function Add-MachineEnvironmentPath {
  param (
    [parameter(Mandatory=$true)] [string]$Path
  )
  # Verify that the $Path is not already in the $env:Path variable.
  $pathForCompare = $Path.TrimEnd('\').ToLower()
  foreach ($p in $env:Path.Split(";")) {
    if ($p.TrimEnd('\').ToLower() -eq $pathForCompare) {
        return
    }
  }

  $newMachinePath = $Path + ";" + `
    [System.Environment]::GetEnvironmentVariable("Path","Machine")
  [Environment]::SetEnvironmentVariable("Path", $newMachinePath, `
    [System.EnvironmentVariableTarget]::Machine)
  $env:Path = $Path + ";" + $env:Path
$ErrorActionPreference = 'Stop'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"

Invoke-Script -File "$PSScriptRoot\version.ps1"

$DIR_PATH = Split-Path -Parent $MyInvocation.MyCommand.Definition
$SRC_PATH = (Resolve-Path "$DIR_PATH\..\..").Path
cd $SRC_PATH\package\windows

$TAG = $env:TAG
if (-not $TAG) {
    $TAG = ('{0}{1}' -f $env:VERSION, $env:SUFFIX)
}
$REPO = $env:REPO
if (-not $REPO) {
    $REPO = "rancher"
}

if ($TAG | Select-String -Pattern 'dirty') {
    $TAG = "dev"
}

if ($env:DRONE_TAG) {
    $TAG = $env:DRONE_TAG
}

$null = Copy-Item -Force -Path "$SRC_PATH\bin\agent.exe" -Destination .

# Get release id as image tag suffix
$HOST_RELEASE_ID = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\' -ErrorAction Ignore).ReleaseId
$RELEASE_ID = $env:RELEASE_ID
if (-not $RELEASE_ID) {
    $RELEASE_ID = $HOST_RELEASE_ID
}
$AGENT_IMAGE = ('{0}/rancher-agent:{1}-windows-{2}' -f $REPO, $TAG, $RELEASE_ID)

$ARCH = $env:ARCH
if ($RELEASE_ID -eq $HOST_RELEASE_ID) {
    docker build `
        --build-arg SERVERCORE_VERSION=$RELEASE_ID `
        --build-arg ARCH=$ARCH `
        --build-arg VERSION=$TAG `
        -t $AGENT_IMAGE `
        -f Dockerfile.agent .
} else {
    docker build `
        --isolation hyperv `
        --build-arg SERVERCORE_VERSION=$RELEASE_ID `
        --build-arg ARCH=$ARCH `
        --build-arg VERSION=$TAG `
        -t $AGENT_IMAGE `
        -f Dockerfile.agent .
}

$ErrorActionPreference = 'Stop'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"

Invoke-Script -File "$PSScriptRoot\version.ps1"

$DIR_PATH = Split-Path -Parent $MyInvocation.MyCommand.Definition
$SRC_PATH = (Resolve-Path "$DIR_PATH\..\..").Path
cd $SRC_PATH

$null = New-Item -Force -ItemType Directory -Path bin -ErrorAction Ignore
$env:GOARCH=$env:ARCH
$env:GOOS='windows'
$env:CGO_ENABLED=0
$LINKFLAGS = ('-X main.VERSION={0} -s -w -extldflags "-static"' -f $env:VERSION)
$ErrorActionPreference = 'Stop'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"

Invoke-Script -File "$PSScriptRoot\version.ps1"

$DIR_PATH = Split-Path -Parent $MyInvocation.MyCommand.Definition
$SRC_PATH = (Resolve-Path "$DIR_PATH\..\..").Path
cd $SRC_PATH

$env:GOARCH=$env:ARCH
$env:GOOS='windows'
go test -v -cover -tags 'test' ./cmd/agent/...
if (-not $?) {
    Log-Fatal "go test failed"
$ErrorActionPreference = 'Stop'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"

Log-Info "Running: build-agent"
$ErrorActionPreference = 'Stop'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'
$InformationPreference = 'SilentlyContinue'

function Log-Info
{
    Write-Host -NoNewline -ForegroundColor Blue "INFO: "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($Args -join " "))
}

function Log-Warn
{
    Write-Host -NoNewline -ForegroundColor DarkYellow "WARN: "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($args -join " "))
}

function Log-Error
{
    Write-Host -NoNewline -ForegroundColor DarkRed "ERRO "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($args -join " "))
}


function Log-Fatal
{
    Write-Host -NoNewline -ForegroundColor DarkRed "FATA: "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($args -join " "))

    throw "EXITED"
}

function Invoke-Script
{
    param (
        [parameter(Mandatory = $true)] [string]$File
    )

    try {
        Invoke-Expression -Command $File
        if (-not $?) {
            throw "CALLFAILED"
        }
    } catch {
        $Msg = $_.Exception.Message
        if ($Msg -eq "CALLFAILED") {
            Log-Fatal "Failed to invoke $File"
        } else {
            Log-Fatal "Could not invoke $File, $Msg"
        }
    }
}

Export-ModuleMember -Function Log-Info
$ErrorActionPreference = 'Stop'

$SCRIPT_PATH = ("{0}\{1}.ps1" -f $PSScriptRoot, $Args[0])
if (Test-Path $SCRIPT_PATH -ErrorAction Ignore)
{
    Invoke-Expression -Command $SCRIPT_PATH
    if (-not $?) {
        exit 255
    }
    exit 0
$ErrorActionPreference = 'Stop'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"

Invoke-Script -File "$PSScriptRoot\build.ps1"
$ErrorActionPreference = 'Stop'

$DIRTY = ""
if ("$(git status --porcelain --untracked-files=no)") {
    $DIRTY = "-dirty"
}

$COMMIT = $(git rev-parse --short HEAD)
$GIT_TAG = $env:DRONE_TAG
if (-not $GIT_TAG) {
    $GIT_TAG = $(git tag -l --contains HEAD | Select-Object -First 1)
}

$VERSION = "${COMMIT}${DIRTY}"
if ((-not $DIRTY) -and ($GIT_TAG)) {
    $VERSION = "${GIT_TAG}"
}
$env:VERSION = $VERSION

$ARCH = $env:ARCH
<#
    clean all windows settings
#>

$ErrorActionPreference = 'Stop'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'
$InformationPreference = 'SilentlyContinue'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"

Log-Info "Start cleanning ..."

# check identity
if (-not (Is-Administrator))
{
    Log-Fatal "You need elevated Administrator privileges in order to run this script, start Windows PowerShell by using the Run as Administrator option"
}

# clean up docker conatiner: docker rm -fv $(docker ps -qa)
$containers = $(docker.exe ps -aq)
if ($containers)
{
    Log-Info "Cleaning up docker containers ..."
    $errMsg = $($containers | ForEach-Object {docker.exe rm -f $_})
    if (-not $?) {
        Log-Warn "Could not remove docker containers: $errMsg"
    }

    # wati a while for rancher-wins to clean up processes
    Start-Sleep -Seconds 10
}

# clean up kubernetes components processes
Get-Process -ErrorAction Ignore -Name "rancher-wins-*" | ForEach-Object {
    Log-Info "Stopping process $($_.Name) ..."
    $_ | Stop-Process -ErrorAction Ignore -Force
}

# clean up firewall rules
Get-NetFirewallRule -PolicyStore ActiveStore -Name "rancher-wins-*" -ErrorAction Ignore | ForEach-Object {
    Log-Info "Cleaning up firewall rule $($_.Name) ..."
    $_ | Remove-NetFirewallRule -ErrorAction Ignore | Out-Null
}

# clean up rancher-wins service
Get-Service -Name "rancher-wins" -ErrorAction Ignore | Where-Object {$_.Status -eq "Running"} | ForEach-Object {
    Log-Info "Stopping rancher-wins service ..."
    $_ | Stop-Service -Force -ErrorAction Ignore

    Log-Info "Unregistering rancher-wins service ..."
    Push-Location c:\etc\rancher
    $errMsg = $(.\wins.exe srv app run --unregister)
    if (-not $?) {
        Log-Warn "Could not unregister: $errMsg"
    }
    Pop-Location
}

# clean up network settings
try {
    Invoke-HNSRequest -Method "GET" -Type "networks" | Where-Object {@('cbr0', 'vxlan0') -contains $_.Name} | ForEach-Object {
        Log-Info "Cleaning up HNSNetwork $($_.Name) ..."
        Invoke-HNSRequest -Method "DELETE" -Type "networks" -Id $_.Id
    }

    Invoke-HNSRequest -Method "GET" -Type "policylists" | Where-Object {-not [string]::IsNullOrEmpty($_.Id)} | ForEach-Object {
        Log-Info "Cleaning up HNSPolicyList $($_.Id) ..."
        Invoke-HNSRequest -Method "DELETE" -Type "policylists" -Id $_.Id
    }
} catch {
    Log-Warn "Could not clean: $($_.Exception.Message)"
}

# clean up data
Get-Item -ErrorAction Ignore -Path @(
    "c:\run\*"
    "c:\opt\*"
    "c:\etc\rancher\*"
    "c:\etc\nginx\*"
    "c:\etc\cni\*"
    "c:\etc\kubernetes\*"
    "c:\var\run\*"
    "c:\var\log\*"
    "c:\var\lib\*"
) | ForEach-Object {
    Log-Info "Cleaning up data $($_.FullName) ..."
    try {
        $_ | Remove-Item -ErrorAction Ignore -Recurse -Force | Out-Null
    } catch {
        Log-Warn "Could not clean: $($_.Exception.Message)"
    }
}

<#
	entry.ps1 detects the first argument as command, and then
	select the corresponding execution logic
 #>

$ErrorActionPreference = 'Stop'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'
$InformationPreference = 'SilentlyContinue'

function Run-PowerShell
{
    param (
        [parameter(Mandatory = $false)] [string[]]$ArgumentList
    )

    try {
        if ($ArgumentList) {
            Start-Process -NoNewWindow -Wait -FilePath "powershell" -ArgumentList $ArgumentList
        } else {
            Start-Process -NoNewWindow -Wait -FilePath "powershell"
        }
    } catch {
        $errMsg = $_.Exception.Message
        if ($errMsg -like "*This command cannot be run due to the error: *") {
            if ($ArgumentList) {
                Start-Process -NoNewWindow -Wait -FilePath "pwsh" -ArgumentList $ArgumentList
            } else {
                Start-Process -NoNewWindow -Wait -FilePath "pwsh"
            }
        } else {
            throw $_
        }
    }
}

$psArgs = $null
$componentScript = "$PSScriptRoot\$($args[0]).ps1"
if (-not (Test-Path -ErrorAction Ignore -Path $componentScript))
{
    if ($env:CATTLE_AGENT_CONNECT -eq "true")
    {
        $psArgs = @("-NoLogo", "-NonInteractive", "-File", "$PSScriptRoot\execute.ps1") + $args[0..$args.Length]
    }
}
else
{
    $psArgs = @("-NoLogo", "-NonInteractive", "-File", "$PSScriptRoot\$($args[0]).ps1") + $args[1..$args.Length]
}


if ($psArgs)
{
    Run-PowerShell -ArgumentList $psArgs
<#
	output.ps1 could output the execution commands, and then
	pass the content to `Invoke-Expression` via pipe character
 #>

$ErrorActionPreference = 'Stop'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'
$InformationPreference = 'SilentlyContinue'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"
$CATTLE_PREFIX_PATH = Get-Env -Key "CATTLE_PREFIX_PATH"

# parse arguments
$vals = $null
for ($i = $args.Length; $i -ge 0; $i--)
{
    $arg = $args[$i]
    switch -regex ($arg)
    {
        '^(--prefix-path)$' {
            $CATTLE_PREFIX_PATH = ($vals | Select-Object -First 1)
            $vals = $null
        }
        default {
			if ($vals) {
				$vals = ,$arg + $vals
			} else {
				$vals = @($arg)
			}
		}
	}
}

if ([string]::IsNullOrEmpty($CATTLE_PREFIX_PATH)) {
	$CATTLE_PREFIX_PATH = "c:\"
}

if ($CATTLE_PREFIX_PATH.Chars($CATTLE_PREFIX_PATH.Length - 1) -ne '\') {
    # confirm trailing slash for path building below
    $CATTLE_PREFIX_PATH = ($CATTLE_PREFIX_PATH + '\')
}

$hostPrefixPath = $CATTLE_PREFIX_PATH -Replace "c:\\", "c:\host\"


# create directories on the host
# windows docker can only mount an existing path into containers
try
{
    New-Item -Force -ItemType Directory -Path @(
        "$($hostPrefixPath)opt"
        "$($hostPrefixPath)opt\bin"
        "$($hostPrefixPath)opt\cni"
        "$($hostPrefixPath)opt\cni\bin"
        "$($hostPrefixPath)etc"
        "$($hostPrefixPath)etc\rancher"
        "$($hostPrefixPath)etc\rancher\wins"
        "$($hostPrefixPath)etc\kubernetes"
        "$($hostPrefixPath)etc\kubernetes\bin"
        "$($hostPrefixPath)etc\cni"
        "$($hostPrefixPath)etc\cni\net.d"
        "$($hostPrefixPath)etc\nginx"
        "$($hostPrefixPath)etc\nginx\logs"
        "$($hostPrefixPath)etc\nginx\temp"
        "$($hostPrefixPath)etc\nginx\conf"
        "$($hostPrefixPath)etc\kube-flannel"
        "$($hostPrefixPath)var"
        "$($hostPrefixPath)var\run"
        "$($hostPrefixPath)var\log"
        "$($hostPrefixPath)var\log\pods"
        "$($hostPrefixPath)var\log\containers"
        "$($hostPrefixPath)var\lib"
        "$($hostPrefixPath)var\lib\cni"
        "$($hostPrefixPath)var\lib\rancher"
        "$($hostPrefixPath)var\lib\rancher\rke"
        "$($hostPrefixPath)var\lib\rancher\rke\log"
        "$($hostPrefixPath)var\lib\kubelet"
        "$($hostPrefixPath)var\lib\kubelet\volumeplugins"
        "$($hostPrefixPath)run"
        "c:\host\ProgramData\docker\certs.d"
    ) | Out-Null
} catch { }

# copy cleanup.ps1 & wins.exe to the host
# wins needs to run as a service on the host to accept requests from container
try
{
    Copy-Item -Force -Destination "$($hostPrefixPath)etc\rancher" -Path @(
        "c:\etc\rancher\utils.psm1"
        "c:\etc\rancher\cleanup.ps1"
        "c:\Windows\wins.exe"
    )
} catch { }

$verification = @"
Log-Info "Detecting running permission ..."
if (-not (Is-Administrator))
{
    Log-Fatal "You need elevated Administrator privileges in order to run this script, start Windows PowerShell by using the Run as Administrator option"
}

Log-Info "Detecting host CPU reservation ..."
try
{
    `$cpuLogicalProccessors = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty NumberOfLogicalProcessors
    if (`$cpuLogicalProccessors -le 1) {
        Log-Fatal "The CPU resource could not satisfy the default reservation for both Windows system and Kuberentes components, please increase the CPU resource to more than 2 logic processors"
    } elseif (`$cpuLogicalProccessors -lt 2) {
        Log-Warn "The CPU resource only satisfies the lowest limit for running Kubernetes components"
        Log-Warn "Please increase the CPU resource to more than 2 logic processors if you are unable to schedule Pods on this Node"
    }
}
catch
{
    Log-Warn "Could not detect the CPU resource: `$(`$_.Exception.Message)"
}

Log-Info "Detecting host RAM reservation ..."
try
{
    `$lowestLimitGB = 2.5
    `$systemType = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty PCSystemType
    if (`$systemType -eq 1) {
        # system with GUI
        `$lowestLimitGB = 4.5
    }

    `$ramTotalGB = `$(Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty TotalPhysicalMemory)/1GB
    if (`$ramTotalGB -lt `$lowestLimitGB) {
        Log-Fatal "The RAM resource could not satisfy the default reservation for both Windows system and Kubernetes components, please increase the RAM resource to more than `$lowestLimitGB GB"
    }

    `$ramAvailableMB = `$(Get-WmiObject -Class Win32_PerfFormattedData_PerfOS_Memory | Measure-Object -Sum -Property AvailableBytes | Select-Object -ExpandProperty Sum)/1MB
    if (`$ramAvailableMB -le 500) {
        Log-Fatal "The RAM resource could not satisfy the default reservation for Kuberentes components, please increase the RAM resource to more than `$lowestLimitGB GB"
    } elseif (`$ramAvailableMB -le 600) {
        Log-Warn "The RAM resource only satisfies the lowest limit for running Kubernetes components"
        Log-Warn "Please increase the RAM resource to more than `$lowestLimitGB GB if you are unable to schedule Pods on this Node"
    }
}
catch
{
    Log-Warn "Could not detect the RAM resource: `$(`$_.Exception.Message)"
}

Log-Info "Detecting host DISK reservation ..."
try
{
    `$diskAvaliableGB = `$(Get-WmiObject -Class Win32_LogicalDisk | Where-Object {`$_.DeviceID -eq "C:"} | Select-Object -ExpandProperty Size)/1GB
    if (`$diskAvaliableGB -lt 29.5) {
        Log-Fatal "The DISK resource could not satisfy the default reservation for both Windows system and Kubernetes components, please increase the DISK resource to more than 30 GB"
    } elseif (`$diskAvaliableGB -lt 49.5) {
        Log-Warn "The DISK resource only satisfies the lowest limit for running Kubernetes components"
        Log-Warn "Please increase the DISK resource to more than 50 GB if you are unable to schedule Pods on this Node"
    }
}
catch
{
    Log-Warn "Could not detect the DISK resource: `$(`$_.Exception.Message)"
}

Log-Info "Detecting host Docker named pipe existing ..."
`$dockerNPipe = Get-ChildItem //./pipe/ -ErrorAction Ignore | ? Name -eq "docker_engine"
if (-not `$dockerNPipe)
{
    Log-Warn "Default Docker named pipe is not available"
    Log-Warn "Please create '//./pipe/docker_engine' named pipe to access docker daemon if docker errors occur"
}

Log-Info "Detecting host Docker platform name..."
try
{
    `$dockerPlatform = docker.exe version -f "{{.Server.Platform.Name}}"
    if (-not (`$dockerPlatform -like '*Enterprise*') -AND -not (`$dockerPlatform -eq 'Mirantis Container Runtime'))
    {
        Log-Fatal "Only Docker EE or Mirantis Container Runtime supported"
    }
}
catch
{
    Log-Fatal "Could not find Docker service: `$(`$_.Exception.Message)"
}

Log-Info "Detecting host network interface ..."
`$vNetAdapters = Get-HnsNetwork | Select-Object -ExpandProperty "Subnets" | Select-Object -ExpandProperty "GatewayAddress"
`$allNetAdapters = Get-WmiObject -Class Win32_NetworkAdapterConfiguration -Filter "IPEnabled=True" | Sort-Object Index | ForEach-Object { `$_.IPAddress[0] } | Where-Object { -not (`$vNetAdapters -contains `$_) }
`$networkCount = `$allNetAdapters | Measure-Object | Select-Object -ExpandProperty "Count"
if (`$networkCount -gt 1)
{
    Log-Warn "More than 1 network interface was found: `$(`$allNetAdapters -join ", ")"
    Log-Warn "Please indicate --internal-address when adding failed"
}

Log-Info "Configuring host Docker Service to start automatically..."
try
{
    Get-Service -Name "docker" -ErrorAction Ignore | Where-Object {`$_.StartType -ne "Automatic"} | Set-Service -StartupType Automatic
}
catch
{
    Log-Warn "Could not configure the Docker service to start automatically: `$(`$_.Exception.Message)"
    Log-Warn "Please change the Docker service 'StartupType' to 'Automatic'"
}

Log-Info "Enabling host msiscsi service to support iscsi storage ..."
`$svcMsiscsi = Get-Service -Name "msiscsi" -ErrorAction Ignore
if (`$svcMsiscsi -and (`$svcMsiscsi.Status -ne "Running"))
{
    Set-Service -Name "msiscsi" -StartupType Automatic -WarningAction Ignore
    Start-Service -Name "msiscsi" -ErrorAction Ignore -WarningAction Ignore
    if (-not `$?) {
        Log-Warn "Failed to start msiscsi service, you may not be able to use the iSCSI flexvolume properly"
    }
}
"@

# allow user to disable the verification
if ($env:WITHOUT_VERIFICATION -eq "true") {
    $verification = ""
}

Out-File -Encoding ascii -FilePath "$($hostPrefixPath)etc\rancher\bootstrap.ps1" -InputObject @"
`$ErrorActionPreference = 'Stop'
`$WarningPreference = 'SilentlyContinue'
`$VerbosePreference = 'SilentlyContinue'
`$DebugPreference = 'SilentlyContinue'
`$InformationPreference = 'SilentlyContinue'

# import modules
Import-Module -WarningAction Ignore -Name "`$PSScriptRoot\utils.psm1"

# remove script
Remove-Item -Force -Path "`$PSScriptRoot\bootstrap.ps1" -ErrorAction Ignore

$verification

# repair Get-GcePdName method
# this is a stopgap, we could drop this after https://github.com/kubernetes/kubernetes/issues/74674 fixed
# related: rke-tools container
`$getGcePodNameCommand = Get-Command -Name "Get-GcePdName" -ErrorAction Ignore
if (-not `$getGcePodNameCommand)
{
    `$profilePath = "`$PsHome\profile.ps1"
    if (-not (Test-Path `$profilePath)) {
        New-Item -ItemType File -Path `$profilePath -ErrorAction Ignore | Out-Null
    }
    `$appendProfile = @'
Unblock-File -Path DLLPATH -ErrorAction Ignore
Import-Module -Name DLLPATH -ErrorAction Ignore
'@
    Add-Content -Path `$profilePath -Value `$appendProfile.replace('DLLPATH', "$($CATTLE_PREFIX_PATH)run\GetGcePdName.dll") -ErrorAction Ignore
}

# clean up the stale HNS network if required
try
{
    # warm up HNS network
    1..5 | ForEach-Object { Invoke-HNSRequest -Method "GET" -Type "networks" | Out-Null }

    # remove the HNS networks
    Invoke-HNSRequest -Method "GET" -Type "networks" | Where-Object {@('cbr0', 'vxlan0') -contains `$_.Name} | ForEach-Object {
        Log-Info "Cleaning up stale HNSNetwork `$(`$_.Name) ..."
        Invoke-HNSRequest -Method "DELETE" -Type "networks" -Id `$_.Id
    }

    # remove the HNS policies
    Invoke-HNSRequest -Method "GET" -Type "policylists" | Where-Object {-not [string]::IsNullOrEmpty(`$_.Id)} | ForEach-Object {
        Log-Info "Cleaning up HNSPolicyList `$(`$_.Id) ..."
        Invoke-HNSRequest -Method "DELETE" -Type "policylists" -Id `$_.Id
    }
}
catch
{
    Log-Warn "Could not clean: `$(`$_.Exception.Message)"
}

# output wins config
@{
    whiteList = @{
        processPaths = @(
            "$($CATTLE_PREFIX_PATH)etc\wmi-exporter\wmi-exporter.exe"
            "$($CATTLE_PREFIX_PATH)etc\kubernetes\bin\kube-proxy.exe"
            "$($CATTLE_PREFIX_PATH)etc\kubernetes\bin\kubelet.exe"
            "$($CATTLE_PREFIX_PATH)etc\nginx\nginx.exe"
            "$($CATTLE_PREFIX_PATH)opt\bin\flanneld.exe"
        )
    }
} | ConvertTo-Json -Compress -Depth 32 | Out-File -NoNewline -Encoding utf8 -Force -FilePath "$($CATTLE_PREFIX_PATH)etc\rancher\wins\config"

# register wins
Start-Process -NoNewWindow -Wait ``
    -FilePath "$($CATTLE_PREFIX_PATH)etc\rancher\wins.exe" ``
    -ArgumentList "srv app run --register"

# start wins
Start-Service -Name "rancher-wins" -ErrorAction Ignore

# run agent
Start-Process -NoNewWindow -Wait ``
    -FilePath "docker.exe" ``
    -ArgumentList "run -d --restart=unless-stopped -e CATTLE_PREFIX_PATH=$CATTLE_PREFIX_PATH -v \\.\pipe\docker_engine:\\.\pipe\docker_engine -v c:\ProgramData\docker\certs.d:c:\etc\docker\certs.d -v $($CATTLE_PREFIX_PATH)etc\kubernetes:c:\etc\kubernetes -v \\.\pipe\rancher_wins:\\.\pipe\rancher_wins -v $($CATTLE_PREFIX_PATH)etc\rancher\wins:c:\etc\rancher\wins $($env:AGENT_IMAGE) execute $($args -join " ")"
"@

$ErrorActionPreference = 'Stop'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'
$InformationPreference = 'SilentlyContinue'

function Log-Info
{
    Write-Host -NoNewline -ForegroundColor Blue "INFO: "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($args -join " "))
}

function Log-Warn
{
    Write-Host -NoNewline -ForegroundColor DarkYellow "WARN: "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($args -join " "))
}

function Log-Error
{
    Write-Host -NoNewline -ForegroundColor DarkRed "ERRO: "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($args -join " "))
}

function Log-Fatal
{
    Write-Host -NoNewline -ForegroundColor DarkRed "FATA: "
    Write-Host -ForegroundColor Gray ("{0,-44}" -f ($args -join " "))

    exit 255
}

function Is-Administrator
{
    $p = New-Object System.Security.Principal.WindowsPrincipal([System.Security.Principal.WindowsIdentity]::GetCurrent())
    return $p.IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
}

function ConvertTo-JsonObj
{
    param (
        [parameter(Mandatory = $false, ValueFromPipeline = $true)] [string]$JSON
    )

    if (-not $JSON) {
        return $null
    }

    try {
        $ret = $JSON | ConvertFrom-Json -ErrorAction Ignore -WarningAction Ignore
        return $ret
    } catch {
        return $null
    }
}

function Set-Env
{
    param(
        [parameter(Mandatory = $true)] [string]$Key,
        [parameter(Mandatory = $false)] [string]$Value = ""
    )

    try {
        [Environment]::SetEnvironmentVariable($Key, $Value, [EnvironmentVariableTarget]::Process)
    } catch {
        Log-Error "Could not set $Key = $Value in Process target: $($_.Exception.Message)"
    }

    try {
        [Environment]::SetEnvironmentVariable($Key, $Value, [EnvironmentVariableTarget]::Machine)
    } catch {
        Log-Error "Could not set $Key = $Value in Machine target: $($_.Exception.Message)"
    }
}

function Get-Env
{
    param(
        [parameter(Mandatory = $true)] [string]$Key
    )

    try {
        $val = [Environment]::GetEnvironmentVariable($Key, [EnvironmentVariableTarget]::Process)
        if ($val) {
            return $val
        }
    } catch {
        Log-Error "Could not get $Key in Process target: $($_.Exception.Message)"
    }

    try {
        $val = [Environment]::GetEnvironmentVariable($Key, [EnvironmentVariableTarget]::Machine)
        if ($val) {
            return $val
        }
    } catch {
        Log-Error "Could not get $Key in Machine target: $($_.Exception.Message)"
    }

    return ""
}

function Get-VmComputeNativeMethods()
{
    $ret = 'VmCompute.PrivatePInvoke.NativeMethods' -as [type]
    if (-not $ret) {
        $signature = @'
[DllImport("vmcompute.dll")]
public static extern void HNSCall([MarshalAs(UnmanagedType.LPWStr)] string method, [MarshalAs(UnmanagedType.LPWStr)] string path, [MarshalAs(UnmanagedType.LPWStr)] string request, [MarshalAs(UnmanagedType.LPWStr)] out string response);
'@
        $ret = Add-Type -MemberDefinition $signature -Namespace VmCompute.PrivatePInvoke -Name "NativeMethods" -PassThru
    }
    return $ret
}

function Invoke-HNSRequest
{
    param
    (
        [ValidateSet('GET', 'POST', 'DELETE')]
        [parameter(Mandatory = $true)] [string] $Method,
        [ValidateSet('networks', 'endpoints', 'activities', 'policylists', 'endpointstats', 'plugins')]
        [parameter(Mandatory = $true)] [string] $Type,
        [parameter(Mandatory = $false)] [string] $Action,
        [parameter(Mandatory = $false)] [string] $Data = "",
        [parameter(Mandatory = $false)] [Guid] $Id = [Guid]::Empty
    )

    $hnsPath = "/$Type"
    if ($id -ne [Guid]::Empty) {
        $hnsPath += "/$id"
    }
    if ($Action) {
        $hnsPath += "/$Action"
    }

    $response = ""
    $hnsApi = Get-VmComputeNativeMethods
    $hnsApi::HNSCall($Method, $hnsPath, "$Data", [ref]$response)

    $output = @()
    if ($response) {
        try {
            $output = ($response | ConvertFrom-Json)
            if ($output.Error) {
                Log-Error $output;
            } else {
                $output = $output.Output;
            }
        } catch {
            Log-Error $_.Exception.Message
        }
    }

    return $output;
}

function Transfer-File
{
    param (
        [parameter(Mandatory = $true)] [string]$Src,
        [parameter(Mandatory = $true)] [string]$Dst
    )

    if (Test-Path -PathType leaf -Path $Dst) {
        $dstHasher = Get-FileHash -Path $Dst
        $srcHasher = Get-FileHash -Path $Src
        if ($dstHasher.Hash -eq $srcHasher.Hash) {
            return
        }
    }

    try {
        $null = Copy-Item -Force -Path $Src -Destination $Dst
    } catch {
        Log-Fatal "Could not transfer file $Src to $Dst : $($_.Exception.Message)"
    }
}

Export-ModuleMember -Function Log-Info
Export-ModuleMember -Function Log-Warn
Export-ModuleMember -Function Log-Error
Export-ModuleMember -Function Log-Fatal
Export-ModuleMember -Function Is-Administrator
Export-ModuleMember -Function ConvertTo-JsonObj
Export-ModuleMember -Function Set-Env
Export-ModuleMember -Function Get-Env
Export-ModuleMember -Function Get-VmComputeNativeMethods
Export-ModuleMember -Function Invoke-HNSRequest
<#
	run.ps1 executes the agent
 #>

$ErrorActionPreference = 'Stop'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'
$InformationPreference = 'SilentlyContinue'

Import-Module -WarningAction Ignore -Name "$PSScriptRoot\utils.psm1"

function Get-Address
{
    param(
        [parameter(Mandatory = $false)] [string]$Addr
    )

    if (-not $Addr) {
        return ""
    }

    # If given address is a network interface on the system, retrieve configured IP on that interface (only the first configured IP is taken)
    try {
        $getAdapterJson = wins.exe cli net get --name $Addr
        if ($?) {
            $namedNetwork = $getAdapterJson | ConvertTo-JsonObj
            if ($namedNetwork) {
                return $namedNetwork.AddressCIDR -replace "/32",""
            }
        }
    } catch {}

    # Repair the container route for `169.254.169.254` before cloud provider query
    $actualGateway = $(route.exe print 0.0.0.0 | Where-Object {$_ -match '0\.0\.0\.0.*[a-z]'} | Select-Object -First 1 | ForEach-Object {($_ -replace '0\.0\.0\.0|[a-z]|\s+',' ').Trim() -split ' '} | Select-Object -First 1)
    $expectedGateway = $(route.exe print 169.254.169.254 | Where-Object {$_ -match '169\.254\.169\.254'} | Select-Object -First 1 | ForEach-Object {($_ -replace '169\.254\.169\.254|255\.255\.255\.255|[a-z]|\s+',' ').Trim() -split ' '} | Select-Object -First 1)
    if ($actualGateway -ne $expectedGateway) {
        $errMsg = $(route.exe add 169.254.169.254 MASK 255.255.255.255 $actualGateway METRIC 1)
        if (-not $?) {
            Log-Error "Could not repair contain route for using cloud provider"
        }
    }

    # Loop through cloud provider options to get IP from metadata, if not found return given value
    switch ($Addr)
    {
        "awslocal" {
            return $(curl.exe -s "http://169.254.169.254/latest/meta-data/local-ipv4")
        }
        "awspublic" {
            return $(curl.exe -s "http://169.254.169.254/latest/meta-data/public-ipv4")
        }
        "doprivate" {
            return $(curl.exe -s "http://169.254.169.254/metadata/v1/interfaces/private/0/ipv4/address")
        }
        "dopublic" {
            return $(curl.exe -s "http://169.254.169.254/metadata/v1/interfaces/public/0/ipv4/address")
        }
        "azprivate" {
            return $(curl.exe -s -H "Metadata:true" "http://169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/privateIpAddress?api-version=2017-08-01&format=text")
        }
        "azpublic" {
            return $(curl.exe -s -H "Metadata:true" "http://169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-08-01&format=text")
        }
        "gceinternal" {
            return $(curl.exe -s -H "Metadata-Flavor: Google" "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip?alt=json")
        }
        "gceexternal" {
            return $(curl.exe -s -H "Metadata-Flavor: Google" "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip?alt=json")
        }
        "packetlocal" {
            return $(curl.exe -s "https://metadata.packet.net/2009-04-04/meta-data/local-ipv4")
        }
        "packetpublic" {
            return $(curl.exe -s "https://metadata.packet.net/2009-04-04/meta-data/public-ipv4")
        }
        "ipify" {
            return $(curl.exe -s "https://api.ipify.org")
        }
    }

    return $Addr
}

# required envs
Set-Env -Key "DOCKER_HOST" -Value "npipe:////./pipe/docker_engine"
Set-Env -Key "CATTLE_ROLE" -Value "worker"

# clean up
$CLUSTER_CLEANUP = Get-Env -Key "CLUSTER_CLEANUP"
if ($CLUSTER_CLEANUP -eq "true")
{
    Start-Process -NoNewWindow -Wait -FilePath "c:\etc\rancher\agent.exe"
    exit 0
}

# init parameters
$CATTLE_SERVER = Get-Env -Key "CATTLE_SERVER"
$CATTLE_TOKEN = Get-Env -Key "CATTLE_TOKEN"
$CATTLE_NODE_NAME = Get-Env -Key "CATTLE_NODE_NAME"
$CATTLE_ADDRESS = Get-Env -Key "CATTLE_ADDRESS"
$CATTLE_INTERNAL_ADDRESS = Get-Env -Key "CATTLE_INTERNAL_ADDRESS"
$CATTLE_CA_CHECKSUM = Get-Env -Key "CATTLE_CA_CHECKSUM"
$CATTLE_NODE_LABEL = @()
$CATTLE_NODE_TAINTS = @()

# parse arguments
$vals = $null
for ($i = $args.Length; $i -ge 0; $i--)
{
    $arg = $args[$i]
    switch -regex ($arg)
    {
        '^(-d|--debug)$' {
            Set-Env -Key "CATTLE_DEBUG" -Value "true"
            $vals = $null
        }
        '^(-s|--server)$' {
            $CATTLE_SERVER = ($vals | Select-Object -First 1)
            $vals = $null
        }
        '^(-t|--token)$' {
            $CATTLE_TOKEN = ($vals | Select-Object -First 1)
            $vals = $null
        }
        '^(-c|--ca-checksum)$' {
            $CATTLE_CA_CHECKSUM = ($vals | Select-Object -First 1)
            $vals = $null
        }
        '^(-all|--all-roles)$' {
            $vals = $null
        }
        '^(-e|--etcd)$' {
            $vals = $null
        }
        '^(-w|--worker)$' {
            $vals = $null
        }
        '^(-p|--controlplane)$' {
            $vals = $null
        }
        '^(-r|--node-name)$' {
            $CATTLE_NODE_NAME = ($vals | Select-Object -First 1)
            $vals = $null
        }
        '^(-n|--no-register)$' {
            Set-Env -Key "CATTLE_AGENT_CONNECT" -Value "true"
            $vals = $null
        }
        '^(-a|--address)$' {
            $CATTLE_ADDRESS = ($vals | Select-Object -First 1)
            $vals = $null
        }
        '^(-i|--internal-address)$' {
            $CATTLE_INTERNAL_ADDRESS = ($vals | Select-Object -First 1)
            $vals = $null
        }
        '^(-l|--label)$' {
            if ($vals) {
                $CATTLE_NODE_LABEL += $vals
            }
            $vals = $null
        }
        '^(-o|--only-write-certs)$' {
            Set-Env -Key "CATTLE_WRITE_CERT_ONLY" -Value "true"
            $vals = $null
        }
        '^--taints$' {
            if ($vals) {
                $CATTLE_NODE_TAINTS += $vals
            }
            $vals = $null
        }
        default {
            if ($vals) {
                $vals = ,$arg + $vals
            } else {
                $vals = @($arg)
            }
        }
    }
}

# use the register token to request wins server
if (Test-Path -PathType Leaf -Path "c:\cattle-credentials\token")
{
    $token = Get-Content -Path "c:\cattle-credentials\token" -Raw -ErrorAction Ignore
    Set-Env -Key "WINS_AUTH_TOKEN" -Value $token
}

# check docker npipe
$CATTLE_CLUSTER = Get-Env -Key "CATTLE_CLUSTER"
if ($CATTLE_CLUSTER -ne "true")
{
    $dockerNPipe = Get-ChildItem //./pipe/ -ErrorAction Ignore | ? Name -eq "docker_engine"
    if (-not $dockerNPipe) {
        Log-Warn "Default docker named pipe is not found"
        Log-Warn "Please bind mount in the docker named pipe to //./pipe/docker_engine if docker errors occur"
        Log-Warn "example: docker run -v //./pipe/custom_docker_named_pipe://./pipe/docker_engine ..."
    }
}

# get address
$CATTLE_ADDRESS = Get-Address -Addr $CATTLE_ADDRESS
$CATTLE_INTERNAL_ADDRESS = Get-Address -Addr $CATTLE_INTERNAL_ADDRESS

# get default network metadata when nodeName or address is blank
if ((-not $CATTLE_NODE_NAME) -or (-not $CATTLE_ADDRESS))
{
    $getAdapterJson = wins.exe cli net get
    if ($?) {
        $defaultNetwork = $getAdapterJson | ConvertTo-JsonObj
        if ($defaultNetwork) {
            if (-not $CATTLE_NODE_NAME) {
                $CATTLE_NODE_NAME = $defaultNetwork.HostName
                $CATTLE_NODE_NAME = $CATTLE_NODE_NAME.ToLower()
            }

            if (-not $CATTLE_ADDRESS) {
                $CATTLE_ADDRESS = $defaultNetwork.AddressCIDR -replace "/32",""
            }
        } else {
            Log-Warn "Could not convert '$getAdapterJson' to json object"
        }
    } else {
        Log-Warn "Could not get host network metadata: $getAdapterJson"
    }
}

# check token and address
$CATTLE_K8S_MANAGED = Get-Env -Key "CATTLE_K8S_MANAGED"
if ($CATTLE_K8S_MANAGED -ne "true")
{
    if (-not $CATTLE_TOKEN) {
        Log-Fatal "--token is a required option"
    }
    if (-not $CATTLE_ADDRESS) {
        Log-Fatal "--address is a required option"
    }
}

# check rancher server address
if (-not $CATTLE_SERVER)
{
    Log-Fatal "--server is a required option"
}

# check rancher server
try
{
    curl.exe --insecure -s -fL "$CATTLE_SERVER/ping" | Out-Null
    if ($?) {
        Log-Info "$CATTLE_SERVER is accessible"
    } else {
        Log-Fatal "$CATTLE_SERVER is not accessible"
    }
}
catch
{
    Log-Fatal "$CATTLE_SERVER is not accessible: $($_.Exception.Message)"
}

# download cattle server CA
if ($CATTLE_CA_CHECKSUM)
{
    $sslCertDir = Get-Env -Key "SSL_CERT_DIR"
    $server = $CATTLE_SERVER
    $caChecksum = $CATTLE_CA_CHECKSUM
    $temp = New-TemporaryFile
    $cacerts = $null
    try {
        $cacerts = $(curl.exe --insecure -s -fL "$server/v3/settings/cacerts" | ConvertTo-JsonObj).value
    } catch {}
    if (-not $cacerts) {
        Log-Fatal "Could not get cattle server CA from $server"
    }

    $cacerts + "`n" | Out-File -NoNewline -Encoding ascii -FilePath $temp.FullName
    $tempHasher = Get-FileHash -LiteralPath $temp.FullName -Algorithm SHA256
    if ($tempHasher.Hash.ToLower() -ne $caChecksum.ToLower()) {
        $temp.Delete()
        Log-Fatal "Actual cattle server CA checksum is $($tempHasher.Hash.ToLower()), $server/v3/settings/cacerts does not match $($caChecksum.ToLower())"
    }
    Remove-Item -Force -Recurse -Path "$sslCertDir\serverca" -ErrorAction Ignore
    New-Item -Force -ItemType Directory -Path $sslCertDir -ErrorAction Ignore | Out-Null
    $temp.MoveTo("$sslCertDir\serverca")

    # import the self-signed certificate
    $caBytes = $null
    Get-Content "$sslCertDir\serverca" | % {
        if ($_ -match '-+BEGIN CERTIFICATE-+') {
            $caBytes = @()
        } elseif ($_ -match '-+END CERTIFICATE-+') {
            $caTemp = New-TemporaryFile
            $caString = [Convert]::ToBase64String($caBytes)
            Set-Content -Value $caString -Path $caTemp.FullName
            certoc.exe -addstore root $caTemp.FullName | Out-Null
            if (-not $?) {
                $caTemp.Delete()
                Log-Fatal "Failed to import rancher server certificates to Root"
            }
            $caTemp.Delete()
        } else {
            $caBytes += [Convert]::FromBase64String($_)
        }
    }

    $CATTLE_SERVER_HOSTNAME = ([System.Uri]"$server").Host
    $CATTLE_SERVER_HOSTNAME_WITH_PORT = ([System.Uri]"$server").Authority

    # windows path could not allow colons
    $CATTLE_SERVER_HOSTNAME_WITH_PORT = $CATTLE_SERVER_HOSTNAME_WITH_PORT -replace ":", ""

    $dockerCertsPath = "c:\etc\docker\certs.d\$CATTLE_SERVER_HOSTNAME_WITH_PORT"
    New-Item -Force -ItemType Directory -Path $dockerCertsPath -ErrorAction Ignore | Out-Null
    Copy-Item -Force -Path "$sslCertDir\serverca" -Destination "$dockerCertsPath\ca.crt" -ErrorAction Ignore
}

# add labels
$getVersionJson = wins.exe cli host get-version
if ($?) {
    $windowsCurrentVersion = $getVersionJson | ConvertTo-JsonObj
    if ($windowsCurrentVersion) {
        $versionTag = "$($windowsCurrentVersion.CurrentMajorVersionNumber).$($windowsCurrentVersion.CurrentMinorVersionNumber).$($windowsCurrentVersion.CurrentBuildNumber).$($windowsCurrentVersion.UBR)"
        $CATTLE_NODE_LABEL += @("rke.cattle.io/windows-version=$versionTag")
        $CATTLE_NODE_LABEL += @("rke.cattle.io/windows-release-id=$($windowsCurrentVersion.ReleaseId)")
        $CATTLE_NODE_LABEL += @("rke.cattle.io/windows-major-version=$($windowsCurrentVersion.CurrentMajorVersionNumber)")
        $CATTLE_NODE_LABEL += @("rke.cattle.io/windows-minor-version=$($windowsCurrentVersion.CurrentMinorVersionNumber)")
        $CATTLE_NODE_LABEL += @("rke.cattle.io/windows-kernel-version=$($windowsCurrentVersion.BuildLabEx)")
        $CATTLE_NODE_LABEL += @("rke.cattle.io/windows-build=$($windowsCurrentVersion.CurrentBuild)")
    } else {
        Log-Warn "Could not convert Windows Current Version JSON '$getVersionJson' to object"
    }
} else {
    Log-Warn "Could not get host version: $getVersionJson"
}

# set environment variables
Set-Env -Key "CATTLE_SERVER" -Value $CATTLE_SERVER
Set-Env -Key "CATTLE_TOKEN" -Value $CATTLE_TOKEN
Set-Env -Key "CATTLE_ADDRESS" -Val $CATTLE_ADDRESS
Set-Env -Key "CATTLE_INTERNAL_ADDRESS" -Val $CATTLE_INTERNAL_ADDRESS
Set-Env -Key "CATTLE_NODE_NAME" -Value $CATTLE_NODE_NAME
Set-Env -Key "CATTLE_NODE_LABEL" -Value $($CATTLE_NODE_LABEL -join ",")
Set-Env -Key "CATTLE_NODE_TAINTS" -Value $($CATTLE_NODE_TAINTS -join ",")
#Requires -Version 5.0
$ErrorActionPreference = "Stop"

$STATIC_CONTENT_PATH = "c:\inetpub\wwwroot"
$CONTAINER_NAME = $env:CONTAINER_NAME
if (-not $CONTAINER_NAME) {
    $CONTAINER_NAME = hostname
}
$CONTAINER_NAME | Out-File -Encoding ascii -Force -FilePath "$STATIC_CONTENT_PATH\name.html"
$CONTAINER_NAME | Out-File -Encoding ascii -Force -FilePath "$STATIC_CONTENT_PATH\service1.html"
$defaultStyleText = "(default style)"
$headerMarkdown = "##"
$listMarkdown = "-"
$themesDirectory = "..\MaterialDesignThemes.Wpf\Themes\"
$latestHash = git log -1 --pretty=format:"%H"
$baseURL = "https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit/blob"
$filePathURL = "MaterialDesignThemes.Wpf/Themes"
$outputFileName = "ControlStyleList.md"
$themesFullDir = Join-Path $PSScriptRoot $themesDirectory 
$outputFullDir = Join-Path $PSScriptRoot $outputFileName
$DebugPreference = 'Continue' # Log debug messages to terminal.

$discoverdStyles = New-Object System.Collections.ArrayList
$defaults = New-Object System.Collections.ArrayList

Function Main {
    # Get xaml files and loop through.
    Get-ChildItem $themesFullDir -Filter *.xaml | 
        Foreach-Object {
            $xamlString = Get-Content -Path $_.FullName
            $file = Select-ControlNameFromFile($_.Name)
            Read-XamlStyles -xamlString $xamlString -file $file 
        }
    Set-Defaults
    Format-Output
}

Function Format-Output {
    Write-OutputFile "[//]: <> (AUTO GENERATED FILE; DO NOT EDIT)"
    foreach($style in $discoverdStyles | Sort-Object -Property File,@{Expression = {$_.IsDefault}; Ascending = $false}) {
        if ($previousFile -ne $style.File) {
            Write-OutputFile "`n$headerMarkdown $($style.File)"
        }
        $previousFile = $style.File;
        
        $linkAndStyleName = "[$($style.Style)]($($baseURL)/$($latestHash)/" +
                            "$($filePathURL)/MaterialDesignTheme.$($style.File).xaml)";
        if ($style.IsDefault) {
            Write-OutputFile ("$listMarkdown $($linkAndStyleName) $defaultStyleText" -replace '\s+', ' ')
        }
        else {
            Write-OutputFile "$listMarkdown $($linkAndStyleName)"
        }
    }
}

Function Write-OutputFile{
    Param ($output)
    Add-content $outputFullDir -value $output
    Write-Debug $output #debug
}

Function Set-Defaults{
    ForEach ($default in $defaults) {
        $style = $discoverdStyles.Where({$_.style -match $default.style -and $_.Control -match $default.Type})
        if ($null -ne $style[0]) {
            $style[0].IsDefault = $true
        }
        else {            
            $temp = Get-Style -targetType $default.Type -styleName $default.Style -fileName $default.Type
            $discoverdStyles.Add($temp) | Out-Null
        }
    }
    $discoverdStyles | Format-Table #debug
}

Function Select-ControlNameFromFile {
    Param ($fileName)
    return $fileName -replace ".xaml" -replace "MaterialDesignTheme."
}

Function Read-XamlStyles {
    Param ($xamlString, $file)
    [xml]$xaml = $xamlString
    $xaml.ResourceDictionary.Style |
    Foreach-Object { 
        Write-Output $_
        if ($file -eq "Defaults") {
            # Special handeling of Defaults
            New-Default -style $_ -file $file 
        }
        elseif ($file -eq "Generic") {
            # Special handeling of Generic
            New-GenericDefault -style $_ -file $file 
        }
        else{
            New-Style -style $_ -file $file
        }
    }
}

Function New-GenericDefault {
    Param ($style, $file)
    $targetType = Read-TargetType($style | Select-Object TargetType)
    $basedOn = Read-BasedOn($style | Select-Object BasedOn)
    $styleNameValue = ($style | Select-Object Key).Key
    $defaultStyleName = if ($null -eq $styleNameValue) { $basedOn } else { $styleNameValue }
    Write-Debug "[$file] [Type: $targetType] [StyleNameValue: $styleNameValue] [BasedOn: $basedOn] [DefaultStyleName: $defaultStyleName]"
    Add-DefaultStyle -file $file -targetType $targetType -styleName $defaultStyleName
}


Function New-Default {
    Param ($style, $file)
    $targetType = Read-TargetType($style | Select-Object TargetType)
    $basedOn = Read-BasedOn($style | Select-Object BasedOn)
    $styleNameValue = ($style | Select-Object Key).Key
    $defaultStyleName = if ($null -eq $styleNameValue) { $basedOn } else { $styleNameValue }
    Write-Debug "[$file] [Type: $targetType] [StyleNameValue: $styleNameValue] [BasedOn: $basedOn] [DefaultStyleName: $defaultStyleName]"
    Add-DefaultStyle -file $file -targetType $targetType -styleName $defaultStyleName
}

Function New-Style {
    Param ($style, $file)
    $targetType = Read-TargetType($style | Select-Object TargetType)
    $styleName = ($style | Select-Object Key).Key
    $splittedFile =  $file.split('.') # Suport for "nested" file names like DataGrid.ComboBox

    if ($targetType -eq $splittedFile[-1]) {
        Write-Debug "[Match  ] [File: $file] [Type: $targetType] [Style: $styleName]"
        Add-Style -targetType $targetType -styleName $styleName -fileName $file
    }
    else {
        Write-Debug "[Skipped] [File: $file] [Type: $targetType] [Style: $styleName] "
    }
}

Function Add-Style {
    Param ($targetType, $styleName, $fileName)
    $temp = Get-Style -targetType $targetType -styleName $styleName -fileName $file
    $discoverdStyles.Add($temp) | Out-Null
}

Function Get-Style {
    Param ($targetType, $styleName, $fileName)
    $temp = "" | Select-Object "Control", "Style", "IsDefault", "File"
    $temp.Control = $targetType
    $temp.Style = $styleName
    $temp.IsDefault = !$styleName
    $temp.File = $fileName
    return $temp
}

Function Add-DefaultStyle {
    Param ($file, $targetType, $styleName)
    $temp = "" | Select-Object "File", "Type", "Style"
    $temp.File = $file
    $temp.Type = $targetType
    $temp.Style = $styleName
    $defaults.Add($temp) | Out-Null
}

Function Read-TargetType {
    Param ($targetTypeText)
    return ($targetTypeText.TargetType -replace "{x:Type" -replace "{x:Type" -replace ".*:" -replace "}*" -replace "Base").Trim()
}

Function Read-BasedOn {
    Param ($targetTypeText)
    return ($targetTypeText.BasedOn -replace "{StaticResource" -replace ".*:" -replace "}*").Trim()
param(
  [string]$MDIXVersion = "1.0.0",
  [string]$MDIXColorsVersion = "1.0.0",
  [string]$MDIXMahAppsVersion = "1.0.0"
)

$year = [System.DateTime]::Now.ToString("yyyy")
$copywrite = "Copyright $year James Willock/Mulholland Software Ltd"
$configuration = "Release"

function Update-Icon {
  param (
    [string]$Path
  )
  $Path = Resolve-Path $Path
  [xml] $xml = Get-Content $Path
  [string] $iconUrl = $xml.package.metadata.iconUrl;
  if (![string]::IsNullOrWhiteSpace($iconUrl) -and [string]::IsNullOrWhiteSpace($xml.package.metadata.icon)) {
    $nugetIconFile = "$($xml.package.metadata.id).Icon.png";
    Invoke-WebRequest $iconUrl -OutFile "$nugetIconFile"
    $files = $xml.SelectSingleNode("/package/files")
    $iconFile = $xml.CreateElement("file")
    $iconFile.SetAttribute("src", "$nugetIconFile")
    $iconFile.SetAttribute("target", "images\")
    $files.AppendChild($iconFile) | Out-Null

    $iconElement = $xml.CreateElement("icon")
    $iconElement.InnerText = "images\$nugetIconFile"
    $xml.package.metadata.AppendChild($iconElement) | Out-Null
  }
  $xml.Save($Path)
}

function Update-Versions {
  param (
    [string]$Path
  )
  $Path = Resolve-Path $Path
  [xml] $xml = Get-Content $Path

  foreach($dependency in $xml.package.metadata.dependencies.group.dependency){
    if ($dependency.id -eq "MaterialDesignColors") {
      $dependency.version = Get-VersionString $MDIXColorsVersion
    } elseif ($dependency.id -eq "MaterialDesignThemes") {
      $dependency.version = Get-VersionString $MDIXVersion
    }
  }
  $xml.Save($Path)
}

function Get-VersionString {
  param (
    [string]$Version
  )

  $callback = {
    [int]$args[0].Groups[1].Value + 1
  }

  $re = [regex]"^(\d+).*"
  $nextVersion = $re.Replace($Version, $callback)
  return "[$Version,$nextVersion.0)"
}

function New-Nuget {
  param (
    [string]$NuSpecPath,
    [string]$Version
  )

  $NuSpecPath = Resolve-Path $NuSpecPath
  Update-Icon "$NuSpecPath" 
  nuget pack "$NuSpecPath" -version "$Version" -Properties "Configuration=$configuration;Copywrite=$copywrite"
}

Push-Location "$(Join-Path $PSScriptRoot "..")"

Update-Versions .\MaterialDesignColors.nuspec
Update-Versions .\MaterialDesignThemes.nuspec
Update-Versions .\MaterialDesignThemes.MahApps.nuspec

New-Nuget .\MaterialDesignColors.nuspec $MDIXColorsVersion
New-Nuget .\MaterialDesignThemes.nuspec $MDIXVersion
New-Nuget .\MaterialDesignThemes.MahApps.nuspec $MDIXMahAppsVersion

param(
  [string]$Path,
  [string]$MDIXVersion = "1.0.0",
  [string]$MDIXColorsVersion = "1.0.0",
  [string]$MDIXMahAppsVersion = "1.0.0"
)

function Get-VersionString {
  param (
    [string]$Version
  )

  $incrementCallback = {
    [int]$args[0].Groups[1].Value + 1
  }
  $releaseVersionCallback = {
      "$($args[0].Groups[1].Value).$($args[0].Groups[2].Value)"
  }

  $re = [regex]"^(\d+)\.(\d+\.\d+).*"
  $releaseVersion = $re.Replace($Version, $releaseVersionCallback)
  $nextVersion = $re.Replace($Version, $incrementCallback)
  return "[$releaseVersion,$nextVersion)"
}

Push-Location "$(Join-Path $PSScriptRoot "..")"

$Path = Resolve-Path $Path

nupkgwrench nuspec dependencies modify "$Path" --dependency-id "MaterialDesignThemes" --dependency-version "$(Get-VersionString $MDIXVersion)"
$fn = $($MyInvocation.MyCommand.Name)
$name = $fn -replace "(.*)\.ps1$", '$1'
Register-ArgumentCompleter -Native -CommandName $name -ScriptBlock {
     param($commandName, $wordToComplete, $cursorPosition)
     $other = "$wordToComplete --generate-bash-completion"
param (
  [string]$platform,
  [string]$arch
)

$ErrorActionPreference = "Stop";

$binary = "portainer.exe"
$project_path = $((Get-Location).Path)

New-Item -Name dist -Path "$project_path" -ItemType Directory | Out-Null
Set-Location -Path "$project_path\api\cmd\portainer"

C:\go\bin\go.exe get -t -d -v ./...
C:\go\bin\go.exe build -v
# build-chocolatey.ps1: Builds a Chocolatey package for Bit, and optionally pushes it to
# Chocolatey.org (if the -Publish flag is passed).

param(
  [switch] $Publish = $false
)

#$ErrorActionPreference = 'Stop'; # stop on all errors

$latest_version = $(node -p -e "require('./package.json').version")
#$latest_chocolatey_version = (Find-Package -Name Bit).Version

#if ([Version]$latest_chocolatey_version -ge [Version]$latest_version) {
#  Write-Output ('Current version ({0}) is the latest' -f $latest_chocolatey_version)
#  Exit
#}

#Write-Output ('Latest version is {0}, version on Chocolatey is {1}. Updating...' -f $latest_version, $latest_chocolatey_version)

if (-Not (Test-Path artifacts)) {
  mkdir artifacts
}
# Remove any existing Chocolatey packages, we don't care about them any more
rm artifacts/*.nupkg

# Download the installer so we can compute its hash
# Keep this in sync with chocolateyInstall.ps1.in
# This is intentionally not using /latest.msi to ensure the URL used by the Chocolatey package is valid.
$url = "https://bitsrc.jfrog.io/bitsrc/bit-msi/$env:ENVIRONMENT/bit/$latest_version/bit-$latest_version-unsigned.msi"
$installer_file = [IO.Path]::GetTempFileName()
Invoke-WebRequest -Uri $url -OutFile $installer_file

$hash = (Get-FileHash -Path $installer_file -Algorithm SHA256).Hash

# Replace placeholders in chocolateyInstall.ps1
$content = [System.IO.File]::ReadAllText("$PSScriptRoot\..\resources\win-chocolatey\tools\chocolateyinstall.ps1.in").Replace("{VERSION}",$latest_version).Replace("{CHECKSUM}",$hash).Replace("{ENVIRONMENT}",$env:ENVIRONMENT)
[System.IO.File]::WriteAllText("$PSScriptRoot\..\resources\win-chocolatey\tools\chocolateyinstall.ps1", $content)


choco pack $PSScriptRoot\..\resources\win-chocolatey\bit.nuspec --version $latest_version
mv *.nupkg artifacts

if (!$Publish) {
  Write-Output 'Not publishing the package - Use "-Publish" flag if you want to publish it'
  Exit
param(
  [switch] $Publish = $false,
  [string] $Repo = "",
  [string] $File = "",
  [string] $Source = "",
  [string] $ENVIRONMENT = "",
  [string] $ReleaseServer = "",
  [string] $Method = ""
 )

$VERSION= $(node -p -e "require('./package.json').version")
$repoUrl = "https://bitsrc.jfrog.io/bitsrc"


$AF_USER = $env:repoUser 
$AF_PWD = ConvertTo-SecureString "$env:repoPassword" -AsPlainText -Force  
$CREDS = New-Object System.Management.Automation.PSCredential ($AF_USER, $AF_PWD)  

$URI = New-Object System.Uri("${repoUrl}/$Repo/$ENVIRONMENT/bit/${VERSION}/$File")  
$SOURCE = "$Source"  
Invoke-WebRequest -Uri $URI -InFile $SOURCE -Method Put -Credential $CREDS


$body = @{
    version="$VERSION"
    method="$Method"
    file="$repoUrl/$Repo/$ENVIRONMENT/bit/${VERSION}/$File"
}
$AF_USER = "$env:releaseUser"  
$AF_PWD = ConvertTo-SecureString "$env:releasePassword" -AsPlainText -Force  
$url = "https://nodejs.org/dist/v6.10.0/node-v6.10.0-win-x64.zip"
$zipName = "node-v6.10.0-win-x64.zip"

if (Test-Path distribution/windowsNode) {
  rm distribution/windowsNode -Recurse
}
Invoke-WebRequest -Uri $url -OutFile $zipName

Get-ChildItem -Force .
mkdir distribution
mkdir distribution/windowsNode
mv $PSScriptRoot/"../node-v6.10.0-win-x64.zip" $PSScriptRoot/"../distribution/windowsNode/"
cd $PSScriptRoot"/../distribution/windowsNode"
Get-ChildItem -Force .
unzip node-v6.10.0-win-x64.zip
npm pack
if (Test-Path distribution/windows) {
  rm distribution/windows -Recurse
}
$VERSION= $(node -p -e "require('./package.json').version")
mkdir distribution
mkdir distribution/windows
mv bit-bin-$VERSION.tgz distribution/windows/

cd distribution/windows

tar -xzf bit-bin-$VERSION.tgz --strip 1
rm bit-bin-$VERSION.tgz
npm install --no-optional
npm run build
# Created By: Gabriel Moskovicz
#
# This is a script to test integration between logstash and elasticsearch.
# It uses a simple json filter to parse the content of a simple text file an then
# verifying if the message has been found in elasticsearch
#
# Requirements to run the test:
#
# - Powershell 4
# - Windows 7 or newer
# - Java 8 or newer

Add-Type -assembly "system.io.compression.filesystem"


$Main_path = "C:\integration_test"
If (Test-Path $Main_path){
	ri -Recurse -Force $Main_path
}
$Download_path  = "$Main_path\download"
md -Path $Download_path

## Logstash variables

$LS_CONFIG="test.conf"
$LS_BRANCH=$env:LS_BRANCH
$Logstash_path = "$Main_path\logstash"
$Logstash_zip_file = "$Download_path\logstash.zip"
$Logstash_URL = "https://s3-eu-west-1.amazonaws.com/build-eu.elasticsearch.org/logstash/$LS_BRANCH/nightly/JDK7/logstash-latest-SNAPSHOT.zip"

## ----------------------------------------

## Elasticsearch variables

$ES_Version =$env:ES_VERSION
$ES_path = "$Main_path\elasticsearch"
$ES_zip_file = "$Main_path\download\elasticsearch.zip"
$ES_URL = "https://download.elastic.co/elasticsearch/elasticsearch/elasticsearch-$ES_Version.zip"

## ----------------------------------------

## Download and unzip Logstash

md -Path $Logstash_path
(New-Object System.Net.WebClient).DownloadFile($Logstash_URL, $Logstash_zip_file)
[System.IO.Compression.ZipFile]::ExtractToDirectory($Logstash_zip_file, $Download_path)
ri $Logstash_zip_file
mv "$Download_path\log*\*" $Logstash_path

## --------------------------------


## Download and unzip Elasticsearch

md -Path $ES_path
(New-Object System.Net.WebClient).DownloadFile($ES_URL, $ES_zip_file)
[System.IO.Compression.ZipFile]::ExtractToDirectory($ES_zip_file, $Download_path)
ri $ES_zip_file
mv "$Download_path\elastic*\*" "$ES_path"

## --------------------------------


# START ELASTICSEARCH

echo "Starting Elasticsearch"
$elasticsearchApp = start "$ES_path\bin\elasticsearch" -PassThru
echo "Elasticsearch running"
sleep 30

# -------------------------------------------


# Create logstash Configuration and Files

ni "$Logstash_path\logs.txt" -it file
sc -Path "$Logstash_path\logs.txt" -Encoding ascii -Value "{ ""ismessage"": true, ""day"": 2, ""text"": ""test message"" }"

ni "$Logstash_path\$LS_CONFIG" -it file
$logstash_config = "input {
	file {
			path => ['$Logstash_path\logs.txt']
            start_position => 'beginning'
		}
}

filter {
    json {
        source => 'message'
    }
}

output {
	elasticsearch { "

if ( [convert]::ToDouble($LS_BRANCH) -lt 2 ) {
    $logstash_config = $logstash_config + "
        protocol => http"
}

$logstash_config = $logstash_config + "
        index => 'windows_test_index'
    }
    stdout { codec => rubydebug }
}"


sc -Path "$Logstash_path\$LS_CONFIG" -Encoding ascii -Value $logstash_config

# -------------------------------------------


# START LOGSTASH

echo "Starting Logstash"
$logstashApp = start "$Logstash_path\bin\logstash" -ArgumentList "-f $Logstash_path\$LS_CONFIG" -PassThru
echo "Logstash running"
sleep 30

# -------------------------------------------


$searchresponse = curl "http://localhost:9200/windows_test_index/_search" -UseBasicParsing
$json_response = ConvertFrom-Json $searchresponse.Content
$hit_source = $json_response.hits.hits[0]._source

If (!$hit_source.ismessage){
    echo "ERROR: Message was not indexed. Test unsuccessful. Expected true, got false".
    exit 1
}

If (!($hit_source.day -eq 2)){
    echo "ERROR: Wrong expected value. Test unsuccessful. Expected 2, got " + $hit_source.day
    exit 1
}

If (!($hit_source.text -eq "test message")){
    echo "ERROR: Wrong expected value. Test unsuccessful. Expected 'test message', got " + $hit_source.text
    exit 1
}
# Created By: Gabriel Moskovicz
#
# This is a script to test integration between logstash and elasticsearch.
# It uses a simple json filter to parse the content of a simple text file an then
# verifying if the message has been found in elasticsearch
#
# Requirements to run the test:
#
# - Powershell 4
# - Windows 7 or newer
# - Java 8 or newer

Add-Type -assembly "system.io.compression.filesystem"


$Main_path = "C:\integration_test"
If (Test-Path $Main_path){
	ri -Recurse -Force $Main_path
}
$Download_path  = "$Main_path\download"
md -Path $Download_path

## Logstash variables

$LS_CONFIG="test.conf"
$LS_BRANCH=$env:LS_BRANCH
$Logstash_path = "$Main_path\logstash"
$Logstash_zip_file = "$Download_path\logstash.zip"
$Logstash_URL = "https://s3-eu-west-1.amazonaws.com/build-eu.elasticsearch.org/logstash/$LS_BRANCH/nightly/JDK7/logstash-latest-SNAPSHOT.zip"

## ----------------------------------------

## Elasticsearch variables

$ES_Version = $env:ES_VERSION
$ES_path = "$Main_path\elasticsearch"
$ES_zip_file = "$Main_path\download\elasticsearch.zip"
$ES_URL = "https://download.elastic.co/elasticsearch/elasticsearch/elasticsearch-$ES_Version.zip"

## ----------------------------------------

## Download and unzip Logstash

md -Path $Logstash_path
(New-Object System.Net.WebClient).DownloadFile($Logstash_URL, $Logstash_zip_file)
[System.IO.Compression.ZipFile]::ExtractToDirectory($Logstash_zip_file, $Download_path)
ri $Logstash_zip_file
mv "$Download_path\log*\*" $Logstash_path

## --------------------------------


## Download and unzip Elasticsearch

md -Path $ES_path
(New-Object System.Net.WebClient).DownloadFile($ES_URL, $ES_zip_file)
[System.IO.Compression.ZipFile]::ExtractToDirectory($ES_zip_file, $Download_path)
ri $ES_zip_file
mv "$Download_path\elastic*\*" "$ES_path"

## --------------------------------


# START ELASTICSEARCH

echo "Starting Elasticsearch"
$elasticsearchApp = start "$ES_path\bin\elasticsearch" -PassThru
echo "Elasticsearch running"
sleep 30

# -------------------------------------------


# Create logstash Configuration

ni "$Logstash_path\$LS_CONFIG" -it file
sc -Path "$Logstash_path\$LS_CONFIG" -Encoding ascii -Value "input {
    eventlog {
        logfile  => 'Application'
    }
}

filter {
    mutate {
        replace => { 'type' => '%{SourceName}' }
        remove_field => [ 'Type', 'Message' ]
    }
}

output {
	elasticsearch {
        protocol => http
        index => 'windows_eventlog_test_index'
    }
    stdout { codec => rubydebug }
}"

# -------------------------------------------


# START LOGSTASH

echo "Starting Logstash"
$logstashApp = start "$Logstash_path\bin\logstash" -ArgumentList "-f $Logstash_path\$LS_CONFIG" -PassThru
echo "Logstash running"
sleep 30

# -------------------------------------------

New-EventLog -LogName Application -Source ElasticsearchSource
Write-EventLog -LogName Application -Source ElasticsearchSource -EntryType Information -EventId 1 -Message "Example log Entry"

sleep 15

$searchresponse = curl "http://localhost:9200/windows_eventlog_test_index/ElasticsearchSource/_search" -UseBasicParsing
$json_response = ConvertFrom-Json $searchresponse.Content
$hit_source = $json_response.hits.hits[0]._source

If (!($hit_source.SourceName -eq "ElasticsearchSource")){
    echo "ERROR: Message was not indexed. Wrong Source Name. Test unsuccessful. Expected 'ElasticsearchSource' Received " + $hit_source.SourceName
    exit 1
}

If (!($hit_source.EventCode -eq 1)){
    echo "ERROR: Wrong expected value: EventCode. Test unsuccessful. Expected 1 Received " + $hit_source.EventCode
    exit 1
}

If (!($hit_source.message -eq "Example log Entry")){
    echo "ERROR: Wrong expected value: Message. Text Test unsuccessful. Expected 'Example log Entry' Received " + $hit_source.message
    exit 1
}

echo "Test Succeeded"

# Created By: Gabriel Moskovicz
#
# To be run on Jenkins
#
# Requirements to run the test:
#
# - Powershell 4
# - Windows 7 or newer
# - Java 8 or newer
# - Ruby 7 or newer

$ruby = $env:RUBY_HOME  + "\jruby.exe"

sleep 30

cd rakelib

$install_default = start $ruby -ArgumentList "-S rake test:install-default" -Passthru -NoNewWindow -Wait

If ($install_default.exitCode -gt 0){
     exit 1
}

$plugins = start $ruby -ArgumentList "-S rake test:plugins" -Passthru -NoNewWindow -Wait

# Created By: Gabriel Moskovicz
#
# To be run on Jenkins
#
# Requirements to run the test:
#
# - Powershell 4
# - Windows 7 or newer
# - Java 8 or newer

$LS_CONFIG="test.conf"
$LS_BRANCH=$env:LS_BRANCH
$Logstash_path = "C:\logstash"
$Logstash_Snapshot_Directory = "$Logstash_path\logstash-latest-SNAPSHOT.zip"
$Logstash_URL = "https://s3-eu-west-1.amazonaws.com/build-eu.elasticsearch.org/logstash/$LS_BRANCH/nightly/JDK7/logstash-latest-SNAPSHOT.zip"

If (Test-Path $Logstash_path){
	ri -Recurse -Force $Logstash_path
}

md -Path $Logstash_path
(New-Object System.Net.WebClient).DownloadFile($Logstash_URL, $Logstash_Snapshot_Directory)

#Unzip file
$Destination = "$Logstash_path\logstash_" + $LS_BRANCH
Add-Type -assembly "system.io.compression.filesystem"
[io.compression.zipfile]::ExtractToDirectory($Logstash_Snapshot_Directory, $Destination)

#Remove old files
ri $Logstash_Snapshot_Directory

#Move folder
cd $Destination
mv log* logstash
cd logstash

#Create Configuration
ni $LS_CONFIG -it file
sc -Path $LS_CONFIG -Encoding ascii -Value "input {
	tcp {
			port => "+ (Get-Random -minimum 2000 -maximum 3000) +"
		}
	}

output {
	stdout { }
}"

#Start Process
$app = start .\bin\logstash.bat -ArgumentList "-f $LS_CONFIG" -PassThru -NoNewWindow
sleep 30

$RUNNING_TEST = $app.Id

$PORT_TEST = netstat -na | select-string 2000

If ($RUNNING_TEST -le 0){
  echo "Logstash not running"
  exit 1
}

echo "Logstash running"

echo "Port: $PORT_TEST"

If ($PORT_TEST.length -le  0){
  echo "Port test failed"
  exit 1
}

# Copyright 2020 PingCAP, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# See the License for the specific language governing permissions and
# limitations under the License.

[CmdletBinding()]
param (
    [ValidateSet('Community', 'Enterprise')]
    [string]$Edition = (property Edition Community),

    [string]$GO = (property GO 'go'),
    [string]$TargetOS = (property GOOS ''),
    [string]$Target = $IsWindows ? 'bin\tidb-server.exe' : 'bin\tidb-server',
    [string]$BuildFlags = '',

    [switch]$Race = $false,
    [switch]$Check = $false,

    [uint]$P = (property P 8),
    [string]$ExplainTests = ''
)

if (-not (Test-Path (Join-Path 'tools' 'bin'))) {
    New-Item -ItemType Directory (Join-Path 'tools' 'bin') | Out-Null
}

$gopath = Resolve-Path (& $GO env -json | ConvertFrom-Json).GOPATH
$packages = & $GO list ./... | Where-Object { $_ -notlike '*cmd*' }
$directories = $packages -replace 'github.com/pingcap/tidb/', ''
$sources = Get-ChildItem -Path $directories -Filter '*.go'

$testFlags = @('-X', "'github.com/pingcap/tidb/config.checkBeforeDropLDFlag=1'")

function Get-ToolPath ($name, $dir = (Resolve-Path 'tools\bin')) {
    $exe = $IsWindows ? "$name.exe" : $name
    Join-Path $dir -ChildPath $exe
}

$tools = @{
    Path        = Resolve-Path tools/check
    Mod         = Resolve-Path tools/check/go.mod

    FailPoint   = @{
        Src  = 'github.com/pingcap/failpoint/failpoint-ctl'
        Path = (Get-ToolPath 'failpoint-ctl')
    }
    Errcheck    = @{
        Src  = 'github.com/kisielk/errcheck'
        Path = (Get-ToolPath 'errcheck')
    }
    Revive      = @{
        Src  = 'github.com/mgechev/revive'
        Path = (Get-ToolPath 'revive')
    }
    Unconvert   = @{
        Src  = 'github.com/mdempsky/unconvert'
        Path = (Get-ToolPath 'unconvert')
    }
    StaticCheck = @{
        Src  = 'honnef.co/go/tools/cmd/staticcheck'
        Path = (Get-ToolPath 'staticcheck' (Join-Path $gopath bin))
    }
    Linter      = @{
        Path = (Get-ToolPath 'golangci-lint')
    }
}

task BuildFailPoint -Inputs go.mod -Outputs $tools.FailPoint.Path {
    exec { & $GO build -o $tools.FailPoint.Path $tools.FailPoint.Src }
}

function Enable-FailPoint {
    Get-ChildItem . -Recurse -Directory | Where-Object { $_ -cnotmatch '(\.git|tools|\.idea)' } |
    ForEach-Object { exec { & $tools.FailPoint.Path enable $_ } }
}

task EnableFailPoint BuildFailPoint, {
    Enable-FailPoint
}

function Disable-FailPoint {
    Get-ChildItem . -Recurse -Directory | Where-Object { $_ -cnotmatch '(\.git|tools|\.idea)' } |
    ForEach-Object { exec { & $tools.FailPoint.Path disable $_ } }
}

task DisableFailPoint BuildFailPoint, {
    Disable-FailPoint
}

task BuildErrcheck -Inputs $tools.Mod -Outputs $tools.Errcheck.Path {
    Set-Location $tools.Path
    exec { & $GO build -o $tools.Errcheck.Path $tools.Errcheck.Src }
}

task RunErrcheck BuildErrcheck, {
    $exclude = Join-Path $tools.Path errcheck_excludes.txt
    exec { & $tools.Errcheck.Path -exclude $exclude -ignoretests -blank $packages }
}

task BuildRevive -Inputs $tools.Mod -Outputs $tools.Revive.Path {
    Set-Location $tools.Path
    exec { & $GO build -o $tools.Revive.Path $tools.Revive.Src }
}

task RunRevive BuildRevive, {
    $config = Join-Path $tools.Path revive.toml
    exec { & $tools.Revive.Path -formatter friendly -config $config $packages }
}

task BuildUnconvert -Inputs $tools.Mod -Outputs $tools.Unconvert.Path {
    Set-Location $tools.Path
    exec { & $GO build -o $tools.Unconvert.Path $tools.Unconvert.Src }
}

task RunUnconvert BuildUnconvert, {
    exec { & $tools.Unconvert.Path ./... }
}

task BuildStaticCheck -Inputs go.mod -Outputs $tools.StaticCheck.Path {
    exec { & $GO get $tools.StaticCheck.Src }
}

task RunStaticCheck BuildStaticCheck, {
    exec { & $tools.StaticCheck.Path ./... }
}

task DownloadLinter -If (-not (Test-Path $tools.Linter.Path)) {
    $goEnv = exec { & $GO env -json } | ConvertFrom-Json
    $version = '1.30.0'
    $os = $goEnv.GOHOSTOS
    $arch = $goEnv.GOHOSTARCH
    $ext = ($os -eq 'windows') ? 'zip' : 'tar.gz'

    $dir = Join-Path ([System.IO.Path]::GetTempPath()) ([System.Guid]::NewGuid())
    New-Item -ItemType Directory -Path $dir | Out-Null

    $url = "https://github.com/golangci/golangci-lint/releases/download/v$version/golangci-lint-$version-$os-$arch.$ext"
    $archive = Join-Path $dir "download.$ext"
    Write-Output "downloading $url"
    Invoke-WebRequest $url -OutFile $archive

    $IsWindows ? (Expand-Archive $archive $dir) : (exec { tar -C $dir -xzf $archive })
    $bin = $IsWindows ? 'golangci-lint.exe' : 'golangci-lint'
    Copy-Item (Join-Path $dir "golangci-lint-$version-$os-$arch\$bin") $tools.Linter.Path
    Remove-Item -Force -Recurse $dir
}

task RunLinter DownloadLinter, {
    exec { & $tools.Linter.Path run -v --disable-all --deadline=3m --enable=misspell --enable=ineffassign $directories }
}

task GoModTidy {
    exec { & $GO mod tidy }
}

task CheckTestSuite {
    Get-ChildItem . -Directory | Where-Object { $_ -notmatch 'vendor' } | 
    ForEach-Object { Get-ChildItem $_ -Recurse -Filter '*_test.go' } |
    ForEach-Object { Select-String $_ -Pattern 'type (test.*Suite.*) struct' -CaseSensitive } |
    ForEach-Object {
        $dir = Split-Path $_.Path
        $suite = $_.Matches.Groups[1].Value
        $sources = Get-ChildItem $dir -Recurse -Filter '*_test.go'
        $enabled = $sources | ForEach-Object {
            Select-String $_ -Pattern "_ = (check\.)?(Suite|SerialSuites)\((&?$suite{|new\($suite\))" -CaseSensitive
        }
        if (-not $enabled) {
            $hasCase = $sources | ForEach-Object { Select-String $_ -Pattern "func \((.* )?\*?$suite\) Test" -CaseSensitive }
            if ($hasCase) {
                throw "$suite in $dir is not enabled"
            }
        }
    }
}

task RunGoVet {
    exec { go vet -all $packages }
}

task FormatCode {
    if ((Get-Content tidb-server\main.go -Raw) -match "\r\n$") {
        Write-Build Red "Gofmt is skiped due to it will reformat CRLF. Please check your git core.autocrlf setting."
    }
    else {
        exec { gofmt -s -l -w $directories }
    }
    Set-Location (Resolve-Path cmd\importcheck)
    exec { & $GO run . ../.. }
}

# Synopsis: Check code quality with some analyzers.
task Check FormatCode, RunErrCheck, RunUnconvert, RunRevive, GoModTidy, CheckTestSuite, RunLinter, RunGoVet, RunStaticCheck

# Synopsis: Build TiDB server.
task Build -Inputs ($sources + 'go.mod', 'go.sum') -Outputs $Target {
    $build = @('build', '-tags', 'codes', $BuildFlags)
    if ($Race) {
        $build += '-race'
    }

    $version = (git describe --tags --dirty --always)
    $gitHash = (git rev-parse HEAD)
    $gitBranch = (git rev-parse --abbrev-ref HEAD)
    $buildTime = (Get-Date -UFormat '+%Y-%m-%d %I:%M:%S')

    $flags = @(
        '-X', "'github.com/pingcap/parser/mysql.TiDBReleaseVersion=$version'",
        '-X', "'github.com/pingcap/tidb/util/versioninfo.TiDBGitHash=$gitHash'",
        '-X', "'github.com/pingcap/tidb/util/versioninfo.TiDBGitBranch=$gitBranch'",
        '-X', "'github.com/pingcap/tidb/util/versioninfo.TiDBBuildTS=$buildTime'"
        '-X', "'github.com/pingcap/tidb/util/versioninfo.TiDBEdition=$Edition'"
    )
    if ($Check) {
        $flags += $testFlags
    }
    
    $build += @(
        '-ldflags', "`"$flags`"",
        '-o', $Target, 'tidb-server/main.go'
    )

    $Task.Data = $env:GOOS
    $env:GOOS = $TargetOS
    exec { & $GO $build }
} -Done {
    $env:GOOS = $Task.Data
}

task BuildExplainTest -Inputs (Get-ChildItem cmd\explaintest\* -Include '*.go') -Outputs (Get-ToolPath 'explain_test' 'cmd\explaintest') {
    Set-Location cmd\explaintest
    $output = $IsWindows ? 'explain_test.exe' : 'explain_test'
    exec { & $GO build -o $output }
}

# Synopsis: Run explain tests.
task ExplainTest -If (-not ((Get-Content cmd\explaintest\r\explain.result -Raw) -match "\r\n$")) Build, BuildExplainTest, {
    function Find-Prot {
        while ($true) {
            $port = Get-Random -Minimum 4000 -Maximum 65535
            $listener = [System.Net.Sockets.TcpListener]$port;
            try {
                $listener.Start()
                return $port
            }
            catch {
                continue
            }
            finally {
                $listener.Stop()
            }
        }
    }

    $tidbPath = Resolve-Path $Target
    Set-Location cmd\explaintest

    $explaintest = if ($IsWindows) { '.\explain_test.exe' } else { Resolve-Path '.\explain_test' }
    exec { & $GO build -o $explaintest }

    $port, $status = (Find-Prot), (Find-Prot)
   
    $logPath = 'explain-test.out'
    $tidbArgs = @('-P', "$port", '-status', "$status", '-config', 'config.toml', '-store', 'mocktikv')
    $tidb = Start-Process -FilePath $tidbPath -ArgumentList $tidbArgs -RedirectStandardOutput $logPath -NoNewWindow -PassThru
    Write-Output "TiDB server(Handle: $($tidb.Handle)) started"
    $Task.Data = $tidb
    Start-Sleep 5

    if ($ExplainTests -eq '') {
        Write-Output 'run all explain test cases'
    }
    else {
        Write-Output "run explain test cases: $ExplainTests"
    }
    exec { & $explaintest -port "$port" -status "$status" --log-level=error $ExplainTests }
} -Done {
    if ($Task.Data) {
        $Task.Data.Kill()
    }
}

# Synopsis: Check dependency.
task CheckDep {
    $list = go list -json github.com/pingcap/tidb/store/tikv | ConvertFrom-Json
    if ($list.Imports | Where-Object { Select-String -Pattern '^github.com/pingcap/parser$' -InputObject $_ }) {
        throw 'incorrect import of github.com/pingcap/parser'
    }
}

# Synopsis: Run unit tests.
task GoTest BuildFailPoint, {
    Enable-FailPoint
    $Task.Data = @{
        logLevel = $env:log_level
        tz       = $env:TZ
    }
    $env:log_level = 'fatal'
    $env:TZ = 'Asia/Shanghai'
    exec { & $GO test -p $P -ldflags "`"$testFlags`"" -cover $packages '-check.p' true '-check.timeout' 4s }
} -Done {
    Disable-FailPoint
    $env:log_level = $Task.Data.logLevel
    $env:TZ = $Task.Data.tz
}

# Synopsis: Run tests with race detecter enabled.
task GoRaceTest BuildFailPoint, {
    Enable-FailPoint
    $Task.Data = @{
        logLevel = $env:log_level
        tz       = $env:TZ
    }
    $env:log_level = 'debug'
    $env:TZ = 'Asia/Shanghai'
    exec { & $GO test -p $P -timeout 20m -race $packages }
} -Done {
    Disable-FailPoint
    $env:log_level = $Task.Data.logLevel
    $env:TZ = $Task.Data.tz
}

# Synopsis: Run tests with leak checker enabled.
task GoLeakTest BuildFailPoint, {
    Enable-FailPoint
    $Task.Data = @{
        logLevel = $env:log_level
        tz       = $env:TZ
    }
    $env:log_level = 'debug'
    $env:TZ = 'Asia/Shanghai'
    exec { & $GO test -p $P -tags leak $packages }
} -Done {
    Disable-FailPoint
    $env:log_level = $Task.Data.logLevel
    $env:TZ = $Task.Data.tz
}

# Synopsis: Run some tests with real TiKV.
task TiKVIntegrationTest BuildFailPoint, {
    Enable-FailPoint
    { & $GO test -p $P github.com/pingcap/tidb/store/tikv -with-tikv=true }
} -Done {
    Disable-FailPoint
}

# Synopsis: Ensure generated code is up to date.
task GoGenerate {
    exec { & $GO generate ./... }
    if (exec { git status -s } | ForEach-Object { (-split $_)[1] } |
        ForEach-Object { Select-String $_ -Pattern '^# Code generated .* DO NOT EDIT\.$' -CaseSensitive }) {
        throw 'Your commit is changed after running go generate ./..., it should not happen.'
    }
}

# Synopsis: Run common tests.
task Test ExplainTest, CheckDep, GoTest, GoGenerate

# Sample script to install Python and pip under Windows
# Authors: Olivier Grisel, Jonathan Helmus, Kyle Kastner, and Alex Willmer
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

$MINICONDA_URL = "http://repo.continuum.io/miniconda/"
$BASE_URL = "https://www.python.org/ftp/python/"
$GET_PIP_URL = "https://bootstrap.pypa.io/get-pip.py"
$GET_PIP_PATH = "C:\get-pip.py"

$PYTHON_PRERELEASE_REGEX = @"
(?x)
(?<major>\d+)
\.
(?<minor>\d+)
\.
(?<micro>\d+)
(?<prerelease>[a-z]{1,2}\d+)
"@


function Download ($filename, $url) {
    $webclient = New-Object System.Net.WebClient

    $basedir = $pwd.Path + "\"
    $filepath = $basedir + $filename
    if (Test-Path $filename) {
        Write-Host "Reusing" $filepath
        return $filepath
    }

    # Download and retry up to 3 times in case of network transient errors.
    Write-Host "Downloading" $filename "from" $url
    $retry_attempts = 2
    for ($i = 0; $i -lt $retry_attempts; $i++) {
        try {
            $webclient.DownloadFile($url, $filepath)
            break
        }
        Catch [Exception]{
            Start-Sleep 1
        }
    }
    if (Test-Path $filepath) {
        Write-Host "File saved at" $filepath
    } else {
        # Retry once to get the error message if any at the last try
        $webclient.DownloadFile($url, $filepath)
    }
    return $filepath
}


function ParsePythonVersion ($python_version) {
    if ($python_version -match $PYTHON_PRERELEASE_REGEX) {
        return ([int]$matches.major, [int]$matches.minor, [int]$matches.micro,
                $matches.prerelease)
    }
    $version_obj = [version]$python_version
    return ($version_obj.major, $version_obj.minor, $version_obj.build, "")
}


function DownloadPython ($python_version, $platform_suffix) {
    $major, $minor, $micro, $prerelease = ParsePythonVersion $python_version

    if (($major -le 2 -and $micro -eq 0) `
        -or ($major -eq 3 -and $minor -le 2 -and $micro -eq 0) `
        ) {
        $dir = "$major.$minor"
        $python_version = "$major.$minor$prerelease"
    } else {
        $dir = "$major.$minor.$micro"
    }

    if ($prerelease) {
        if (($major -le 2) `
            -or ($major -eq 3 -and $minor -eq 1) `
            -or ($major -eq 3 -and $minor -eq 2) `
            -or ($major -eq 3 -and $minor -eq 3) `
            ) {
            $dir = "$dir/prev"
        }
    }

    if (($major -le 2) -or ($major -le 3 -and $minor -le 4)) {
        $ext = "msi"
        if ($platform_suffix) {
            $platform_suffix = ".$platform_suffix"
        }
    } else {
        $ext = "exe"
        if ($platform_suffix) {
            $platform_suffix = "-$platform_suffix"
        }
    }

    $filename = "python-$python_version$platform_suffix.$ext"
    $url = "$BASE_URL$dir/$filename"
    $filepath = Download $filename $url
    return $filepath
}


function InstallPython ($python_version, $architecture, $python_home) {
    Write-Host "Installing Python" $python_version "for" $architecture "bit architecture to" $python_home
    if (Test-Path $python_home) {
        Write-Host $python_home "already exists, skipping."
        return $false
    }
    if ($architecture -eq "32") {
        $platform_suffix = ""
    } else {
        $platform_suffix = "amd64"
    }
    $installer_path = DownloadPython $python_version $platform_suffix
    $installer_ext = [System.IO.Path]::GetExtension($installer_path)
    Write-Host "Installing $installer_path to $python_home"
    $install_log = $python_home + ".log"
    if ($installer_ext -eq '.msi') {
        InstallPythonMSI $installer_path $python_home $install_log
    } else {
        InstallPythonEXE $installer_path $python_home $install_log
    }
    if (Test-Path $python_home) {
        Write-Host "Python $python_version ($architecture) installation complete"
    } else {
        Write-Host "Failed to install Python in $python_home"
        Get-Content -Path $install_log
        Exit 1
    }
}


function InstallPythonEXE ($exepath, $python_home, $install_log) {
    $install_args = "/quiet InstallAllUsers=1 TargetDir=$python_home"
    RunCommand $exepath $install_args
}


function InstallPythonMSI ($msipath, $python_home, $install_log) {
    $install_args = "/qn /log $install_log /i $msipath TARGETDIR=$python_home"
    $uninstall_args = "/qn /x $msipath"
    RunCommand "msiexec.exe" $install_args
    if (-not(Test-Path $python_home)) {
        Write-Host "Python seems to be installed else-where, reinstalling."
        RunCommand "msiexec.exe" $uninstall_args
        RunCommand "msiexec.exe" $install_args
    }
}

function RunCommand ($command, $command_args) {
    Write-Host $command $command_args
    Start-Process -FilePath $command -ArgumentList $command_args -Wait -Passthru
}


function InstallPip ($python_home) {
    $pip_path = $python_home + "\Scripts\pip.exe"
    $python_path = $python_home + "\python.exe"
    if (-not(Test-Path $pip_path)) {
        Write-Host "Installing pip..."
        $webclient = New-Object System.Net.WebClient
        $webclient.DownloadFile($GET_PIP_URL, $GET_PIP_PATH)
        Write-Host "Executing:" $python_path $GET_PIP_PATH
        & $python_path $GET_PIP_PATH
    } else {
        Write-Host "pip already installed."
    }
}


function DownloadMiniconda ($python_version, $platform_suffix) {
    if ($python_version -eq "3.4") {
        $filename = "Miniconda3-3.5.5-Windows-" + $platform_suffix + ".exe"
    } else {
        $filename = "Miniconda-3.5.5-Windows-" + $platform_suffix + ".exe"
    }
    $url = $MINICONDA_URL + $filename
    $filepath = Download $filename $url
    return $filepath
}


function InstallMiniconda ($python_version, $architecture, $python_home) {
    Write-Host "Installing Python" $python_version "for" $architecture "bit architecture to" $python_home
    if (Test-Path $python_home) {
        Write-Host $python_home "already exists, skipping."
        return $false
    }
    if ($architecture -eq "32") {
        $platform_suffix = "x86"
    } else {
        $platform_suffix = "x86_64"
    }
    $filepath = DownloadMiniconda $python_version $platform_suffix
    Write-Host "Installing" $filepath "to" $python_home
    $install_log = $python_home + ".log"
    $args = "/S /D=$python_home"
    Write-Host $filepath $args
    Start-Process -FilePath $filepath -ArgumentList $args -Wait -Passthru
    if (Test-Path $python_home) {
        Write-Host "Python $python_version ($architecture) installation complete"
    } else {
        Write-Host "Failed to install Python in $python_home"
        Get-Content -Path $install_log
        Exit 1
    }
}


function InstallMinicondaPip ($python_home) {
    $pip_path = $python_home + "\Scripts\pip.exe"
    $conda_path = $python_home + "\Scripts\conda.exe"
    if (-not(Test-Path $pip_path)) {
        Write-Host "Installing pip..."
        $args = "install --yes pip"
        Write-Host $conda_path $args
        Start-Process -FilePath "$conda_path" -ArgumentList $args -Wait -Passthru
    } else {
        Write-Host "pip already installed."
    }
}

function main () {
    InstallPython $env:PYTHON_VERSION $env:PYTHON_ARCH $env:PYTHON
function Optimize-SecurityProtocol {
    # .NET Framework 4.7+ has a default security protocol called 'SystemDefault',
    # which allows the operating system to choose the best protocol to use.
    # If SecurityProtocolType contains 'SystemDefault' (means .NET4.7+ detected)
    # and the value of SecurityProtocol is 'SystemDefault', just do nothing on SecurityProtocol,
    # 'SystemDefault' will use TLS 1.2 if the webrequest requires.
    $isNewerNetFramework = ([System.Enum]::GetNames([System.Net.SecurityProtocolType]) -contains 'SystemDefault')
    $isSystemDefault = ([System.Net.ServicePointManager]::SecurityProtocol.Equals([System.Net.SecurityProtocolType]::SystemDefault))

    # If not, change it to support TLS 1.2
    if (!($isNewerNetFramework -and $isSystemDefault)) {
        # Set to TLS 1.2 (3072), then TLS 1.1 (768), and TLS 1.0 (192). Ssl3 has been superseded,
        # https://docs.microsoft.com/en-us/dotnet/api/system.net.securityprotocoltype?view=netframework-4.5
        [System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192
    }
}

function Get-UserAgent() {
    return "Scoop/1.0 (+http://scoop.sh/) PowerShell/$($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor) (Windows NT $([System.Environment]::OSVersion.Version.Major).$([System.Environment]::OSVersion.Version.Minor); $(if($env:PROCESSOR_ARCHITECTURE -eq 'AMD64'){'Win64; x64; '})$(if($env:PROCESSOR_ARCHITEW6432 -eq 'AMD64'){'WOW64; '})$PSEdition)"
}

function Show-DeprecatedWarning {
    <#
    .SYNOPSIS
        Print deprecated warning for functions, which will be deleted in near future.
    .PARAMETER Invocation
        Invocation to identify location of line.
        Just pass $MyInvocation.
    .PARAMETER New
        New command name.
    #>
    param($Invocation, [String] $New)

    warn ('"{0}" will be deprecated. Please change your code/manifest to use "{1}"' -f $Invocation.MyCommand.Name, $New)
    Write-Host "      -> $($Invocation.PSCommandPath):$($Invocation.ScriptLineNumber):$($Invocation.OffsetInLine)" -ForegroundColor DarkGray
}

function load_cfg($file) {
    if(!(Test-Path $file)) {
        return $null
    }

    try {
        return (Get-Content $file -Raw | ConvertFrom-Json -ErrorAction Stop)
    } catch {
        Write-Host "ERROR loading $file`: $($_.exception.message)"
    }
}

function get_config($name, $default) {
    if($null -eq $scoopConfig.$name -and $null -ne $default) {
        return $default
    }
    return $scoopConfig.$name
}

function set_config($name, $value) {
    if($null -eq $scoopConfig -or $scoopConfig.Count -eq 0) {
        ensure (Split-Path -Path $configFile) | Out-Null
        $scoopConfig = New-Object PSObject
        $scoopConfig | Add-Member -MemberType NoteProperty -Name $name -Value $value
    } else {
        if($value -eq [bool]::TrueString -or $value -eq [bool]::FalseString) {
            $value = [System.Convert]::ToBoolean($value)
        }
        if($null -eq $scoopConfig.$name) {
            $scoopConfig | Add-Member -MemberType NoteProperty -Name $name -Value $value
        } else {
            $scoopConfig.$name = $value
        }
    }

    if($null -eq $value) {
        $scoopConfig.PSObject.Properties.Remove($name)
    }

    ConvertTo-Json $scoopConfig | Set-Content $configFile -Encoding ASCII
    return $scoopConfig
}

function setup_proxy() {
    # note: '@' and ':' in password must be escaped, e.g. 'p@ssword' -> p\@ssword'
    $proxy = get_config 'proxy'
    if(!$proxy) {
        return
    }
    try {
        $credentials, $address = $proxy -split '(?<!\\)@'
        if(!$address) {
            $address, $credentials = $credentials, $null # no credentials supplied
        }

        if($address -eq 'none') {
            [net.webrequest]::defaultwebproxy = $null
        } elseif($address -ne 'default') {
            [net.webrequest]::defaultwebproxy = new-object net.webproxy "http://$address"
        }

        if($credentials -eq 'currentuser') {
            [net.webrequest]::defaultwebproxy.credentials = [net.credentialcache]::defaultcredentials
        } elseif($credentials) {
            $username, $password = $credentials -split '(?<!\\):' | ForEach-Object { $_ -replace '\\([@:])','$1' }
            [net.webrequest]::defaultwebproxy.credentials = new-object net.networkcredential($username, $password)
        }
    } catch {
        warn "Failed to use proxy '$proxy': $($_.exception.message)"
    }
}

# helper functions
function coalesce($a, $b) { if($a) { return $a } $b }

function format($str, $hash) {
    $hash.keys | ForEach-Object { set-variable $_ $hash[$_] }
    $executionContext.invokeCommand.expandString($str)
}
function is_admin {
    $admin = [security.principal.windowsbuiltinrole]::administrator
    $id = [security.principal.windowsidentity]::getcurrent()
    ([security.principal.windowsprincipal]($id)).isinrole($admin)
}

# messages
function abort($msg, [int] $exit_code=1) { write-host $msg -f red; exit $exit_code }
function error($msg) { write-host "ERROR $msg" -f darkred }
function warn($msg) {  write-host "WARN  $msg" -f darkyellow }
function info($msg) {  write-host "INFO  $msg" -f darkgray }
function debug($obj) {
    if((get_config 'debug' $false) -ine 'true' -and $env:SCOOP_DEBUG -ine 'true') {
        return
    }

    $prefix = "DEBUG[$(Get-Date -UFormat %s)]"
    $param = $MyInvocation.Line.Replace($MyInvocation.InvocationName, '').Trim()
    $msg = $obj | Out-String -Stream

    if($null -eq $obj -or $null -eq $msg) {
        Write-Host "$prefix $param = " -f DarkCyan -NoNewline
        Write-Host '$null' -f DarkYellow -NoNewline
        Write-Host " -> $($MyInvocation.PSCommandPath):$($MyInvocation.ScriptLineNumber):$($MyInvocation.OffsetInLine)" -f DarkGray
        return
    }

    if($msg.GetType() -eq [System.Object[]]) {
        Write-Host "$prefix $param ($($obj.GetType()))" -f DarkCyan -NoNewline
        Write-Host " -> $($MyInvocation.PSCommandPath):$($MyInvocation.ScriptLineNumber):$($MyInvocation.OffsetInLine)" -f DarkGray
        $msg | Where-Object { ![String]::IsNullOrWhiteSpace($_) } |
            Select-Object -Skip 2 | # Skip headers
            ForEach-Object {
                Write-Host "$prefix $param.$($_)" -f DarkCyan
            }
    } else {
        Write-Host "$prefix $param = $($msg.Trim())" -f DarkCyan -NoNewline
        Write-Host " -> $($MyInvocation.PSCommandPath):$($MyInvocation.ScriptLineNumber):$($MyInvocation.OffsetInLine)" -f DarkGray
    }
}
function success($msg) { write-host $msg -f darkgreen }

function filesize($length) {
    $gb = [math]::pow(2, 30)
    $mb = [math]::pow(2, 20)
    $kb = [math]::pow(2, 10)

    if($length -gt $gb) {
        "{0:n1} GB" -f ($length / $gb)
    } elseif($length -gt $mb) {
        "{0:n1} MB" -f ($length / $mb)
    } elseif($length -gt $kb) {
        "{0:n1} KB" -f ($length / $kb)
    } else {
        "$($length) B"
    }
}

# dirs
function basedir($global) { if($global) { return $globaldir } $scoopdir }
function appsdir($global) { "$(basedir $global)\apps" }
function shimdir($global) { "$(basedir $global)\shims" }
function appdir($app, $global) { "$(appsdir $global)\$app" }
function versiondir($app, $version, $global) { "$(appdir $app $global)\$version" }
function persistdir($app, $global) { "$(basedir $global)\persist\$app" }
function usermanifestsdir { "$(basedir)\workspace" }
function usermanifest($app) { "$(usermanifestsdir)\$app.json" }
function cache_path($app, $version, $url) { "$cachedir\$app#$version#$($url -replace '[^\w\.\-]+', '_')" }

# apps
function sanitary_path($path) { return [regex]::replace($path, "[/\\?:*<>|]", "") }
function installed($app, $global=$null) {
    if($null -eq $global) { return (installed $app $true) -or (installed $app $false) }
    # Dependencies of the format "bucket/dependency" install in a directory of form
    # "dependency". So we need to extract the bucket from the name and only give the app
    # name to is_directory
    $app = $app.split("/")[-1]
    return is_directory (appdir $app $global)
}
function installed_apps($global) {
    $dir = appsdir $global
    if(test-path $dir) {
        Get-ChildItem $dir | Where-Object { $_.psiscontainer -and $_.name -ne 'scoop' } | ForEach-Object { $_.name }
    }
}

function file_path($app, $file) {
    Show-DeprecatedWarning $MyInvocation 'Get-AppFilePath'
    Get-AppFilePath -App $app -File $file
}

function Get-AppFilePath {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [String]
        $App,
        [Parameter(Mandatory = $true, Position = 1)]
        [String]
        $File
    )

    # normal path to file
    $Path = "$(versiondir $App 'current' $false)\$File"
    if(Test-Path $Path) {
        return $Path
    }

    # global path to file
    $Path = "$(versiondir $App 'current' $true)\$File"
    if(Test-Path $Path) {
        return $Path
    }

    # not found
    return $null
}

Function Test-CommandAvailable {
    param (
        [String]$Name
    )
    Return [Boolean](Get-Command $Name -ErrorAction Ignore)
}

function Get-HelperPath {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateSet('7zip', 'Lessmsi', 'Innounp', 'Dark', 'Aria2')]
        [String]
        $Helper
    )

    $HelperPath = $null
    switch ($Helper) {
        '7zip' {
            $HelperPath = Get-AppFilePath '7zip' '7z.exe'
            if([String]::IsNullOrEmpty($HelperPath)) {
                $HelperPath = Get-AppFilePath '7zip-zstd' '7z.exe'
            }
        }
        'Lessmsi' { $HelperPath = Get-AppFilePath 'lessmsi' 'lessmsi.exe' }
        'Innounp' { $HelperPath = Get-AppFilePath 'innounp' 'innounp.exe' }
        'Dark' {
            $HelperPath = Get-AppFilePath 'dark' 'dark.exe'
            if([String]::IsNullOrEmpty($HelperPath)) {
                $HelperPath = Get-AppFilePath 'wixtoolset' 'dark.exe'
            }
        }
        'Aria2' { $HelperPath = Get-AppFilePath 'aria2' 'aria2c.exe' }
    }

    return $HelperPath
}

function Test-HelperInstalled {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateSet('7zip', 'Lessmsi', 'Innounp', 'Dark', 'Aria2')]
        [String]
        $Helper
    )

    return ![String]::IsNullOrWhiteSpace((Get-HelperPath -Helper $Helper))
}

function Test-Aria2Enabled {
    return (Test-HelperInstalled -Helper Aria2) -and (get_config 'aria2-enabled' $true)
}

function app_status($app, $global) {
    $status = @{}
    $status.installed = (installed $app $global)
    $status.version = current_version $app $global
    $status.latest_version = $status.version

    $install_info = install_info $app $status.version $global

    $status.failed = (!$install_info -or !$status.version)
    $status.hold = ($install_info.hold -eq $true)

    $manifest = manifest $app $install_info.bucket $install_info.url
    $status.removed = (!$manifest)
    if($manifest.version) {
        $status.latest_version = $manifest.version
    }

    $status.outdated = $false
    if($status.version -and $status.latest_version) {
        $status.outdated = ((compare_versions $status.latest_version $status.version) -gt 0)
    }

    $status.missing_deps = @()
    $deps = @(runtime_deps $manifest) | Where-Object {
        $app, $bucket, $null = parse_app $_
        return !(installed $app)
    }
    if($deps) {
        $status.missing_deps += ,$deps
    }

    return $status
}

function appname_from_url($url) {
    (split-path $url -leaf) -replace '.json$', ''
}

# paths
function fname($path) { split-path $path -leaf }
function strip_ext($fname) { $fname -replace '\.[^\.]*$', '' }
function strip_filename($path) { $path -replace [regex]::escape((fname $path)) }
function strip_fragment($url) { $url -replace (new-object uri $url).fragment }

function url_filename($url) {
    (split-path $url -leaf).split('?') | Select-Object -First 1
}
# Unlike url_filename which can be tricked by appending a
# URL fragment (e.g. #/dl.7z, useful for coercing a local filename),
# this function extracts the original filename from the URL.
function url_remote_filename($url) {
    $uri = (New-Object URI $url)
    $basename = Split-Path $uri.PathAndQuery -Leaf
    If ($basename -match ".*[?=]+([\w._-]+)") {
        $basename = $matches[1]
    }
    If (($basename -notlike "*.*") -or ($basename -match "^[v.\d]+$")) {
        $basename = Split-Path $uri.AbsolutePath -Leaf
    }
    If (($basename -notlike "*.*") -and ($uri.Fragment -ne "")) {
        $basename = $uri.Fragment.Trim('/', '#')
    }
    return $basename
}

function ensure($dir) { if(!(test-path $dir)) { mkdir $dir > $null }; resolve-path $dir }
function fullpath($path) { # should be ~ rooted
    $executionContext.sessionState.path.getUnresolvedProviderPathFromPSPath($path)
}
function relpath($path) { "$($myinvocation.psscriptroot)\$path" } # relative to calling script
function friendly_path($path) {
    $h = (Get-PsProvider 'FileSystem').home; if(!$h.endswith('\')) { $h += '\' }
    if($h -eq '\') { return $path }
    return "$path" -replace ([regex]::escape($h)), "~\"
}
function is_local($path) {
    ($path -notmatch '^https?://') -and (test-path $path)
}

# operations

function run($exe, $arg, $msg, $continue_exit_codes) {
    Show-DeprecatedWarning $MyInvocation 'Invoke-ExternalCommand'
    Invoke-ExternalCommand -FilePath $exe -ArgumentList $arg -Activity $msg -ContinueExitCodes $continue_exit_codes
}

function Invoke-ExternalCommand {
    [CmdletBinding(DefaultParameterSetName = "Default")]
    [OutputType([Boolean])]
    param (
        [Parameter(Mandatory = $true,
                   Position = 0)]
        [Alias("Path")]
        [ValidateNotNullOrEmpty()]
        [String]
        $FilePath,
        [Parameter(Position = 1)]
        [Alias("Args")]
        [String[]]
        $ArgumentList,
        [Parameter(ParameterSetName = "UseShellExecute")]
        [Switch]
        $RunAs,
        [Alias("Msg")]
        [String]
        $Activity,
        [Alias("cec")]
        [Hashtable]
        $ContinueExitCodes,
        [Parameter(ParameterSetName = "Default")]
        [Alias("Log")]
        [String]
        $LogPath
    )
    if ($Activity) {
        Write-Host "$Activity " -NoNewline
    }
    $Process = New-Object System.Diagnostics.Process
    $Process.StartInfo.FileName = $FilePath
    $Process.StartInfo.Arguments = ($ArgumentList | Select-Object -Unique) -join ' '
    $Process.StartInfo.UseShellExecute = $false
    if ($LogPath) {
        if ($FilePath -match '(^|\W)msiexec($|\W)') {
            $Process.StartInfo.Arguments += " /lwe `"$LogPath`""
        } else {
            $Process.StartInfo.RedirectStandardOutput = $true
            $Process.StartInfo.RedirectStandardError = $true
        }
    }
    if ($RunAs) {
        $Process.StartInfo.UseShellExecute = $true
        $Process.StartInfo.Verb = 'RunAs'
    }
    try {
        $Process.Start() | Out-Null
    } catch {
        if ($Activity) {
            Write-Host "error." -ForegroundColor DarkRed
        }
        error $_.Exception.Message
        return $false
    }
    if ($LogPath -and ($FilePath -notmatch '(^|\W)msiexec($|\W)')) {
        Out-File -FilePath $LogPath -Encoding ASCII -Append -InputObject $Process.StandardOutput.ReadToEnd()
    }
    $Process.WaitForExit()
    if ($Process.ExitCode -ne 0) {
        if ($ContinueExitCodes -and ($ContinueExitCodes.ContainsKey($Process.ExitCode))) {
            if ($Activity) {
                Write-Host "done." -ForegroundColor DarkYellow
            }
            warn $ContinueExitCodes[$Process.ExitCode]
            return $true
        } else {
            if ($Activity) {
                Write-Host "error." -ForegroundColor DarkRed
            }
            error "Exit code was $($Process.ExitCode)!"
            return $false
        }
    }
    if ($Activity) {
        Write-Host "done." -ForegroundColor Green
    }
    return $true
}

function dl($url,$to) {
    $wc = New-Object Net.Webclient
    $wc.headers.add('Referer', (strip_filename $url))
    $wc.Headers.Add('User-Agent', (Get-UserAgent))
    $wc.downloadFile($url,$to)
}

function env($name,$global,$val='__get') {
    $target = 'User'; if($global) {$target = 'Machine'}
    if($val -eq '__get') { [environment]::getEnvironmentVariable($name,$target) }
    else { [environment]::setEnvironmentVariable($name,$val,$target) }
}

function isFileLocked([string]$path) {
    $file = New-Object System.IO.FileInfo $path

    if ((Test-Path -Path $path) -eq $false) {
        return $false
    }

    try {
        $stream = $file.Open([System.IO.FileMode]::Open, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)
        if ($stream) {
            $stream.Close()
        }
        return $false
    }
    catch {
        # file is locked by a process.
        return $true
    }
}

function is_directory([String] $path) {
    return (Test-Path $path) -and (Get-Item $path) -is [System.IO.DirectoryInfo]
}

function movedir($from, $to) {
    $from = $from.trimend('\')
    $to = $to.trimend('\')

    $proc = New-Object System.Diagnostics.Process
    $proc.StartInfo.FileName = 'robocopy.exe'
    $proc.StartInfo.Arguments = "`"$from`" `"$to`" /e /move"
    $proc.StartInfo.RedirectStandardOutput = $true
    $proc.StartInfo.RedirectStandardError = $true
    $proc.StartInfo.UseShellExecute = $false
    $proc.StartInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Hidden
    $proc.Start()
    $out = $proc.StandardOutput.ReadToEnd()
    $proc.WaitForExit()

    if($proc.ExitCode -ge 8) {
        debug $out
        throw "Could not find '$(fname $from)'! (error $($proc.ExitCode))"
    }

    # wait for robocopy to terminate its threads
    1..10 | ForEach-Object {
        if (Test-Path $from) {
            Start-Sleep -Milliseconds 100
        }
    }
}

function get_app_name($path) {
    if ($path -match '([^/\\]+)[/\\]current[/\\]') {
        return $matches[1].tolower()
    }
    return ''
}

function get_app_name_from_ps1_shim($shim_ps1) {
    if (!(Test-Path($shim_ps1))) {
        return ''
    }
    $content = (Get-Content $shim_ps1 -Encoding utf8) -join ' '
    return get_app_name $content
}

function warn_on_overwrite($shim_ps1, $path) {
    if (!(Test-Path($shim_ps1))) {
        return
    }
    $shim_app = get_app_name_from_ps1_shim $shim_ps1
    $path_app = get_app_name $path
    if ($shim_app -eq $path_app) {
        return
    }
    $filename = [System.IO.Path]::GetFileName($path)
    warn "Overwriting shim to $filename installed from $shim_app"
}

function shim($path, $global, $name, $arg) {
    if(!(test-path $path)) { abort "Can't shim '$(fname $path)': couldn't find '$path'." }
    $abs_shimdir = ensure (shimdir $global)
    if(!$name) { $name = strip_ext (fname $path) }

    $shim = "$abs_shimdir\$($name.tolower())"

    warn_on_overwrite "$shim.ps1" $path

    # convert to relative path
    Push-Location $abs_shimdir
    $relative_path = resolve-path -relative $path
    Pop-Location
    $resolved_path = resolve-path $path

    # if $path points to another drive resolve-path prepends .\ which could break shims
    if($relative_path -match "^(.\\[\w]:).*$") {
        write-output "`$path = `"$path`"" | out-file "$shim.ps1" -encoding utf8
    } else {
        # Setting PSScriptRoot in Shim if it is not defined, so the shim doesn't break in PowerShell 2.0
        Write-Output "if (!(Test-Path Variable:PSScriptRoot)) { `$PSScriptRoot = Split-Path `$MyInvocation.MyCommand.Path -Parent }" | Out-File "$shim.ps1" -Encoding utf8
        write-output "`$path = join-path `"`$psscriptroot`" `"$relative_path`"" | out-file "$shim.ps1" -Encoding utf8 -Append
    }

    if($path -match '\.jar$') {
        "if(`$myinvocation.expectingInput) { `$input | & java -jar `$path $arg @args } else { & java -jar `$path $arg @args }" | out-file "$shim.ps1" -encoding utf8 -append
    } else {
        "if(`$myinvocation.expectingInput) { `$input | & `$path $arg @args } else { & `$path $arg @args }" | out-file "$shim.ps1" -encoding utf8 -append
    }

    if($path -match '\.(exe|com)$') {
        # for programs with no awareness of any shell
        Copy-Item (get_shim_path) "$shim.exe" -force
        write-output "path = $resolved_path" | out-file "$shim.shim" -encoding utf8
        if($arg) {
            write-output "args = $arg" | out-file "$shim.shim" -encoding utf8 -append
        }
    } elseif($path -match '\.(bat|cmd)$') {
        # shim .bat, .cmd so they can be used by programs with no awareness of PSH
        "@`"$resolved_path`" $arg %*" | out-file "$shim.cmd" -encoding ascii

        "#!/bin/sh`nMSYS2_ARG_CONV_EXCL=/C cmd.exe /C `"$resolved_path`" $arg `"$@`"" | out-file $shim -encoding ascii
    } elseif($path -match '\.ps1$') {
        # make ps1 accessible from cmd.exe
        "@echo off
setlocal enabledelayedexpansion
set args=%*
:: replace problem characters in arguments
set args=%args:`"='%
set args=%args:(=``(%
set args=%args:)=``)%
set invalid=`"='
if !args! == !invalid! ( set args= )
powershell -noprofile -ex unrestricted `"& '$resolved_path' $arg %args%;exit `$lastexitcode`"" | out-file "$shim.cmd" -encoding ascii

        "#!/bin/sh`npowershell.exe -noprofile -ex unrestricted `"$resolved_path`" $arg `"$@`"" | out-file $shim -encoding ascii
    } elseif($path -match '\.jar$') {
        "@java -jar `"$resolved_path`" $arg %*" | out-file "$shim.cmd" -encoding ascii
        "#!/bin/sh`njava -jar `"$resolved_path`" $arg `"$@`"" | out-file $shim -encoding ascii
    }
}

function get_shim_path() {
    $shim_path = "$(versiondir 'scoop' 'current')\supporting\shimexe\bin\shim.exe"
    $shim_version = get_config 'shim' 'default'
    switch ($shim_version) {
        '71' { $shim_path = "$(versiondir 'scoop' 'current')\supporting\shims\71\shim.exe"; Break }
        'kiennq' { $shim_path = "$(versiondir 'scoop' 'current')\supporting\shims\kiennq\shim.exe"; Break }
        'default' { Break }
        default { warn "Unknown shim version: '$shim_version'" }
    }
    return $shim_path
}

function search_in_path($target) {
    $path = (env 'PATH' $false) + ";" + (env 'PATH' $true)
    foreach($dir in $path.split(';')) {
        if(test-path "$dir\$target" -pathType leaf) {
            return "$dir\$target"
        }
    }
}

function ensure_in_path($dir, $global) {
    $path = env 'PATH' $global
    $dir = fullpath $dir
    if($path -notmatch [regex]::escape($dir)) {
        write-output "Adding $(friendly_path $dir) to $(if($global){'global'}else{'your'}) path."

        env 'PATH' $global "$dir;$path" # for future sessions...
        $env:PATH = "$dir;$env:PATH" # for this session
    }
}

function ensure_architecture($architecture_opt) {
    if(!$architecture_opt) {
        return default_architecture
    }
    $architecture_opt = $architecture_opt.ToString().ToLower()
    switch($architecture_opt) {
        { @('64bit', '64', 'x64', 'amd64', 'x86_64', 'x86-64')  -contains $_ } { return '64bit' }
        { @('32bit', '32', 'x86', 'i386', '386', 'i686')  -contains $_ } { return '32bit' }
        default { throw [System.ArgumentException] "Invalid architecture: '$architecture_opt'"}
    }
}

function Confirm-InstallationStatus {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [String[]]
        $Apps,
        [Switch]
        $Global
    )
    $Installed = @()
    $Apps | Select-Object -Unique | Where-Object { $_.Name -ne 'scoop' } | ForEach-Object {
        $App, $null, $null = parse_app $_
        if ($Global) {
            if (installed $App $true) {
                $Installed += ,@($App, $true)
            } elseif (installed $App $false) {
                error "'$App' isn't installed globally, but it is installed for your account."
                warn "Try again without the --global (or -g) flag instead."
            } else {
                error "'$App' isn't installed."
            }
        } else {
            if(installed $App $false) {
                $Installed += ,@($App, $false)
            } elseif (installed $App $true) {
                error "'$App' isn't installed for your account, but it is installed globally."
                warn "Try again with the --global (or -g) flag instead."
            } else {
                error "'$App' isn't installed."
            }
        }
    }
    return ,$Installed
}

function strip_path($orig_path, $dir) {
    if($null -eq $orig_path) { $orig_path = '' }
    $stripped = [string]::join(';', @( $orig_path.split(';') | Where-Object { $_ -and $_ -ne $dir } ))
    return ($stripped -ne $orig_path), $stripped
}

function add_first_in_path($dir, $global) {
    $dir = fullpath $dir

    # future sessions
    $null, $currpath = strip_path (env 'path' $global) $dir
    env 'path' $global "$dir;$currpath"

    # this session
    $null, $env:PATH = strip_path $env:PATH $dir
    $env:PATH = "$dir;$env:PATH"
}

function remove_from_path($dir, $global) {
    $dir = fullpath $dir

    # future sessions
    $was_in_path, $newpath = strip_path (env 'path' $global) $dir
    if($was_in_path) {
        Write-Output "Removing $(friendly_path $dir) from your path."
        env 'path' $global $newpath
    }

    # current session
    $was_in_path, $newpath = strip_path $env:PATH $dir
    if($was_in_path) { $env:PATH = $newpath }
}

function ensure_scoop_in_path($global) {
    $abs_shimdir = ensure (shimdir $global)
    # be aggressive (b-e-aggressive) and install scoop first in the path
    ensure_in_path $abs_shimdir $global
}

function ensure_robocopy_in_path {
    if(!(Test-CommandAvailable robocopy)) {
        shim "C:\Windows\System32\Robocopy.exe" $false
    }
}

function wraptext($text, $width) {
    if(!$width) { $width = $host.ui.rawui.buffersize.width };
    $width -= 1 # be conservative: doesn't seem to print the last char

    $text -split '\r?\n' | ForEach-Object {
        $line = ''
        $_ -split ' ' | ForEach-Object {
            if($line.length -eq 0) { $line = $_ }
            elseif($line.length + $_.length + 1 -le $width) { $line += " $_" }
            else { $lines += ,$line; $line = $_ }
        }
        $lines += ,$line
    }

    $lines -join "`n"
}

function pluralize($count, $singular, $plural) {
    if($count -eq 1) { $singular } else { $plural }
}

function reset_alias($name, $value) {
    if($existing = get-alias $name -ea ignore | Where-Object { $_.options -match 'readonly' }) {
        if($existing.definition -ne $value) {
            write-host "Alias $name is read-only; can't reset it." -f darkyellow
        }
        return # already set
    }
    if($value -is [scriptblock]) {
        if(!(test-path -path "function:script:$name")) {
            new-item -path function: -name "script:$name" -value $value | out-null
        }
        return
    }

    set-alias $name $value -scope script -option allscope
}

function reset_aliases() {
    # for aliases where there's a local function, re-alias so the function takes precedence
    $aliases = get-alias | Where-Object { $_.options -notmatch 'readonly|allscope' } | ForEach-Object { $_.name }
    get-childitem function: | ForEach-Object {
        $fn = $_.name
        if($aliases -contains $fn) {
            set-alias $fn local:$fn -scope script
        }
    }

    # for dealing with user aliases
    $default_aliases = @{
        'cp' = 'copy-item'
        'echo' = 'write-output'
        'gc' = 'get-content'
        'gci' = 'get-childitem'
        'gcm' = 'get-command'
        'gm' = 'get-member'
        'iex' = 'invoke-expression'
        'ls' = 'get-childitem'
        'mkdir' = { new-item -type directory @args }
        'mv' = 'move-item'
        'rm' = 'remove-item'
        'sc' = 'set-content'
        'select' = 'select-object'
        'sls' = 'select-string'
    }

    # set default aliases
    $default_aliases.keys | ForEach-Object { reset_alias $_ $default_aliases[$_] }
}

# convert list of apps to list of ($app, $global) tuples
function applist($apps, $global) {
    if(!$apps) { return @() }
    return ,@($apps | ForEach-Object { ,@($_, $global) })
}

function parse_app([string] $app) {
    if($app -match '(?:(?<bucket>[a-zA-Z0-9-]+)\/)?(?<app>.*.json$|[a-zA-Z0-9-_.]+)(?:@(?<version>.*))?') {
        return $matches['app'], $matches['bucket'], $matches['version']
    }
    return $app, $null, $null
}

function show_app($app, $bucket, $version) {
    if($bucket) {
        $app = "$bucket/$app"
    }
    if($version) {
        $app = "$app@$version"
    }
    return $app
}

function last_scoop_update() {
    # PowerShell 6 returns an DateTime Object
    $last_update = (scoop config lastupdate)

    if ($null -ne $last_update -and $last_update.GetType() -eq [System.String]) {
        try {
            $last_update = [System.DateTime]::Parse($last_update)
        } catch {
            $last_update = $null
        }
    }
    return $last_update
}

function is_scoop_outdated() {
    $last_update = $(last_scoop_update)
    $now = [System.DateTime]::Now
    if($null -eq $last_update) {
        scoop config lastupdate $now.ToString('o')
        # enforce an update for the first time
        return $true
    }
    return $last_update.AddHours(3) -lt $now.ToLocalTime()
}

function substitute($entity, [Hashtable] $params, [Bool]$regexEscape = $false) {
    if ($entity -is [Array]) {
        return $entity | ForEach-Object { substitute $_ $params $regexEscape}
    } elseif ($entity -is [String]) {
        $params.GetEnumerator() | ForEach-Object {
            if($regexEscape -eq $false -or $null -eq $_.Value) {
                $entity = $entity.Replace($_.Name, $_.Value)
            } else {
                $entity = $entity.Replace($_.Name, [Regex]::Escape($_.Value))
            }
        }
        return $entity
    }
}

function format_hash([String] $hash) {
    $hash = $hash.toLower()
    switch ($hash.Length)
    {
        32 { $hash = "md5:$hash" } # md5
        40 { $hash = "sha1:$hash" } # sha1
        64 { $hash = $hash } # sha256
        128 { $hash = "sha512:$hash" } # sha512
        default { $hash = $null }
    }
    return $hash
}

function format_hash_aria2([String] $hash) {
    $hash = $hash -split ':' | Select-Object -Last 1
    switch ($hash.Length)
    {
        32 { $hash = "md5=$hash" } # md5
        40 { $hash = "sha-1=$hash" } # sha1
        64 { $hash = "sha-256=$hash" } # sha256
        128 { $hash = "sha-512=$hash" } # sha512
        default { $hash = $null }
    }
    return $hash
}

function get_hash([String] $multihash) {
    $type, $hash = $multihash -split ':'
    if(!$hash) {
        # no type specified, assume sha256
        $type, $hash = 'sha256', $multihash
    }

    if(@('md5','sha1','sha256', 'sha512') -notcontains $type) {
        return $null, "Hash type '$type' isn't supported."
    }

    return $type, $hash.ToLower()
}

function handle_special_urls($url)
{
    # FossHub.com
    if ($url -match "^(?:.*fosshub.com\/)(?<name>.*)(?:\/|\?dwl=)(?<filename>.*)$") {
        $Body = @{
            projectUri      = $Matches.name;
            fileName        = $Matches.filename;
            source          = 'CF';
            isLatestVersion = $true
        }
        if ((Invoke-RestMethod -Uri $url) -match '"p":"(?<pid>[a-f0-9]{24}).*?"r":"(?<rid>[a-f0-9]{24})') {
            $Body.Add("projectId", $Matches.pid)
            $Body.Add("releaseId", $Matches.rid)
        }
        $url = Invoke-RestMethod -Method Post -Uri "https://api.fosshub.com/download/" -ContentType "application/json" -Body (ConvertTo-Json $Body -Compress)
        if ($null -eq $url.error) {
            $url = $url.data.url
        }
    }

    # Sourceforge.net
    if ($url -match "(?:downloads\.)?sourceforge.net\/projects?\/(?<project>[^\/]+)\/(?:files\/)?(?<file>.*?)(?:$|\/download|\?)") {
        # Reshapes the URL to avoid redirections
        $url = "https://downloads.sourceforge.net/project/$($matches['project'])/$($matches['file'])"
    }
    return $url
}

function get_magic_bytes($file) {
    if(!(Test-Path $file)) {
        return ''
    }

    if((Get-Command Get-Content).parameters.ContainsKey('AsByteStream')) {
        # PowerShell Core (6.0+) '-Encoding byte' is replaced by '-AsByteStream'
        return Get-Content $file -AsByteStream -TotalCount 8
    }
    else {
        return Get-Content $file -Encoding byte -TotalCount 8
    }
}

function get_magic_bytes_pretty($file, $glue = ' ') {
    if(!(Test-Path $file)) {
        return ''
    }

    return (get_magic_bytes $file | ForEach-Object { $_.ToString('x2') }) -join $glue
}

##################
# Core Bootstrap #
##################

# Note: Github disabled TLS 1.0 support on 2018-02-23. Need to enable TLS 1.2
#       for all communication with api.github.com
Optimize-SecurityProtocol

# Scoop root directory
$scoopdir = $env:SCOOP, (get_config 'rootPath'), "$env:USERPROFILE\scoop" | Where-Object { -not [String]::IsNullOrEmpty($_) } | Select-Object -First 1

# Scoop global apps directory
$globaldir = $env:SCOOP_GLOBAL, (get_config 'globalPath'), "$env:ProgramData\scoop" | Where-Object { -not [String]::IsNullOrEmpty($_) } | Select-Object -first 1

# Scoop cache directory
# Note: Setting the SCOOP_CACHE environment variable to use a shared directory
#       is experimental and untested. There may be concurrency issues when
#       multiple users write and access cached files at the same time.
#       Use at your own risk.
$cachedir = $env:SCOOP_CACHE, (get_config 'cachePath'), "$scoopdir\cache" | Where-Object { -not [String]::IsNullOrEmpty($_) } | Select-Object -first 1

# Scoop config file migration
$configHome = $env:XDG_CONFIG_HOME, "$env:USERPROFILE\.config" | Select-Object -First 1
$configFile = "$configHome\scoop\config.json"
if ((Test-Path "$env:USERPROFILE\.scoop") -and !(Test-Path $configFile)) {
    New-Item -ItemType Directory (Split-Path -Path $configFile) -ErrorAction Ignore | Out-Null
    Move-Item "$env:USERPROFILE\.scoop" $configFile
    write-host "WARN  Scoop configuration has been migrated from '~/.scoop'" -f darkyellow
    write-host "WARN  to '$configFile'" -f darkyellow
}

# Load Scoop config
$scoopConfig = load_cfg $configFile
<#
Diagnostic tests.
Return $true if the test passed, otherwise $false.
Use 'warn' to highlight the issue, and follow up with the recommended actions to rectify.
#>
. "$PSScriptRoot\buckets.ps1"

function check_windows_defender($global) {
    $defender = get-service -name WinDefend -errorAction SilentlyContinue
    if($defender -and $defender.status) {
        if($defender.status -eq [system.serviceprocess.servicecontrollerstatus]::running) {
            if (Test-CommandAvailable Get-MpPreference) {
                $installPath = $scoopdir;
                if($global) { $installPath = $globaldir; }

                $exclusionPath = (Get-MpPreference).exclusionPath
                if(!($exclusionPath -contains $installPath)) {
                    warn "Windows Defender may slow down or disrupt installs with realtime scanning."
                    write-host "  Consider running:"
                    write-host "    sudo Add-MpPreference -ExclusionPath '$installPath'"
                    write-host "  (Requires 'sudo' command. Run 'scoop install sudo' if you don't have it.)"
                    return $false
                }
            }
        }
    }
    return $true
}

function check_main_bucket {
    if ((Get-LocalBucket) -notcontains 'main'){
        warn 'Main bucket is not added.'
        Write-Host "  run 'scoop bucket add main'"

        return $false
    }

    return $true
}

function check_long_paths {
    $key = Get-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem' -ErrorAction SilentlyContinue -Name 'LongPathsEnabled'
    if (!$key -or ($key.LongPathsEnabled -eq 0)) {
        warn 'LongPaths support is not enabled.'
        Write-Host "You can enable it with running:"
        Write-Host "    Set-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem' -Name 'LongPathsEnabled' -Value 1"

        return $false
    }

    return $true
}

function check_envs_requirements {
    if ($null -eq $env:COMSPEC) {
        warn '$env:COMSPEC environment variable is missing.'
        Write-Host "    By default the variable should points to the cmd.exe in Windows: '%SystemRoot%\system32\cmd.exe'."

        return $false
    }
# Note: This file is for overwriting global variables and functions to make
#       them unix compatible. It has to be imported after everything else!

function is_unix() { $PSVersionTable.Platform -eq 'Unix' }
function is_mac() { $PSVersionTable.OS.ToLower().StartsWith('darwin') }
function is_linux() { $PSVersionTable.OS.ToLower().StartsWith('linux') }

if(!(is_unix)) {
    return # get the hell outta here
}

# core.ps1
$scoopdir = $env:SCOOP, (get_config 'rootPath'), (Join-Path $env:HOME "scoop") | Select-Object -first 1
$globaldir = $env:SCOOP_GLOBAL, (get_config 'globalPath'), "/usr/local/scoop" | Select-Object -first 1
$cachedir = $env:SCOOP_CACHE, (get_config 'cachePath'), (Join-Path $scoopdir "cache") | Select-Object -first 1

# core.ps1
function ensure($dir) {
    mkdir -p $dir > $null
    return resolve-path $dir
}

# install.ps1
function compute_hash($file, $algname) {
    if(is_mac) {
        switch ($algname)
        {
            "md5" { $result = (md5 -q $file) }
            "sha1" { $result = (shasum -ba 1 $file) }
            "sha256" { $result = (shasum -ba 256 $file) }
            "sha512" { $result = (shasum -ba 512 $file) }
            default { $result = (shasum -ba 256 $file) }
        }
    } else {
        switch ($algname)
        {
            "md5" { $result = (md5sum -b $file) }
            "sha1" { $result = (sha1sum -b $file) }
            "sha256" { $result = (sha256sum -b $file) }
            "sha512" { $result = (sha512sum -b $file) }
$modulesdir = "$scoopdir\modules"

function install_psmodule($manifest, $dir, $global) {
    $psmodule = $manifest.psmodule
    if(!$psmodule) { return }

    if($global) {
        abort "Installing PowerShell modules globally is not implemented!"
    }

    $modulesdir = ensure $modulesdir
    ensure_in_psmodulepath $modulesdir $global

    $module_name = $psmodule.name
    if(!$module_name) {
        abort "Invalid manifest: The 'name' property is missing from 'psmodule'."
    }

    $linkfrom = "$modulesdir\$module_name"
    write-host "Installing PowerShell module '$module_name'"

    write-host "Linking $(friendly_path $linkfrom) => $(friendly_path $dir)"

    if(test-path $linkfrom) {
        warn "$(friendly_path $linkfrom) already exists. It will be replaced."
        & "$env:COMSPEC" /c "rmdir `"$linkfrom`""
    }

    & "$env:COMSPEC" /c "mklink /j `"$linkfrom`" `"$dir`"" | out-null
}

function uninstall_psmodule($manifest, $dir, $global) {
    $psmodule = $manifest.psmodule
    if(!$psmodule) { return }

    $module_name = $psmodule.name
    write-host "Uninstalling PowerShell module '$module_name'."

    $linkfrom = "$modulesdir\$module_name"
    if(test-path $linkfrom) {
        write-host "Removing $(friendly_path $linkfrom)"
        $linkfrom = resolve-path $linkfrom
        & "$env:COMSPEC" /c "rmdir `"$linkfrom`""
    }
}

function ensure_in_psmodulepath($dir, $global) {
    $path = env 'psmodulepath' $global
    if(!$global -and $null -eq $path) {
        $path = "$env:USERPROFILE\Documents\WindowsPowerShell\Modules"
    }
    $dir = fullpath $dir
    if($path -notmatch [regex]::escape($dir)) {
        write-output "Adding $(friendly_path $dir) to $(if($global){'global'}else{'your'}) PowerShell module path."

# resolve dependencies for the supplied apps, and sort into the correct order
function install_order($apps, $arch) {
    $res = @()
    foreach ($app in $apps) {
        foreach ($dep in deps $app $arch) {
            if ($res -notcontains $dep) { $res += $dep}
        }
        if ($res -notcontains $app) { $res += $app }
    }
    return $res
}

# http://www.electricmonk.nl/docs/dependency_resolving_algorithm/dependency_resolving_algorithm.html
function deps($app, $arch) {
    $resolved = new-object collections.arraylist
    dep_resolve $app $arch $resolved @()

    if ($resolved.count -eq 1) { return @() } # no dependencies
    return $resolved[0..($resolved.count - 2)]
}

function dep_resolve($app, $arch, $resolved, $unresolved) {
    $app, $bucket, $null = parse_app $app
    $unresolved += $app
    $null, $manifest, $null, $null = Find-Manifest $app $bucket

    if(!$manifest) {
        if(((Get-LocalBucket) -notcontains $bucket) -and $bucket) {
            warn "Bucket '$bucket' not installed. Add it with 'scoop bucket add $bucket' or 'scoop bucket add $bucket <repo>'."
        }
        abort "Couldn't find manifest for '$app'$(if(!$bucket) { '.' } else { " from '$bucket' bucket." })"
    }

    $deps = @(install_deps $manifest $arch) + @(runtime_deps $manifest) | Select-Object -Unique

    foreach ($dep in $deps) {
        if ($resolved -notcontains $dep) {
            if ($unresolved -contains $dep) {
                abort "Circular dependency detected: '$app' -> '$dep'."
            }
            dep_resolve $dep $arch $resolved $unresolved
        }
    }
    $resolved.add($app) | Out-Null
    $unresolved = $unresolved -ne $app # remove from unresolved
}

function runtime_deps($manifest) {
    if ($manifest.depends) { return $manifest.depends }
}

function script_deps($script) {
    $deps = @()
    if($script -is [Array]) {
        $script = $script -join "`n"
    }
    if([String]::IsNullOrEmpty($script)) {
        return $deps
    }

    if($script -like '*Expand-7zipArchive *' -or $script -like '*extract_7zip *') {
        $deps += '7zip'
    }
    if($script -like '*Expand-MsiArchive *' -or $script -like '*extract_msi *') {
        $deps += 'lessmsi'
    }
    if($script -like '*Expand-InnoArchive *' -or $script -like '*unpack_inno *') {
        $deps += 'innounp'
    }
    if($script -like '*Expand-DarkArchive *') {
        $deps += 'dark'
    }

    return $deps
}

function install_deps($manifest, $arch) {
    $deps = @()

    if (!(Test-HelperInstalled -Helper 7zip) -and (Test-7zipRequirement -URL (url $manifest $arch))) {
        $deps += '7zip'
    }
    if (!(Test-HelperInstalled -Helper Lessmsi) -and (Test-LessmsiRequirement -URL (url $manifest $arch))) {
        $deps += 'lessmsi'
    }
    if (!(Test-HelperInstalled -Helper Innounp) -and $manifest.innosetup) {
        $deps += 'innounp'
    }

    $pre_install = arch_specific 'pre_install' $manifest $arch
    $installer = arch_specific 'installer' $manifest $arch
    $post_install = arch_specific 'post_install' $manifest $arch
    $deps += script_deps $pre_install
    $deps += script_deps $installer.script
    $deps += script_deps $post_install
function find_description($url, $html, $redir = $false) {
    $meta = meta_tags $html

    # check <meta property="og:description">
    $og_description = meta_content $meta 'property' 'og:description'
    if($og_description) {
        return $og_description, '<meta property="og:description">'
    }

    # check <meta name="description">
    $description = meta_content $meta 'name' 'description'
    if($description) {
        return $description, '<meta name="description">'
    }

    # check <meta http-equiv="refresh"> redirect
    $refresh = meta_refresh $meta $url
    if($refresh -and !$redir) {
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        $html = $wc.downloadstring($refresh)
        return find_description $refresh $html $true
    }

    # check text for 'x is ...'
    $text = html_text $html $meta
    $text_desc = find_is $text
    if($text_desc) {
        return $text_desc, 'text'
    }

    # first paragraph
    $first_para = first_para $html
    if($first_para) {
        return $first_para, 'first <p>'
    }

    return $null, $null
}

function clean_description($description) {
    if(!$description) { return $description }
    $description = $description -replace '\n', ' '
    $description = $description -replace '\s{2,}', ' '
    return $description.trim()
}

# Collects meta tags from $html into hashtables.
function meta_tags($html) {
    $tags = @()
    $meta = ([regex]'<meta [^>]+>').matches($html)
    $meta | ForEach-Object {
        $attrs = ([regex]'([\w-]+)="([^"]+)"').matches($_.value)
        $hash = @{}
        $attrs | ForEach-Object {
            $hash[$_.groups[1].value] = $_.groups[2].value
        }
        $tags += $hash
    }
    $tags
}

function meta_content($tags, $attribute, $search) {
    if(!$tags) { return }
    return $tags | Where-Object { $_[$attribute] -eq $search } | ForEach-Object { $_['content'] }
}

# Looks for a redirect URL in a <meta> refresh tag.
function meta_refresh($tags, $url) {
    $refresh = meta_content $tags 'http-equiv' 'refresh'
    if($refresh) {
        if($refresh -match '\d+;\s*url\s*=\s*(.*)') {
            $refresh_url = $matches[1].trim("'", '"')
            if($refresh_url -notmatch '^https?://') {
                $refresh_url = "$url$refresh_url"
            }
            return $refresh_url
        }
    }
}

function html_body($html) {
    if($html -match '(?s)<body[^>]*>(.*?)</body>') {
        $body = $matches[1]
        $body = $body -replace '(?s)<script[^>]*>.*?</script>', ' '
        $body = $body -replace '(?s)<!--.*?-->', ' '
        return $body
    }
}

function html_text($body, $meta_tags) {
    $body = html_body $html
    if($body) {
        return strip_html $body
    }
}

function strip_html($html) {
    $html = $html -replace '(?s)<[^>]*>', ' '
    $html = $html -replace '\t', ' '
    $html = $html -replace '&nbsp;?', ' '
    $html = $html -replace '&gt;?', '>'
    $html = $html -replace '&lt;?', '<'
    $html = $html -replace '&quot;?', '"'

    $encoding_meta = meta_content $meta_tags 'http-equiv' 'Content-Type'
    if($encoding_meta) {
        if($encoding_meta -match 'charset\s*=\s*(.*)') {
            $charset = $matches[1]
            try {
                $encoding = [text.encoding]::getencoding($charset)
            } catch {
                Write-Warning "Unknown charset"
            }
            if($encoding) {
                $html = ([regex]'&#(\d+);?').replace($html, {
                    param($m)
                    try {
                        return $encoding.getstring($m.Groups[1].Value)
                    } catch {
                        return $m.value
                    }
                })
            }
        }
    }

    $html = $html -replace '\n +', "`r`n"
    $html = $html -replace '\n{2,}', "`r`n"
    $html = $html -replace ' {2,}', ' '
    $html = $html -replace ' (\.|,)', '$1'
    return $html.trim()
}

function find_is($text) {
    if($text -match '(?s)[\n\.]((?:[^\n\.])+? is .+?[\.!])') {
        return $matches[1].trim()
    }
}

function first_para($html) {
    $body = html_body $html
    if($body -match '(?s)<p[^>]*>(.*?)</p>') {
        return strip_html $matches[1]
    }
# Convert objects to pretty json
# Only needed until PowerShell ConvertTo-Json will be improved https://github.com/PowerShell/PowerShell/issues/2736
# https://github.com/PowerShell/PowerShell/issues/2736 was fixed in pwsh
# Still needed in normal powershell

function ConvertToPrettyJson {
    [CmdletBinding()]

    Param (
        [Parameter(Mandatory, ValueFromPipeline)]
        $data
    )

    Process {
        $data = normalize_values $data

        # convert to string
        [String]$json = $data | ConvertTo-Json -Depth 8 -Compress
        [String]$output = ''

        # state
        [String]$buffer = ''
        [Int]$depth = 0
        [Bool]$inString = $false

        # configuration
        [String]$indent = ' ' * 4
        [Bool]$unescapeString = $true
        [String]$eol = "`r`n"

        for ($i = 0; $i -lt $json.Length; $i++) {
            # read current char
            $buffer = $json.Substring($i, 1)

            $objectStart = !$inString -and $buffer.Equals('{')
            $objectEnd = !$inString -and $buffer.Equals('}')
            $arrayStart = !$inString -and $buffer.Equals('[')
            $arrayEnd = !$inString -and $buffer.Equals(']')
            $colon = !$inString -and $buffer.Equals(':')
            $comma = !$inString -and $buffer.Equals(',')
            $quote = $buffer.Equals('"')
            $escape = $buffer.Equals('\')

            if ($quote) {
                $inString = !$inString
            }

            # skip escape sequences
            if ($escape) {
                $buffer = $json.Substring($i, 2)
                ++$i

                # Unescape unicode
                if ($inString -and $unescapeString) {
                    if ($buffer.Equals('\n')) {
                        $buffer = "`n"
                    } elseif ($buffer.Equals('\r')) {
                        $buffer = "`r"
                    } elseif ($buffer.Equals('\t')) {
                        $buffer = "`t"
                    } elseif ($buffer.Equals('\u')) {
                        $buffer = [regex]::Unescape($json.Substring($i - 1, 6))
                        $i += 4
                    }
                }

                $output += $buffer
                continue
            }

            # indent / outdent
            if ($objectStart -or $arrayStart) {
                ++$depth
            } elseif ($objectEnd -or $arrayEnd) {
                --$depth
                $output += $eol + ($indent * $depth)
            }

            # add content
            $output += $buffer

            # add whitespace and newlines after the content
            if ($colon) {
                $output += ' '
            } elseif ($comma -or $arrayStart -or $objectStart) {
                $output += $eol
                $output += $indent * $depth
            }
        }

        return $output
    }
}

function json_path([String] $json, [String] $jsonpath, [Hashtable] $substitutions) {
    Add-Type -Path "$psscriptroot\..\supporting\validator\bin\Newtonsoft.Json.dll"
    if ($null -ne $substitutions) {
        $jsonpath = substitute $jsonpath $substitutions ($jsonpath -like "*=~*")
    }
    try {
        $obj = [Newtonsoft.Json.Linq.JObject]::Parse($json)
    } catch [Newtonsoft.Json.JsonReaderException] {
        try {
            $obj = [Newtonsoft.Json.Linq.JArray]::Parse($json)
        } catch [Newtonsoft.Json.JsonReaderException] {
            return $null
        }
    }

    try {
        try {
            $result = $obj.SelectToken($jsonpath, $true)
        } catch [Newtonsoft.Json.JsonException] {
            return $null
        }
        return $result.ToString()
    } catch [System.Management.Automation.MethodInvocationException] {
        write-host -f DarkRed $_
        return $null
    }

    return $null
}

function json_path_legacy([String] $json, [String] $jsonpath, [Hashtable] $substitutions) {
    $result = $json | ConvertFrom-Json -ea stop
    $isJsonPath = $jsonpath.StartsWith('$')
    $jsonpath.split('.') | ForEach-Object {
        $el = $_

        # substitute the basename and version varibales into the jsonpath
        if ($null -ne $substitutions) {
            $el = substitute $el $substitutions
        }

        # skip $ if it's jsonpath format
        if ($el -eq '$' -and $isJsonPath) {
            return
        }

        # array detection
        if ($el -match '^(?<property>\w+)?\[(?<index>\d+)\]$') {
            $property = $matches['property']
            if ($property) {
                $result = $result.$property[$matches['index']]
            } else {
                $result = $result[$matches['index']]
            }
            return
        }

        $result = $result.$el
    }
    return $result
}

function normalize_values([psobject] $json) {
    # Iterate Through Manifest Properties
    $json.PSObject.Properties | ForEach-Object {
        # Recursively edit psobjects
        # If the values is psobjects, its not normalized
        # For example if manifest have architecture and it's architecture have array with single value it's not formatted.
        # @see https://github.com/lukesampson/scoop/pull/2642#issue-220506263
        if ($_.Value -is [System.Management.Automation.PSCustomObject]) {
            $_.Value = normalize_values $_.Value
        }

        # Process String Values
        if ($_.Value -is [String]) {

            # Split on new lines
            [Array] $parts = ($_.Value -split '\r?\n').Trim()

            # Replace with string array if result is multiple lines
            if ($parts.Count -gt 1) {
                $_.Value = $parts
            }
        }

        # Convert single value array into string
        if ($_.Value -is [Array]) {
            # Array contains only 1 element String or Array
            if ($_.Value.Count -eq 1) {
                # Array
                if ($_.Value[0] -is [Array]) {
                    $_.Value = $_.Value
                } else {
                    # String
                    $_.Value = $_.Value[0]
                }
            } else {
                # Array of Arrays
                $resulted_arrs = @()
                foreach ($element in $_.Value) {
                    if ($element.Count -eq 1) {
                        $resulted_arrs += $element
                    } else {
                        $resulted_arrs += , $element
                    }
                }

                $_.Value = $resulted_arrs
            }
        }

function git_proxy_cmd {
    $proxy = get_config 'proxy'
    $cmd = "git $($args | ForEach-Object { "$_ " })"
    if($proxy -and $proxy -ne 'none') {
        $cmd = "SET HTTPS_PROXY=$proxy&&SET HTTP_PROXY=$proxy&&$cmd"
    }
    & "$env:COMSPEC" /d /c $cmd
}

function git_clone {
    git_proxy_cmd clone $args
}

function git_ls_remote {
    git_proxy_cmd ls-remote $args
}

function git_checkout {
    git_proxy_cmd checkout $args
}

function git_pull {
    git_proxy_cmd pull --rebase=false $args
}

function git_fetch {
    git_proxy_cmd fetch $args
}

function git_checkout {
# Creates shortcut for the app in the start menu
function create_startmenu_shortcuts($manifest, $dir, $global, $arch) {
    $shortcuts = @(arch_specific 'shortcuts' $manifest $arch)
    $shortcuts | Where-Object { $_ -ne $null } | ForEach-Object {
        $target = [System.IO.Path]::Combine($dir, $_.item(0))
        $target = New-Object System.IO.FileInfo($target)
        $name = $_.item(1)
        $arguments = ""
        $icon = $null
        if($_.length -ge 3) {
            $arguments = $_.item(2)
        }
        if($_.length -ge 4) {
            $icon = [System.IO.Path]::Combine($dir, $_.item(3))
            $icon = New-Object System.IO.FileInfo($icon)
        }
        $arguments = (substitute $arguments @{ '$dir' = $dir; '$original_dir' = $original_dir; '$persist_dir' = $persist_dir})
        startmenu_shortcut $target $name $arguments $icon $global
    }
}

function shortcut_folder($global) {
    $directory = [System.IO.Path]::Combine([Environment]::GetFolderPath('startmenu'), 'Programs', 'Scoop Apps')
    if($global) {
        $directory = [System.IO.Path]::Combine([Environment]::GetFolderPath('commonstartmenu'), 'Programs', 'Scoop Apps')
    }
    return $(ensure $directory)
}

function startmenu_shortcut([System.IO.FileInfo] $target, $shortcutName, $arguments, [System.IO.FileInfo]$icon, $global) {
    if(!$target.Exists) {
        Write-Host -f DarkRed "Creating shortcut for $shortcutName ($(fname $target)) failed: Couldn't find $target"
        return
    }
    if($icon -and !$icon.Exists) {
        Write-Host -f DarkRed "Creating shortcut for $shortcutName ($(fname $target)) failed: Couldn't find icon $icon"
        return
    }

    $scoop_startmenu_folder = shortcut_folder $global
    $subdirectory = [System.IO.Path]::GetDirectoryName($shortcutName)
    if ($subdirectory) {
        $subdirectory = ensure $([System.IO.Path]::Combine($scoop_startmenu_folder, $subdirectory))
    }

    $wsShell = New-Object -ComObject WScript.Shell
    $wsShell = $wsShell.CreateShortcut("$scoop_startmenu_folder\$shortcutName.lnk")
    $wsShell.TargetPath = $target.FullName
    $wsShell.WorkingDirectory = $target.DirectoryName
    if ($arguments) {
        $wsShell.Arguments = $arguments
    }
    if($icon -and $icon.Exists) {
        $wsShell.IconLocation = $icon.FullName
    }
    $wsShell.Save()
    write-host "Creating shortcut for $shortcutName ($(fname $target))"
}

# Removes the Startmenu shortcut if it exists
function rm_startmenu_shortcuts($manifest, $global, $arch) {
    $shortcuts = @(arch_specific 'shortcuts' $manifest $arch)
    $shortcuts | Where-Object { $_ -ne $null } | ForEach-Object {
        $name = $_.item(1)
        $shortcut = "$(shortcut_folder $global)\$name.lnk"
        write-host "Removing shortcut $(friendly_path $shortcut)"
        if(Test-Path -Path $shortcut) {
             Remove-Item $shortcut
        }
        # Before issue 1514 Startmenu shortcut removal
        #
        # Shortcuts that should have been installed globally would
        # have been installed locally up until 27 June 2017.
        #
        # TODO: Remove this 'if' block and comment after
        #       27 June 2018.
        if($global) {
            $shortcut = "$(shortcut_folder $false)\$name.lnk"
            if(Test-Path -Path $shortcut) {
                 Remove-Item $shortcut
. "$PSScriptRoot\core.ps1"

$bucketsdir = "$scoopdir\buckets"

function Find-BucketDirectory {
    <#
    .DESCRIPTION
        Return full path for bucket with given name.
        Main bucket will be returned as default.
    .PARAMETER Name
        Name of bucket.
    .PARAMETER Root
        Root folder of bucket repository will be returned instead of 'bucket' subdirectory (if exists).
    #>
    param(
        [string] $Name = 'main',
        [switch] $Root
    )

    # Handle info passing empty string as bucket ($install.bucket)
    if(($null -eq $Name) -or ($Name -eq '')) { $Name = 'main' }
    $bucket = "$bucketsdir\$Name"

    if ((Test-Path "$bucket\bucket") -and !$Root) {
        $bucket = "$bucket\bucket"
    }

    return $bucket
}

function bucketdir($name) {
    Show-DeprecatedWarning $MyInvocation 'Find-BucketDirectory'

    return Find-BucketDirectory $name
}

function known_bucket_repos {
    $json = "$PSScriptRoot\..\buckets.json"

    return Get-Content $json -raw | convertfrom-json -ea stop
}

function known_bucket_repo($name) {
    $buckets = known_bucket_repos
    $buckets.$name
}

function known_buckets {
    known_bucket_repos | ForEach-Object { $_.psobject.properties | Select-Object -expand 'name' }
}

function apps_in_bucket($dir) {
    return Get-ChildItem $dir | Where-Object { $_.Name.endswith('.json') } | ForEach-Object { $_.Name -replace '.json$', '' }
}

function Get-LocalBucket {
    <#
    .SYNOPSIS
        List all local buckets.
    #>

    return (Get-ChildItem -Directory $bucketsdir).Name
}

function buckets {
    Show-DeprecatedWarning $MyInvocation 'Get-LocalBucket'

    return Get-LocalBucket
}

function find_manifest($app, $bucket) {
    if ($bucket) {
        $manifest = manifest $app $bucket
        if ($manifest) { return $manifest, $bucket }
        return $null
    }

    foreach($bucket in Get-LocalBucket) {
        $manifest = manifest $app $bucket
        if($manifest) { return $manifest, $bucket }
    }
}

function add_bucket($name, $repo) {
    if (!$name) { "<name> missing"; $usage_add; exit 1 }
    if (!$repo) {
        $repo = known_bucket_repo $name
        if (!$repo) { "Unknown bucket '$name'. Try specifying <repo>."; $usage_add; exit 1 }
    }

    if (!(Test-CommandAvailable git)) {
        abort "Git is required for buckets. Run 'scoop install git' and try again."
    }

    $dir = Find-BucketDirectory $name -Root
    if (test-path $dir) {
        warn "The '$name' bucket already exists. Use 'scoop bucket rm $name' to remove it."
        exit 0
    }

    write-host 'Checking repo... ' -nonewline
    $out = git_ls_remote $repo 2>&1
    if ($lastexitcode -ne 0) {
        abort "'$repo' doesn't look like a valid git repository`n`nError given:`n$out"
    }
    write-host 'ok'

    ensure $bucketsdir > $null
    $dir = ensure $dir
    git_clone "$repo" "`"$dir`"" -q
    success "The $name bucket was added successfully."
}

function rm_bucket($name) {
    if (!$name) { "<name> missing"; $usage_rm; exit 1 }
    $dir = Find-BucketDirectory $name -Root
    if (!(test-path $dir)) {
        abort "'$name' bucket not found."
    }

    Remove-Item $dir -r -force -ea stop
}

function new_issue_msg($app, $bucket, $title, $body) {
    $app, $manifest, $bucket, $url = Find-Manifest $app $bucket
    $url = known_bucket_repo $bucket
    $bucket_path = "$bucketsdir\$bucket"

    if (Test-path $bucket_path) {
        Push-Location $bucket_path
        $remote = Invoke-Expression "git config --get remote.origin.url"
        # Support ssh and http syntax
        # git@PROVIDER:USER/REPO.git
        # https://PROVIDER/USER/REPO.git
        $remote -match '(@|:\/\/)(?<provider>.+)[:/](?<user>.*)\/(?<repo>.*)(\.git)?$' | Out-Null
        $url = "https://$($Matches.Provider)/$($Matches.User)/$($Matches.Repo)"
        Pop-Location
    }

    if(!$url) { return 'Please contact the bucket maintainer!' }

    # Print only github repositories
    if ($url -like '*github*') {
        $title = [System.Web.HttpUtility]::UrlEncode("$app@$($manifest.version): $title")
        $body = [System.Web.HttpUtility]::UrlEncode($body)
        $url = $url -replace '\.git$', ''
        $url = "$url/issues/new?title=$title"
        if($body) {
            $url += "&body=$body"
        }
function command_files {
    (Get-ChildItem (relpath '..\libexec')) `
        + (Get-ChildItem "$scoopdir\shims") `
        | Where-Object { $_.name -match 'scoop-.*?\.ps1$' }
}

function commands {
    command_files | ForEach-Object { command_name $_ }
}

function command_name($filename) {
    $filename.name | Select-String 'scoop-(.*?)\.ps1$' | ForEach-Object { $_.matches[0].groups[1].value }
}

function command_path($cmd) {
    $cmd_path = relpath "..\libexec\scoop-$cmd.ps1"

    # built in commands
    if (!(Test-Path $cmd_path)) {
        # get path from shim
        $shim_path = "$scoopdir\shims\scoop-$cmd.ps1"
        $line = ((Get-Content $shim_path) | Where-Object { $_.startswith('$path') })
        if($line) {
            Invoke-Expression -command "$line"
            $cmd_path = $path
        }
        else { $cmd_path = $shim_path }
    }

    $cmd_path
}

function exec($cmd, $arguments) {
    $cmd_path = command_path $cmd

function usage($text) {
    $text | Select-String '(?m)^# Usage: ([^\n]*)$' | ForEach-Object { "Usage: " + $_.matches[0].groups[1].value }
}

function summary($text) {
    $text | Select-String '(?m)^# Summary: ([^\n]*)$' | ForEach-Object { $_.matches[0].groups[1].value }
}

function scoop_help($text) {
    $help_lines = $text | Select-String '(?ms)^# Help:(.(?!^[^#]))*' | ForEach-Object { $_.matches[0].value; }
    $help_lines -replace '(?ms)^#\s?(Help: )?', ''
}

function my_usage { # gets usage for the calling script
    usage (Get-Content $myInvocation.PSCommandPath -raw)
. "$psscriptroot/autoupdate.ps1"
. "$psscriptroot/buckets.ps1"

function nightly_version($date, $quiet = $false) {
    $date_str = $date.tostring("yyyyMMdd")
    if (!$quiet) {
        warn "This is a nightly version. Downloaded files won't be verified."
    }
    "nightly-$date_str"
}

function install_app($app, $architecture, $global, $suggested, $use_cache = $true, $check_hash = $true) {
    $app, $bucket, $null = parse_app $app
    $app, $manifest, $bucket, $url = Find-Manifest $app $bucket

    if(!$manifest) {
        abort "Couldn't find manifest for '$app'$(if($url) { " at the URL $url" })."
    }

    $version = $manifest.version
    if(!$version) { abort "Manifest doesn't specify a version." }
    if($version -match '[^\w\.\-\+_]') {
        abort "Manifest version has unsupported character '$($matches[0])'."
    }

    $is_nightly = $version -eq 'nightly'
    if ($is_nightly) {
        $version = nightly_version $(get-date)
        $check_hash = $false
    }

    if(!(supports_architecture $manifest $architecture)) {
        write-host -f DarkRed "'$app' doesn't support $architecture architecture!"
        return
    }

    write-output "Installing '$app' ($version) [$architecture]"

    $dir = ensure (versiondir $app $version $global)
    $original_dir = $dir # keep reference to real (not linked) directory
    $persist_dir = persistdir $app $global

    $fname = dl_urls $app $version $manifest $bucket $architecture $dir $use_cache $check_hash
    pre_install $manifest $architecture
    run_installer $fname $manifest $architecture $dir $global
    ensure_install_dir_not_in_path $dir $global
    $dir = link_current $dir
    create_shims $manifest $dir $global $architecture
    create_startmenu_shortcuts $manifest $dir $global $architecture
    install_psmodule $manifest $dir $global
    if($global) { ensure_scoop_in_path $global } # can assume local scoop is in path
    env_add_path $manifest $dir $global $architecture
    env_set $manifest $dir $global $architecture

    # persist data
    persist_data $manifest $original_dir $persist_dir
    persist_permission $manifest $global

    post_install $manifest $architecture

    # save info for uninstall
    save_installed_manifest $app $bucket $dir $url
    save_install_info @{ 'architecture' = $architecture; 'url' = $url; 'bucket' = $bucket } $dir

    if($manifest.suggest) {
        $suggested[$app] = $manifest.suggest
    }

    success "'$app' ($version) was installed successfully!"

    show_notes $manifest $dir $original_dir $persist_dir
}

function locate($app, $bucket) {
    Show-DeprecatedWarning $MyInvocation 'Find-Manifest'
    return Find-Manifest $app $bucket
}

function Find-Manifest($app, $bucket) {
    $manifest, $url = $null, $null

    # check if app is a URL or UNC path
    if($app -match '^(ht|f)tps?://|\\\\') {
        $url = $app
        $app = appname_from_url $url
        $manifest = url_manifest $url
    } else {
        # check buckets
        $manifest, $bucket = find_manifest $app $bucket

        if(!$manifest) {
            # couldn't find app in buckets: check if it's a local path
            $path = $app
            if(!$path.endswith('.json')) { $path += '.json' }
            if(test-path $path) {
                $url = "$(resolve-path $path)"
                $app = appname_from_url $url
                $manifest, $bucket = url_manifest $url
            }
        }
    }

    return $app, $manifest, $bucket, $url
}

function dl_with_cache($app, $version, $url, $to, $cookies = $null, $use_cache = $true) {
    $cached = fullpath (cache_path $app $version $url)

    if(!(test-path $cached) -or !$use_cache) {
        ensure $cachedir | Out-Null
        do_dl $url "$cached.download" $cookies
        Move-Item "$cached.download" $cached -force
    } else { write-host "Loading $(url_remote_filename $url) from cache"}

    if (!($null -eq $to)) {
        Copy-Item $cached $to
    }
}

function do_dl($url, $to, $cookies) {
    $progress = [console]::isoutputredirected -eq $false -and
        $host.name -ne 'Windows PowerShell ISE Host'

    try {
        $url = handle_special_urls $url
        dl $url $to $cookies $progress
    } catch {
        $e = $_.exception
        if($e.innerexception) { $e = $e.innerexception }
        throw $e
    }
}

function aria_exit_code($exitcode) {
    $codes = @{
        0='All downloads were successful'
        1='An unknown error occurred'
        2='Timeout'
        3='Resource was not found'
        4='Aria2 saw the specified number of "resource not found" error. See --max-file-not-found option'
        5='Download aborted because download speed was too slow. See --lowest-speed-limit option'
        6='Network problem occurred.'
        7='There were unfinished downloads. This error is only reported if all finished downloads were successful and there were unfinished downloads in a queue when aria2 exited by pressing Ctrl-C by an user or sending TERM or INT signal'
        8='Remote server did not support resume when resume was required to complete download'
        9='There was not enough disk space available'
        10='Piece length was different from one in .aria2 control file. See --allow-piece-length-change option'
        11='Aria2 was downloading same file at that moment'
        12='Aria2 was downloading same info hash torrent at that moment'
        13='File already existed. See --allow-overwrite option'
        14='Renaming file failed. See --auto-file-renaming option'
        15='Aria2 could not open existing file'
        16='Aria2 could not create new file or truncate existing file'
        17='File I/O error occurred'
        18='Aria2 could not create directory'
        19='Name resolution failed'
        20='Aria2 could not parse Metalink document'
        21='FTP command failed'
        22='HTTP response header was bad or unexpected'
        23='Too many redirects occurred'
        24='HTTP authorization failed'
        25='Aria2 could not parse bencoded file (usually ".torrent" file)'
        26='".torrent" file was corrupted or missing information that aria2 needed'
        27='Magnet URI was bad'
        28='Bad/unrecognized option was given or unexpected option argument was given'
        29='The remote server was unable to handle the request due to a temporary overloading or maintenance'
        30='Aria2 could not parse JSON-RPC request'
        31='Reserved. Not used'
        32='Checksum validation failed'
    }
    if($null -eq $codes[$exitcode]) {
        return 'An unknown error occurred'
    }
    return $codes[$exitcode]
}

function get_filename_from_metalink($file) {
    $bytes = get_magic_bytes_pretty $file ''
    # check if file starts with '<?xml'
    if(!($bytes.StartsWith('3c3f786d6c'))) {
        return $null
    }

    # Add System.Xml for reading metalink files
    Add-Type -AssemblyName 'System.Xml'
    $xr = [System.Xml.XmlReader]::Create($file)
    $filename = $null
    try {
        $xr.ReadStartElement('metalink')
        if($xr.ReadToFollowing('file') -and $xr.MoveToFirstAttribute()) {
            $filename = $xr.Value
        }
    } catch [System.Xml.XmlException] {
        return $null
    } finally {
        $xr.Close()
    }

    return $filename
}

function dl_with_cache_aria2($app, $version, $manifest, $architecture, $dir, $cookies = $null, $use_cache = $true, $check_hash = $true) {
    $data = @{}
    $urls = @(url $manifest $architecture)

    # aria2 input file
    $urlstxt = Join-Path $cachedir "$app.txt"
    $urlstxt_content = ''
    $has_downloads = $false

    # aria2 options
    $options = @(
        "--input-file='$urlstxt'"
        "--user-agent='$(Get-UserAgent)'"
        "--allow-overwrite=true"
        "--auto-file-renaming=false"
        "--retry-wait=$(get_config 'aria2-retry-wait' 2)"
        "--split=$(get_config 'aria2-split' 5)"
        "--max-connection-per-server=$(get_config 'aria2-max-connection-per-server' 5)"
        "--min-split-size=$(get_config 'aria2-min-split-size' '5M')"
        "--console-log-level=warn"
        "--enable-color=false"
        "--no-conf=true"
        "--follow-metalink=true"
        "--metalink-preferred-protocol=https"
        "--min-tls-version=TLSv1.2"
        "--stop-with-process=$PID"
        "--continue"
        "--summary-interval 0"
    )

    if($cookies) {
        $options += "--header='Cookie: $(cookie_header $cookies)'"
    }

    $proxy = get_config 'proxy'
    if($proxy -ne 'none') {
        if([Net.Webrequest]::DefaultWebProxy.Address) {
            $options += "--all-proxy='$([Net.Webrequest]::DefaultWebProxy.Address.Authority)'"
        }
        if([Net.Webrequest]::DefaultWebProxy.Credentials.UserName) {
            $options += "--all-proxy-user='$([Net.Webrequest]::DefaultWebProxy.Credentials.UserName)'"
        }
        if([Net.Webrequest]::DefaultWebProxy.Credentials.Password) {
            $options += "--all-proxy-passwd='$([Net.Webrequest]::DefaultWebProxy.Credentials.Password)'"
        }
    }

    $more_options = get_config 'aria2-options'
    if($more_options) {
        $options += $more_options
    }

    foreach($url in $urls) {
        $data.$url = @{
            'filename' = url_filename $url
            'target' = "$dir\$(url_filename $url)"
            'cachename' = fname (cache_path $app $version $url)
            'source' = fullpath (cache_path $app $version $url)
        }

        if(!(test-path $data.$url.source)) {
            $has_downloads = $true
            # create aria2 input file content
            $urlstxt_content += "$(handle_special_urls $url)`n"
            if(!$url.Contains('sourceforge.net')) {
                $urlstxt_content += "    referer=$(strip_filename $url)`n"
            }
            $urlstxt_content += "    dir=$cachedir`n"
            $urlstxt_content += "    out=$($data.$url.cachename)`n"
        } else {
            Write-Host "Loading " -NoNewline
            Write-Host $(url_remote_filename $url) -f Cyan -NoNewline
            Write-Host " from cache."
        }
    }

    if($has_downloads) {
        # write aria2 input file
        Set-Content -Path $urlstxt $urlstxt_content

        # build aria2 command
        $aria2 = "& '$(Get-HelperPath -Helper Aria2)' $($options -join ' ')"

        # handle aria2 console output
        Write-Host "Starting download with aria2 ..."

        Invoke-Expression $aria2 | ForEach-Object {
            # Skip blank lines
            if ([String]::IsNullOrWhiteSpace($_)) { return }

            # Prevent potential overlaping of text when one line is shorter
            $len = $Host.UI.RawUI.WindowSize.Width - $_.Length - 20
            $blank = if ($len -gt 0) { ' ' * $len } else { '' }
            $color = 'Gray'

            if ($_.StartsWith('(OK):')) {
                $noNewLine = $true
                $color = 'Green'
            } elseif ($_.StartsWith('[') -and $_.EndsWith(']')) {
                $noNewLine = $true
                $color = 'Cyan'
            } elseif ($_.StartsWith('Download Results:')) {
                $noNewLine = $false
            }

            Write-Host "`rDownload: $_$blank" -ForegroundColor $color -NoNewline:$noNewLine
        }
        Write-Host ''

        if($lastexitcode -gt 0) {
            error "Download failed! (Error $lastexitcode) $(aria_exit_code $lastexitcode)"
            error $urlstxt_content
            error $aria2
            abort $(new_issue_msg $app $bucket "download via aria2 failed")
        }

        # remove aria2 input file when done
        if(test-path($urlstxt)) {
            Remove-Item $urlstxt
        }
    }

    foreach($url in $urls) {

        $metalink_filename = get_filename_from_metalink $data.$url.source
        if($metalink_filename) {
            Remove-Item $data.$url.source -Force
            Rename-Item -Force (Join-Path -Path $cachedir -ChildPath $metalink_filename) $data.$url.source
        }

        # run hash checks
        if($check_hash) {
            $manifest_hash = hash_for_url $manifest $url $architecture
            $ok, $err = check_hash $data.$url.source $manifest_hash $(show_app $app $bucket)
            if(!$ok) {
                error $err
                if(test-path $data.$url.source) {
                    # rm cached file
                    Remove-Item -force $data.$url.source
                }
                if($url.Contains('sourceforge.net')) {
                    Write-Host -f yellow 'SourceForge.net is known for causing hash validation fails. Please try again before opening a ticket.'
                }
                abort $(new_issue_msg $app $bucket "hash check failed")
            }
        }

        # copy or move file to target location
        if(!(test-path $data.$url.source) ) {
            abort $(new_issue_msg $app $bucket "cached file not found")
        }

        if(!($dir -eq $cachedir)) {
            if($use_cache) {
                Copy-Item $data.$url.source $data.$url.target
            } else {
                Move-Item $data.$url.source $data.$url.target -force
            }
        }
    }
}

# download with filesize and progress indicator
function dl($url, $to, $cookies, $progress) {
    $reqUrl = ($url -split "#")[0]
    $wreq = [net.webrequest]::create($reqUrl)
    if($wreq -is [net.httpwebrequest]) {
        $wreq.useragent = Get-UserAgent
        if (-not ($url -imatch "sourceforge\.net" -or $url -imatch "portableapps\.com")) {
            $wreq.referer = strip_filename $url
        }
        if($cookies) {
            $wreq.headers.add('Cookie', (cookie_header $cookies))
        }
    }

    try {
        $wres = $wreq.GetResponse()
    } catch [System.Net.WebException] {
        $exc = $_.Exception
        $handledCodes = @(
            [System.Net.HttpStatusCode]::MovedPermanently,  # HTTP 301
            [System.Net.HttpStatusCode]::Found,             # HTTP 302
            [System.Net.HttpStatusCode]::SeeOther,          # HTTP 303
            [System.Net.HttpStatusCode]::TemporaryRedirect  # HTTP 307
        )

        # Only handle redirection codes
        $redirectRes = $exc.Response
        if ($handledCodes -notcontains $redirectRes.StatusCode) {
            throw $exc
        }

        # Get the new location of the file
        if ((-not $redirectRes.Headers) -or ($redirectRes.Headers -notcontains 'Location')) {
            throw $exc
        }

        $newUrl = $redirectRes.Headers['Location']
        info "Following redirect to $newUrl..."

        # Handle manual file rename
        if ($url -like '*#/*') {
            $null, $postfix = $url -split '#/'
            $newUrl = "$newUrl#/$postfix"
        }

        dl $newUrl $to $cookies $progress
        return
    }

    $total = $wres.ContentLength
    if($total -eq -1 -and $wreq -is [net.ftpwebrequest]) {
        $total = ftp_file_size($url)
    }

    if ($progress -and ($total -gt 0)) {
        [console]::CursorVisible = $false
        function dl_onProgress($read) {
            dl_progress $read $total $url
        }
    } else {
        write-host "Downloading $url ($(filesize $total))..."
        function dl_onProgress {
            #no op
        }
    }

    try {
        $s = $wres.getresponsestream()
        $fs = [io.file]::openwrite($to)
        $buffer = new-object byte[] 2048
        $totalRead = 0
        $sw = [diagnostics.stopwatch]::StartNew()

        dl_onProgress $totalRead
        while(($read = $s.read($buffer, 0, $buffer.length)) -gt 0) {
            $fs.write($buffer, 0, $read)
            $totalRead += $read
            if ($sw.elapsedmilliseconds -gt 100) {
                $sw.restart()
                dl_onProgress $totalRead
            }
        }
        $sw.stop()
        dl_onProgress $totalRead
    } finally {
        if ($progress) {
            [console]::CursorVisible = $true
            write-host
        }
        if ($fs) {
            $fs.close()
        }
        if ($s) {
            $s.close();
        }
        $wres.close()
    }
}

function dl_progress_output($url, $read, $total, $console) {
    $filename = url_remote_filename $url

    # calculate current percentage done
    $p = [math]::Round($read / $total * 100, 0)

    # pre-generate LHS and RHS of progress string
    # so we know how much space we have
    $left  = "$filename ($(filesize $total))"
    $right = [string]::Format("{0,3}%", $p)

    # calculate remaining width for progress bar
    $midwidth  = $console.BufferSize.Width - ($left.Length + $right.Length + 8)

    # calculate how many characters are completed
    $completed = [math]::Abs([math]::Round(($p / 100) * $midwidth, 0) - 1)

    # generate dashes to symbolise completed
    if ($completed -gt 1) {
        $dashes = [string]::Join("", ((1..$completed) | ForEach-Object {"="}))
    }

    # this is why we calculate $completed - 1 above
    $dashes += switch($p) {
        100 {"="}
        default {">"}
    }

    # the remaining characters are filled with spaces
    $spaces = switch($dashes.Length) {
        $midwidth {[string]::Empty}
        default {
            [string]::Join("", ((1..($midwidth - $dashes.Length)) | ForEach-Object {" "}))
        }
    }

    "$left [$dashes$spaces] $right"
}

function dl_progress($read, $total, $url) {
    $console = $host.UI.RawUI;
    $left  = $console.CursorPosition.X;
    $top   = $console.CursorPosition.Y;
    $width = $console.BufferSize.Width;

    if($read -eq 0) {
        $maxOutputLength = $(dl_progress_output $url 100 $total $console).length
        if (($left + $maxOutputLength) -gt $width) {
            # not enough room to print progress on this line
            # print on new line
            write-host
            $left = 0
            $top  = $top + 1
            if($top -gt $console.CursorPosition.Y) { $top = $console.CursorPosition.Y }
        }
    }

    write-host $(dl_progress_output $url $read $total $console) -nonewline
    [console]::SetCursorPosition($left, $top)
}

function dl_urls($app, $version, $manifest, $bucket, $architecture, $dir, $use_cache = $true, $check_hash = $true) {
    # we only want to show this warning once
    if(!$use_cache) { warn "Cache is being ignored." }

    # can be multiple urls: if there are, then msi or installer should go last,
    # so that $fname is set properly
    $urls = @(url $manifest $architecture)

    # can be multiple cookies: they will be used for all HTTP requests.
    $cookies = $manifest.cookie

    $fname = $null

    # extract_dir and extract_to in manifest are like queues: for each url that
    # needs to be extracted, will get the next dir from the queue
    $extract_dirs = @(extract_dir $manifest $architecture)
    $extract_tos = @(extract_to $manifest $architecture)
    $extracted = 0;

    # download first
    if(Test-Aria2Enabled) {
        dl_with_cache_aria2 $app $version $manifest $architecture $dir $cookies $use_cache $check_hash
    } else {
        foreach($url in $urls) {
            $fname = url_filename $url

            try {
                dl_with_cache $app $version $url "$dir\$fname" $cookies $use_cache
            } catch {
                write-host -f darkred $_
                abort "URL $url is not valid"
            }

            if($check_hash) {
                $manifest_hash = hash_for_url $manifest $url $architecture
                $ok, $err = check_hash "$dir\$fname" $manifest_hash $(show_app $app $bucket)
                if(!$ok) {
                    error $err
                    $cached = cache_path $app $version $url
                    if(test-path $cached) {
                        # rm cached file
                        Remove-Item -force $cached
                    }
                    if($url.Contains('sourceforge.net')) {
                        Write-Host -f yellow 'SourceForge.net is known for causing hash validation fails. Please try again before opening a ticket.'
                    }
                    abort $(new_issue_msg $app $bucket "hash check failed")
                }
            }
        }
    }

    foreach($url in $urls) {
        $fname = url_filename $url

        $extract_dir = $extract_dirs[$extracted]
        $extract_to = $extract_tos[$extracted]

        # work out extraction method, if applicable
        $extract_fn = $null
        if ($manifest.innosetup) {
            $extract_fn = 'Expand-InnoArchive'
        } elseif($fname -match '\.zip$') {
            # Use 7zip when available (more fast)
            if (((get_config 7ZIPEXTRACT_USE_EXTERNAL) -and (Test-CommandAvailable 7z)) -or (Test-HelperInstalled -Helper 7zip)) {
                $extract_fn = 'Expand-7zipArchive'
            } else {
                $extract_fn = 'Expand-ZipArchive'
            }
        } elseif($fname -match '\.msi$') {
            # check manifest doesn't use deprecated install method
            if(msi $manifest $architecture) {
                warn "MSI install is deprecated. If you maintain this manifest, please refer to the manifest reference docs."
            } else {
                $extract_fn = 'Expand-MsiArchive'
            }
        } elseif(Test-7zipRequirement -File $fname) { # 7zip
            $extract_fn = 'Expand-7zipArchive'
        }

        if($extract_fn) {
            Write-Host "Extracting " -NoNewline
            Write-Host $fname -f Cyan -NoNewline
            Write-Host " ... " -NoNewline
            & $extract_fn -Path "$dir\$fname" -DestinationPath "$dir\$extract_to" -ExtractDir $extract_dir -Removal
            Write-Host "done." -f Green
            $extracted++
        }
    }

    $fname # returns the last downloaded file
}

function cookie_header($cookies) {
    if(!$cookies) { return }

    $vals = $cookies.psobject.properties | ForEach-Object {
        "$($_.name)=$($_.value)"
    }

    [string]::join(';', $vals)
}

function is_in_dir($dir, $check) {
    $check = "$(fullpath $check)"
    $dir = "$(fullpath $dir)"
    $check -match "^$([regex]::escape("$dir"))(\\|`$)"
}

function ftp_file_size($url) {
    $request = [net.ftpwebrequest]::create($url)
    $request.method = [net.webrequestmethods+ftp]::getfilesize
    $request.getresponse().contentlength
}

# hashes
function hash_for_url($manifest, $url, $arch) {
    $hashes = @(hash $manifest $arch) | Where-Object { $_ -ne $null };

    if($hashes.length -eq 0) { return $null }

    $urls = @(url $manifest $arch)

    $index = [array]::indexof($urls, $url)
    if($index -eq -1) { abort "Couldn't find hash in manifest for '$url'." }

    @($hashes)[$index]
}

# returns (ok, err)
function check_hash($file, $hash, $app_name) {
    $file = fullpath $file
    if(!$hash) {
        warn "Warning: No hash in manifest. SHA256 for '$(fname $file)' is:`n    $(compute_hash $file 'sha256')"
        return $true, $null
    }

    Write-Host "Checking hash of " -NoNewline
    Write-Host $(url_remote_filename $url) -f Cyan -NoNewline
    Write-Host " ... " -nonewline
    $algorithm, $expected = get_hash $hash
    if ($null -eq $algorithm) {
        return $false, "Hash type '$algorithm' isn't supported."
    }

    $actual = compute_hash $file $algorithm
    $expected = $expected.ToLower()

    if($actual -ne $expected) {
        $msg = "Hash check failed!`n"
        $msg += "App:         $app_name`n"
        $msg += "URL:         $url`n"
        if(Test-Path $file) {
            $msg += "First bytes: $((get_magic_bytes_pretty $file ' ').ToUpper())`n"
        }
        if($expected -or $actual) {
            $msg += "Expected:    $expected`n"
            $msg += "Actual:      $actual"
        }
        return $false, $msg
    }
    Write-Host "ok." -f Green
    return $true, $null
}

function compute_hash($file, $algname) {
    try {
        if(Test-CommandAvailable Get-FileHash) {
            return (Get-FileHash -Path $file -Algorithm $algname).Hash.ToLower()
        } else {
            $fs = [system.io.file]::openread($file)
            $alg = [system.security.cryptography.hashalgorithm]::create($algname)
            $hexbytes = $alg.computehash($fs) | ForEach-Object { $_.tostring('x2') }
            return [string]::join('', $hexbytes)
        }
    } catch {
        error $_.exception.message
    } finally {
        if($fs) { $fs.dispose() }
        if($alg) { $alg.dispose() }
    }
    return ''
}

# for dealing with installers
function args($config, $dir, $global) {
    if($config) { return $config | ForEach-Object { (format $_ @{'dir'=$dir;'global'=$global}) } }
    @()
}

function run_installer($fname, $manifest, $architecture, $dir, $global) {
    # MSI or other installer
    $msi = msi $manifest $architecture
    $installer = installer $manifest $architecture
    if($installer.script) {
        write-output "Running installer script..."
        Invoke-Expression (@($installer.script) -join "`r`n")
        return
    }

    if($msi) {
        install_msi $fname $dir $msi
    } elseif($installer) {
        install_prog $fname $dir $installer $global
    }
}

# deprecated (see also msi_installed)
function install_msi($fname, $dir, $msi) {
    $msifile = "$dir\$(coalesce $msi.file "$fname")"
    if(!(is_in_dir $dir $msifile)) {
        abort "Error in manifest: MSI file $msifile is outside the app directory."
    }
    if(!($msi.code)) { abort "Error in manifest: Couldn't find MSI code."}
    if(msi_installed $msi.code) { abort "The MSI package is already installed on this system." }

    $logfile = "$dir\install.log"

    $arg = @("/i `"$msifile`"", '/norestart', "/lvp `"$logfile`"", "TARGETDIR=`"$dir`"",
        "INSTALLDIR=`"$dir`"") + @(args $msi.args $dir)

    if($msi.silent) { $arg += '/qn', 'ALLUSERS=2', 'MSIINSTALLPERUSER=1' }
    else { $arg += '/qb-!' }

    $continue_exit_codes = @{ 3010 = "a restart is required to complete installation" }

    $installed = Invoke-ExternalCommand 'msiexec' $arg -Activity "Running installer..." -ContinueExitCodes $continue_exit_codes
    if(!$installed) {
        abort "Installation aborted. You might need to run 'scoop uninstall $app' before trying again."
    }
    Remove-Item $logfile
    Remove-Item $msifile
}

# deprecated
# get-wmiobject win32_product is slow and checks integrity of each installed program,
# so this uses the [wmi] type accelerator instead
# http://blogs.technet.com/b/heyscriptingguy/archive/2011/12/14/use-powershell-to-find-and-uninstall-software.aspx
function msi_installed($code) {
    $path = "hklm:\software\microsoft\windows\currentversion\uninstall\$code"
    if(!(test-path $path)) { return $false }
    $key = Get-Item $path
    $name = $key.getvalue('displayname')
    $version = $key.getvalue('displayversion')
    $classkey = "IdentifyingNumber=`"$code`",Name=`"$name`",Version=`"$version`""
    try { $wmi = [wmi]"Win32_Product.$classkey"; $true } catch { $false }
}

function install_prog($fname, $dir, $installer, $global) {
    $prog = "$dir\$(coalesce $installer.file "$fname")"
    if(!(is_in_dir $dir $prog)) {
        abort "Error in manifest: Installer $prog is outside the app directory."
    }
    $arg = @(args $installer.args $dir $global)

    if($prog.endswith('.ps1')) {
        & $prog @arg
    } else {
        $installed = Invoke-ExternalCommand $prog $arg -Activity "Running installer..."
        if(!$installed) {
            abort "Installation aborted. You might need to run 'scoop uninstall $app' before trying again."
        }

        # Don't remove installer if "keep" flag is set to true
        if(!($installer.keep -eq "true")) {
            Remove-Item $prog
        }
    }
}

function run_uninstaller($manifest, $architecture, $dir) {
    $msi = msi $manifest $architecture
    $uninstaller = uninstaller $manifest $architecture
    $version = $manifest.version
    if($uninstaller.script) {
        write-output "Running uninstaller script..."
        Invoke-Expression (@($uninstaller.script) -join "`r`n")
        return
    }

    if($msi -or $uninstaller) {
        $exe = $null; $arg = $null; $continue_exit_codes = @{}

        if($msi) {
            $code = $msi.code
            $exe = "msiexec";
            $arg = @("/norestart", "/x $code")
            if($msi.silent) {
                $arg += '/qn', 'ALLUSERS=2', 'MSIINSTALLPERUSER=1'
            } else {
                $arg += '/qb-!'
            }

            $continue_exit_codes.1605 = 'not installed, skipping'
            $continue_exit_codes.3010 = 'restart required'
        } elseif($uninstaller) {
            $exe = "$dir\$($uninstaller.file)"
            $arg = args $uninstaller.args
            if(!(is_in_dir $dir $exe)) {
                warn "Error in manifest: Installer $exe is outside the app directory, skipping."
                $exe = $null;
            } elseif(!(test-path $exe)) {
                warn "Uninstaller $exe is missing, skipping."
                $exe = $null;
            }
        }

        if($exe) {
            if($exe.endswith('.ps1')) {
                & $exe @arg
            } else {
                $uninstalled = Invoke-ExternalCommand $exe $arg -Activity "Running uninstaller..." -ContinueExitCodes $continue_exit_codes
                if(!$uninstalled) { abort "Uninstallation aborted." }
            }
        }
    }
}

# get target, name, arguments for shim
function shim_def($item) {
    if($item -is [array]) { return $item }
    return $item, (strip_ext (fname $item)), $null
}

function create_shims($manifest, $dir, $global, $arch) {
    $shims = @(arch_specific 'bin' $manifest $arch)
    $shims | Where-Object { $_ -ne $null } | ForEach-Object {
        $target, $name, $arg = shim_def $_
        write-output "Creating shim for '$name'."

        if(test-path "$dir\$target" -pathType leaf) {
            $bin = "$dir\$target"
        } elseif(test-path $target -pathType leaf) {
            $bin = $target
        } else {
            $bin = search_in_path $target
        }
        if(!$bin) { abort "Can't shim '$target': File doesn't exist."}

        shim $bin $global $name (substitute $arg @{ '$dir' = $dir; '$original_dir' = $original_dir; '$persist_dir' = $persist_dir})
    }
}

function rm_shim($name, $shimdir) {
    $shim = "$shimdir\$name.ps1"

    if(!(test-path $shim)) { # handle no shim from failed install
        warn "Shim for '$name' is missing. Skipping."
    } else {
        write-output "Removing shim for '$name'."
        Remove-Item $shim
    }

    # other shim types might be present
    '', '.exe', '.shim', '.cmd' | ForEach-Object {
        if(test-path -Path "$shimdir\$name$_" -PathType leaf) {
            Remove-Item "$shimdir\$name$_"
        }
    }
}

function rm_shims($manifest, $global, $arch) {
    $shims = @(arch_specific 'bin' $manifest $arch)

    $shims | Where-Object { $_ -ne $null } | ForEach-Object {
        $target, $name, $null = shim_def $_
        $shimdir = shimdir $global

        rm_shim $name $shimdir
    }
}

# Gets the path for the 'current' directory junction for
# the specified version directory.
function current_dir($versiondir) {
    $parent = split-path $versiondir
    return "$parent\current"
}


# Creates or updates the directory junction for [app]/current,
# pointing to the specified version directory for the app.
#
# Returns the 'current' junction directory if in use, otherwise
# the version directory.
function link_current($versiondir) {
    if(get_config NO_JUNCTIONS) { return $versiondir }

    $currentdir = current_dir $versiondir

    write-host "Linking $(friendly_path $currentdir) => $(friendly_path $versiondir)"

    if($currentdir -eq $versiondir) {
        abort "Error: Version 'current' is not allowed!"
    }

    if(test-path $currentdir) {
        # remove the junction
        attrib -R /L $currentdir
        & "$env:COMSPEC" /c rmdir $currentdir
    }

    & "$env:COMSPEC" /c mklink /j $currentdir $versiondir | out-null
    attrib $currentdir +R /L
    return $currentdir
}

# Removes the directory junction for [app]/current which
# points to the current version directory for the app.
#
# Returns the 'current' junction directory (if it exists),
# otherwise the normal version directory.
function unlink_current($versiondir) {
    if(get_config NO_JUNCTIONS) { return $versiondir }
    $currentdir = current_dir $versiondir

    if(test-path $currentdir) {
        write-host "Unlinking $(friendly_path $currentdir)"

        # remove read-only attribute on link
        attrib $currentdir -R /L

        # remove the junction
        & "$env:COMSPEC" /c "rmdir `"$currentdir`""
        return $currentdir
    }
    return $versiondir
}

# to undo after installers add to path so that scoop manifest can keep track of this instead
function ensure_install_dir_not_in_path($dir, $global) {
    $path = (env 'path' $global)

    $fixed, $removed = find_dir_or_subdir $path "$dir"
    if($removed) {
        $removed | ForEach-Object { "Installer added '$(friendly_path $_)' to path. Removing."}
        env 'path' $global $fixed
    }

    if(!$global) {
        $fixed, $removed = find_dir_or_subdir (env 'path' $true) "$dir"
        if($removed) {
            $removed | ForEach-Object { warn "Installer added '$_' to system path. You might want to remove this manually (requires admin permission)."}
        }
    }
}

function find_dir_or_subdir($path, $dir) {
    $dir = $dir.trimend('\')
    $fixed = @()
    $removed = @()
    $path.split(';') | ForEach-Object {
        if($_) {
            if(($_ -eq $dir) -or ($_ -like "$dir\*")) { $removed += $_ }
            else { $fixed += $_ }
        }
    }
    return [string]::join(';', $fixed), $removed
}

function env_add_path($manifest, $dir, $global, $arch) {
    $env_add_path = arch_specific 'env_add_path' $manifest $arch
    if ($env_add_path) {
        # GH-3785: Add path in ascending order.
        [Array]::Reverse($env_add_path)
        $env_add_path | Where-Object { $_ } | ForEach-Object {
            $path_dir = Join-Path $dir $_

            if (!(is_in_dir $dir $path_dir)) {
                abort "Error in manifest: env_add_path '$_' is outside the app directory."
            }
            add_first_in_path $path_dir $global
        }
    }
}

function env_rm_path($manifest, $dir, $global, $arch) {
    $env_add_path = arch_specific 'env_add_path' $manifest $arch
    $env_add_path | Where-Object { $_ } | ForEach-Object {
        $path_dir = Join-Path $dir $_

        remove_from_path $path_dir $global
    }
}

function env_set($manifest, $dir, $global, $arch) {
    $env_set = arch_specific 'env_set' $manifest $arch
    if ($env_set) {
        $env_set | Get-Member -Member NoteProperty | ForEach-Object {
            $name = $_.name;
            $val = format $env_set.$($_.name) @{ "dir" = $dir }
            env $name $global $val
            Set-Content env:\$name $val
        }
    }
}
function env_rm($manifest, $global, $arch) {
    $env_set = arch_specific 'env_set' $manifest $arch
    if ($env_set) {
        $env_set | Get-Member -Member NoteProperty | ForEach-Object {
            $name = $_.name
            env $name $global $null
            if (Test-Path env:\$name) { Remove-Item env:\$name }
        }
    }
}

function pre_install($manifest, $arch) {
    $pre_install = arch_specific 'pre_install' $manifest $arch
    if($pre_install) {
        write-output "Running pre-install script..."
        Invoke-Expression (@($pre_install) -join "`r`n")
    }
}

function post_install($manifest, $arch) {
    $post_install = arch_specific 'post_install' $manifest $arch
    if($post_install) {
        write-output "Running post-install script..."
        Invoke-Expression (@($post_install) -join "`r`n")
    }
}

function show_notes($manifest, $dir, $original_dir, $persist_dir) {
    if($manifest.notes) {
        write-output "Notes"
        write-output "-----"
        write-output (wraptext (substitute $manifest.notes @{ '$dir' = $dir; '$original_dir' = $original_dir; '$persist_dir' = $persist_dir}))
    }
}

function all_installed($apps, $global) {
    $apps | Where-Object {
        $app, $null, $null = parse_app $_
        installed $app $global
    }
}

# returns (uninstalled, installed)
function prune_installed($apps, $global) {
    $installed = @(all_installed $apps $global)

    $uninstalled = $apps | Where-Object { $installed -notcontains $_ }

    return @($uninstalled), @($installed)
}

# check whether the app failed to install
function failed($app, $global) {
    if (is_directory (appdir $app $global)) {
        return !(install_info $app (current_version $app $global) $global)
    } else {
        return $false
    }
}

function ensure_none_failed($apps, $global) {
    foreach($app in $apps) {
        if(failed $app $global) {
            abort "'$app' install failed previously. Please uninstall it and try again."
        }
    }
}

function show_suggestions($suggested) {
    $installed_apps = (installed_apps $true) + (installed_apps $false)

    foreach($app in $suggested.keys) {
        $features = $suggested[$app] | get-member -type noteproperty | ForEach-Object { $_.name }
        foreach($feature in $features) {
            $feature_suggestions = $suggested[$app].$feature

            $fulfilled = $false
            foreach($suggestion in $feature_suggestions) {
                $suggested_app, $bucket, $null = parse_app $suggestion

                if($installed_apps -contains $suggested_app) {
                    $fulfilled = $true;
                    break;
                }
            }

            if(!$fulfilled) {
                write-host "'$app' suggests installing '$([string]::join("' or '", $feature_suggestions))'."
            }
        }
    }
}

# Persistent data
function persist_def($persist) {
    if ($persist -is [Array]) {
        $source = $persist[0]
        $target = $persist[1]
    } else {
        $source = $persist
        $target = $null
    }

    if (!$target) {
        $target = $source
    }

    return $source, $target
}

function persist_data($manifest, $original_dir, $persist_dir) {
    $persist = $manifest.persist
    if($persist) {
        $persist_dir = ensure $persist_dir

        if ($persist -is [String]) {
            $persist = @($persist);
        }

        $persist | ForEach-Object {
            $source, $target = persist_def $_

            write-host "Persisting $source"

            $source = $source.TrimEnd("/").TrimEnd("\\")

            $source = fullpath "$dir\$source"
            $target = fullpath "$persist_dir\$target"

            # if we have had persist data in the store, just create link and go
            if (Test-Path $target) {
                # if there is also a source data, rename it (to keep a original backup)
                if (Test-Path $source) {
                    Move-Item -Force $source "$source.original"
                }
            # we don't have persist data in the store, move the source to target, then create link
            } elseif (Test-Path $source) {
                # ensure target parent folder exist
                ensure (Split-Path -Path $target) | Out-Null
                Move-Item $source $target
            # we don't have neither source nor target data! we need to crate an empty target,
            # but we can't make a judgement that the data should be a file or directory...
            # so we create a directory by default. to avoid this, use pre_install
            # to create the source file before persisting (DON'T use post_install)
            } else {
                $target = New-Object System.IO.DirectoryInfo($target)
                ensure $target | Out-Null
            }

            # create link
            if (is_directory $target) {
                # target is a directory, create junction
                & "$env:COMSPEC" /c "mklink /j `"$source`" `"$target`"" | out-null
                attrib $source +R /L
            } else {
                # target is a file, create hard link
                & "$env:COMSPEC" /c "mklink /h `"$source`" `"$target`"" | out-null
            }
        }
    }
}

function unlink_persist_data($dir) {
    # unlink all junction / hard link in the directory
    Get-ChildItem -Recurse $dir | ForEach-Object {
        $file = $_
        if ($null -ne $file.LinkType) {
            $filepath = $file.FullName
            # directory (junction)
            if ($file -is [System.IO.DirectoryInfo]) {
                # remove read-only attribute on the link
                attrib -R /L $filepath
                # remove the junction
                & "$env:COMSPEC" /c "rmdir /s /q `"$filepath`""
            } else {
                # remove the hard link
                & "$env:COMSPEC" /c "del `"$filepath`""
            }
        }
    }
}

# check whether write permission for Users usergroup is set to global persist dir, if not then set
function persist_permission($manifest, $global) {
    if($global -and $manifest.persist -and (is_admin)) {
        $path = persistdir $null $global
        $user = New-Object System.Security.Principal.SecurityIdentifier 'S-1-5-32-545'
        $target_rule = New-Object System.Security.AccessControl.FileSystemAccessRule($user, 'Write', 'ObjectInherit', 'none', 'Allow')
        $acl = Get-Acl -Path $path
        $acl.SetAccessRule($target_rule)
        $acl | Set-Acl -Path $path
    }
# adapted from http://hg.python.org/cpython/file/2.7/Lib/getopt.py
# argv:
#    array of arguments
# shortopts:
#    string of single-letter options. options that take a parameter
#    should be follow by ':'
# longopts:
#    array of strings that are long-form options. options that take
#    a parameter should end with '='
# returns @(opts hash, remaining_args array, error string)
function getopt($argv, $shortopts, $longopts) {
    $opts = @{}; $rem = @()

    function err($msg) {
        $opts, $rem, $msg
    }

    function regex_escape($str) {
        return [regex]::escape($str)
    }

    # ensure these are arrays
    $argv = @($argv)
    $longopts = @($longopts)

    for($i = 0; $i -lt $argv.length; $i++) {
        $arg = $argv[$i]
        if($null -eq $arg) { continue }
        # don't try to parse array arguments
        if($arg -is [array]) { $rem += ,$arg; continue }
        if($arg -is [int]) { $rem += $arg; continue }
        if($arg -is [decimal]) { $rem += $arg; continue }

        if($arg.startswith('--')) {
            $name = $arg.substring(2)

            $longopt = $longopts | Where-Object { $_ -match "^$name=?$" }

            if($longopt) {
                if($longopt.endswith('=')) { # requires arg
                    if($i -eq $argv.length - 1) {
                        return err "Option --$name requires an argument."
                    }
                    $opts.$name = $argv[++$i]
                } else {
                    $opts.$name = $true
                }
            } else {
                return err "Option --$name not recognized."
            }
        } elseif($arg.startswith('-') -and $arg -ne '-') {
            for($j = 1; $j -lt $arg.length; $j++) {
                $letter = $arg[$j].tostring()

                if($shortopts -match "$(regex_escape $letter)`:?") {
                    $shortopt = $matches[0]
                    if($shortopt[1] -eq ':') {
                        if($j -ne $arg.length -1 -or $i -eq $argv.length - 1) {
                            return err "Option -$letter requires an argument."
                        }
                        $opts.$letter = $argv[++$i]
                    } else {
                        $opts.$letter = $true
                    }
                } else {
                    return err "Option -$letter not recognized."
                }
            }
        } else {
            $rem += $arg
# versions
function latest_version($app, $bucket, $url) {
    (manifest $app $bucket $url).version
}
function current_version($app, $global) {
    @(versions $app $global)[-1]
}
function versions($app, $global) {
    $appdir = appdir $app $global
    if(!(test-path $appdir)) { return @() }

    sort_versions (Get-ChildItem $appdir -dir -attr !reparsePoint | Where-Object { $null -ne $(Get-ChildItem $_.fullname) } | ForEach-Object { $_.name })
}

function version($ver) {
    $ver -split '[\.-]' | ForEach-Object {
        $num = $_ -as [int]
        if($num) { $num } else { $_ }
    }
}
function compare_versions($a, $b) {
    $ver_a = @(version $a)
    $ver_b = @(version $b)

    for($i=0;$i -lt $ver_a.length;$i++) {
        if($i -gt $ver_b.length) { return 1; }

        # don't try to compare int to string
        if($ver_b[$i] -is [string] -and $ver_a[$i] -isnot [string]) {
            $ver_a[$i] = "$($ver_a[$i])"
        }

        if($ver_a[$i] -gt $ver_b[$i]) { return 1; }
        if($ver_a[$i] -lt $ver_b[$i]) { return -1; }
    }
    if($ver_b.length -gt $ver_a.length) { return -1 }
    return 0
}

function qsort($ary, $fn) {
    if($null -eq $ary) { return @() }
    if(!($ary -is [array])) { return @($ary) }

    $pivot = $ary[0]
    $rem = $ary[1..($ary.length-1)]

    $lesser = qsort ($rem | Where-Object { (& $fn $_ $pivot) -lt 0 }) $fn

    $greater = qsort ($rem | Where-Object { (& $fn $_ $pivot) -ge 0 }) $fn

function Test-7zipRequirement {
    [CmdletBinding(DefaultParameterSetName = "URL")]
    [OutputType([Boolean])]
    param (
        [Parameter(Mandatory = $true, ParameterSetName = "URL")]
        [String[]]
        $URL,
        [Parameter(Mandatory = $true, ParameterSetName = "File")]
        [String]
        $File
    )
    if ($URL) {
        if ((get_config 7ZIPEXTRACT_USE_EXTERNAL)) {
            return $false
        } else {
            return ($URL | Where-Object { Test-7zipRequirement -File $_ }).Count -gt 0
        }
    } else {
        return $File -match '\.((gz)|(tar)|(tgz)|(lzma)|(bz)|(bz2)|(7z)|(rar)|(iso)|(xz)|(lzh)|(nupkg))$'
    }
}

function Test-LessmsiRequirement {
    [CmdletBinding()]
    [OutputType([Boolean])]
    param (
        [Parameter(Mandatory = $true)]
        [String[]]
        $URL
    )
    if ((get_config MSIEXTRACT_USE_LESSMSI)) {
        return ($URL | Where-Object { $_ -match '\.msi$' }).Count -gt 0
    } else {
        return $false
    }
}

function Expand-7zipArchive {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [String]
        $Path,
        [Parameter(Position = 1)]
        [String]
        $DestinationPath = (Split-Path $Path),
        [String]
        $ExtractDir,
        [Parameter(ValueFromRemainingArguments = $true)]
        [String]
        $Switches,
        [ValidateSet("All", "Skip", "Rename")]
        [String]
        $Overwrite,
        [Switch]
        $Removal
    )
    if ((get_config 7ZIPEXTRACT_USE_EXTERNAL)) {
        try {
            $7zPath = (Get-Command '7z' -CommandType Application | Select-Object -First 1).Source
        } catch [System.Management.Automation.CommandNotFoundException] {
            abort "Cannot find external 7-Zip (7z.exe) while '7ZIPEXTRACT_USE_EXTERNAL' is 'true'!`nRun 'scoop config 7ZIPEXTRACT_USE_EXTERNAL false' or install 7-Zip manually and try again."
        }
    } else {
        $7zPath = Get-HelperPath -Helper 7zip
    }
    $LogPath = "$(Split-Path $Path)\7zip.log"
    $ArgList = @('x', "`"$Path`"", "-o`"$DestinationPath`"", '-y')
    $IsTar = ((strip_ext $Path) -match '\.tar$') -or ($Path -match '\.t[abgpx]z2?$')
    if (!$IsTar -and $ExtractDir) {
        $ArgList += "-ir!`"$ExtractDir\*`""
    }
    if ($Switches) {
        $ArgList += (-split $Switches)
    }
    switch ($Overwrite) {
        "All" { $ArgList += "-aoa" }
        "Skip" { $ArgList += "-aos" }
        "Rename" { $ArgList += "-aou" }
    }
    $Status = Invoke-ExternalCommand $7zPath $ArgList -LogPath $LogPath
    if (!$Status) {
        abort "Failed to extract files from $Path.`nLog file:`n  $(friendly_path $LogPath)`n$(new_issue_msg $app $bucket 'decompress error')"
    }
    if (!$IsTar -and $ExtractDir) {
        movedir "$DestinationPath\$ExtractDir" $DestinationPath | Out-Null
    }
    if (Test-Path $LogPath) {
        Remove-Item $LogPath -Force
    }
    if ($IsTar) {
        # Check for tar
        $Status = Invoke-ExternalCommand $7zPath @('l', "`"$Path`"") -LogPath $LogPath
        if ($Status) {
            $TarFile = (Get-Content -Path $LogPath)[-4] -replace '.{53}(.*)', '$1' # get inner tar file name
            Expand-7zipArchive -Path "$DestinationPath\$TarFile" -DestinationPath $DestinationPath -ExtractDir $ExtractDir -Removal
        } else {
            abort "Failed to list files in $Path.`nNot a 7-Zip supported archive file."
        }
    }
    if ($Removal) {
        # Remove original archive file
        Remove-Item $Path -Force
    }
}

function Expand-MsiArchive {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [String]
        $Path,
        [Parameter(Position = 1)]
        [String]
        $DestinationPath = (Split-Path $Path),
        [String]
        $ExtractDir,
        [Parameter(ValueFromRemainingArguments = $true)]
        [String]
        $Switches,
        [Switch]
        $Removal
    )
    $DestinationPath = $DestinationPath.TrimEnd("\")
    if ($ExtractDir) {
        $OriDestinationPath = $DestinationPath
        $DestinationPath = "$DestinationPath\_tmp"
    }
    if ((get_config MSIEXTRACT_USE_LESSMSI)) {
        $MsiPath = Get-HelperPath -Helper Lessmsi
        $ArgList = @('x', "`"$Path`"", "`"$DestinationPath\\`"")
    } else {
        $MsiPath = 'msiexec.exe'
        $ArgList = @('/a', "`"$Path`"", '/qn', "TARGETDIR=`"$DestinationPath\\SourceDir`"")
    }
    $LogPath = "$(Split-Path $Path)\msi.log"
    if ($Switches) {
        $ArgList += (-split $Switches)
    }
    $Status = Invoke-ExternalCommand $MsiPath $ArgList -LogPath $LogPath
    if (!$Status) {
        abort "Failed to extract files from $Path.`nLog file:`n  $(friendly_path $LogPath)`n$(new_issue_msg $app $bucket 'decompress error')"
    }
    if ($ExtractDir -and (Test-Path "$DestinationPath\SourceDir")) {
        movedir "$DestinationPath\SourceDir\$ExtractDir" $OriDestinationPath | Out-Null
        Remove-Item $DestinationPath -Recurse -Force
    } elseif ($ExtractDir) {
        movedir "$DestinationPath\$ExtractDir" $OriDestinationPath | Out-Null
        Remove-Item $DestinationPath -Recurse -Force
    } elseif (Test-Path "$DestinationPath\SourceDir") {
        movedir "$DestinationPath\SourceDir" $DestinationPath | Out-Null
    }
    if (($DestinationPath -ne (Split-Path $Path)) -and (Test-Path "$DestinationPath\$(fname $Path)")) {
        Remove-Item "$DestinationPath\$(fname $Path)" -Force
    }
    if (Test-Path $LogPath) {
        Remove-Item $LogPath -Force
    }
    if ($Removal) {
        # Remove original archive file
        Remove-Item $Path -Force
    }
}

function Expand-InnoArchive {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [String]
        $Path,
        [Parameter(Position = 1)]
        [String]
        $DestinationPath = (Split-Path $Path),
        [String]
        $ExtractDir,
        [Parameter(ValueFromRemainingArguments = $true)]
        [String]
        $Switches,
        [Switch]
        $Removal
    )
    $LogPath = "$(Split-Path $Path)\innounp.log"
    $ArgList = @('-x', "-d`"$DestinationPath`"", "`"$Path`"", '-y')
    switch -Regex ($ExtractDir) {
        "^[^{].*" { $ArgList += "-c{app}\$ExtractDir" }
        "^{.*" { $ArgList += "-c$ExtractDir" }
        Default { $ArgList += "-c{app}" }
    }
    if ($Switches) {
        $ArgList += (-split $Switches)
    }
    $Status = Invoke-ExternalCommand (Get-HelperPath -Helper Innounp) $ArgList -LogPath $LogPath
    if (!$Status) {
        abort "Failed to extract files from $Path.`nLog file:`n  $(friendly_path $LogPath)`n$(new_issue_msg $app $bucket 'decompress error')"
    }
    if (Test-Path $LogPath) {
        Remove-Item $LogPath -Force
    }
    if ($Removal) {
        # Remove original archive file
        Remove-Item $Path -Force
    }
}

function Expand-ZipArchive {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [String]
        $Path,
        [Parameter(Position = 1)]
        [String]
        $DestinationPath = (Split-Path $Path),
        [String]
        $ExtractDir,
        [Switch]
        $Removal
    )
    if ($ExtractDir) {
        $OriDestinationPath = $DestinationPath
        $DestinationPath = "$DestinationPath\_tmp"
    }
    # All methods to unzip the file require .NET4.5+
    if ($PSVersionTable.PSVersion.Major -lt 5) {
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        try {
            [System.IO.Compression.ZipFile]::ExtractToDirectory($Path, $DestinationPath)
        } catch [System.IO.PathTooLongException] {
            # try to fall back to 7zip if path is too long
            if (Test-HelperInstalled -Helper 7zip) {
                Expand-7zipArchive $Path $DestinationPath -Removal
                return
            } else {
                abort "Unzip failed: Windows can't handle the long paths in this zip file.`nRun 'scoop install 7zip' and try again."
            }
        } catch [System.IO.IOException] {
            if (Test-HelperInstalled -Helper 7zip) {
                Expand-7zipArchive $Path $DestinationPath -Removal
                return
            } else {
                abort "Unzip failed: Windows can't handle the file names in this zip file.`nRun 'scoop install 7zip' and try again."
            }
        } catch {
            abort "Unzip failed: $_"
        }
    } else {
        # Use Expand-Archive to unzip in PowerShell 5+
        # Compatible with Pscx (https://github.com/Pscx/Pscx)
        Microsoft.PowerShell.Archive\Expand-Archive -Path $Path -DestinationPath $DestinationPath -Force
    }
    if ($ExtractDir) {
        movedir "$DestinationPath\$ExtractDir" $OriDestinationPath | Out-Null
        Remove-Item $DestinationPath -Recurse -Force
    }
    if ($Removal) {
        # Remove original archive file
        Remove-Item $Path -Force
    }
}

function Expand-DarkArchive {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [String]
        $Path,
        [Parameter(Position = 1)]
        [String]
        $DestinationPath = (Split-Path $Path),
        [Parameter(ValueFromRemainingArguments = $true)]
        [String]
        $Switches,
        [Switch]
        $Removal
    )
    $LogPath = "$(Split-Path $Path)\dark.log"
    $ArgList = @('-nologo', "-x `"$DestinationPath`"", "`"$Path`"")
    if ($Switches) {
        $ArgList += (-split $Switches)
    }
    $Status = Invoke-ExternalCommand (Get-HelperPath -Helper Dark) $ArgList -LogPath $LogPath
    if (!$Status) {
        abort "Failed to extract files from $Path.`nLog file:`n  $(friendly_path $LogPath)`n$(new_issue_msg $app $bucket 'decompress error')"
    }
    if (Test-Path $LogPath) {
        Remove-Item $LogPath -Force
    }
    if ($Removal) {
        # Remove original archive file
        Remove-Item $Path -Force
    }
}

function extract_7zip($path, $to, $removal) {
    Show-DeprecatedWarning $MyInvocation 'Expand-7zipArchive'
    Expand-7zipArchive -Path $path -DestinationPath $to -Removal:$removal @args
}

function extract_msi($path, $to, $removal) {
    Show-DeprecatedWarning $MyInvocation 'Expand-MsiArchive'
    Expand-MsiArchive -Path $path -DestinationPath $to -Removal:$removal
}

function unpack_inno($path, $to, $removal) {
    Show-DeprecatedWarning $MyInvocation 'Expand-InnoArchive'
    Expand-InnoArchive -Path $path -DestinationPath $to -Removal:$removal @args
}

function extract_zip($path, $to, $removal) {
    Show-DeprecatedWarning $MyInvocation 'Expand-ZipArchive'
. "$psscriptroot/core.ps1"
. "$psscriptroot/autoupdate.ps1"

function manifest_path($app, $bucket) {
    fullpath "$(Find-BucketDirectory $bucket)\$(sanitary_path $app).json"
}

function parse_json($path) {
    if(!(test-path $path)) { return $null }
    Get-Content $path -raw -Encoding UTF8 | convertfrom-json -ea stop
}

function url_manifest($url) {
    $str = $null
    try {
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        $str = $wc.downloadstring($url)
    } catch [system.management.automation.methodinvocationexception] {
        warn "error: $($_.exception.innerexception.message)"
    } catch {
        throw
    }
    if(!$str) { return $null }
    $str | convertfrom-json
}

function manifest($app, $bucket, $url) {
    if($url) { return url_manifest $url }
    parse_json (manifest_path $app $bucket)
}

function save_installed_manifest($app, $bucket, $dir, $url) {
    if($url) {
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        $wc.downloadstring($url) > "$dir\manifest.json"
    } else {
        Copy-Item (manifest_path $app $bucket) "$dir\manifest.json"
    }
}

function installed_manifest($app, $version, $global) {
    parse_json "$(versiondir $app $version $global)\manifest.json"
}

function save_install_info($info, $dir) {
    $nulls = $info.keys | Where-Object { $null -eq $info[$_] }
    $nulls | ForEach-Object { $info.remove($_) } # strip null-valued

    $file_content = $info | ConvertToPrettyJson
    [System.IO.File]::WriteAllLines("$dir\install.json", $file_content)
}

function install_info($app, $version, $global) {
    $path = "$(versiondir $app $version $global)\install.json"
    if(!(test-path $path)) { return $null }
    parse_json $path
}

function default_architecture {
    $arch = get_config 'default-architecture'
    $system = if ([Environment]::Is64BitOperatingSystem) { '64bit' } else { '32bit' }
    if ($null -eq $arch) {
        $arch = $system
    } else {
        try {
            $arch = ensure_architecture $arch
        } catch {
            warn 'Invalid default architecture configured. Determining default system architecture'
            $arch = $system
        }
    }

    return $arch
}

function arch_specific($prop, $manifest, $architecture) {
    if($manifest.architecture) {
        $val = $manifest.architecture.$architecture.$prop
        if($val) { return $val } # else fallback to generic prop
    }

    if($manifest.$prop) { return $manifest.$prop }
}

function supports_architecture($manifest, $architecture) {
    return -not [String]::IsNullOrEmpty((arch_specific 'url' $manifest $architecture))
}

function generate_user_manifest($app, $bucket, $version) {
    $null, $manifest, $bucket, $null = Find-Manifest $app $bucket
    if ("$($manifest.version)" -eq "$version") {
        return manifest_path $app $bucket
    }
    warn "Given version ($version) does not match manifest ($($manifest.version))"
    warn "Attempting to generate manifest for '$app' ($version)"

    if (!($manifest.autoupdate)) {
        abort "'$app' does not have autoupdate capability`r`ncouldn't find manifest for '$app@$version'"
    }

    ensure $(usermanifestsdir) | out-null
    try {
        autoupdate $app "$(resolve-path $(usermanifestsdir))" $manifest $version $(@{})
        return "$(resolve-path $(usermanifest $app))"
    } catch {
        write-host -f darkred "Could not install $app@$version"
    }

    return $null
}

function url($manifest, $arch) { arch_specific 'url' $manifest $arch }
function installer($manifest, $arch) { arch_specific 'installer' $manifest $arch }
<#
TODO
 - clean up
#>
. "$psscriptroot\..\lib\json.ps1"

. "$psscriptroot/core.ps1"
. "$psscriptroot/json.ps1"

function find_hash_in_rdf([String] $url, [String] $basename) {
    $data = $null
    try {
        # Download and parse RDF XML file
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('Referer', (strip_filename $url))
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        [xml]$data = $wc.downloadstring($url)
    } catch [system.net.webexception] {
        write-host -f darkred $_
        write-host -f darkred "URL $url is not valid"
        return $null
    }

    # Find file content
    $digest = $data.RDF.Content | Where-Object { [String]$_.about -eq $basename }

    return format_hash $digest.sha256
}

function find_hash_in_textfile([String] $url, [Hashtable] $substitutions, [String] $regex) {
    $hashfile = $null

    $templates = @{
        '$md5' = '([a-fA-F0-9]{32})';
        '$sha1' = '([a-fA-F0-9]{40})';
        '$sha256' = '([a-fA-F0-9]{64})';
        '$sha512' = '([a-fA-F0-9]{128})';
        '$checksum' = '([a-fA-F0-9]{32,128})';
        '$base64' = '([a-zA-Z0-9+\/=]{24,88})';
    }

    try {
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('Referer', (strip_filename $url))
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        $hashfile = $wc.downloadstring($url)
    } catch [system.net.webexception] {
        write-host -f darkred $_
        write-host -f darkred "URL $url is not valid"
        return
    }

    if ($regex.Length -eq 0) {
        $regex = '^([a-fA-F0-9]+)$'
    }

    $regex = substitute $regex $templates $false
    $regex = substitute $regex $substitutions $true
    debug $regex
    if ($hashfile -match $regex) {
        $hash = $matches[1] -replace '\s',''
    }

    # convert base64 encoded hash values
    if ($hash -match '^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$') {
        $base64 = $matches[0]
        if(!($hash -match '^[a-fA-F0-9]+$') -and $hash.length -notin @(32, 40, 64, 128)) {
            try {
                $hash = ([System.Convert]::FromBase64String($base64) | ForEach-Object { $_.ToString('x2') }) -join ''
            } catch {
                $hash = $hash
            }
        }
    }

    # find hash with filename in $hashfile
    if ($hash.Length -eq 0) {
        $filenameRegex = "([a-fA-F0-9]{32,128})[\x20\t]+.*`$basename(?:[\x20\t]+\d+)?"
        $filenameRegex = substitute $filenameRegex $substitutions $true
        if ($hashfile -match $filenameRegex) {
            $hash = $matches[1]
        }
        $metalinkRegex = "<hash[^>]+>([a-fA-F0-9]{64})"
        if ($hashfile -match $metalinkRegex) {
            $hash = $matches[1]
        }
    }

    return format_hash $hash
}

function find_hash_in_json([String] $url, [Hashtable] $substitutions, [String] $jsonpath) {
    $json = $null

    try {
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('Referer', (strip_filename $url))
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        $json = $wc.downloadstring($url)
    } catch [system.net.webexception] {
        write-host -f darkred $_
        write-host -f darkred "URL $url is not valid"
        return
    }
    $hash = json_path $json $jsonpath $substitutions
    if(!$hash) {
        $hash = json_path_legacy $json $jsonpath $substitutions
    }
    return format_hash $hash
}

function find_hash_in_xml([String] $url, [Hashtable] $substitutions, [String] $xpath) {
    $xml = $null

    try {
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('Referer', (strip_filename $url))
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        $xml = [xml]$wc.downloadstring($url)
    } catch [system.net.webexception] {
        write-host -f darkred $_
        write-host -f darkred "URL $url is not valid"
        return
    }

    # Replace placeholders
    if ($substitutions) {
        $xpath = substitute $xpath $substitutions
    }

    # Find all `significant namespace declarations` from the XML file
    $nsList = $xml.SelectNodes("//namespace::*[not(. = ../../namespace::*)]")
    # Then add them into the NamespaceManager
    $nsmgr = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $nsList | ForEach-Object {
        $nsmgr.AddNamespace($_.LocalName, $_.Value)
    }

    # Getting hash from XML, using XPath
    $hash = $xml.SelectSingleNode($xpath, $nsmgr).'#text'
    return format_hash $hash
}

function find_hash_in_headers([String] $url) {
    $hash = $null

    try {
        $req = [System.Net.WebRequest]::Create($url)
        $req.Referer = (strip_filename $url)
        $req.AllowAutoRedirect = $false
        $req.UserAgent = (Get-UserAgent)
        $req.Timeout = 2000
        $req.Method = 'HEAD'
        $res = $req.GetResponse()
        if(([int]$response.StatusCode -ge 300) -and ([int]$response.StatusCode -lt 400)) {
            if($res.Headers['Digest'] -match 'SHA-256=([^,]+)' -or $res.Headers['Digest'] -match 'SHA=([^,]+)' -or $res.Headers['Digest'] -match 'MD5=([^,]+)') {
                $hash = ([System.Convert]::FromBase64String($matches[1]) | ForEach-Object { $_.ToString('x2') }) -join ''
                debug $hash
            }
        }
        $res.Close()
    } catch [system.net.webexception] {
        write-host -f darkred $_
        write-host -f darkred "URL $url is not valid"
        return
    }

    return format_hash $hash
}

function get_hash_for_app([String] $app, $config, [String] $version, [String] $url, [Hashtable] $substitutions) {
    $hash = $null

    $hashmode = $config.mode
    $basename = [System.Web.HttpUtility]::UrlDecode((url_remote_filename($url)))

    $substitutions = $substitutions.Clone()
    $substitutions.Add('$url', (strip_fragment $url))
    $substitutions.Add('$baseurl', (strip_filename (strip_fragment $url)).TrimEnd('/'))
    $substitutions.Add('$basename', $basename)
    $substitutions.Add('$urlNoExt', (strip_ext (strip_fragment $url)))
    $substitutions.Add('$basenameNoExt', (strip_ext $basename))

    debug $substitutions

    $hashfile_url = substitute $config.url $substitutions
    debug $hashfile_url
    if ($hashfile_url) {
        write-host -f DarkYellow 'Searching hash for ' -NoNewline
        write-host -f Green $basename -NoNewline
        write-host -f DarkYellow ' in ' -NoNewline
        write-host -f Green $hashfile_url
    }

    if ($hashmode.Length -eq 0 -and $config.url.Length -ne 0) {
        $hashmode = 'extract'
    }

    $jsonpath = ''
    if ($config.jp) {
        $jsonpath = $config.jp
        $hashmode = 'json'
    }
    if ($config.jsonpath) {
        $jsonpath = $config.jsonpath
        $hashmode = 'json'
    }
    $regex = ''
    if ($config.find) {
        $regex = $config.find
    }
    if ($config.regex) {
        $regex = $config.regex
    }

    $xpath = ''
    if ($config.xpath) {
        $xpath = $config.xpath
        $hashmode = 'xpath'
    }

    if (!$hashfile_url -and $url -match "^(?:.*fosshub.com\/).*(?:\/|\?dwl=)(?<filename>.*)$") {
        $hashmode = 'fosshub'
    }

    if (!$hashfile_url -and $url -match "(?:downloads\.)?sourceforge.net\/projects?\/(?<project>[^\/]+)\/(?:files\/)?(?<file>.*)") {
        $hashmode = 'sourceforge'
    }

    switch ($hashmode) {
        'extract' {
            $hash = find_hash_in_textfile $hashfile_url $substitutions $regex
        }
        'json' {
            $hash = find_hash_in_json $hashfile_url $substitutions $jsonpath
        }
        'xpath' {
            $hash = find_hash_in_xml $hashfile_url $substitutions $xpath
        }
        'rdf' {
            $hash = find_hash_in_rdf $hashfile_url $basename
        }
        'metalink' {
            $hash = find_hash_in_headers $url
            if (!$hash) {
                $hash = find_hash_in_textfile "$url.meta4" $substitutions
            }
        }
        'fosshub' {
            $hash = find_hash_in_textfile $url $substitutions ($Matches.filename+'.*?"sha256":"([a-fA-F0-9]{64})"')
        }
        'sourceforge' {
            # change the URL because downloads.sourceforge.net doesn't have checksums
            $hashfile_url = (strip_filename (strip_fragment "https://sourceforge.net/projects/$($matches['project'])/files/$($matches['file'])")).TrimEnd('/')
            $hash = find_hash_in_textfile $hashfile_url $substitutions '"$basename":.*?"sha1":\s"([a-fA-F0-9]{40})"'
        }
    }

    if ($hash) {
        # got one!
        write-host -f DarkYellow 'Found: ' -NoNewline
        write-host -f Green $hash -NoNewline
        write-host -f DarkYellow ' using ' -NoNewline
        write-host -f Green  "$((Get-Culture).TextInfo.ToTitleCase($hashmode)) Mode"
        return $hash
    } elseif ($hashfile_url) {
        write-host -f DarkYellow "Could not find hash in $hashfile_url"
    }

    write-host -f DarkYellow 'Downloading ' -NoNewline
    write-host -f Green $basename -NoNewline
    write-host -f DarkYellow ' to compute hashes!'
    try {
        dl_with_cache $app $version $url $null $null $true
    } catch [system.net.webexception] {
        write-host -f darkred $_
        write-host -f darkred "URL $url is not valid"
        return $null
    }
    $file = fullpath (cache_path $app $version $url)
    $hash = compute_hash $file 'sha256'
    write-host -f DarkYellow 'Computed hash: ' -NoNewline
    write-host -f Green $hash
    return $hash
}

function update_manifest_with_new_version($json, [String] $version, [String] $url, [String] $hash, $architecture = $null) {
    $json.version = $version

    if ($null -eq $architecture) {
        if ($json.url -is [System.Array]) {
            $json.url[0] = $url
            $json.hash[0] = $hash
        } else {
            $json.url = $url
            $json.hash = $hash
        }
    } else {
        # If there are multiple urls we replace the first one
        if ($json.architecture.$architecture.url -is [System.Array]) {
            $json.architecture.$architecture.url[0] = $url
            $json.architecture.$architecture.hash[0] = $hash
        } else {
            $json.architecture.$architecture.url = $url
            $json.architecture.$architecture.hash = $hash
        }
    }
}

function update_manifest_prop([String] $prop, $json, [Hashtable] $substitutions) {
    # first try the global property
    if ($json.$prop -and $json.autoupdate.$prop) {
        $json.$prop = substitute $json.autoupdate.$prop $substitutions
    }

    # check if there are architecture specific variants
    if ($json.architecture -and $json.autoupdate.architecture) {
        $json.architecture | Get-Member -MemberType NoteProperty | ForEach-Object {
            $architecture = $_.Name
            if ($json.architecture.$architecture.$prop -and $json.autoupdate.architecture.$architecture.$prop) {
                $json.architecture.$architecture.$prop = substitute (arch_specific $prop $json.autoupdate $architecture) $substitutions
            }
        }
    }
}

function get_version_substitutions([String] $version, [Hashtable] $customMatches) {
    $firstPart = $version.Split('-') | Select-Object -first 1
    $lastPart = $version.Split('-') | Select-Object -last 1
    $versionVariables = @{
        '$version' = $version;
        '$underscoreVersion' = ($version -replace "\.", "_");
        '$dashVersion' = ($version -replace "\.", "-");
        '$cleanVersion' = ($version -replace "\.", "");
        '$majorVersion' = $firstPart.Split('.') | Select-Object -first 1;
        '$minorVersion' = $firstPart.Split('.') | Select-Object -skip 1 -first 1;
        '$patchVersion' = $firstPart.Split('.') | Select-Object -skip 2 -first 1;
        '$buildVersion' = $firstPart.Split('.') | Select-Object -skip 3 -first 1;
        '$preReleaseVersion' = $lastPart;
    }
    if($version -match "(?<head>\d+\.\d+(?:\.\d+)?)(?<tail>.*)") {
        $versionVariables.Set_Item('$matchHead', $matches['head'])
        $versionVariables.Set_Item('$matchTail', $matches['tail'])
    }
    if($customMatches) {
        $customMatches.GetEnumerator() | ForEach-Object {
            if($_.Name -ne "0") {
                $versionVariables.Set_Item('$match' + (Get-Culture).TextInfo.ToTitleCase($_.Name), $_.Value)
            }
        }
    }
    return $versionVariables
}

function autoupdate([String] $app, $dir, $json, [String] $version, [Hashtable] $matches) {
    Write-Host -f DarkCyan "Autoupdating $app"
    $has_changes = $false
    $has_errors = $false
    [Bool]$valid = $true
    $substitutions = get_version_substitutions $version $matches

    if ($json.url) {
        # create new url
        $url   = substitute $json.autoupdate.url $substitutions
        $valid = $true

        if($valid) {
            # create hash
            $hash = get_hash_for_app $app $json.autoupdate.hash $version $url $substitutions
            if ($null -eq $hash) {
                $valid = $false
                Write-Host -f DarkRed "Could not find hash!"
            }
        }

        # write changes to the json object
        if ($valid) {
            $has_changes = $true
            update_manifest_with_new_version $json $version $url $hash
        } else {
            $has_errors = $true
            throw "Could not update $app"
        }
    } else {
        $json.architecture | Get-Member -MemberType NoteProperty | ForEach-Object {
            $valid = $true
            $architecture = $_.Name

            # create new url
            $url   = substitute (arch_specific "url" $json.autoupdate $architecture) $substitutions
            $valid = $true

            if($valid) {
                # create hash
                $hash = get_hash_for_app $app (arch_specific "hash" $json.autoupdate $architecture) $version $url $substitutions
                if ($null -eq $hash) {
                    $valid = $false
                    Write-Host -f DarkRed "Could not find hash!"
                }
            }

            # write changes to the json object
            if ($valid) {
                $has_changes = $true
                update_manifest_with_new_version $json $version $url $hash $architecture
            } else {
                $has_errors = $true
                throw "Could not update $app $architecture"
            }
        }
    }

    # update properties
    update_manifest_prop "extract_dir" $json $substitutions

    # update license
    update_manifest_prop "license" $json $substitutions

    if ($has_changes -and !$has_errors) {
        # write file
        Write-Host -f DarkGreen "Writing updated $app manifest"

        $path = join-path $dir "$app.json"

        $file_content = $json | ConvertToPrettyJson
        [System.IO.File]::WriteAllLines($path, $file_content)

        # notes
        if ($json.autoupdate.note) {
            Write-Host ""
            Write-Host -f DarkYellow $json.autoupdate.note
        }
    } else {
        Write-Host -f DarkGray "No updates for $app"
    }
if([String]::IsNullOrEmpty($MyInvocation.PSScriptRoot)) {
    Write-Error 'This script should not be called directly! It has to be imported from a buckets test file!'
    exit 1
}

. "$psscriptroot\Scoop-TestLib.ps1"
. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\unix.ps1"

$repo_dir = (Get-Item $MyInvocation.PSScriptRoot).FullName

$repo_files = @(Get-ChildItem $repo_dir -file -recurse)

$project_file_exclusions = @(
    $([regex]::Escape($repo_dir)+'(\\|/).git(\\|/).*$'),
    '.sublime-workspace$',
    '.DS_Store$',
    'supporting(\\|/)validator(\\|/)packages(\\|/)*'
)

$bucketdir = $repo_dir
if(Test-Path("$repo_dir\bucket")) {
    $bucketdir = "$repo_dir\bucket"
}
. "$psscriptroot\..\libexec\scoop-alias.ps1" | out-null

reset_aliases

describe "add_alias" -Tag 'Scoop' {
  mock shimdir { "TestDrive:\shim" }
  mock set_config { }
  mock get_config { @{} }

  $shimdir = shimdir
  mkdir $shimdir

  context "alias doesn't exist" {
    it "creates a new alias" {
      $alias_file = "$shimdir\scoop-rm.ps1"
      $alias_file | should -not -exist

      add_alias "rm" '"hello, world!"'
      Invoke-Expression $alias_file | should -be "hello, world!"
    }
  }

  context "alias exists" {
    it "does not change existing alias" {
      $alias_file = "$shimdir\scoop-rm.ps1"
      new-item $alias_file -type file
      $alias_file | should -exist

      add_alias "rm" "test"
      $alias_file | should -FileContentMatch ""
    }
  }
}

describe "rm_alias" {
  mock shimdir { "TestDrive:\shim" }
  mock set_config { }
  mock get_config { @{} }

  $shimdir = shimdir
  mkdir $shimdir

  context "alias exists" {
    it "removes an existing alias" {
      $alias_file = "$shimdir\scoop-rm.ps1"
      add_alias "rm" '"hello, world!"'

      $alias_file | should -exist
      mock get_config { @(@{"rm" = "scoop-rm"}) }

. "$psscriptroot\Scoop-TestLib.ps1"
. "$psscriptroot\..\lib\getopt.ps1"

describe "getopt" -Tag 'Scoop' {
    it 'handle short option with required argument missing' {
        $null, $null, $err = getopt '-x' 'x:' ''
        $err | should -be 'Option -x requires an argument.'

        $null, $null, $err = getopt '-xy' 'x:y' ''
        $err | should -be 'Option -x requires an argument.'
    }

    it 'handle long option with required argument missing' {
        $null, $null, $err = getopt '--arb' '' 'arb='
        $err | should -be 'Option --arb requires an argument.'
    }

    it 'handle unrecognized short option' {
        $null, $null, $err = getopt '-az' 'a' ''
        $err | should -be 'Option -z not recognized.'
    }

    it 'handle unrecognized long option' {
        $null, $null, $err = getopt '--non-exist' '' ''
        $err | should -be 'Option --non-exist not recognized.'

        $null, $null, $err = getopt '--global','--another' 'abc:de:' 'global','one'
        $err | should -be 'Option --another not recognized.'
    }

    it 'remaining args returned' {
        $opt, $rem, $err = getopt '-g','rem' 'g' ''
        $err | should -benullorempty
        $opt.g | should -betrue
        $rem | should -not -benullorempty
        $rem.length | should -be 1
        $rem[0] | should -be 'rem'
    }

    it 'get a long flag and a short option with argument' {
        $a = "--global -a 32bit test" -split ' '
        $opt, $rem, $err = getopt $a 'ga:' 'global','arch='

        $err | should -benullorempty
        $opt.global | should -betrue
        $opt.a | should -be '32bit'
    }

    it 'handles regex characters' {
        $a = "-?"
        { $opt, $rem, $err = getopt $a 'ga:' 'global' 'arch=' } | should -not -throw
        { $null, $null, $null = getopt $a '?:' 'help' | should -not -throw }
    }

    it 'handles short option without required argument' {
        $null, $null, $err = getopt '-x' 'x' ''
        $err | should -benullorempty
    }

    it 'handles long option without required argument' {
        $opt, $null, $err = getopt '--long-arg' '' 'long-arg'
        $err | should -benullorempty
        $opt."long-arg" | should -betrue
    }

    it 'handles long option with required argument' {
        $opt, $null, $err = getopt '--long-arg', 'test' '' 'long-arg='
        $err | should -benullorempty
        $opt."long-arg" | should -be "test"
    }
param($bucketdir = "$psscriptroot\..\bucket\")
. "$psscriptroot\Scoop-TestLib.ps1"
. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"

describe -Tag 'Manifests' "manifest-validation" {
    beforeall {
        $working_dir = setup_working "manifest"
        $schema = "$psscriptroot/../schema.json"
        Add-Type -Path "$psscriptroot\..\supporting\validator\bin\Newtonsoft.Json.dll"
        Add-Type -Path "$psscriptroot\..\supporting\validator\bin\Newtonsoft.Json.Schema.dll"
        Add-Type -Path "$psscriptroot\..\supporting\validator\bin\Scoop.Validator.dll"
    }

    it "Scoop.Validator is available" {
        ([System.Management.Automation.PSTypeName]'Scoop.Validator').Type | should -be 'Scoop.Validator'
    }

    context "parse_json function" {
        it "fails with invalid json" {
            { parse_json "$working_dir\broken_wget.json" } | should -throw
        }
    }

    context "schema validation" {
        it "fails with broken schema" {
            $validator = new-object Scoop.Validator("$working_dir/broken_schema.json", $true)
            $validator.Validate("$working_dir/wget.json") | should -BeFalse
            $validator.Errors.Count | should -be 1
            $validator.Errors | select-object -First 1 | should -match "broken_schema.*(line 6).*(position 4)"
        }
        it "fails with broken manifest" {
            $validator = new-object Scoop.Validator($schema, $true)
            $validator.Validate("$working_dir/broken_wget.json") | should -BeFalse
            $validator.Errors.Count | should -be 1
            $validator.Errors | select-object -First 1 | should -match "broken_wget.*(line 5).*(position 4)"
        }
        it "fails with invalid manifest" {
            $validator = new-object Scoop.Validator($schema, $true)
            $validator.Validate("$working_dir/invalid_wget.json") | should -BeFalse
            $validator.Errors.Count | should -be 16
            $validator.Errors | select-object -First 1 | should -match "Property 'randomproperty' has not been defined and the schema does not allow additional properties\."
            $validator.Errors | select-object -Last 1 | should -match "Required properties are missing from object: version\."
        }
    }

    context "manifest validates against the schema" {
        beforeall {
            if ($null -eq $bucketdir) {
                $bucketdir = "$psscriptroot\..\bucket\"
            }
            $changed_manifests = @()
            if($env:CI -eq $true) {
                $commit = if($env:APPVEYOR_PULL_REQUEST_HEAD_COMMIT) { $env:APPVEYOR_PULL_REQUEST_HEAD_COMMIT } else { $env:APPVEYOR_REPO_COMMIT }
                $changed_manifests = (Get-GitChangedFile -Include '*.json' -Commit $commit)
            }
            $manifest_files = Get-ChildItem $bucketdir *.json
            $validator = new-object Scoop.Validator($schema, $true)
        }

        $quota_exceeded = $false

        $manifest_files | ForEach-Object {
            $skip_manifest = ($changed_manifests -inotcontains $_.FullName)
            if($env:CI -ne $true -or $changed_manifests -imatch 'schema.json') {
                $skip_manifest = $false
            }
            it "$_" -skip:$skip_manifest {
                $file = $_ # exception handling may overwrite $_

                if(!($quota_exceeded)) {
                    try {
                        $validator.Validate($file.fullname)

                        if ($validator.Errors.Count -gt 0) {
                            write-host -f red "      [-] $_ has $($validator.Errors.Count) Error$(If($validator.Errors.Count -gt 1) { 's' })!"
                            write-host -f yellow $validator.ErrorsAsString
                        }
                        $validator.Errors.Count | should -be 0
                    } catch {
                        if($_.exception.message -like '*The free-quota limit of 1000 schema validations per hour has been reached.*') {
                            $quota_exceeded = $true
                            write-host -f darkyellow 'Schema validation limit exceeded. Will skip further validations.'
                        } else {
                            throw
                        }
                    }
                }

                $manifest = parse_json $file.fullname
                $url = arch_specific "url" $manifest "32bit"
                $url64 = arch_specific "url" $manifest "64bit"
                if(!$url) {
                    $url = $url64
                }
. "$psscriptroot\Scoop-TestLib.ps1"
. "$psscriptroot\..\lib\versions.ps1"

describe "versions" -Tag 'Scoop' {
    it 'compares versions with integer-string mismatch' {
        $a = '1.8.9'
        $b = '1.8.5-1'
        $res = compare_versions $a $b

        $res | should -be 1
    }

    it 'handles plain string version comparison to int version' {
        $a = 'latest'
        $b = '20150405'
        $res = compare_versions $a $b

        $res | should -be 1
    }

    it 'handles dashed version components' {
        $a = '7.0.4-9'
        $b = '7.0.4-10'

        $res = compare_versions $a $b

        $res | should -be -1
    }

    it 'handles comparsion against en empty string' {
        compare_versions '7.0.4-9' '' | should -be 1
    }

    it 'handles equal versions' {
        compare_versions '12.0' '12.0' | should -be 0
if(!$script:run) { $script:run = 0 }
if(!$script:failed) { $script:failed = 0 }

function filter_tests($arg) {
    if(!$arg) { return }
    $script:filter = $arg -join ' '
    write-host "filtering by '$filter'"
}
function test($desc, $assertions) {
    if($filter -and $desc -notlike "*$filter*") { return }
    $script:test = $desc
    $script:run++
    try {
        $assertions.invoke()
    } catch {
        script:fail $_.exception.innerexception.message
    }
    $script:test = $null
}

function assert($x,$eq='__undefined',$ne='__undefined') {
    if($args.length -gt 0) {
        fail "unexpected arguments: $args"
    }

    if($eq -ne "__undefined") {
        if($x -ne $eq) { fail "$(fmt $x) != $(fmt $eq)" }
    } elseif ($ne -ne "__undefined") {
        if($x -eq $ne) { fail "$(fmt $x) == $(fmt $ne)" }
    } else {
        if(!$x) { fail "$x" }
    }
}

function test_results {
    $col = 'darkgreen'
    $res = 'all passed'
    if($script:failed -gt 0) {
        $col = 'darkred'
        $res = "$script:failed failed"
    }

    write-host "ran $script:run tests, " -nonewline
    write-host $res -f $col
}

function script:fail($msg) {
    $script:failed++
    $invoked = (get-variable -scope 1 myinvocation).value

    $script = split-path $invoked.scriptname -leaf
    $line = $invoked.scriptlinenumber

    if($script:test) { $msg = "$script:test`r`n      -> $msg" }

    write-host "FAIL: $msg" -f darkred
    write-host "$script line $line`:"
    write-host (($invoked.positionmessage -split "`r`n")[1..2] -join "`r`n")
}

function script:fmt($var) {
    if($null -eq $var) { return "`$null" }
    if($var -is [string]) { return "'$var'" }
    return $var
}

# copies fixtures to a working directory
function setup_working($name) {
    $fixtures = "$psscriptroot/fixtures/$name"
    if(!(test-path $fixtures)) {
        write-host "couldn't find fixtures for $name at $fixtures" -f red
        exit 1
    }

    # reset working dir
    if($PSVersionTable.Platform -eq 'Unix') {
        $working_dir = "/tmp/ScoopTestFixtures/$name"
    } else {
        $working_dir = "$env:TEMP/ScoopTestFixtures/$name"
    }

    if(test-path $working_dir) {
        Remove-Item -Recurse -Force $working_dir
    }

. "$PSScriptRoot\..\lib\core.ps1"

Describe "config" -Tag 'Scoop' {
    BeforeAll {
        $json = '{ "one": 1, "two": [ { "a": "a" }, "b", 2 ], "three": { "four": 4 }, "five": true, "six": false, "seven": "\/Date(1529917395805)\/", "eight": "2019-03-18T15:22:09.3930000+00:00" }'
    }

    It "converts JSON to PSObject" {
        $obj = ConvertFrom-Json $json

        $obj.one | Should -BeExactly 1
        $obj.two[0].a | Should -Be "a"
        $obj.two[1] | Should -Be "b"
        $obj.two[2] | Should -BeExactly 2
        $obj.three.four | Should -BeExactly 4
        $obj.five | Should -BeTrue
        $obj.six | Should -BeFalse
        $obj.seven | Should -BeOfType [System.DateTime]
        if($PSVersionTable.PSVersion.Major -lt 6) {
            $obj.eight | Should -BeOfType [System.String]
        } else {
            $obj.eight | Should -BeOfType [System.DateTime]
        }
    }

    It "load_config should return PSObject" {
        Mock Get-Content { $json }
        Mock Test-Path { $true }
        (load_cfg 'file') | Should -Not -BeNullOrEmpty
        (load_cfg 'file') | Should -BeOfType [System.Management.Automation.PSObject]
        (load_cfg 'file').one | Should -BeExactly 1
    }

    It "get_config should return exactly the same values" {
        $scoopConfig = ConvertFrom-Json $json
        get_config 'does_not_exist' 'default' | Should -Be 'default'

        get_config 'one' | Should -BeExactly 1
        (get_config 'two')[0].a | Should -Be "a"
        (get_config 'two')[1] | Should -Be "b"
        (get_config 'two')[2] | Should -BeExactly 2
        (get_config 'three').four | Should -BeExactly 4
        get_config 'five' | Should -BeTrue
        get_config 'six' | Should -BeFalse
        get_config 'seven' | Should -BeOfType [System.DateTime]
        if($PSVersionTable.PSVersion.Major -lt 6) {
            get_config 'eight' | Should -BeOfType [System.String]
        } else {
            get_config 'eight' | Should -BeOfType [System.DateTime]
        }
    }

    It "set_config should create a new PSObject and ensure existing directory" {
        $scoopConfig = $null
        $configFile = "$PSScriptRoot\.scoop"

        Mock ensure { $PSScriptRoot } -Verifiable -ParameterFilter { $dir -eq (Split-Path -Path $configFile) }
        Mock Set-Content {} -Verifiable -ParameterFilter { $Path -eq $configFile }
        Mock ConvertTo-Json { '' } -Verifiable -ParameterFilter { $InputObject -is [System.Management.Automation.PSObject] }

        set_config 'does_not_exist' 'default'

        Assert-VerifiableMock
    }

    It "set_config should remove a value if set to `$null" {
        $scoopConfig = New-Object PSObject
        $scoopConfig | Add-Member -MemberType NoteProperty -Name 'should_be_removed' -Value 'a_value'
        $scoopConfig | Add-Member -MemberType NoteProperty -Name 'should_stay' -Value 'another_value'
        $configFile = "$PSScriptRoot\.scoop"

        Mock Set-Content {} -Verifiable -ParameterFilter { $Path -eq $configFile }
        Mock ConvertTo-Json { '' } -Verifiable -ParameterFilter { $InputObject -is [System.Management.Automation.PSObject] }

        $scoopConfig = set_config 'should_be_removed' $null
        $scoopConfig.should_be_removed | Should -BeNullOrEmpty
        $scoopConfig.should_stay | Should -Be 'another_value'

        Assert-VerifiableMock
    }
Write-Host "PowerShell: $($PSVersionTable.PSVersion)"
(7z.exe | Select-String -Pattern '7-Zip').ToString()
Write-Host "Install dependencies ..."
Install-Module -Repository PSGallery -Scope CurrentUser -Force -Name Pester -RequiredVersion 4.10.1 -SkipPublisherCheck
Install-Module -Repository PSGallery -Scope CurrentUser -Force -Name PSScriptAnalyzer,BuildHelpers

if ($env:CI_WINDOWS -eq $true) {
    # Do not force maintainers to have this inside environment appveyor config
    if (-not $env:SCOOP_HELPERS) {
        $env:SCOOP_HELPERS = 'C:\projects\helpers'
        [System.Environment]::SetEnvironmentVariable('SCOOP_HELPERS', $env:SCOOP_HELPERS, 'Machine')
    }

    if(!(Test-Path $env:SCOOP_HELPERS)) {
        New-Item -ItemType Directory -Path $env:SCOOP_HELPERS
    }
    if(!(Test-Path "$env:SCOOP_HELPERS\lessmsi\lessmsi.exe")) {
        Start-FileDownload 'https://github.com/activescott/lessmsi/releases/download/v1.6.3/lessmsi-v1.6.3.zip' -FileName "$env:SCOOP_HELPERS\lessmsi.zip"
        & 7z.exe x "$env:SCOOP_HELPERS\lessmsi.zip" -o"$env:SCOOP_HELPERS\lessmsi" -y
    }
    if(!(Test-Path "$env:SCOOP_HELPERS\innounp\innounp.exe")) {
        Start-FileDownload 'https://raw.githubusercontent.com/ScoopInstaller/Binary/master/innounp/innounp048.rar' -FileName "$env:SCOOP_HELPERS\innounp.rar"
        & 7z.exe x "$env:SCOOP_HELPERS\innounp.rar" -o"$env:SCOOP_HELPERS\innounp" -y
    }
}

if($env:CI -eq $true) {
    Write-Host "Load 'BuildHelpers' environment variables ..."
    Set-BuildEnvironment -Force
}

$buildVariables = ( Get-ChildItem -Path 'Env:' ).Where( { $_.Name -match "^(?:BH|CI(?:_|$)|APPVEYOR)" } )
$buildVariables += ( Get-Variable -Name 'CI_*' -Scope 'Script' )
$details = $buildVariables |
    Where-Object -FilterScript { $_.Name -notmatch 'EMAIL' } |
#requires -Version 5.0
#requires -Modules @{ ModuleName = 'BuildHelpers'; ModuleVersion = '2.0.1' }
#requires -Modules @{ ModuleName = 'Pester'; ModuleVersion = '4.4.0' }
#requires -Modules @{ ModuleName = 'PSScriptAnalyzer'; ModuleVersion = '1.17.1' }
param(
    [String] $TestPath = 'test/'
)

$resultsXml = "$PSScriptRoot/TestResults.xml"
$excludes = @()

$splat = @{
    Path         = $TestPath
    OutputFile   = $resultsXml
    OutputFormat = 'NUnitXML'
    PassThru     = $true
}

if ($env:CI -eq $true) {
    $commit = if ($env:APPVEYOR_PULL_REQUEST_HEAD_COMMIT) { $env:APPVEYOR_PULL_REQUEST_HEAD_COMMIT } else { $env:APPVEYOR_REPO_COMMIT }
    $commitMessage = "$env:APPVEYOR_REPO_COMMIT_MESSAGE $env:APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED".TrimEnd()

    if ($commitMessage -match '!linter') {
        Write-Warning "Skipping code linting per commit flag '!linter'"
        $excludes += 'Linter'
    }

    $changed_scripts = (Get-GitChangedFile -Include '*.ps1' -Commit $commit)
    if (!$changed_scripts) {
        Write-Warning "Skipping tests and code linting for *.ps1 files because they didn't change"
        $excludes += 'Linter'
        $excludes += 'Scoop'
    }

    $changed_scripts = (Get-GitChangedFile -Include '*decompress.ps1' -Commit $commit)
    if (!$changed_scripts) {
        Write-Warning "Skipping tests and code linting for decompress.ps1 files because it didn't change"
        $excludes += 'Decompress'
    }

    if ($env:CI_WINDOWS -ne $true) {
        Write-Warning "Skipping tests and code linting for decompress.ps1 because they only work on Windows"
        $excludes += 'Decompress'
    }

    if ($commitMessage -match '!manifests') {
        Write-Warning "Skipping manifest validation per commit flag '!manifests'"
        $excludes += 'Manifests'
    }

    $changed_manifests = (Get-GitChangedFile -Include '*.json' -Commit $commit)
    if (!$changed_manifests) {
        Write-Warning "Skipping tests and validation for manifest files because they didn't change"
        $excludes += 'Manifests'
    }

    if ($excludes.Length -gt 0) {
        $splat.ExcludeTag = $excludes
    }
}

Write-Host 'Invoke-Pester' @splat
$result = Invoke-Pester @splat

(New-Object Net.WebClient).UploadFile("https://ci.appveyor.com/api/testresults/nunit/$($env:APPVEYOR_JOB_ID)", $resultsXml)
. "$psscriptroot\Scoop-TestLib.ps1"
. "$psscriptroot\..\lib\json.ps1"
. "$psscriptroot\..\lib\manifest.ps1"

Describe 'Pretty json formating' -Tag 'Scoop' {
    BeforeAll {
        $format = "$PSScriptRoot\fixtures\format"
        $manifests = Get-ChildItem "$format\formated" -File -Filter '*.json'
    }

    Context 'Beautify manifest' {
        $manifests | ForEach-Object {
            if ($PSVersionTable.PSVersion.Major -gt 5) { $_ = $_.Name } # Fix for pwsh

            It "$_" {
                $pretty_json = (parse_json "$format\unformated\$_") | ConvertToPrettyJson
                $correct = (Get-Content "$format\formated\$_") -join "`r`n"
                $correct.CompareTo($pretty_json) | Should Be 0
            }
        }
if([String]::IsNullOrEmpty($MyInvocation.PSScriptRoot)) {
    Write-Error 'This script should not be called directly! It has to be imported from a buckets test file!'
    exit 1
}

describe 'Style constraints for non-binary project files' {

    $files = @(
        # gather all files except '*.exe', '*.zip', or any .git repository files
        $repo_files |
            where-object { $_.fullname -inotmatch $($project_file_exclusions -join '|') } |
            where-object { $_.fullname -inotmatch '(.exe|.zip|.dll)$' } |
            where-object { $_.fullname -inotmatch '(unformated)' }
    )

    $files_exist = ($files.Count -gt 0)

    it $('non-binary project files exist ({0} found)' -f $files.Count) -skip:$(-not $files_exist) {
        if (-not ($files.Count -gt 0))
        {
            throw "No non-binary project were found"
        }
    }

    it 'files do not contain leading UTF-8 BOM' -skip:$(-not $files_exist) {
        # UTF-8 BOM == 0xEF 0xBB 0xBF
        # see http://www.powershellmagazine.com/2012/12/17/pscxtip-how-to-determine-the-byte-order-mark-of-a-text-file @@ https://archive.is/RgT42
        # ref: http://poshcode.org/2153 @@ https://archive.is/sGnnu
        $badFiles = @(
            foreach ($file in $files)
            {
                if((Get-Command Get-Content).parameters.ContainsKey('AsByteStream')) {
                    # PowerShell Core (6.0+) '-Encoding byte' is replaced by '-AsByteStream'
                    $content = ([char[]](Get-Content $file.FullName -AsByteStream -TotalCount 3) -join '')
                } else {
                    $content = ([char[]](Get-Content $file.FullName -Encoding byte -TotalCount 3) -join '')
                }
                if ([regex]::match($content, '(?ms)^\xEF\xBB\xBF').success) {
                    $file.FullName
                }
            }
        )

        if ($badFiles.Count -gt 0)
        {
            throw "The following files have utf-8 BOM: `r`n`r`n$($badFiles -join "`r`n")"
        }
    }

    it 'files end with a newline' -skip:$(-not $files_exist) {
        $badFiles = @(
            foreach ($file in $files)
            {
                # Ignore previous TestResults.xml
                if ($file -match "TestResults.xml") {
                    continue
                }
                $string = [System.IO.File]::ReadAllText($file.FullName)
                if ($string.Length -gt 0 -and $string[-1] -ne "`n")
                {
                    $file.FullName
                }
            }
        )

        if ($badFiles.Count -gt 0)
        {
            throw "The following files do not end with a newline: `r`n`r`n$($badFiles -join "`r`n")"
        }
    }

    it 'file newlines are CRLF' -skip:$(-not $files_exist) {
        $badFiles = @(
            foreach ($file in $files)
            {
                $content = Get-Content -raw $file.FullName
                if(!$content) {
                    throw "File contents are null: $($file.FullName)"
                }
                $lines = [regex]::split($content, '\r\n')
                $lineCount = $lines.Count

                for ($i = 0; $i -lt $lineCount; $i++)
                {
                    if ( [regex]::match($lines[$i], '\r|\n').success )
                    {
                        $file.FullName
                        break
                    }
                }
            }
        )

        if ($badFiles.Count -gt 0)
        {
            throw "The following files have non-CRLF line endings: `r`n`r`n$($badFiles -join "`r`n")"
        }
    }

    it 'files have no lines containing trailing whitespace' -skip:$(-not $files_exist) {
        $badLines = @(
            foreach ($file in $files)
            {
                # Ignore previous TestResults.xml
                if ($file -match "TestResults.xml") {
                    continue
                }
                $lines = [System.IO.File]::ReadAllLines($file.FullName)
                $lineCount = $lines.Count

                for ($i = 0; $i -lt $lineCount; $i++)
                {
                    if ($lines[$i] -match '\s+$')
                    {
                        'File: {0}, Line: {1}' -f $file.FullName, ($i + 1)
                    }
                }
            }
        )

        if ($badLines.Count -gt 0)
        {
            throw "The following $($badLines.Count) lines contain trailing whitespace: `r`n`r`n$($badLines -join "`r`n")"
        }
    }

    it 'any leading whitespace consists only of spaces (excepting makefiles)' -skip:$(-not $files_exist) {
        $badLines = @(
            foreach ($file in $files)
            {
                if ($file.fullname -inotmatch '(^|.)makefile$')
                {
                    $lines = [System.IO.File]::ReadAllLines($file.FullName)
                    $lineCount = $lines.Count

                    for ($i = 0; $i -lt $lineCount; $i++)
                    {
                        if ($lines[$i] -notmatch '^[ ]*(\S|$)')
                        {
                            'File: {0}, Line: {1}' -f $file.FullName, ($i + 1)
                        }
                    }
                }
            }
        )

        if ($badLines.Count -gt 0)
        {
            throw "The following $($badLines.Count) lines contain TABs within leading whitespace: `r`n`r`n$($badLines -join "`r`n")"
        }
$repo_dir = (Get-Item $MyInvocation.MyCommand.Path).Directory.Parent.FullName

$repo_files = @( Get-ChildItem $repo_dir -file -recurse -force )

$project_file_exclusions = @(
    $([regex]::Escape($repo_dir)+'(\\|/).git(\\|/).*$'),
    '.sublime-workspace$',
    '.DS_Store$',
    'supporting(\\|/)validator(\\|/)packages(\\|/)*',
    'supporting(\\|/)shimexe(\\|/)packages(\\|/)*'
)

describe 'Project code' {

    $files = @(
        $repo_files |
            where-object { $_.fullname -inotmatch $($project_file_exclusions -join '|') } |
            where-object { $_.fullname -imatch '.(ps1|psm1)$' }
    )

    $files_exist = ($files.Count -gt 0)

    it $('PowerShell code files exist ({0} found)' -f $files.Count) -skip:$(-not $files_exist) {
        if (-not ($files.Count -gt 0))
        {
            throw "No PowerShell code files were found"
        }
    }

    function Test-PowerShellSyntax {
        # ref: http://powershell.org/wp/forums/topic/how-to-check-syntax-of-scripts-automatically @@ https://archive.is/xtSv6
        # originally created by Alexander Petrovskiy & Dave Wyatt
        [CmdletBinding()]
        param (
            [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
            [string[]]
            $Path
        )

        process {
            foreach ($scriptPath in $Path) {
                $contents = Get-Content -Path $scriptPath

                if ($null -eq $contents) {
                    continue
                }

                $errors = $null
                $null = [System.Management.Automation.PSParser]::Tokenize($contents, [ref]$errors)

                New-Object psobject -Property @{
                    Path = $scriptPath
                    SyntaxErrorsFound = ($errors.Count -gt 0)
                }
            }
        }
    }

    it 'PowerShell code files do not contain syntax errors' -skip:$(-not $files_exist) {
        $badFiles = @(
            foreach ($file in $files)
            {
                if ( (Test-PowerShellSyntax $file.FullName).SyntaxErrorsFound )
                {
                    $file.FullName
                }
            }
        )

        if ($badFiles.Count -gt 0)
        {
            throw "The following files have syntax errors: `r`n`r`n$($badFiles -join "`r`n")"
        }
    }

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\unix.ps1"
. "$psscriptroot\Scoop-TestLib.ps1"

$repo_dir = (Get-Item $MyInvocation.MyCommand.Path).directory.parent.FullName
$isUnix = is_unix

describe "Get-AppFilePath" -Tag 'Scoop' {
    beforeall {
        $working_dir = setup_working "is_directory"
        Mock versiondir { 'local' } -Verifiable -ParameterFilter { $global -eq $false }
        Mock versiondir { 'global' } -Verifiable -ParameterFilter { $global -eq $true }
    }

    it "should return locally installed program" {
        Mock Test-Path { $true } -Verifiable -ParameterFilter { $Path -eq 'local\i_am_a_file.txt' }
        Mock Test-Path { $false } -Verifiable -ParameterFilter { $Path -eq 'global\i_am_a_file.txt' }
        Get-AppFilePath -App 'is_directory' -File 'i_am_a_file.txt' | Should -Be 'local\i_am_a_file.txt'
    }

    it "should return globally installed program" {
        Mock Test-Path { $false } -Verifiable -ParameterFilter { $Path -eq 'local\i_am_a_file.txt' }
        Mock Test-Path { $true } -Verifiable -ParameterFilter { $Path -eq 'global\i_am_a_file.txt' }
        Get-AppFilePath -App 'is_directory' -File 'i_am_a_file.txt' | Should -Be 'global\i_am_a_file.txt'
    }

    it "should return null if program is not installed" {
        Get-AppFilePath -App 'is_directory' -File 'i_do_not_exist' | Should -BeNullOrEmpty
    }

    it "should throw if parameter is wrong or missing" {
        { Get-AppFilePath -App 'is_directory' -File } | Should -Throw
        { Get-AppFilePath -App -File 'i_am_a_file.txt' } | Should -Throw
        { Get-AppFilePath -App -File } | Should -Throw
    }
}

describe "Get-HelperPath" -Tag 'Scoop' {
    beforeall {
        $working_dir = setup_working "is_directory"
    }
    it "should return path if program is installed" {
        Mock Get-AppFilePath { '7zip\current\7z.exe' }
        Get-HelperPath -Helper 7zip | Should -Be '7zip\current\7z.exe'
    }

    it "should return null if program is not installed" {
        Mock Get-AppFilePath { $null }
        Get-HelperPath -Helper 7zip | Should -BeNullOrEmpty
    }

    it "should throw if parameter is wrong or missing" {
        { Get-HelperPath -Helper } | Should -Throw
        { Get-HelperPath -Helper Wrong } | Should -Throw
    }
}


describe "Test-HelperInstalled" -Tag 'Scoop' {
    it "should return true if program is installed" {
        Mock Get-HelperPath { '7z.exe' }
        Test-HelperInstalled -Helper 7zip | Should -BeTrue
    }

    it "should return false if program is not installed" {
        Mock Get-HelperPath { $null }
        Test-HelperInstalled -Helper 7zip | Should -BeFalse
    }

    it "should throw if parameter is wrong or missing" {
        { Test-HelperInstalled -Helper } | Should -Throw
        { Test-HelperInstalled -Helper Wrong } | Should -Throw
    }
}

describe "Test-Aria2Enabled" -Tag 'Scoop' {
    it "should return true if aria2 is installed" {
        Mock Test-HelperInstalled { $true }
        Mock get_config { $true }
        Test-Aria2Enabled | Should -BeTrue
    }

    it "should return false if aria2 is not installed" {
        Mock Test-HelperInstalled { $false }
        Mock get_config { $false }
        Test-Aria2Enabled | Should -BeFalse

        Mock Test-HelperInstalled { $false }
        Mock get_config { $true }
        Test-Aria2Enabled | Should -BeFalse

        Mock Test-HelperInstalled { $true }
        Mock get_config { $false }
        Test-Aria2Enabled | Should -BeFalse
    }
}

describe "Test-CommandAvailable" -Tag 'Scoop' {
    it "should return true if command exists" {
        Test-CommandAvailable 'Write-Host' | Should -BeTrue
    }

    it "should return false if command doesn't exist" {
        Test-CommandAvailable 'Write-ThisWillProbablyNotExist' | Should -BeFalse
    }

    it "should throw if parameter is wrong or missing" {
        { Test-CommandAvailable } | Should -Throw
    }
}


describe "is_directory" -Tag 'Scoop' {
    beforeall {
        $working_dir = setup_working "is_directory"
    }

    it "is_directory recognize directories" {
        is_directory "$working_dir\i_am_a_directory" | should -be $true
    }
    it "is_directory recognize files" {
        is_directory "$working_dir\i_am_a_file.txt" | should -be $false
    }

    it "is_directory is falsey on unknown path" {
        is_directory "$working_dir\i_do_not_exist" | should -be $false
    }
}

describe "movedir" -Tag 'Scoop' {
    $extract_dir = "subdir"
    $extract_to = $null

    beforeall {
        $working_dir = setup_working "movedir"
    }

    it "moves directories with no spaces in path" -skip:$isUnix {
        $dir = "$working_dir\user"
        movedir "$dir\_tmp\$extract_dir" "$dir\$extract_to"

        "$dir\test.txt" | should -FileContentMatch "this is the one"
        "$dir\_tmp\$extract_dir" | should -not -exist
    }

    it "moves directories with spaces in path" -skip:$isUnix {
        $dir = "$working_dir\user with space"
        movedir "$dir\_tmp\$extract_dir" "$dir\$extract_to"

        "$dir\test.txt" | should -FileContentMatch "this is the one"
        "$dir\_tmp\$extract_dir" | should -not -exist

        # test trailing \ in from dir
        movedir "$dir\_tmp\$null" "$dir\another"
        "$dir\another\test.txt" | should -FileContentMatch "testing"
        "$dir\_tmp" | should -not -exist
    }

    it "moves directories with quotes in path" -skip:$isUnix {
        $dir = "$working_dir\user with 'quote"
        movedir "$dir\_tmp\$extract_dir" "$dir\$extract_to"

        "$dir\test.txt" | should -FileContentMatch "this is the one"
        "$dir\_tmp\$extract_dir" | should -not -exist
    }
}

describe "shim" -Tag 'Scoop' {
    beforeall {
        $working_dir = setup_working "shim"
        $shimdir = shimdir
        $(ensure_in_path $shimdir) | out-null
    }

    it "links a file onto the user's path" -skip:$isUnix {
        { get-command "shim-test" -ea stop } | should -throw
        { get-command "shim-test.ps1" -ea stop } | should -throw
        { get-command "shim-test.cmd" -ea stop } | should -throw
        { shim-test } | should -throw

        shim "$working_dir\shim-test.ps1" $false "shim-test"
        { get-command "shim-test" -ea stop } | should -not -throw
        { get-command "shim-test.ps1" -ea stop } | should -not -throw
        { get-command "shim-test.cmd" -ea stop } | should -not -throw
        shim-test | should -be "Hello, world!"
    }

    context "user with quote" {
        it "shims a file with quote in path" -skip:$isUnix {
            { get-command "shim-test" -ea stop } | should -throw
            { shim-test } | should -throw

            shim "$working_dir\user with 'quote\shim-test.ps1" $false "shim-test"
            { get-command "shim-test" -ea stop } | should -not -throw
            shim-test | should -be "Hello, world!"
        }
    }

    aftereach {
        rm_shim "shim-test" $shimdir
    }
}

describe "rm_shim" -Tag 'Scoop' {
    beforeall {
        $working_dir = setup_working "shim"
        $shimdir = shimdir
        $(ensure_in_path $shimdir) | out-null
    }

    it "removes shim from path" -skip:$isUnix {
        shim "$working_dir\shim-test.ps1" $false "shim-test"

        rm_shim "shim-test" $shimdir

        { get-command "shim-test" -ea stop } | should -throw
        { get-command "shim-test.ps1" -ea stop } | should -throw
        { get-command "shim-test.cmd" -ea stop } | should -throw
        { shim-test } | should -throw
    }
}

Describe "get_app_name_from_ps1_shim" -Tag 'Scoop' {
    BeforeAll {
        $working_dir = setup_working "shim"
        $shimdir = shimdir
        $(ensure_in_path $shimdir) | Out-Null
    }

    It "returns empty string if file does not exist" -skip:$isUnix {
        get_app_name_from_ps1_shim "non-existent-file" | should -be ""
    }

    It "returns app name if file exists and is a shim to an app" -skip:$isUnix {
        mkdir -p "$working_dir/mockapp/current/"
        Write-Output "" | Out-File "$working_dir/mockapp/current/mockapp.ps1"
        shim "$working_dir/mockapp/current/mockapp.ps1" $false "shim-test"
        $shim_path = (get-command "shim-test.ps1").Path
        get_app_name_from_ps1_shim "$shim_path" | should -be "mockapp"
    }

    It "returns empty string if file exists and is not a shim" -skip:$isUnix {
        Write-Output "lorem ipsum" | Out-File -Encoding ascii "$working_dir/mock-shim.ps1"
        get_app_name_from_ps1_shim "$working_dir/mock-shim.ps1" | should -be ""
    }

    AfterEach {
        if (Get-Command "shim-test" -ErrorAction SilentlyContinue) {
            rm_shim "shim-test" $shimdir -ErrorAction SilentlyContinue
        }
        Remove-Item -Force -Recurse -ErrorAction SilentlyContinue "$working_dir/mockapp"
        Remove-Item -Force -ErrorAction SilentlyContinue "$working_dir/moch-shim.ps1"
    }
}

describe "ensure_robocopy_in_path" -Tag 'Scoop' {
    $shimdir = shimdir $false
    mock versiondir { $repo_dir }

    beforeall {
        reset_aliases
    }

    context "robocopy is not in path" {
        it "shims robocopy when not on path" -skip:$isUnix {
            mock Test-CommandAvailable { $false }
            Test-CommandAvailable robocopy | should -be $false

            ensure_robocopy_in_path

            "$shimdir/robocopy.ps1" | should -exist
            "$shimdir/robocopy.exe" | should -exist

            # clean up
            rm_shim robocopy $(shimdir $false) | out-null
        }
    }

    context "robocopy is in path" {
        it "does not shim robocopy when it is in path" -skip:$isUnix {
            mock Test-CommandAvailable { $true }
            Test-CommandAvailable robocopy | should -be $true

            ensure_robocopy_in_path

            "$shimdir/robocopy.ps1" | should -not -exist
            "$shimdir/robocopy.exe" | should -not -exist
        }
    }
}

describe 'sanitary_path' -Tag 'Scoop' {
  it 'removes invalid path characters from a string' {
    $path = 'test?.json'
    $valid_path = sanitary_path $path

    $valid_path | should -be "test.json"
  }
}

describe 'app' -Tag 'Scoop' {
    it 'parses the bucket name from an app query' {
        $query = "C:\test.json"
        $app, $bucket, $version = parse_app $query
        $app | should -be "C:\test.json"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = "test.json"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test.json"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = ".\test.json"
        $app, $bucket, $version = parse_app $query
        $app | should -be ".\test.json"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = "..\test.json"
        $app, $bucket, $version = parse_app $query
        $app | should -be "..\test.json"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = "\\share\test.json"
        $app, $bucket, $version = parse_app $query
        $app | should -be "\\share\test.json"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = "https://example.com/test.json"
        $app, $bucket, $version = parse_app $query
        $app | should -be "https://example.com/test.json"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = "test"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = "extras/enso"
        $app, $bucket, $version = parse_app $query
        $app | should -be "enso"
        $bucket | should -be "extras"
        $version | should -benullorempty

        $query = "test-app"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test-app"
        $bucket | should -benullorempty
        $version | should -benullorempty

        $query = "test-bucket/test-app"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test-app"
        $bucket | should -be "test-bucket"
        $version | should -benullorempty

        $query = "test-bucket/test-app@1.8.0"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test-app"
        $bucket | should -be "test-bucket"
        $version | should -be "1.8.0"

        $query = "test-bucket/test-app@1.8.0-rc2"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test-app"
        $bucket | should -be "test-bucket"
        $version | should -be "1.8.0-rc2"

        $query = "test-bucket/test_app"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test_app"
        $bucket | should -be "test-bucket"
        $version | should -benullorempty

        $query = "test-bucket/test_app@1.8.0"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test_app"
        $bucket | should -be "test-bucket"
        $version | should -be "1.8.0"

        $query = "test-bucket/test_app@1.8.0-rc2"
        $app, $bucket, $version = parse_app $query
        $app | should -be "test_app"
. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\unix.ps1"
. "$psscriptroot\Scoop-TestLib.ps1"

$isUnix = is_unix

describe "ensure_architecture" -Tag 'Scoop' {
    it "should keep correct architectures" {
        ensure_architecture "32bit" | should -be "32bit"
        ensure_architecture "32" | should -be "32bit"
        ensure_architecture "x86" | should -be "32bit"
        ensure_architecture "X86" | should -be "32bit"
        ensure_architecture "i386" | should -be "32bit"
        ensure_architecture "386" | should -be "32bit"
        ensure_architecture "i686" | should -be "32bit"

        ensure_architecture "64bit" | should -be "64bit"
        ensure_architecture "64" | should -be "64bit"
        ensure_architecture "x64" | should -be "64bit"
        ensure_architecture "X64" | should -be "64bit"
        ensure_architecture "amd64" | should -be "64bit"
        ensure_architecture "AMD64" | should -be "64bit"
        ensure_architecture "x86_64" | should -be "64bit"
        ensure_architecture "x86-64" | should -be "64bit"
    }

    it "should fallback to the default architecture on empty input" {
        ensure_architecture "" | should -be $(default_architecture)
        ensure_architecture $null | should -be $(default_architecture)
    }

    it "should show an error with an invalid architecture" {
        { ensure_architecture "PPC" } | Should -Throw
        { ensure_architecture "PPC" } | Should -Throw "Invalid architecture: 'ppc'"
    }
}

describe "appname_from_url" -Tag 'Scoop' {
    it "should extract the correct name" {
        appname_from_url "https://example.org/directory/foobar.json" | should -be "foobar"
    }
}

describe "url_filename" -Tag 'Scoop' {
    it "should extract the real filename from an url" {
        url_filename "http://example.org/foo.txt" | should -be "foo.txt"
        url_filename "http://example.org/foo.txt?var=123" | should -be "foo.txt"
    }

    it "can be tricked with a hash to override the real filename" {
        url_filename "http://example.org/foo-v2.zip#/foo.zip" | should -be "foo.zip"
    }
}

describe "url_remote_filename" -Tag 'Scoop' {
    it "should extract the real filename from an url" {
        url_remote_filename "http://example.org/foo.txt" | should -be "foo.txt"
        url_remote_filename "http://example.org/foo.txt?var=123" | should -be "foo.txt"
    }

    it "can not be tricked with a hash to override the real filename" {
        url_remote_filename "http://example.org/foo-v2.zip#/foo.zip" | should -be "foo-v2.zip"
    }
}

describe "is_in_dir" -Tag 'Scoop' {
    it "should work correctly" -skip:$isUnix {
        is_in_dir "C:\test" "C:\foo" | should -BeFalse
        is_in_dir "C:\test" "C:\test\foo\baz.zip" | should -betrue

        is_in_dir "test" "$psscriptroot" | should -betrue
        is_in_dir "$psscriptroot\..\" "$psscriptroot" | should -BeFalse
    }
}

describe "env add and remove path" -Tag 'Scoop' {
    # test data
    $manifest = @{
        "env_add_path" = @("foo", "bar")
    }
    $testdir = join-path $psscriptroot "path-test-directory"
    $global = $false

    # store the original path to prevent leakage of tests
    $origPath = $env:PATH

    it "should concat the correct path" -skip:$isUnix {
        mock add_first_in_path {}
        mock remove_from_path {}

        # adding
        env_add_path $manifest $testdir $global
        Assert-MockCalled add_first_in_path -Times 1 -ParameterFilter {$dir -like "$testdir\foo"}
        Assert-MockCalled add_first_in_path -Times 1 -ParameterFilter {$dir -like "$testdir\bar"}

        env_rm_path $manifest $testdir $global
        Assert-MockCalled remove_from_path -Times 1 -ParameterFilter {$dir -like "$testdir\foo"}
        Assert-MockCalled remove_from_path -Times 1 -ParameterFilter {$dir -like "$testdir\bar"}
    }
}

describe "shim_def" -Tag 'Scoop' {
    it "should use strings correctly" {
        $target, $name, $shimArgs = shim_def "command.exe"
        $target | should -be "command.exe"
        $name | should -be "command"
        $shimArgs | should -benullorempty
    }

    it "should expand the array correctly" {
        $target, $name, $shimArgs = shim_def @("foo.exe", "bar")
        $target | should -be "foo.exe"
        $name | should -be "bar"
        $shimArgs | should -benullorempty

        $target, $name, $shimArgs = shim_def @("foo.exe", "bar", "--test")
        $target | should -be "foo.exe"
        $name | should -be "bar"
        $shimArgs | should -be "--test"
    }
}

describe 'persist_def' -Tag 'Scoop' {
    it 'parses string correctly' {
        $source, $target = persist_def "test"
        $source | should -be "test"
        $target | should -be "test"
    }

    it 'should handle sub-folder' {
        $source, $target = persist_def "foo/bar"
        $source | should -be "foo/bar"
        $target | should -be "foo/bar"
    }

    it 'should handle arrays' {
        # both specified
        $source, $target = persist_def @("foo", "bar")
        $source | should -be "foo"
        $target | should -be "bar"

        # only first specified
        $source, $target = persist_def @("foo")
        $source | should -be "foo"
        $target | should -be "foo"

        # null value specified
        $source, $target = persist_def @("foo", $null)
        $source | should -be "foo"
        $target | should -be "foo"
    }
}

describe 'compute_hash' -Tag 'Scoop' {
    beforeall {
        $working_dir = setup_working "manifest"
    }

    it 'computes MD5 correctly' {
        compute_hash (join-path "$working_dir" "invalid_wget.json") 'md5' | should -be "cf229eecc201063e32b436e73b71deba"
        compute_hash (join-path "$working_dir" "wget.json") 'md5' | should -be "57c397fd5092cbd6a8b4df56be2551ab"
        compute_hash (join-path "$working_dir" "broken_schema.json") 'md5' | should -be "0427c7f4edc33d6d336db98fc160beb0"
        compute_hash (join-path "$working_dir" "broken_wget.json") 'md5' | should -be "30a7d4d3f64cb7a800d96c0f2ccec87f"
    }

    it 'computes SHA-1 correctly' {
        compute_hash (join-path "$working_dir" "invalid_wget.json") 'sha1' | should -be "33ae44df8feed86cdc8f544234029fb28280c3c5"
        compute_hash (join-path "$working_dir" "wget.json") 'sha1' | should -be "98bfacb887da8cd05d3a1162f89d90173294be55"
        compute_hash (join-path "$working_dir" "broken_schema.json") 'sha1' | should -be "6dcd64f8ce7a3ae6bbc3dc2288b7cb202dbfa3c8"
        compute_hash (join-path "$working_dir" "broken_wget.json") 'sha1' | should -be "60b5b1d5bcb4193d19aeab265eab0bb9b0c46c8f"
    }

    it 'computes SHA-256 correctly' {
        compute_hash (join-path "$working_dir" "invalid_wget.json") 'sha256' | should -be "1a92ef57c5f3cecba74015ae8e92fc3f2dbe141f9d171c3a06f98645a522d58c"
        compute_hash (join-path "$working_dir" "wget.json") 'sha256' | should -be "31d6d0953d4e95f0a42080acd61a8c2f92bc90cae324c0d6d2301a974c15f62f"
        compute_hash (join-path "$working_dir" "broken_schema.json") 'sha256' | should -be "f3e5082e366006c317d9426e590623254cb1ce23d4f70165afed340b03ce333b"
        compute_hash (join-path "$working_dir" "broken_wget.json") 'sha256' | should -be "da658987c3902658c6e754bfa6546dfd084aaa2c3ae25f1fd8aa4645bc9cae24"
    }

    it 'computes SHA-512 correctly' {
        compute_hash (join-path "$working_dir" "invalid_wget.json") 'sha512' | should -be "7a7b82ec17547f5ec13dc614a8cec919e897e6c344a6ce7d71205d6f1c3aed276c7b15cbc69acac8207f72417993299cef36884e1915d56758ea09efa2259870"
        compute_hash (join-path "$working_dir" "wget.json") 'sha512' | should -be "216ebf07bb77062b51420f0f5eb6b7a94d9623d1d41d36c833436058f41e39898f2aa48d7020711c0d8765d02b87ac2e6810f3f502636a6e6f47dc4b9aa02d17"
        compute_hash (join-path "$working_dir" "broken_schema.json") 'sha512' | should -be "8d3f5617517e61c33275eafea4b166f0a245ec229c40dea436173c354786bad72e4fd9d662f6ac2b9f3dd375c00815a07f10e12975eec1b12da7ba7db10f9c14"
. "$psscriptroot\Scoop-TestLib.ps1"
. "$psscriptroot\..\lib\decompress.ps1"
. "$psscriptroot\..\lib\unix.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\manifest.ps1"

$isUnix = is_unix

function test_extract($extract_fn, $from, $removal) {
    $to = (strip_ext $from) -replace '\.tar$', ''
    & $extract_fn ($from -replace '/', '\') ($to -replace '/', '\') -Removal:$removal
    return $to
}

Describe 'Decompression function' -Tag 'Scoop', 'Decompress' {
    BeforeAll {
        $working_dir = setup_working 'decompress'

        It "Decompression test cases should exist" {
            $testcases = "$working_dir\TestCases.zip"
            $testcases | Should -Exist
            compute_hash $testcases 'sha256' | Should -Be '695bb18cafda52644a19afd184b2545e9c48f1a191f7ff1efc26cb034587079c'
            if (!$isUnix) {
                Microsoft.Powershell.Archive\Expand-Archive $testcases $working_dir
            }
        }
    }

    Context "7zip extraction" {

        BeforeAll {
            if($env:CI) {
                mock Get-AppFilePath { (Get-Command 7z.exe).Path }
            } elseif(!(installed 7zip)) {
                scoop install 7zip
            }
            $test1 = "$working_dir\7ZipTest1.7z"
            $test2 = "$working_dir\7ZipTest2.tgz"
            $test3 = "$working_dir\7ZipTest3.tar.bz2"
            $test4 = "$working_dir\7ZipTest4.tar.gz"
        }

        It "extract normal compressed file" -Skip:$isUnix {
            $to = test_extract "Expand-7zipArchive" $test1
            $to | Should -Exist
            "$to\empty" | Should -Exist
            (Get-ChildItem $to).Count | Should -Be 1
        }

        It "extract nested compressed file" -Skip:$isUnix {
            # file ext: tgz
            $to = test_extract "Expand-7zipArchive" $test2
            $to | Should -Exist
            "$to\empty" | Should -Exist
            (Get-ChildItem $to).Count | Should -Be 1

            # file ext: tar.bz2
            $to = test_extract "Expand-7zipArchive" $test3
            $to | Should -Exist
            "$to\empty" | Should -Exist
            (Get-ChildItem $to).Count | Should -Be 1
        }

        It "extract nested compressed file with different inner name" -Skip:$isUnix {
            $to = test_extract "Expand-7zipArchive" $test4
            $to | Should -Exist
            "$to\empty" | Should -Exist
            (Get-ChildItem $to).Count | Should -Be 1
        }

        It "works with '-Removal' switch (`$removal param)" -Skip:$isUnix {
            $test1 | Should -Exist
            test_extract "Expand-7zipArchive" $test1 $true
            $test1 | Should -Not -Exist
        }
    }

    Context "msi extraction" {

        BeforeAll {
            if($env:CI) {
                mock Get-AppFilePath { $env:lessmsi }
            } elseif(!(installed lessmsi)) {
                scoop install lessmsi
            }
            $test1 = "$working_dir\MSITest.msi"
            $test2 = "$working_dir\MSITestNull.msi"
        }

        It "extract normal MSI file" -Skip:$isUnix {
            mock get_config { $false }
            $to = test_extract "Expand-MsiArchive" $test1
            $to | Should -Exist
            "$to\MSITest\empty" | Should -Exist
            (Get-ChildItem "$to\MSITest").Count | Should -Be 1
        }

        It "extract empty MSI file using lessmsi" -Skip:$isUnix {
            mock get_config { $true }
            $to = test_extract "Expand-MsiArchive" $test2
            $to | Should -Exist
        }

        It "works with '-Removal' switch (`$removal param)" -Skip:$isUnix {
            mock get_config { $false }
            $test1 | Should -Exist
            test_extract "Expand-MsiArchive" $test1 $true
            $test1 | Should -Not -Exist
        }
    }

    Context "inno extraction" {

        BeforeAll {
            if($env:CI) {
                mock Get-AppFilePath { $env:innounp }
            } elseif(!(installed innounp)) {
                scoop install innounp
            }
            $test = "$working_dir\InnoTest.exe"
        }

        It "extract Inno Setup file" -Skip:$isUnix {
            $to = test_extract "Expand-InnoArchive" $test
            $to | Should -Exist
            "$to\empty" | Should -Exist
            (Get-ChildItem $to).Count | Should -Be 1
        }

        It "works with '-Removal' switch (`$removal param)" -Skip:$isUnix {
            $test | Should -Exist
            test_extract "Expand-InnoArchive" $test $true
            $test | Should -Not -Exist
        }
    }

    Context "zip extraction" {

        BeforeAll {
            $test = "$working_dir\ZipTest.zip"
        }

        It "extract compressed file" -Skip:$isUnix {
            $to = test_extract "Expand-ZipArchive" $test
            $to | Should -Exist
            "$to\empty" | Should -Exist
            (Get-ChildItem $to).Count | Should -Be 1
        }

        It "works with '-Removal' switch (`$removal param)" -Skip:$isUnix {
            $test | Should -Exist
            test_extract "Expand-ZipArchive" $test $true
            $test | Should -Not -Exist
        }
    }
$repo_dir = (Get-Item $MyInvocation.MyCommand.Path).directory.parent.FullName

Describe -Tag 'Linter' "PSScriptAnalyzer" {
    $scoop_modules = Get-ChildItem $repo_dir -Recurse -Include *.psd1, *.psm1, *.ps1
    $scoop_modules = $scoop_modules | Where-Object { $_.DirectoryName -notlike '*\supporting*' -and $_.DirectoryName -notlike '*\test*' }
    $scoop_modules = $scoop_modules | Select-Object -ExpandProperty Directory -Unique

    Context "Checking ScriptAnalyzer" {
        It "Invoke-ScriptAnalyzer Cmdlet should exist" {
            { Get-Command Invoke-ScriptAnalyzer -ErrorAction Stop } | should -not -throw
        }
        It "PSScriptAnalyzerSettings.ps1 should exist" {
            Test-Path "$repo_dir\PSScriptAnalyzerSettings.psd1" | should -betrue
        }
        It "There should be files to test" {
            $scoop_modules.Count | should -not -be 0
        }
    }

    $linting_settings = Get-Item -Path "$repo_dir\PSScriptAnalyzerSettings.psd1"

    Context "Linting all *.psd1, *.psm1 and *.ps1 files" {
        foreach($directory in $scoop_modules) {
            $analysis = Invoke-ScriptAnalyzer -Path $directory.FullName -Settings $linting_settings.FullName
            It "Should pass: $directory" {
                $analysis.Count | should -be 0
            }
            if($analysis) {
                foreach($result in $analysis) {
                    switch -wildCard ($result.ScriptName) {
                        '*.psm1' { $type = 'Module' }
                        '*.ps1'  { $type = 'Script' }
                        '*.psd1' { $type = 'Manifest' }
                    }
                    Write-Host -f Yellow "      [*] $($result.Severity): $($result.Message)"
                    Write-Host -f Yellow "          $($result.RuleName) in $type`: $directory\$($result.ScriptName):$($result.Line)"
                }
            }
        }
    }
# The PowerShell Script Analyzer will generate a warning
# diagnostic record for this file due to a bug -
# https://github.com/PowerShell/PSScriptAnalyzer/issues/472
@{
    # Only diagnostic records of the specified severity will be generated.
    # Uncomment the following line if you only want Errors and Warnings but
    # not Information diagnostic records.
    Severity = @('Error','Warning')

    # Analyze **only** the following rules. Use IncludeRules when you want
    # to invoke only a small subset of the defualt rules.
    # IncludeRules = @('PSAvoidDefaultValueSwitchParameter',
    #                  'PSMisleadingBacktick',
    #                  'PSMissingModuleManifestField',
    #                  'PSReservedCmdletChar',
    #                  'PSReservedParams',
    #                  'PSShouldProcess',
    #                  'PSUseApprovedVerbs',
    #                  'PSAvoidUsingCmdletAliases',
    #                  'PSUseDeclaredVarsMoreThanAssignments')

    # Do not analyze the following rules. Use ExcludeRules when you have
    # commented out the IncludeRules settings above and want to include all
    # the default rules except for those you exclude below.
    # Note: if a rule is in both IncludeRules and ExcludeRules, the rule
    # will be excluded.
    ExcludeRules = @(
        # Currently Scoop widely uses Write-Host to output colored text.
        'PSAvoidUsingWriteHost',
        # Temporarily allow uses of Invoke-Expression,
        # this command is used by some core functions and hard to be removed.
        'PSAvoidUsingInvokeExpression',
        # PSUseDeclaredVarsMoreThanAssignments doesn't currently work due to:
        # https://github.com/PowerShell/PSScriptAnalyzer/issues/636
        'PSUseDeclaredVarsMoreThanAssignments'
#requires -v 3
param($cmd)

set-strictmode -off

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\git.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. (relpath '..\lib\commands')

reset_aliases

$commands = commands
if ('--version' -contains $cmd -or (!$cmd -and '-v' -contains $args)) {
    Push-Location $(versiondir 'scoop' 'current')
    write-host "Current Scoop version:"
    Invoke-Expression "git --no-pager log --oneline HEAD -n 1"
    write-host ""
    Pop-Location

    Get-LocalBucket | ForEach-Object {
        Push-Location (Find-BucketDirectory $_ -Root)
        if(test-path '.git') {
            write-host "'$_' bucket:"
            Invoke-Expression "git --no-pager log --oneline HEAD -n 1"
            write-host ""
        }
        Pop-Location
    }
}
<#
.SYNOPSIS
    List manifests which do not have valid URLs.
.PARAMETER App
    Manifest name to search.
    Placeholder is supported.
.PARAMETER Dir
    Where to search for manifest(s).
.PARAMETER Timeout
    How long (seconds) the request can be pending before it times out.
.PARAMETER SkipValid
    Manifests will all valid URLs will not be shown.
#>
param(
    [String] $App = '*',
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!(Test-Path $_ -Type Container)) {
            throw "$_ is not a directory!"
        } else {
            $true
        }
    })]
    [String] $Dir,
    [Int] $Timeout = 5,
    [Switch] $SkipValid
)

. "$PSScriptRoot\..\lib\core.ps1"
. "$PSScriptRoot\..\lib\manifest.ps1"
. "$PSScriptRoot\..\lib\install.ps1"

$Dir = Resolve-Path $Dir
$Queue = @()

Get-ChildItem $Dir "$App.json" | ForEach-Object {
    $manifest = parse_json "$Dir\$($_.Name)"
    $Queue += , @($_.Name, $manifest)
}

Write-Host '[' -NoNewLine
Write-Host 'U' -NoNewLine -ForegroundColor Cyan
Write-Host ']RLs'
Write-Host ' | [' -NoNewLine
Write-Host 'O' -NoNewLine -ForegroundColor Green
Write-Host ']kay'
Write-Host ' |  | [' -NoNewLine
Write-Host 'F' -NoNewLine -ForegroundColor Red
Write-Host ']ailed'
Write-Host ' |  |  |'

function test_dl([String] $url, $cookies) {
    # Trim renaming suffix, prevent getting 40x response
    $url = ($url -split '#/')[0]

    $wreq = [Net.WebRequest]::Create($url)
    $wreq.Timeout = $Timeout * 1000
    if ($wreq -is [Net.HttpWebRequest]) {
        $wreq.UserAgent = Get-UserAgent
        $wreq.Referer = strip_filename $url
        if ($cookies) {
            $wreq.Headers.Add('Cookie', (cookie_header $cookies))
        }
    }
    $wres = $null
    try {
        $wres = $wreq.GetResponse()

        return $url, $wres.StatusCode, $null
    } catch {
        $e = $_.Exception
        if ($e.InnerException) { $e = $e.InnerException }

        return $url, 'Error', $e.Message
    } finally {
        if ($null -ne $wres -and $wres -isnot [Net.FtpWebResponse]) {
            $wres.Close()
        }
    }
}

foreach ($man in $Queue) {
    $name, $manifest = $man
    $urls = @()
    $ok = 0
    $failed = 0
    $errors = @()

    if ($manifest.url) {
        $manifest.url | ForEach-Object { $urls += $_ }
    } else {
        url $manifest '64bit' | ForEach-Object { $urls += $_ }
        url $manifest '32bit' | ForEach-Object { $urls += $_ }
    }

    $urls | ForEach-Object {
        $url, $status, $msg = test_dl $_ $manifest.cookie
        if ($msg) { $errors += "$msg ($url)" }
        if ($status -eq 'OK' -or $status -eq 'OpeningData') { $ok += 1 } else { $failed += 1 }
    }

    if (($ok -eq $urls.Length) -and $SkipValid) { continue }

    # URLS
    Write-Host '[' -NoNewLine
    Write-Host $urls.Length -NoNewLine -ForegroundColor Cyan
    Write-Host ']' -NoNewLine

    # Okay
    Write-Host '[' -NoNewLine
    if ($ok -eq $urls.Length) {
        Write-Host $ok -NoNewLine -ForegroundColor Green
    } elseif ($ok -eq 0) {
        Write-Host $ok -NoNewLine -ForegroundColor Red
    } else {
        Write-Host $ok -NoNewLine -ForegroundColor Yellow
    }
    Write-Host ']' -NoNewLine

    # Failed
    Write-Host '[' -NoNewLine
    if ($failed -eq 0) {
        Write-Host $failed -NoNewLine -ForegroundColor Green
    } else {
        Write-Host $failed -NoNewLine -ForegroundColor Red
    }
    Write-Host '] ' -NoNewLine
    Write-Host (strip_ext $name)

    $errors | ForEach-Object {
<#
.SYNOPSIS
    Check if ALL urls inside manifest have correct hashes.
.PARAMETER App
    Manifest to be checked.
    Wildcard is supported.
.PARAMETER Dir
    Where to search for manifest(s).
.PARAMETER Update
    When there are mismatched hashes, manifest will be updated.
.PARAMETER ForceUpdate
    Manifest will be updated all the time. Not only when there are mismatched hashes.
.PARAMETER SkipCorrect
    Manifests without mismatch will not be shown.
.PARAMETER UseCache
    Downloaded files will not be deleted after script finish.
    Should not be used, because check should be used for downloading actual version of file (as normal user, not finding in some document from vendors, which could be damaged / wrong (Example: Slack@3.3.1 lukesampson/scoop-extras#1192)), not some previously downloaded.
.EXAMPLE
    PS BUCKETROOT> .\bin\checkhashes.ps1
    Check all manifests for hash mismatch.
.EXAMPLE
    PS BUCKETROOT> .\bin\checkhashes.ps1 MANIFEST -Update
    Check MANIFEST and Update if there are some wrong hashes.
#>
param(
    [String] $App = '*',
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!(Test-Path $_ -Type Container)) {
            throw "$_ is not a directory!"
        } else {
            $true
        }
    })]
    [String] $Dir,
    [Switch] $Update,
    [Switch] $ForceUpdate,
    [Switch] $SkipCorrect,
    [Alias('k')]
    [Switch] $UseCache
)

. "$PSScriptRoot\..\lib\core.ps1"
. "$PSScriptRoot\..\lib\manifest.ps1"
. "$PSScriptRoot\..\lib\buckets.ps1"
. "$PSScriptRoot\..\lib\autoupdate.ps1"
. "$PSScriptRoot\..\lib\json.ps1"
. "$PSScriptRoot\..\lib\versions.ps1"
. "$PSScriptRoot\..\lib\install.ps1"
. "$PSScriptRoot\..\lib\unix.ps1"

$Dir = Resolve-Path $Dir
if ($ForceUpdate) { $Update = $true }
# Cleanup
if (!$UseCache) { Remove-Item "$cachedir\*HASH_CHECK*" -Force }

function err ([String] $name, [String[]] $message) {
    Write-Host "$name`: " -ForegroundColor Red -NoNewline
    Write-Host ($message -join "`r`n") -ForegroundColor Red
}

$MANIFESTS = @()
foreach ($single in Get-ChildItem $Dir "$App.json") {
    $name = (strip_ext $single.Name)
    $manifest = parse_json "$Dir\$($single.Name)"

    # Skip nighly manifests, since their hash validation is skipped
    if ($manifest.version -eq 'nightly') { continue }

    $urls = @()
    $hashes = @()

    if ($manifest.url) {
        $manifest.url | ForEach-Object { $urls += $_ }
        $manifest.hash | ForEach-Object { $hashes += $_ }
    } elseif ($manifest.architecture) {
        # First handle 64bit
        url $manifest '64bit' | ForEach-Object { $urls += $_ }
        hash $manifest '64bit' | ForEach-Object { $hashes += $_ }
        url $manifest '32bit' | ForEach-Object { $urls += $_ }
        hash $manifest '32bit' | ForEach-Object { $hashes += $_ }
    } else {
        err $name 'Manifest does not contain URL property.'
        continue
    }

    # Number of URLS and Hashes is different
    if ($urls.Length -ne $hashes.Length) {
        err $name 'URLS and hashes count mismatch.'
        continue
    }

    $MANIFESTS += @{
        app      = $name
        manifest = $manifest
        urls     = $urls
        hashes   = $hashes
    }
}

# clear any existing events
Get-Event | ForEach-Object { Remove-Event $_.SourceIdentifier }

foreach ($current in $MANIFESTS) {
    $count = 0
    # Array of indexes mismatched hashes.
    $mismatched = @()
    # Array of computed hashes
    $actuals = @()

    $current.urls | ForEach-Object {
        $algorithm, $expected = get_hash $current.hashes[$count]
        $version = 'HASH_CHECK'
        $tmp = $expected_hash -split ':'

        dl_with_cache $current.app $version $_ $null $null -use_cache:$UseCache

        $to_check = fullpath (cache_path $current.app $version $_)
        $actual_hash = compute_hash $to_check $algorithm

        # Append type of algorithm to both expected and actual if it's not sha256
        if ($algorithm -ne 'sha256') {
            $actual_hash = "$algorithm`:$actual_hash"
            $expected = "$algorithm`:$expected"
        }

        $actuals += $actual_hash
        if ($actual_hash -ne $expected) {
            $mismatched += $count
        }
        $count++
    }

    if ($mismatched.Length -eq 0 ) {
        if (!$SkipCorrect) {
            Write-Host "$($current.app): " -NoNewline
            Write-Host 'OK' -ForegroundColor Green
        }
    } else {
        Write-Host "$($current.app): " -NoNewline
        Write-Host 'Mismatch found ' -ForegroundColor Red
        $mismatched | ForEach-Object {
            $file = fullpath (cache_path $current.app $version $current.urls[$_])
            Write-Host  "`tURL:`t`t$($current.urls[$_])"
            if (Test-Path $file) {
                Write-Host  "`tFirst bytes:`t$((get_magic_bytes_pretty $file ' ').ToUpper())"
            }
            Write-Host  "`tExpected:`t$($current.hashes[$_])" -ForegroundColor Green
            Write-Host  "`tActual:`t`t$($actuals[$_])" -ForegroundColor Red
        }
    }

    if ($Update) {
        if ($current.manifest.url -and $current.manifest.hash) {
            $current.manifest.hash = $actuals
        } else {
            $platforms = ($current.manifest.architecture | Get-Member -MemberType NoteProperty).Name
            # Defaults to zero, don't know, which architecture is available
            $64bit_count = 0
            $32bit_count = 0

            if ($platforms.Contains('64bit')) {
                $64bit_count = $current.manifest.architecture.'64bit'.hash.Count
                # 64bit is get, donwloaded and added first
                $current.manifest.architecture.'64bit'.hash = $actuals[0..($64bit_count - 1)]
            }
            if ($platforms.Contains('32bit')) {
                $32bit_count = $current.manifest.architecture.'32bit'.hash.Count
                $max = $64bit_count + $32bit_count - 1 # Edge case if manifest contains 64bit and 32bit.
                $current.manifest.architecture.'32bit'.hash = $actuals[($64bit_count)..$max]
            }
        }

        Write-Host "Writing updated $($current.app) manifest" -ForegroundColor DarkGreen

<#
.SYNOPSIS
    Uninstall ALL scoop applications and scoop itself.
.PARAMETER global
    Global applications will be uninstalled.
.PARAMETER purge
    Persisted data will be deleted.
#>
param(
    [bool] $global,
    [bool] $purge
)

. "$PSScriptRoot\..\lib\core.ps1"
. "$PSScriptRoot\..\lib\install.ps1"
. "$PSScriptRoot\..\lib\shortcuts.ps1"
. "$PSScriptRoot\..\lib\versions.ps1"
. "$PSScriptRoot\..\lib\manifest.ps1"

if ($global -and !(is_admin)) {
    error 'You need admin rights to uninstall globally.'
    exit 1
}

if ($purge) {
    warn 'This will uninstall Scoop, all the programs that have been installed with Scoop and all persisted data!'
} else {
    warn 'This will uninstall Scoop and all the programs that have been installed with Scoop!'
}
$yn = Read-Host 'Are you sure? (yN)'
if ($yn -notlike 'y*') { exit }

$errors = $false

# Uninstall given app
function do_uninstall($app, $global) {
    $version = current_version $app $global
    $dir = versiondir $app $version $global
    $manifest = installed_manifest $app $version $global
    $install = install_info $app $version $global
    $architecture = $install.architecture

    Write-Output "Uninstalling '$app'"
    run_uninstaller $manifest $architecture $dir
    rm_shims $manifest $global $architecture

    # If a junction was used during install, that will have been used
    # as the reference directory. Othewise it will just be the version
    # directory.
    $refdir = unlink_current (appdir $app $global)

    env_rm_path $manifest $refdir $global
    env_rm $manifest $global

    $appdir = appdir $app $global
    try {
        Remove-Item $appdir -Recurse -Force -ErrorAction Stop
    } catch {
        $errors = $true
        warn "Couldn't remove $(friendly_path $appdir): $_.Exception"
    }
}

function rm_dir($dir) {
    try {
        Remove-Item $dir -Recurse -Force -ErrorAction Stop
    } catch {
        abort "Couldn't remove $(friendly_path $dir): $_"
    }
}

# Remove all folders (except persist) inside given scoop directory.
function keep_onlypersist($directory) {
    Get-ChildItem $directory -Exclude 'persist' | ForEach-Object { rm_dir $_ }
}

# Run uninstallation for each app if necessary, continuing if there's
# a problem deleting a directory (which is quite likely)
if ($global) {
    installed_apps $true | ForEach-Object { # global apps
        do_uninstall $_ $true
    }
}

installed_apps $false | ForEach-Object { # local apps
    do_uninstall $_ $false
}

if ($errors) {
    abort 'Not all apps could be deleted. Try again or restart.'
}

if ($purge) {
    rm_dir $scoopdir
    if ($global) { rm_dir $globaldir }
} else {
    keep_onlypersist $scoopdir
    if ($global) { keep_onlypersist $globaldir }
}

#Requires -Version 5

# remote install:
#   Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
$old_erroractionpreference = $erroractionpreference
$erroractionpreference = 'stop' # quit if anything goes wrong

if (($PSVersionTable.PSVersion.Major) -lt 5) {
    Write-Output "PowerShell 5 or later is required to run Scoop."
    Write-Output "Upgrade PowerShell: https://docs.microsoft.com/en-us/powershell/scripting/setup/installing-windows-powershell"
    break
}

# show notification to change execution policy:
$allowedExecutionPolicy = @('Unrestricted', 'RemoteSigned', 'ByPass')
if ((Get-ExecutionPolicy).ToString() -notin $allowedExecutionPolicy) {
    Write-Output "PowerShell requires an execution policy in [$($allowedExecutionPolicy -join ", ")] to run Scoop."
    Write-Output "For example, to set the execution policy to 'RemoteSigned' please run :"
    Write-Output "'Set-ExecutionPolicy RemoteSigned -scope CurrentUser'"
    break
}

if ([System.Enum]::GetNames([System.Net.SecurityProtocolType]) -notcontains 'Tls12') {
    Write-Output "Scoop requires at least .NET Framework 4.5"
    Write-Output "Please download and install it first:"
    Write-Output "https://www.microsoft.com/net/download"
    break
}

# get core functions
$core_url = 'https://raw.githubusercontent.com/lukesampson/scoop/master/lib/core.ps1'
Write-Output 'Initializing...'
Invoke-Expression (new-object net.webclient).downloadstring($core_url)

# prep
if (installed 'scoop') {
    write-host "Scoop is already installed. Run 'scoop update' to get the latest version." -f red
    # don't abort if invoked with iex that would close the PS session
    if ($myinvocation.mycommand.commandtype -eq 'Script') { return } else { exit 1 }
}
$dir = ensure (versiondir 'scoop' 'current')

# download scoop zip
$zipurl = 'https://github.com/lukesampson/scoop/archive/master.zip'
$zipfile = "$dir\scoop.zip"
Write-Output 'Downloading scoop...'
dl $zipurl $zipfile

Write-Output 'Extracting...'
Add-Type -Assembly "System.IO.Compression.FileSystem"
[IO.Compression.ZipFile]::ExtractToDirectory($zipfile, "$dir\_tmp")
Copy-Item "$dir\_tmp\*master\*" $dir -Recurse -Force
Remove-Item "$dir\_tmp", $zipfile -Recurse -Force

Write-Output 'Creating shim...'
shim "$dir\bin\scoop.ps1" $false

# download main bucket
$dir = "$scoopdir\buckets\main"
$zipurl = 'https://github.com/ScoopInstaller/Main/archive/master.zip'
$zipfile = "$dir\main-bucket.zip"
Write-Output 'Downloading main bucket...'
New-Item $dir -Type Directory -Force | Out-Null
dl $zipurl $zipfile

Write-Output 'Extracting...'
[IO.Compression.ZipFile]::ExtractToDirectory($zipfile, "$dir\_tmp")
Copy-Item "$dir\_tmp\*-master\*" $dir -Recurse -Force
Remove-Item "$dir\_tmp", $zipfile -Recurse -Force

ensure_robocopy_in_path
ensure_scoop_in_path

scoop config lastupdate ([System.DateTime]::Now.ToString('o'))
success 'Scoop was installed successfully!'
<#
.SYNOPSIS
    Check if manifest contains checkver and autoupdate property.
.PARAMETER App
    Manifest name.
    Wirldcard is supported.
.PARAMETER Dir
    Location of manifests.
.PARAMETER SkipSupported
    Manifests with checkver and autoupdate will not be presented.
#>
param(
    [String] $App = '*',
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!(Test-Path $_ -Type Container)) {
            throw "$_ is not a directory!"
        } else {
            $true
        }
    })]
    [String] $Dir,
    [Switch] $SkipSupported
)

. "$PSScriptRoot\..\lib\core.ps1"
. "$PSScriptRoot\..\lib\manifest.ps1"

$Dir = Resolve-Path $Dir

Write-Host '[' -NoNewLine
Write-Host 'C' -NoNewLine -ForegroundColor Green
Write-Host ']heckver'
Write-Host ' | [' -NoNewLine
Write-Host 'A' -NoNewLine -ForegroundColor Cyan
Write-Host ']utoupdate'
Write-Host ' |  |'

Get-ChildItem $Dir "$App.json" | ForEach-Object {
    $json = parse_json "$Dir\$($_.Name)"

    if ($SkipSupported -and $json.checkver -and $json.autoupdate) { return }

    Write-Host '[' -NoNewLine
    Write-Host $(if ($json.checkver) { 'C' } else { ' ' }) -NoNewLine -ForegroundColor Green
    Write-Host ']' -NoNewLine

    Write-Host '[' -NoNewLine
    Write-Host $(if ($json.autoupdate) { 'A' } else { ' ' }) -NoNewLine -ForegroundColor Cyan
    Write-Host '] ' -NoNewLine
<#
.SYNOPSIS
    Updates manifests and pushes them or creates pull-requests.
.DESCRIPTION
    Updates manifests and pushes them directly to the master branch or creates pull-requests for upstream.
.PARAMETER Upstream
    Upstream repository with the target branch.
    Must be in format '<user>/<repo>:<branch>'
.PARAMETER App
    Manifest name to search.
    Placeholders are supported.
.PARAMETER Dir
    The directory where to search for manifests.
.PARAMETER Push
    Push updates directly to 'origin master'.
.PARAMETER Request
    Create pull-requests on 'upstream master' for each update.
.PARAMETER Help
    Print help to console.
.PARAMETER SpecialSnowflakes
    An array of manifests, which should be updated all the time. (-ForceUpdate parameter to checkver)
.PARAMETER SkipUpdated
    Updated manifests will not be shown.
.EXAMPLE
    PS BUCKETROOT > .\bin\auto-pr.ps1 'someUsername/repository:branch' -Request
.EXAMPLE
    PS BUCKETROOT > .\bin\auto-pr.ps1 -Push
    Update all manifests inside 'bucket/' directory.
#>

param(
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!($_ -match '^(.*)\/(.*):(.*)$')) {
            throw 'Upstream must be in this format: <user>/<repo>:<branch>'
        }
        $true
    })]
    [String] $Upstream,
    [String] $App = '*',
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!(Test-Path $_ -Type Container)) {
            throw "$_ is not a directory!"
        } else {
            $true
        }
    })]
    [String] $Dir,
    [Switch] $Push,
    [Switch] $Request,
    [Switch] $Help,
    [string[]] $SpecialSnowflakes,
    [Switch] $SkipUpdated
)

. "$PSScriptRoot\..\lib\manifest.ps1"
. "$PSScriptRoot\..\lib\json.ps1"
. "$PSScriptRoot\..\lib\unix.ps1"

$Dir = Resolve-Path $Dir

if ((!$Push -and !$Request) -or $Help) {
    Write-Host @'
Usage: auto-pr.ps1 [OPTION]

Mandatory options:
  -p,  -push                       push updates directly to 'origin master'
  -r,  -request                    create pull-requests on 'upstream master' for each update

Optional options:
  -u,  -upstream                   upstream repository with target branch
                                   only used if -r is set (default: lukesampson/scoop:master)
  -h,  -help
'@
    exit 0
}

if (is_unix) {
    if (!(which hub)) {
        Write-Host "Please install hub ('brew install hub' or visit: https://hub.github.com/)" -ForegroundColor Yellow
        exit 1
    }
} else {
    if (!(scoop which hub)) {
        Write-Host "Please install hub 'scoop install hub'" -ForegroundColor Yellow
        exit 1
    }
}

function execute($cmd) {
    Write-Host $cmd -ForegroundColor Green
    $output = Invoke-Expression $cmd

    if ($LASTEXITCODE -gt 0) {
        abort "^^^ Error! See above ^^^ (last command: $cmd)"
    }

    return $output
}

function pull_requests($json, [String] $app, [String] $upstream, [String] $manifest) {
    $version = $json.version
    $homepage = $json.homepage
    $branch = "manifest/$app-$version"

    execute 'hub checkout master'
    Write-Host "hub rev-parse --verify $branch" -ForegroundColor Green
    hub rev-parse --verify $branch

    if ($LASTEXITCODE -eq 0) {
        Write-Host "Skipping update $app ($version) ..." -ForegroundColor Yellow
        return
    }

    Write-Host "Creating update $app ($version) ..." -ForegroundColor DarkCyan
    execute "hub checkout -b $branch"
    execute "hub add $manifest"
    execute "hub commit -m '${app}: Update to version $version'"
    Write-Host "Pushing update $app ($version) ..." -ForegroundColor DarkCyan
    execute "hub push origin $branch"

    if ($LASTEXITCODE -gt 0) {
        error "Push failed! (hub push origin $branch)"
        execute 'hub reset'
        return
    }

    Start-Sleep 1
    Write-Host "Pull-Request update $app ($version) ..." -ForegroundColor DarkCyan
    Write-Host "hub pull-request -m '<msg>' -b '$upstream' -h '$branch'" -ForegroundColor Green

    $msg = @"
$app`: Update to version $version

Hello lovely humans,
a new version of [$app]($homepage) is available.

| State       | Update :rocket: |
| :---------- | :-------------- |
| New version | $version        |
"@

    hub pull-request -m "$msg" -b '$upstream' -h '$branch'
    if ($LASTEXITCODE -gt 0) {
        execute 'hub reset'
        abort "Pull Request failed! (hub pull-request -m '${app}: Update to version $version' -b '$upstream' -h '$branch')"
    }
}

Write-Host 'Updating ...' -ForegroundColor DarkCyan
if ($Push) {
    execute 'hub pull origin master'
    execute 'hub checkout master'
} else {
    execute 'hub pull upstream master'
    execute 'hub push origin master'
}

. "$PSScriptRoot\checkver.ps1" -App $App -Dir $Dir -Update -SkipUpdated:$SkipUpdated
if ($SpecialSnowflakes) {
    Write-Host "Forcing update on our special snowflakes: $($SpecialSnowflakes -join ',')" -ForegroundColor DarkCyan
    $SpecialSnowflakes -split ',' | ForEach-Object {
        . "$PSScriptRoot\checkver.ps1" $_ -Dir $Dir -ForceUpdate
    }
}

hub diff --name-only | ForEach-Object {
    $manifest = $_
    if (!$manifest.EndsWith('.json')) {
        return
    }

    $app = ([System.IO.Path]::GetFileNameWithoutExtension($manifest))
    $json = parse_json $manifest
    if (!$json.version) {
        error "Invalid manifest: $manifest ..."
        return
    }
    $version = $json.version

    if ($Push) {
        Write-Host "Creating update $app ($version) ..." -ForegroundColor DarkCyan
        execute "hub add $manifest"

        # detect if file was staged, because it's not when only LF or CRLF have changed
        $status = execute 'hub status --porcelain -uno'
        $status = $status | Where-Object { $_ -match "M\s{2}.*$app.json" }
        if ($status -and $status.StartsWith('M  ') -and $status.EndsWith("$app.json")) {
            execute "hub commit -m '${app}: Update to version $version'"
        } else {
            Write-Host "Skipping $app because only LF/CRLF changes were detected ..." -ForegroundColor Yellow
        }
    } else {
        pull_requests $json $app $Upstream $manifest
    }
}

if ($Push) {
    Write-Host 'Pushing updates ...' -ForegroundColor DarkCyan
    execute 'hub push origin master'
} else {
    Write-Host 'Returning to master branch and removing unstaged files ...' -ForegroundColor DarkCyan
    execute 'hub checkout -f master'
}
<#
.SYNOPSIS
    Search for application description on homepage.
.PARAMETER App
    Manifest name to search.
    Placeholders are supported.
.PARAMETER Dir
    Where to search for manifest(s).
#>
param(
    [String] $App = '*',
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!(Test-Path $_ -Type Container)) {
            throw "$_ is not a directory!"
        } else {
            $true
        }
    })]
    [String] $Dir
)

. "$PSScriptRoot\..\lib\core.ps1"
. "$PSScriptRoot\..\lib\manifest.ps1"
. "$PSScriptRoot\..\lib\description.ps1"

$Dir = Resolve-Path $Dir
$Queue = @()

Get-ChildItem $Dir "$App.json" | ForEach-Object {
    $manifest = parse_json "$Dir\$($_.Name)"
    $Queue += , @(($_.Name -replace '\.json$', ''), $manifest)
}

$Queue | ForEach-Object {
    $name, $manifest = $_
    Write-Host "$name`: " -NoNewline

    if (!$manifest.homepage) {
        Write-Host "`nNo homepage set." -ForegroundColor Red
        return
    }
    # get description from homepage
    try {
        $wc = New-Object Net.Webclient
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
        $home_html = $wc.DownloadString($manifest.homepage)
    } catch {
        Write-Host "`n$($_.Exception.Message)" -ForegroundColor Red
        return
    }

    $description, $descr_method = find_description $manifest.homepage $home_html
    if (!$description) {
        Write-Host "`nDescription not found ($($manifest.homepage))" -ForegroundColor Red
        return
    }

    $description = clean_description $description

<#
.SYNOPSIS
    Check manifest for a newer version.
.DESCRIPTION
    Checks websites for newer versions using an (optional) regular expression defined in the manifest.
.PARAMETER App
    Manifest name to search.
    Placeholders are supported.
.PARAMETER Dir
    Where to search for manifest(s).
.PARAMETER Update
    Update given manifest
.PARAMETER ForceUpdate
    Update given manifest(s) even when there is no new version.
    Useful for hash updates.
.PARAMETER SkipUpdated
    Updated manifests will not be shown.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1
    Check all manifest inside default directory.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 -SkipUpdated
    Check all manifest inside default directory (list only outdated manifests).
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 -Update
    Check all manifests and update All outdated manifests.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 APP
    Check manifest APP.json inside default directory.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 APP -Update
    Check manifest APP.json and update, if there is newer version.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 APP -ForceUpdate
    Check manifest APP.json and update, even if there is no new version.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 APP -Update -Version VER
    Check manifest APP.json and update, using version VER
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 APP DIR
    Check manifest APP.json inside ./DIR directory.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 -Dir DIR
    Check all manifests inside ./DIR directory.
.EXAMPLE
    PS BUCKETROOT > .\bin\checkver.ps1 APP DIR -Update
    Check manifest APP.json inside ./DIR directory and update if there is newer version.
#>
param(
    [String] $App = '*',
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!(Test-Path $_ -Type Container)) {
            throw "$_ is not a directory!"
        } else {
            $true
        }
    })]
    [String] $Dir,
    [Switch] $Update,
    [Switch] $ForceUpdate,
    [Switch] $SkipUpdated,
    [String] $Version = ''
)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\autoupdate.ps1"
. "$psscriptroot\..\lib\json.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\install.ps1" # needed for hash generation
. "$psscriptroot\..\lib\unix.ps1"

$Dir = Resolve-Path $Dir
$Search = $App

# get apps to check
$Queue = @()
$json = ''
Get-ChildItem $Dir "$App.json" | ForEach-Object {
    $json = parse_json "$Dir\$($_.Name)"
    if ($json.checkver) {
        $Queue += , @($_.Name, $json)
    }
}

# clear any existing events
Get-Event | ForEach-Object {
    Remove-Event $_.SourceIdentifier
}

# start all downloads
$Queue | ForEach-Object {
    $name, $json = $_

    $substitutions = get_version_substitutions $json.version

    $wc = New-Object Net.Webclient
    if ($json.checkver.useragent) {
        $wc.Headers.Add('User-Agent', (substitute $json.checkver.useragent $substitutions))
    } else {
        $wc.Headers.Add('User-Agent', (Get-UserAgent))
    }
    Register-ObjectEvent $wc downloadstringcompleted -ErrorAction Stop | Out-Null

    $githubRegex = '\/releases\/tag\/(?:v|V)?([\d.]+)'

    $url = $json.homepage
    if ($json.checkver.url) {
        $url = $json.checkver.url
    }
    $regex = ''
    $jsonpath = ''
    $xpath = ''
    $replace = ''

    if ($json.checkver -eq 'github') {
        if (!$json.homepage.StartsWith('https://github.com/')) {
            error "$name checkver expects the homepage to be a github repository"
        }
        $url = $json.homepage + '/releases/latest'
        $regex = $githubRegex
    }

    if ($json.checkver.github) {
        $url = $json.checkver.github + '/releases/latest'
        $regex = $githubRegex
    }

    if ($json.checkver.re) {
        $regex = $json.checkver.re
    }
    if ($json.checkver.regex) {
        $regex = $json.checkver.regex
    }

    if ($json.checkver.jp) {
        $jsonpath = $json.checkver.jp
    }
    if ($json.checkver.jsonpath) {
        $jsonpath = $json.checkver.jsonpath
    }
    if ($json.checkver.xpath) {
        $xpath = $json.checkver.xpath
    }

    if ($json.checkver.replace -and $json.checkver.replace.GetType() -eq [System.String]) {
        $replace = $json.checkver.replace
    }

    if (!$jsonpath -and !$regex -and !$xpath) {
        $regex = $json.checkver
    }

    $reverse = $json.checkver.reverse -and $json.checkver.reverse -eq 'true'

    $url = substitute $url $substitutions

    $state = New-Object psobject @{
        app      = (strip_ext $name);
        url      = $url;
        regex    = $regex;
        json     = $json;
        jsonpath = $jsonpath;
        xpath    = $xpath;
        reverse  = $reverse;
        replace  = $replace;
    }

    $wc.Headers.Add('Referer', (strip_filename $url))
    $wc.DownloadStringAsync($url, $state)
}

function next($er) {
    Write-Host "$App`: " -NoNewline
    Write-Host $er -ForegroundColor DarkRed
}

# wait for all to complete
$in_progress = $Queue.length
while ($in_progress -gt 0) {
    $ev = Wait-Event
    Remove-Event $ev.SourceIdentifier
    $in_progress--

    $state = $ev.SourceEventArgs.UserState
    $app = $state.app
    $json = $state.json
    $url = $state.url
    $regexp = $state.regex
    $jsonpath = $state.jsonpath
    $xpath = $state.xpath
    $reverse = $state.reverse
    $replace = $state.replace
    $expected_ver = $json.version
    $ver = ''

    $page = $ev.SourceEventArgs.Result
    $err = $ev.SourceEventArgs.Error
    if ($json.checkver.script) {
        $page = $json.checkver.script -join "`r`n" | Invoke-Expression
    }

    if ($err) {
        next "$($err.message)`r`nURL $url is not valid"
        continue
    }

    if (!$regex -and $replace) {
        next "'replace' requires 're' or 'regex'"
        continue
    }

    if ($jsonpath) {
        $ver = json_path $page $jsonpath
        if (!$ver) {
            $ver = json_path_legacy $page $jsonpath
        }
        if (!$ver) {
            next "couldn't find '$jsonpath' in $url"
            continue
        }
    }

    if ($xpath) {
        $xml = [xml]$page
        # Find all `significant namespace declarations` from the XML file
        $nsList = $xml.SelectNodes("//namespace::*[not(. = ../../namespace::*)]")
        # Then add them into the NamespaceManager
        $nsmgr = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
        $nsList | ForEach-Object {
            $nsmgr.AddNamespace($_.LocalName, $_.Value)
        }
        # Getting version from XML, using XPath
        $ver = $xml.SelectSingleNode($xpath, $nsmgr).'#text'
        if (!$ver) {
            next "couldn't find '$xpath' in $url"
            continue
        }
    }

    if ($jsonpath -and $regexp) {
        $page = $ver
        $ver = ''
    }

    if ($xpath -and $regexp) {
        $page = $ver
        $ver = ''
    }

    if ($regexp) {
        $regex = New-Object System.Text.RegularExpressions.Regex($regexp)
        if ($reverse) {
            $match = $regex.Matches($page) | Select-Object -Last 1
        } else {
            $match = $regex.Matches($page) | Select-Object -First 1
        }

        if ($match -and $match.Success) {
            $matchesHashtable = @{}
            $regex.GetGroupNames() | ForEach-Object { $matchesHashtable.Add($_, $match.Groups[$_].Value) }
            $ver = $matchesHashtable['1']
            if ($replace) {
                $ver = $regex.Replace($match.Value, $replace)
            }
            if (!$ver) {
                $ver = $matchesHashtable['version']
            }
        } else {
            next "couldn't match '$regexp' in $url"
            continue
        }
    }

    if (!$ver) {
        next "couldn't find new version in $url"
        continue
    }

    # Skip actual only if versions are same and there is no -f
    if (($ver -eq $expected_ver) -and !$ForceUpdate -and $SkipUpdated) { continue }

    Write-Host "$App`: " -NoNewline

    # version hasn't changed (step over if forced update)
    if ($ver -eq $expected_ver -and !$ForceUpdate) {
        Write-Host $ver -ForegroundColor DarkGreen
        continue
    }

    Write-Host $ver -ForegroundColor DarkRed -NoNewline
    Write-Host " (scoop version is $expected_ver)" -NoNewline
    $update_available = (compare_versions $expected_ver $ver) -eq -1

    if ($json.autoupdate -and $update_available) {
        Write-Host ' autoupdate available' -ForegroundColor Cyan
    } else {
        Write-Host ''
    }

    # forcing an update implies updating, right?
    if ($ForceUpdate) { $Update = $true }

    if ($Update -and $json.autoupdate) {
        if ($ForceUpdate) {
            Write-Host 'Forcing autoupdate!' -ForegroundColor DarkMagenta
        }
        try {
            if ($Version -ne "") {
                $ver = $Version
            }
            autoupdate $App $Dir $json $ver $matchesHashtable
        } catch {
# for development, update the installed scripts to match local source
. "$psscriptroot\..\lib\core.ps1"

$src = relpath ".."
$dest = ensure (versiondir 'scoop' 'current')

# make sure not running from the installed directory
if("$src" -eq "$dest") { abort "$(strip_ext $myinvocation.mycommand.name) is for development only" }

'copying files...'
$output = robocopy $src $dest /mir /njh /njs /nfl /ndl /xd .git tmp /xf .DS_Store last_updated

$output | Where-Object { $_ -ne "" }

Write-Output 'creating shim...'
<#
.SYNOPSIS
    Format manifest.
.PARAMETER App
    Manifest to format.

    Wildcards are supported.
.PARAMETER Dir
    Where to search for manifest(s).
.EXAMPLE
    PS BUCKETROOT> .\bin\formatjson.ps1
    Format all manifests inside bucket directory.
.EXAMPLE
    PS BUCKETROOT> .\bin\formatjson.ps1 7zip
    Format manifest '7zip' inside bucket directory.
#>
param(
    [String] $App = '*',
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
        if (!(Test-Path $_ -Type Container)) {
            throw "$_ is not a directory!"
        } else {
            $true
        }
    })]
    [String] $Dir
)

. "$PSScriptRoot\..\lib\core.ps1"
. "$PSScriptRoot\..\lib\manifest.ps1"
. "$PSScriptRoot\..\lib\json.ps1"

$Dir = Resolve-Path $Dir

Get-ChildItem $Dir "$App.json" | ForEach-Object {
    if ($PSVersionTable.PSVersion.Major -gt 5) { $_ = $_.Name } # Fix for pwsh

    # beautify
    $json = parse_json "$Dir\$_" | ConvertToPrettyJson
# Usage: scoop list [query]
# Summary: List installed apps
# Help: Lists all installed apps, or the apps matching the supplied query.
param($query)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"

reset_aliases
$def_arch = default_architecture

$local = installed_apps $false | ForEach-Object { @{ name = $_ } }
$global = installed_apps $true | ForEach-Object { @{ name = $_; global = $true } }

$apps = @($local) + @($global)

if($apps) {
    write-host "Installed apps$(if($query) { `" matching '$query'`"}): `n"
    $apps | Sort-Object { $_.name } | Where-Object { !$query -or ($_.name -match $query) } | ForEach-Object {
        $app = $_.name
        $global = $_.global
        $ver = current_version $app $global

        $install_info = install_info $app $ver $global
        write-host "  $app " -NoNewline
        write-host -f DarkCyan $ver -NoNewline

        if($global) { write-host -f DarkGreen ' *global*' -NoNewline }

        if (!$install_info) { Write-Host ' *failed*' -ForegroundColor DarkRed -NoNewline }
        if ($install_info.hold) { Write-Host ' *hold*' -ForegroundColor DarkMagenta -NoNewline }

        if ($install_info.bucket) {
            write-host -f Yellow " [$($install_info.bucket)]" -NoNewline
        } elseif ($install_info.url) {
            write-host -f Yellow " [$($install_info.url)]" -NoNewline
        }

        if ($install_info.architecture -and $def_arch -ne $install_info.architecture) {
            write-host -f DarkRed " {$($install_info.architecture)}" -NoNewline
        }
        write-host ''
    }
    write-host ''
    exit 0
} else {
    write-host "There aren't any apps installed."
    exit 1
# Usage: scoop bucket add|list|known|rm [<args>]
# Summary: Manage Scoop buckets
# Help: Add, list or remove buckets.
#
# Buckets are repositories of apps available to install. Scoop comes with
# a default bucket, but you can also add buckets that you or others have
# published.
#
# To add a bucket:
#     scoop bucket add <name> [<repo>]
#
# e.g.:
#     scoop bucket add extras https://github.com/lukesampson/scoop-extras.git
#
# Since the 'extras' bucket is known to Scoop, this can be shortened to:
#     scoop bucket add extras
#
# To list all known buckets, use:
#     scoop bucket known
param($cmd, $name, $repo)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\git.ps1"

reset_aliases

$usage_add = "usage: scoop bucket add <name> [<repo>]"
$usage_rm = "usage: scoop bucket rm <name>"

switch($cmd) {
    'add' { add_bucket $name $repo }
    'rm' { rm_bucket $name }
    'list' { Get-LocalBucket }
# Usage: scoop uninstall <app> [options]
# Summary: Uninstall an app
# Help: e.g. scoop uninstall git
#
# Options:
#   -g, --global   Uninstall a globally installed app
#   -p, --purge    Remove all persistent data

. "$PSScriptRoot\..\lib\core.ps1"
. "$PSScriptRoot\..\lib\manifest.ps1"
. "$PSScriptRoot\..\lib\help.ps1"
. "$PSScriptRoot\..\lib\install.ps1"
. "$PSScriptRoot\..\lib\shortcuts.ps1"
. "$PSScriptRoot\..\lib\psmodules.ps1"
. "$PSScriptRoot\..\lib\versions.ps1"
. "$PSScriptRoot\..\lib\getopt.ps1"

reset_aliases

# options
$opt, $apps, $err = getopt $args 'gp' 'global', 'purge'

if ($err) {
    error "scoop uninstall: $err"
    exit 1
}

$global = $opt.g -or $opt.global
$purge = $opt.p -or $opt.purge

if (!$apps) {
    error '<app> missing'
    my_usage
    exit 1
}

if ($global -and !(is_admin)) {
    error 'You need admin rights to uninstall global apps.'
    exit 1
}

if ($apps -eq 'scoop') {
    & "$PSScriptRoot\..\bin\uninstall.ps1" $global $purge
    exit
}

$apps = Confirm-InstallationStatus $apps -Global:$global
if (!$apps) { exit 0 }

:app_loop foreach ($_ in $apps) {
    ($app, $global) = $_

    $version = current_version $app $global
    Write-Host "Uninstalling '$app' ($version)."

    $dir = versiondir $app $version $global
    $persist_dir = persistdir $app $global

    #region Workaround for #2952
    $processdir = appdir $app $global | Resolve-Path | Select-Object -ExpandProperty Path
    if (Get-Process | Where-Object { $_.Path -like "$processdir\*" }) {
        error "Application is still running. Close all instances and try again."
        continue
    }
    #endregion Workaround for #2952

    try {
        Test-Path $dir -ErrorAction Stop | Out-Null
    } catch [UnauthorizedAccessException] {
        error "Access denied: $dir. You might need to restart."
        continue
    }

    $manifest = installed_manifest $app $version $global
    $install = install_info $app $version $global
    $architecture = $install.architecture

    run_uninstaller $manifest $architecture $dir
    rm_shims $manifest $global $architecture
    rm_startmenu_shortcuts $manifest $global $architecture

    # If a junction was used during install, that will have been used
    # as the reference directory. Otherwise it will just be the version
    # directory.
    $refdir = unlink_current $dir

    uninstall_psmodule $manifest $refdir $global

    env_rm_path $manifest $refdir $global
    env_rm $manifest $global

    try {
        # unlink all potential old link before doing recursive Remove-Item
        unlink_persist_data $dir
        Remove-Item $dir -Recurse -Force -ErrorAction Stop
    } catch {
        if (Test-Path $dir) {
            error "Couldn't remove '$(friendly_path $dir)'; it may be in use."
            continue
        }
    }

    # remove older versions
    $old = @(versions $app $global)
    foreach ($oldver in $old) {
        Write-Host "Removing older version ($oldver)."
        $dir = versiondir $app $oldver $global
        try {
            # unlink all potential old link before doing recursive Remove-Item
            unlink_persist_data $dir
            Remove-Item $dir -Recurse -Force -ErrorAction Stop
        } catch {
            error "Couldn't remove '$(friendly_path $dir)'; it may be in use."
            continue app_loop
        }
    }

    if (@(versions $app $global).length -eq 0) {
        $appdir = appdir $app $global
        try {
            # if last install failed, the directory seems to be locked and this
            # will throw an error about the directory not existing
            Remove-Item $appdir -Recurse -Force -ErrorAction Stop
        } catch {
            if ((Test-Path $appdir)) { throw } # only throw if the dir still exists
        }
    }

    # purge persistant data
    if ($purge) {
        Write-Host 'Removing persisted data.'
        $persist_dir = persistdir $app $global

        if (Test-Path $persist_dir) {
            try {
                Remove-Item $persist_dir -Recurse -Force -ErrorAction Stop
            } catch {
                error "Couldn't remove '$(friendly_path $persist_dir)'; it may be in use."
                continue
            }
        }
    }

    success "'$app' was uninstalled."
}
# Usage: scoop hold <apps>
# Summary: Hold an app to disable updates

. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\manifest.ps1"

reset_aliases
$apps = $args

if(!$apps) {
    my_usage
    exit 1
}

$apps | ForEach-Object {
    $app = $_
    $global = installed $app $true

    if (!(installed $app)) {
        error "'$app' is not installed."
        return
    }

    $dir = versiondir $app 'current' $global
    $json = install_info $app 'current' $global
    $install = @{}
    $json | Get-Member -MemberType Properties | ForEach-Object { $install.Add($_.Name, $json.($_.Name))}
    $install.hold = $true
    save_install_info $install $dir
    success "$app is now held and can not be updated anymore."
# Usage: scoop export > filename
# Summary: Exports (an importable) list of installed apps
# Help: Lists all installed apps.

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"

reset_aliases
$def_arch = default_architecture

$local = installed_apps $false | ForEach-Object { @{ name = $_; global = $false } }
$global = installed_apps $true | ForEach-Object { @{ name = $_; global = $true } }

$apps = @($local) + @($global)
$count = 0

# json
# echo "{["

if($apps) {
    $apps | Sort-Object { $_.name } | Where-Object { !$query -or ($_.name -match $query) } | ForEach-Object {
        $app = $_.name
        $global = $_.global
        $ver = current_version $app $global
        $global_display = $null; if($global) { $global_display = ' *global*'}

        $install_info = install_info $app $ver $global
        $bucket = ''
        if ($install_info.bucket) {
            $bucket = ' [' + $install_info.bucket + ']'
        } elseif ($install_info.url) {
            $bucket = ' [' + $install_info.url + ']'
        }
        if ($install_info.architecture -and $def_arch -ne $install_info.architecture) {
            $arch = ' {' + $install_info.architecture + '}'
        } else {
            $arch = ''
        }

        # json
        # $val = "{ 'name': '$app', 'version': '$ver', 'global': $($global.toString().tolower()) }"
        # if($count -gt 0) {
        #     " ," + $val
        # } else {
        #     "  " + $val
        # }

        # "$app (v:$ver) global:$($global.toString().tolower())"
        "$app (v:$ver)$global_display$bucket$arch"

        $count++
    }
}
# Usage: scoop checkup
# Summary: Check for potential problems
# Help: Performs a series of diagnostic tests to try to identify things that may
# cause problems with Scoop.

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\diagnostic.ps1"

$issues = 0

$issues += !(check_windows_defender $false)
$issues += !(check_windows_defender $true)
$issues += !(check_main_bucket)
$issues += !(check_long_paths)
$issues += !(check_envs_requirements)

if (!(Test-HelperInstalled -Helper 7zip)) {
    error "'7-Zip' is not installed! It's required for unpacking most programs. Please Run 'scoop install 7zip' or 'scoop install 7zip-zstd'."
    $issues++
}

if (!(Test-HelperInstalled -Helper Innounp)) {
    error "'Inno Setup Unpacker' is not installed! It's required for unpacking InnoSetup files. Please run 'scoop install innounp'."
    $issues++
}

if (!(Test-HelperInstalled -Helper Dark)) {
    error "'dark' is not installed! It's required for unpacking installers created with the WiX Toolset. Please run 'scoop install dark' or 'scoop install wixtoolset'."
    $issues++
}

$globaldir = New-Object System.IO.DriveInfo($globaldir)
if($globaldir.DriveFormat -ne 'NTFS') {
    error "Scoop requires an NTFS volume to work! Please point `$env:SCOOP_GLOBAL or 'globalPath' variable in '~/.config/scoop/config.json' to another Drive."
    $issues++
}

$scoopdir = New-Object System.IO.DriveInfo($scoopdir)
if($scoopdir.DriveFormat -ne 'NTFS') {
    error "Scoop requires an NTFS volume to work! Please point `$env:SCOOP or 'rootPath' variable in '~/.config/scoop/config.json' to another Drive."
    $issues++
}

if($issues) {
    warn "Found $issues potential $(pluralize $issues problem problems)."
# Usage: scoop prefix <app>
# Summary: Returns the path to the specified app
param($app)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"

reset_aliases

if(!$app) { my_usage; exit 1 }

$app_path = versiondir $app 'current' $false
if(!(Test-Path $app_path)) {
    $app_path = versiondir $app 'current' $true
}

if(Test-Path $app_path) {
    Write-Output $app_path
# Usage: scoop unhold <app>
# Summary: Unhold an app to enable updates

. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\manifest.ps1"

reset_aliases
$apps = $args

if(!$apps) {
    my_usage
    exit 1
}

$apps | ForEach-Object {
    $app = $_
    $global = installed $app $true

    if (!(installed $app)) {
        error "'$app' is not installed."
        return
    }

    $dir = versiondir $app 'current' $global
    $json = install_info $app 'current' $global
    $install = @{}
    $json | Get-Member -MemberType Properties | ForEach-Object { $install.Add($_.Name, $json.($_.Name))}
    $install.hold = $null
    save_install_info $install $dir
    success "$app is no longer held and can be updated again."
# Usage: scoop search <query>
# Summary: Search available apps
# Help: Searches for apps that are available to install.
#
# If used with [query], shows app names that match the query.
# Without [query], shows all the available apps.
param($query)
. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\versions.ps1"

reset_aliases

function bin_match($manifest, $query) {
    if(!$manifest.bin) { return $false }
    foreach($bin in $manifest.bin) {
        $exe, $alias, $args = $bin
        $fname = split-path $exe -leaf -ea stop

        if((strip_ext $fname) -match $query) { return $fname }
        if($alias -match $query) { return $alias }
    }
    $false
}

function search_bucket($bucket, $query) {
    $apps = apps_in_bucket (Find-BucketDirectory $bucket) | ForEach-Object {
        @{ name = $_ }
    }

    if($query) {
        try {
            $query = new-object regex $query, 'IgnoreCase'
        } catch {
            abort "Invalid regular expression: $($_.exception.innerexception.message)"
        }

        $apps = $apps | Where-Object {
            if($_.name -match $query) { return $true }
            $bin = bin_match (manifest $_.name $bucket) $query
            if($bin) {
                $_.bin = $bin; return $true;
            }
        }
    }
    $apps | ForEach-Object { $_.version = (latest_version $_.name $bucket); $_ }
}

function download_json($url) {
    $progressPreference = 'silentlycontinue'
    $result = invoke-webrequest $url -UseBasicParsing | Select-Object -exp content | convertfrom-json
    $progressPreference = 'continue'
    $result
}

function github_ratelimit_reached {
    $api_link = "https://api.github.com/rate_limit"
    (download_json $api_link).rate.remaining -eq 0
}

function search_remote($bucket, $query) {
    $repo = known_bucket_repo $bucket

    $uri = [system.uri]($repo)
    if ($uri.absolutepath -match '/([a-zA-Z0-9]*)/([a-zA-Z0-9-]*)(.git|/)?') {
        $user = $matches[1]
        $repo_name = $matches[2]
        $api_link = "https://api.github.com/repos/$user/$repo_name/git/trees/HEAD?recursive=1"
        $result = download_json $api_link | Select-Object -exp tree | Where-Object {
            $_.path -match "(^(.*$query.*).json$)"
        } | ForEach-Object { $matches[2] }
    }

    $result
}

function search_remotes($query) {
    $buckets = known_bucket_repos
    $names = $buckets | get-member -m noteproperty | Select-Object -exp name

    $results = $names | Where-Object { !(test-path $(Find-BucketDirectory $_)) } | ForEach-Object {
        @{"bucket" = $_; "results" = (search_remote $_ $query)}
    } | Where-Object { $_.results }

    if ($results.count -gt 0) {
        "Results from other known buckets..."
        "(add them using 'scoop bucket add <name>')"
        ""
    }

    $results | ForEach-Object {
        "'$($_.bucket)' bucket:"
        $_.results | ForEach-Object { "    $_" }
        ""
    }
}

Get-LocalBucket | ForEach-Object {
    $res = search_bucket $_ $query
    $local_results = $local_results -or $res
    if($res) {
        $name = "$_"

        Write-Host "'$name' bucket:"
        $res | ForEach-Object {
            $item = "    $($_.name) ($($_.version))"
            if($_.bin) { $item += " --> includes '$($_.bin)'" }
            $item
        }
        ""
    }
}

if (!$local_results -and !(github_ratelimit_reached)) {
    $remote_results = search_remotes $query
    if(!$remote_results) { [console]::error.writeline("No matches found."); exit 1 }
    $remote_results
}

# Usage: scoop status
# Summary: Show status and check for new app versions

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\depends.ps1"
. "$psscriptroot\..\lib\git.ps1"

reset_aliases

# check if scoop needs updating
$currentdir = fullpath $(versiondir 'scoop' 'current')
$needs_update = $false

if(test-path "$currentdir\.git") {
    Push-Location $currentdir
    git_fetch -q origin
    $commits = $(git log "HEAD..origin/$(scoop config SCOOP_BRANCH)" --oneline)
    if($commits) { $needs_update = $true }
    Pop-Location
}
else {
    $needs_update = $true
}

if($needs_update) {
    warn "Scoop is out of date. Run 'scoop update' to get the latest changes."
}
else { success "Scoop is up to date."}

$failed = @()
$outdated = @()
$removed = @()
$missing_deps = @()
$onhold = @()

$true, $false | ForEach-Object { # local and global apps
    $global = $_
    $dir = appsdir $global
    if(!(test-path $dir)) { return }

    Get-ChildItem $dir | Where-Object name -ne 'scoop' | ForEach-Object {
        $app = $_.name
        $status = app_status $app $global
        if($status.failed) {
            $failed += @{ $app = $status.version }
        }
        if($status.removed) {
            $removed += @{ $app = $status.version }
        }
        if($status.outdated) {
            $outdated += @{ $app = @($status.version, $status.latest_version) }
            if($status.hold) {
                $onhold += @{ $app = @($status.version, $status.latest_version) }
            }
        }
        if($status.missing_deps) {
            $missing_deps += ,(@($app) + @($status.missing_deps))
        }
    }
}

if($outdated) {
    write-host -f DarkCyan 'Updates are available for:'
    $outdated.keys | ForEach-Object {
        $versions = $outdated.$_
        "    $_`: $($versions[0]) -> $($versions[1])"
    }
}

if($onhold) {
    write-host -f DarkCyan 'These apps are outdated and on hold:'
    $onhold.keys | ForEach-Object {
        $versions = $onhold.$_
        "    $_`: $($versions[0]) -> $($versions[1])"
    }
}

if($removed) {
    write-host -f DarkCyan 'These app manifests have been removed:'
    $removed.keys | ForEach-Object {
        "    $_"
    }
}

if($failed) {
    write-host -f DarkCyan 'These apps failed to install:'
    $failed.keys | ForEach-Object {
        "    $_"
    }
}

if($missing_deps) {
    write-host -f DarkCyan 'Missing runtime dependencies:'
    $missing_deps | ForEach-Object {
        $app, $deps = $_
        "    '$app' requires '$([string]::join("', '", $deps))'"
    }
}

if(!$old -and !$removed -and !$failed -and !$missing_deps -and !$needs_update) {
    success "Everything is ok!"
}
# Usage: scoop which <command>
# Summary: Locate a shim/executable (similar to 'which' on Linux)
# Help: Locate the path to a shim/executable that was installed with Scoop (similar to 'which' on Linux)
param($command)
. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\help.ps1"

reset_aliases

if(!$command) { 'ERROR: <command> missing'; my_usage; exit 1 }

try {
    $gcm = Get-Command "$command" -ea stop
} catch {
    abort "'$command' not found" 3
}

$path = "$($gcm.path)"
$usershims = "$(resolve-path $(shimdir $false))"
$globalshims = fullpath (shimdir $true) # don't resolve: may not exist

if($path.endswith(".ps1") -and ($path -like "$usershims*" -or $path -like "$globalshims*")) {
    $shimtext = Get-Content $path

    $exepath = ($shimtext | Where-Object { $_.startswith('$path') }).split(' ') | Select-Object -Last 1 | Invoke-Expression

    if(![system.io.path]::ispathrooted($exepath)) {
        # Expand relative path
        $exepath = resolve-path (join-path (split-path $path) $exepath)
    }

    friendly_path $exepath
} elseif($gcm.commandtype -eq 'Application') {
    $gcm.Source
} elseif($gcm.commandtype -eq 'Alias') {
    scoop which $gcm.resolvedcommandname
} else {
    [console]::error.writeline("Not a scoop shim.")
    $path
    exit 2
# Usage: scoop alias add|list|rm [<args>]
# Summary: Manage scoop aliases
# Help: Add, remove or list Scoop aliases
#
# Aliases are custom Scoop subcommands that can be created to make common tasks
# easier.
#
# To add an Alias:
#     scoop alias add <name> <command> <description>
#
# e.g.:
#     scoop alias add rm 'scoop uninstall $args[0]' 'Uninstalls an app'
#     scoop alias add upgrade 'scoop update *' 'Updates all apps, just like brew or apt'
#
# Options:
#   -v, --verbose   Show alias description and table headers (works only for 'list')

param(
  [String]$opt,
  [String]$name,
  [String]$command,
  [String]$description,
  [Switch]$verbose = $false
)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\install.ps1"

$script:config_alias = "alias"

function init_alias_config {
    $aliases = get_config $script:config_alias
    if(!$aliases) {
        $aliases = @{}
    }

    return $aliases
}

function add_alias($name, $command) {
    if(!$command) {
        abort "Can't create an empty alias."
    }

    # get current aliases from config
    $aliases = init_alias_config
    if($aliases.$name) {
        abort "Alias $name already exists."
    }

    $alias_file = "scoop-$name"

    # generate script
    $shimdir = shimdir $false
    $script =
@"
# Summary: $description
$command
"@
    $script | out-file "$shimdir\$alias_file.ps1" -encoding utf8

    # add alias to config
    $aliases | Add-Member -MemberType NoteProperty -Name $name -Value $alias_file

    set_config $script:config_alias $aliases | Out-Null
}

function rm_alias($name) {
    $aliases = init_alias_config
    if(!$name) {
        abort "Which alias should be removed?"
    }

    if($aliases.$name) {
        "Removing alias $name..."

        rm_shim $aliases.$name (shimdir $false)

        $aliases.PSObject.Properties.Remove($name)
        set_config $script:config_alias $aliases | Out-Null
    } else {
        abort "Alias $name doesn't exist."
    }
}

function list_aliases {
    $aliases = @()

    (init_alias_config).PSObject.Properties.GetEnumerator() | ForEach-Object {
        $content = Get-Content (command_path $_.Name)
        $command = ($content | Select-Object -Skip 1).Trim()
        $summary = (summary $content).Trim()

        $aliases += New-Object psobject -Property @{Name=$_.name; Summary=$summary; Command=$command}
    }

    if(!$aliases.count) {
        warn "No aliases founds."
    }
    $aliases = $aliases.GetEnumerator() | Sort-Object Name
    if($verbose) {
        return $aliases | Select-Object Name, Command, Summary | Format-Table -autosize -wrap
    } else {
        return $aliases | Select-Object Name, Command | Format-Table -autosize -hidetablehead -wrap
    }
}

switch($opt) {
    "add" { add_alias $name $command }
    "rm" { rm_alias $name }
    "list" { list_aliases }
    default { my_usage; exit 1 }
}

# Usage: scoop install <app> [options]
# Summary: Install apps
# Help: e.g. The usual way to install an app (uses your local 'buckets'):
#      scoop install git
#
# To install an app from a manifest at a URL:
#      scoop install https://raw.githubusercontent.com/ScoopInstaller/Main/master/bucket/runat.json
#
# To install an app from a manifest on your computer
#      scoop install \path\to\app.json
#
# Options:
#   -g, --global              Install the app globally
#   -i, --independent         Don't install dependencies automatically
#   -k, --no-cache            Don't use the download cache
#   -s, --skip                Skip hash validation (use with caution!)
#   -a, --arch <32bit|64bit>  Use the specified architecture, if the app supports it

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\decompress.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\shortcuts.ps1"
. "$psscriptroot\..\lib\psmodules.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\getopt.ps1"
. "$psscriptroot\..\lib\depends.ps1"

reset_aliases

function is_installed($app, $global) {
    if ($app.EndsWith('.json')) {
        $app = [System.IO.Path]::GetFileNameWithoutExtension($app)
    }
    if (installed $app $global) {
        function gf($g) { if ($g) { ' --global' } }

        $version = @(versions $app $global)[-1]
        if (!(install_info $app $version $global)) {
            error "It looks like a previous installation of $app failed.`nRun 'scoop uninstall $app$(gf $global)' before retrying the install."
        }
        warn "'$app' ($version) is already installed.`nUse 'scoop update $app$(gf $global)' to install a new version."
        return $true
    }
    return $false
}

$opt, $apps, $err = getopt $args 'gfiksa:' 'global', 'force', 'independent', 'no-cache', 'skip', 'arch='
if ($err) { "scoop install: $err"; exit 1 }

$global = $opt.g -or $opt.global
$check_hash = !($opt.s -or $opt.skip)
$independent = $opt.i -or $opt.independent
$use_cache = !($opt.k -or $opt.'no-cache')
$architecture = default_architecture
try {
    $architecture = ensure_architecture ($opt.a + $opt.arch)
} catch {
    abort "ERROR: $_"
}

if (!$apps) { error '<app> missing'; my_usage; exit 1 }

if ($global -and !(is_admin)) {
    abort 'ERROR: you need admin rights to install global apps'
}

if (is_scoop_outdated) {
    scoop update
}

if ($apps.length -eq 1) {
    $app, $null, $version = parse_app $apps
    if ($null -eq $version -and (is_installed $app $global)) {
        return
    }
}

# get any specific versions that we need to handle first
$specific_versions = $apps | Where-Object {
    $null, $null, $version = parse_app $_
    return $null -ne $version
}

# compare object does not like nulls
if ($specific_versions.length -gt 0) {
    $difference = Compare-Object -ReferenceObject $apps -DifferenceObject $specific_versions -PassThru
} else {
    $difference = $apps
}

$specific_versions_paths = $specific_versions | ForEach-Object {
    $app, $bucket, $version = parse_app $_
    if (installed_manifest $app $version) {
        abort "'$app' ($version) is already installed.`nUse 'scoop update $app$global_flag' to install a new version."
    }

    generate_user_manifest $app $bucket $version
}
$apps = @(($specific_versions_paths + $difference) | Where-Object { $_ } | Sort-Object -Unique)

# remember which were explictly requested so that we can
# differentiate after dependencies are added
$explicit_apps = $apps

if (!$independent) {
    $apps = install_order $apps $architecture # adds dependencies
}
ensure_none_failed $apps $global

$apps, $skip = prune_installed $apps $global

$skip | Where-Object { $explicit_apps -contains $_ } | ForEach-Object {
    $app, $null, $null = parse_app $_
    $version = @(versions $app $global)[-1]
    warn "'$app' ($version) is already installed. Skipping."
}

$suggested = @{ };
if (Test-Aria2Enabled) {
    warn "Scoop uses 'aria2c' for multi-connection downloads."
    warn "Should it cause issues, run 'scoop config aria2-enabled false' to disable it."
}
# Usage: scoop cleanup <app> [options]
# Summary: Cleanup apps by removing old versions
# Help: 'scoop cleanup' cleans Scoop apps by removing old versions.
# 'scoop cleanup <app>' cleans up the old versions of that app if said versions exist.
#
# You can use '*' in place of <app> to cleanup all apps.
#
# Options:
#   -g, --global       Cleanup a globally installed app
#   -k, --cache        Remove outdated download cache

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\getopt.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\install.ps1"

reset_aliases

$opt, $apps, $err = getopt $args 'gk' 'global', 'cache'
if ($err) { "scoop cleanup: $err"; exit 1 }
$global = $opt.g -or $opt.global
$cache = $opt.k -or $opt.cache

if (!$apps) { 'ERROR: <app> missing'; my_usage; exit 1 }

if ($global -and !(is_admin)) {
    'ERROR: you need admin rights to cleanup global apps'; exit 1
}

function cleanup($app, $global, $verbose, $cache) {
    $current_version = current_version $app $global
    if ($cache) {
        Remove-Item "$cachedir\$app#*" -Exclude "$app#$current_version#*"
    }
    $versions = versions $app $global | Where-Object { $_ -ne $current_version -and $_ -ne 'current' }
    if (!$versions) {
        if ($verbose) { success "$app is already clean" }
        return
    }

    write-host -f yellow "Removing $app`:" -nonewline
    $versions | ForEach-Object {
        $version = $_
        write-host " $version" -nonewline
        $dir = versiondir $app $version $global
        # unlink all potential old link before doing recursive Remove-Item
        unlink_persist_data $dir
        Remove-Item $dir -ErrorAction Stop -Recurse -Force
    }
    write-host ''
}

if ($apps) {
    $verbose = $true
    if ($apps -eq '*') {
        $verbose = $false
        $apps = applist (installed_apps $false) $false
        if ($global) {
            $apps += applist (installed_apps $true) $true
        }
    } else {
        $apps = Confirm-InstallationStatus $apps -Global:$global
    }

    # $apps is now a list of ($app, $global) tuples
    $apps | ForEach-Object { cleanup @_ $verbose $cache}

    if ($cache) {
        Remove-Item "$cachedir\*.download" -ErrorAction Ignore
    }

    if (!$verbose) {
# Usage: scoop depends <app>
# Summary: List dependencies for an app

. "$psscriptroot\..\lib\depends.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\getopt.ps1"
. "$psscriptroot\..\lib\decompress.ps1"
. "$psscriptroot\..\lib\help.ps1"

reset_aliases

$opt, $apps, $err = getopt $args 'a:' 'arch='
$app = $apps[0]

if(!$app) { error '<app> missing'; my_usage; exit 1 }

$architecture = default_architecture
try {
    $architecture = ensure_architecture ($opt.a + $opt.arch)
} catch {
    abort "ERROR: $_"
}

$deps = @(deps $app $architecture)
if($deps) {
    $deps[($deps.length - 1)..0]
}

# Usage: scoop info <app>
# Summary: Display information about an app
param($app)

. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\depends.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\versions.ps1"

reset_aliases

if(!$app) { my_usage; exit 1 }

if ($app -match '^(ht|f)tps?://|\\\\') {
    # check if $app is a URL or UNC path
    $url = $app
    $app = appname_from_url $url
    $global = installed $app $true
    $status = app_status $app $global
    $manifest = url_manifest $url
    $manifest_file = $url
} else {
    # else $app is a normal app name
    $global = installed $app $true
    $app, $bucket, $null = parse_app $app
    $status = app_status $app $global
    $manifest, $bucket = find_manifest $app $bucket
}

if (!$manifest) {
    abort "Could not find manifest for '$(show_app $app $bucket)'."
}

$install = install_info $app $status.version $global
$status.installed = $install.bucket -eq $bucket
$version_output = $manifest.version
if (!$manifest_file) {
    $manifest_file = manifest_path $app $bucket
}

$dir = versiondir $app 'current' $global
$original_dir = versiondir $app $manifest.version $global
$persist_dir = persistdir $app $global

if($status.installed) {
    $manifest_file = manifest_path $app $install.bucket
    if ($install.url) {
        $manifest_file = $install.url
    }
    if($status.version -eq $manifest.version) {
        $version_output = $status.version
    } else {
        $version_output = "$($status.version) (Update to $($manifest.version) available)"
    }
}

Write-Output "Name: $app"
if ($manifest.description) {
    Write-Output "Description: $($manifest.description)"
}
Write-Output "Version: $version_output"
Write-Output "Website: $($manifest.homepage)"
# Show license
if ($manifest.license) {
    $license = $manifest.license
    if ($manifest.license.identifier -and $manifest.license.url) {
        $license = "$($manifest.license.identifier) ($($manifest.license.url))"
    } elseif ($manifest.license -match '^((ht)|f)tps?://') {
        $license = "$($manifest.license)"
    } elseif ($manifest.license -match '[|,]') {
        $licurl = $manifest.license.Split("|,") | ForEach-Object {"https://spdx.org/licenses/$_.html"}
        $license = "$($manifest.license) ($($licurl -join ', '))"
    } else {
        $license = "$($manifest.license) (https://spdx.org/licenses/$($manifest.license).html)"
    }
    Write-Output "License: $license"
}

# Manifest file
Write-Output "Manifest:`n  $manifest_file"

if($status.installed) {
    # Show installed versions
    Write-Output "Installed:"
    $versions = versions $app $global
    $versions | ForEach-Object {
        $dir = versiondir $app $_ $global
        if($global) { $dir += " *global*" }
        Write-Output "  $dir"
    }
} else {
    Write-Output "Installed: No"
}

$binaries = @(arch_specific 'bin' $manifest $install.architecture)
if($binaries) {
    $binary_output = "Binaries:`n "
    $binaries | ForEach-Object {
        if($_ -is [System.Array]) {
            $binary_output += " $($_[1]).exe"
        } else {
            $binary_output += " $_"
        }
    }
    Write-Output $binary_output
}

if($manifest.env_set -or $manifest.env_add_path) {
    if($status.installed) {
        Write-Output "Environment:"
    } else {
        Write-Output "Environment: (simulated)"
    }
}
if($manifest.env_set) {
    $manifest.env_set | Get-Member -member noteproperty | ForEach-Object {
        $value = env $_.name $global
        if(!$value) {
            $value = format $manifest.env_set.$($_.name) @{ "dir" = $dir }
        }
        Write-Output "  $($_.name)=$value"
    }
}
if($manifest.env_add_path) {
    $manifest.env_add_path | Where-Object { $_ } | ForEach-Object {
        if($_ -eq '.') {
            Write-Output "  PATH=%PATH%;$dir"
        } else {
            Write-Output "  PATH=%PATH%;$dir\$_"
        }
    }
}
# Usage: scoop help <command>
# Summary: Show help for a command
param($cmd)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\commands.ps1"
. "$psscriptroot\..\lib\help.ps1"

reset_aliases

function print_help($cmd) {
    $file = Get-Content (command_path $cmd) -raw

    $usage = usage $file
    $summary = summary $file
    $help = scoop_help $file

    if($usage) { "$usage`n" }
    if($help) { $help }
}

function print_summaries {
    $commands = @{}

    command_files | ForEach-Object {
        $command = command_name $_
        $summary = summary (Get-Content (command_path $command) -raw)
        if(!($summary)) { $summary = '' }
        $commands.add("$command ", $summary) # add padding
    }

    $commands.getenumerator() | Sort-Object name | Format-Table -hidetablehead -autosize -wrap
}

$commands = commands

if(!($cmd)) {
    "Usage: scoop <command> [<args>]

Some useful commands are:"
    print_summaries
    "Type 'scoop help <command>' to get help for a specific command."
} elseif($commands -contains $cmd) {
    print_help $cmd
} else {
# Usage: scoop cache show|rm [app]
# Summary: Show or clear the download cache
# Help: Scoop caches downloads so you don't need to download the same files
# when you uninstall and re-install the same version of an app.
#
# You can use
#     scoop cache show
# to see what's in the cache, and
#     scoop cache rm <app> to remove downloads for a specific app.
#
# To clear everything in your cache, use:
#     scoop cache rm *
param($cmd, $app)

. "$psscriptroot\..\lib\help.ps1"

reset_aliases

function cacheinfo($file) {
    $app, $version, $url = $file.name -split '#'
    $size = filesize $file.length
    return new-object psobject -prop @{ app=$app; version=$version; url=$url; size=$size }
}

function show($app) {
    $files = @(Get-ChildItem "$cachedir" | Where-Object { $_.name -match "^$app" })
    $total_length = ($files | Measure-Object length -sum).sum -as [double]

    $f_app  = @{ expression={"$($_.app) ($($_.version))" }}
    $f_url  = @{ expression={$_.url};alignment='right'}
    $f_size = @{ expression={$_.size}; alignment='right'}


    $files | ForEach-Object { cacheinfo $_ } | Format-Table $f_size, $f_app, $f_url -auto -hide

    "Total: $($files.length) $(pluralize $files.length 'file' 'files'), $(filesize $total_length)"
}

switch($cmd) {
    'rm' {
        if(!$app) { 'ERROR: <app> missing'; my_usage; exit 1 }
        Remove-Item "$cachedir\$app#*"
        if(test-path("$cachedir\$app.txt")) {
            Remove-Item "$cachedir\$app.txt"
        }
    }
    'show' {
        show $app
    }
    '' {
        show
    }
    default {
        my_usage
    }
# Usage: scoop virustotal [* | app1 app2 ...] [options]
# Summary: Look for app's hash on virustotal.com
# Help: Look for app's hash (MD5, SHA1 or SHA256) on virustotal.com
#
# Use a single '*' for app to check all installed apps.
#
# The download's hash is also a key to access VirusTotal's scan results.
# This allows to check the safety of the files without even downloading
# them in many cases.  If the hash is unknown to VirusTotal, the
# download link is printed to submit it to VirusTotal.
#
# If you have signed up to VirusTotal's community, you have an API key
# that this script can use to submit unknown packages for inspection
# if you use the `--scan' flag.  Tell scoop about your API key with:
#
#   scoop config virustotal_api_key <your API key: 64 lower case hex digits>
#
# Exit codes:
# 0 -> success
# 1 -> problem parsing arguments
# 2 -> at least one package was marked unsafe by VirusTotal
# 4 -> at least one exception was raised while looking for info
# 8 -> at least one package couldn't be queried because its hash type
#      isn't supported by VirusTotal, the manifest couldn't be found
#      or didn't contain a hash
# Note: the exit codes (2, 4 & 8) may be combined, e.g. 6 -> exit codes
#       2 & 4 combined
#
# Options:
#   -a, --arch <32bit|64bit>  Use the specified architecture, if the app supports it
#   -s, --scan For packages where VirusTotal has no information, send download URL
#              for analysis (and future retrieval).  This requires you to configure
#              your virustotal_api_key.
#   -n, --no-depends By default, all dependencies are checked, too.  This flag allows
#                    to avoid it.

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\getopt.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\json.ps1"
. "$psscriptroot\..\lib\decompress.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\depends.ps1"

reset_aliases

$opt, $apps, $err = getopt $args 'a:sn' @('arch=', 'scan', 'no-depends')
if($err) { "scoop virustotal: $err"; exit 1 }
if(!$apps) { my_usage; exit 1 }
$architecture = ensure_architecture ($opt.a + $opt.arch)

if(is_scoop_outdated) { scoop update }

$apps_param = $apps

if($apps_param -eq '*') {
    $apps = installed_apps $false
    $apps += installed_apps $true
}

if (!$opt.n -and !$opt."no-depends") {
    $apps = install_order $apps $architecture
}

$_ERR_UNSAFE = 2
$_ERR_EXCEPTION = 4
$_ERR_NO_INFO = 8

$exit_code = 0

# Global flag to warn only once about missing API key:
$warned_no_api_key = $False

# Global flag to explain only once about sleep between requests
$explained_rate_limit_sleeping = $False

# Requests counter to slow down requests submitted to VirusTotal as
# script execution progresses
$requests = 0

Function Get-VirusTotalResult($hash, $app) {
    $hash = $hash.ToLower()
    $url = "https://www.virustotal.com/ui/files/$hash"
    $wc = New-Object Net.Webclient
    $wc.Headers.Add('User-Agent', (Get-UserAgent))
    $result = $wc.downloadstring($url)
    $stats = json_path $result '$.data.attributes.last_analysis_stats'
    $malicious = json_path $stats '$.malicious'
    $suspicious = json_path $stats '$.suspicious'
    $undetected = json_path $stats '$.undetected'
    $unsafe = [int]$malicious + [int]$suspicious
    $see_url = "see https://www.virustotal.com/#/file/$hash/detection"
    switch ($unsafe) {
        0 { if ($undetected -eq 0) { $fg = "Yellow" } else { $fg = "DarkGreen" } }
        1 { $fg = "DarkYellow" }
        2 { $fg = "Yellow" }
        default { $fg = "Red" }
    }
    write-host -f $fg "$app`: $unsafe/$undetected, $see_url"
    if($unsafe -gt 0) {
        return $_ERR_UNSAFE
    }
    return 0
}

Function Search-VirusTotal ($hash, $app) {
    if ($hash -match '(?<algo>[^:]+):(?<hash>.*)') {
        $hash = $matches['hash']
        if ($matches['algo'] -match '(md5|sha1|sha256)') {
            return Get-VirusTotalResult $hash $app
        } else {
            warn "$app`: Unsupported hash $($matches['algo']). VirusTotal needs md5, sha1 or sha256."
            return $_ERR_NO_INFO
        }
    }

    return Get-VirusTotalResult $hash $app
}

Function Submit-RedirectedUrl {
    # Follow up to one level of HTTP redirection
    #
    # Copied from http://www.powershellmagazine.com/2013/01/29/pstip-retrieve-a-redirected-url/
    # Adapted according to Roy's response (January 23, 2014 at 11:59 am)
    # Adapted to always return an URL
    Param (
        [Parameter(Mandatory=$true)]
        [String]$URL
    )
    $request = [System.Net.WebRequest]::Create($url)
    $request.AllowAutoRedirect=$false
    $response=$request.GetResponse()
    if (([int]$response.StatusCode -ge 300) -and ([int]$response.StatusCode -lt 400)) {
        $redir = $response.GetResponseHeader("Location")
    }
    else {
        $redir = $URL
    }
    $response.Close()
    return $redir
}

# Submit-ToVirusTotal
# - $url: where file to check can be downloaded
# - $app: Name of the application (used for reporting)
# - $do_scan: [boolean flag] whether to actually submit to VirusTotal
#             This is a parameter instead of conditionnally calling
#             the function to consolidate the warning message
# - $retrying: [boolean] Optional, for internal use to retry
#              submitting the file after a delay if the rate limit is
#              exceeded, without risking an infinite loop (as stack
#              overflow) if the submission keeps failing.
Function Submit-ToVirusTotal ($url, $app, $do_scan, $retrying=$False) {
    $api_key = get_config("virustotal_api_key")
    if ($do_scan -and !$api_key -and !$warned_no_api_key) {
        $warned_no_api_key = $true
        info "Submitting unknown apps needs a VirusTotal API key.  " +
             "Set it up with`n`tscoop config virustotal_api_key <API key>"

    }
    if (!$do_scan -or !$api_key) {
        warn "$app`: not found`: manually submit $url"
        return
    }

    try {
        # Follow redirections (for e.g. sourceforge URLs) because
        # VirusTotal analyzes only "direct" download links
        $url = $url.Split("#").GetValue(0)
        $new_redir = $url
        do {
            $orig_redir = $new_redir
            $new_redir = Submit-RedirectedUrl $orig_redir
        } while ($orig_redir -ne $new_redir)
        $requests += 1
        $result = Invoke-WebRequest -Uri "https://www.virustotal.com/vtapi/v2/url/scan" -Body @{apikey=$api_key;url=$new_redir} -Method Post -UseBasicParsing
        $submitted = $result.StatusCode -eq 200
        if ($submitted) {
            warn "$app`: not found`: submitted $url"
            return
        }

        # EAFP: submission failed -> sleep, then retry
        if (!$retrying) {
            if (!$explained_rate_limit_sleeping) {
                $explained_rate_limit_sleeping = $True
                info "Sleeping 60+ seconds between requests due to VirusTotal's 4/min limit"
            }
            Start-Sleep -s (60 + $requests)
            Submit-ToVirusTotal $new_redir $app $do_scan $True
        } else {
            warn "$app`: VirusTotal submission of $url failed`:`n" +
                    "`tAPI returned $($result.StatusCode) after retrying"
        }
    } catch [Exception] {
        warn "$app`: VirusTotal submission failed`: $($_.Exception.Message)"
        return
    }
}

$apps | ForEach-Object {
    $app = $_
    # write-host $app
    $manifest, $bucket = find_manifest $app
    if(!$manifest) {
        $exit_code = $exit_code -bor $_ERR_NO_INFO
        warn "$app`: manifest not found"
        return
    }

    $urls = url $manifest $architecture
    $urls | ForEach-Object {
        $url = $_
        $hash = hash_for_url $manifest $url $architecture

        try {
            if($hash) {
                $exit_code = $exit_code -bor (Search-VirusTotal $hash $app)
            } else {
                warn "$app`: Can't find hash for $url"
            }
        } catch [Exception] {
            $exit_code = $exit_code -bor $_ERR_EXCEPTION
            if ($_.Exception.Message -like "*(404)*") {
                Submit-ToVirusTotal $url $app ($opt.scan -or $opt.s)
            } else {
                if ($_.Exception.Message -match "\(204|429\)") {
                    abort "$app`: VirusTotal request failed`: $($_.Exception.Message)", $exit_code
                }
                warn "$app`: VirusTotal request failed`: $($_.Exception.Message)"
            }
        }
    }
# Usage: scoop home <app>
# Summary: Opens the app homepage
param($app)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"

reset_aliases

if($app) {
    $manifest, $bucket = find_manifest $app
    if($manifest) {
        if([string]::isnullorempty($manifest.homepage)) {
            abort "Could not find homepage in manifest for '$app'."
        }
        Start-Process $manifest.homepage
    }
    else {
# Usage: scoop update <app> [options]
# Summary: Update apps, or Scoop itself
# Help: 'scoop update' updates Scoop to the latest version.
# 'scoop update <app>' installs a new version of that app, if there is one.
#
# You can use '*' in place of <app> to update all apps.
#
# Options:
#   -f, --force               Force update even when there isn't a newer version
#   -g, --global              Update a globally installed app
#   -i, --independent         Don't install dependencies automatically
#   -k, --no-cache            Don't use the download cache
#   -s, --skip                Skip hash validation (use with caution!)
#   -q, --quiet               Hide extraneous messages

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\shortcuts.ps1"
. "$psscriptroot\..\lib\psmodules.ps1"
. "$psscriptroot\..\lib\decompress.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\buckets.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\getopt.ps1"
. "$psscriptroot\..\lib\depends.ps1"
. "$psscriptroot\..\lib\git.ps1"
. "$psscriptroot\..\lib\install.ps1"

reset_aliases

$opt, $apps, $err = getopt $args 'gfiksq:' 'global', 'force', 'independent', 'no-cache', 'skip', 'quiet'
if ($err) { "scoop update: $err"; exit 1 }
$global = $opt.g -or $opt.global
$force = $opt.f -or $opt.force
$check_hash = !($opt.s -or $opt.skip)
$use_cache = !($opt.k -or $opt.'no-cache')
$quiet = $opt.q -or $opt.quiet
$independent = $opt.i -or $opt.independent

# load config
$configRepo = get_config SCOOP_REPO
if (!$configRepo) {
    $configRepo = "https://github.com/lukesampson/scoop"
    set_config SCOOP_REPO $configRepo | Out-Null
}

# Find current update channel from config
$configBranch = get_config SCOOP_BRANCH
if (!$configBranch) {
    $configBranch = "master"
    set_config SCOOP_BRANCH $configBranch | Out-Null
}

if(($PSVersionTable.PSVersion.Major) -lt 5) {
    # check powershell version
    Write-Output "PowerShell 5 or later is required to run Scoop."
    Write-Output "Upgrade PowerShell: https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows"
    break
}

function update_scoop() {
    # check for git
    if(!(Test-CommandAvailable git)) { abort "Scoop uses Git to update itself. Run 'scoop install git' and try again." }

    write-host "Updating Scoop..."
    $last_update = $(last_scoop_update)
    if ($null -eq $last_update) {$last_update = [System.DateTime]::Now}
    $last_update = $last_update.ToString('s')
    $show_update_log = get_config 'show_update_log' $true
    $currentdir = fullpath $(versiondir 'scoop' 'current')
    if (!(test-path "$currentdir\.git")) {
        $newdir = fullpath $(versiondir 'scoop' 'new')

        # get git scoop
        git_clone -q $configRepo --branch $configBranch --single-branch "`"$newdir`""

        # check if scoop was successful downloaded
        if (!(test-path "$newdir")) {
            abort 'Scoop update failed.'
        }

        # replace non-git scoop with the git version
        Remove-Item -r -force $currentdir -ea stop
        Move-Item $newdir $currentdir
    } else {
        Push-Location $currentdir

        $previousCommit = Invoke-Expression 'git rev-parse HEAD'
        $currentRepo = Invoke-Expression "git config remote.origin.url"
        $currentBranch = Invoke-Expression "git branch"

        $isRepoChanged = !($currentRepo -match $configRepo)
        $isBranchChanged = !($currentBranch -match "\*\s+$configBranch")

        # Change remote url if the repo is changed
        if ($isRepoChanged) {
            Invoke-Expression "git config remote.origin.url '$configRepo'"
        }

        # Fetch and reset local repo if the repo or the branch is changed
        if ($isRepoChanged -or $isBranchChanged) {
            # Reset git fetch refs, so that it can fetch all branches (GH-3368)
            Invoke-Expression "git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'"
            # fetch remote branch
            git_fetch --force origin "refs/heads/`"$configBranch`":refs/remotes/origin/$configBranch" -q
            # checkout and track the branch
            git_checkout -B $configBranch -t origin/$configBranch -q
            # reset branch HEAD
            Invoke-Expression "git reset --hard origin/$configBranch -q"
        } else {
            git_pull -q
        }

        $res = $lastexitcode
        if ($show_update_log) {
            Invoke-Expression "git --no-pager log --no-decorate --format='tformat: * %C(yellow)%h%Creset %<|(72,trunc)%s %C(cyan)%cr%Creset' '$previousCommit..HEAD'"
        }

        Pop-Location
        if ($res -ne 0) {
            abort 'Update failed.'
        }
    }

    if ((Get-LocalBucket) -notcontains 'main') {
        info "The main bucket of Scoop has been separated to 'https://github.com/ScoopInstaller/Main'"
        info "Adding main bucket..."
        add_bucket 'main'
    }

    ensure_scoop_in_path
    shim "$currentdir\bin\scoop.ps1" $false

    Get-LocalBucket | ForEach-Object {
        write-host "Updating '$_' bucket..."

        $loc = Find-BucketDirectory $_ -Root
        # Make sure main bucket, which was downloaded as zip, will be properly "converted" into git
        if (($_ -eq 'main') -and !(Test-Path "$loc\.git")) {
            rm_bucket 'main'
            add_bucket 'main'
        }

        Push-Location $loc
        $previousCommit = (Invoke-Expression 'git rev-parse HEAD')
        git_pull -q
        if ($show_update_log) {
            Invoke-Expression "git --no-pager log --no-decorate --format='tformat: * %C(yellow)%h%Creset %<|(72,trunc)%s %C(cyan)%cr%Creset' '$previousCommit..HEAD'"
        }
        Pop-Location
    }

    set_config lastupdate ([System.DateTime]::Now.ToString('o')) | Out-Null
    success 'Scoop was updated successfully!'
}

function update($app, $global, $quiet = $false, $independent, $suggested, $use_cache = $true, $check_hash = $true) {
    $old_version = current_version $app $global
    $old_manifest = installed_manifest $app $old_version $global
    $install = install_info $app $old_version $global

    # re-use architecture, bucket and url from first install
    $architecture = ensure_architecture $install.architecture
    $bucket = $install.bucket
    if ($null -eq $bucket) {
        $bucket = 'main'
    }
    $url = $install.url

    if (!$independent) {
        # check dependencies
        $man = if ($url) { $url } else { $app }
        $deps = @(deps $man $architecture) | Where-Object { !(installed $_) }
        $deps | ForEach-Object { install_app $_ $architecture $global $suggested $use_cache $check_hash }
    }

    $version = latest_version $app $bucket $url
    $is_nightly = $version -eq 'nightly'
    if ($is_nightly) {
        $version = nightly_version $(get-date) $quiet
        $check_hash = $false
    }

    if (!$force -and ($old_version -eq $version)) {
        if (!$quiet) {
            warn "The latest version of '$app' ($version) is already installed."
        }
        return
    }
    if (!$version) {
        # installed from a custom bucket/no longer supported
        error "No manifest available for '$app'."
        return
    }

    $manifest = manifest $app $bucket $url

    write-host "Updating '$app' ($old_version -> $version)"

    # region Workaround
    # Workaround for https://github.com/lukesampson/scoop/issues/2220 until install is refactored
    # Remove and replace whole region after proper fix
    Write-Host "Downloading new version"
    if (Test-Aria2Enabled) {
        dl_with_cache_aria2 $app $version $manifest $architecture $cachedir $manifest.cookie $true $check_hash
    } else {
        $urls = url $manifest $architecture

        foreach ($url in $urls) {
            dl_with_cache $app $version $url $null $manifest.cookie $true

            if ($check_hash) {
                $manifest_hash = hash_for_url $manifest $url $architecture
                $source = fullpath (cache_path $app $version $url)
                $ok, $err = check_hash $source $manifest_hash $(show_app $app $bucket)

                if (!$ok) {
                    error $err
                    if (test-path $source) {
                        # rm cached file
                        Remove-Item -force $source
                    }
                    if ($url.Contains('sourceforge.net')) {
                        Write-Host -f yellow 'SourceForge.net is known for causing hash validation fails. Please try again before opening a ticket.'
                    }
                    abort $(new_issue_msg $app $bucket "hash check failed")
                }
            }
        }
    }
    # There is no need to check hash again while installing
    $check_hash = $false
    # endregion Workaround

    $dir = versiondir $app $old_version $global
    $persist_dir = persistdir $app $global

    #region Workaround for #2952
    $processdir = appdir $app $global | Resolve-Path | Select-Object -ExpandProperty Path
    if (Get-Process | Where-Object { $_.Path -like "$processdir\*" }) {
        error "Application is still running. Close all instances and try again."
        return
    }
    #endregion Workaround for #2952

    write-host "Uninstalling '$app' ($old_version)"
    run_uninstaller $old_manifest $architecture $dir
    rm_shims $old_manifest $global $architecture
    env_rm_path $old_manifest $dir $global
    env_rm $old_manifest $global

    # If a junction was used during install, that will have been used
    # as the reference directory. Otherwise it will just be the version
    # directory.
    $refdir = unlink_current $dir

    if ($force -and ($old_version -eq $version)) {
        if (!(Test-Path "$dir/../_$version.old")) {
            Move-Item "$dir" "$dir/../_$version.old"
        } else {
            $i = 1
            While (Test-Path "$dir/../_$version.old($i)") {
                $i++
            }
            Move-Item "$dir" "$dir/../_$version.old($i)"
        }
    }

    if ($bucket) {
        # add bucket name it was installed from
        $app = "$bucket/$app"
    }
    if ($install.url) {
        # use the url of the install json if the application was installed through url
        $app = $install.url
    }
    install_app $app $architecture $global $suggested $use_cache $check_hash
}

if (!$apps) {
    if ($global) {
        "scoop update: --global is invalid when <app> is not specified."; exit 1
    }
    if (!$use_cache) {
        "scoop update: --no-cache is invalid when <app> is not specified."; exit 1
    }
    update_scoop
} else {
    if ($global -and !(is_admin)) {
        'ERROR: You need admin rights to update global apps.'; exit 1
    }

    if (is_scoop_outdated) {
        update_scoop
    }
    $outdated = @()
    $apps_param = $apps

    if ($apps_param -eq '*') {
        $apps = applist (installed_apps $false) $false
        if ($global) {
            $apps += applist (installed_apps $true) $true
        }
    } else {
        $apps = Confirm-InstallationStatus $apps_param -Global:$global
    }
    if ($apps) {
        $apps | ForEach-Object {
            ($app, $global) = $_
            $status = app_status $app $global
            if ($force -or $status.outdated) {
                if(!$status.hold) {
                    $outdated += applist $app $global
                    write-host -f yellow ("$app`: $($status.version) -> $($status.latest_version){0}" -f ('',' (global)')[$global])
                } else {
                    warn "'$app' is held to version $($status.version)"
                }
            } elseif ($apps_param -ne '*') {
                write-host -f green "$app`: $($status.version) (latest version)"
            }
        }

        if ($outdated -and (Test-Aria2Enabled)) {
            warn "Scoop uses 'aria2c' for multi-connection downloads."
            warn "Should it cause issues, run 'scoop config aria2-enabled false' to disable it."
        }
        if ($outdated.Length -gt 1) {
            write-host -f DarkCyan "Updating $($outdated.Length) outdated apps:"
        } elseif ($outdated.Length -eq 0) {
            write-host -f Green "Latest versions for all apps are installed! For more information try 'scoop status'"
        } else {
            write-host -f DarkCyan "Updating one outdated app:"
        }
    }

    $suggested = @{};
# Usage: scoop reset <app>
# Summary: Reset an app to resolve conflicts
# Help: Used to resolve conflicts in favor of a particular app. For example,
# if you've installed 'python' and 'python27', you can use 'scoop reset' to switch between
# using one or the other.

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\manifest.ps1"
. "$psscriptroot\..\lib\help.ps1"
. "$psscriptroot\..\lib\getopt.ps1"
. "$psscriptroot\..\lib\install.ps1"
. "$psscriptroot\..\lib\versions.ps1"
. "$psscriptroot\..\lib\shortcuts.ps1"

reset_aliases
$opt, $apps, $err = getopt $args
if($err) { "scoop reset: $err"; exit 1 }

if(!$apps) { error '<app> missing'; my_usage; exit 1 }

if($apps -eq '*') {
    $local = installed_apps $false | ForEach-Object { ,@($_, $false) }
    $global = installed_apps $true | ForEach-Object { ,@($_, $true) }
    $apps = @($local) + @($global)
}

$apps | ForEach-Object {
    ($app, $global) = $_

    $app, $bucket, $version = parse_app $app

    if(($global -eq $null) -and (installed $app $true)) {
        # set global flag when running reset command on specific app
        $global = $true
    }

    if($app -eq 'scoop') {
        # skip scoop
        return
    }

    if(!(installed $app)) {
        error "'$app' isn't installed"
        return
    }

    if ($null -eq $version) {
        $version = current_version $app $global
    }

    $manifest = installed_manifest $app $version $global
    # if this is null we know the version they're resetting to
    # is not installed
    if ($manifest -eq $null) {
        error "'$app ($version)' isn't installed"
        return
    }

    if($global -and !(is_admin)) {
        warn "'$app' ($version) is a global app. You need admin rights to reset it. Skipping."
        return
    }

    write-host "Resetting $app ($version)."

    $dir = resolve-path (versiondir $app $version $global)
    $original_dir = $dir
    $persist_dir = persistdir $app $global

    $install = install_info $app $version $global
    $architecture = $install.architecture

    $dir = link_current $dir
    create_shims $manifest $dir $global $architecture
    create_startmenu_shortcuts $manifest $dir $global $architecture
    env_add_path $manifest $dir
    env_set $manifest $dir $global
    # unlink all potential old link before re-persisting
    unlink_persist_data $original_dir
    persist_data $manifest $original_dir $persist_dir
# Usage: scoop create <url>
# Summary: Create a custom app manifest
# Help: Create your own custom app manifest
param($url)

function create_manifest($url) {
    $manifest = new_manifest

    $manifest.url = $url

    $url_parts = $null
    try {
        $url_parts = parse_url $url
    }
    catch {
        abort "Error: $url is not a valid URL"
    }

    $name = choose_item $url_parts "App name"
    $name = if ($name.Length -gt 0) {
        $name
    }
    else {
        file_name ($url_parts | select-object -last 1)
    }

    $manifest.version = choose_item $url_parts "Version"

    $manifest | convertto-json | out-file -filepath "$name.json" -encoding utf8
    $manifest_path = join-path $pwd "$name.json"
    write-host "Created '$manifest_path'."
}

function new_manifest() {
    @{ "homepage" = ""; "license" = ""; "version" = ""; "url" = "";
        "hash" = ""; "extract_dir" = ""; "bin" = ""; "depends" = "" }
}

function file_name($segment) {
    $segment.substring(0, $segment.lastindexof('.'))
}

function parse_url($url) {
    $uri = new-object Uri $url
    $uri.pathandquery.substring(1).split("/")
}

function choose_item($list, $query) {
    for ($i = 0; $i -lt $list.count; $i++) {
        $item = $list[$i]
        write-host "$($i + 1)) $item"
    }
    $sel = read-host $query

    if ($sel.trim() -match '^[0-9+]$') {
        return $list[$sel-1]
    }

    $sel
}

if (!$url) {
    scoop help create
}
else {
# Usage: scoop config [rm] name [value]
# Summary: Get or set configuration values
# Help: The scoop configuration file is saved at ~/.config/scoop/config.json.
#
# To get a configuration setting:
#
#     scoop config <name>
#
# To set a configuration setting:
#
#     scoop config <name> <value>
#
# To remove a configuration setting:
#
#     scoop config rm <name>
#
# Settings
# --------
#
# proxy: [username:password@]host:port
#
# By default, Scoop will use the proxy settings from Internet Options, but with anonymous authentication.
#
# * To use the credentials for the current logged-in user, use 'currentuser' in place of username:password
# * To use the system proxy settings configured in Internet Options, use 'default' in place of host:port
# * An empty or unset value for proxy is equivalent to 'default' (with no username or password)
# * To bypass the system proxy and connect directly, use 'none' (with no username or password)

param($name, $value)

. "$psscriptroot\..\lib\core.ps1"
. "$psscriptroot\..\lib\help.ps1"

reset_aliases

if(!$name) { my_usage; exit 1 }

if($name -like 'rm') {
    set_config $value $null | Out-Null
    Write-Output "'$value' has been removed"
} elseif($null -ne $value) {
    set_config $name $value | Out-Null
    Write-Output "'$name' has been set to '$value'"
} else {
    $value = get_config $name
    if($null -eq $value) {
        Write-Output "'$name' is not set"
    } else {
        Write-Output $value
    }
# https://github.com/edymtt/nugetstandalone
$destinationFolder = "$psscriptroot\packages"
if (!(Test-Path -path $destinationFolder)) {
    Write-Host -f Red "Run .\install.ps1 first!"
    exit 1
Param([Switch]$Fast)
Push-Location $psscriptroot
. "$psscriptroot\..\..\lib\install.ps1"

if(!$Fast) {
    Write-Host "Install dependencies ..."
    Invoke-Expression "$psscriptroot\install.ps1"
}

$output = "$psscriptroot\bin"
Write-Output 'Compiling shim.cs ...'
& "$psscriptroot\packages\Microsoft.Net.Compilers\tools\csc.exe" /deterministic /platform:anycpu /nologo /optimize /target:exe /out:"$output\shim.exe" shim.cs

Write-Output 'Computing checksums ...'
Remove-Item "$psscriptroot\bin\checksum.sha256" -ErrorAction Ignore
Remove-Item "$psscriptroot\bin\checksum.sha512" -ErrorAction Ignore
Get-ChildItem "$psscriptroot\bin\*" -Include *.exe,*.dll | ForEach-Object {
    "$(compute_hash $_ 'sha256') *$($_.Name)" | Out-File "$psscriptroot\bin\checksum.sha256" -Append -Encoding oem
    "$(compute_hash $_ 'sha512') *$($_.Name)" | Out-File "$psscriptroot\bin\checksum.sha512" -Append -Encoding oem
}
# https://github.com/edymtt/nugetstandalone
$destinationFolder = "$psscriptroot\packages"
if ((Test-Path -path $destinationFolder)) {
    Remove-Item -Path $destinationFolder -Recurse | Out-Null
}
# https://github.com/edymtt/nugetstandalone
$destinationFolder = "$psscriptroot\packages"
if (!(Test-Path -path $destinationFolder)) {
    Write-Host -f Red "Run .\install.ps1 first!"
    exit 1
Param([Switch]$Fast)
Push-Location $psscriptroot
. "$psscriptroot\..\..\lib\install.ps1"

if(!$Fast) {
    Write-Host "Install dependencies ..."
    Invoke-Expression "$psscriptroot\install.ps1"
}

$output = "$psscriptroot\bin"
if(!$Fast) {
    Get-ChildItem "$psscriptroot\packages\Newtonsoft.*\lib\net45\*.dll" -File | ForEach-Object { Copy-Item $_ $output }
}
Write-Output 'Compiling Scoop.Validator.cs ...'
& "$psscriptroot\packages\Microsoft.Net.Compilers\tools\csc.exe" /deterministic /platform:anycpu /nologo /optimize /target:library /reference:"$output\Newtonsoft.Json.dll","$output\Newtonsoft.Json.Schema.dll" /out:"$output\Scoop.Validator.dll" Scoop.Validator.cs
Write-Output 'Compiling validator.cs ...'
& "$psscriptroot\packages\Microsoft.Net.Compilers\tools\csc.exe" /deterministic /platform:anycpu /nologo /optimize /target:exe /reference:"$output\Scoop.Validator.dll","$output\Newtonsoft.Json.dll","$output\Newtonsoft.Json.Schema.dll" /out:"$output\validator.exe" validator.cs

Write-Output 'Computing checksums ...'
Remove-Item "$psscriptroot\bin\checksum.sha256" -ErrorAction Ignore
Remove-Item "$psscriptroot\bin\checksum.sha512" -ErrorAction Ignore
Get-ChildItem "$psscriptroot\bin\*" -Include *.exe,*.dll | ForEach-Object {
    "$(compute_hash $_ 'sha256') *$($_.Name)" | Out-File "$psscriptroot\bin\checksum.sha256" -Append -Encoding oem
    "$(compute_hash $_ 'sha512') *$($_.Name)" | Out-File "$psscriptroot\bin\checksum.sha512" -Append -Encoding oem
}
# https://github.com/edymtt/nugetstandalone
$destinationFolder = "$psscriptroot\packages"
if ((Test-Path -path $destinationFolder)) {
    Remove-Item -Path $destinationFolder -Recurse | Out-Null
}
$tool = $args[0]
if (Get-Command wt -ErrorAction SilentlyContinue) {
	Start-Process wt -ArgumentList "powershell.exe","-Command","& '$PSScriptRoot\$tool.exe'"
} else { 
	Start-Process powershell -ArgumentList "-Command","& '$PSScriptRoot\$tool.exe'"
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

7z x -y windows_package.7z

$env:MXNET_LIBRARY_PATH=join-path $pwd.Path windows_package\lib\libmxnet.dll
$env:PYTHONPATH=join-path $pwd.Path windows_package\python
$env:MXNET_STORAGE_FALLBACK_LOG_VERBOSE=0
$env:MXNET_SUBGRAPH_VERBOSE=0
$env:MXNET_HOME=[io.path]::combine($PSScriptRoot, 'mxnet_home')

C:\Python37\Scripts\pip install -r ci\docker\install\requirements
C:\Python37\python.exe -m pytest -v -m 'not serial' -n 4 --durations=50 --cov-report xml:tests_unittest.xml tests\python\unittest
if ($LastExitCode -ne 0) { Throw ("Error running parallel unittest, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
C:\Python37\python.exe -m pytest -v -m 'serial' --durations=50 --cov-report xml:tests_unittest.xml --cov-append tests\python\unittest
if ($LastExitCode -ne 0) { Throw ("Error running serial unittest, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
C:\Python37\python.exe -m pytest -v -m 'not serial' -n 4 --durations=50 --cov-report xml:tests_train.xml tests\python\train
if ($LastExitCode -ne 0) { Throw ("Error running parallel train tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
C:\Python37\python.exe -m pytest -v -m 'serial' --durations=50 --cov-report xml:tests_train.xml --cov-append tests\python\train
if ($LastExitCode -ne 0) { Throw ("Error running serial train tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
# Adding this extra test since it's not possible to set env var on the fly in Windows.
C:\Python37\python.exe -m pytest -v --durations=50 --cov-report xml:tests_unittest.xml --cov-append tests\python\unittest\test_operator.py::test_norm
if ($LastExitCode -ne 0) { Throw ("Error running unittest, python exited with status code " + ('{0:X}' -f $LastExitCode)) }

# Need to explicitly set the environment variable for MXNET_MEMORY_OPT.
$env:MXNET_MEMORY_OPT=1
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

7z x -y windows_package.7z

$env:MXNET_LIBRARY_PATH=join-path $pwd.Path windows_package\lib\libmxnet.dll
$env:PYTHONPATH=join-path $pwd.Path windows_package\python
$env:MXNET_STORAGE_FALLBACK_LOG_VERBOSE=0
$env:MXNET_SUBGRAPH_VERBOSE=0
$env:MXNET_HOME=[io.path]::combine($PSScriptRoot, 'mxnet_home')
$env:MXNET_GPU_MEM_POOL_TYPE="Unpooled"

C:\Python37\Scripts\pip install -r ci\docker\install\requirements
C:\Python37\python.exe -m pytest -v -m 'not serial' -n 4 --durations=50 --cov-report xml:tests_unittest.xml tests\python\unittest
if ($LastExitCode -ne 0) { Throw ("Error running parallel unittest, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
C:\Python37\python.exe -m pytest -v -m 'serial' --durations=50 --cov-report xml:tests_unittest.xml --cov-append tests\python\unittest
if ($LastExitCode -ne 0) { Throw ("Error running serial unittest, python exited with status code " + ('{0:X}' -f $LastExitCode)) }

C:\Python37\python.exe -m pytest -v -m 'not serial' -n 4 --durations=50 --cov-report xml:tests_operator.xml tests\python\gpu\test_operator_gpu.py
if ($LastExitCode -ne 0) { Throw ("Error running parallel tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
C:\Python37\python.exe -m pytest -v -m 'serial' --durations=50 --cov-report xml:tests_operator.xml --cov-append tests\python\gpu\test_operator_gpu.py
if ($LastExitCode -ne 0) { Throw ("Error running serial tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }

C:\Python37\python.exe -m pytest -v -m 'not serial' -n 4 --durations=50 --cov-report xml:tests_train.xml tests\python\train
if ($LastExitCode -ne 0) { Throw ("Error running parallel tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
C:\Python37\python.exe -m pytest -v -m 'serial' --durations=50 --cov-report xml:tests_train.xml --cov-append tests\python\train
if ($LastExitCode -ne 0) { Throw ("Error running serial tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }

# Adding this extra test since it's not possible to set env var on the fly in Windows.
C:\Python37\python.exe -m pytest -v --durations=50 --cov-report xml:tests_operator.xml --cov-append tests\python\gpu\test_operator_gpu.py::test_norm
if ($LastExitCode -ne 0) { Throw ("Error running tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }
C:\Python37\python.exe -m pytest -v --durations=50 --cov-report xml:tests_tvm_op.xml tests\python\gpu\test_tvm_op_gpu.py
if ($LastExitCode -ne 0) { Throw ("Error running TVM op tests, python exited with status code " + ('{0:X}' -f $LastExitCode)) }

# Need to explicitly set the environment variable for MXNET_MEMORY_OPT.
$env:MXNET_MEMORY_OPT=1
<#
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
#>

$CRAN = "https://cloud.r-project.org"

Function InstallR {
  if ( -not(Test-Path Env:\R_ARCH) ) {
    $arch = "x64"
  }
  Else {
    $arch = $env:R_ARCH
  }

  $urlPath = ""
  $latestVer = $(ConvertFrom-JSON $(Invoke-WebRequest https://rversions.r-pkg.org/r-release-win).Content).version
  If ($rVer -ne $latestVer) {
    $urlPath = ("old/" + $rVer + "/")
  }

  $rurl = $CRAN + "/bin/windows/base/" + $urlPath + "R-" + $rVer + "-win.exe"

  # Downloading R
  Start-FileDownload $rurl "R-win.exe"

  # Running R installer
  Start-Process -FilePath .\R-win.exe -ArgumentList "/VERYSILENT /DIR=C:\R" -NoNewWindow -Wait

  $RDrive = "C:"
  echo "R is now available on drive $RDrive"

  $env:PATH = $RDrive + '\R\bin\' + $arch + ';' + 'C:\MinGW\msys\1.0\bin;' + $env:PATH

  # Testing R installation
  Rscript -e "sessionInfo()"
}

Function InstallRtools {
  $rtoolsver = $rToolsVer.Split('.')[0..1] -Join ''
  $rtoolsurl = $CRAN + "/bin/windows/Rtools/rtools$rtoolsver-x86_64.exe"

  # Downloading Rtools
  Start-FileDownload $rtoolsurl "Rtools-current.exe"

  # Running Rtools installer
  Start-Process -FilePath .\Rtools-current.exe -ArgumentList /VERYSILENT -NoNewWindow -Wait

  $RtoolsDrive = "C:"
  echo "Rtools is now available on drive $RtoolsDrive"

  if ( -not(Test-Path Env:\GCC_PATH) ) {
    $gccPath = "gcc-4.6.3"
  }
  Else {
    $gccPath = $env:GCC_PATH
  }
  $env:PATH = $RtoolsDrive + '\Rtools40\bin;' + $RtoolsDrive + '\Rtools40\mingw64\bin;' + $RtoolsDrive + '\Rtools40\' + $gccPath + '\bin;' + $env:PATH
  $env:BINPREF=$RtoolsDrive + '/Rtools40/mingw$(WIN)/bin/'
}

# create tools directory outside of Spark directory
$up = (Get-Item -Path ".." -Verbose).FullName
$tools = "$up\tools"
if (!(Test-Path $tools)) {
    New-Item -ItemType Directory -Force -Path $tools | Out-Null
}

# ========================== Maven
Push-Location $tools

$mavenVer = "3.6.3"
Start-FileDownload "https://archive.apache.org/dist/maven/maven-3/$mavenVer/binaries/apache-maven-$mavenVer-bin.zip" "maven.zip"

# extract
Invoke-Expression "7z.exe x maven.zip"

# add maven to environment variables
$env:PATH = "$tools\apache-maven-$mavenVer\bin;" + $env:PATH
$env:M2_HOME = "$tools\apache-maven-$mavenVer"
$env:MAVEN_OPTS = "-Xmx2g -XX:ReservedCodeCacheSize=1g"

Pop-Location

# ========================== Hadoop bin package
# This must match the version at https://github.com/cdarlint/winutils/tree/master/hadoop-3.2.0
$hadoopVer = "3.2.0"
$hadoopPath = "$tools\hadoop"
if (!(Test-Path $hadoopPath)) {
    New-Item -ItemType Directory -Force -Path $hadoopPath | Out-Null
}
Push-Location $hadoopPath

Start-FileDownload "https://codeload.github.com/cdarlint/winutils/zip/master" "winutils-master.zip"

# extract
Invoke-Expression "7z.exe x winutils-master.zip"

# add hadoop bin to environment variables
$env:HADOOP_HOME = "$hadoopPath\winutils-master\hadoop-$hadoopVer"
$env:PATH = "$env:HADOOP_HOME\bin;" + $env:PATH

Pop-Location

# ========================== R
$rVer = "4.0.2"
$rToolsVer = "4.0.2"

InstallR
InstallRtools

$env:R_LIBS_USER = 'c:\RLibrary'
if ( -not(Test-Path $env:R_LIBS_USER) ) {
$scriptPath = split-path -parent $MyInvocation.MyCommand.Definition

$headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
$headers.Add("Authorization", "token $env:DESKTOPBOT_TOKEN")
$headers.Add("Accept", 'application/vnd.github.v3.raw')
$scriptPath = split-path -parent $MyInvocation.MyCommand.Definition

$file = "$scriptPath\windows-certificate.pfx"

if ((Test-Path $file)) {
# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

$ErrorActionPreference = 'stop'

python -c "from jupyterlab.commands import build_check; build_check()"
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

if ($Env:GROUP -eq "python") {
    jupyter lab build --debug
    if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

    # Run the python tests
    py.test
    if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }
}

if ($Env:GROUP -eq "integrity") {
    # Run the integrity script first
    jlpm run integrity --force
    if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

    # Check yarn.lock file
    jlpm check --integrity
    if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

    # Run a browser check in dev mode
    jlpm run build
    if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

$ErrorActionPreference = 'stop'

# create jupyter base dir (needed for config retrieval)
New-Item -Path $Env:USERPROFILE\.jupyter -ItemType "directory" -Force

# Install and enable the server extension
pip install -q --upgrade pip --user
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

pip --version
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

# Show a verbose install if the install fails, for debugging
pip install -e ".[test]" || pip install -v -e ".[test]"
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

jlpm versions
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

jlpm config current
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

jupyter lab path
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }

jupyter server extension enable jupyterlab
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }
# TODO: batch script grepping

# TODO: remove when we no longer support classic notebook
jupyter serverextension enable jupyterlab
if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }
# TODO: batch script grepping

if ($Env:GROUP -eq "integrity") {
    pip install notebook==4.3.1
    if ($LASTEXITCODE -ne 0) { throw "Command failed. See above errors for details" }
#Requires -Version 3.0
<#
.SYNOPSIS
    Download and install latest version of MongoDB Compass.

.DESCRIPTION
    A longer description.

.INPUTS
    Description of objects that can be piped to the script

.OUTPUTS
    Description of objects that are output by the script

.EXAMPLE
    Example of how to run the script

.LINK
    Links to further documentation

.NOTES
    Detail on what the script does, if this is needed
#>
param()
$ErrorActionPreference = 'Stop'

$CompassUrl = 'https://compass.mongodb.com/api/v2/download/latest/compass/stable/windows'

$TemporaryDir = [System.IO.Path]::GetTempPath()
$CompassExe = "$TemporaryDir" + "compass-install.exe"

Remove-Item $CompassExe -ErrorAction:Ignore

try {
    Write-Output "Downloading Compass from $CompassUrl"

    # Default PowerShell SecurityProtocol does not support Tls1.2 (required by domain)
    if ([Net.ServicePointManager]::SecurityProtocol.ToString() -NotMatch "Tls12") {
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    }
    Invoke-WebRequest -Uri $CompassUrl -OutFile $CompassExe

    Write-Output "Installing Compass"
    & $CompassExe
    Write-Output "Successfully installed Compass"
} catch {
    # Fail silently. With the way that we've hooked into the MSI
    # currently we're not able to do any meaningful error reporting
    # and not crash the installer.
    Write-Output "Error installing Compass."
$version="0.25.1"

$fzf_base=Split-Path -Parent $MyInvocation.MyCommand.Definition

function check_binary () {
  Write-Host "  - Checking fzf executable ... " -NoNewline
  $output=cmd /c $fzf_base\bin\fzf.exe --version 2>&1
  if (-not $?) {
    Write-Host "Error: $output"
    $binary_error="Invalid binary"
  } else {
    $output=(-Split $output)[0]
    if ($version -ne $output) {
      Write-Host "$output != $version"
      $binary_error="Invalid version"
    } else {
      Write-Host "$output"
      $binary_error=""
      return 1
    }
  }
  Remove-Item "$fzf_base\bin\fzf.exe"
  return 0
}

function download {
  param($file)
  Write-Host "Downloading bin/fzf ..."
  if (Test-Path "$fzf_base\bin\fzf.exe") {
    Write-Host "  - Already exists"
    if (check_binary) {
      return
    }
  }
  if (-not (Test-Path "$fzf_base\bin")) {
    md "$fzf_base\bin"
  }
  if (-not $?) {
    $binary_error="Failed to create bin directory"
    return
  }
  cd "$fzf_base\bin"
  $url="https://github.com/junegunn/fzf/releases/download/$version/$file"
  $temp=$env:TMP + "\fzf.zip"
  [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
  if ($PSVersionTable.PSVersion.Major -ge 3) {
    Invoke-WebRequest -Uri $url -OutFile $temp
  } else {
    (New-Object Net.WebClient).DownloadFile($url, $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath("$temp"))
  }
  if ($?) {
    (Microsoft.PowerShell.Archive\Expand-Archive -Path $temp -DestinationPath .); (Remove-Item $temp)
  } else {
    $binary_error="Failed to download with powershell"
  }
  if (-not (Test-Path fzf.exe)) {
    $binary_error="Failed to download $file"
    return
  }
  echo y | icacls $fzf_base\bin\fzf.exe /grant Administrator:F ; check_binary >$null
 #   P o w e r S h e l l   s c r i p t   f o r   t e s t i n g   s y n t a x   h i g h l i g h t i n g 
 
 
 
 f u n c t i o n   G e t - F u t u r e T i m e   { 
 
         p a r a m   ( 
 
                 [ I n t 3 2 ]   $ M i n u t e s 
 
         ) 
 
         
 
         $ t i m e   =   G e t - D a t e   |   %   {   $ _ . A d d M i n u t e s ( $ M i n u t e s )   } 
 
         " { 0 : d 2 } : { 1 : d 2 } : { 2 : d 2 } "   - f   @ ( $ t i m e . h o u r ,   $ t i m e . m i n u t e ,   $ t i m e . s e c o n d ) 
 
 } 
 
 
 
 i f   ( $ e n v : P A T H   - m a t c h   ' . * r u s t . * ' )   { 
 
       ' P a t h   c o n t a i n s   R u s t ' 
 
         t r y   { 
 
                 &   " c a r g o "   " - - v e r s i o n " 
 
         }   c a t c h   { 
 
                 W r i t e - E r r o r   " F a i l e d   t o   r u n   c a r g o " 
 
         } 
 
 }   e l s e   { 
 
       ' P a t h   d o e s   n o t   c o n t a i n   R u s t ' 
 
 } 
 
 
 
 ( 5 . . 3 0 )   |   ?   {   $ _   %   ( 2   *   2   +   1 )   - e q   0   }   |   %   { " I n   { 0 }   m i n u t e s ,   t h e   t i m e   w i l l   b e   { 1 } . "   - f   $ _ ,   $ (   G e t - F u t u r e T i m e   $ _   ) } 
[38;2;248;248;242m[0m[38;2;117;113;94m#[0m[38;2;117;113;94m PowerShell script for testing syntax highlighting[0m

[3;38;2;102;217;239mfunction[0m[38;2;248;248;242m [0m[38;2;166;226;46mGet-FutureTime[0m[38;2;248;248;242m [0m[38;2;248;248;242m{[0m
[38;2;248;248;242m    [0m[38;2;249;38;114mparam[0m[38;2;248;248;242m [0m[38;2;248;248;242m([0m
[38;2;248;248;242m        [0m[38;2;248;248;242m[[0m[3;38;2;102;217;239mInt32[0m[38;2;248;248;242m][0m[38;2;248;248;242m [0m[38;2;255;255;255m$[0m[38;2;255;255;255mMinutes[0m
[38;2;248;248;242m    [0m[38;2;248;248;242m)[0m
[38;2;248;248;242m    [0m
[38;2;248;248;242m    [0m[38;2;255;255;255m$[0m[38;2;255;255;255mtime[0m[38;2;248;248;242m [0m[38;2;249;38;114m=[0m[38;2;248;248;242m [0m[38;2;102;217;239mGet-Date[0m[38;2;248;248;242m [0m[38;2;249;38;114m|[0m[38;2;248;248;242m [0m[38;2;249;38;114m%[0m[38;2;248;248;242m [0m[38;2;248;248;242m{[0m[38;2;248;248;242m [0m[38;2;255;255;255m$[0m[38;2;248;248;242m_[0m[38;2;255;255;255m.AddMinutes[0m[38;2;248;248;242m([0m[38;2;255;255;255m$[0m[38;2;255;255;255mMinutes[0m[38;2;248;248;242m)[0m[38;2;248;248;242m [0m[38;2;248;248;242m}[0m
[38;2;248;248;242m    [0m[38;2;230;219;116m"[0m[38;2;230;219;116m{0:d2}:{1:d2}:{2:d2}[0m[38;2;230;219;116m"[0m[38;2;248;248;242m [0m[38;2;249;38;114m-f[0m[38;2;248;248;242m [0m[38;2;249;38;114m@[0m[38;2;248;248;242m([0m[38;2;255;255;255m$[0m[38;2;255;255;255mtime[0m[38;2;255;255;255m.hour[0m[38;2;249;38;114m,[0m[38;2;248;248;242m [0m[38;2;255;255;255m$[0m[38;2;255;255;255mtime[0m[38;2;255;255;255m.minute[0m[38;2;249;38;114m,[0m[38;2;248;248;242m [0m[38;2;255;255;255m$[0m[38;2;255;255;255mtime[0m[38;2;255;255;255m.second[0m[38;2;248;248;242m)[0m
[38;2;248;248;242m}[0m

[38;2;249;38;114mif[0m[38;2;248;248;242m [0m[38;2;248;248;242m([0m[38;2;255;255;255m$[0m[38;2;255;255;255menv:[0m[38;2;255;255;255mPATH[0m[38;2;248;248;242m [0m[38;2;249;38;114m-match[0m[38;2;248;248;242m [0m[38;2;230;219;116m'[0m[38;2;230;219;116m.*rust.*[0m[38;2;230;219;116m'[0m[38;2;248;248;242m)[0m[38;2;248;248;242m [0m[38;2;248;248;242m{[0m
[38;2;248;248;242m   [0m[38;2;230;219;116m'[0m[38;2;230;219;116mPath contains Rust[0m[38;2;230;219;116m'[0m
[38;2;248;248;242m    [0m[38;2;249;38;114mtry[0m[38;2;248;248;242m [0m[38;2;248;248;242m{[0m
[38;2;248;248;242m        [0m[38;2;249;38;114m&[0m[38;2;248;248;242m [0m[38;2;230;219;116m"[0m[38;2;230;219;116mcargo[0m[38;2;230;219;116m"[0m[38;2;248;248;242m [0m[38;2;230;219;116m"[0m[38;2;230;219;116m--version[0m[38;2;230;219;116m"[0m
[38;2;248;248;242m    [0m[38;2;248;248;242m}[0m[38;2;248;248;242m [0m[38;2;249;38;114mcatch[0m[38;2;248;248;242m [0m[38;2;248;248;242m{[0m
[38;2;248;248;242m        [0m[38;2;102;217;239mWrite-Error[0m[38;2;248;248;242m [0m[38;2;230;219;116m"[0m[38;2;230;219;116mFailed to run cargo[0m[38;2;230;219;116m"[0m
[38;2;248;248;242m    [0m[38;2;248;248;242m}[0m
[38;2;248;248;242m}[0m[38;2;248;248;242m [0m[38;2;249;38;114melse[0m[38;2;248;248;242m [0m[38;2;248;248;242m{[0m
[38;2;248;248;242m   [0m[38;2;230;219;116m'[0m[38;2;230;219;116mPath does not contain Rust[0m[38;2;230;219;116m'[0m
Param(
    [parameter(Mandatory=$false)][string]$registry,
    [parameter(Mandatory=$false)][string]$dockerUser,
    [parameter(Mandatory=$false)][string]$dockerPassword,
    [parameter(Mandatory=$false)][string]$externalDns,
    [parameter(Mandatory=$false)][string]$appName="eshop",
    [parameter(Mandatory=$false)][bool]$deployInfrastructure=$true,
    [parameter(Mandatory=$false)][bool]$deployCharts=$true,
    [parameter(Mandatory=$false)][bool]$clean=$true,
    [parameter(Mandatory=$false)][string]$aksName="",
    [parameter(Mandatory=$false)][string]$aksRg="",
    [parameter(Mandatory=$false)][string]$imageTag="latest",
    [parameter(Mandatory=$false)][bool]$useLocalk8s=$false,
    [parameter(Mandatory=$false)][bool]$useMesh=$false,
    [parameter(Mandatory=$false)][string][ValidateSet('Always','IfNotPresent','Never', IgnoreCase=$false)]$imagePullPolicy="Always",
    [parameter(Mandatory=$false)][string][ValidateSet('prod','staging','none','custom', IgnoreCase=$false)]$sslSupport = "none",
    [parameter(Mandatory=$false)][string]$tlsSecretName = "eshop-tls-custom",
    [parameter(Mandatory=$false)][string]$chartsToDeploy="*",
    [parameter(Mandatory=$false)][string]$ingressMeshAnnotationsFile="ingress_values_linkerd.yaml"
    )

function Install-Chart  {
    Param([string]$chart,[string]$initialOptions, [bool]$customRegistry)
    $options=$initialOptions
    if ($sslEnabled) {
        $options = "$options --set ingress.tls[0].secretName=$tlsSecretName --set ingress.tls[0].hosts={$dns}" 
        if ($sslSupport -ne "custom") {
            $options = "$options --set inf.tls.issuer=$sslIssuer"
        }
    }
    if ($customRegistry) {
        $options = "$options --set inf.registry.server=$registry --set inf.registry.login=$dockerUser --set inf.registry.pwd=$dockerPassword --set inf.registry.secretName=eshop-docker-scret"
    }
    
    if ($chart -ne "eshop-common" -or $customRegistry)  {       # eshop-common is ignored when no secret must be deployed        
        $command = "install $options --name=$appName-$chart $chart"
        Write-Host "Helm Command: helm $command" -ForegroundColor Gray
        Invoke-Expression 'cmd /c "helm $command"'
    }
}

$dns = $externalDns
$sslEnabled=$false
$sslIssuer=""

if ($sslSupport -eq "staging") {
    $sslEnabled=$true
    $tlsSecretName="eshop-letsencrypt-staging"
    $sslIssuer="letsencrypt-staging"
}
elseif ($sslSupport -eq "prod") {
    $sslEnabled=$true
    $tlsSecretName="eshop-letsencrypt-prod"
    $sslIssuer="letsencrypt-prod"
}
elseif ($sslSupport -eq "custom") {
    $sslEnabled=$true
}

$ingressValuesFile="ingress_values.yaml"

if ($useLocalk8s -eq $true) {
    $ingressValuesFile="ingress_values_dockerk8s.yaml"
    $dns="localhost"
}

if ($externalDns -eq "aks") {
    if  ([string]::IsNullOrEmpty($aksName) -or [string]::IsNullOrEmpty($aksRg)) {
        Write-Host "Error: When using -dns aks, MUST set -aksName and -aksRg too." -ForegroundColor Red
        exit 1
    }
    Write-Host "Getting DNS of AKS of AKS $aksName (in resource group $aksRg)..." -ForegroundColor Green
    $dns = $(az aks show -n $aksName  -g $aksRg --query addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName)
    if ([string]::IsNullOrEmpty($dns)) {
        Write-Host "Error getting DNS of AKS $aksName (in resource group $aksRg). Please ensure AKS has httpRouting enabled AND Azure CLI is logged & in version 2.0.37 or higher" -ForegroundColor Red
        exit 1
    }
    $dns = $dns -replace '[\"]'
    Write-Host "DNS base found is $dns. Will use $appName.$dns for the app!" -ForegroundColor Green
    $dns = "$appName.$dns"
}

# Initialization & check commands
if ([string]::IsNullOrEmpty($dns)) {
    Write-Host "No DNS specified. Ingress resources will be bound to public ip" -ForegroundColor Yellow
    if ($sslEnabled) {
        Write-Host "Can't bound SSL to public IP. DNS is mandatory when using TLS" -ForegroundColor Red
        exit 1
    }
}

if ($useLocalk8s -and $sslEnabled) {
    Write-Host "SSL can'be enabled on local K8s." -ForegroundColor Red
    exit 1
}

if ($clean) {
    Write-Host "Cleaning previous helm releases..." -ForegroundColor Green
    helm delete --purge $(helm ls -q eshop) 
    Write-Host "Previous releases deleted" -ForegroundColor Green
}

$useCustomRegistry=$false

if (-not [string]::IsNullOrEmpty($registry)) {
    $useCustomRegistry=$true
    if ([string]::IsNullOrEmpty($dockerUser) -or [string]::IsNullOrEmpty($dockerPassword)) {
        Write-Host "Error: Must use -dockerUser AND -dockerPassword if specifying custom registry" -ForegroundColor Red
        exit 1
    }
}

Write-Host "Begin eShopOnContainers installation using Helm" -ForegroundColor Green

$infras = ("sql-data", "nosql-data", "rabbitmq", "keystore-data", "basket-data")
$charts = ("eshop-common", "basket-api","catalog-api", "identity-api", "mobileshoppingagg","ordering-api","ordering-backgroundtasks","ordering-signalrhub", "payment-api", "webmvc", "webshoppingagg", "webspa", "webstatus", "webhooks-api", "webhooks-web")
$gateways = ("apigwmm", "apigwms", "apigwwm", "apigwws")

if ($deployInfrastructure) {
    foreach ($infra in $infras) {
        Write-Host "Installing infrastructure: $infra" -ForegroundColor Green
        helm install --values app.yaml --values inf.yaml --values $ingressValuesFile --set app.name=$appName --set inf.k8s.dns=$dns --set "ingress.hosts={$dns}" --name="$appName-$infra" $infra     
    }
}
else {
    Write-Host "eShopOnContainers infrastructure (bbdd, redis, ...) charts aren't installed (-deployCharts is false)" -ForegroundColor Yellow
}

if ($deployCharts) {
    foreach ($chart in $charts) {
        if ($chartsToDeploy -eq "*" -or $chartsToDeploy.Contains($chart)) {
            Write-Host "Installing: $chart" -ForegroundColor Green
            Install-Chart $chart "-f app.yaml --values inf.yaml -f $ingressValuesFile -f $ingressMeshAnnotationsFile --set app.name=$appName --set inf.k8s.dns=$dns --set ingress.hosts={$dns} --set image.tag=$imageTag --set image.pullPolicy=$imagePullPolicy --set inf.tls.enabled=$sslEnabled --set inf.mesh.enabled=$useMesh --set inf.k8s.local=$useLocalk8s" $useCustomRegistry
        }
    }

    foreach ($chart in $gateways) {
        if ($chartsToDeploy -eq "*" -or $chartsToDeploy.Contains($chart)) {
            Write-Host "Installing Api Gateway Chart: $chart" -ForegroundColor Green
            Install-Chart $chart "-f app.yaml -f inf.yaml -f $ingressValuesFile  --set app.name=$appName --set inf.k8s.dns=$dns  --set image.pullPolicy=$imagePullPolicy --set inf.mesh.enabled=$useMesh --set ingress.hosts={$dns} --set inf.tls.enabled=$sslEnabled" $false
            
        }
    }
}
else {
Param (
[parameter(Mandatory=$false)][string]$aksName="",
[parameter(Mandatory=$false)][string]$aksRg=""
)

if ($aksName -and $aksRg) {

    $aks=$(az aks show -n $aksName -g $aksRg -o json | ConvertFrom-Json)
    if (-not $aks) {
        Write-Host "AKS $aksName not found in RG $aksRg" -ForegroundColor Red
        exit 1
    }

    Write-Host "Switching kubectl context to $aksRg/$aksName" -ForegroundColor Yellow
    az aks get-credentials -g $aksRg -n $aksName
Param(
    [parameter(Mandatory=$true)][string]$resourceGroupName,
    [parameter(Mandatory=$true)][string]$location,
    [parameter(Mandatory=$true)][string]$serviceName,
    [parameter(Mandatory=$true)][string]$dnsNamePrefix,
    [parameter(Mandatory=$false)][string]$registryName,
    [parameter(Mandatory=$true)][bool]$createAcr=$true,
    [parameter(Mandatory=$false)][int]$nodeCount=3,
    [parameter(Mandatory=$false)][string]$nodeVMSize="Standard_D2_v2",
    [parameter(Mandatory=$false)][bool]$enableHttpApplicationAddon=$true,
    [parameter(Mandatory=$false)][bool]$enableAzureMonitoring=$false,
    [parameter(Mandatory=$false)][ValidateSet("VirtualMachineScaleSets","AvailabilitySet",IgnoreCase=$true)]$vmSetType="VirtualMachineScaleSets"
)

# Create resource group
Write-Host "Creating Azure Resource Group..." -ForegroundColor Yellow
az group create --name=$resourceGroupName --location=$location

if ($createAcr -eq $true) {
    # Create Azure Container Registry
    if ([string]::IsNullOrEmpty($registryName)) {
        $registryName=$serviceName
    }
    Write-Host "Creating Azure Container Registry named $registryName" -ForegroundColor Yellow
    az acr create -n $registryName -g $resourceGroupName -l $location  --admin-enabled true --sku Basic
}

# Create kubernetes cluster in AKS
Write-Host "Creating AKS $resourceGroupName/$serviceName" -ForegroundColor Yellow
az aks create --resource-group=$resourceGroupName --name=$serviceName --dns-name-prefix=$dnsNamePrefix --generate-ssh-keys --node-count=$nodeCount --node-vm-size=$nodeVMSize --vm-set-type $vmSetType

if ($enableHttpApplicationAddon) {
    Write-Host "Enabling Http Applciation Routing in AKS $serviceName" -ForegroundColor Yellow
    az aks enable-addons --resource-group $resourceGroupName --name $serviceName --addons http_application_routing
}

if ($enableAzureMonitoring) {
    Write-Host "Enabling Azure Monitoring in AKS $serviceName" -ForegroundColor Yellow
    az aks enable-addons --resource-group $resourceGroupName --name $serviceName --addons monitoring
}

# Retrieve kubernetes cluster configuration and save it under ~/.kube/config
Write-Host "Getting Kubernetes config..." -ForegroundColor Yellow
az aks get-credentials --resource-group=$resourceGroupName --name=$serviceName

Param(
    [parameter(Mandatory=$false)][string]$registry,
    [parameter(Mandatory=$false)][string]$dockerUser,
    [parameter(Mandatory=$false)][string]$dockerPassword,
    [parameter(Mandatory=$false)][string]$externalDns,
    [parameter(Mandatory=$false)][string]$appName="eshop",
    [parameter(Mandatory=$false)][bool]$deployInfrastructure=$true,
    [parameter(Mandatory=$false)][bool]$deployCharts=$true,
    [parameter(Mandatory=$false)][bool]$clean=$true,
    [parameter(Mandatory=$false)][string]$aksName="",
    [parameter(Mandatory=$false)][string]$aksRg="",
    [parameter(Mandatory=$false)][string]$imageTag="latest",
    [parameter(Mandatory=$false)][bool]$useLocalk8s=$false,
    [parameter(Mandatory=$false)][bool]$useMesh=$false,
    [parameter(Mandatory=$false)][string][ValidateSet('Always','IfNotPresent','Never', IgnoreCase=$false)]$imagePullPolicy="Always",
    [parameter(Mandatory=$false)][string][ValidateSet('prod','staging','none','custom', IgnoreCase=$false)]$sslSupport = "none",
    [parameter(Mandatory=$false)][string]$tlsSecretName = "eshop-tls-custom",
    [parameter(Mandatory=$false)][string]$chartsToDeploy="*",
    [parameter(Mandatory=$false)][string]$ingressMeshAnnotationsFile="ingress_values_linkerd.yaml"
    )

function Install-Chart  {
    Param([string]$chart,[string]$initialOptions, [bool]$customRegistry)
    $options=$initialOptions
    if ($sslEnabled) {
        $options = "$options --set ingress.tls[0].secretName=$tlsSecretName --set ingress.tls[0].hosts=`{$dns`}" 
        if ($sslSupport -ne "custom") {
            $options = "$options --set inf.tls.issuer=$sslIssuer"
        }
    }
    if ($customRegistry) {
        $options = "$options --set inf.registry.server=$registry --set inf.registry.login=$dockerUser --set inf.registry.pwd=$dockerPassword --set inf.registry.secretName=eshop-docker-scret"
    }
    
    if ($chart -ne "eshop-common" -or $customRegistry)  {       # eshop-common is ignored when no secret must be deployed        
        
        $command = "helm install $appName-$chart $options $chart"
        Write-Host "Helm Command: $command" -ForegroundColor Gray        
        Invoke-Expression $command
    }
}

$dns = $externalDns
$sslEnabled=$false
$sslIssuer=""

if ($sslSupport -eq "staging") {
    $sslEnabled=$true
    $tlsSecretName="eshop-letsencrypt-staging"
    $sslIssuer="letsencrypt-staging"
}
elseif ($sslSupport -eq "prod") {
    $sslEnabled=$true
    $tlsSecretName="eshop-letsencrypt-prod"
    $sslIssuer="letsencrypt-prod"
}
elseif ($sslSupport -eq "custom") {
    $sslEnabled=$true
}

$ingressValuesFile="ingress_values.yaml"

if ($useLocalk8s -eq $true) {
    $ingressValuesFile="ingress_values_dockerk8s.yaml"
    $dns="localhost"
}

if ($externalDns -eq "aks") {
    if  ([string]::IsNullOrEmpty($aksName) -or [string]::IsNullOrEmpty($aksRg)) {
        Write-Host "Error: When using -dns aks, MUST set -aksName and -aksRg too." -ForegroundColor Red
        exit 1
    }
    Write-Host "Getting DNS of AKS of AKS $aksName (in resource group $aksRg)..." -ForegroundColor Green
    $dns = $(az aks show -n $aksName  -g $aksRg --query addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName)
    if ([string]::IsNullOrEmpty($dns)) {
        Write-Host "Error getting DNS of AKS $aksName (in resource group $aksRg). Please ensure AKS has httpRouting enabled AND Azure CLI is logged & in version 2.0.37 or higher" -ForegroundColor Red
        exit 1
    }
    $dns = $dns -replace '[\"]'
    Write-Host "DNS base found is $dns. Will use $appName.$dns for the app!" -ForegroundColor Green
    $dns = "$appName.$dns"
}

# Initialization & check commands
if ([string]::IsNullOrEmpty($dns)) {
    Write-Host "No DNS specified. Ingress resources will be bound to public ip" -ForegroundColor Yellow
    if ($sslEnabled) {
        Write-Host "Can't bound SSL to public IP. DNS is mandatory when using TLS" -ForegroundColor Red
        exit 1
    }
}

if ($useLocalk8s -and $sslEnabled) {
    Write-Host "SSL can'be enabled on local K8s." -ForegroundColor Red
    exit 1
}

if ($clean) {    
    $listOfReleases=$(helm ls --filter eshop -q)    
    if ([string]::IsNullOrEmpty($listOfReleases)) {
        Write-Host "No previous releases found!" -ForegroundColor Green
	}else{
        Write-Host "Previous releases found" -ForegroundColor Green
        Write-Host "Cleaning previous helm releases..." -ForegroundColor Green
        helm uninstall $listOfReleases
        Write-Host "Previous releases deleted" -ForegroundColor Green
	}        
}

$useCustomRegistry=$false

if (-not [string]::IsNullOrEmpty($registry)) {
    $useCustomRegistry=$true
    if ([string]::IsNullOrEmpty($dockerUser) -or [string]::IsNullOrEmpty($dockerPassword)) {
        Write-Host "Error: Must use -dockerUser AND -dockerPassword if specifying custom registry" -ForegroundColor Red
        exit 1
    }
}

Write-Host "Begin eShopOnContainers installation using Helm" -ForegroundColor Green

$infras = ("sql-data", "nosql-data", "rabbitmq", "keystore-data", "basket-data")
$charts = ("eshop-common", "basket-api","catalog-api", "identity-api", "mobileshoppingagg","ordering-api","ordering-backgroundtasks","ordering-signalrhub", "payment-api", "webmvc", "webshoppingagg", "webspa", "webstatus", "webhooks-api", "webhooks-web")
$gateways = ("apigwms", "apigwws")

if ($deployInfrastructure) {
    foreach ($infra in $infras) {
        Write-Host "Installing infrastructure: $infra" -ForegroundColor Green
        helm install "$appName-$infra" --values app.yaml --values inf.yaml --values $ingressValuesFile --set app.name=$appName --set inf.k8s.dns=$dns --set "ingress.hosts={$dns}" $infra     
    }
}
else {
    Write-Host "eShopOnContainers infrastructure (bbdd, redis, ...) charts aren't installed (-deployCharts is false)" -ForegroundColor Yellow
}

if ($deployCharts) {
    foreach ($chart in $charts) {
        if ($chartsToDeploy -eq "*" -or $chartsToDeploy.Contains($chart)) {
            Write-Host "Installing: $chart" -ForegroundColor Green
            Install-Chart $chart "--values app.yaml --values inf.yaml --values $ingressValuesFile --values $ingressMeshAnnotationsFile --set app.name=$appName --set inf.k8s.dns=$dns --set ingress.hosts=``{$dns``} --set image.tag=$imageTag --set image.pullPolicy=$imagePullPolicy --set inf.tls.enabled=$sslEnabled --set inf.mesh.enabled=$useMesh --set inf.k8s.local=$useLocalk8s" $useCustomRegistry
        }
    }

    foreach ($chart in $gateways) {
        if ($chartsToDeploy -eq "*" -or $chartsToDeploy.Contains($chart)) {
            Write-Host "Installing Api Gateway Chart: $chart" -ForegroundColor Green
            Install-Chart $chart "--values app.yaml --values inf.yaml --values $ingressValuesFile  --set app.name=$appName --set inf.k8s.dns=$dns  --set image.pullPolicy=$imagePullPolicy --set inf.mesh.enabled=$useMesh --set ingress.hosts=``{$dns``} --set inf.tls.enabled=$sslEnabled" $false
            
        }
    }
}
else {
    Write-Host "eShopOnContainers non-infrastructure charts aren't installed (-deployCharts is false)" -ForegroundColor Yellow
}

Param(
    [parameter(Mandatory=$false)][string]$registry,
    [parameter(Mandatory=$false)][string]$dockerUser,
    [parameter(Mandatory=$false)][string]$dockerPassword,
    [parameter(Mandatory=$false)][string]$externalDns,
    [parameter(Mandatory=$false)][string]$appName="eshop",
    [parameter(Mandatory=$false)][bool]$deployInfrastructure=$true,
    [parameter(Mandatory=$false)][bool]$deployCharts=$true,
    [parameter(Mandatory=$false)][bool]$clean=$true,
    [parameter(Mandatory=$false)][string]$aksName="",
    [parameter(Mandatory=$false)][string]$aksRg="",
    [parameter(Mandatory=$false)][string]$imageTag="latest",
    [parameter(Mandatory=$false)][bool]$useLocalk8s=$false,
    [parameter(Mandatory=$false)][bool]$useMesh=$false,
    [parameter(Mandatory=$false)][string][ValidateSet('Always','IfNotPresent','Never', IgnoreCase=$false)]$imagePullPolicy="Always",
    [parameter(Mandatory=$false)][string][ValidateSet('prod','staging','none','custom', IgnoreCase=$false)]$sslSupport = "none",
    [parameter(Mandatory=$false)][string]$tlsSecretName = "eshop-tls-custom",
    [parameter(Mandatory=$false)][string]$chartsToDeploy="*",
    [parameter(Mandatory=$false)][string]$ingressMeshAnnotationsFile="ingress_values_linkerd.yaml"
    )

function Install-Chart  {
    Param([string]$chart,[string]$initialOptions, [bool]$customRegistry)
    $options=$initialOptions
    if ($sslEnabled) {
        $options = "$options --set ingress.tls[0].secretName=$tlsSecretName --set ingress.tls[0].hosts={$dns}" 
        if ($sslSupport -ne "custom") {
            $options = "$options --set inf.tls.issuer=$sslIssuer"
        }
    }
    if ($customRegistry) {
        $options = "$options --set inf.registry.server=$registry --set inf.registry.login=$dockerUser --set inf.registry.pwd=$dockerPassword --set inf.registry.secretName=eshop-docker-scret"
    }
    
    if ($chart -ne "eshop-common" -or $customRegistry)  {       # eshop-common is ignored when no secret must be deployed        
        $command = "install $appName-$chart $options $chart"
        Write-Host "Helm Command: helm $command" -ForegroundColor Gray
        Invoke-Expression 'cmd /c "helm $command"'
    }
}

$dns = $externalDns
$sslEnabled=$false
$sslIssuer=""

if ($sslSupport -eq "staging") {
    $sslEnabled=$true
    $tlsSecretName="eshop-letsencrypt-staging"
    $sslIssuer="letsencrypt-staging"
}
elseif ($sslSupport -eq "prod") {
    $sslEnabled=$true
    $tlsSecretName="eshop-letsencrypt-prod"
    $sslIssuer="letsencrypt-prod"
}
elseif ($sslSupport -eq "custom") {
    $sslEnabled=$true
}

$ingressValuesFile="ingress_values.yaml"

if ($useLocalk8s -eq $true) {
    $ingressValuesFile="ingress_values_dockerk8s.yaml"
    $dns="localhost"
}

if ($externalDns -eq "aks") {
    if  ([string]::IsNullOrEmpty($aksName) -or [string]::IsNullOrEmpty($aksRg)) {
        Write-Host "Error: When using -dns aks, MUST set -aksName and -aksRg too." -ForegroundColor Red
        exit 1
    }
    Write-Host "Getting DNS of AKS of AKS $aksName (in resource group $aksRg)..." -ForegroundColor Green
    $dns = $(az aks show -n $aksName  -g $aksRg --query addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName)
    if ([string]::IsNullOrEmpty($dns)) {
        Write-Host "Error getting DNS of AKS $aksName (in resource group $aksRg). Please ensure AKS has httpRouting enabled AND Azure CLI is logged & in version 2.0.37 or higher" -ForegroundColor Red
        exit 1
    }
    $dns = $dns -replace '[\"]'
    Write-Host "DNS base found is $dns. Will use $appName.$dns for the app!" -ForegroundColor Green
    $dns = "$appName.$dns"
}

# Initialization & check commands
if ([string]::IsNullOrEmpty($dns)) {
    Write-Host "No DNS specified. Ingress resources will be bound to public ip" -ForegroundColor Yellow
    if ($sslEnabled) {
        Write-Host "Can't bound SSL to public IP. DNS is mandatory when using TLS" -ForegroundColor Red
        exit 1
    }
}

if ($useLocalk8s -and $sslEnabled) {
    Write-Host "SSL can'be enabled on local K8s." -ForegroundColor Red
    exit 1
}

if ($clean) {    
    $listOfReleases=$(helm ls --filter eshop -q)    
    if ([string]::IsNullOrEmpty($listOfReleases)) {
        Write-Host "No previous releases found!" -ForegroundColor Green
	}else{
        Write-Host "Previous releases found" -ForegroundColor Green
        Write-Host "Cleaning previous helm releases..." -ForegroundColor Green
        helm uninstall $listOfReleases
        Write-Host "Previous releases deleted" -ForegroundColor Green
	}        
}

$useCustomRegistry=$false

if (-not [string]::IsNullOrEmpty($registry)) {
    $useCustomRegistry=$true
    if ([string]::IsNullOrEmpty($dockerUser) -or [string]::IsNullOrEmpty($dockerPassword)) {
        Write-Host "Error: Must use -dockerUser AND -dockerPassword if specifying custom registry" -ForegroundColor Red
        exit 1
    }
}

Write-Host "Begin eShopOnContainers installation using Helm" -ForegroundColor Green

$infras = ("sql-data", "nosql-data", "rabbitmq", "keystore-data", "basket-data")
$charts = ("eshop-common", "basket-api","catalog-api", "identity-api", "mobileshoppingagg","ordering-api","ordering-backgroundtasks","ordering-signalrhub", "payment-api", "webmvc", "webshoppingagg", "webspa", "webstatus", "webhooks-api", "webhooks-web")
$gateways = ("apigwms", "apigwws")

if ($deployInfrastructure) {
    foreach ($infra in $infras) {
        Write-Host "Installing infrastructure: $infra" -ForegroundColor Green
        helm install "$appName-$infra" --values app.yaml --values inf.yaml --values $ingressValuesFile --set app.name=$appName --set inf.k8s.dns=$dns --set "ingress.hosts={$dns}" $infra     
    }
}
else {
    Write-Host "eShopOnContainers infrastructure (bbdd, redis, ...) charts aren't installed (-deployCharts is false)" -ForegroundColor Yellow
}

if ($deployCharts) {
    foreach ($chart in $charts) {
        if ($chartsToDeploy -eq "*" -or $chartsToDeploy.Contains($chart)) {
            Write-Host "Installing: $chart" -ForegroundColor Green
            Install-Chart $chart "-f app.yaml --values inf.yaml -f $ingressValuesFile -f $ingressMeshAnnotationsFile --set app.name=$appName --set inf.k8s.dns=$dns --set ingress.hosts={$dns} --set image.tag=$imageTag --set image.pullPolicy=$imagePullPolicy --set inf.tls.enabled=$sslEnabled --set inf.mesh.enabled=$useMesh --set inf.k8s.local=$useLocalk8s" $useCustomRegistry
        }
    }

    foreach ($chart in $gateways) {
        if ($chartsToDeploy -eq "*" -or $chartsToDeploy.Contains($chart)) {
            Write-Host "Installing Api Gateway Chart: $chart" -ForegroundColor Green
            Install-Chart $chart "-f app.yaml -f inf.yaml -f $ingressValuesFile  --set app.name=$appName --set inf.k8s.dns=$dns  --set image.pullPolicy=$imagePullPolicy --set inf.mesh.enabled=$useMesh --set ingress.hosts={$dns} --set inf.tls.enabled=$sslEnabled" $false
            
        }
    }
}
Param (
[parameter(Mandatory=$false)][string]$aksName="",
[parameter(Mandatory=$false)][string]$aksRg=""
)

if ($aksName -and $aksRg) {

    $aks=$(az aks show -n $aksName -g $aksRg -o json | ConvertFrom-Json)
    if (-not $aks) {
        Write-Host "AKS $aksName not found in RG $aksRg" -ForegroundColor Red
        exit 1
    }

    Write-Host "Switching kubectl context to $aksRg/$aksName" -ForegroundColor Yellow
    az aks get-credentials -g $aksRg -n $aksName
Param(
    [parameter(Mandatory=$true)][string]$resourceGroupName,
    [parameter(Mandatory=$true)][string]$location,
    [parameter(Mandatory=$true)][string]$serviceName,
    [parameter(Mandatory=$true)][string]$dnsNamePrefix,
    [parameter(Mandatory=$false)][string]$registryName,
    [parameter(Mandatory=$true)][bool]$createAcr=$true,
    [parameter(Mandatory=$false)][int]$nodeCount=3,
    [parameter(Mandatory=$false)][string]$nodeVMSize="Standard_D2_v2",
    [parameter(Mandatory=$false)][bool]$enableHttpApplicationAddon=$true,
    [parameter(Mandatory=$false)][bool]$enableAzureMonitoring=$false,
    [parameter(Mandatory=$false)][ValidateSet("VirtualMachineScaleSets","AvailabilitySet",IgnoreCase=$true)]$vmSetType="VirtualMachineScaleSets"
)

# Create resource group
Write-Host "Creating Azure Resource Group..." -ForegroundColor Yellow
az group create --name=$resourceGroupName --location=$location

if ($createAcr -eq $true) {
    # Create Azure Container Registry
    if ([string]::IsNullOrEmpty($registryName)) {
        $registryName=$serviceName
    }
    Write-Host "Creating Azure Container Registry named $registryName" -ForegroundColor Yellow
    az acr create -n $registryName -g $resourceGroupName -l $location  --admin-enabled true --sku Basic
}

# Create kubernetes cluster in AKS
Write-Host "Creating AKS $resourceGroupName/$serviceName" -ForegroundColor Yellow
az aks create --resource-group=$resourceGroupName --name=$serviceName --dns-name-prefix=$dnsNamePrefix --generate-ssh-keys --node-count=$nodeCount --node-vm-size=$nodeVMSize --vm-set-type $vmSetType

if ($enableHttpApplicationAddon) {
    Write-Host "Enabling Http Applciation Routing in AKS $serviceName" -ForegroundColor Yellow
    az aks enable-addons --resource-group $resourceGroupName --name $serviceName --addons http_application_routing
}

if ($enableAzureMonitoring) {
    Write-Host "Enabling Azure Monitoring in AKS $serviceName" -ForegroundColor Yellow
    az aks enable-addons --resource-group $resourceGroupName --name $serviceName --addons monitoring
}

# Retrieve kubernetes cluster configuration and save it under ~/.kube/config
Write-Host "Getting Kubernetes config..." -ForegroundColor Yellow
az aks get-credentials --resource-group=$resourceGroupName --name=$serviceName

param(
  [string]$Name = "eShopOnContainers",
  [string]$InboundDisplayName = "eShopOnContainers-Inbound",
  [string]$OutboundDisplayName = "eShopOnContainers-Outbound",
  [switch]$Elevated
  )

function Check-Admin {
  $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
  $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
}
function Add-InboundRule {
  New-NetFirewallRule -DisplayName $InboundDisplayName -Confirm -Description "$Name Inbound Rule for port range 5100-5150" -LocalAddress Any -LocalPort 5100-5150 -Protocol tcp -RemoteAddress Any -RemotePort Any -Direction Inbound
}
function Add-OutboundRule {
  New-NetFirewallRule -DisplayName $OutboundDisplayName -Confirm -Description "$Name Outbound Rule for port range 5100-5150" -LocalAddress Any -LocalPort 5100-5150 -Protocol tcp -RemoteAddress Any -RemotePort Any -Direction Outbound
}

if ((Check-Admin) -eq $false) {
  if ($elevated)
  {
  # could not elevate, quit
  } 
  else {  
    Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file "{0}" -elevated' -f ($myinvocation.MyCommand.Definition))
  }
  exit
}


try {
  $rules = $(Get-NetFirewallRule -DisplayName $Name-* -ErrorAction Stop | Out-String)
  if (!$rules.Contains($InboundDisplayName) -and !$rules.Contains($OutboundDisplayName))
  {
    Add-InboundRule
    Add-OutboundRule
  } 
  elseif (!$rules.Contains($InboundDisplayName))
  {
    Add-InboundRule
  }  
  elseif (!$rules.Contains($OutboundDisplayName))
  {
    Add-OutboundRule
  }
  else{
    Write-Host "Rules found!"
  }
}
catch [Exception] {
# This script just copies app.yaml and inf.yaml files to all devspaces projects.
# This is to workaround issue #56 - https://github.com/Azure/dev-spaces/issues/56


Write-Host "Copying app.yaml and inf.yaml to Mobile.Bff.Shopping" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\ApiGateways\Mobile.Bff.Shopping\apigw" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\ApiGateways\Mobile.Bff.Shopping\apigw" -Force

Write-Host "Copying app.yaml and inf.yaml to Web.Bff.Shopping" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\ApiGateways\Web.Bff.Shopping\apigw" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\ApiGateways\Web.Bff.Shopping\apigw" -Force

Write-Host "Copying app.yaml and inf.yaml to Mobile.Bff Shopping Aggregator" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\ApiGateways\Mobile.Bff.Shopping\aggregator" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\ApiGateways\Mobile.Bff.Shopping\aggregator" -Force

Write-Host "Copying app.yaml and inf.yaml to Web.Bff Shopping Aggregator" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\ApiGateways\Web.Bff.Shopping\aggregator" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\ApiGateways\Web.Bff.Shopping\aggregator" -Force

Write-Host "Copying app.yaml and inf.yaml to Basket API" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Basket\Basket.API" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Basket\Basket.API" -Force

Write-Host "Copying app.yaml and inf.yaml to Catalog API" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Catalog\Catalog.API" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Catalog\Catalog.API" -Force

Write-Host "Copying app.yaml and inf.yaml to Identity API" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Identity\Identity.API" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Identity\Identity.API" -Force

Write-Host "Copying app.yaml and inf.yaml to Ordering API" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Ordering\Ordering.API" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Ordering\Ordering.API" -Force

Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Ordering\Ordering.SignalrHub" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Ordering\Ordering.SignalrHub" -Force

Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Ordering\Ordering.BackgroundTasks" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Ordering\Ordering.BackgroundTasks" -Force

Write-Host "Copying app.yaml and inf.yaml to Payment API" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Payment\Payment.API" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Payment\Payment.API" -Force

Write-Host "Copying app.yaml and inf.yaml to Webhooks API" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Services\Webhooks\Webhooks.API" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Services\Webhooks\Webhooks.API" -Force

Write-Host "Copying app.yaml and inf.yaml to WebMVC" -ForegroundColor Yellow
Copy-Item "..\k8s\helm\app.yaml" -Destination ".\Web\WebMVC" -Force
Copy-Item "..\k8s\helm\inf.yaml" -Destination ".\Web\WebMVC" -Force


[cmdletbinding(SupportsShouldProcess=$true)]
param($publishProperties=@{}, $packOutput, $pubProfilePath)

# to learn more about this file visit https://go.microsoft.com/fwlink/?LinkId=524327

try{
    if ($publishProperties['ProjectGuid'] -eq $null){
        $publishProperties['ProjectGuid'] = 'f0333d8e-0b27-42b7-b2c6-78f3657624e2'
    }

    $publishModulePath = Join-Path (Split-Path $MyInvocation.MyCommand.Path) 'publish-module.psm1'
    Import-Module $publishModulePath -DisableNameChecking -Force

    # call Publish-AspNet to perform the publish operation
    Publish-AspNet -publishProperties $publishProperties -packOutput $packOutput -pubProfilePath $pubProfilePath
param (
  [string]$solution = "eShopOnContainers-ServicesAndWebApps.sln"
)

$outfile = "DockerfileSolutionRestore.txt"

# This script creates the $outfile file, with Dockerfile commands to restore all the packages for the solution,
# so you can insert them (by hand) into Dockerfiles right before the "COPY . ." line
# to increase build speed by optimizing the use of docker build images cache.

# This script is only needed when adding or removing projects from the solution.

Write-Output "COPY ""$solution"" ""$solution""" > $outfile 

Add-Content -Path $outfile ""
Select-String -Path $solution -Pattern ', "(.*?\.csproj)"' | ForEach-Object { $_.Matches.Groups[1].Value.Replace("\", "/") } | Sort-Object | ForEach-Object {"COPY ""$_"" ""$_"""} | Out-File -FilePath $outfile -Append
Add-Content -Path $outfile ""
Select-String -Path $solution -Pattern ', "(.*?\.dcproj)"' | ForEach-Object { $_.Matches.Groups[1].Value.Replace("\", "/") } | Sort-Object | ForEach-Object {"COPY ""$_"" ""$_"""} | Out-File -FilePath $outfile -Append
Add-Content -Path $outfile ""
Add-Content -Path $outfile "COPY ""NuGet.config"" ""NuGet.config"""
Param(
    [parameter(Mandatory=$false)][string]$acrName,
    [parameter(Mandatory=$false)][string]$gitUser,
    [parameter(Mandatory=$false)][string]$repoName="eShopOnContainers",
    [parameter(Mandatory=$false)][string]$gitBranch="dev",
    [parameter(Mandatory=$true)][string]$patToken
)

$gitContext = "https://github.com/$gitUser/$repoName"

$services = @( 
    @{ Name="eshopbasket"; Image="eshop/basket.api"; File="src/Services/Basket/Basket.API/Dockerfile" },
    @{ Name="eshopcatalog"; Image="eshop/catalog.api"; File="src/Services/Catalog/Catalog.API/Dockerfile" },
    @{ Name="eshopidentity"; Image="eshop/identity.api"; File="src/Services/Identity/Identity.API/Dockerfile" },
    @{ Name="eshopordering"; Image="eshop/ordering.api"; File="src/Services/Ordering/Ordering.API/Dockerfile" },
	@{ Name="eshoporderingbg"; Image="eshop/ordering.backgroundtasks"; File="src/Services/Ordering/Ordering.BackgroundTasks/Dockerfile" },
    @{ Name="eshopwebspa"; Image="eshop/webspa"; File="src/Web/WebSPA/Dockerfile" },
    @{ Name="eshopwebmvc"; Image="eshop/webmvc"; File="src/Web/WebMVC/Dockerfile" },
    @{ Name="eshopwebstatus"; Image="eshop/webstatus"; File="src/Web/WebStatus/Dockerfile" },
    @{ Name="eshoppayment"; Image="eshop/payment.api"; File="src/Services/Payment/Payment.API/Dockerfile" },
    @{ Name="eshopocelotapigw"; Image="eshop/ocelotapigw"; File="src/ApiGateways/ApiGw-Base/Dockerfile" },
    @{ Name="eshopmobileshoppingagg"; Image="eshop/mobileshoppingagg"; File="src/ApiGateways/Mobile.Bff.Shopping/aggregator/Dockerfile" },
    @{ Name="eshopwebshoppingagg"; Image="eshop/webshoppingagg"; File="src/ApiGateways/Web.Bff.Shopping/aggregator/Dockerfile" },
    @{ Name="eshoporderingsignalrhub"; Image="eshop/ordering.signalrhub"; File="src/Services/Ordering/Ordering.SignalrHub/Dockerfile" }
)

$services |% {
    $bname = $_.Name
    $bimg = $_.Image
    $bfile = $_.File
Param(
    [parameter(Mandatory=$true)][string]$registry
)

if ([String]::IsNullOrEmpty($registry)) {
    Write-Host "Registry must be set to docker registry to use" -ForegroundColor Red
    exit 1 
}

Write-Host "This script creates the local manifests, for pushing the multi-arch manifests" -ForegroundColor Yellow
Write-Host "Tags used are linux-master, win-master, linux-dev, win-dev, linux-latest, win-latest" -ForegroundColor Yellow
Write-Host "Multiarch images tags will be master, dev, latest" -ForegroundColor Yellow


$services = "identity.api", "basket.api", "catalog.api", "ordering.api", "ordering.backgroundtasks", "payment.api", "webhooks.api", "ocelotapigw", "mobileshoppingagg", "webshoppingagg", "ordering.signalrhub", "webstatus", "webspa", "webmvc", "webhooks.client"

foreach ($svc in $services) {
    Write-Host "Creating manifest for $svc and tags :latest, :master, and :dev"
    docker manifest create $registry/${svc}:master $registry/${svc}:linux-master $registry/${svc}:win-master
    docker manifest create $registry/${svc}:dev $registry/${svc}:linux-dev $registry/${svc}:win-dev
    docker manifest create $registry/${svc}:latest $registry/${svc}:linux-latest $registry/${svc}:win-latest
    Write-Host "Pushing manifest for $svc and tags :latest, :master, and :dev"
    docker manifest push $registry/${svc}:latest
    docker manifest push $registry/${svc}:dev
    docker manifest push $registry/${svc}:master
<#
Copyright (c) Microsoft Open Technologies, Inc.
All rights reserved.

(3-clause BSD License)

Redistribution and use in source and binary forms, with or without modification, are permitted provided that
the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the
following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or
promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
#>

[CmdletBinding()]
Param(
    [parameter(Mandatory=$False)]
    [switch]
    $HELP,

    [parameter(Mandatory=$False)]
    [switch]
    $BUILD,

    [parameter(Mandatory=$False)]
    [Array]
    [ValidateNotNull()]
    $PLATFORMS_IN = "WP",

    [parameter(Mandatory=$False)]
    [Array]
    [ValidateNotNull()]
    $VERSIONS_IN = "8.1",

    [parameter(Mandatory=$False)]
    [Array]
    [ValidateNotNull()]
    $ARCHITECTURES_IN = "x86",

    [parameter(Mandatory=$False)]
    [String]
    $TESTS = "None",

    [parameter(Mandatory=$False)]
    [String]
    [ValidateNotNull()]
    [ValidateSet("Visual Studio 15 2017","Visual Studio 14 2015","Visual Studio 12 2013","Visual Studio 11 2012")]
    $GENERATOR = "Visual Studio 15 2017",

    [parameter(Mandatory=$False)]
    [String]
    $INSTALL
)


Function L() {
    Param(
        [parameter(Mandatory=$true)]
        [String]
        [ValidateNotNull()]
        $str
    )

    Write-Host "INFO> $str"
}

Function D() {
    Param(
        [parameter(Mandatory=$true)]
        [String]
        [ValidateNotNull()]
        $str
    )

    # Use this trigger to toggle debug output
    [bool]$debug = $true

    if ($debug) {
        Write-Host "DEBUG> $str"
    }
}

function Get-Batchfile ($file) {
    $cmd = "`"$file`" & set"
    cmd /c $cmd | Foreach-Object {
        $p, $v = $_.split('=')
        Set-Item -path env:$p -value $v
    }
}

# Enables access to Visual Studio variables via "vsvars32.bat"
function Set-VS12()
{
    Try {
        $vs12comntools = (Get-ChildItem env:VS120COMNTOOLS).Value
        $batchFile = [System.IO.Path]::Combine($vs12comntools, "vsvars32.bat")
        Get-Batchfile $BatchFile
        [System.Console]::Title = "Visual Studio 2010 Windows PowerShell"
     } Catch {
        $ErrorMessage = $_.Exception.Message
        L "Error: $ErrorMessage"
        return $false
     }
     return $true
}

# Executes msbuild to build or install projects
# Throws Exception on error
function Call-MSBuild($path, $config)
{
    $command = "msbuild $path /p:Configuration='$config' /m"
    L "Executing: $($command)"
    msbuild $path /p:Configuration="$config" /m

    if(-Not $?) {
        Throw "Failure executing command: $($command)"
    }

    return $true
}

function RunAccuracyTests($path) {
    md "$path\bin\Release\accuracy"
    python "$PSScriptRoot\..\..\modules\ts\misc\run.py" -w "$path\bin\Release\accuracy" -a "$path\bin\Release"
}

function RunPerfTests($path) {
    md "$path\bin\Release\perf"
    python "$PSScriptRoot\..\..\modules\ts\misc\run.py" -w "$path\bin\Release\perf" "$path\bin\Release"
}

Function Execute() {
    If ($HELP.IsPresent) {
        ShowHelp
    }

    # Validating arguments.
    # This type of validation (rather than using ValidateSet()) is required to make .bat wrapper work

    D "Input Platforms: $PLATFORMS_IN"
    $platforms = New-Object System.Collections.ArrayList
    $PLATFORMS_IN.Split("," ,[System.StringSplitOptions]::RemoveEmptyEntries) | ForEach {
        $_ = $_.Trim()
        if ("WP","WS" -Contains $_) {
            [void]$platforms.Add($_)
            D "$_ is valid"
        } else {
            Throw "$($_) is not valid! Please use WP, WS"
        }
    }
    D "Processed Platforms: $platforms"

    D "Input Versions: $VERSIONS_IN"
    $versions = New-Object System.Collections.ArrayList
    $VERSIONS_IN.Split("," ,[System.StringSplitOptions]::RemoveEmptyEntries) | ForEach {
        $_ = $_.Trim()
        if ("8.0","8.1","10.0" -Contains $_) {
            [void]$versions.Add($_)
            D "$_ is valid"
        } else {
            Throw "$($_) is not valid! Please use 8.0, 8.1, 10.0"
        }
    }
    D "Processed Versions: $versions"

    D "Input Architectures: $ARCHITECTURES_IN"
    $architectures = New-Object System.Collections.ArrayList
    $ARCHITECTURES_IN.Split("," ,[System.StringSplitOptions]::RemoveEmptyEntries) | ForEach {
        $_ = $_.Trim()
        if ("x86","x64","ARM" -Contains $_) {
            $architectures.Add($_) > $null
            D "$_ is valid"
        } else {
            Throw "$($_) is not valid! Please use x86, x64, ARM"
        }
    }

    D "Processed Architectures: $architectures"

    # Assuming we are in '<ocv-sources>/platforms/winrt' we should move up to sources root directory
    Push-Location ../../

    $SRC = Get-Location

    $def_architectures = @{
        "x86" = "";
        "x64" = " Win64"
        "arm" = " ARM"
    }

    # Setting up Visual Studio variables to enable build
    $shouldBuid = $false
    If ($BUILD.IsPresent) {
        $shouldBuild = Set-VS12
    }

    foreach($plat in $platforms) {
        # Set proper platform name.
        $platName = ""
        Switch ($plat) {
            "WP" { $platName = "WindowsPhone" }
            "WS" { $platName = "WindowsStore" }
        }

        foreach($vers in $versions) {

            foreach($arch in $architectures) {

                # Set proper architecture. For MSVS this is done by selecting proper generator
                $genName = $GENERATOR
                Switch ($arch) {
                    "ARM" { $genName = $GENERATOR + $def_architectures['arm'] }
                    "x64" { $genName = $GENERATOR + $def_architectures['x64'] }
                }

                # Constructing path to the install binaries
                # Creating these binaries will be done by building CMake-generated INSTALL project from Visual Studio
                $installPath = "$SRC\bin\install\$plat\$vers\$arch"
                if ($INSTALL) {
                    # Do not add architrecture to the path since it will be added by OCV CMake logic
                    $installPath = "$SRC\$INSTALL\$plat\$vers"
                }

                $path = "$SRC\bin\$plat\$vers\$arch"

                L "-----------------------------------------------"
                L "Target:"
                L "    Directory: $path"
                L "    Platform: $platName"
                L "    Version: $vers"
                L "    Architecture: $arch"
                L "    Generator: $genName"
                L "    Install Directory: $installPath"

                # Delete target directory if exists to ensure that CMake cache is cleared out.
                If (Test-Path $path) {
                    Remove-Item -Recurse -Force $path
                }

                # Validate if required directory exists, create if it doesn't
                New-Item -ItemType Directory -Force -Path $path

                # Change location to the respective subdirectory
                Push-Location -Path $path

                L "Generating project:"
                L "cmake -G $genName -DCMAKE_SYSTEM_NAME:String=$platName -DCMAKE_SYSTEM_VERSION:String=$vers -DCMAKE_VS_EFFECTIVE_PLATFORMS:String=$arch -DCMAKE_INSTALL_PREFIX:PATH=$installPath $SRC"
                cmake -G $genName -DCMAKE_SYSTEM_NAME:String=$platName -DCMAKE_SYSTEM_VERSION:String=$vers -DCMAKE_VS_EFFECTIVE_PLATFORMS:String=$arch -DCMAKE_INSTALL_PREFIX:PATH=$installPath $SRC
                L "-----------------------------------------------"

                # REFERENCE:
                # Executed from '$SRC/bin' folder.
                # Targeting x86 WindowsPhone 8.1.
                # cmake -G "Visual Studio 12 2013" -DCMAKE_SYSTEM_NAME:String=WindowsPhone -DCMAKE_SYSTEM_VERSION:String=8.1 ..


                # Building and installing project
                Try {
                    If ($shouldBuild) {
                        L "Building and installing project:"

                        Call-MSBuild "OpenCV.sln" "Debug"
                        Call-MSBuild "INSTALL.vcxproj" "Debug"

                        Call-MSBuild "OpenCV.sln" "Release"
                        Call-MSBuild "INSTALL.vcxproj" "Release"

                        Try {
                            # Running tests for release versions:
                            If ($TESTS -eq "ALL") {
                                RunAccuracyTests "$path"
                                RunPerfTests "$path"
                            } else {
                                If($TESTS -eq "ACC") {
                                    RunAccuracyTests "$path"
                                }
                                If($TESTS -eq "PERF") {
                                    RunPerfTests "$path"
                                }
                            }
                        } Catch {
                            $ErrorMessage = $_.Exception.Message
                            L "Error: $ErrorMessage"
                            exit
                        }
                    }
                } Catch {
                    $ErrorMessage = $_.Exception.Message
                    L "Error: $ErrorMessage"

                    # Exiting at this point will leave command line pointing at the erroneous configuration directory
                    exit
                }

                # Return back to Sources folder
                Pop-Location
            }
        }
    }

    # Return back to Script folder
    Pop-Location
}

Function ShowHelp() {
    Write-Host "Configures OpenCV and generates projects for specified version of Visual Studio/platforms/architectures."
    Write-Host "Must be executed from the sources folder containing main CMakeLists configuration."
    Write-Host "Parameter keys can be shortened down to a single symbol (e.g. '-a') and are not case sensitive."
    Write-Host "Proper parameter sequencing is required when omitting keys."
    Write-Host "Generates the following folder structure, depending on the supplied parameters: "
    Write-Host "     bin/ "
    Write-Host "      | "
    Write-Host "      |-WP "
    Write-Host "      |  ... "
    Write-Host "      |-WinRT "
    Write-Host "      |  |-8.0 "
    Write-Host "      |  |-8.1 "
    Write-Host "      |  |  |-x86 "
    Write-Host "      |  |  |-x64 "
    Write-Host "      |  |  |-ARM "
    Write-Host " "
    Write-Host " USAGE: "
    Write-Host "   Calling:"
    Write-Host "     PS> setup_winrt.ps1 [params]"
    Write-Host "     cmd> setup_winrt.bat [params]"
    Write-Host "     cmd> PowerShell.exe -ExecutionPolicy Unrestricted -File setup_winrt.ps1 [params]"
    Write-Host "   Parameters:"
    Write-Host "     setup_winrt [options] [platform] [version] [architecture] [tests] [generator] [install-path]"
    Write-Host "     setup_winrt -b 'WP' 'x86,ARM' "
    Write-Host "     setup_winrt -b 'WP' 'x86,ARM' ALL"
    Write-Host "     setup_winrt -b 'WP' 'x86,ARM' -test PERF "
    Write-Host "     setup_winrt -architecture x86 -platform WP "
    Write-Host "     setup_winrt -arc x86 -plat 'WP,WS' "
    Write-Host "     setup_winrt -a x86 -g 'Visual Studio 15 2017' -pl WP "
    Write-Host " WHERE: "
    Write-Host "     options -  Options to call "
    Write-Host "                 -h: displays command line help "
    Write-Host "                 -b: builds BUILD_ALL and INSTALL projects for each generated configuration in both Debug and Release modes."
    Write-Host "     platform -  Array of target platforms. "
    Write-Host "                 Default: WP "
    Write-Host "                 Example: 'WS,WP' "
    Write-Host "                 Options: WP, WS ('WindowsPhone', 'WindowsStore'). "
    Write-Host "                 Note that you'll need to use quotes to specify more than one platform. "
    Write-Host "     version - Array of platform versions. "
    Write-Host "                 Default: 8.1 "
    Write-Host "                 Example: '8.0,8.1' "
    Write-Host "                 Options: 8.0, 8.1, 10.0. Available options may be limited depending on your local setup (e.g. SDK availability). "
    Write-Host "                 Note that you'll need to use quotes to specify more than one version. "
    Write-Host "     architecture - Array of target architectures to build for. "
    Write-Host "                 Default: x86 "
    Write-Host "                 Example: 'ARM,x64' "
    Write-Host "                 Options: x86, ARM, x64. Available options may be limited depending on your local setup. "
    Write-Host "                 Note that you'll need to use quotes to specify more than one architecture. "
    Write-Host "     tests - Test sets to run. Requires -b option otherwise ignored. "
    Write-Host "                 Default: None. "
    Write-Host "                 Example: 'ALL' "
    Write-Host "                 Options: ACC, PERF, ALL. "
    Write-Host "     generator - Visual Studio instance used to generate the projects. "
    Write-Host "                 Default: Visual Studio 12 2013 "
    Write-Host "                 Example: 'Visual Studio 11 2012' "
    Write-Host "                 Use 'cmake --help' to find all available option on your machine. "
    Write-Host "     install-path - Path to install binaries (relative to the sources directory). "
    Write-Host "                 Default: <src-dir>\bin\install\<platform>\<version>\<architecture> "
    Write-Host "                 Example: '../install' "

    Exit
@{

# Script module or binary module file associated with this manifest.
ModuleToProcess = 'posh-vcpkg.psm1'

# Version number of this module.
ModuleVersion = '0.0.1'

# ID used to uniquely identify this module
GUID = '948f02ab-fc99-4a53-8335-b6556eef129b'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '5.0'

FunctionsToExport = @('TabExpansion')
CmdletsToExport = @()
VariablesToExport = @()
AliasesToExport = @()

# Private data to pass to the module specified in RootModule/ModuleToProcess.
# This may also contain a PSData hashtable with additional module metadata used by PowerShell.
PrivateData = 
@{
    PSData =
    @{
        # Tags applied to this module. These help with module discovery in online galleries.
        Tags = @('vcpkg', 'tab', 'tab-completion', 'tab-expansion', 'tabexpansion')
    }
}

param()

if (Get-Module posh-vcpkg) { return }

if ($PSVersionTable.PSVersion.Major -lt 5) {
    Write-Warning ("posh-vcpkg does not support PowerShell versions before 5.0.")
    return
}

if (Test-Path Function:\TabExpansion) {
    Rename-Item Function:\TabExpansion VcpkgTabExpansionBackup
}

function TabExpansion($line, $lastWord) {
    $lastBlock = [regex]::Split($line, '[|;]')[-1].TrimStart()

    switch -regex ($lastBlock) {
        "^(?<vcpkgexe>(\./|\.\\|)vcpkg(\.exe|)) (?<remaining>.*)$"
        {
            & $matches['vcpkgexe'] autocomplete $matches['remaining']
            return
        }

        # Fall back on existing tab expansion
        default {
            if (Test-Path Function:\VcpkgTabExpansionBackup) {
                VcpkgTabExpansionBackup $line $lastWord
            }
        }
    }
}

$exportModuleMemberParams = @{
    Function = @(
        'TabExpansion'
[CmdletBinding()]
param(
    $badParam,
    [Parameter(Mandatory=$False)][switch]$win64 = $false,
    [Parameter(Mandatory=$False)][string]$withVSPath = "",
    [Parameter(Mandatory=$False)][string]$withWinSDK = "",
    [Parameter(Mandatory=$False)][switch]$disableMetrics = $false
)
Set-StrictMode -Version Latest
# Powershell2-compatible way of forcing named-parameters
if ($badParam)
{
    if ($disableMetrics -and $badParam -eq "1")
    {
        Write-Warning "'disableMetrics 1' is deprecated, please change to 'disableMetrics' (without '1')."
    }
    else
    {
        throw "Only named parameters are allowed."
    }
}

if ($win64)
{
    Write-Warning "-win64 no longer has any effect; ignored."
}

if (-Not [string]::IsNullOrWhiteSpace($withVSPath))
{
    Write-Warning "-withVSPath no longer has any effect; ignored."
}

if (-Not [string]::IsNullOrWhiteSpace($withWinSDK))
{
    Write-Warning "-withWinSDK no longer has any effect; ignored."
}

$scriptsDir = split-path -parent $script:MyInvocation.MyCommand.Definition
$vcpkgRootDir = $scriptsDir
while (!($vcpkgRootDir -eq "") -and !(Test-Path "$vcpkgRootDir\.vcpkg-root"))
{
    Write-Verbose "Examining $vcpkgRootDir for .vcpkg-root"
    $vcpkgRootDir = Split-path $vcpkgRootDir -Parent
}

Write-Verbose "Examining $vcpkgRootDir for .vcpkg-root - Found"

& "$scriptsDir/tls12-download.exe" github.com "/microsoft/vcpkg-tool/releases/download/2021-01-13-768d8f95c9e752603d2c5901c7a7c7fbdb08af35/vcpkg.exe" "$vcpkgRootDir/vcpkg.exe"
Write-Host ""

if ($LASTEXITCODE -ne 0)
{
    Write-Error "Downloading vcpkg.exe failed. Please check your internet connection, or consider downloading a recent vcpkg.exe from https://github.com/microsoft/vcpkg-tool with a browser."
    throw
}

if ($disableMetrics)
{
    Set-Content -Value "" -Path "$vcpkgRootDir\vcpkg.disable-metrics" -Force
}
elseif (-Not (Test-Path "$vcpkgRootDir\vcpkg.disable-metrics"))
{
    # Note that we intentionally leave any existing vcpkg.disable-metrics; once a user has
    # opted out they should stay opted out.
    Write-Host @"
Telemetry
---------
vcpkg collects usage data in order to help us improve your experience.
The data collected by Microsoft is anonymous.
You can opt-out of telemetry by re-running the bootstrap-vcpkg script with -disableMetrics,
passing --disable-metrics to vcpkg on the command line,
or by setting the VCPKG_DISABLE_METRICS environment variable.

Read more about vcpkg telemetry at docs/about/privacy.md
"@
[CmdletBinding()]
param()

function findExistingImportModuleDirectives([Parameter(Mandatory=$true)][string]$path)
{
    if (!(Test-Path $path))
    {
        return
    }

    $fileContents = Get-Content $path
    $fileContents -match 'Import-Module.+?(?=posh-vcpkg)'
    return
}

$scriptsDir = split-path -parent $script:MyInvocation.MyCommand.Definition

$profileEntry = "Import-Module '$scriptsDir\posh-vcpkg'"
$profilePath = $PROFILE # Implicit PowerShell variable
$profileDir = Split-Path $profilePath -Parent
if (!(Test-Path $profileDir))
{
    New-Item -ItemType Directory -Path $profileDir | Out-Null
}

Write-Host "`nAdding the following line to ${profilePath}:"
Write-Host "    $profileEntry"

# @() Needed to force Array in PowerShell 2.0
[Array]$existingImports = @(findExistingImportModuleDirectives $profilePath)
if ($existingImports.Count -gt 0)
{
    $existingImportsOut = $existingImports -join "`n    "
    Write-Host "`nposh-vcpkg is already imported to your PowerShell profile. The following entries were found:"
    Write-Host "    $existingImportsOut"
    Write-Host "`nPlease make sure you have started a new PowerShell window for the changes to take effect."
    return
}

# Modifying the profile will invalidate any signatures.
# Posh-git does the following check, so we should too.
# https://github.com/dahlbyk/posh-git/blob/master/src/Utils.ps1
# If the profile script exists and is signed, then we should not modify it
if (Test-Path $profilePath)
{
    $sig = Get-AuthenticodeSignature $profilePath
    if ($null -ne $sig.SignerCertificate)
    {
        Write-Warning "Skipping add of posh-vcpkg import to profile; '$profilePath' appears to be signed."
        Write-Warning "Please manually add the line '$profileEntry' to your profile and resign it."
        return
    }
}

Add-Content $profilePath -Value "`n$profileEntry" -Encoding UTF8
[cmdletbinding()]
param([string]$targetBinary, [string]$installedDir, [string]$tlogFile, [string]$copiedFilesLog)

$g_searched = @{}
# Note: installedDir is actually the bin\ directory.
$g_install_root = Split-Path $installedDir -parent
$g_is_debug = $g_install_root -match '(.*\\)?debug(\\)?$'

# Ensure we create the copied files log, even if we don't end up copying any files
if ($copiedFilesLog)
{
    Set-Content -Path $copiedFilesLog -Value "" -Encoding UTF8
}

function computeHash([System.Security.Cryptography.HashAlgorithm]$alg, [string]$str) {
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($str)
    $hash = $alg.ComputeHash($bytes)
    return [Convert]::ToBase64String($hash)
}

function getMutex([string]$targetDir) {
    $sha512Hash = [System.Security.Cryptography.SHA512]::Create()
    if ($sha512Hash) {
        $hash = computeHash $sha512Hash $targetDir
        $mtxName = "VcpkgAppLocalDeployBinary-" + $hash
        return New-Object System.Threading.Mutex($false, $mtxName)
    }

    return New-Object System.Threading.Mutex($false, "VcpkgAppLocalDeployBinary")
}

# Note: this function signature is depended upon by the qtdeploy.ps1 script introduced in 5.7.1-7
function deployBinary([string]$targetBinaryDir, [string]$SourceDir, [string]$targetBinaryName) {
    try {
        $mtx = getMutex($targetBinaryDir)
        if ($mtx) {
            $mtx.WaitOne() | Out-Null
        }

        if (Test-Path "$targetBinaryDir\$targetBinaryName") {
            $sourceModTime = (Get-Item $SourceDir\$targetBinaryName).LastWriteTime
            $destModTime = (Get-Item $targetBinaryDir\$targetBinaryName).LastWriteTime
            if ($destModTime -lt $sourceModTime) {
                Write-Verbose "  ${targetBinaryName}: Updating $SourceDir\$targetBinaryName"
                Copy-Item "$SourceDir\$targetBinaryName" $targetBinaryDir
            } else {
                Write-Verbose "  ${targetBinaryName}: already present"
            }
        }
        else {
            Write-Verbose "  ${targetBinaryName}: Copying $SourceDir\$targetBinaryName"
            Copy-Item "$SourceDir\$targetBinaryName" $targetBinaryDir
        }
        if ($copiedFilesLog) { Add-Content $copiedFilesLog "$targetBinaryDir\$targetBinaryName" -Encoding UTF8 }
        if ($tlogFile) { Add-Content $tlogFile "$targetBinaryDir\$targetBinaryName" -Encoding Unicode }
    } finally {
        if ($mtx) {
            $mtx.ReleaseMutex() | Out-Null
            $mtx.Dispose() | Out-Null
        }
    }
}


Write-Verbose "Resolving base path $targetBinary..."
try
{
    $baseBinaryPath = Resolve-Path $targetBinary -erroraction stop
    $baseTargetBinaryDir = Split-Path $baseBinaryPath -parent
}
catch [System.Management.Automation.ItemNotFoundException]
{
    return
}

# Note: this function signature is depended upon by the qtdeploy.ps1 script
function resolve([string]$targetBinary) {
    Write-Verbose "Resolving $targetBinary..."
    try
    {
        $targetBinaryPath = Resolve-Path $targetBinary -erroraction stop
    }
    catch [System.Management.Automation.ItemNotFoundException]
    {
        return
    }
    $targetBinaryDir = Split-Path $targetBinaryPath -parent

    if (Get-Command "dumpbin" -ErrorAction SilentlyContinue) {
        $a = $(dumpbin /DEPENDENTS $targetBinary | ? { $_ -match "^    [^ ].*\.dll" } | % { $_ -replace "^    ","" })
    } elseif (Get-Command "llvm-objdump" -ErrorAction SilentlyContinue) {
        $a = $(llvm-objdump -p $targetBinary| ? { $_ -match "^ {4}DLL Name: .*\.dll" } | % { $_ -replace "^ {4}DLL Name: ","" })
    } else {
        Write-Error "Neither dumpbin nor llvm-objdump could be found. Can not take care of dll dependencies."
    }
    $a | % {
        if ([string]::IsNullOrEmpty($_)) {
            return
        }
        if ($g_searched.ContainsKey($_)) {
            Write-Verbose "  ${_}: previously searched - Skip"
            return
        }
        $g_searched.Set_Item($_, $true)
        if (Test-Path "$installedDir\$_") {
            deployBinary $baseTargetBinaryDir $installedDir "$_"
            if (Test-Path function:\deployPluginsIfQt) { deployPluginsIfQt $baseTargetBinaryDir "$g_install_root\plugins" "$_" }
            if (Test-Path function:\deployOpenNI2) { deployOpenNI2 $targetBinaryDir "$g_install_root" "$_" }
            if (Test-Path function:\deployPluginsIfMagnum) {
                if ($g_is_debug) {
                    deployPluginsIfMagnum $targetBinaryDir "$g_install_root\bin\magnum-d" "$_"
                } else {
                    deployPluginsIfMagnum $targetBinaryDir "$g_install_root\bin\magnum" "$_"
                }
            }
            if (Test-Path function:\deployAzureKinectSensorSDK) { deployAzureKinectSensorSDK $targetBinaryDir "$g_install_root" "$_" }
            resolve "$baseTargetBinaryDir\$_"
        } elseif (Test-Path "$targetBinaryDir\$_") {
            Write-Verbose "  ${_}: $_ not found in vcpkg; locally deployed"
            resolve "$targetBinaryDir\$_"
        } else {
            Write-Verbose "  ${_}: $installedDir\$_ not found"
        }
    }
    Write-Verbose "Done Resolving $targetBinary."
}

# Note: This is a hack to make Qt5 work.
# Introduced with Qt package version 5.7.1-7
if (Test-Path "$g_install_root\plugins\qtdeploy.ps1") {
    . "$g_install_root\plugins\qtdeploy.ps1"
}

# Note: This is a hack to make OpenNI2 work.
if (Test-Path "$g_install_root\bin\OpenNI2\openni2deploy.ps1") {
    . "$g_install_root\bin\OpenNI2\openni2deploy.ps1"
}

# Note: This is a hack to make Magnum work.
if (Test-Path "$g_install_root\bin\magnum\magnumdeploy.ps1") {
    . "$g_install_root\bin\magnum\magnumdeploy.ps1"
} elseif (Test-Path "$g_install_root\bin\magnum-d\magnumdeploy.ps1") {
    . "$g_install_root\bin\magnum-d\magnumdeploy.ps1"
}

# Note: This is a hack to make Azure Kinect Sensor SDK work.
if (Test-Path "$g_install_root\tools\azure-kinect-sensor-sdk\k4adeploy.ps1") {
    . "$g_install_root\tools\azure-kinect-sensor-sdk\k4adeploy.ps1"
}

[CmdletBinding()]
param (
    $libraries = @(),
    $version = "1.75.0",
    $portsDir = $null
)

$ErrorActionPreference = 'Stop'

$scriptsDir = split-path -parent $MyInvocation.MyCommand.Definition
if ($null -eq $portsDir)
{
    $portsDir = "$scriptsDir/../../ports"
}

if ($IsWindows)
{
    $vcpkg = "$scriptsDir/../../vcpkg.exe"
    $curl = "curl.exe"
}
else
{
    $vcpkg = "$scriptsDir/../../vcpkg"
    $curl = "curl"
}

# Clear this array when moving to a new boost version
$port_versions = @{
    #e.g.  "asio" = 1;
    "asio" = 1;
    "python" = 1;
}

$per_port_data = @{
    "asio" =  @{ "supports" = "!emscripten" };
    "beast" =  @{ "supports" = "!emscripten" };
    "fiber" = @{ "supports" = "!osx&!uwp&!arm&!emscripten" };
    "filesystem" = @{ "supports" = "!uwp" };
    "iostreams" = @{ "supports" = "!uwp" };
    "context" = @{ "supports" = "!uwp&!emscripten" };
    "stacktrace" = @{ "supports" = "!uwp" };
    "coroutine" = @{ "supports" = "!arm&!uwp&!emscripten" };
    "coroutine2" = @{ "supports" = "!emscripten" };
    "test" = @{ "supports" = "!uwp" };
    "wave" = @{ "supports" = "!uwp" };
    "log" = @{ "supports" = "!uwp&!emscripten" };
    "locale" = @{
        "supports" = "!uwp";
        "features" = @{
            icu=@{
                dependencies=@("icu")
                description="ICU backend for Boost.Locale"
            }
        }
    };
    "parameter-python" =  @{ "supports" = "!emscripten" };
    "process" =  @{ "supports" = "!emscripten" };
    "python" = @{
        "supports" = "!uwp&!(arm&windows)&!emscripten";
        "features" = @{
            python2=@{
                dependencies=@(@{name="python2"; platform="windows"})
                description="Build with Python2 support"
            }
        }
    };
    "regex" = @{
        "features" = @{
            icu=@{
                dependencies=@("icu")
                description="ICU backend for Boost.Regex"
            }
        }
    }
}

function TransformReference()
{
    param (
        [string]$library
    )

    if ($per_port_data[$library].supports)
    {
        @{name="boost-$library"; platform=$per_port_data[$library].supports}
    }
    else
    {
        "boost-$library"
    }
}

function Generate()
{
    param (
        [string]$Name,
        [string]$PortName,
        [string]$Hash,
        [bool]$NeedsBuild,
        $Depends = @()
    )

    New-Item -ItemType "Directory" "$portsDir/boost-$PortName" -erroraction SilentlyContinue | out-null
    $controlLines = @{
        name="boost-$PortName"; `
        "version-string"=$version; `
        dependencies=$Depends; `
        homepage="https://github.com/boostorg/$Name"; `
        description="Boost $Name module" `
    }
    if ($port_versions[$PortName])
    {
        $controlLines["port-version"] = $port_versions[$PortName]
    }

    if ($per_port_data[$PortName])
    {
        $controlLines += $per_port_data[$PortName]
    }
    $controlLines | ConvertTo-Json -Depth 10 -Compress | out-file -enc ascii "$portsDir/boost-$PortName/vcpkg.json"
    & $vcpkg format-manifest "$portsDir/boost-$PortName/vcpkg.json"

    $portfileLines = @(
        "# Automatically generated by scripts/boost/generate-ports.ps1"
        ""
    )

    if ($PortName -eq "system")
    {
        $portfileLines += @(
            "vcpkg_buildpath_length_warning(37)"
            ""
        )
    }

    $portfileLines += @(
        "vcpkg_from_github("
        "    OUT_SOURCE_PATH SOURCE_PATH"
        "    REPO boostorg/$Name"
        "    REF boost-$version"
        "    SHA512 $Hash"
        "    HEAD_REF master"
    )
    $patches = Get-ChildItem $portsDir/boost-$PortName/*.patch
    if ($patches.Count -eq 0)
    {
    }
    elseif ($patches.Count -eq 1)
    {
        $portfileLines += @("    PATCHES $($patches.name)")
    }
    else
    {
        $portfileLines += @("    PATCHES")
        foreach ($patch in $patches)
        {
            $portfileLines += @("        $($patch.name)")
        }
    }
    $portfileLines += @(
        ")"
        ""
    )

    if (Test-Path "$scriptsDir/post-source-stubs/$PortName.cmake")
    {
        $portfileLines += @(get-content "$scriptsDir/post-source-stubs/$PortName.cmake")
    }

    if ($NeedsBuild)
    {
        $portfileLines += @(
            "include(`${CURRENT_INSTALLED_DIR}/share/boost-build/boost-modular-build.cmake)"
        )
        # b2-options.cmake contains port-specific build options
        if (Test-Path "$portsDir/boost-$PortName/b2-options.cmake")
        {
            $portfileLines += @(
                "boost_modular_build("
                "    SOURCE_PATH `${SOURCE_PATH}"
                "    BOOST_CMAKE_FRAGMENT `"`${CMAKE_CURRENT_LIST_DIR}/b2-options.cmake`""
                ")"
            )
        }
        elseif (Test-Path "$portsDir/boost-$PortName/b2-options.cmake.in")
        {
            $portfileLines += @(
                'configure_file('
                '    "${CMAKE_CURRENT_LIST_DIR}/b2-options.cmake.in"'
                '    "${CURRENT_BUILDTREES_DIR}/vcpkg-b2-options.cmake"'
                '    @ONLY'
                ')'
                'boost_modular_build('
                '    SOURCE_PATH ${SOURCE_PATH}'
                '    BOOST_CMAKE_FRAGMENT "${CURRENT_BUILDTREES_DIR}/vcpkg-b2-options.cmake"'
                ')'
            )
        }
        else
        {
            $portfileLines += @(
                "boost_modular_build(SOURCE_PATH `${SOURCE_PATH})"
            )
        }
    }

    $portfileLines += @(
        "include(`${CURRENT_INSTALLED_DIR}/share/boost-vcpkg-helpers/boost-modular-headers.cmake)"
        "boost_modular_headers(SOURCE_PATH `${SOURCE_PATH})"
    )

    if (Test-Path "$scriptsDir/post-build-stubs/$PortName.cmake")
    {
        $portfileLines += @(get-content "$scriptsDir/post-build-stubs/$PortName.cmake")
    }

    $portfileLines += @("")
    $($portfileLines -join "`r`n") | out-file -enc ascii "$portsDir/boost-$PortName/portfile.cmake" -NoNewline
}

if (!(Test-Path "$scriptsDir/boost"))
{
    "Cloning boost..."
    pushd $scriptsDir
    try
    {
        git clone https://github.com/boostorg/boost --branch boost-$version
    }
    finally
    {
        popd
    }
}
else
{
    pushd $scriptsDir/boost
    try
    {
        git fetch
        git checkout -f boost-$version
    }
    finally
    {
        popd
    }
}

$libraries_found = Get-ChildItem $scriptsDir/boost/libs -directory | % name | % {
    if ($_ -match "numeric")
    {
        "numeric_conversion"
        "interval"
        "odeint"
        "ublas"
        "safe_numerics"
    }
    elseif ($_ -eq "headers")
    {
    }
    else
    {
        $_
    }
}

New-Item -ItemType "Directory" $scriptsDir/downloads -erroraction SilentlyContinue | out-null

if ($libraries.Length -eq 0)
{
    $libraries = $libraries_found
}

$libraries_in_boost_port = @()

foreach ($library in $libraries)
{
    "Handling boost/$library..."
    $archive = "$scriptsDir/downloads/$library-boost-$version.tar.gz"
    if (!(Test-Path $archive))
    {
        "Downloading boost/$library..."
        & $curl -L "https://github.com/boostorg/$library/archive/boost-$version.tar.gz" --output "$scriptsDir/downloads/$library-boost-$version.tar.gz"
    }
    $hash = & $vcpkg hash $archive
    $unpacked = "$scriptsDir/libs/$library-boost-$version"
    if (!(Test-Path $unpacked))
    {
        "Unpacking boost/$library..."
        New-Item -ItemType "Directory" $scriptsDir/libs -erroraction SilentlyContinue | out-null
        pushd $scriptsDir/libs
        try
        {
            cmake -E tar xf $archive
        }
        finally
        {
            popd
        }
    }
    pushd $unpacked
    try
    {
        if ($IsWindows)
        {
            $groups = $(
                findstr /si /C:"include <boost/" include/*
                findstr /si /C:"include <boost/" src/*
            ) | % { $_ -replace "^[^:]*:","" }
        }
        else
        {
            $groups = $(
                grep -irhs "include <boost/" include src
            )
        }

        $groups = $groups |
        % { $_ `
                -replace "boost/numeric/conversion/","boost/numeric_conversion/" `
                -replace "boost/functional/hash.hpp","boost/container_hash/hash.hpp" `
                -replace "boost/detail/([^/]+)/","boost/`$1/" `
                -replace " *# *include *<boost/([a-zA-Z0-9\._]*)(/|>).*", "`$1" `
                -replace "/|\.hp?p?| ","" } | group | % name | % {
            # mappings
            Write-Verbose "${library}: $_"
            if ($_ -match "aligned_storage") { "type_traits" }
            elseif ($_ -match "noncopyable|ref|swap|get_pointer|checked_delete|visit_each") { "core" }
            elseif ($_ -eq "type") { "core" }
            elseif ($_ -match "concept|concept_archetype") { "concept_check" }
            elseif ($_ -match "unordered_") { "unordered" }
            elseif ($_ -match "cstdint|integer_fwd|integer_traits") { "integer" }
            elseif ($_ -match "call_traits|operators|current_function|cstdlib|next_prior|compressed_pair") { "utility" }
            elseif ($_ -match "^version|^workaround") { "config" }
            elseif ($_ -match "enable_shared_from_this|shared_ptr|make_shared|make_unique|intrusive_ptr|scoped_ptr|pointer_cast|pointer_to_other|weak_ptr|shared_array|scoped_array") { "smart_ptr" }
            elseif ($_ -match "iterator_adaptors|generator_iterator|pointee") { "iterator" }
            elseif ($_ -eq "regex_fwd") { "regex" }
            elseif ($_ -eq "make_default") { "convert" }
            elseif ($_ -eq "foreach_fwd") { "foreach" }
            elseif ($_ -eq "cerrno") { "system" }
            elseif ($_ -eq "circular_buffer_fwd") { "circular_buffer" }
            elseif ($_ -eq "archive") { "serialization" }
            elseif ($_ -match "none|none_t") { "optional" }
            elseif ($_ -eq "limits") { "compatibility" }
            elseif ($_ -match "cstdfloat|math_fwd") { "math" }
            elseif ($_ -eq "cast") { "conversion"; "numeric_conversion" } # DEPRECATED header file, includes <boost/polymorphic_cast.hpp> and <boost/numeric/conversion/cast.hpp>
            elseif ($_ -match "polymorphic_cast|implicit_cast") { "conversion" }
            elseif ($_ -eq "nondet_random") { "random" }
            elseif ($_ -eq "memory_order") { "atomic" }
            elseif ($_ -match "blank|blank_fwd|numeric_traits|fenv") { "detail" }
            elseif ($_ -match "is_placeholder|mem_fn") { "bind" }
            elseif ($_ -eq "exception_ptr") { "exception" }
            elseif ($_ -match "multi_index_container|multi_index_container_fwd") { "multi_index" }
            elseif ($_ -eq "lexical_cast") { "lexical_cast"; "math" }
            elseif ($_ -match "token_iterator|token_functions") { "tokenizer" }
            elseif ($_ -eq "numeric" -and $library -notmatch "numeric_conversion|interval|odeint|ublas") { "numeric_conversion"; "interval"; "odeint"; "ublas" }
            elseif ($_ -eq "io_fwd") { "io" }
            else { $_ }
        } | group | % name | ? { $_ -ne $library }

        #"`nFor ${library}:"
        "      [known] " + $($groups | ? { $libraries_found -contains $_ })
        "    [unknown] " + $($groups | ? { $libraries_found -notcontains $_ })

        $deps = @($groups | ? { $libraries_found -contains $_ })

        $deps = @($deps | ? {
            # Boost contains cycles, so remove a few dependencies to break the loop.
            (($library -notmatch "core|assert|mpl|detail|throw_exception|type_traits|^exception") -or ($_ -notmatch "utility")) `
            -and `
            (($library -notmatch "assert") -or ($_ -notmatch "integer"))`
            -and `
            (($library -notmatch "range") -or ($_ -notmatch "algorithm"))`
            -and `
            (($library -ne "config") -or ($_ -notmatch "integer"))`
            -and `
            (($library -notmatch "multiprecision") -or ($_ -notmatch "random|math"))`
            -and `
            (($library -notmatch "lexical_cast") -or ($_ -notmatch "math"))`
            -and `
            (($library -notmatch "functional") -or ($_ -notmatch "function"))`
            -and `
            (($library -notmatch "detail") -or ($_ -notmatch "static_assert|integer|mpl|type_traits"))`
            -and `
            ($_ -notmatch "mpi")`
            -and `
            (($library -notmatch "spirit") -or ($_ -notmatch "serialization"))`
            -and `
            (($library -notmatch "throw_exception") -or ($_ -notmatch "^exception"))`
            -and `
            (($library -notmatch "iostreams|math") -or ($_ -notmatch "random"))`
            -and `
            (($library -notmatch "utility|concept_check") -or ($_ -notmatch "iterator"))
        } | % { $_ -replace "_","-" } | % { TransformReference $_ })

        $deps += @("boost-vcpkg-helpers")

        $needsBuild = $false
        if ((Test-Path $unpacked/build/Jamfile.v2) -and $library -ne "metaparse" -and $library -ne "graph_parallel")
        {
            $deps += @("boost-build", "boost-modular-build-helper")
            $needsBuild = $true
        }

        if ($library -eq "python")
        {
            $deps += @("python3")
            $needsBuild = $true
        }
        elseif ($library -eq "iostreams")
        {
            $deps += @("zlib", "bzip2", "liblzma", "zstd")
        }
        elseif ($library -eq "locale")
        {
            $deps += @(@{ name="libiconv"; platform="!uwp&!windows&!mingw" }, "boost-system")
        }
        elseif ($library -eq "asio")
        {
            $deps += @("openssl")
        }
        elseif ($library -eq "mpi")
        {
            $deps += @("mpi")
        }

        $portName = $library -replace "_","-"

        Generate `
            -Name $library `
            -PortName $portName `
            -Hash $hash `
            -Depends $deps `
            -NeedsBuild $needsBuild

        $libraries_in_boost_port += @(TransformReference $portName)
    }
    finally
    {
        popd
    }
}

if ($libraries_in_boost_port.length -gt 1) {
    # Generate master boost control file which depends on each individual library
    # mpi is excluded due to it having a dependency on msmpi/openmpi
    $boostDependsList = $libraries_in_boost_port | ? { $_ -notmatch "boost-mpi" }

    @{
        name="boost";
        "version-string"=$version;
        "port-version"= $port_versions.boost ? $port_versions.boost : 0;
        homepage="https://boost.org";
        description="Peer-reviewed portable C++ source libraries";
        dependencies=$boostDependsList;
        features=@(
            @{
                name="mpi";
                description="Build with MPI support";
                dependencies=@("boost-mpi");
            }
        );
    } | ConvertTo-Json -Depth 10 -Compress | out-file -enc ascii $portsDir/boost/vcpkg.json
    & $vcpkg format-manifest "$portsDir/boost/vcpkg.json"

    "set(VCPKG_POLICY_EMPTY_PACKAGE enabled)`n" | out-file -enc ascii $portsDir/boost/portfile.cmake
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#
<#
.SYNOPSIS
Moves files from an MSVC compiler drop to the locations where they are installed in a Visual Studio installation.

.PARAMETER DropRoot
The location where the MSVC compiler drop has been downloaded.

.PARAMETER BuildType
The MSVC drop build type set with /p:_BuildType when MSVC was built. Defaults to 'ret'.

#>
[CmdletBinding()]
param(
    [Parameter(Mandatory = $true)][string]$DropRoot,
    [Parameter(Mandatory = $false)][ValidateSet('ret', 'chk')][string]$BuildType = 'ret'
)

Set-StrictMode -Version Latest

$MSVCRoot = "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC"

$ErrorActionPreference = "Stop"

$tempRoot = "$DropRoot\readytodeploy"

New-Item -ItemType Directory -Path $tempRoot | Out-Null

Write-Host "Rearranging x86$BuildType"
New-Item -ItemType Directory -Path "$tempRoot\bin\HostX86" | Out-Null
Move-Item "$DropRoot\binaries.x86$BuildType\bin\i386" "$tempRoot\bin\HostX86\x86"
Move-Item "$DropRoot\binaries.x86$BuildType\bin\x86_amd64" "$tempRoot\bin\HostX86\x64"
Move-Item "$DropRoot\binaries.x86$BuildType\bin\x86_arm" "$tempRoot\bin\HostX86\arm"

Write-Host "Rearranging amd64$BuildType"
New-Item -ItemType Directory -Path "$tempRoot\bin\HostX64" | Out-Null
Move-Item "$DropRoot\binaries.amd64$BuildType\bin\amd64" "$tempRoot\bin\HostX64\x64"
Move-Item "$DropRoot\binaries.amd64$BuildType\bin\amd64_x86" "$tempRoot\bin\HostX64\x86"
Move-Item "$DropRoot\binaries.amd64$BuildType\bin\amd64_arm" "$tempRoot\bin\HostX64\arm"

# Only copy files and directories that already exist in the VS installation.
Write-Host "Rearranging inc, lib"
New-Item -ItemType Directory -Path "$tempRoot\lib" | Out-Null
Move-Item "$DropRoot\binaries.x86$BuildType\inc" "$tempRoot\include"
Move-Item "$DropRoot\binaries.x86$BuildType\lib\i386" "$tempRoot\lib\x86"
Move-Item "$DropRoot\binaries.amd64$BuildType\lib\amd64" "$tempRoot\lib\x64"

Write-Host "Rearranging atlmfc"
New-Item -ItemType Directory -Path "$tempRoot\atlmfc" | Out-Null
New-Item -ItemType Directory -Path "$tempRoot\atlmfc\lib" | Out-Null
Move-Item "$DropRoot\binaries.x86$BuildType\atlmfc\include" "$tempRoot\atlmfc\include"
Move-Item "$DropRoot\binaries.x86$BuildType\atlmfc\lib\i386" "$tempRoot\atlmfc\lib\x86"
Move-Item "$DropRoot\binaries.amd64$BuildType\atlmfc\lib\amd64" "$tempRoot\atlmfc\lib\x64"

$toolsets = Get-ChildItem -Path $MSVCRoot -Directory | Sort-Object -Descending
if ($toolsets.Length -eq 0) {
    throw "Could not find Visual Studio toolset!"
}

Write-Host "Found toolsets:`n$($toolsets -join `"`n`")`n"
$selectedToolset = $toolsets[0]
Write-Host "Using toolset: $selectedToolset"
for ($idx = 1; $idx -lt $toolsets.Length; $idx++) {
    $badToolset = $toolsets[$idx]
    Write-Host "Deleting toolset: $badToolset"
    Remove-Item $badToolset -Recurse -Force
}

# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT

<#
.SYNOPSIS
Returns whether there's a name collision in the resource group.

.DESCRIPTION
Find-ResourceGroupNameCollision takes a list of resources, and checks if $Test
collides names with any of the resources.

.PARAMETER Test
The name to test.

.PARAMETER Resources
The list of resources.
#>
function Find-ResourceGroupNameCollision {
  [CmdletBinding()]
  Param([string]$Test, $Resources)

  foreach ($resource in $Resources) {
    if ($resource.ResourceGroupName -eq $Test) {
      return $true
    }
  }

  return $false
}

<#
.SYNOPSIS
Attempts to find a name that does not collide with any resources in the resource group.

.DESCRIPTION
Find-ResourceGroupName takes a set of resources from Get-AzResourceGroup, and finds the
first name in {$Prefix, $Prefix-1, $Prefix-2, ...} such that the name doesn't collide with
any of the resources in the resource group.

.PARAMETER Prefix
The prefix of the final name; the returned name will be of the form "$Prefix(-[1-9][0-9]*)?"
#>
function Find-ResourceGroupName {
  [CmdletBinding()]
  Param([string] $Prefix)

  $resources = Get-AzResourceGroup
  $result = $Prefix
  $suffix = 0
  while (Find-ResourceGroupNameCollision -Test $result -Resources $resources) {
    $suffix++
    $result = "$Prefix-$suffix"
  }

  return $result
}

<#
.SYNOPSIS
Generates a random password.

.DESCRIPTION
New-Password generates a password, randomly, of length $Length, containing
only alphanumeric characters, underscore, and dash.

.PARAMETER Length
The length of the returned password.
#>
function New-Password {
  Param ([int] $Length = 32)

  # This 64-character alphabet generates 6 bits of entropy per character.
  # The power-of-2 alphabet size allows us to select a character by masking a random Byte with bitwise-AND.
  $alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-"
  $mask = 63
  if ($alphabet.Length -ne 64) {
    throw 'Bad alphabet length'
  }

  [Byte[]]$randomData = [Byte[]]::new($Length)
  $rng = $null
  try {
    $rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()
    $rng.GetBytes($randomData)
  }
  finally {
    if ($null -ne $rng) {
      $rng.Dispose()
    }
  }

  $result = ''
  for ($idx = 0; $idx -lt $Length; $idx++) {
    $result += $alphabet[$randomData[$idx] -band $mask]
  }

  return $result
}

<#
.SYNOPSIS
Waits for the shutdown of the specified resource.

.DESCRIPTION
Wait-Shutdown takes a VM, and checks if there's a 'PowerState/stopped'
code; if there is, it returns. If there isn't, it waits ten seconds and
tries again.

.PARAMETER ResourceGroupName
The name of the resource group to look up the VM in.

.PARAMETER Name
The name of the virtual machine to wait on.
#>
function Wait-Shutdown {
  [CmdletBinding()]
  Param([string]$ResourceGroupName, [string]$Name)

  Write-Host "Waiting for $Name to stop..."
  while ($true) {
    $Vm = Get-AzVM -ResourceGroupName $ResourceGroupName -Name $Name -Status
    $highestStatus = $Vm.Statuses.Count
    for ($idx = 0; $idx -lt $highestStatus; $idx++) {
      if ($Vm.Statuses[$idx].Code -eq 'PowerState/stopped') {
        return
      }
    }

    Write-Host "... not stopped yet, sleeping for 10 seconds"
    Start-Sleep -Seconds 10
  }
}

<#
.SYNOPSIS
Sanitizes a name to be used in a storage account.

.DESCRIPTION
Sanitize-Name takes a string, and removes all of the '-'s and
lowercases the string, since storage account names must have no
'-'s and must be completely lowercase alphanumeric. It then makes
certain that the length of the string is not greater than 24,
since that is invalid.

.PARAMETER RawName
The name to sanitize.
#>
function Sanitize-Name {
  [CmdletBinding()]
  Param(
    [string]$RawName
  )

  $result = $RawName.Replace('-', '').ToLowerInvariant()
  if ($result.Length -gt 24) {
    Write-Error 'Sanitized name for storage account $result was too long.'
    throw
  }

  return $result
}

Export-ModuleMember -Function Find-ResourceGroupName
Export-ModuleMember -Function New-Password
Export-ModuleMember -Function Wait-Shutdown
#!pwsh
#Requires -Version 6.0

<#
.SYNOPSIS
Installs the set of prerequisites for the macOS CI hosts.

.DESCRIPTION
Install-Prerequisites.ps1 installs all of the necessary prerequisites
to run the vcpkg macOS CI in a vagrant virtual machine,
skipping all prerequisites that are already installed.

.PARAMETER Force
Don't skip the prerequisites that are already installed.

.INPUTS
None

.OUTPUTS
None
#>
[CmdletBinding()]
Param(
    [Parameter()]
    [Switch]$Force
)

Set-StrictMode -Version 2

if (-not $IsMacOS) {
    Write-Error 'This script should only be run on a macOS host'
    throw
}

Import-Module "$PSScriptRoot/Utilities.psm1"

$Installables = Get-Content "$PSScriptRoot/configuration/installables.json" | ConvertFrom-Json

$Installables.Applications | ForEach-Object {
    if (-not (Get-CommandExists $_.TestCommand)) {
        Write-Host "$($_.Name) not installed; installing now"
    } elseif ($Force) {
        Write-Host "$($_.Name) found; attempting to upgrade or re-install"
    } else {
        Write-Host "$($_.Name) already installed"
        return
    }

    $pathToDmg = "~/Downloads/$($_.Name).dmg"
    Get-RemoteFile -OutFile $pathToDmg -Uri $_.DmgUrl -Sha256 $_.Sha256

    hdiutil attach $pathToDmg -mountpoint /Volumes/setup-installer
    sudo installer -pkg "/Volumes/setup-installer/$($_.InstallerPath)" -target /
    hdiutil detach /Volumes/setup-installer
}

$Installables.Brew | ForEach-Object {
    $installable = $_
    if ($null -eq (Get-Member -InputObject $installable -Name 'Kind')) {
        brew install $installable.Name
    } else {
        switch ($installable.Kind) {
            'cask' { brew install --cask $installable.Name }
            default {
                Write-Error "Invalid kind: $_. Expected either empty, or 'cask'."
            }
         }
     }
}

# Install plugins
$installedExtensionPacks = Get-InstalledVirtualBoxExtensionPacks

$Installables.VBoxExtensions | ForEach-Object {
    $extension = $_
    $installedExts = $installedExtensionPacks | Where-Object { $_.Pack -eq $extension.FullName -and $_.Usable -eq 'true' }

    if ($null -eq $installedExts) {
        Write-Host "VBox extension: $($extension.Name) not installed; installing now"
    } elseif ($Force) {
        Write-Host "VBox extension: $($extension.Name) found; attempting to upgrade or re-install"
    } else {
        Write-Host "VBox extension: $($extension.Name) already installed"
        return
    }

    $pathToExt = "~/Downloads/$($extension.FullName -replace ' ','_').vbox-extpack"

    Get-RemoteFile -OutFile $pathToExt -Uri $extension.Url -Sha256 $extension.Sha256 | Out-Null

#!pwsh
#Requires -Version 6.0

<#
.SYNOPSIS
Sets up the configuration for the vagrant virtual machines.

.DESCRIPTION
Setup-VagrantMachines.ps1 sets up the virtual machines for
vcpkg's macOS CI. It puts the VagrantFile and necessary
configuration JSON file into ~/vagrant/vcpkg-eg-mac.

.PARAMETER MachineId
The number to give the machine; should match [0-9]{2}.

.PARAMETER DevopsPat
The personal access token which has Read & Manage permissions on the ADO pool.

.PARAMETER Date
The date on which this pool is being created. Sets the default values for BoxVersion and AgentPool.

.PARAMETER BoxVersion
The version of the box to use. If -Date is passed, uses that as the version.

.PARAMETER AgentPool
The agent pool to add the machine to. If -Date is passed, uses "PrOsx-$Date" as the pool.

.PARAMETER DevopsUrl
The URL of the ADO instance; defaults to vcpkg's, which is https://dev.azure.com/vcpkg.

.PARAMETER BaseName
The base name for the vagrant VM; the machine name is $BaseName-$MachineId.
Defaults to 'vcpkg-eg-mac'.

.PARAMETER BoxName
The name of the box to use. Defaults to 'vcpkg/macos-ci',
which is only available internally.

.PARAMETER Force
Delete any existing vagrant/vcpkg-eg-mac directory.

.PARAMETER DiskSize
The size to make the temporary disks in gigabytes. Defaults to 350.

.INPUTS
None

.OUTPUTS
None
#>
[CmdletBinding(PositionalBinding=$False, DefaultParameterSetName='DefineDate')]
Param(
    [Parameter(Mandatory=$True)]
    [String]$MachineId,

    [Parameter(Mandatory=$True)]
    [String]$DevopsPat,

    [Parameter(Mandatory=$True, ParameterSetName='DefineDate')]
    [String]$Date,

    [Parameter(Mandatory=$True, ParameterSetName='DefineVersionAndAgentPool')]
    [String]$BoxVersion,

    [Parameter(Mandatory=$True, ParameterSetName='DefineVersionAndAgentPool')]
    [String]$AgentPool,

    [Parameter(Mandatory=$False)]
    [String]$DevopsUrl = 'https://dev.azure.com/vcpkg',

    [Parameter()]
    [String]$BaseName = 'vcpkg-eg-mac',

    [Parameter()]
    [String]$BoxName = 'vcpkg/macos-ci',

    [Parameter()]
    [Int]$DiskSize = 250,

    [Parameter()]
    [Switch]$Force
)

Set-StrictMode -Version 2

if (-not $IsMacOS) {
    throw 'This script should only be run on a macOS host'
}

if (-not [String]::IsNullOrEmpty($Date)) {
    $BoxVersion = $Date
    $AgentPool = "PrOsx-$Date"
}

if (Test-Path '~/vagrant/vcpkg-eg-mac') {
    if ($Force) {
        Write-Host 'Deleting existing directories'
        Remove-Item -Recurse -Force -Path '~/vagrant/vcpkg-eg-mac' | Out-Null
    } else {
        throw '~/vagrant/vcpkg-eg-mac already exists; try re-running with -Force'
    }
}

Write-Host 'Creating new directories'
if (-not (Test-Path -Path '~/vagrant')) {
	New-Item -ItemType 'Directory' -Path '~/vagrant' | Out-Null
}
New-Item -ItemType 'Directory' -Path '~/vagrant/vcpkg-eg-mac' | Out-Null

Copy-Item `
    -Path "$PSScriptRoot/configuration/Vagrantfile" `
    -Destination '~/vagrant/vcpkg-eg-mac/Vagrantfile'

$configuration = @{
    pat = $DevopsPat;
    agent_pool = $AgentPool;
    devops_url = $DevopsUrl;
    machine_name = "${BaseName}-${MachineId}";
    box_name = $BoxName;
    box_version = $BoxVersion;
#!pwsh
#Requires -Version 6.0

<#
.SYNOPSIS
Installs the base box at the specified version from the share.

.PARAMETER FileshareMachine
The machine which is acting as a fileshare

.PARAMETER BoxVersion
The version of the box to add. Defaults to latest if nothing is passed.
#>
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$True)]
    [String]$FileshareMachine,

    [Parameter()]
    [String]$BoxVersion
)

Set-StrictMode -Version 2

if (-not $IsMacOS) {
    throw 'This script should only be run on a macOS host'
}

$mountPoint = '/Users/vcpkg/vagrant/share'

if (mount | grep "on $mountPoint (") {
    umount $mountPoint
    if (-not $?) {
        Write-Error "umount $mountPoint failed with return code $LASTEXITCODE."
        throw
    }
}

sshfs "fileshare@${FileshareMachine}:/Users/fileshare/share" $mountPoint
if ($LASTEXITCODE -eq 1) {
    Write-Error 'sshfs returned 1.
This means that the osxfuse kernel extension was not allowed to load.
You may need to force un/reinstall osxfuse and/or sshfs with
  brew uninstall osxfuse
  brew uninstall sshfs
  brew install osxfuse
  brew install sshfs
Then, rerun this script.

If you''ve already done that, Please open
System Preferences > Security & Privacy > General,
and allow the kernel extension to load.
Then, rerun this script.

If you''ve already done this, you probably need to add your ssh keys to the fileshare machine.'
    throw
} elseif (-not $?) {
    Write-Error "sshfs failed with return code $LASTEXITCODE."
    throw
}

if (-not [String]::IsNullOrEmpty($BoxVersion)) {
    $versionArgs = @("--box-version", $BoxVersion)
} else {
    $versionArgs = @()
#Requires -Version 6.0
Set-StrictMode -Version 2

<#
.SYNOPSIS
Returns whether the specified command exists in the current environment.

.DESCRIPTION
Get-CommandExists takes a string as a parameter,
and returns whether it exists in the current environment;
either a function, alias, or an executable in the path.
It's somewhat equivalent to `which`.

.PARAMETER Name
Specifies the name of the command which may or may not exist.

.INPUTS
System.String
    The name of the command.

.OUTPUTS
System.Boolean
    Whether the command exists.
#>
function Get-CommandExists
{
    [CmdletBinding()]
    [OutputType([Boolean])]
    Param(
        [Parameter(ValueFromPipeline)]
        [String]$Name
    )

    $null -ne (Get-Command -Name $Name -ErrorAction SilentlyContinue)
}

<#
.SYNOPSIS
Downloads a file and checks its hash.

.DESCRIPTION
Get-RemoteFile takes a URI and a hash,
downloads the file at that URI to OutFile,
and checks that the hash of the downloaded file.
It then returns a FileInfo object corresponding to the downloaded file.

.PARAMETER OutFile
Specifies the file path to download to.

.PARAMETER Uri
The URI to download from.

.PARAMETER Sha256
The expected SHA256 of the downloaded file.

.INPUTS
None

.OUTPUTS
System.IO.FileInfo
    The FileInfo for the downloaded file.
#>
function Get-RemoteFile
{
    [CmdletBinding(PositionalBinding=$False)]
    [OutputType([System.IO.FileInfo])]
    Param(
        [Parameter(Mandatory=$True)]
        [String]$OutFile,
        [Parameter(Mandatory=$True)]
        [String]$Uri,
        [Parameter(Mandatory=$True)]
        [String]$Sha256
    )

    Invoke-WebRequest -OutFile $OutFile -Uri $Uri
    $actualHash = Get-FileHash -Algorithm SHA256 -Path $OutFile

    if ($actualHash.Hash -ne $Sha256) {
        throw @"
Invalid hash for file $OutFile;
    expected: $Hash
    found:    $($actualHash.Hash)
Please make sure that the hash in the powershell file is correct.
"@
    }

    Get-Item $OutFile
}

<#
.SYNOPSIS
Gets the list of installed extensions as powershell objects.

.DESCRIPTION
Get-InstalledVirtualBoxExtensionPacks gets the installed extensions,
returning objects that look like:

{
    Pack = 'Oracle VM VirtualBox Extension Pack';
    Version = '6.1.10';
    ...
}

.INPUTS
None

.OUTPUTS
PSCustomObject
    The list of VBox Extension objects that are installed.
#>
function Get-InstalledVirtualBoxExtensionPacks
{
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    Param()

    $lines = VBoxManage list extpacks

    $result = @()

    $currentObject = $null
    $currentKey = ""
    $currentString = ""

    $lines | ForEach-Object {
        $Line = $_
        if ($Line[0] -eq ' ') {
            $currentString += "`n$($Line.Trim())"
        } else {
            if ($null -ne $currentObject) {
                $currentObject.$currentKey = $currentString
            }
            $currentKey, $currentString = $Line -Split ':'
            $currentString = $currentString.Trim()

            if ($currentKey.StartsWith('Pack no')) {
                $currentKey = 'Pack'
                if ($null -ne $currentObject) {
                    Write-Output ([PSCustomObject]$currentObject)
                }
                $currentObject = @{}
            }
        }
    }

    if ($null -ne $currentObject) {
        $currentObject.$currentKey = $currentString
        Write-Output ([PSCustomObject]$currentObject)
    }
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#

<#
.SYNOPSIS
Generates a list of ports to skip in the CI.

.DESCRIPTION
generate-skip-list takes a triplet, and the path to the ci.baseline.txt
file, and generates a skip list string to pass to vcpkg.

.PARAMETER Triplet
The triplet to find skipped ports for.

.PARAMETER BaselineFile
The path to the ci.baseline.txt file.
#>
[CmdletBinding()]
Param(
    [string]$Triplet,
    [string]$BaselineFile,
    [switch]$SkipFailures = $false
)

$ErrorActionPreference = 'Stop'

if (-not (Test-Path -Path $BaselineFile)) {
    Write-Error "Unable to find baseline file $BaselineFile"
    throw
}

#read in the file, strip out comments and blank lines and spaces
$baselineListRaw = Get-Content -Path $BaselineFile `
    | Where-Object { -not ($_ -match "\s*#") } `
    | Where-Object { -not ( $_ -match "^\s*$") } `
    | ForEach-Object { $_ -replace "\s" }

###############################################################
# This script is running at the beginning of the CI test, so do a little extra
# checking so things can fail early.

#verify everything has a valid value
$missingValues = $baselineListRaw | Where-Object { -not ($_ -match "=\w") }

if ($missingValues) {
    Write-Error "The following are missing values: $missingValues"
    throw
}

$invalidValues = $baselineListRaw `
    | Where-Object { -not ($_ -match "=(skip|pass|fail|ignore)$") }

if ($invalidValues) {
    Write-Error "The following have invalid values: $invalidValues"
    throw
}

$baselineForTriplet = $baselineListRaw `
    | Where-Object { $_ -match ":$Triplet=" }

# Verify there are no duplicates (redefinitions are not allowed)
$file_map = @{ }
foreach ($port in $baselineForTriplet | ForEach-Object { $_ -replace ":.*$" }) {
    if ($null -ne $file_map[$port]) {
        Write-Error `
            "$($port):$($Triplet) has multiple definitions in $baselineFile"
        throw
    }
    $file_map[$port] = $true
}

# Format the skip list for the command line
if ($SkipFailures) {
    $targetRegex = "=(?:skip|fail)$"
} else {
    $targetRegex = "=skip$"
}

$skip_list = $baselineForTriplet `
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#

<#
.SYNOPSIS
Analyze the test results as output by the CI system.

.DESCRIPTION
Takes the set of port test results from $logDir,
and the baseline from $baselineFile, and makes certain that the set
of failures we expected are exactly the set of failures we got.
Then, uploads the logs from any unexpected failures.

.PARAMETER logDir
Directory of xml test logs to analyze.

.PARAMETER allResults
Include tests that have no change from the baseline in the output.

.PARAMETER triplet
The triplet to analyze.

.PARAMETER baselineFile
The path to the ci.baseline.txt file in the vcpkg repository.
#>
[CmdletBinding()]
Param(
    [Parameter(Mandatory = $true)]
    [string]$logDir,
    [switch]$allResults,
    [Parameter(Mandatory = $true)]
    [string]$triplet,
    [Parameter(Mandatory = $true)]
    [string]$baselineFile
)

$ErrorActionPreference = 'Stop'

if ( -not (Test-Path $logDir) ) {
    [System.Console]::Error.WriteLine("Log directory does not exist: $logDir")
    exit
}

<#
.SYNOPSIS
Creates an object the represents the test run.

.DESCRIPTION
build_test_results takes an XML file of results from the CI run,
and constructs an object based on that XML file for further
processing.

.OUTPUTS
An object with the following elements:
    assemblyName:
    assemblyStartDate:
    assemblyStartTime:
    assemblyTime:
    collectionName:
    collectionTime:
    allTests: A hashtable with an entry for each port tested
        The key is the name of the port
        The value is an object with the following elements:
            name: Name of the port (Does not include the triplet name)
            result: Pass/Fail/Skip result from xunit
            time: Test time in seconds
            originalResult: Result as defined by Build.h in vcpkg source code
            abi_tag: The port hash
            features: The features installed

.PARAMETER xmlFilename
The path to the XML file to parse.
#>
function build_test_results {
    [CmdletBinding()]
    Param
    (
        [string]$xmlFilename
    )
    if ( ($xmlFilename.Length -eq 0) -or ( -not( Test-Path $xmlFilename))) {
        #write-error "Missing file: $xmlFilename"
        return $null
    }

    Write-Verbose "building test hash for $xmlFilename"

    [xml]$xmlContents = Get-Content $xmlFilename

    # This currently only supports one collection per assembly, which is the way
    # the vcpkg tests are designed to run in the pipeline.
    $xmlAssembly = $xmlContents.assemblies.assembly
    $assemblyName = $xmlAssembly.name
    $assemblyStartDate = $xmlAssembly."run-date"
    $assemblyStartTime = $xmlAssembly."run-time"
    $assemblyTime = $xmlAssembly.time
    $xmlCollection = $xmlAssembly.collection
    $collectionName = $xmlCollection.name
    $collectionTime = $xmlCollection.time

    $allTestResults = @{ }
    foreach ( $test in $xmlCollection.test) {
        $name = ($test.name -replace ":.*$")

        # Reconstruct the original BuildResult enumeration (defined in Build.h)
        #   failure.message - why the test failed (valid only on test failure)
        #   reason - why the test was skipped (valid only when the test is skipped)
        #    case BuildResult::POST_BUILD_CHECKS_FAILED:
        #    case BuildResult::FILE_CONFLICTS:
        #    case BuildResult::BUILD_FAILED:
        #    case BuildResult::EXCLUDED:
        #    case BuildResult::CASCADED_DUE_TO_MISSING_DEPENDENCIES:
        $originalResult = "NULLVALUE"
        switch ($test.result) {
            "Skip" {
                $originalResult = $test.reason.InnerText
            }
            "Fail" {
                $originalResult = $test.failure.message.InnerText
            }
            "Pass" {
                $originalResult = "SUCCEEDED"
            }
        }

        $abi_tag = ""
        $features = ""
        foreach ( $trait in $test.traits.trait) {
            switch ( $trait.name ) {
                "abi_tag" { $abi_tag = $trait.value }
                "features" { $features = $trait.value }
            }
        }

        # If additional fields get saved in the XML, then they should be added to this hash
        # also consider using a PSCustomObject here instead of a hash
        $testHash = @{ name = $name; result = $test.result; time = $test.time; originalResult = $originalResult; abi_tag = $abi_tag; features = $features }
        $allTestResults[$name] = $testHash
    }

    return @{
        assemblyName      = $assemblyName;
        assemblyStartDate = $assemblyStartDate;
        assemblyStartTime = $assemblyStartTime;
        assemblyTime      = $assemblyTime;
        collectionName    = $collectionName;
        collectionTime    = $collectionTime;
        allTests          = $allTestResults
    }
}

<#
.SYNOPSIS
Creates an object that represents the baseline expectations.

.DESCRIPTION
build_baseline_results converts the baseline file to an object representing
the expectations set up by the baseline file. It records four states:
    1) fail
    2) skip
    3) ignore
    4) pass -- this is represented by not being recorded
In other words, if a port is not contained in the object returned by this
cmdlet, expect it to pass.

.OUTPUTS
An object containing the following fields:
    collectionName: the triplet
    fail: ports marked as fail
    skip: ports marked as skipped
    ignore: ports marked as ignore

.PARAMETER baselineFile
The path to vcpkg's ci.baseline.txt.

.PARAMETER triplet
The triplet to create the result object for.
#>
function build_baseline_results {
    [CmdletBinding()]
    Param(
        $baselineFile,
        $triplet
    )
    #read in the file, strip out comments and blank lines and spaces, leave only the current triplet
    #remove comments, remove empty lines, remove whitespace, then keep only those lines for $triplet
    $baseline_list_raw = Get-Content -Path $baselineFile `
        | Where-Object { -not ($_ -match "\s*#") } `
        | Where-Object { -not ( $_ -match "^\s*$") } `
        | ForEach-Object { $_ -replace "\s" } `
        | Where-Object { $_ -match ":$triplet=" }

    #filter to skipped and trim the triplet
    $skip_hash = @{ }
    foreach ( $port in $baseline_list_raw | ? { $_ -match "=skip$" } | % { $_ -replace ":.*$" }) {
        if ($skip_hash[$port] -ne $null) {
            [System.Console]::Error.WriteLine("$($port):$($triplet) has multiple definitions in $baselineFile")
        }
        $skip_hash[$port] = $true
    }
    $fail_hash = @{ }
    $baseline_list_raw | ? { $_ -match "=fail$" } | % { $_ -replace ":.*$" } | ? { $fail_hash[$_] = $true } | Out-Null
    $ignore_hash = @{ }
    $baseline_list_raw | ? { $_ -match "=ignore$" } | % { $_ -replace ":.*$" } | ? { $ignore_hash[$_] = $true } | Out-Null

    return @{
        collectionName = $triplet;
        skip           = $skip_hash;
        fail           = $fail_hash;
        ignore         = $ignore_hash
    }
}

<#
.SYNOPSIS
Analyzes the results of the current run against the baseline.

.DESCRIPTION
combine_results compares the results to the baselie, and generates the results
for the CI -- whether it should pass or fail.

.OUTPUTS
An object containing the following:
(Note that this is not the same data structure as build_test_results)
    assemblyName:
    assemblyStartDate:
    assemblyStartTime:
    assemblyTime:
    collectionName:
    collectionTime:
    allTests: A hashtable of each port with a different status from the baseline
        The key is the name of the port
        The value is an object with the following data members:
            name: The name of the port
            result: xunit test result Pass/Fail/Skip
            message: Human readable message describing the test result
            time: time the current test results took to run.
            baselineResult:
            currentResult:
            features:
    ignored: list of ignored tests

.PARAMETER baseline
The baseline object to use from build_baseline_results.

.PARAMETER current
The results object to use from build_test_results.
#>
function combine_results {
    [CmdletBinding()]
    Param
    (
        $baseline,
        $current
    )

    if ($baseline.collectionName -ne $current.collectionName) {
        Write-Warning "Comparing mismatched collections $($baseline.collectionName) and $($current.collectionName)"
    }

    $currentTests = $current.allTests

    # lookup table with the results of all of the tests
    $allTestResults = @{ }

    $ignoredList = @()

    Write-Verbose "analyzing $($currentTests.count) tests"

    foreach ($key in $currentTests.keys) {
        Write-Verbose "analyzing $key"

        $message = $null
        $result = $null
        $time = $null
        $currentResult = $null
        $features = $currentTest.features

        $baselineResult = "Pass"
        if ($baseline.fail[$key] -ne $null) {
            Write-Verbose "$key is failing"
            $baselineResult = "Fail"
        }
        elseif ( $baseline.skip[$key] -ne $null) {
            Write-Verbose "$key is skipped"
            $baselineResult = "Skip"
        }
        elseif ( $baseline.ignore[$key] -ne $null) {
            $baselineResult = "ignore"
        }

        $currentTest = $currentTests[$key]

        if ( $currentTest.result -eq $baselineResult) {
            Write-Verbose "$key has no change from baseline"
            $currentResult = $currentTest.result
            if ($allResults) {
                # Only marking regressions as failures but keep the skipped status
                if ($currentResult -eq "Skip") {
                    $result = "Skip"
                }
                else {
                    $result = "Pass"
                }
                $message = "No change from baseline"
                $time = $currentTest.time
            }
        }
        elseif ( $baselineResult -eq "ignore") {
            if ( $currentTest.result -eq "Fail" ) {
                Write-Verbose "ignoring failure on $key"
                $ignoredList += $key
            }
        }
        else {
            Write-Verbose "$key had a change from the baseline"

            $currentResult = $currentTest.result
            # Test exists in both test runs but does not match.  Determine if this is a regression
            # Pass -> Fail = Fail (Regression)
            # Pass -> Skip = Skip
            # Fail -> Pass = Fail (need to update baseline)
            # Fail -> Skip = Skip
            # Skip -> Fail = Fail (Should not happen)
            # Skip -> Pass = Fail (should not happen)

            $lookupTable = @{
                'Pass' = @{
                    'Fail' = @('Fail', "Test passes in baseline but fails in current run. If expected update ci.baseline.txt with '$($key):$($current.collectionName)=fail'");
                    'Skip' = @($null, 'Test was skipped due to missing dependencies')
                };
                'Fail' = @{
                    'Pass' = @('Fail', "Test fails in baseline but now passes.  Update ci.baseline.txt with '$($key):$($current.collectionName)=pass'");
                    'Skip' = @($null, 'Test fails in baseline but is skipped in current run')
                };
                'Skip' = @{
                    'Fail' = @('Skip', "Test is skipped in baseline but fails in current run. Results are ignored")
                    'Pass' = @('Skip', "Test is skipped in baseline but passes in current run. Results are ignored")
                }
            }
            $resultList = $lookupTable[$baselineResult][$currentResult]
            $result = $resultList[0]
            $message = $resultList[1]
            $time = $currentTest.time
            Write-Verbose ">$key $message"
        }

        if ($result -ne $null) {
            Write-Verbose "Adding $key to result list"
            $allTestResults[$key] = @{ name = $key; result = $result; message = $message; time = $time; abi_tag = $currentTest.abi_tag; baselineResult = $baselineResult; currentResult = $currentResult; features = $features }
        }
    }

    return @{
        assemblyName      = $current.assemblyName;
        assemblyStartDate = $current.assemblyStartDate;
        assemblyStartTime = $current.assemblyStartTime;
        assemblyTime      = $current.assemblyTime;
        collectionName    = $current.collectionName;
        collectionTime    = $current.collectionTime;
        allTests          = $allTestResults;
        ignored           = $ignoredList
    }
}

<#
.SYNOPSIS
Writes short errors to the CI logs.

.DESCRIPTION
write_errors_for_summary takes a hashtable from triplets to combine_results
objects, and writes short errors to the CI logs.

.PARAMETER complete_results
A hashtable from triplets to combine_results objects.
#>
function write_errors_for_summary {
    [CmdletBinding()]
    Param(
        $complete_results
    )

    $failure_found = $false

    Write-Verbose "preparing error output for Azure Devops"

    foreach ($triplet in $complete_results.Keys) {
        $triplet_results = $complete_results[$triplet]

        Write-Verbose "searching $triplet triplet"

        # add each port results
        foreach ($testName in $triplet_results.allTests.Keys) {
            $test = $triplet_results.allTests[$testName]

            Write-Verbose "checking $($testName):$triplet $($test.result)"

            if ($test.result -eq 'Fail') {
                $failure_found = $true
                if ($test.currentResult -eq "pass") {
                    [System.Console]::Error.WriteLine( `
                            "PASSING, REMOVE FROM FAIL LIST: $($test.name):$triplet ($baselineFile)" `
                    )
                }
                else {
                    [System.Console]::Error.WriteLine( `
                            "REGRESSION: $($test.name):$triplet. If expected, add $($test.name):$triplet=fail to $baselineFile." `
                    )
                }
            }
        }
    }
}


$complete_results = @{ }
Write-Verbose "looking for $triplet logs"

# The standard name for logs is:
#   <triplet>.xml
# for example:
#   x64-linux.xml

$current_test_hash = build_test_results( Convert-Path "$logDir\$($triplet).xml" )
$baseline_results = build_baseline_results -baselineFile $baselineFile -triplet $triplet

if ($current_test_hash -eq $null) {
    [System.Console]::Error.WriteLine("Missing $triplet test results in current test run")
    $missing_triplets[$triplet] = "test"
}
else {
    Write-Verbose "combining results..."
    $complete_results[$triplet] = combine_results -baseline $baseline_results -current $current_test_hash
}

# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#

<#
.SYNOPSIS
Prepares the virtual machine for imaging.

.DESCRIPTION
Runs the `sysprep` utility to prepare the system for imaging.
See https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/sysprep--system-preparation--overview
for more information.
#>

$ErrorActionPreference = 'Stop'
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#

<#
.SYNOPSIS
Creates a Windows virtual machine scale set, set up for vcpkg's CI.

.DESCRIPTION
create-vmss.ps1 creates an Azure Windows VM scale set, set up for vcpkg's CI
system. See https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/overview
for more information.

This script assumes you have installed Azure tools into PowerShell by following the instructions
at https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-3.6.1
or are running from Azure Cloud Shell.

.PARAMETER Unstable
If this parameter is set, the machine is configured for use in the "unstable" pool used for testing
the compiler rather than for testing vcpkg. Differences:
* The machine prefix is changed to VcpkgUnstable instead of PrWin.
* No storage account or "archives" share is provisioned.
* The firewall is not opened to allow communication with Azure Storage.
#>

[CmdLetBinding()]
Param(
  [switch]$Unstable = $false
)

$Location = 'westus2'
if ($Unstable) {
  $Prefix = 'VcpkgUnstable-'
} else {
  $Prefix = 'PrWin-'
}

$Prefix += (Get-Date -Format 'yyyy-MM-dd')
$VMSize = 'Standard_D16a_v4'
$ProtoVMName = 'PROTOTYPE'
$LiveVMPrefix = 'BUILD'
$WindowsServerSku = '2019-Datacenter'
$ErrorActionPreference = 'Stop'

$ProgressActivity = 'Creating Scale Set'
$TotalProgress = 12
if ($Unstable) {
  $TotalProgress -= 1 # skipping the archives share part
}

$CurrentProgress = 1

Import-Module "$PSScriptRoot/../create-vmss-helpers.psm1" -DisableNameChecking

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating resource group' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$ResourceGroupName = Find-ResourceGroupName $Prefix
$AdminPW = New-Password
New-AzResourceGroup -Name $ResourceGroupName -Location $Location
$AdminPWSecure = ConvertTo-SecureString $AdminPW -AsPlainText -Force
$Credential = New-Object System.Management.Automation.PSCredential ("AdminUser", $AdminPWSecure)

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating virtual network' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$allFirewallRules = @()

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowHTTP `
  -Description 'Allow HTTP(S)' `
  -Access Allow `
  -Protocol Tcp `
  -Direction Outbound `
  -Priority 1008 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange @(80, 443)

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowSFTP `
  -Description 'Allow (S)FTP' `
  -Access Allow `
  -Protocol Tcp `
  -Direction Outbound `
  -Priority 1009 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange @(21, 22)

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowDNS `
  -Description 'Allow DNS' `
  -Access Allow `
  -Protocol * `
  -Direction Outbound `
  -Priority 1010 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange 53

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowGit `
  -Description 'Allow git' `
  -Access Allow `
  -Protocol Tcp `
  -Direction Outbound `
  -Priority 1011 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange 9418

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name DenyElse `
  -Description 'Deny everything else' `
  -Access Deny `
  -Protocol * `
  -Direction Outbound `
  -Priority 1013 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange *

$NetworkSecurityGroupName = $ResourceGroupName + 'NetworkSecurity'
$NetworkSecurityGroup = New-AzNetworkSecurityGroup `
  -Name $NetworkSecurityGroupName `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -SecurityRules $allFirewallRules

$SubnetName = $ResourceGroupName + 'Subnet'
$Subnet = New-AzVirtualNetworkSubnetConfig `
  -Name $SubnetName `
  -AddressPrefix "10.0.0.0/16" `
  -NetworkSecurityGroup $NetworkSecurityGroup `
  -ServiceEndpoint "Microsoft.Storage"

$VirtualNetworkName = $ResourceGroupName + 'Network'
$VirtualNetwork = New-AzVirtualNetwork `
  -Name $VirtualNetworkName `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -AddressPrefix "10.0.0.0/16" `
  -Subnet $Subnet

####################################################################################################
if (-Not $Unstable) {
  Write-Progress `
    -Activity $ProgressActivity `
    -Status 'Creating archives storage account' `
    -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

  $StorageAccountName = Sanitize-Name $ResourceGroupName

  New-AzStorageAccount `
    -ResourceGroupName $ResourceGroupName `
    -Location $Location `
    -Name $StorageAccountName `
    -SkuName 'Standard_LRS' `
    -Kind StorageV2

  $StorageAccountKeys = Get-AzStorageAccountKey `
    -ResourceGroupName $ResourceGroupName `
    -Name $StorageAccountName

  $StorageAccountKey = $StorageAccountKeys[0].Value

  $StorageContext = New-AzStorageContext `
    -StorageAccountName $StorageAccountName `
    -StorageAccountKey $StorageAccountKey

  New-AzStorageContainer -Name archives -Context $StorageContext -Permission Off
  $StartTime = [DateTime]::Now
  $ExpiryTime = $StartTime.AddMonths(6)

  $SasToken = New-AzStorageAccountSASToken `
    -Service Blob `
    -Permission "racwdlup" `
    -Context $StorageContext `
    -StartTime $StartTime `
    -ExpiryTime $ExpiryTime `
    -ResourceType Service,Container,Object `
    -Protocol HttpsOnly

  $SasToken = $SasToken.Substring(1) # strip leading ?

  # Note that we put the storage account into the firewall after creating the above SAS token or we
  # would be denied since the person running this script isn't one of the VMs we're creating here.
  Set-AzStorageAccount `
    -ResourceGroupName $ResourceGroupName `
    -AccountName $StorageAccountName `
    -NetworkRuleSet ( `
      @{bypass="AzureServices"; `
      virtualNetworkRules=( `
        @{VirtualNetworkResourceId=$VirtualNetwork.Subnets[0].Id;Action="allow"}); `
      defaultAction="Deny"})
}

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating prototype VM' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$NicName = $ResourceGroupName + 'NIC'
$Nic = New-AzNetworkInterface `
  -Name $NicName `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -Subnet $VirtualNetwork.Subnets[0]

$VM = New-AzVMConfig -Name $ProtoVMName -VMSize $VMSize -Priority 'Spot' -MaxPrice -1
$VM = Set-AzVMOperatingSystem `
  -VM $VM `
  -Windows `
  -ComputerName $ProtoVMName `
  -Credential $Credential `
  -ProvisionVMAgent

$VM = Add-AzVMNetworkInterface -VM $VM -Id $Nic.Id
$VM = Set-AzVMSourceImage `
  -VM $VM `
  -PublisherName 'MicrosoftWindowsServer' `
  -Offer 'WindowsServer' `
  -Skus $WindowsServerSku `
  -Version latest

$VM = Set-AzVMBootDiagnostic -VM $VM -Disable
New-AzVm `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -VM $VM

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Running provisioning script provision-image.txt (as a .ps1) in VM' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$provisionParameters = @{AdminUserPassword = $AdminPW;}
if (-Not $Unstable) {
  $provisionParameters['StorageAccountName'] = $StorageAccountName
  $provisionParameters['StorageAccountSasToken'] = $SasToken
}

$ProvisionImageResult = Invoke-AzVMRunCommand `
  -ResourceGroupName $ResourceGroupName `
  -VMName $ProtoVMName `
  -CommandId 'RunPowerShellScript' `
  -ScriptPath "$PSScriptRoot\provision-image.txt" `
  -Parameter $provisionParameters

Write-Host "provision-image.ps1 output: $($ProvisionImageResult.value.Message)"

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Restarting VM' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

Restart-AzVM -ResourceGroupName $ResourceGroupName -Name $ProtoVMName

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Running provisioning script sysprep.ps1 in VM' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$SysprepResult = Invoke-AzVMRunCommand `
  -ResourceGroupName $ResourceGroupName `
  -VMName $ProtoVMName `
  -CommandId 'RunPowerShellScript' `
  -ScriptPath "$PSScriptRoot\sysprep.ps1"

Write-Host "sysprep.ps1 output: $($SysprepResult.value.Message)"

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Waiting for VM to shut down' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

Wait-Shutdown -ResourceGroupName $ResourceGroupName -Name $ProtoVMName

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Converting VM to Image' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

Stop-AzVM `
  -ResourceGroupName $ResourceGroupName `
  -Name $ProtoVMName `
  -Force

Set-AzVM `
  -ResourceGroupName $ResourceGroupName `
  -Name $ProtoVMName `
  -Generalized

$VM = Get-AzVM -ResourceGroupName $ResourceGroupName -Name $ProtoVMName
$PrototypeOSDiskName = $VM.StorageProfile.OsDisk.Name
$ImageConfig = New-AzImageConfig -Location $Location -SourceVirtualMachineId $VM.ID
$Image = New-AzImage -Image $ImageConfig -ImageName $ProtoVMName -ResourceGroupName $ResourceGroupName

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Deleting unused VM and disk' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

Remove-AzVM -Id $VM.ID -Force
Remove-AzDisk -ResourceGroupName $ResourceGroupName -DiskName $PrototypeOSDiskName -Force

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating scale set' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$VmssIpConfigName = $ResourceGroupName + 'VmssIpConfig'
$VmssIpConfig = New-AzVmssIpConfig -SubnetId $Nic.IpConfigurations[0].Subnet.Id -Primary -Name $VmssIpConfigName
$VmssName = $ResourceGroupName + 'Vmss'
$Vmss = New-AzVmssConfig `
  -Location $Location `
  -SkuCapacity 0 `
  -SkuName $VMSize `
  -SkuTier 'Standard' `
  -Overprovision $false `
  -UpgradePolicyMode Manual `
  -EvictionPolicy Delete `
  -Priority Spot `
  -MaxPrice -1

$Vmss = Add-AzVmssNetworkInterfaceConfiguration `
  -VirtualMachineScaleSet $Vmss `
  -Primary $true `
  -IpConfiguration $VmssIpConfig `
  -NetworkSecurityGroupId $NetworkSecurityGroup.Id `
  -Name $NicName

$Vmss = Set-AzVmssOsProfile `
  -VirtualMachineScaleSet $Vmss `
  -ComputerNamePrefix $LiveVMPrefix `
  -AdminUsername 'AdminUser' `
  -AdminPassword $AdminPW `
  -WindowsConfigurationProvisionVMAgent $true `
  -WindowsConfigurationEnableAutomaticUpdate $true

$Vmss = Set-AzVmssStorageProfile `
  -VirtualMachineScaleSet $Vmss `
  -OsDiskCreateOption 'FromImage' `
  -OsDiskCaching ReadWrite `
  -ImageReferenceId $Image.Id

New-AzVmss `
  -ResourceGroupName $ResourceGroupName `
  -Name $VmssName `
  -VirtualMachineScaleSet $Vmss

####################################################################################################
Write-Progress -Activity $ProgressActivity -Completed
Write-Host "Location: $Location"
Write-Host "Resource group name: $ResourceGroupName"
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#

<#
.SYNOPSIS
Prints total and free disk space for each disk on the system
#>

Function Format-Size {
    [CmdletBinding()]
    Param([long]$Size)

    if ($Size -lt 1024) {
        $Size = [int]$Size
        return "$Size B"
    }

    $Size = $Size / 1024
    if ($Size -lt 1024) {
        $Size = [int]$Size
        return "$Size KiB"
    }

    $Size = $Size / 1024
    if ($Size -lt 1024) {
        $Size = [int]$Size
        return "$Size MiB"
    }

# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#

<#
.SYNOPSIS
Runs the 'Test Modified Ports' part of the vcpkg CI system for all platforms.

.PARAMETER Triplet
The triplet to test.

.PARAMETER WorkingRoot
The location used as scratch space for 'installed', 'packages', and 'buildtrees' vcpkg directories.

.PARAMETER ArtifactStagingDirectory
The Azure Pipelines artifacts directory. If not supplied, defaults to the current directory.

.PARAMETER ArchivesRoot
Equivalent to '-BinarySourceStub "files,$ArchivesRoot"'

.PARAMETER UseEnvironmentSasToken
Equivalent to '-BinarySourceStub "x-azblob,https://$($env:PROVISIONED_AZURE_STORAGE_NAME).blob.core.windows.net/archives,$($env:PROVISIONED_AZURE_STORAGE_SAS_TOKEN)"'

.PARAMETER BinarySourceStub
The type and parameters of the binary source. Shared across runs of this script. If
this parameter is not set, binary caching will not be used. Example: "files,W:\"

.PARAMETER BuildReason
The reason Azure Pipelines is running this script (controls in which mode Binary Caching is used).
If BinarySourceStub is not set, this parameter has no effect. If BinarySourceStub is set and this is
not, binary caching will default to read-write mode.
#>

[CmdletBinding(DefaultParameterSetName="ArchivesRoot")]
Param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]$Triplet,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    $WorkingRoot,
    [ValidateNotNullOrEmpty()]
    $ArtifactStagingDirectory = '.',
    [Parameter(ParameterSetName='ArchivesRoot')]
    $ArchivesRoot = $null,
    [switch]
    $UseEnvironmentSasToken = $false,
    [Parameter(ParameterSetName='BinarySourceStub')]
    $BinarySourceStub = $null,
    $BuildReason = $null
)

if (-Not ((Test-Path "triplets/$Triplet.cmake") -or (Test-Path "triplets/community/$Triplet.cmake"))) {
    Write-Error "Incorrect triplet '$Triplet', please supply a valid triplet."
    throw
}

$usingBinaryCaching = $true
if ([string]::IsNullOrWhiteSpace($BinarySourceStub)) {
    if ([string]::IsNullOrWhiteSpace($ArchivesRoot)) {
        if ($UseEnvironmentSasToken) {
            $BinarySourceStub = "x-azblob,https://$($env:PROVISIONED_AZURE_STORAGE_NAME).blob.core.windows.net/archives,$($env:PROVISIONED_AZURE_STORAGE_SAS_TOKEN)"
        } else {
            $usingBinaryCaching = $false
        }
    } else {
        if ($UseEnvironmentSasToken) {
            Write-Error "Only one binary caching setting may be used."
            throw
        } else {
            $BinarySourceStub = "files,$ArchivesRoot"
        }
    }
} elseif ((-Not [string]::IsNullOrWhiteSpace($ArchivesRoot)) -Or $UseEnvironmentSasToken) {
    Write-Error "Only one binary caching setting may be used."
    throw
}

$env:VCPKG_DOWNLOADS = Join-Path $WorkingRoot 'downloads'
$buildtreesRoot = Join-Path $WorkingRoot 'buildtrees'
$installRoot = Join-Path $WorkingRoot 'installed'
$packagesRoot = Join-Path $WorkingRoot 'packages'

$commonArgs = @()
if ($usingBinaryCaching) {
    $commonArgs += @('--binarycaching')
} else {
    $commonArgs += @('--no-binarycaching')
}

$commonArgs += @(
    "--x-buildtrees-root=$buildtreesRoot",
    "--x-install-root=$installRoot",
    "--x-packages-root=$packagesRoot",
    "--overlay-ports=scripts/test_ports"
)

$skipFailures = $false
if ($usingBinaryCaching) {
    $binaryCachingMode = 'readwrite'
    if ([string]::IsNullOrWhiteSpace($BuildReason)) {
        Write-Host 'Build reason not specified, defaulting to using binary caching in read write mode.'
    }
    elseif ($BuildReason -eq 'PullRequest') {
        Write-Host 'Build reason was Pull Request, using binary caching in read write mode, skipping failures.'
        $skipFailures = $true
    }
    else {
        Write-Host "Build reason was $BuildReason, using binary caching in write only mode."
        $binaryCachingMode = 'write'
    }

    $commonArgs += @("--binarysource=clear;$BinarySourceStub,$binaryCachingMode")
}

if ($Triplet -eq 'x64-linux') {
    $env:HOME = '/home/agent'
    $executableExtension = [string]::Empty
}
elseif ($Triplet -eq 'x64-osx') {
    $executableExtension = [string]::Empty
}
else {
    $executableExtension = '.exe'
}

$xmlResults = Join-Path $ArtifactStagingDirectory 'xml-results'
mkdir $xmlResults
$xmlFile = Join-Path $xmlResults "$Triplet.xml"

$failureLogs = Join-Path $ArtifactStagingDirectory 'failure-logs'

& "./vcpkg$executableExtension" x-ci-clean @commonArgs
$skipList = . "$PSScriptRoot/generate-skip-list.ps1" `
    -Triplet $Triplet `
    -BaselineFile "$PSScriptRoot/../ci.baseline.txt" `
    -SkipFailures:$skipFailures

# WORKAROUND: the x86-windows flavors of these are needed for all cross-compilation, but they are not auto-installed.
# Install them so the CI succeeds:
if ($Triplet -in @('x64-uwp', 'arm64-windows', 'arm-uwp')) {
    .\vcpkg.exe install protobuf:x86-windows boost-build:x86-windows sqlite3:x86-windows yasm-tool:x86-windows ampl-mp:x86-windows @commonArgs
} elseif ($Triplet -in @('x64-windows', 'x64-windows-static', 'x64-windows-static-md')) {
    .\vcpkg.exe install yasm-tool:x86-windows @commonArgs
}
[CmdletBinding(PositionalBinding=$False)]
Param(
    [Parameter(Mandatory=$True)]
    [String]$DiffFile
)

Start-Process -FilePath 'git' -ArgumentList 'diff' `
    -NoNewWindow -Wait `
    -RedirectStandardOutput $DiffFile
if (0 -ne (Get-Item -LiteralPath $DiffFile).Length)
{
    $msg = @(
        'The formatting of the files in the repo were not what we expected,',
        'or the documentation was not regenerated.',
        'Please access the diff from format.diff in the build artifacts,'
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: MIT
#

<#
.SYNOPSIS
Creates a Linux virtual machine scale set, set up for vcpkg's CI.

.DESCRIPTION
create-vmss.ps1 creates an Azure Linux VM scale set, set up for vcpkg's CI
system. See https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/overview
for more information.

This script assumes you have installed Azure tools into PowerShell by following the instructions
at https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-3.6.1
or are running from Azure Cloud Shell.

This script assumes you have installed the OpenSSH Client optional Windows component.
#>

$Location = 'westus2'
$Prefix = 'PrLin-' + (Get-Date -Format 'yyyy-MM-dd')
$VMSize = 'Standard_D16a_v4'
$ProtoVMName = 'PROTOTYPE'
$LiveVMPrefix = 'BUILD'
$ErrorActionPreference = 'Stop'

$ProgressActivity = 'Creating Scale Set'
$TotalProgress = 11
$CurrentProgress = 1

Import-Module "$PSScriptRoot/../create-vmss-helpers.psm1" -DisableNameChecking

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating SSH key' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$sshDir = [System.IO.Path]::GetTempPath() + [System.IO.Path]::GetRandomFileName()
mkdir $sshDir
try {
  ssh-keygen.exe -q -b 2048 -t rsa -f "$sshDir/key" -P [string]::Empty
  $sshPublicKey = Get-Content "$sshDir/key.pub"
} finally {
  Remove-Item $sshDir -Recurse -Force
}

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating resource group' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$ResourceGroupName = Find-ResourceGroupName $Prefix
$AdminPW = New-Password
New-AzResourceGroup -Name $ResourceGroupName -Location $Location
$AdminPWSecure = ConvertTo-SecureString $AdminPW -AsPlainText -Force
$Credential = New-Object System.Management.Automation.PSCredential ("AdminUser", $AdminPWSecure)

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating virtual network' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$allFirewallRules = @()

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowHTTP `
  -Description 'Allow HTTP(S)' `
  -Access Allow `
  -Protocol Tcp `
  -Direction Outbound `
  -Priority 1008 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange @(80, 443)

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowSFTP `
  -Description 'Allow (S)FTP' `
  -Access Allow `
  -Protocol Tcp `
  -Direction Outbound `
  -Priority 1009 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange @(21, 22)

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowDNS `
  -Description 'Allow DNS' `
  -Access Allow `
  -Protocol * `
  -Direction Outbound `
  -Priority 1010 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange 53

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name AllowGit `
  -Description 'Allow git' `
  -Access Allow `
  -Protocol Tcp `
  -Direction Outbound `
  -Priority 1011 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange 9418

$allFirewallRules += New-AzNetworkSecurityRuleConfig `
  -Name DenyElse `
  -Description 'Deny everything else' `
  -Access Deny `
  -Protocol * `
  -Direction Outbound `
  -Priority 1013 `
  -SourceAddressPrefix * `
  -SourcePortRange * `
  -DestinationAddressPrefix * `
  -DestinationPortRange *

$NetworkSecurityGroupName = $ResourceGroupName + 'NetworkSecurity'
$NetworkSecurityGroup = New-AzNetworkSecurityGroup `
  -Name $NetworkSecurityGroupName `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -SecurityRules $allFirewallRules

$SubnetName = $ResourceGroupName + 'Subnet'
$Subnet = New-AzVirtualNetworkSubnetConfig `
  -Name $SubnetName `
  -AddressPrefix "10.0.0.0/16" `
  -NetworkSecurityGroup $NetworkSecurityGroup `
  -ServiceEndpoint "Microsoft.Storage"

$VirtualNetworkName = $ResourceGroupName + 'Network'
$VirtualNetwork = New-AzVirtualNetwork `
  -Name $VirtualNetworkName `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -AddressPrefix "10.0.0.0/16" `
  -Subnet $Subnet

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating archives storage account' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$StorageAccountName = Sanitize-Name $ResourceGroupName

New-AzStorageAccount `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -Name $StorageAccountName `
  -SkuName 'Standard_LRS' `
  -Kind StorageV2

$StorageAccountKeys = Get-AzStorageAccountKey `
  -ResourceGroupName $ResourceGroupName `
  -Name $StorageAccountName

$StorageAccountKey = $StorageAccountKeys[0].Value

$StorageContext = New-AzStorageContext `
  -StorageAccountName $StorageAccountName `
  -StorageAccountKey $StorageAccountKey

New-AzStorageContainer -Name archives -Context $StorageContext -Permission Off
$StartTime = [DateTime]::Now
$ExpiryTime = $StartTime.AddMonths(6)

$SasToken = New-AzStorageAccountSASToken `
  -Service Blob `
  -Permission "racwdlup" `
  -Context $StorageContext `
  -StartTime $StartTime `
  -ExpiryTime $ExpiryTime `
  -ResourceType Service,Container,Object `
  -Protocol HttpsOnly

$SasToken = $SasToken.Substring(1) # strip leading ?

# Note that we put the storage account into the firewall after creating the above SAS token or we
# would be denied since the person running this script isn't one of the VMs we're creating here.
Set-AzStorageAccount `
  -ResourceGroupName $ResourceGroupName `
  -AccountName $StorageAccountName `
  -NetworkRuleSet ( `
    @{bypass="AzureServices"; `
    virtualNetworkRules=( `
      @{VirtualNetworkResourceId=$VirtualNetwork.Subnets[0].Id;Action="allow"}); `
    defaultAction="Deny"})

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating prototype VM' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$NicName = $ResourceGroupName + 'NIC'
$Nic = New-AzNetworkInterface `
  -Name $NicName `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -Subnet $VirtualNetwork.Subnets[0]

$VM = New-AzVMConfig -Name $ProtoVMName -VMSize $VMSize -Priority 'Spot' -MaxPrice -1
$VM = Set-AzVMOperatingSystem `
  -VM $VM `
  -Linux `
  -ComputerName $ProtoVMName `
  -Credential $Credential `
  -DisablePasswordAuthentication

$VM = Add-AzVMNetworkInterface -VM $VM -Id $Nic.Id
$VM = Set-AzVMSourceImage `
  -VM $VM `
  -PublisherName 'Canonical' `
  -Offer 'UbuntuServer' `
  -Skus '18.04-LTS' `
  -Version latest

$VM = Set-AzVMBootDiagnostic -VM $VM -Disable

$VM = Add-AzVMSshPublicKey `
  -VM $VM `
  -KeyData $sshPublicKey `
  -Path "/home/AdminUser/.ssh/authorized_keys"

New-AzVm `
  -ResourceGroupName $ResourceGroupName `
  -Location $Location `
  -VM $VM

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Running provisioning script provision-image.sh in VM' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$tempScript = [System.IO.Path]::GetTempPath() + [System.IO.Path]::GetRandomFileName() + ".sh"
try {
  $script = Get-Content "$PSScriptRoot\provision-image.sh" -Encoding utf8NoBOM
  $script += "echo `"PROVISIONED_AZURE_STORAGE_NAME=\`"$StorageAccountName\`"`" | sudo tee -a /etc/environment"
  $script += "echo `"PROVISIONED_AZURE_STORAGE_SAS_TOKEN=\`"$SasToken\`"`" | sudo tee -a /etc/environment"
  Set-Content -Path $tempScript -Value $script -Encoding utf8NoBOM

  $ProvisionImageResult = Invoke-AzVMRunCommand `
    -ResourceGroupName $ResourceGroupName `
    -VMName $ProtoVMName `
    -CommandId 'RunShellScript' `
    -ScriptPath $tempScript

  Write-Host "provision-image.sh output: $($ProvisionImageResult.value.Message)"
} finally {
  Remove-Item $tempScript -Recurse -Force
}

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Restarting VM' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

Restart-AzVM -ResourceGroupName $ResourceGroupName -Name $ProtoVMName

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Converting VM to Image' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

Stop-AzVM `
  -ResourceGroupName $ResourceGroupName `
  -Name $ProtoVMName `
  -Force

Set-AzVM `
  -ResourceGroupName $ResourceGroupName `
  -Name $ProtoVMName `
  -Generalized

$VM = Get-AzVM -ResourceGroupName $ResourceGroupName -Name $ProtoVMName
$PrototypeOSDiskName = $VM.StorageProfile.OsDisk.Name
$ImageConfig = New-AzImageConfig -Location $Location -SourceVirtualMachineId $VM.ID
$Image = New-AzImage -Image $ImageConfig -ImageName $ProtoVMName -ResourceGroupName $ResourceGroupName

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Deleting unused VM and disk' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

Remove-AzVM -Id $VM.ID -Force
Remove-AzDisk -ResourceGroupName $ResourceGroupName -DiskName $PrototypeOSDiskName -Force

####################################################################################################
Write-Progress `
  -Activity $ProgressActivity `
  -Status 'Creating scale set' `
  -PercentComplete (100 / $TotalProgress * $CurrentProgress++)

$VmssIpConfigName = $ResourceGroupName + 'VmssIpConfig'
$VmssIpConfig = New-AzVmssIpConfig -SubnetId $Nic.IpConfigurations[0].Subnet.Id -Primary -Name $VmssIpConfigName
$VmssName = $ResourceGroupName + 'Vmss'
$Vmss = New-AzVmssConfig `
  -Location $Location `
  -SkuCapacity 0 `
  -SkuName $VMSize `
  -SkuTier 'Standard' `
  -Overprovision $false `
  -UpgradePolicyMode Manual `
  -EvictionPolicy Delete `
  -Priority Spot `
  -MaxPrice -1

$Vmss = Add-AzVmssNetworkInterfaceConfiguration `
  -VirtualMachineScaleSet $Vmss `
  -Primary $true `
  -IpConfiguration $VmssIpConfig `
  -NetworkSecurityGroupId $NetworkSecurityGroup.Id `
  -Name $NicName

$VmssPublicKey = New-Object -TypeName 'Microsoft.Azure.Management.Compute.Models.SshPublicKey' `
  -ArgumentList @('/home/AdminUser/.ssh/authorized_keys', $sshPublicKey)

$Vmss = Set-AzVmssOsProfile `
  -VirtualMachineScaleSet $Vmss `
  -ComputerNamePrefix $LiveVMPrefix `
  -AdminUsername AdminUser `
  -AdminPassword $AdminPW `
  -LinuxConfigurationDisablePasswordAuthentication $true `
  -PublicKey @($VmssPublicKey)

$Vmss = Set-AzVmssStorageProfile `
  -VirtualMachineScaleSet $Vmss `
  -OsDiskCreateOption 'FromImage' `
  -OsDiskCaching ReadWrite `
  -ImageReferenceId $Image.Id

New-AzVmss `
  -ResourceGroupName $ResourceGroupName `
  -Name $VmssName `
  -VirtualMachineScaleSet $Vmss

####################################################################################################
Write-Progress -Activity $ProgressActivity -Completed
[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)][string]$ExtractedSources,
    [Parameter(Mandatory=$true)][string]$ManifestIn,
    [Parameter(Mandatory=$true)][string]$ManifestOut,
    [Parameter(Mandatory=$true)][string]$CMakeFragmentFile,
    [Parameter(Mandatory=$false)][string]$vcpkg = "vcpkg"
)

$ErrorActionPreference = "Stop"

$subfolders = Get-Item $ExtractedSources\aws-cpp-sdk-*

$manifest = Get-Content $ManifestIn | ConvertFrom-Json
$manifest | Add-Member -NotePropertyName 'features' -NotePropertyValue @{}

$cmakefragmenttext = @("# Automatically generated by generateFeatures.ps1")

function GetDescription($dir, $modulename)
{
    if (Test-Path "$dir\CMakeLists.txt")
    {
        $descs = @(Select-String -Path "$dir\CMakeLists.txt" -Pattern "`"C\+\+ SDK for the AWS [^`"]*`"")
        if ($descs.count -eq 1) {
            $desc = $descs[0].Matches.Value -replace "`"",""
            "$desc"
        }
        else { "C++ SDK for the AWS $modulename service" }
    }
    else { "C++ SDK for the AWS $modulename service" }
}

foreach ($subfolder in $subfolders)
{
    $modulename = $subfolder.name -replace "^aws-cpp-sdk-",""
    if ($modulename -match "-tests`$") { continue }
    if ($modulename -match "-sample`$") { continue }
    if ($modulename -eq "core") { continue }

    $lowermodulename = $modulename.ToLower()

    $manifest.features.Add("$lowermodulename", @{ description=(GetDescription $subfolder $modulename) })

    $cmakefragmenttext += @(
        "if(`"$lowermodulename`" IN_LIST FEATURES)",
        "  list(APPEND BUILD_ONLY $modulename)",
        "endif()"
    )
}

[IO.File]::WriteAllText($ManifestOut, (ConvertTo-Json -Depth 5 -InputObject $manifest))

Write-Verbose ($cmakefragmenttext -join "`n")
[IO.File]::WriteAllText($CMakeFragmentFile, ($cmakefragmenttext -join "`n") +"`n")

# Note: This function signature and behavior is depended upon by applocal.ps1

function deployOpenNI2([string]$targetBinaryDir, [string]$installedDir, [string]$targetBinaryName) {
    if ($targetBinaryName -like "OpenNI2.dll") {
        if(Test-Path "$installedDir\bin\OpenNI2\OpenNI.ini") {
            Write-Verbose "  Deploying OpenNI2 Initialization"
            deployBinary "$targetBinaryDir" "$installedDir\bin\OpenNI2" "OpenNI.ini"
        }
        if(Test-Path "$installedDir\bin\OpenNI2\Drivers") {
            Write-Verbose "  Deploying OpenNI2 Drivers"
            New-Item "$targetBinaryDir\OpenNI2\Drivers" -ItemType Directory -ErrorAction SilentlyContinue | Out-Null
            Get-ChildItem "$installedDir\bin\OpenNI2\Drivers\*.*" -include "*.dll","*.ini" | % {
                deployBinary "$targetBinaryDir\OpenNI2\Drivers" "$installedDir\bin\OpenNI2\Drivers" $_.Name
            }
        }
# This script is based on the implementation of windeployqt for qt5.7.1
#
# Qt's plugin deployment strategy is that each main Qt Module has a hardcoded
# set of plugin subdirectories. Each of these subdirectories is deployed in
# full if that Module is referenced.
#
# This hardcoded list is found inside qttools\src\windeployqt\main.cpp. For
# updating, inspect the symbols qtModuleEntries and qtModuleForPlugin.

# Note: this function signature and behavior is depended upon by applocal.ps1
function deployPluginsIfQt([string]$targetBinaryDir, [string]$QtPluginsDir, [string]$targetBinaryName) {
    $baseDir = Split-Path $QtPluginsDir -parent
    $binDir = "$baseDir\bin"

    function deployPlugins([string]$pluginSubdirName) {
        if (Test-Path "$QtPluginsDir\$pluginSubdirName") {
            Write-Verbose "  Deploying plugins directory '$pluginSubdirName'"
            New-Item "$targetBinaryDir\plugins\$pluginSubdirName" -ItemType Directory -ErrorAction SilentlyContinue | Out-Null
            Get-ChildItem "$QtPluginsDir\$pluginSubdirName\*.dll" | % {
                deployBinary "$targetBinaryDir\plugins\$pluginSubdirName" "$QtPluginsDir\$pluginSubdirName" $_.Name
                resolve "$targetBinaryDir\plugins\$pluginSubdirName\$($_.Name)"
            }
        } else {
            Write-Verbose "  Skipping plugins directory '$pluginSubdirName': doesn't exist"
        }
    }

    # We detect Qt modules in use via the DLLs themselves. See qtModuleEntries in Qt to find the mapping.
    if ($targetBinaryName -match "Qt5Cored?.dll") {
        if (!(Test-Path "$targetBinaryDir\qt.conf")) {
            "[Paths]" | Out-File -encoding ascii "$targetBinaryDir\qt.conf"
        }
    } elseif ($targetBinaryName -match "Qt5Guid?.dll") {
        Write-Verbose "  Deploying platforms"
        New-Item "$targetBinaryDir\plugins\platforms" -ItemType Directory -ErrorAction SilentlyContinue | Out-Null
        Get-ChildItem "$QtPluginsDir\platforms\qwindows*.dll" | % {
            deployBinary "$targetBinaryDir\plugins\platforms" "$QtPluginsDir\platforms" $_.Name
        }

        deployPlugins "accessible"
        deployPlugins "imageformats"
        deployPlugins "iconengines"
        deployPlugins "platforminputcontexts"
        deployPlugins "styles"
    } elseif ($targetBinaryName -match "Qt5Networkd?.dll") {
        deployPlugins "bearer"
        if (Test-Path "$binDir\libcrypto-1_1-x64.dll")
        {
            deployBinary "$targetBinaryDir" "$binDir" "libcrypto-1_1-x64.dll"
            deployBinary "$targetBinaryDir" "$binDir" "libssl-1_1-x64.dll"
        }
        if (Test-Path "$binDir\libcrypto-1_1.dll")
        {
            deployBinary "$targetBinaryDir" "$binDir" "libcrypto-1_1.dll"
            deployBinary "$targetBinaryDir" "$binDir" "libssl-1_1.dll"
        }
    } elseif ($targetBinaryName -match "Qt5Sqld?.dll") {
        deployPlugins "sqldrivers"
    } elseif ($targetBinaryName -match "Qt5Multimediad?.dll") {
        deployPlugins "audio"
        deployPlugins "mediaservice"
        deployPlugins "playlistformats"
    } elseif ($targetBinaryName -match "Qt5PrintSupportd?.dll") {
        deployPlugins "printsupport"
    } elseif ($targetBinaryName -match "Qt5Qmld?.dll") {
        if(!(Test-Path "$targetBinaryDir\qml"))
        {
            if (Test-Path "$binDir\..\qml") {
                cp -r "$binDir\..\qml" $targetBinaryDir
            } elseif (Test-Path "$binDir\..\..\qml") {
                cp -r "$binDir\..\..\qml" $targetBinaryDir
            } else {
                throw "FAILED"
            }
        }
    } elseif ($targetBinaryName -match "Qt5Quickd?.dll") {
        foreach ($a in @("Qt5QuickControls2", "Qt5QuickControls2d", "Qt5QuickShapes", "Qt5QuickShapesd", "Qt5QuickTemplates2", "Qt5QuickTemplates2d", "Qt5QmlWorkerScript", "Qt5QmlWorkerScriptd", "Qt5QuickParticles", "Qt5QuickParticlesd", "Qt5QuickWidgets", "Qt5QuickWidgetsd"))
        {
            if (Test-Path "$binDir\$a.dll")
            {
                deployBinary "$targetBinaryDir" "$binDir" "$a.dll"
            }
        }
        deployPlugins "scenegraph"
        deployPlugins "qmltooling"
    } elseif ($targetBinaryName -like "Qt5Declarative*.dll") {
        deployPlugins "qml1tooling"
    } elseif ($targetBinaryName -like "Qt5Positioning*.dll") {
        deployPlugins "position"
    } elseif ($targetBinaryName -like "Qt5Location*.dll") {
        deployPlugins "geoservices"
    } elseif ($targetBinaryName -like "Qt5Sensors*.dll") {
        deployPlugins "sensors"
        deployPlugins "sensorgestures"
    } elseif ($targetBinaryName -like "Qt5WebEngineCore*.dll") {
        deployPlugins "qtwebengine"
    } elseif ($targetBinaryName -like "Qt53DRenderer*.dll") {
        deployPlugins "sceneparsers"
    } elseif ($targetBinaryName -like "Qt5TextToSpeech*.dll") {
        deployPlugins "texttospeech"
# Note: This function signature and behavior is depended upon by applocal.ps1

function deployAzureKinectSensorSDK([string]$targetBinaryDir, [string]$installedDir, [string]$targetBinaryName) {
    if ($targetBinaryName -like "k4a.dll") {
        if(Test-Path "$installedDir\tools\azure-kinect-sensor-sdk\depthengine_2_0.dll") {
# Magnum's plugin deployment strategy is that each Magnum module has a hardcoded
# set of plugin directories. Each of these directories is deployed in
# full if that Module is referenced.
#
# Note: this function signature and behavior is depended upon by applocal.ps1
function deployPluginsIfMagnum([string]$targetBinaryDir, [string]$MagnumPluginsDir, [string]$targetBinaryName) {
    Write-Verbose "Deploying magnum plugins"

    $baseDir = Split-Path $MagnumPluginsDir -parent
    $pluginsBase = Split-Path $MagnumPluginsDir -Leaf
    $binDir = "$baseDir\bin"

    function deployPlugins([string]$pluginSubdirName) {
        if (Test-Path "$MagnumPluginsDir\$pluginSubdirName") {
            Write-Verbose "  Deploying plugins directory '$pluginSubdirName'"
            New-Item "$targetBinaryDir\$pluginsBase\$pluginSubdirName" -ItemType Directory -ErrorAction SilentlyContinue | Out-Null
            Get-ChildItem -Path "$MagnumPluginsDir\$pluginSubdirName\*" -Include "*.dll", "*.conf", "*.pdb" | % {
                deployBinary "$targetBinaryDir\$pluginsBase\$pluginSubdirName" "$MagnumPluginsDir\$pluginSubdirName" $_.Name
                resolve $_
            }
        } else {
            Write-Verbose "  Skipping plugins directory '$pluginSubdirName': doesn't exist"
        }
    }

    # We detect Magnum modules in use via the DLLs that contain their
    # plugin interfaces.
    if ($targetBinaryName -like "MagnumAudio.dll" -or $targetBinaryName -like "MagnumAudio-d.dll") {
        deployPlugins "audioimporters"
    } elseif ($targetBinaryName -like "MagnumText.dll" -or $targetBinaryName -like "MagnumText-d.dll") {
        deployPlugins "fonts"
        deployPlugins "fontconverters"
    } elseif ($targetBinaryName -like "MagnumTrade.dll" -or $targetBinaryName -like "MagnumTrade-d.dll") {
        deployPlugins "importers"
        deployPlugins "imageconverters"
#! /usr/bin/env pwsh

[CmdletBinding()]
Param(
    [String]$VcpkgRoot = ''
)

if ([String]::IsNullOrEmpty($VcpkgRoot)) {
    $VcpkgRoot = "${PSScriptRoot}/.."
}

$VcpkgRoot = Resolve-Path $VcpkgRoot

if (-not (Test-Path "$VcpkgRoot/.vcpkg-root")) {
    throw "Invalid vcpkg instance, did you forget -VcpkgRoot?"
}

$tableOfContents = @()
$internalTableOfContents = @()

function WriteFile
{
    Param(
        [String[]]$Value,
        [String]$Path
    )
    # note that we use this method of getting the utf-8 bytes in order to:
    #  - have no final `r`n, which happens when Set-Content does the thing automatically on Windows
    #  - have no BOM, which happens when one uses [System.Text.Encoding]::UTF8
    [byte[]]$ValueAsBytes = (New-Object -TypeName 'System.Text.UTF8Encoding').GetBytes($Value -join "`n")
    Set-Content -Path $Path -Value $ValueAsBytes -AsByteStream
}
function FinalDocFile
{
    Param(
        [String[]]$Value,
        [String]$Name
    )
    $Value + @(
        "",
        "## Source",
        "[scripts/cmake/$Name](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/$Name)",
        ""
    )
}

Get-ChildItem "$VcpkgRoot/scripts/cmake" -Filter '*.cmake' | ForEach-Object {
    $filename = $_
    [String[]]$contents = Get-Content $filename

    if ($contents[0] -eq '# DEPRECATED') {
        return
    }

    [String]$startCommentRegex = '#\[(=*)\['
    [String]$endCommentRegex = ''
    [Bool]$inComment = $False
    [Bool]$failThisFile = $False
    [Bool]$isInternalFunction = $filename.Name.StartsWith("vcpkg_internal") -or $filename.Name.StartsWith("z_vcpkg")

    $contents = $contents | ForEach-Object {
        if (-not $inComment) {
            if ($_ -match "^\s*${startCommentRegex}(\.[a-z]*)?:?\s*$") {
                if (-not [String]::IsNullOrEmpty($matches[2]) -and $matches[2] -ne '.md') {
                    Write-Warning "The documentation in ${filename} doesn't seem to be markdown (extension: $($matches[2])). Only markdown is supported; please rewrite the documentation in markdown."
                }
                $inComment = $True
                $endCommentRegex = "\]$($matches[1])\]"
            } elseif ($_ -match $startCommentRegex) {
                $failThisFile = $True
                Write-Warning "Invalid start of comment -- the comment start must be at the beginning of the line.
    (on line: `"$_`")"
            } else {
                # do nothing -- we're outside a comment, so cmake code
            }
        } else {
            if ($_ -match "^\s*#?${endCommentRegex}\s*$") {
                $inComment = $False
                $endCommentRegex = ''
            } elseif ($_ -match $endCommentRegex) {
                $failThisFile = $True
                Write-Warning "Invalid end of comment -- the comment end must be on it's own on a line.
    (on line: `"$_`")"
            } else {
                # regular documentation line
                $_
            }
        }
    }

    if ($inComment) {
        Write-Warning "File ${filename} has an unclosed comment."
        return
    }

    if ($failThisFile) {
        return
    }


    if ($contents) {
        if ($isInternalFunction) {
            WriteFile `
                -Path "$PSScriptRoot/maintainers/internal/$($filename.BaseName).md" `
                -Value (FinalDocFile $contents $filename.Name)

            $internalTableOfContents += $filename.BaseName
        } else {
            WriteFile `
                -Path "$PSScriptRoot/maintainers/$($filename.BaseName).md" `
                -Value (FinalDocFile $contents $filename.Name)

            $tableOfContents += $filename.BaseName
        }
    } elseif (-not $isInternalFunction) {
        # don't worry about undocumented internal functions
        Write-Warning "The cmake function in file $filename doesn't seem to have any documentation. Make sure the documentation comments are correctly written."
    }
}

$portfileFunctionsContent = @(
    '<!-- Run regenerate.ps1 to extract documentation from scripts/cmake/*.cmake -->',
    '',
    '# Portfile helper functions')

$tableOfContents | Sort-Object -Culture '' | ForEach-Object {
    $portfileFunctionsContent += "- [$($_ -replace '_','\_')]($_.md)"
}
$portfileFunctionsContent += @("", "## Internal Functions", "")
$internalTableOfContents | Sort-Object -Culture '' | ForEach-Object {
    $portfileFunctionsContent += "- [$($_ -replace '_','\_')](internal/$_.md)"
}
$portfileFunctionsContent += "" # final newline

WriteFile `
# ==============================================================================
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root
# for full license information.
# ==============================================================================
[CmdletBinding()]
Param([Parameter(Mandatory=$true)] [string]$PyVersion, [string]$WheelBaseUrl)

$ErrorActionPreference = 'Stop'
$ProgressPreference = 'SilentlyContinue'

Set-Location c:\local
Expand-Archive -Path BinaryDrop.zip

$installCache = '.\BinaryDrop\cntk\Scripts\install\windows\ps\InstallCache'
Move-Item -Path InstallCache -Destination $installCache

Get-ChildItem .\BinaryDrop\cntk\Scripts\install\windows\ps\ -Recurse -File -Include *.ps1, *.psm1 |
  Add-Content -Stream Zone.Identifier -Value "[ZoneTransfer]`r`nZoneId=3`r`n"

.\BinaryDrop\cntk\Scripts\install\windows\install.bat -NoConfirm -Verbose @PSBoundParameters
if ($LASTEXITCODE -ne 0) {
  throw "Fail"
}

# ==============================================================================
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root
# for full license information.
# ==============================================================================
[CmdletBinding()]
Param([Parameter(Mandatory=$true)] [string]$PyVersion, [string]$WheelBaseUrl)

$image = 'cntk:installtest'

$serverInfo = docker version --format '{{json .Server}}' | ConvertFrom-Json
if ($LASTEXITCODE -ne 0) {
  throw "Fail"
}

$expectedOsArch = 'windows/amd64'
if (("{0}/{1}" -f $serverInfo.Os, $serverInfo.Arch) -ne $expectedOsArch) {
  throw "docker server OS/Arch is different from $expectedOsArch. Make sure to switch to Windows Containers."
}

docker build -t $image .
if ($LASTEXITCODE -ne 0) {
  throw "Fail"
}
docker run --rm -e TEST_TAG=$env:TEST_TAG $image powershell c:/local/test-install.ps1 @PSBoundParameters
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function VerifyOperations(
    [bool] $NoConfirm)
{
    Write-Host "Determining Operations to perform. This will take a moment..."

    foreach ($item in $operations) {
        $needsInstall = $false

        foreach ($verificationItem in $item.Verification) {
            
            $needsInstall = VerifyItem $verificationItem
            if (-not $needsInstall) {
                $Script:operationList += $item
                break
            }
        }
    }

    Write-Host 

    if ($Script:operationList.Count -gt 0) {
        Write-Host "The following operations will be performed:"

        foreach ($item in $Script:operationList) {
            $info = $item.Info
            Write-Host " * $info"
        }
        if ($NoConfirm) {
            return $true
        }
        Write-Host 
        Write-Host "Do you want to continue? (y/n)"
        
        $choice = GetKey '^[yYnN]+$'

        if ($choice -contains "y") {
            return $true
        }
    }
    else {
        Write-Host "No additional installation required"
    }
    return $false
}

function VerifyItem(
    [hashtable] $item)
{
    $func = $item["Function"]
    $name = $item["Name"]

    $expr = $func +' $item' 
        
    Write-Verbose "Calling Operation: [$func]: [$name]"
    $noInstallRequired = Invoke-Expression $expr 

    return $noInstallRequired
}

function VerifyScanPrograms(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $noInstallRequired = $true
    
    # no actual work is being performed, just the script local datastructure with the list
    # of installed programs is being initialized
    LoadWinProduct
    return $noInstallRequired
}

function VerifyWinProductExists(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $match = $table["Match"]
    $noInstallRequired = $true

    $allProducts = LoadWinProduct
    $productList = @($allProducts | Where-Object { $_.Name -match $match } )
    
    if ($productList.Count -eq 0) {
        $noInstallRequired = $false
    }

    Write-Verbose "[$func]: Product [$match] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyWinProductVersion(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $match = $table["Match"]
    $version = $table["Version"]
    $noInstallRequired = $true

    $allProducts = LoadWinProduct
    $productList = @($allProducts | Where-Object { $_.Name -match $match } )

    if ($productList.Count -eq 0) {
        Write-Verbose "No product found with Name matching [$match]"
        $noInstallRequired = $false
    }
    else {
        $productList = @($productList | Where-Object { $_.Version -lt $version })
        if ($productList.Count -gt 0) {
            Write-Verbose "Products with earlier versions found`n$productList"
            $noInstallRequired = $false
        }
    }

    Write-Verbose "[$func]: Product [$match] Version {$version] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyDirectory(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $path = $table["Path"]

    $noInstallRequired = (test-path -path $path -PathType Container)

    Write-Verbose "[$func]: [$path] returned [$noInstallRequired]"
    
    return $noInstallRequired
}

function VerifyRunAlways(
	[Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]

    $noInstallRequired = $false
    Write-Verbose "[$func]: returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyFile(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $path = $table["Path"]

    $noInstallRequired = (test-path -path $path -PathType Leaf)

    Write-Verbose "[$func]: [$path] returned [$noInstallRequired]"
    
    return $noInstallRequired
}

function VerifyRegistryKey(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $key = $table["Key"]

    $noInstallRequired = (test-path -path $key)

    Write-Verbose "[$func]: [$key] returned [$noInstallRequired]"
    
    return $noInstallRequired
}

function VerifyRegistryKeyName(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func     = $table["Function"]
    $key      = $table["Key"]
    $regName  = $table["RegName"]

    $noInstallRequired = Test-ItemProperty -Path $key -Name $regName

    Write-Verbose "[$func]: [$key]:[$regname] returned [$noInstallRequired]"
    
    return $noInstallRequired
}

function VerifyRegistryKeyNameData(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func     = $table["Function"]
    $key      = $table["Key"]
    $regName  = $table["RegName"]
    $regData  = $table["RegData"]

    $noInstallRequired = (test-path -path $key)

    if ($noInstallRequired) {
        $theKeyObj = get-item $key
        $noInstallRequired = ($theKeyObj.GetValue("$regName") -eq $regData)
    }

    Write-Verbose "[$func]: [$key]:[$regname] == [$regData] returned [$noInstallRequired]"
    return $noInstallRequired
}

function Test-ItemProperty (
    [string] $Path, 
    [string] $Name)
{
    if (Test-Path $Path) {
        try {
            $ItemProperty = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue
            if ( $ItemProperty -ne $null ) {
                return $true 
            }
        }
        catch {
            return $false
        }
    }
    return $false
}

function LoadWinProduct
{
    if (-not $Script:WinProduct) {
        # 
        # $Script:WinProduct = Get-WmiObject Win32_Product
        # The above line was the previous solution, but iterating through the registry is much faster
        # get-wmiobject does more house-holding, like checking for consistency etc ...
        # 
        $allInstalled = @(Get-ChildItem "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" -ErrorAction SilentlyContinue) + 
                        @(Get-ChildItem "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" -ErrorAction SilentlyContinue) + 
                        @(get-ChildItem "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\" -ErrorAction SilentlyContinue)

        $result = @()
        foreach ($item in $allInstalled) {
            $displayName = $item.GetValue("DisplayName")
            if ($displayName) {
                $entry = New-Object PSObject
                $entry | Add-Member -MemberType NoteProperty -Name "Name" -Value $displayName
                $entry | Add-Member -MemberType NoteProperty -Name "Version" -Value $($item.GetValue("DisplayVersion"))
                
                $result += $entry
            }

        } 
        $result = $result | Sort-Object Name,Version -Unique

#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function FunctionIntro(
    [Parameter(Mandatory = $true)][hashtable] $table) {
    $table | Out-String | Write-Verbose
}

function GetKey(
    [string] $validChar) {
    do {
        $key = Read-Host
    } until ($key -match $validChar)

    return $key
}

function DisplayStartMessage {
"

This script will setup CNTK, the CNTK prerequisites and the CNTK Python environment onto the system.
More help can be found at: 
  https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-Windows-Binary-Script

The script will analyse your machine and will determine which components are required. 
The required components will be downloaded in [$localCache]
Repeated operation of this script will reuse already downloaded components.

 - If required VS2017 Runtime will be installed
 - If required MSMPI will be installed
 - Anaconda3 will be installed into [$AnacondaBasePath]
 - A CNTK-PY$PyVersion environment will be created or updated in [$AnacondaBasePath\envs]
 - CNTK will be installed or updated in the CNTK-PY$PyVersion environment
"
}

function Display64BitWarningMessage {
    "
A 64bit version of Powershell is required to run this script.
Please make sure you started this installation from a 64bit command process.
"
}

function DisplayVersionWarningMessage(
    [string] $version) {
    "
You are executing this script from Powershell Version $version.
We recommend that you execute the script from Powershell Version 4 or later. You can install Powershell Version 4 from:
    https://www.microsoft.com/en-us/download/details.aspx?id=40855
"
}

function DisplayWarningNoExecuteMessage {
    "
The parameter '-Execute:$false' has been supplied to the script.
The script will execute without making any actual changes to the machine.
"
}

function DisplayStartContinueMessage {
    "
1 - I agree and want to continue
Q - Quit the installation process
"
}

function CheckPowershellVersion {
    $psVersion = $PSVersionTable.PSVersion.Major
    if ($psVersion -ge 4) {
        return $true
    }

    Write-Host $(DisplayVersionWarningMessage $psVersion)
    if ($psVersion -eq 3) {
        return $true
    }
    return $false
}

function CheckOSVersion {
    $runningOn = (Get-WmiObject -class Win32_OperatingSystem).Caption
    $isMatching = ($runningOn -match "^Microsoft Windows (8\.1|10|Server 2012 R2|Server 2016)") 
    if ($isMatching) {
        return
    }

    Write-Warning "
You are running this script on [$runningOn].
The Microsoft Cognitive Toolkit is designed and tested on Windows 8.1, Windows 10, 
Windows Server 2012 R2, and Windows Server 2016.
"
    return
}

function Check64BitProcess {
    if ([System.Environment]::Is64BitProcess) {
        return $true
    }

    Write-Warning $(Display64BitWarningMessage)
    return $false
}

function DisplayStart(
    [bool] $NoConfirm) {
    Write-Host $(DisplayStartMessage)
    if (-not (Check64BitProcess)) {
        return $false
    }
    if (-not (CheckPowershellVersion)) {
        return $false
    }

    CheckOSVersion

    if (-not $Execute) {
        Write-Warning $(DisplayWarningNoExecuteMessage)
    }
    if ($NoConfirm) {
        return $true
    }
    Write-Host $(DisplayStartContinueMessage)
    $choice = GetKey '^[1qQ]+$'

    if ($choice -contains "1") {
        return $true
    }

    return $false
}

Function DisplayEnd() {
    if (-not $Execute) { return }

    Write-Host "

CNTK v2 Python install complete.

To activate the CNTK Python environment and set the PATH to include CNTK, start a command shell and run
   $cntkRootDir\scripts\cntkpy$PyVersion.bat

Please checkout tutorials and examples here:
   $cntkRootDir\Tutorials
   $cntkRootDir\Examples
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#

<#
  .SYNOPSIS
 Use this cmdlet to install CNTK from a precompiled binary drop (see https://github.com/Microsoft/CNTK/releases)

 By default the script will:

 - Create or reuse Anaconda3 in the folder `C:\local\Anaconda3-4.3.1-Windows-x86_64`
 - Create or update a CNTK Python 3.5 environment in `C:\local\Anaconda3-4.3.1-Windows-x86_64\envs\cntk-py35`

 .DESCRIPTION
 The script will download and install the CNTK prerequisites and Anaconda environment.

 It will analyse your machine and will determine which components are required. 
 The required components will be downloaded and cached.
 Repeated operation of this script will reuse already downloaded components.

 - If required VS2017 Runtime will be installed
 - If required MSMPI will be installed
 - Anaconda3 will be installed into [<AnacondaBasePath>]
 - A CNTK-PY<version> environment will be created or updated in [<AnacondaBasePath>\envs]
 - CNTK will be installed or updated in the CNTK-PY<version> environment
 
  .PARAMETER Execute
 You can set this switch to 'false' to prevent Install from performing any physical changes to the machine.

 .PARAMETER NoConfirm
 If you supply this optional parameter, the install script will execute operations without asking for user confirmation.

 .PARAMETER AnacondaBasePath
 This optional parameter allows you to specify the location of an Anaconda installation to be used or created on your 
 machine. If the directory exists on your machine, the script will continue under the assumption that this is a working 
 Anaconda 3 (4.3.1) (or compatible) installation, and will create the CNTK Python environment in that location.
 By default a version of Anaconda3 will be installed into [C:\local\Anaconda3-4.3.1-Windows-x86_64]

 .PARAMETER PyVersion
 This is an optional parameter and can be used to specify the Python version used in the CNTK Python environment.
 Supported values for this parameter are 27, 35, or 36. The default values is 35 (for a CNTK Python 35 environment).

  .PARAMETER WheelBaseUrl
 This is an internal test-only parameter and should be ignored.

.EXAMPLE
 .\install.ps1
 
 Run the installer and perform the installation operations
.EXAMPLE
 .\install.ps1 -Execute:$false
 
 Run the installer and see what operations would be performed, without actually performing these actions
.EXAMPLE
 .\install.ps1 -Execute -AnacondaBasePath d:\cntkBeta

 This will install Anaconda in the [d:\cntkBeta] directory.
#>

[CmdletBinding()]
Param(
    [Parameter(Mandatory=$false)] [string] $AnacondaBasePath = "C:\local\Anaconda3-4.3.1-Windows-x86_64",
    [Parameter(Mandatory=$false)] [ValidateSet("27", "35", "36")] [string] $PyVersion = "35",
    [Parameter(Mandatory=$false)] [switch] $Execute = $true,
    [Parameter(Mandatory=$false)] [switch] $NoConfirm,
    [Parameter(Mandatory=$false)] [string] $WheelBaseUrl = "https://cntk.ai/PythonWheel")

Set-StrictMode -Version latest

Import-Module Download -ErrorAction Stop

$MyDir = Split-Path $MyInvocation.MyCommand.Definition
$ymlDir = Split-Path $MyDir
$cntkRootDir = Split-Path $MyDir | Split-Path | Split-Path | Split-Path

$roboCopyCmd    = "C:\Windows\System32\robocopy.exe"
$localCache     = "$MyDir\InstallCache"

. "$MyDir\_operations"
. "$MyDir\_verify"
. "$MyDir\_download"
. "$MyDir\_info"
. "$MyDir\_action"

function VerifyInstallationContent(
    [Parameter(Mandatory=$true)][string] $path)
{
    $structureCorrect = (join-path $path cntk\cntk.exe | test-path -PathType Leaf) 
    $structureCorrect = (join-path $path prerequisites\VS2017\vc_redist.x64.exe | test-path -PathType Leaf) -and $structureCorrect
    $structureCorrect = (join-path $path version.txt | test-path -PathType Leaf) -and $structureCorrect
    
    Write-Verbose "[VerifyInstallationContent]: [$path] result [$structureCorrect]"

    if (-not $structureCorrect) {
        throw "`nFatal Error: Files from the CNTK binary download package are missing!`nThe install script must be run out of the unpacked binary CNTK package. For help see: https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-Windows-Binary-Script"
    }
}

function WhlFileInfoFromVersionFile(
    [Parameter(Mandatory=$true)][string] $path,
    [Parameter(Mandatory=$true)][string] $pyVersion,
    [string] $wheelBaseUrl)
{
    $versionFile = Join-Path $path version.txt

    try {
        $reader = [System.IO.File]::OpenText($versionFile)
        $cntkVersion = $reader.ReadLine()       # cntk-*-*-xxxx*-*
        $cntkConfig = $reader.ReadLine()        # Debug, Release, ...
        $cntkTarget = $reader.ReadLine()        # CPU-Only, GPU, ...

        if ((-not $cntkVersion) -or (-not $cntkConfig) -or (-not $cntkTarget) -or (-not ($cntkVersion -match "^cntk"))) {
            throw "`nFatal Error: Malformed version information in [$versionFile]."
        }
        $cntkVersion = $cntkVersion -replace "-", "."
        $cntkVersion = $cntkVersion -replace ".rc", "rc"
        if ($cntkTarget -eq "GPU") {
            $cntkVersion = $cntkVersion -replace "^cntk\.", "cntk_gpu-"
        } else {
            $cntkVersion = $cntkVersion -replace "^cntk\.", "cntk-"
        }

        if ($wheelBaseUrl.StartsWith('http')) {
            $cntkUrl = "{0}/{1}" -f $wheelBaseUrl, $cntkTarget
        } else {
            $cntkUrl = "{0}\{1}" -f $wheelBaseUrl, $cntkTarget
        }
        return @{ Name = "{0}-cp{1}-cp{2}m-win_amd64.whl" -f $cntkVersion, $pyVersion, $pyVersion; CntkUrl = $cntkUrl }
    }
    finally {
        $reader.close()
    }
}

function Get-WheelUrl(
    [Parameter(Mandatory=$true)][string] $path,
    [Parameter(Mandatory=$true)][string] $pyVersion,
    [string] $WheelBaseUrl)
{
    # if a local wheel exists in the $path\cntk\Python directory, we will pip install this wheel
    # if the file doesn't exist we will pip install the wheel in the specified url/path
    # If $WheelBaseUrl starts with http[s], it is treated as URL and as a local path otherwise

    $whlFileInfo = WhlFileInfoFromVersionFile -path $path -pyVersion $pyVersion -wheelBaseUrl $WheelBaseUrl

    $whlPath = Join-Path $path cntk\Python
    $whlFile = Join-Path $whlPath $whlFileInfo.Name

    if (Test-Path $whlFile) {
        return $whlFile
    }

    if ($whlFileInfo.CntkUrl.StartsWith('http')) {
        $cntkURL = "{0}/{1}" -f $whlFileInfo.CntkUrl, $whlFileInfo.Name
    } else {
        $cntkURL = "{0}\{1}" -f $whlFileInfo.CntkUrl, $whlFileInfo.Name
    }
    return $cntkURL
}

Function main
{
    try {
        if (-not (DisplayStart -NoConfirm $NoConfirm)) {
            Write-Host  
            Write-Host " ... Quitting ... "
            Write-Host
            return
        }

        #check we are running inside the unpacked distribution content
        VerifyInstallationContent $cntkRootDir

        $whlUrl = Get-WheelUrl -path $cntkRootDir -pyVersion $PyVersion -wheelBaseUrl $WheelBaseUrl

        if(-not (Test-Path -Path $localCache)) {
            new-item -Path $localcache -ItemType Container | Out-Null
        }

        $operations = Set-OperationsInfo -whlUrl $whlUrl 
        $Script:operationList  = @()
        $Script:WinProduct = $null
        if (VerifyOperations -NoConfirm $NoConfirm) {

            DownloadOperations
            
            ActionOperations

            DisplayEnd
        }
    }
    catch {
        Write-Host `nFatal error during script execution!`n($Error[0]).Exception`n
        exit 1
    }
}

main

#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#

Import-Module Disk -ErrorAction Stop

Set-StrictMode -Version Latest

function DownloadFileWebRequest (
    [Parameter(Mandatory=$True)][string] $SourceFile,
    [Parameter(Mandatory=$True)][string] $OutFile)
{
    try {
        $response = Invoke-WebRequest -Uri $SourceFile -OutFile $OutFile -UserAgent Firefox -TimeoutSec 120 
        return $true
    } 
    catch {
      Write-Verbose "DownloadFileWebRequest failed: $_.Exception.Response.StatusCode.Value__"
      Remove-Item -Path $OutFile -Force -ErrorAction SilentlyContinue
      return $false
    }
}

function DownloadFileWebClient(
    [Parameter(Mandatory=$True)][string] $SourceFile,
    [Parameter(Mandatory=$True)][string] $OutFile)
{
    try {
        (New-Object System.Net.WebClient).DownloadFile($SourceFile, $OutFile) 
        return $true
    } 
    catch {
      Write-Verbose "$_.Exception"
      if ($_.Exception.InnerException) {
          Write-Verbose ("Inner exception: {0}" -f $_.Exception.InnerException)
          if ($_.Exception.InnerException.InnerException) {
              Write-Verbose ("Inner inner exception: {0}" -f $_.Exception.InnerException.InnerException)
          }
      }

      Remove-Item -Path $OutFile -Force -ErrorAction SilentlyContinue
      return $false
    }
}

function Get-FileFromLocation(
    [Parameter(Mandatory=$True)][string] $SourceFile,
    [Parameter(Mandatory=$True)][string] $OutFile,
    [switch] $WebClient,
    [int] $Maxtry = 5,
    [int] $TryDelaySeconds = 60)
{
    $targetDir = Split-Path $OutFile
    if (-not (Test-Path -Path $targetDir -PathType Container)) {
        # if we can't create the target directory, we will stop
        New-Item -ItemType Directory -Force -Path $targetDir -ErrorAction Stop
    }
    if (Test-Path -Path $OutFile) {
        # Outfile already exists
        Write-Verbose "Get-FileFromLocation: Success. [$OutFile] already exists."
        return $true
    }
    $workFile = Get-TempFileName -filePrefix FromLocation -tempDir $targetDir

    try {
        for ($count = 1; $count -le $Maxtry; $count++) {
            Write-Verbose "Copy-FileWeb: Iteration [$count] of [$maxtry]"
            if ($count -gt 1) {
                Start-Sleep -Seconds $TryDelaySeconds
            }
            if ($WebClient) {
                $result = DownloadFileWebClient -SourceFile $SourceFile -OutFile $workFile
            }
            else {
                $result = DownloadFileWebRequest -SourceFile $SourceFile -OutFile $workFile
            }
            if ($result) {
                Rename-Item $workFile $OutFile -Force -ErrorAction Stop | Out-Null
                return $true
            }
        }
        Write-Verbose "Get-FileFromLocation: Failed"
        return $false
    }
    finally {
        Remove-Item $workfile -Force -ErrorAction SilentlyContinue
    }
}
        
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#

Set-StrictMode -Version Latest

function Get-FreeDiskSpaceGB(
    [Parameter(Mandatory=$True)][string] $driveLetter)
{
    try {
        if ($driveLetter.Length -eq 1) {
            $driveLetter += ":"
        }
        $targetDisk = Split-Path $driveLetter -Qualifier

        $disks = Get-WmiObject win32_Volume
        $disk = $disks | Where-Object { $_.DriveLetter -eq $targetDisk }

        return [int] ($disk.FreeSpace / 1GB)
    }
    catch {
        return [int] 0
    }
}

function Compress-CacheDirectory(
    [Parameter(Mandatory=$True)][string] $directory,
    [int] $maxCount = 48,
    [int] $minFreeDiskSpaceGB = 16,
    [string] $filter = "*.*",
    [switch] $isContainer)
{
    try {
        $selection = @(Get-ChildItem -path $directory -filter $filter | Where-Object { $_.PSIsContainer -eq $isContainer })
        $fileCount = $selection.Count

        if ($fileCount -gt 0) {
            $freeSpaceGB = Get-FreeDiskSpaceGB -driveLetter (Split-Path $directory -Qualifier)
            
    
            if (($fileCount -gt $maxCount) -or ($freeSpaceGB -lt $minFreeDiskSpaceGB)){
                $toSkip = $fileCount - 4
                if ($toSkip -lt 1) {
                    $toSkip = 1
                }
                # TODO: this is not concurrency safe. Another job could use a directory we are trying to remove ...
                $selection | Sort-Object LastWriteTime -Descending | Select-Object -Skip $toSkip | Remove-Item -Recurse -ErrorAction SilentlyContinue
            }
        }
    }
    catch {
        # suppress all errors
    }
}

function Get-TempFileName(
    [string] $filePrefix,
    [string] $tempDir = "")
{
    if (-not $tempDir) {
        $tempDir = [System.IO.Path]::GetTempPath()
    }
    if ($filePrefix) {
        $fileName = [io.path]::GetFileNameWithoutExtension($filePrefix)
    }
    else {
        $fileName = [string]::Empty
    }
    $fileName += ([GUID]::NewGuid()).Guid
    return Join-Path $tempDir $filename
}

function Update-FileLastWriteTime(
    [Parameter(Mandatory=$True)][string] $fileName)
{
    Set-ItemProperty -Path $fileName -Name LastWriteTime -Value (Get-Date) -ErrorAction SilentlyContinue
}

Export-ModuleMember -Function (Write-Output `
    Get-FreeDiskSpaceGB `
    Compress-CacheDirectory `
    Get-TempFileName `
    Update-FileLastWriteTime )

#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#

function DownloadOperations()
{
    Write-Host "Performing download operations"

    foreach ($item in $Script:operationList) {
        foreach ($downloadItem in $item.Download) {
            DownloadItem $downloadItem
        }
    }

    Write-Host "Download operations finished"
    Write-Host
}


function DownloadItem(
    [hashtable] $item)
{
    $func = $item["Function"]

    $expr = $func +' $item' 
        
    Write-Verbose "Calling Operation: [$func]"
    Invoke-Expression $expr 
}


function Download(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $source = $table["Source"]
    $destination = $table["Destination"]

    $downloadOk = Get-FileFromLocation -SourceFile $source -OutFile $destination -Maxtry 2

    if (-not $downloadOk) {
        throw "Download $SourceFile Failed!"
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#

function ActionOperations()
{
    Write-Host "Performing install operations"

    foreach ($item in $Script:operationList) {
        
        foreach ($actionItem in $item.Action) {
            ActionItem $actionItem
        }
    }

    Write-Host "Install operations finished"
    Write-Host
}

function ActionItem(
    [hashtable] $item)
{
    $func = $item["Function"]

    $expr = $func +' $item' 
        
    Write-Verbose "Calling Operation: [$func]"
    Invoke-Expression $expr 
}


function InstallExe(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $cmd  = $table["Command"]
    $param= $table["Param"]
    $dir  = $table["WorkDir"]
    $platform = $table["Platform"]
    $processWait = $table["ProcessWait"]
    $message =  $table["message"]
    $runAs = $table["runAs"]
    $maxErrorLevel = $table["maxErrorLevel"]

    if ($runAs -eq $null) {
        $runAs = $true
    }
    if ($maxErrorLevel -eq $null) {
        $maxErrorLevel = 0
    }
    if ($platform -ne $null) {
        $runningOn = ((Get-WmiObject -class Win32_OperatingSystem).Caption).ToUpper()
        $platform  = ($platform.ToString()).ToUpper()

        if (-not $runningOn.StartsWith($platform)) {
            return
        }
    }

    if ($message -ne $null) {
        Write-Host $message
    }
    
    if ($dir -eq $null) {
        DoProcess -command $cmd -param $param -requiresRunAs $runAs -maxErrorLevel $maxErrorLevel
    }
    else {
        DoProcess -command $cmd -param $param -requiresRunAs $runAs -workingDir $dir -maxErrorLevel $maxErrorLevel
    }
    
    if ( ($processWait -ne $null) -and ($Execute) -and ($false) ) {
        do {
            start-sleep 20
            $pwait = Get-Process $processWait -ErrorAction SilentlyContinue
        } while (-not ($pwait -eq $null))
    }
}

function InstallYml(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $basePath  = $table["BasePath"]
    $env= $table["Env"]
    $ymlFile  = $table["ymlFile"]

    $envsDir = Join-Path $basePath envs
    $targetDir = Join-Path $envsDir $env

    $newTable = @{ Function = "InstallExe"; Command = "$basepath\Scripts\conda.exe"; Param = "update conda -y"; WorkDir = "$basePath\Scripts"; runAs=$false }
    InstallExe $newTable

    if (test-path -path $targetDir -PathType Container) {
        $newTable = @{ Function = "InstallExe"; Command = "$basepath\Scripts\conda.exe"; Param = "env update --file `"$ymlFile`" --name `"$targetDir`""; WorkDir = "$basePath\Scripts"; runAs=$false }
    }
    else {
        $newTable = @{ Function = "InstallExe"; Command = "$basepath\Scripts\conda.exe"; Param = "env create --file `"$ymlFile`" --prefix `"$targetDir`""; WorkDir = "$basePath\Scripts"; runAs=$false }
    }

    InstallExe $newTable
}

function ExecuteApplication(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $appName = $table["AppName"]
    $param= $table["Param"]
    $appDir = $table["AppDir"]
    $usePath = $table["UseEnvPath"]
    $dir  = $table["WorkDir"]
    $maxErrorLevel = $table["maxErrorLevel"]

    if ($appDir -eq $null) {
        $appDir = ""
    }
    if ($usePath -eq $null) {
        $usePath = $false
    }
    if ($maxErrorLevel -eq $null) {
        $maxErrorLevel = 0
    }

    if ($Execute) {
        $application = ResolveApplicationName -name $appName -directory $appDir -usePath $usePath
        if (-not $application) {
            throw "ExecuteApplication: Couldn't resolve program [$appName] with location directory [$appDir] and usePath [$usePath]"
        }

        if ($dir -eq $null) {
            DoProcess -command $application -param $param -maxErrorLevel $maxErrorLevel
        }
        else {
            DoProcess -command $application -param $param -workingDir $dir -maxErrorLevel $maxErrorLevel
        }
    }
}

function InstallWheel(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $BasePath     = $table["BasePath"]
    $EnvName      = $table["EnvName"]
    $message      = $table["message"]
    $whl = $table["whlUrl"]

    Write-Host $message
    if (-not $Execute) {
         Write-Host  "** Running in DEMOMODE - setting Exit Code **: 0"
         return 
    }
    $condaExe = Join-Path $BasePath 'Scripts\conda.exe'
    $newPaths = Invoke-DosCommand $condaExe (Write-Output ..activate cmd.exe $EnvName)  -maxErrorLevel 0

    $oldPath = $env:PATH
    $env:PATH = $newPaths + ';' + $env:PATH

    Invoke-DosCommand pip (Write-Output install $whl) -maxErrorLevel 0
    $env:PATH = $oldPath 
    return
}

function MakeDirectory(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $path = $table["Path"]

    if (-not (test-path -path $path)) {
        if ($Execute) {
            New-Item $path -type directory
        }
    }
}

function AddToPath(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func    = $table["Function"]
    $dir     = $table["Dir"]
    $atStart = $table["AtStart"]
    $env     = $table["env"]

    if ($env.Length -eq 0) {
        $env = "PATH"
    }

    $pathValue = [environment]::GetEnvironmentVariable($env, "Machine")
    if ($pathValue -eq $null) {
        $pathValue = ""
    }
    $pv = $pathValue.ToLower()
    $ap = $dir.ToLower()

    if ($pv.Contains("$ap")) {
        Write-Verbose "AddToPath - path information already up-to-date" 
    }

    Write-Host Adding [$dir] to environment [$env]
    if ($atStart) {
        $pathvalue = "$dir;$pathvalue"
    }
    else {
        $pathvalue = "$pathvalue;$dir"
    }
    if ($Execute) {
        SetEnvVar -name $env -content "$pathvalue" 
    }
}

function ExtractAllFromZip(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func    = $table["Function"]
    $zipFileName = $table["zipFileName"]
    $destinationFolder = $table["destinationFolder"]

    if (-not (test-path -path $destinationFolder)) {
        throw "$destinationFolder doesn't exist"
    }
    if (-not (test-path $zipFileName -PathType Leaf)) {
        throw "$zipFileName doesn't exist"
    }

    if ($Execute) {
        $obj = new-object -com shell.application
        $zipFile = $obj.NameSpace($zipFileName)
        $destination = $obj.NameSpace($destinationFolder)

        $destination.CopyHere($zipFile.Items())
    }
}

function CreateBatch(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $filename = $table["Filename"]
    $pyVersion = $table["PyVersion"]

    if (-not $Execute) {
        Write-Host "Create-Batch [$filename]:No-Execute flag. No file created"
        return
    }

    Remove-Item -Path $filename -ErrorAction SilentlyContinue | Out-Null

    $batchScript = @"
@echo off
if /I "%CMDCMDLINE%" neq ""%COMSPEC%" " (
    echo.
    echo Please execute this script from inside a regular Windows command prompt.
    echo.
    exit /b 0
)
set PATH=$cntkRootDir\cntk;%PATH%
"$AnacondaBasePath\Scripts\activate" "$AnacondaBasePath\envs\cntk-py$pyVersion"
"@

    add-content -Path $filename -Encoding Ascii -Value $batchScript
}


function DoProcess(
    [string]  $command,
    [string]  $param,
    [string]  $workingDir = "",
    [boolean] $requiresRunAs = $false,
    [int] $maxErrorLevel)
{
    $info = "start-process [$command] with [$param]"

    Write-Verbose "$info"

    if (-not $Execute) {
         Write-Host  "** Running in DEMOMODE - setting Exit Code **: 0"
         return
    }

    if ($workingDir.Length -eq 0) {
        if ($requiresRunAs) {
            $process = start-process -FilePath "$command" -ArgumentList "$param" -Wait -PassThru -Verb runas
        }
        else {
            $process = start-process -FilePath "$command" -ArgumentList "$param" -Wait -PassThru
        }

    }
    else {
        if ($requiresRunAs) {
            $process = start-process -FilePath "$command" -ArgumentList "$param" -Wait -PassThru -Verb runas -WorkingDirectory "$workingDir"
        }
        else {
            $process = start-process -FilePath "$command" -ArgumentList "$param" -Wait -PassThru -WorkingDirectory "$workingDir"
        }
    }

    $eCode = ($process.ExitCode)

    if ($ecode -gt $maxErrorLevel) {
        throw "Running 'start-process $command $param' failed with exit code [$ecode]"
    }
    
    return
}



function SetEnvVar(
    [Parameter(Mandatory=$true)][string] $name,
    [Parameter(Mandatory=$true)][string] $content,
    [string] $location = "Machine")
{
    Write-Verbose "SetEnvVar [$name] with [$content]"
    
    if ($Execute) {
        $commandString = "& { [environment]::SetEnvironmentVariable('"+$name+"', '"+$content+"', '"+$location+"') }"
        RunPowershellCommand -command "$commandString" -elevated $true -maxErrorLevel 0
    }    
}

function RunPowershellCommand(
    [string] $commandString,
    [boolean] $elevated,
    [int] $maxErrorLevel
)
{
    $commandBytes = [System.Text.Encoding]::Unicode.GetBytes($commandString)
    $encodedCommand = [Convert]::ToBase64String($commandBytes)
    $commandLine = "-NoProfile -EncodedCommand $encodedCommand"

    if ($elevated) {
        $process = Start-Process -PassThru -FilePath powershell.exe -ArgumentList $commandLine -wait -verb runas
    }
    else {
        $process = Start-Process -PassThru -FilePath powershell.exe -ArgumentList $commandLine -wait
    }
    
    $eCode = ($process.ExitCode)
    if ($ecode -gt $maxErrorLevel) {
        throw "Running 'powershell.exe $commandString' failed with exit code [$ecode]"
    }
    return
}

function Invoke-DosCommand {
  [CmdletBinding()]
  Param(
    [ValidateScript({ Get-Command $_ })]
    [string] $Command,
    [string[]] $Argument,
    [string] [ValidateScript({ Test-Path -PathType Container $_ })] $WorkingDirectory,
    [int] $maxErrorLevel,
    [switch] $SuppressOutput
  )
    Write-Verbose "Running '$Command $Argument'"
    if ($WorkingDirectory) {
        Push-Location $WorkingDirectory -ErrorAction Stop
    }
    if ($SuppressOutput) {
        $null = & $Command $Argument 2>&1
    } else {
        & $Command $Argument
    }
    if ($WorkingDirectory) {
        Pop-Location
    }
    if ($LASTEXITCODE -gt $maxErrorLevel) {
        throw "Running '$Command $Argument' failed with exit code $LASTEXITCODE"
    }
}

function ResolveApplicationName(
    [Parameter(Mandatory=$True)][string] $name,
    [string] $directory = "",
    [bool] $usePath = $false)
{
    $application = ""

    if ($directory) {
        $application = CallGetCommand (join-path $directory $name)
    }
    if (-not $application) {
        if ($usePath) {
            # we are at this point if we are supposed to check in the path environment for a match and
            # $directory was empty or we couldn't find it in the $directory

            $application = CallGetCommand $name
        }
    }
    # application will be an empty string if we couldn't resolve the name, otherwise we can execute $application
    return $application
}

function CallGetCommand(
    [Parameter(Mandatory=$True)][string] $application)
{
    $matches = @(get-command $application -CommandType Application -TotalCount 1 -ErrorAction SilentlyContinue)
    if ($matches.Count -eq 0) {
        return ""
    }

    return $matches[0].Source
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#

Function Set-OperationsInfo(
    [Parameter(Mandatory=$true)][string] $whlUrl)
{
    @(
        @{Name = "Scan System for installed programs"; ShortName = "SCANPROG"; Info = "Scan System for installed programs";
          Verification = @( @{Function = "VerifyScanPrograms" } );
          Download = @( ) ;
          Action = @() ;
         },
        @{Name = "Installation VS2017 Runtime"; ShortName = "VS2017"; Info = "Install VS2017 Runtime";
          Verification = @( @{Function = "VerifyWinProductExists"; Match = "^Microsoft Visual C\+\+ 201(5|7) x64 Additional Runtime" },
                            @{Function = "VerifyWinProductExists"; Match = "^Microsoft Visual C\+\+ 201(5|7) x64 Minimum Runtime" } );
          Download = @( ) ;
          Action = @( @{Function = "InstallExe"; Command  = "$cntkRootDir\prerequisites\VS2017\vc_redist.x64.exe"; Param = "/install /passive /norestart"; Message="Installing VS2017 Runtime...." } )
         },
        @{Name = "MSMPI Installation"; ShortName = "CNTK"; Info = "Install MSMPI";
          Verification = @( @{Function = "VerifyWinProductVersion"; Match = "^Microsoft MPI \(\d+\."; Version = "7.0.12437.6" } );
          Download = @( ) ;
          Action = @( @{Function = "InstallExe"; Command = "$cntkRootDir\prerequisites\msmpisetup.EXE"; Param = "/unattend"; Message="Installing MSMPI ...." } )
         },
        @{Name = "Anaconda3-4.3.1"; ShortName = "ANA3-431"; Info = "Install Anaconda3-4.3.1";
          Verification = @( @{Function = "VerifyDirectory"; Path = "$AnacondaBasePath"; } );
          Download = @( @{Function = "Download"; Source = "https://repo.continuum.io/archive/Anaconda3-4.3.1-Windows-x86_64.exe"; Destination = "$localCache\Anaconda3-4.3.1-Windows-x86_64.exe" } );
          Action = @( @{Function = "InstallExe"; Command = "$localCache\Anaconda3-4.3.1-Windows-x86_64.exe"; Param = "/InstallationType=JustMe /AddToPath=0 /RegisterPython=0 /S /D=$AnacondaBasePath"; runAs=$false; Message="Installing Anaconda3-4.3.1. Please be patient ...."} );
         },
        @{Name = "CNTK Python Environment"; ShortName = "CNTKPY"; Info = "Setup CNTK PythonEnvironment $PyVersion";
          Verification  = @( @{Function = "VerifyRunAlways"  } );
          Download = @( ) ;
          Action = @( @{Function = "InstallYml"; BasePath = $AnacondaBasePath; Env = "cntk-py$PyVersion"; ymlFile= "$ymlDir\conda-windows-cntk-py$PyVersion-environment.yml"; PyVersion = $PyVersion } )
         },
        @{Name = "CNTK WHL Install"; ShortName = "CNTKWHL"; Info = "Setup/Update CNTK Wheel $PyVersion";
          Verification  = @( @{Function = "VerifyRunAlways" } );
          Download = @( ) ;
          Action = @( @{Function = "InstallWheel"; WhlUrl = $whlUrl; BasePath = "$AnacondaBasePath"; EnvName = "cntk-py$PyVersion"; Message="Setup/Update with wheel: $whlUrl. Please be patient...." } )
         },
        @{Name = "Create CNTKPY batch file"; ShortName = "BATCH"; Info = "Create CNTKPY batch file";
          Verification  = @( @{Function = "VerifyFile"; Path = "$cntkRootDir\scripts\cntkpy$PyVersion.bat"; PyVersion = $PyVersion } );
          Download = @( ) ;
          Action = @( @{Function = "CreateBatch"; Filename = "$cntkRootDir\scripts\cntkpy$PyVersion.bat"; PyVersion = $PyVersion } )
         }
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE file in the project root for full license information.

# Assumes clean Git working directory
[CmdletBinding()]
Param([Parameter(Mandatory=$true)][string]$Output)

if (-not (Get-Command -ErrorAction SilentlyContinue 7za.exe)) {
    throw "7za.exe not found in path"
}

Set-StrictMode -Version Latest

$ErrorActionPreference = 'Stop'

$isVerbose = $PSBoundParameters.ContainsKey('Verbose')

# Normalize path
$Output = [System.IO.Path]::Combine((Get-Location).Path, $Output)
$Output = [System.IO.Path]::GetFullPath($Output)

# N.B. explicit -Verbose conflicts with implicit $ErrorActionPreference... (also below)
Remove-Item -ErrorAction SilentlyContinue -Verbose:$isVerbose -Recurse SamplesZip, $Output

$null = New-Item -ItemType Directory SamplesZip

Copy-Item -ErrorAction Stop -Verbose:$isVerbose -Path LICENSE.md -Destination SamplesZip\LICENSE.md

Copy-Item -ErrorAction Stop -Verbose:$isVerbose -Path Scripts\install\sample_requirements.txt -Destination SamplesZip\requirements.txt

Copy-Item -ErrorAction Stop -Verbose:$isVerbose -Recurse Examples, Tutorials, PretrainedModels, Manual -Destination SamplesZip

Push-Location SamplesZip

try {
    7za.exe a -bd $Output .
    if ($LASTEXITCODE -ne 0) {
        throw "7za.exe returned non-zero exit code $LASTEXITCODE"
    }
} finally {
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#

[CmdletBinding()]
Param([string]$WikiRepoPath)

$scriptDir = Split-Path $MyInvocation.MyCommand.Definition

function GetGitFilesAndDirs {
  [CmdletBinding()]
  Param(
    [parameter(Mandatory=$true)]
    [ref]
    $FileHash,

    [parameter(Mandatory=$true)]
    [ref]
    $DirHash,

    [parameter(Mandatory=$true)]
    [ValidateScript({Test-Path $_})]
    [string]
    $RepoPath,

    [parameter(Mandatory=$true)]
    [string]
    $Treeish
  )

  if ($FileHash.Value -isnot [hashtable]) {
    throw "-FileHash parameter not a [hashtable] reference"
  }
  if ($DirHash.Value -isnot [hashtable]) {
    throw "-DirHash parameter not a [hashtable] reference"
  }
  if (-not (Get-Command git)) {
    throw "git command not in path"
  }

  $FileHash.Value.Clear()
  $DirHash.Value.Clear()

  $originalLocation = Get-Location
  try {
    Set-Location -ErrorAction Stop $RepoPath

    $outFile = git ls-tree -r $Treeish --full-tree --name-only
    if ($LASTEXITCODE -ne 0) {
      throw "git ls-tree failed"
    }

    $outDir = git ls-tree -r $Treeish -d --full-tree --name-only
    if ($LASTEXITCODE -ne 0) {
      throw "git ls-tree -d failed"
    }

    $outFile | ForEach-Object { $FileHash.Value[$_] = $true }
    $outDir | ForEach-Object { $DirHash.Value[$_] = $true }

  } finally {
    Set-Location $originalLocation
  }
}

function SplitPrefix($Prefix, $String) {
  if ($String.StartsWith($Prefix)) {
    $String.Substring($Prefix.Length)
  }
}

# Note: case-sensitive comparison
$sourceFileHash = New-Object -TypeName System.Collections.Hashtable
$sourceDirHash = New-Object -TypeName System.Collections.Hashtable

GetGitFilesAndDirs -FileHash ([ref]$sourceFileHash) -DirHash ([ref]$sourceDirHash) -RepoPath $scriptDir -Treeish HEAD

$wikiFileHash = New-Object -TypeName System.Collections.Hashtable
$wikiDirHash = New-Object -TypeName System.Collections.Hashtable
if ($WikiRepoPath) {
  GetGitFilesAndDirs -FileHash ([ref]$wikiFileHash) -DirHash ([ref]$wikiDirHash) -RepoPath $WikiRepoPath -Treeish HEAD
}

$jsonFile = 'samples.json'

$jsonPath = Join-Path $scriptDir $jsonFile

$json = Get-Content -ErrorAction Stop $jsonPath | ConvertFrom-JSON -ErrorAction Stop

$json.url | ForEach-Object {
  $uri = [Uri]$_

  if ($uri.IsAbsoluteUri -and $uri.Scheme -ceq 'https' -and $uri.Host -ceq 'github.com') {
    $path = $uri.LocalPath
    if ($rest = SplitPrefix '/Microsoft/CNTK/tree/master/' $path) {
      if (-not $sourceDirHash.ContainsKey($rest)) {
        Write-Error "Cannot find $_ as a directory in Git HEAD"
      }
    } elseif ($rest = SplitPrefix '/Microsoft/CNTK/blob/master/' $path) {
      if (-not $sourceFileHash.ContainsKey($rest)) {
        Write-Error "Cannot find $_ as a file in Git HEAD"
      }
    } elseif ($rest = SplitPrefix '/Microsoft/CNTK/wiki/' $path) {
      if ($WikiRepoPath) {
        if (-not ($wikiFileHash.ContainsKey("$rest.md") -or $wikiDirHash.ContainsKey($rest))) {
          Write-Error "Cannot find $_ in Wiki Git HEAD"
        }
      } else {
        Write-Warning "Cannot validate $_, -WikiRepoPath not specified"
      }
    } else {
      throw "Unsupported URL $_"
    }
  } else {
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
[CmdletBinding()]
param(
    [parameter(Mandatory=$true)][string]$targetConfig,           # the config created (CPU, GPU, ...)
    [parameter(Mandatory=$true)][string]$targetConfigSuffix,     # the config suffix (CPU-Only, GPU ...)
    [parameter(Mandatory=$true)][string]$releaseTag,             # the tag of the release (2-0-beta11-0)
    [parameter(Mandatory=$true)][string]$commit,
    [parameter(Mandatory=$true)][string]$outputFileName,         # the generated zip file name
    [parameter(Mandatory=$true)][string]$sharePath)

$ErrorActionPreference = 'Stop'

$workSpace = $PWD.Path
Write-Verbose "Making binary drops..."

# Set Paths
$basePath = "ToZip"
$baseDropPath = Join-Path $basePath -ChildPath cntk
$baseIncludePath = Join-Path $baseDropPath -ChildPath Include
$baseIncludeInternalPath = Join-Path $baseIncludePath -ChildPath Internals
$buildPath = "x64\Release"
if ($targetConfig -eq "CPU")
{
    $buildPath = "x64\Release_CpuOnly"
}
# Include Files
$includePath = "Source\Common\Include"
$includePath20 = "Source\CNTKv2LibraryDll\API"
$includeFiles = New-Object string[] 5
$includeFiles[0] = Join-Path $includePath -ChildPath Eval.h
$includeFiles[1] = Join-Path $includePath20 -ChildPath CNTKLibrary.h
$includeFiles[2] = Join-Path $includePath20 -ChildPath CNTKLibraryInternals.h
$includeFiles[3] = Join-Path $includePath20 -ChildPath CNTKLibraryC.h
$includeFiles[4] = Join-Path $includePath20 -ChildPath HalfConverter.hpp
$sharePath = Join-Path $sharePath -ChildPath $targetConfig

# Include Internal Files
$includeInternalPath20 = Join-Path $includePath20 -ChildPath Internals
$includeInternalFiles = New-Object string[] 5
$includeInternalFiles[0] = Join-Path $includeInternalPath20 -ChildPath ComputationGraphAlgorithms.h
$includeInternalFiles[1] = Join-Path $includeInternalPath20 -ChildPath EvaluatorWrapper.h
$includeInternalFiles[2] = Join-Path $includeInternalPath20 -ChildPath PrimitiveFunctionAttribute.h
$includeInternalFiles[3] = Join-Path $includeInternalPath20 -ChildPath PrimitiveFunction.h
$includeInternalFiles[4] = Join-Path $includeInternalPath20 -ChildPath PrimitiveOpType.h

# binaryDrop locations
$artifactPath = Join-Path $workSpace BinaryDrops
$whlArtifactFolder = Join-Path $artifactPath $targetConfigSuffix
New-Item -Path $artifactPath -ItemType directory -force
New-Item -Path $whlArtifactFolder -ItemType directory -force

# Copy wheels to destination
Copy-Item $buildPath\Python\*.whl $whlArtifactFolder

# Make binary drop folder
New-Item -Path $baseDropPath -ItemType directory

# create version.txt file
$fileContent = "CNTK-{0}`r`nRelease`r`n{1}`r`n{2}`r`n" -f $releaseTag, $targetConfigSuffix, $commit
$fileContent | Set-Content -Encoding Ascii $baseDropPath\version.txt

# Copy build binaries
Write-Verbose "Copying build binaries ..."
Copy-Item $buildPath -Recurse -Destination $baseDropPath\cntk

# Clean unwanted items
Remove-Item $baseDropPath\cntk\*test*.exe*
Remove-Item $baseDropPath\cntk\*.pdb
Remove-Item $baseDropPath\cntk\python -Recurse

# Keep EvalDll.lib
Remove-Item $baseDropPath\cntk\*.lib  -Exclude Cntk.Eval-*.lib, Cntk.Core-*.lib
Remove-Item $baseDropPath\cntk\*.exp
Remove-Item $baseDropPath\cntk\*.metagen
# Remove specific items
Remove-Item $baseDropPath\cntk\CommandEval.exe -Force -ErrorAction SilentlyContinue
Remove-Item $baseDropPath\cntk\Microsoft.VisualStudio.QualityTools.UnitTestFramework.*
Remove-Item $baseDropPath\cntk\java\Main.class

# Make Include folder
New-Item -Path $baseIncludePath -ItemType directory

# Copy Include
Write-Verbose "Copying Include files ..."
Foreach ($includeFile in $includeFiles)
{
    Copy-Item $includeFile -Destination $baseIncludePath
}

# Copy Include Internals
Write-Verbose "Copying Include internal files ..."
Foreach ($includeInternalFile in $includeInternalFiles)
{
    Copy-Item $includeInternalFile -Destination $baseIncludeInternalPath
}

# Copy Examples
Write-Verbose "Copying Examples ..."
Copy-Item Examples -Recurse -Destination $baseDropPath\Examples

# Copy Tutorials
Write-Verbose "Copying Tutorials ..."
Copy-Item Tutorials -Recurse -Destination $baseDropPath\Tutorials

# Copy PretrainedModels
Write-Verbose "Copying PretrainedModels ..."
Copy-Item PretrainedModels -Recurse -Destination $baseDropPath\PretrainedModels

# Copy Manual
Write-Verbose "Copying Manual ..."
Copy-Item Manual -Recurse -Destination $baseDropPath\Manual

# Copy Scripts
Write-Verbose "Copying Scripts ..."
Copy-Item Scripts -Recurse -Destination $baseDropPath\Scripts
# Remove some files if they exist
Remove-Item $baseDropPath\Scripts\pytest.ini -Force -ErrorAction SilentlyContinue
Remove-Item -Recurse $baseDropPath\Scripts\install\linux -Force -ErrorAction SilentlyContinue

# Copy all items from the share
# For whatever reason Copy-Item in the line below does not work
# Copy-Item $sharePath"\*"  -Recurse -Destination $baseDropPath
# Copying with Robocopy. Maximum 2 retries, 30 sec waiting time in between
Write-Verbose "Copying dependencies and other files from Remote Share ..."
robocopy $sharePath $baseDropPath /s /e /r:2 /w:30 /np
# Check that Robocopy finished OK.
# Any exit code greater than 7 indicates error
# See http://ss64.com/nt/robocopy-exit.html
If ($LastExitCode -gt 7)
{
    Throw "Copying from Remote Share failed. Robocopy exit code is " + $LastExitCode
}

Write-Verbose "Making ZIP and cleaning up..."

# Make ZIP file
# Switched to use 7zip because of the backslash separator issue in .NET compressor
# (fixed in 4.6.1, which is not a standard component of build machines
# see https://msdn.microsoft.com/en-us/library/mt712573(v=vs.110).aspx?f=255&MSPPError=-2147217396 )
$source = Join-Path $workSpace -ChildPath $basePath
$destination = Join-Path $artifactPath -ChildPath $outputFileName
Set-Location -Path $source
7za a -bd $destination .
If ($LastExitCode -ne 0)
{
    throw "7za returned exit code $LastExitCode"
}

Set-Location -Path $workSpace

# Log the file hash
Get-FileHash -Algorithm SHA256 -Path $destination, $whlArtifactFolder\*.whl
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
<#
  .SYNOPSIS
 Use this cmdlet to install a CNTK development environment on your machine.
 A detailed description can be found here: https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-with-script-on-Windows
 
 .DESCRIPTION
 The script will download and install the files necessary to create a CNTK development environment on your system. 

 It will analyse your machine and will determine which components are required. 
 The required components will be downloaded into [c:\installCacheCntk] and installed from that location.
 Repeated operation of this script will reuse already downloaded components.
 
 Before you can run this machine you should have read the instructions at 
     https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-with-script-on-Windows
 
 .PARAMETER Execute
 You can set this switch to false to prevent devInstall from performing any physical changes to the machine.

 .PARAMETER NoConfirm
 If you supply this optional parameter, the install script will execute operations without asking for user confirmation.
 
 .PARAMETER localCache
 This optional parameter can be used to specify the directory downloaded components will be stored in

 .PARAMETER InstallLocation
 The directory the install tools/dependencies will be installed in, by default [c:\local]

 .PARAMETER AnacondaBasePath
 This optional parameter allows you to specify the location of an Anaconda installation to be used or created on your 
 machine. If the directory exists on your machine, the script will continue under the assumption that this is a working 
 Anaconda 3 (4.1.1) (or compatible) installation, and will create the CNTK Python environment in that location.
 By default a version of Anaconda3 will be installed into [C:\local\Anaconda3-4.1.1-Windows-x86_64]

  .PARAMETER PyVersion
 This is an optional parameter and can be used to specify the Python version used in the CNTK Python environment.
 Supported values for this parameter are 27, 35, or 36. The default values is 35 (for a CNTK Python 35 environment).

  .PARAMETER PyEnvironmentName
 This optional parameter allows to specify the name of the environment that will be created during the installation process.
 By default the environment will be named cntk-py<PyVersion>, where PyVersion is being replaced by the content of the <PyVersion>
 parameter to this script. If this parameter is specified by you, no version substitution in the environment will be performed. 

  .PARAMETER NoPythonEnvironment
 If this switch parameter is set, the install script will not create a CNTK Python environment during the installation process.
 This allows creation of the desired environment after the installation.

 .EXAMPLE
 .\devInstall.ps1
 
 Run the installer and install the development tools
.EXAMPLE
 .\devInstall.ps1 -Execute:$false
 
 Run the installer and see what operations would be performed, without actually performing these actions
.EXAMPLE
 .\devInstall.ps1 -Execute -AnacondaBasePath d:\mytools\Anaconda34

 If the directory [d:\mytools\Anaconda34] exists, the installer will assume it contains a complete Anaconda installation. 
 If the directory doesn't exist, Anaconda will be installed into this directory.

#>

[CmdletBinding()]
Param(
    [Parameter(Mandatory=$false)] [switch] $Execute = $true,
    [Parameter(Mandatory=$false)] [string] $localCache = "c:\installCacheCntk",
    [Parameter(Mandatory=$false)] [string] $InstallLocation = "c:\local",
    [Parameter(Mandatory=$false)] [string] $AnacondaBasePath,
    [Parameter(Mandatory=$false)] [switch] $NoConfirm,
    [Parameter(Mandatory=$false, ParameterSetName = "PythonVersion")] [ValidateSet("27", "35", "36")] [string] $PyVersion = "35",
    [Parameter(Mandatory=$false, ParameterSetName = "PythonVersion")] [string] $PyEnvironmentName = "",
    [Parameter(Mandatory=$true, ParameterSetName = "PythonNoEnvironment")] [switch] $NoPythonEnvironment)
    
$roboCopyCmd = "robocopy.exe"

if (-not $AnacondaBasePath) {
    $AnacondaBasePath = Join-Path $InstallLocation Anaconda3-4.1.1-Windows-x86_64
}

#just make sure the supplied parameter don't end on a backslash
$localCache = (Join-Path $localCache .) | Split-Path
$InstallLocation = (Join-Path $InstallLocation .) | Split-Path
$AnacondaBasePath = (Join-Path $AnacondaBasePath .) | Split-Path

$localDir = $InstallLocation


# Get the current script's directory
$MyDir = Split-Path $MyInvocation.MyCommand.Definition

$CloneDirectory = Split-Path $mydir
$CloneDirectory = Split-Path $CloneDirectory
$CloneDirectory = Split-Path $CloneDirectory

$reponame = Split-Path $CloneDirectory -Leaf
$repositoryRootDir = Split-Path $CloneDirectory

$solutionfile = Join-Path $CloneDirectory "CNTK.SLN"

if (-not (Test-Path -Path $solutionFile -PathType Leaf)) {
    Write-Warning "The install script was started out of the [$mydir] location. Based on this"
    Write-Warning "[$CloneDirectory] should be the location of the CNTK sourcecode directory."
    Write-Warning "The specified directory is not a valid clone of the CNTK Github project."
    throw "Terminating install operation"
}


. "$MyDir\helper\Display"
. "$MyDir\helper\Common"
. "$MyDir\helper\Operations"
. "$MyDir\helper\Verification"
. "$MyDir\helper\Download"
. "$MyDir\helper\Action"
. "$MyDir\helper\PreRequisites"

Function main
{
    try { if (-not (DisplayStart -NoConfirm $NoConfirm)) {
            Write-Host 
            Write-Host " ... Quitting ... "
            Write-Host
            return
        }
    
        if (-not (Test-Path -Path $localCache)) {
            new-item -Path $localcache -ItemType Container -ErrorAction Stop | Out-Null
        }

        ClearScriptVariables

        $operation = @();
        $operation += OpScanProgram
        $operation += OpCheckVS2017

        $operation += OpCheckCuda10
        $operation += OpNVidiaCudnn73100 -cache $localCache -targetFolder $localDir
        $operation += OpNvidiaCub180 -cache $localCache -targetFolder $localDir

        $operation += OpCMake362 -cache $localCache
        $operation += OpMSMPI70 -cache $localCache
        $operation += OpMSMPI70SDK -cache $localCache
        $operation += OpBoost160VS15 -cache $localCache -targetFolder $localDir
        $operation += OpMKLDNN012 -cache $localCache -targetFolder $localDir
        $operation += OpSwig3010 -cache $localCache -targetFolder $localDir
        $operation += OpProtoBuf310VS17 -cache $localCache -targetFolder $localDir -repoDirectory $CloneDirectory
        $operation += OpProtoBuf310VS17Prebuild -cache $localCache -targetFolder $localDir
        $operation += OpZlibVS17 -cache $localCache -targetFolder $localDir -repoDirectory $CloneDirectory
        $operation += OpZlibVS17Prebuild -cache $localCache -targetFolder $localDir
        $operation += OpOpenCV31 -cache $localCache -targetFolder $localDir
        $operation += OpAnaconda3411 -cache $localCache -AnacondaBasePath $AnacondaBasePath
        if (-not $NoPythonEnvironment) {
            $operation += OpAnacondaEnv -AnacondaBasePath $AnacondaBasePath -repoDir $repositoryRootDir -repoName $reponame -environmentName $PyEnvironmentName -pyVersion $PyVersion
        }

        $operationList = @()
        $operationList += (VerifyOperations $operation)

        PreReqOperations $operationList

        if (DisplayAfterVerify -NoConfirm $NoConfirm -list $operationList) {

            DownloadOperations $operationList

            ActionOperations $operationList 

            DisplayEnd
        }
    }
    catch {
        Write-Host "Exception caught - function main / failure"
        Write-Host ($Error[0]).Exception
        Write-Host
    }
}

main
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function VerifyOperations(
    [array] $verificationList)
{
    Write-Host "Determining Operations to perform. This will take a moment..."

    $result = @()

    foreach ($item in $verificationList) {
        $needsInstall = $false
        Write-Host $item.VerifyInfo
        foreach ($verificationItem in $item.Verification) {
            $needsInstall = VerifyItem $verificationItem
            if (-not $needsInstall) {
                $result += $item
                break
            }
        }
    }
    return $result
}

function VerifyItem(
    [hashtable] $item)
{
    $func = $item["Function"]
    $name = $item["Name"]

    $expr = $func +' $item' 

    Write-Verbose "Calling Operation: [$func]: [$name]"
    $noInstallRequired = Invoke-Expression $expr 
    return $noInstallRequired
}

function VerifyScanPrograms(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $noInstallRequired = $true
    
    # no actual work is being performed, just the script local datastructure with the list
    # of installed programs is being initialized
    LoadWinProduct
    return $noInstallRequired
}

function VerifyWinProductExists(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $match = $table["Match"]
    $compare = GetTableDefaultString -table $table -entryName "Compare" -defaultValue ""
    $matchExact = GetTableDefaultBool -table $table -entryName "MatchExact" -defaultValue $true
    $noInstallRequired = $true

    $allProducts = LoadWinProduct
    $productList = @($allProducts | Where-Object { $_.Name -match $match } )

    if ($productList.Count -eq 0) {
        $noInstallRequired = $false
    }
    elseif ($compare.length -gt 0) {
        if ($matchExact) {
            $productList = @($productList | Where-Object { $_.Name -eq $compare })
        }
        else {
            $productList = @($productList | Where-Object { $_.Version -ge $compare })
        }
        if ($productList.Count -eq 0) {
            Write-Verbose "No product found matching the compare requirement`n$productList"
            $noInstallRequired = $false
        }
    }

    Write-Verbose "[$func]: Product [$match] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyWinProductVersion(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $match = $table["Match"]
    $version = $table["Version"]
    $matchExact = GetTableDefaultBool -table $table -entryName "MatchExact" -defaultValue $false
    $noInstallRequired = $true

    $allProducts = LoadWinProduct
    $productList = @($allProducts | Where-Object { $_.Name -match $match } )

    if ($productList.Count -eq 0) {
        Write-Verbose "No product found with Name matching [$match]"
        $noInstallRequired = $false
    }
    else {
        if ($matchExact) {
            $productList = @($productList | Where-Object { $_.Version -eq $version })
        }
        else {
            $productList = @($productList | Where-Object { $_.Version -ge $version })
        }
        if ($productList.Count -eq 0) {
            Write-Verbose "No product found matching the version requirement`n$productList"
            $noInstallRequired = $false
        }
    }
    Write-Verbose "[$func]: Product [$match] Version {$version] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyDirectory(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $path = $table["Path"]

    $noInstallRequired = (test-path -path $path -PathType Container)

    Write-Verbose "[$func]: [$path] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyRunAlways(
	[Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]

    $noInstallRequired = $false
    Write-Verbose "[$func]: returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyWheelDirectory(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $path = $table["WheelDirectory"]
    $forceUpdate = $table["ForceUpdate"]

    $noInstallRequired = $false

    Write-Verbose "[$func]: [$path] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyPathIncludes(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func = $table["Function"]
    $path = $table["Path"]

    $noInstallRequired = (test-path -path $path -PathType Container)

    Write-Verbose "[$func]: [$path] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyDirectoryContent(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func = $table["Function"]
    $source = $table["Source"]
    $dest = $table["Destination"]

    $noInstallRequired = (test-path -path $source -PathType Container)

    if ($noInstallRequired) {
        $noInstallRequired = (test-path -path $dest -PathType Container)
    }
    if ($noInstallRequired) {
        $r = Compare-Object $(Get-ChildItem $source -Recurse) $(Get-ChildItem $dest -Recurse)
        if ($r) {
            $noInstallRequired = $false
        }
    }

    Write-Verbose "[$func]: [$source] with [$dest] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyFile(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $path = $table["Path"]

    $noInstallRequired = (test-path -path $path -PathType Leaf)

    Write-Verbose "[$func]: [$path] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyRegistryKey(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func = $table["Function"]
    $key = $table["Key"]

    $noInstallRequired = (test-path -path $key)

    Write-Verbose "[$func]: [$key] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyRegistryKeyName(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func     = $table["Function"]
    $key      = $table["Key"]
    $regName  = $table["RegName"]

    $noInstallRequired = Test-ItemProperty -Path $key -Name $regName

    Write-Verbose "[$func]: [$key]:[$regname] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyRegistryKeyNameData(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    $func     = $table["Function"]
    $key      = $table["Key"]
    $regName  = $table["RegName"]
    $regData  = $table["RegData"]
    $orLater  = $table["OrLater"]

    if ($orLater -eq $null) {
        $orLater = $false
    }

    $noInstallRequired = (test-path -path $key)
    if ($noInstallRequired) {
        $theKeyObj = get-item $key
        $theKeyValue = $theKeyObj.GetValue("$regName")
        $noInstallRequired = $false

        if ($theKeyValue -ne $null) {
            if ($orLater) {
                $noInstallRequired = ($theKeyValue -ge $regData)
            }
            else {
                $noInstallRequired = ($theKeyValue -eq $regData)
            }
        }
    }

    Write-Verbose "[$func]: [$key]:[$regname] == [$regData] returned [$noInstallRequired]"
    return $noInstallRequired
}

function VerifyEnvironmentAndData(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func    = $table["Function"]
    $name    = $table["EnvVar"]
    $content = $table["Content"]
    $location = "User"

    $envContent = GetEnvironmentVariableContent $name 
    $noInstallRequired = $envContent -eq $content

    Write-Verbose "[$func]: [$name] == [$content] returned [$noInstallRequired]"
    return $noInstallRequired
}

function Test-ItemProperty (
    [string] $Path, 
    [string] $Name)
{
    if (Test-Path $Path) {
        try {
            $ItemProperty = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue
            if ( $ItemProperty -ne $null ) {
                return $true 
            }
        }
        catch {
            return $false
        }
    }
    return $false
}

function ClearScriptVariables
{
    $Script:WinProduct = $Null
}

function LoadWinProduct
{
    if ($Script:WinProduct -eq $Null) {
        # 
        # $Script:WinProduct = Get-WmiObject Win32_Product
        # The above line was the previous solution, but iterating through the registry is much faster
        # get-wmiobject does more house-holding, like checking for concistency etc ...
        # 
        $allInstalled = @(Get-childitem "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" -ErrorAction SilentlyContinue) + `
                       @(Get-childitem "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" -ErrorAction SilentlyContinue) + `
                       @(get-childitem "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\" -ErrorAction SilentlyContinue)

        $result = @()
        foreach($item in $allInstalled) {
            $displayName = $item.GetValue("DisplayName")
            if ($displayName.Length -gt 0) {
                $entry = New-Object PSObject
                $entry | Add-Member -MemberType NoteProperty -Name "Name" -Value $displayName
                $entry | Add-Member -MemberType NoteProperty -Name "Version" -Value $($item.GetValue("DisplayVersion"))
                
                $result += $entry
            }

        } 
        $result = $result | Sort-Object Name,Version -Unique

        $Script:WinProduct = $result
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function GetTableDefaultBool(
    [hashtable] $table,
    [string] $entryName,
    [bool] $defaultValue
)
{
    if ($table[$entryName] -eq $null) {
        return $defaultValue
    }
    return $table[$entryName]
}

function GetTableDefaultString(
    [hashtable] $table,
    [string] $entryName,
    [string] $defaultValue
)
{
    if ($table[$entryName] -eq $null) {
        return $defaultValue
    }
    return $table[$entryName]
}

function GetTableDefaultInt(
    [hashtable] $table,
    [string] $entryName,
    [int] $defaultValue
)
{
    if ($table[$entryName] -eq $null) {
        return $defaultValue
    }
    return $table[$entryName]
}

function GetEnvironmentVariableContent(
    [string] $envVarName)
{
    $envContent = [environment]::GetEnvironmentVariable($envVarName, "USER")
    if ($envContent) {
        return $envContent
    }
    $envContent = [environment]::GetEnvironmentVariable($envVarName, "MACHINE")
    return $envContent
}
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function ActionOperations(
    [parameter(Mandatory=$true)][array] $actionList)
{
    Write-Host "Performing install operations"

    foreach ($item in $actionList) {
        if ($item.ActionInfo) {
            Write-Host $item.ActionInfo
        }
        foreach ($actionItem in $item.Action) {
            ActionItem $actionItem
        }
    }
}

function ActionItem(
    [hashtable] $item)
{
    $func = $item["Function"]

    $expr = $func +' $item' 
        
    Write-Verbose "Calling Operation: [$func]"
    Invoke-Expression $expr 
}

function InstallExe(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $cmd  = $table["Command"]
    $param= $table["Param"]
    $dir  = $table["WorkDir"]
    $processWait = $table["ProcessWait"]
    $message =  $table["message"]
    $runAs = GetTableDefaultBool -table $table -entryName "runAs" -defaultValue $true
    $maxErrorLevel = GetTableDefaultInt -table $table -entryName "maxErrorLevel" -defaultValue 0

    if ($message -ne $null) {
        Write-Host $message
    }
    
    if ($dir -eq $null) {
        DoProcess -doExecute $Execute -command $cmd -param $param -requiresRunAs $runAs -maxErrorLevel $maxErrorLevel -throwOnError $true
    }
    else {
        DoProcess -doExecute $Execute -command $cmd -param $param -requiresRunAs $runAs -workingDir $dir -maxErrorLevel $maxErrorLevel -throwOnError $true
    }
    
    if ( ($processWait -ne $null) -and ($Execute) -and ($false) ) {
        do {
    	    start-sleep 20
	        $pwait = Get-Process $processWait -ErrorAction SilentlyContinue
        } while (-not ($pwait -eq $null))
    }
}

function InstallYml(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $basePath  = $table["BasePath"]
    $env= $table["Env"]
    $ymlFile  = $table["ymlFile"]

    $envsDir = Join-Path $basePath envs
    $targetDir = Join-Path $envsDir $env
    $condaPath = Join-Path $basePath Scripts\conda.exe

    if (test-path -path $targetDir -PathType Container) {
        $newTable = @{ Function = "InstallExe"; Command = $condaPath; Param = "env update --file `"$ymlFile`" --name $targetDir"; WorkDir = "$basePath\Scripts"; runAs=$false }
    }
    else {
        $newTable = @{ Function = "InstallExe"; Command = $condaPath; Param = "env create --file `"$ymlFile`" --prefix $targetDir"; WorkDir = "$basePath\Scripts"; runAs=$false }
    }

    InstallExe $newTable
}

function ExecuteApplication(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $appName = $table["AppName"]
    $param= $table["Param"]
    $dir  = $table["WorkDir"]
    $appDir = GetTableDefaultString -table $table -entryName "AppDir" -defaultValue ""
    $usePath = GetTableDefaultBool -table $table -entryName "UseEnvPath" -defaultValue $false
    $maxErrorLevel = GetTableDefaultInt -table $table -entryName "maxErrorLevel" -defaultValue 0

    if (-not $Execute) {
         Write-Host  "** Running in DEMOMODE - setting Exit Code **: 0"
         return 
    }
    $application = ResolveApplicationName -name $appName -directory $appDir -usePath $usePath
    if (-not $application) {
        throw "ExecuteApplication: Couldn't resolve program [$appName] with location directory [$appDir] and usePath [$usePath]"
    }
    if ($dir -eq $null) {
        DoProcess -doExecute $Execute -command $application -param $param -maxErrorLevel $maxErrorLevel -throwOnError $true
    }
    else {
        DoProcess -doExecute $Execute -command $application -param $param -workingDir $dir -maxErrorLevel $maxErrorLevel -throwOnError $true
    }
}

function InstallWheel(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $BasePath     = $table["BasePath"]
    $EnvName      = $table["EnvName"]
    $whl          = $table["whl"]
    $message      = $table["message"]
    $whlDirectory = $table["WheelDirectory"]

    Write-Host $message
    if (-not $Execute) {
         Write-Host  "** Running in DEMOMODE - setting Exit Code **: 0"
         return 
    }
    $condaExe = Join-Path $BasePath 'Scripts\conda.exe'
    $newPaths = Invoke-DosCommand $condaExe (Write-Output ..activate cmd.exe $EnvName) -maxErrorLevel 0

    $oldPath = $env:PATH
    $env:PATH = $newPaths + ';' + $env:PATH
    
    Invoke-DosCommand pip (Write-Output install $whl) -maxErrorLevel 0
    $env:PATH = $oldPath 
}

function InstallMSI(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
   
    $func = $table["Function"]
    $msi  = $table["MsiName"]
    $dir  = $table["MsiDir"]

    $completeMsiName = Join-Path $dir $msi

    $windDir = GetEnvironmentVariableContent("WINDIR")
    $cmd = Join-Path $windDir System32\MSIEXEC.EXE

    $param= "/i `"$completeMsiName`" /quiet /norestart"
  
    DoProcess -doExecute $Execute -command $cmd -param $param -requiresRunAs $true -maxErrorLevel 0 -throwOnError $true
}
               
function MakeDirectory(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table
    
    $func = $table["Function"]
    $path = $table["Path"]

    if (-not (test-path -path $path)) {
        if ($Execute) {
            New-Item $path -type directory | Out-Null
        }
    }
}

function RobocopySourceDestination(
    [Parameter(Mandatory = $true)][string] $source,
    [Parameter(Mandatory = $true)][string] $destination,
    [bool] $copyAdditive=$false)
{
    if (-not (test-path $source -PathType Any)) {
        throw SourceDirectory [$source] is missing
    }

    $option = "/NFL /copy:DT /dcopy:D /xj"
    if (-not $copyAdditive) {
        $option += " /MIR "
    }

    $param = "`"$source`" `"$destination`" $option"

    DoProcess -doExecute $Execute -command $roboCopyCmd -param $param -maxErrorLevel 8 -throwOnError $true
}

function SetEnvironmentVariable(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func    = $table["Function"]
    $name    = $table["EnvVar"]
    $content = $table["Content"]
    $location = "User"

    if (-not $Execute) {
        return
    }
    else {
        $demoMessage = ""
    }

    if ($demoMessage.Length -gt 0) {
        Write-Verbose "$demoMessage[$func]: [$name] = [$content] in [$location]"
    }

    SetUserEnvironmentVariable -name "$name" -content "$content" 
}

function AddToPath(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func    = $table["Function"]
    $dir     = $table["Dir"]
    $atStart = $table["AtStart"]
    $env     = $table["env"]

    if ($env.Length -eq 0) {
        $env = "PATH"
    }

    $pathValue = [environment]::GetEnvironmentVariable($env, "Machine")
    if ($pathValue -eq $null) {
        $pathValue = ""
    }
    $pv = $pathValue.ToLower()
    $ap = $dir.ToLower()

    if ($pv.Contains("$ap")) {
        Write-Verbose "AddToPath - path information already up-to-date" 
        return
    }

    Write-Verbose "Adding [$dir] to environment [$env]"
    if ($atStart) {
        $pathvalue = "$dir;$pathvalue"
    }
    else {
        $pathvalue = "$pathvalue;$dir"
    }
    if ($Execute) {
        SetUserEnvironmentVariable -name $env -content $pathvalue
    }
}

function ExtractAllFromZip(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $zipFileName = $table["zipFileName"]
    $destination = $table["destination"]
    $destinationFolder = $table["destinationFolder"]
    $zipSubTree = $table["zipSubTree"]
    $copyAdditive = GetTableDefaultBool -table $table -entryName "AddToDirectory" -defaultValue $false
    
    Write-Verbose "ExtractAllFromZip: zipFileName [$zipFileName] destination [$destination] Folder [$destinationFolder]"

    if (-not $Execute) {
        return
    }
    $completeDestination = join-path -Path $destination -ChildPath $destinationFolder

    if (-not (test-path -path $completeDestination)) {
        new-item $completeDestination -type directory -Force -ErrorAction Stop | Out-Null
    }
    if (-not (test-path $zipFileName -PathType Leaf)) {
        throw  "ExtractAllFromZip: zipFileName [$zipFileName] not found!"
    }

    $tempDir = [System.IO.Path]::GetTempFileName();
    remove-item $tempDir | Out-Null

    $completeTempDestination = join-path -Path $tempDir -ChildPath $destinationFolder
    new-item -type directory -path $completeTempDestination -Force -ErrorAction Stop | Out-Null

    $obj = new-object -com shell.application
    $zipFile = $obj.NameSpace($zipFileName)
    $destinationNS = $obj.NameSpace($completeTempDestination)

    $destinationNS.CopyHere($zipFile.Items())

    if ($zipSubTree) {
        $completeTempDestination = join-path $completeTempDestination $zipSubTree
    }

    RobocopySourceDestination $completeTempDestination $completeDestination $copyAdditive

    Remove-Item -r $tempDir -Force -ErrorAction SilentlyContinue | Out-Null
}


function Extract7zipSelfExtractingArchive(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $archiveName = $table["archiveName"]
    $destination = $table["destination"]
    $destinationFolder = $table["destinationFolder"]
    $archiveSubTree = $table["archiveSubTree"]
    $copyAdditive = GetTableDefaultBool -table $table -entryName "AddToDirectory" -defaultValue $false
    
    Write-Verbose "Extract7zipSelfExtractingArchive: archiveName [$archiveName] destination [$destination] Folder [$destinationFolder]"

    if (-not $Execute) {
        return
    }
    $completeDestination = join-path -Path $destination -ChildPath $destinationFolder

    if (-not (test-path $archiveName -PathType Leaf)) {
        throw  "Extract7zipSelfExtractingArchive: zipFileName [$zipFileName] not found!"
    }

    $tempDir = [System.IO.Path]::GetTempFileName();
    remove-item $tempDir | Out-Null

    $completeTempDestination = $tempDir
    new-item -type directory -path $completeTempDestination -Force -ErrorAction Stop | Out-Null

    $cmdParm  = "-o`"$completeTempDestination`" -y"
    $newTable = @{ Function = "InstallExe"; Command = $archiveName; Param = $cmdParm; runAs=$false }
    InstallExe $newTable
          
    if ($archiveSubTree) {
        $completeTempDestination = join-path $completeTempDestination $archiveSubTree
    }
    RobocopySourceDestination $completeTempDestination $completeDestination $copyAdditive

    Remove-Item -r $tempDir -Force -ErrorAction SilentlyContinue | Out-Null
}

function ExtractAllFromTarGz(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $sourceFile = $table["SourceFile"]
    $targzFileName = $table["TargzFileName"]
    $destination = $table["destination"]

    Write-Verbose "ExtractAllFromTarGz: targzFileName [$targzFileName] destination [$destination] in TargetFolder [$targetfolder]"
    if (-not $Execute) { 
        return 
    }

    $location = ResolveApplicationName -name git.exe -usePath $true
    if (-not $location) {
        throw "Unpacking the file [$targzFileName] requires extraction utility TAR.EXE.`n Make sure `"Git for Windows`" is installed on your machine."
    }

    $location = Split-Path $location -Parent
    $location = Split-Path $location -Parent

    $appDir = Join-Path $location "usr\bin"
    $completeApp = Join-Path $appDir "tar.exe"

    if (-not (Test-Path -path $completeApp -PathType Leaf)) {
        throw "Unpacking the file [$targzFileName] requires extraction utility [$completeApp].\n The utility wasn't found"
    }

    $completeDestination = Join-Path $destination $targzFileName

    Copy-Item $sourceFile $completeDestination -ErrorAction SilentlyContinue

    $dosCommand = @"
set path=$appDir;%PATH% & tar.exe -xz --force-local -f "$completeDestination" -C "$destination"
"@

    & cmd /c $dosCommand
    if ($LASTEXITCODE -gt 0) {
        throw "Running [$completeApp] Command failed with exit code $LASTEXITCODE"
    }
    
    Remove-Item "$completeDestination" -ErrorAction SilentlyContinue
}

function CreateBatch(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $filename = $table["Filename"]

    if (-not $Execute) {
        Write-Host "Create-Batch [$filename]:No-Execute flag. No file created"
        return
    }

    Remove-Item -Path $filename -ErrorAction SilentlyContinue | Out-Null

    $batchScript = @"
@echo off
if /I "%CMDCMDLINE%" neq ""%COMSPEC%" " (
    echo.
    echo Please execute this script from inside a regular Windows command prompt.
    echo.
    exit /b 0
)
set PATH=$cntkRootDir\cntk;%PATH%
"$AnacondaBasePath\Scripts\activate" "$AnacondaBasePath\envs\cntk-py35"
"@

    add-content -Path $filename -Encoding Ascii -Value $batchScript
}

function SetRegistryKey(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func = $table["Function"]
    $key  = $table["key"]
    $elevated = $table["Elevated"]

    if ($Execute) {
        $result = Test-Path -Path $key

        if (-not $result) {
            Write-Verbose "[$func]: [$key] will be created"
            if ($elevated) {
                $commandString = "& { new-item -Path '$key' }"
                RunPowershellCommand -command "$commandString" -elevated $true -maxErrorLevel 0
            }
            else {
                new-item -Path $key
            }
        }
    }
}

function SetRegistryKeyNameData(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func = $table["Function"]
    $key  = $table["key"]
    $regName  = $table["RegName"]
    $data = $table["data"]
    $dataType = $table["dataType"]
    $elevated = GetTableDefaultBool -table $table -entryName "Elevated" -defaultValue $true

    if ($Execute) {
        $tab = @{Function = "SetRegistryKey"; Key=$key; Elevated=$elevated}
        SetRegistryKey $tab
        
        Write-Verbose "[$func]: [$key]:[$regName] will be set to [$dataType]:[$data]"

        $commandString = "& { set-itemproperty -path '$key' -name '$regName'  -Type $dataType -Value $data }"
        RunPowershellCommand -command "$commandString" -elevated $elevated -maxErrorLevel 0

        
        #if ($elevated) {
        #    $commandString = "& { set-itemproperty -path '$key' -name '$regName'  -Type $dataType -Value $data }"
        #    RunPowershellCommand -command "$commandString" -elevated $true -maxErrorLevel 0
        #}
        #else {
        #    set-itemproperty -path '$key' -name '$regName'  -Type $dataType -Value $data
        #}
    }
}

function CreateBuildSimpleBatch(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func = $table["Function"]
    $filename = $table["FileName"]
    $sourceDir  = $table["SourceDir"]
    $targetDir  = $table["TargetDir"]
    $repoDirectory = $table["repoDirectory"]
        
    if ($Execute) {
        Remove-Item -Path $filename -ErrorAction SilentlyContinue | Out-Null

        $batchScript = GetBatchBuildProtoBuf $sourceDir $targetDir $repoDirectory

        add-content -Path $filename -Encoding Ascii -Value $batchScript
    }
}

function CreateBuildZlibBatch(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func = $table["Function"]
    $filename = $table["FileName"]
    $zlibSourceDir  = $table["zlibSourceDir"]
    $libzipSourceDir  = $table["libzipSourceDir"]
    $targetDir  = $table["TargetDir"]
    $repoDirectory = $table["repoDirectory"]
        
    if ($Execute) {
        Remove-Item -Path $filename -ErrorAction SilentlyContinue | Out-Null

        $batchScript = GetBatchBuildZlibBuf $zlibSourceDir $libzipSourceDir $targetDir $repoDirectory

        add-content -Path $filename -Encoding Ascii -Value $batchScript
    }
}

function DoProcess(
    [bool] $doExecute = $false,
    [string] $command,
    [string] $param,
    [string] $workingDir = "",
    [boolean] $requiresRunAs = $false,
    [int] $maxErrorLevel = 0,
    [bool] $throwOnError = $true)
{
    Write-Verbose "start-process [$command] with [$param]"

    if (-not $DoExecute) {
         Write-Host  "DEMOMODE - setting Exit Code: 0"
         return
    }

    if (-not $workingDir) {
        $workingDir = $(get-location).Path
    }
    if ($requiresRunAs) {
        $process = start-process -FilePath $command -ArgumentList $param -Wait -PassThru -Verb runas -WorkingDirectory $workingDir
    }
    else {
        $process = start-process -FilePath $command -ArgumentList $param -Wait -PassThru -WorkingDirectory $workingDir
    }

    $eCode = ($process.ExitCode)

    if (-not $throwOnError) {
        if ($ecode -gt $maxErrorLevel) {
            Write-Verbose "Running [start-process $commandString $param] failed with exit code [$ecode]"
        }
        return
    }

    if ($ecode -gt $maxErrorLevel) {
        throw "Running [start-process $commandString $param] failed with exit code [$ecode]"
    }
}


function SetUserEnvironmentVariable(
    [Parameter(Mandatory=$true)][string] $name,
    [Parameter(Mandatory=$true)][string] $content)    
{
    Write-Verbose "SetUserEnvironmentVariable [$name] with [$content]"
    
    if ($Execute) {
        [environment]::SetEnvironmentVariable($name, $content, "USER")
    }    
}

function SetMachineEnvironmentVariable(
    [Parameter(Mandatory=$true)][string] $name,
    [Parameter(Mandatory=$true)][string] $content)
{
    Write-Verbose "SetMachineEnvironmentVariable [$name] with [$content]"
    
    if ($Execute) {
        $commandString = "& { [environment]::SetEnvironmentVariable(`"$name`", `"$content`", `"MACHINE`") }"
        RunPowershellCommand -command "$commandString" -elevated $true -maxErrorLevel 0
    }    
}

function RunPowershellCommand(
    [string] $commandString,
    [boolean] $elevated,
    [int] $maxErrorLevel)
{
    $commandBytes = [System.Text.Encoding]::Unicode.GetBytes($commandString)
    $encodedCommand = [Convert]::ToBase64String($commandBytes)
    $commandLine = "-NoProfile -EncodedCommand $encodedCommand"

    if ($elevated) {
        $process = Start-Process -PassThru -FilePath powershell.exe -ArgumentList $commandLine -wait -verb runas
    }
    else {
        $process = Start-Process -PassThru -FilePath powershell.exe -ArgumentList $commandLine -wait
    }
    $eCode = ($process.ExitCode)
    if ($ecode -gt $maxErrorLevel) {
        throw "Running 'powershell.exe $commandString' failed with exit code [$ecode]"
    }
}

function Invoke-DosCommand {
  [CmdletBinding()]
  Param(
    [ValidateScript({ Get-Command $_ })]
    [string] $Command,
    [string[]] $Argument,
    [string] [ValidateScript({ Test-Path -PathType Container $_ })] $WorkingDirectory,
    [int] $maxErrorLevel,
    [switch] $SuppressOutput
  )
    Write-Verbose "Running '$Command $Argument'"
    if ($WorkingDirectory) {
        Push-Location $WorkingDirectory -ErrorAction Stop
    }
    if ($SuppressOutput) {
        $null = & $Command $Argument 2>&1
    } else {
        & $Command $Argument
    }
    if ($WorkingDirectory) {
        Pop-Location
    }
    if ($LASTEXITCODE -gt $maxErrorLevel) {
        throw "Running DOS Command '$Command $Argument' failed with exit code $LASTEXITCODE"
    }
}

function GetBatchBuildProtoBuf(
    [string] $sourceDir,
    [string] $targetDir,
    [string] $repoDirectory)
{
    $batchFile = join-path $repoDirectory "tools\devInstall\Windows\buildProtoVS15.bat"
@"
call $batchFile $sourceDir $targetDir
"@
}

function GetBatchBuildZlibBuf(
    [string] $zlibSourceDir,
    [string] $libzipSourceDir,
    [string] $targetDir,
    [string] $repoDirectory)
{
    $batchFile = join-path $repoDirectory "tools\devInstall\Windows\buildZlibVS15.bat"

@"
call $batchFile $libzipSourceDir $zlibSourceDir $targetDir
"@
}

function ResolveApplicationName(
    [Parameter(Mandatory=$True)][string] $name,
    [string] $directory = "",
    [bool] $usePath = $false)
{
    $application = ""

    if ($directory) {
        $application = CallGetCommand (join-path $directory $name)
    }
    if (-not $application) {
        if ($usePath) {
            # we are at this point if we are supposed to check in the path environment for a match and
            # $directory was empty or we couldn't find it in the $directory

            $application = CallGetCommand $name
        }
    }
    # application will be an empty string if we couldn't resolve the name, otherwise we can execute $application
    return $application
}

function CallGetCommand(
    [Parameter(Mandatory=$True)][string] $application)
{
    $matches = @(get-command $application -CommandType Application -TotalCount 1 -ErrorAction SilentlyContinue)
    if ($matches.Count -eq 0) {
        return ""
    }

    return $matches[0].Path
}

#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function OpAnaconda3411(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $AnacondaBasePath)
{
    $targetFolder = Split-Path $AnacondaBasePath -Parent
    $prodSubDir = Split-Path $AnacondaBasePath -Leaf
    $prodName = "Anaconda3-4.1.1"
    $prodFile = "Anaconda3-4.1.1-Windows-x86_64.exe"
    $targetPath = join-path $targetFolder $prodSubDir
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/anaconda3/4.1.1/Anaconda3-4.1.1-Windows-x86_64.exe"
    $expectedHash = "B4889513DC574F9D6F96DB089315D69D293F8B17635DA4D2E6EEE118DC105F38"

    @( @{ShortName = "ANA3-411"; Name = $prodName;  VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName";
         Verification = @( @{Function = "VerifyDirectory"; Path = $targetPath; } );
         Download = @( @{Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash } );
         # command line parameters for Anaconda installer: /D=$targetPath must be the last parameter and can not be surrounded by quotes
         Action = @( @{Function = "InstallExe"; Command = "$cache\$prodFile"; Param = "/InstallationType=JustMe /AddToPath=0 /RegisterPython=0 /S /D=$targetPath"; runAs=$false; Message = ".... This will take some time. Please be patient ...." } );
     } )
}

function OpAnacondaEnv(
    [parameter(Mandatory=$true)][string] $AnacondaBasePath,
    [parameter(Mandatory=$true)][string] $repoDir,
    [parameter(Mandatory=$true)][string] $reponame,
    [string] $environmentName = "",
    [parameter(Mandatory=$true)][string] $pyVersion)
{
    $prodName = "Python $pyVersion Environment"
    $targetFolder = Split-Path $AnacondaBasePath -Parent
    $prodSubDir = Split-Path $AnacondaBasePath -Leaf
    $targetPath = Join-Path $targetFolder $prodSubDir
    if ($environmentName) {
        $envName = $environmentName
    }
    else {
        $envName = "cntk-py$pyVersion"
    }
    $envDir = Join-Path envs $envName
    $envVar = "CNTK_PY$($pyVersion)_PATH";
    $envValue = Join-Path $targetPath $envDir

    $ymlDirectory = Join-Path $repoDir $repoName
    $ymlDirectory = Join-Path $ymlDirectory scripts\install\windows
    $ymlFile = Join-Path $ymlDirectory "conda-windows-cntk-py$($pyVersion)-environment.yml"

    @{ ShortName = "PYENV"; Name = $prodName;  VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Creating $prodName";
      Verification  = @( @{Function = "VerifyRunAlways" } );
      Action = @( @{Function = "InstallYml"; BasePath = $targetPath; Env = $envName; ymlFile= $ymlFile },
                  @{Function = "SetEnvironmentVariable"; EnvVar= $envVar; Content = $envValue } )
     }
}

function OpBoost160VS15(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "Boost 1.60.0"
    $prodFile = "boost_1_60_0-msvc-14.0-64.exe"
    $prodSubDir = "boost_1_60_0-msvc-14.0"
    $targetPath = join-path $targetFolder $prodSubDir
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/boost/1.60.0/boost_1_60_0-msvc-14.0-64.exe"
    $envVar = "BOOST_INCLUDE_PATH"
    $envVarLib = "BOOST_LIB_PATH"
    $envContentLib = "$targetPath\lib64-msvc-14.0"
    $expectedHash = "DBC37E8A33895FF67489ABFDC3DA7FF175A4900F2E4124AFF3E359C8F3014D2E"

    @( @{Name = $prodName; ShortName = "BOOST160VS15"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName";
         Verification = @( @{Function = "VerifyDirectory"; Path = "$targetPath" },
                        @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $targetPath },
                        @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVarLib; Content  = $envContentLib } );
        Download = @( @{Function = "Download"; Method = "WebRequest"; UserAgent = "Firefox"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash } );
        Action = @( @{Function = "SetEnvironmentVariable"; EnvVar = $envVar; Content = $targetPath },
                    @{Function = "SetEnvironmentVariable"; EnvVar = $envVarLib; Content  = $envContentLib },
                    @{Function = "InstallExe"; Command = "$cache\$prodFile"; Param = "/dir=`"$targetPath`" /SP- /SILENT /NORESTART"; runAs=$false } );
     } )
}

function OpCMake362(
    [parameter(Mandatory=$true)][string] $cache)
{
    $prodName = "CMake 3.6.2"
    $targetPath = join-path $env:ProgramFiles "cmake\bin"
    $cmakeName = "cmake-3.6.2-win64-x64.msi"
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/cmake/3.6.2/cmake-3.6.2-win64-x64.msi"
    $expectedHash = "5EB7C09C23B13742161076401BB2F4EDABD75ECAFE8916C7A401532BC3794DD5"
    
    @( @{ShortName = "CMake362"; Name = $prodName; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName";
        Verification = @( @{Function = "VerifyWinProductExists"; Match = "^CMake$"; Version = "3.6.2" }  );
        Download = @( @{Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$cmakeName"; ExpectedHash = $expectedHash } );
        Action = @( @{Function = "InstallMsi"; MsiName =  "$cmakeName" ; MsiDir   = "$cache" }  ,
                    @{Function = "AddToPath"; Dir = "$targetPath" } );
        } )
}

function OpMKLDNN012(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "MKLML and MKL-DNN 0.12 CNTK Prebuild"
    $prodFile = "mklml-mkldnn-0.12.zip"
    $prodSubDir =  "mklml-mkldnn-0.12"

    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "MKL_PATH"
    $envValue = $targetPath
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/mkl-dnn/0.12/mklml-mkldnn-0.12.zip"
    $expectedHash = "13C3D485CF96C216B6460188CE6E120847F1BB16B9F66A4134E56EB5D3A37857"

    @( @{ShortName = "MKLDNN012"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName"; 
         Verification = @( @{Function = "VerifyDirectory"; Path = $targetPath },
                           @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $envValue } );
         Download = @( @{ Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash} );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$prodFile"; destination = $targetFolder; zipSubTree = $prodSubDir; destinationFolder = $prodSubDir },
                     @{Function = "SetEnvironmentVariable"; EnvVar = $envVar; Content  = $envValue }  );
        } )
}

function OpMSMPI70([parameter(
    Mandatory=$true)][string] $cache)
{
    $remoteFilename = "MSMpiSetup.exe"
    $localFilename = "MSMpiSetup70.exe"
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/msmpi/70/$remoteFilename";
    $expectedHash = "7DB377051524EE64D0551735A7A9E9A82402068DC529C0D4CF296E2A616C22AF"

    @( @{Name = "MSMPI Installation"; ShortName = "CNTK"; VerifyInfo = "Checking for installed MSMPI 70"; ActionInfo = "Installing MSMPI 70";
         Verification = @( @{Function = "VerifyWinProductVersion"; Match = "^Microsoft MPI \(\d+\."; Version = "7.0.12437.6"; MatchExact = $false } );
         Download = @( @{Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$localFilename"; ExpectedHash = $expectedHash } );
         Action = @( @{Function = "InstallExe"; Command =  "$cache\$localFilename" ; Param = "/unattend" } )
        } )
}

function OpMSMPI70SDK(
    [parameter(Mandatory=$true)][string] $cache)
{
    $remoteFilename = "msmpisdk.msi"
    $localFilename = "msmpisdk70.msi"
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/msmpisdk/70/$remoteFilename";
    $expectedHash = "C28FB6121FE7A5102ED8B011992708039EE878B9F58A34B84AF41AA3622B8F4D"

    @( @{Name = "MSMPI SDK70 Installation"; ShortName = "CNTK"; VerifyInfo = "Checking for installed MSMPI 70 SDK"; ActionInfo = "Installing MSMPI 70 SDK";
         Verification = @( @{Function = "VerifyWinProductVersion"; Match = "^Microsoft MPI SDK \(\d+\."; Version = "7.0.12437.6"; MatchExact = $false } );
         Download = @( @{Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$localFilename"; ExpectedHash = $expectedHash } );
         Action = @( @{Function = "InstallMsi"; MsiName = "$localFilename" ; MsiDir = "$cache" } )
        } )
}

function OpNvidiaCub180(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "NVidia CUB 1.8.0"
    $prodFile = "cub-1.8.0.zip"
    $prodSubDir = "cub-1.8.0"
    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "CUB_PATH";
    $envValue = $targetPath
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/cub/1.8.0/cub-1.8.0.zip"

    @( @{ShortName = "CUB180"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName";
         Verification = @( @{Function = "VerifyDirectory"; Path = "$targetPath" },
                           @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $envValue } );
         Download = @( @{Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$prodFile" } );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$prodFile"; destination = "$targetFolder"; destinationFolder = $prodSubDir; zipSubTree= $prodSubDir },
                     @{Function = "SetEnvironmentVariable"; EnvVar= $envVar; Content = $envValue } );
         } )
}

function OpNVidiaCudnn73100(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "NVidia CUDNN 7.3.1 for CUDA 10.0"
    $cudnnWin = "cudnn-10.0-windows10-x64-v7.3.1.20.zip"

    $prodSubDir =  "cudnn-10.0-v7.3.1"
    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "CUDNN_PATH"
    $envValue = join-path $targetPath "cuda"
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/cudnn/7.3.1"

    @( @{ShortName = "CUDNN73100"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName";
         Verification = @( @{Function = "VerifyDirectory"; Path = $targetPath },
                           @{Function = "VerifyDirectory"; Path = $envValue },
                           @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $envValue } );
         Download = @( @{Function = "Download"; Method = "WebRequest"; Source = "$downloadSource/$cudnnWin"; Destination = "$cache\$cudnnWin" } );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$cudnnWin"; destination = $targetFolder; destinationFolder = $prodSubDir },
                     @{Function = "SetEnvironmentVariable"; EnvVar = $envVar; Content  = $envValue } );
         })
}

function OpOpenCV31(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "OpenCV-3.1"
    $prodFile = "opencv-3.1.0.exe"
    $prodSubDir = "Opencv3.1.0"
    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "OPENCV_PATH_V31";
    $envValue = "$targetPath\build"
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/opencv/3.1.0/opencv-3.1.0.exe"
    $expectedHash = "0CBB10FAB967111B5B699A44CB224F5D729F8D852D2720CBD5CDB56D8770B7B3"
    $archiveSubTree = "opencv"

    @(  @{ShortName = "OPENCV310"; Name = $prodName; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName"; 
          Verification = @( @{Function = "VerifyDirectory"; Path = "$targetPath" },
                            @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $envValue } );
          Download = @( @{ Function = "Download"; Method = "WebRequest"; UserAgent = "Firefox"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash } );
          Action = @( @{Function = "Extract7zipSelfExtractingArchive"; archiveName = "$cache\$prodFile"; destination = "$targetFolder"; destinationFolder = $prodSubDir; archiveSubTree= $archiveSubTree },
                      @{Function = "SetEnvironmentVariable"; EnvVar= $envVar; Content = $envValue } );
         } )
}

function OpProtoBuf310VS17(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder,
    [parameter(Mandatory=$true)][string] $repoDirectory)
{
    # unzip protobuf source in $protoSourceDir = $targetfolder\src\$prodsubdir
    # create batch file to build protobuf files in $scriptDirectory = $targetFolder\script
    # the script file can be used to create the compiled protobuf libraries in $targetPath = $targetFolder\$prodSubDir

    $prodName = "ProtoBuf 3.1.0 Source"
    $prodSrcSubdir = "protobuf-3.1.0"
    $prodFile = "protobuf310.zip"
    $prodSubDir =  "protobuf-3.1.0-vs17"
    $batchFile = "buildProtoVS17.cmd"

    $protoSourceDir = join-path $targetFolder "src"
    $targetPath = Join-Path $protoSourceDir $prodSrcSubdir
    $scriptDirectory = join-path $targetFolder "script"
    $buildDir = join-path $targetFolder $prodSubDir
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/protobuf/3.1.0/protobuf-3.1.0.zip"
    $expectedHash = "C07629F666312E43A4C2415AF77F6442178605A8658D975299C793CB89999212"

    @( @{ShortName = "PROTO310"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName"; 
         Verification = @( @{Function = "VerifyDirectory"; Path = $targetPath } );
         Download = @( @{ Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash} );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$prodFile"; destination = $protoSourceDir; zipSubTree = $prodSrcSubdir; destinationFolder = $prodSrcSubdir },
                     @{Function = "MakeDirectory"; Path = $scriptDirectory },
                     @{Function = "CreateBuildSimpleBatch"; FileName = "$scriptDirectory\$batchFile"; SourceDir = $targetPath; TargetDir = $buildDir; RepoDirectory = $repoDirectory } );
        } )
}

function OpProtoBuf310VS17Prebuild(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "ProtoBuf 3.1.0 VS17 CNTK Prebuild"
    $prodFile = "protobuf-3.1.0-vs17.zip"
    $prodSubDir =  "protobuf-3.1.0-vs17"

    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "PROTOBUF_PATH"
    $envValue = $targetPath
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/protobuf/3.1.0/protobuf-3.1.0-vs17.zip"
    $expectedHash = "ED0F3215AC60E6AE29B21CBFF53F8876E4CF8B4767FEC525CEF0DA6FDF6A4A73"   

    @( @{ShortName = "PROTO310PRE"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName"; 
         Verification = @( @{Function = "VerifyDirectory"; Path = $targetPath },
                           @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $envValue } );
         Download = @( @{ Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash} );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$prodFile"; destination = $targetFolder; zipSubTree = $prodSubDir; destinationFolder = $prodSubDir },
                     @{Function = "SetEnvironmentVariable"; EnvVar = $envVar; Content  = $envValue }  );
        } )
}

function OpScanProgram()
{
    @{ ShortName = "SCANPROG"; VerifyInfo = "Scan System for installed programs";
      Verification = @( @{Function = "VerifyScanPrograms" } )
     }
}

function OpSwig3010(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "SWIG 3.0.10"
    $prodFile = "swigwin-3.0.10.zip"
    $prodSubDir =  "swigwin-3.0.10"
    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "SWIG_PATH"
    $envValue = $targetPath
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/swig/3.0.10/swigwin-3.0.10.zip"
    $expectedHash = "68A202EBFC62647495074A190A115B629E84C56D74D3017CCB43E56A4B9B83F6"

    @( @{ShortName = "SWIG3010"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName";  
         Verification = @( @{Function = "VerifyDirectory"; Path = $targetPath },
                           @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $envValue } );
         Download = @( @{ Function = "Download"; Method = "WebRequest"; UserAgent = "Firefox"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash } );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$prodFile"; destination = $targetFolder; zipSubTree =$prodSubDir; destinationFolder =$prodSubDir },
                     @{Function = "SetEnvironmentVariable"; EnvVar = $envVar; Content  = $envValue } );
        } )
}

function OpCheckVS2017
{
    @( @{Name = "Verify Installation of VS2017"; ShortName = "PREVS17"; VerifyInfo = "Checking for Visual Studio 2017"; 
                        Verification = @( @{Function = "VerifyWinProductVersion"; Match = "^Visual Studio (Community|Professional|Enterprise) 2017$"; Version = "15.5"; MatchExact = $false} ); 
                        PreReq = @( @{Function = "PrereqInfoVS17" } );
                        Action = @( @{Function = "StopInstallation" } )
                        } )
}

function OpCheckCuda10
{
    $programPath = join-path $env:ProgramFiles "NVIDIA GPU Computing Toolkit\CUDA\v10.0"
    @( @{Name = "Verify Installation of NVidia Cuda 10.0"; ShortName = "PRECUDA100"; VerifyInfo = "Checking for NVidia Cuda 10.0";
         Verification = @( @{Function = "VerifyDirectory"; Path = $programPath },
                           @{Function = "VerifyEnvironmentAndData"; EnvVar = "CUDA_PATH_V10_0"; Content = $programPath } );
         PreReq = @( @{Function = "PrereqInfoCuda10" } );
         Action = @( @{Function = "StopInstallation" } )
        } )
}

function OpZlibVS17(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder,
    [parameter(Mandatory=$true)][string] $repoDirectory)
{
    # unzip protobuf source in $protoSourceDir = $targetfolder\src\$prodsubdir
    # create batch file to build protobuf files in $scriptDirectory = $targetFolder\script
    # the script file can be used to create the compiled protobuf libraries in $targetPath = $targetFolder\$prodSubDir

    $prodName = "zlib / libzip from source"
    $zlibProdName = "zlib-1.2.8"
    $zlibFilename = "zlib128.zip" 
    # $zlibDownloadSource = "https://netix.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib128.zip"
    $zlibDownloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/zlib/1.2.8/zlib128.zip"
    $expectedHashZlib = "879D73D8CD4D155F31C1F04838ECD567D34BEBDA780156F0E82A20721B3973D5"
    
    $libzipProdName = "libzip-1.1.3"
    $libzipFilename = "libzip-1.1.3.tar.gz" 
    $libzipDownloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/libzip/1.1.3/libzip-1.1.3.tar.gz"
    $downloadeSizeLibzip = "1FAA5A524DD4A12C43B6344E618EDCE1BF8050DFDB9D0F73F3CC826929A002B0"
    
    $prodSubDir =  "zlib-vs17"
    $batchFile = "buildZlibVS17.cmd"

    $sourceCodeDir = join-path $targetFolder "src"
    $scriptDirectory = join-path $targetFolder "script"
    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "ZLIB_PATH"
    $envValue = $targetPath
    
    @( @{ShortName = "ZLIBVS17"; VerifyInfo = "Checking for $prodName in $sourceCodeDir"; ActionInfo = "Installing $prodName"; 
         Verification = @( @{Function = "VerifyDirectory"; Path = "$sourceCodeDir\$zlibProdName" },
                           @{Function = "VerifyDirectory"; Path = "$sourceCodeDir\$libzipProdName" },
                           @{Function = "VerifyFile"; Path = "$scriptDirectory\$batchFile" } );
         Download = @( @{ Function = "Download"; Source = $zlibDownloadSource; Destination = "$cache\$zlibFilename"; ExpectedHash = $expectedHashZlib }, 
                       @{ Function = "Download"; Source = $libzipDownloadSource; Destination = "$cache\$libzipFilename"; ExpectedHash = $downloadeSizeLibzip } );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$zlibFilename"; destination = $sourceCodeDir; zipSubTree =$zlibProdName; destinationFolder =$zlibProdName },
                     @{Function = "ExtractAllFromTarGz"; SourceFile =  "$cache\$libzipFilename"; TargzFileName = "$libzipFilename"; destination = $sourceCodeDir },
                     @{Function = "MakeDirectory"; Path = $scriptDirectory },
                     @{Function = "CreateBuildZlibBatch"; FileName = "$scriptDirectory\$batchFile"; zlibSourceDir = (join-path $sourceCodeDir $zlibProdName); libzipSourceDir = (join-path $sourceCodeDir $libzipProdName); TargetDir = $targetPath; RepoDirectory = $repoDirectory } );
        } )
}

function OpZlibVS17Prebuild(
    [parameter(Mandatory=$true)][string] $cache,
    [parameter(Mandatory=$true)][string] $targetFolder)
{
    $prodName = "ZLib VS17 CNTK Prebuild"
    $prodFile = "zlib-vs17.zip"
    $prodSubDir =  "zlib-vs17"


    $targetPath = join-path $targetFolder $prodSubDir
    $envVar = "ZLIB_PATH"
    $envValue = $targetPath
    $downloadSource = "https://cntkbuildstorage.blob.core.windows.net/cntk-ci-dependencies/zlib/vs17/zlib-vs17.zip"
    $expectedHash = "40A79007EC792756370C35E6C8585C0C5E8750A44BD2F60DB1EA542AAF398A7B"

    @( @{ShortName = "ZLIBPRE"; VerifyInfo = "Checking for $prodName in $targetPath"; ActionInfo = "Installing $prodName"; 
         Verification = @( @{Function = "VerifyDirectory"; Path = $targetPath },
                           @{Function = "VerifyEnvironmentAndData"; EnvVar = $envVar; Content = $envValue } );
         Download = @( @{ Function = "Download"; Method = "WebRequest"; Source = $downloadSource; Destination = "$cache\$prodFile"; ExpectedHash = $expectedHash} );
         Action = @( @{Function = "ExtractAllFromZip"; zipFileName = "$cache\$prodFile"; destination = $targetFolder; zipSubTree = $prodSubDir; destinationFolder = $prodSubDir },
                     @{Function = "SetEnvironmentVariable"; EnvVar = $envVar; Content  = $envValue }  );
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function DownloadOperations(
    [parameter(Mandatory=$true)][array] $downloadList)
{
    Write-Host "Performing download operations"

    foreach ($item in $downloadList) {
        foreach ($downloadItem in $item.Download) {
            DownloadItem $downloadItem
        }
    }

    Write-Host "Download operations finished"
    Write-Host
}


function DownloadItem(
    [hashtable] $item
)
{
    $func = $item["Function"]

    $expr = $func +' $item' 
        
    Write-Verbose "Calling Operation: [$func]"
    $result = Invoke-Expression $expr 
}

function DownloadForPlatform(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $platform = $table["Platform"]

    if (PlatformMatching $platform) {
        Download $table
    }
}

function Download(
    [Parameter(Mandatory = $true)][hashtable] $table)
{
    FunctionIntro $table

    $func = $table["Function"]
    $source = $table["Source"]
    $method = GetTableDefaultString -table $table -entryName "Method" -defaultValue "WebRequest"
    $userAgent = GetTableDefaultString -table $table -entryName "UserAgent" -defaultValue = "InternetExplorer"
    $destination = $table["Destination"]
    $expectedHash = GetTableDefaultString -table $table -entryName "expectedHash" -defaultValue ""

    if (test-path $destination -PathType Leaf) {
        Write-Host File [$destination] already exists
        return
    }

    if ($method -eq "WebRequest") {
        DownloadFileWebRequest -SourceFile $source -OutFile $destination -UserAgent $userAgent -expectedHash $expectedHash
    }
    else {
        DownloadFileWebClient -SourceFile $source -OutFile $destination -expectedHash $expectedHash
    }
}

function LocalCopyFile(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    $func = $table["Function"]
    $source = $table["Source"]
    $destination = $table["Destination"]

    if (-not $Execute) {
         Write-Host  "$message ** Running in DEMOMODE - no download performed"
         return $true
    }
    if (test-path $destination -PathType Leaf) {
        Write-Host File [$destination] already exists
        return
    }
    if (-not (test-path $source -PathType Leaf)) {
        throw "Sourcefile [$source] is missing"
    }
    
    Write-Host Copying [$source] to local disk ...
    new-item $destination -type File -Force -ErrorAction SilentlyContinue
    copy-Item $source $destination -Force -ErrorAction SilentlyContinue
}

function NotImplemented(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
     throw "Call to function 'NotImplemented' "
}

function DownloadAndExtract(
    [string] $tPath,
    [string] $sAddress,
    [string] $fileName,
    [string] $targetPathRoot
){
    $outFileName  = Join-Path $tPath $fileName

    DownloadFileWebClient -SourceFile $sAddress `
                    -OutFile $outFileName `
                    -tempFileName $fileName

    Write-Host Extracting into targetpath
    Write-Host

    ExtractAllFromZip $outFileName $targetPathRoot
}

function DownloadFileWebRequest (
    [string] $SourceFile,
    [string] $OutFile,
    [string] $userAgent,
    [string] $expectedHash)
{
    # Use TLS 1.2 because default TLS 1.0 isn't supported by GitHub now.
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Write-Host "Downloading [$SourceFile], please be patient...."
    if (-not $Execute) {
         Write-Host  "$message ** Running in DEMOMODE - no download performed"
         return $true
    }

    if (test-path -path $outFile) {
        Write-Host "File [$outFile] already exists"
        return $true
    }   

    $TempFile = [System.IO.Path]::GetTempFileName()
    try {
        $response = Invoke-WebRequest -Uri $SourceFile -OutFile $TempFile -UserAgent $userAgent -TimeoutSec 120 
    } 
    catch {
      $errorCode = $_.Exception.Response.StatusCode.Value__

      Remove-Item -path $TempFile -ErrorAction SilentlyContinue
      throw "Download $SourceFile Failed! WebRequest reported errorCode: [$errorCode]"
    }

    CheckHash $TempFile $expectedHash

    new-item $outFile -type File -Force -ErrorAction SilentlyContinue
    move-Item $TempFile $OutFile -Force -ErrorAction SilentlyContinue

    if (-not (Test-Path -Path $OutFile)) {
        throw "Download $SourceFile Failed!"
    }
    # we have a file with our expected filename, we are in good shape and ready to report success
    # in case the above rename failed, but the target file exist, we clean up a possible dangling TempFile
    # no need to check if this file is really there. we don't care if it succeeds or not
    Remove-Item -path $TempFile -ErrorAction SilentlyContinue
}

function DownloadFileWebClient(
    [string] $SourceFile,
    [string] $OutFile,
    [string] $expectedHash,
    [int] $timeout = 600,
    [int] $maxtry = 5)
{
    $sb ={
            param([string]$uri,[string]$outfile)
            (New-Object System.Net.WebClient).DownloadFile($uri,$outfile) 
         }
    #---------------

    $startTime = Get-Date
    Write-Host "Downloading [$SourceFile], please be patient, no progress message is shown ..."
    if (-not $Execute) {
         Write-Host  "$message ** Running in DEMOMODE - no download performed"
         return
    }

    $TempFile = [System.IO.Path]::GetTempFileName()

    for ($count=1; $count -le $maxtry; $count +=1) {
        if ($count -gt 1) {
            Write-Host "Iteration [$count] of [$maxtry]"
        }
        
        if ($count -gt 1) {
            start-sleep -Seconds 5
        }
        if (Test-Path -Path $TempFile) {
            # the file we temporary use as a download cache could exist
            # if it does, we remove it and terminate if this fails
            Remove-Item -path $TempFile -ErrorAction Stop
        }    
        
        if (test-path -path $outFile) {
            Write-Host "File [$outFile] already exists"
            return
        }   

        $job = start-job -scriptblock $sb -ArgumentList $sourceFile, $TempFile
        Wait-Job $job -Timeout $timeout

        $jState = $job.State.ToUpper()
        $jStart = $job.PSBeginTime
        $jEnd = $job.PSEndTime
        $jError =  $job.ChildJobs[0].Error
        $current = Get-Date

        switch ($jState) {
            "COMPLETED" { 
                if ($jError.Count -eq 0) {
                    Write-Verbose "End binary download!"

                    Remove-Job $job -force -ErrorAction SilentlyContinue

                    CheckHash $TempFile $expectedHash

                    # we now have the temporary file, we need to rename it
                    new-item $outFile -type File -Force -ErrorAction SilentlyContinue
                    move-Item $TempFile $OutFile -Force -ErrorAction SilentlyContinue

                    if (Test-Path -Path $OutFile) {
                        # we have a file with our expected filename, we are in good shape and ready to report success
                        # in case the above rename failed, but the target file exist, we clean up a possible dangling TempFile
                        # no need to check if this file is really there. we don't care if it succeeds or not
                        Remove-Item -path $TempFile -ErrorAction SilentlyContinue

                        return
                    }

                    # we got here because we finished the job, but some operation failed (i.e. the rename above. we can just try again)
                    Write-Verbose "Job completed but rename operation failed, retrying..."
                    continue
                }

                Write-Host "Job Completed with Error: [$jStart] to [$current]"
                Write-Host $jError
            }
            "RUNNING"   {
                Write-Host "Job Timeout: [$jStart] to [$current]"
            }
            "FAILED"    {
                $current = Get-Date
                Write-Host "Job Failed: [$jStart] to [$current]"
                Write-Host "Error: $jError"
            }
            default     {
                Write-Host "Job State: [$Error] - [$jStart] to [$current]"
            }
        }
        Remove-Job $job -force -ErrorAction SilentlyContinue
    }

    throw "Download $SourceFile Failed!"
}

function CheckHash(
    [string] $tempFile,
    [string] $expectedHash)
{
    if ($expectedHash) {
        $fileHash = (Get-FileHash -Path $tempFile -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
        if ($fileHash -ne $expectedHash) {
              Write-Warning "Hash for downloaded file is not matching expected hash value."
              Write-Warning "This could be a download error or an unexpected version change at the download source."
              Write-Warning "The installation will continue ...."
        }
    }
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function FunctionIntro(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    $table | Out-String | Write-Verbose
}

function GetKey(
    [string] $validChar
)
{
    do {
        $key = Read-Host
    } until ($key -match $validChar)

    return $key
}

function DisplayStartMessage
{
"

This script will setup the CNTK Development Environment on your machine.
More help is given by calling get-help .\devInstall.ps1

The script will analyse your machine and will determine which components are required. 
The required components will be downloaded into [$localCache]
Repeated operation of this script will reuse already downloaded components.
"
}

function DisplayVersionWarningMessage(
    [string] $version)
{
"
You are executing this script from Powershell Version $version.
We recommend that you execute the script from Powershell Version 4 or later. You can install Powershell Version 4 from:
    https://www.microsoft.com/en-us/download/details.aspx?id=40855
"
}

function Display64BitWarningMessage
{
"
A 64bit version of Powershell is required to run this script.
Please check the short-cut/command to start Powershell and make sure you start the 64bit version of Powershell.
"
}

function DisplayWarningNoExecuteMessage
{
"
The parameter '-Execute' hasn't be supplied to the script.
The script will execute withouth making any actual changes to the machine!
"
}

function DisplayStartContinueMessage
{
"
1 - I agree and want to continue
Q - Quit the installation process
"
}

function CheckPowershellVersion
{
    $psVersion = $PSVersionTable.PSVersion.Major
    if ($psVersion -ge 4) {
        return $true
    }

    Write-Warning $(DisplayVersionWarningMessage $psVersion)
    if ($psVersion -eq 3) {
        return $true
    }
    return $false
}

function Check64BitProcess
{
    if ([System.Environment]::Is64BitProcess) {
        return $true
    }

    Write-Warning $(Display64BitWarningMessage)

    return $false
}

function CheckOSVersion 
{
    $runningOn = (Get-WmiObject -class Win32_OperatingSystem).Caption
    $isMatching = ($runningOn -match "^Microsoft Windows (8\.1|10|Server 2012 R2|Server 2016)") 

    if (-not $isMatching) {
       Write-Warning "
You are running this script on [$runningOn].
The Microsoft Cognitive Toolkit is designed and tested on Windows 8.1, Windows 10, 
Windows Server 2012 R2, and Windows Server 2016. 
"
    }
}

function DisplayStart(
    [bool] $NoConfirm)
{
    Write-Host $(DisplayStartMessage)

    if (-not (Check64BitProcess)) {
        return $false
    }

    if (-not (CheckPowershellVersion)) {
        return $false
    }

    CheckOSVersion

    if (-not $Execute) {
        Write-Warning $(DisplayWarningNoExecuteMessage)
    }
    
    if ($NoConfirm) {
        return $true
    }

    Write-Host $(DisplayStartContinueMessage)
    $choice = GetKey '^[1qQ]+$'

    if ($choice -contains "1") {
        return $true
    }

    return $false
}


Function DisplayEnd() 
{
    Write-Host "

Installation finished.
"
}

function DisplayAfterVerify(
    [bool] $NoConfirm,
    [array] $list = @())
{
    Write-Host 

    if ($list.Count -gt 0) {
        Write-Host "The following operations will be performed:"

        foreach ($item in $list) {
            $info = $item.ActionInfo
            Write-Host " * $info"
        }
        if (-not $Execute) {
           Write-Warning $(DisplayWarningNoExecuteMessage)
        }
    
        if ($NoConfirm) {
            return $true
        }

        Write-Host 
        Write-Host "Do you want to continue? (y/n)"
        
        $choice = GetKey '^[yYnN]+$'

        if ($choice -contains "y") {
            return $true
        }
    }
    else {
        Write-Host "No additional installation required"
        Write-Host
       
    }
#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
#
function PreReqOperations(
    [array] $actionList = @())
{
    $continueInstallation = $true
    foreach ($item in $actionList) {
        foreach ($prereqItem in $item.PreReq) {
            $continueInstallation = $false
            PreRequisiteItem $prereqItem
        }
    }
    if (-not $continueInstallation) {
        throw "Not all pre-requisites installed, installation terminated."
    }
    Write-Host "Checking pre-requisites finished"
    Write-Host
}

function PreRequisiteItem(
    [hashtable] $item)
{
    $func = $item["Function"]

    $expr = $func +' $item' 
        
    Write-Verbose "Calling Operation: [$func]"
    Invoke-Expression $expr 
}

function PrereqInfoVS17(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    Write-Warning "

Installation of Visual Studio 2017 is a pre-requisite before installation can continue.
Please check 
  https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-Windows
for more details.
"
}

function PrereqInfoCuda10(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
    Write-Warning "

Installation of NVidia CUDA 10.0 is a pre-requisite before installation can continue.
Please check 
  https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-Windows
for more details.
"
}

function StopInstallation(
    [Parameter(Mandatory = $true)][hashtable] $table
)
{
    FunctionIntro $table
param (
  [switch]$all = $false
)

if(!(Get-Command "git" -ErrorAction SilentlyContinue)) {
  throw "You need to have a git in path to be able to format only the dirty files!"
}

$clangFormat = "clang-format.exe"
if(!(Get-Command $clangFormat -ErrorAction SilentlyContinue)) {
    Write-Information "Can't find clang-format.exe in %PATH%, trying to use %VCINSTALLDIR%..."
    $clangFormat="$env:VCINSTALLDIR\Tools\Llvm\bin\clang-format.exe"
    if(!(Test-Path -Path $clangFormat -PathType leaf)) {
      throw "Can't find clang-format.exe executable. Make sure you either have it in %PATH% or run this script from vcvars.bat!"
    }
}

$sourceExtensions = New-Object System.Collections.Generic.HashSet[string]
$sourceExtensions.Add(".cpp") | Out-Null
$sourceExtensions.Add(".h")   | Out-Null

function Get-Dirty-Files-From-Git() {
  $repo_root = & git rev-parse --show-toplevel

  $staged    = & git diff --name-only --diff-filter=d --cached | % { $repo_root + "/" + $_ }
  $unstaged  = & git ls-files -m
  $untracked = & git ls-files --others --exclude-standard
  $result = New-Object System.Collections.Generic.List[string]
  $staged, $unstaged, $untracked | % {
    $_.Split(" ") | 
      where {Test-Path $_ -PathType Leaf} |
      where {$sourceExtensions.Contains((Get-Item $_).Extension)} | 
      foreach {$result.Add($_)}
  } 
  return $result
}

if($all) { 
  $filesToFormat = 
    Get-ChildItem -Recurse -File ..\src | 
    Resolve-Path -Relative |
    where { (Get-Item $_).Directory -notmatch "(Generated Files)|node_modules" -And 
      $sourceExtensions.Contains((Get-Item $_).Extension)}
}
else {
  $filesToFormat = Get-Dirty-Files-From-Git
}

$filesToFormat | % {
  Write-Host "Formatting $_"
taskkill /f /im PowerRenameUWPUI.exe

.\uninstall_msix.ps1
.\build_msix.ps1
.\sign_msix.ps1
param (
  [bool]$debug = 0
)

$PackagingLayoutFile = "PackagingLayout.xml"

if ($debug) {
  (Get-Content $PackagingLayoutFile) `
  -replace 'x64\\Release\\', 'x64\Debug\' `
  |  Out-File -Encoding utf8 "$env:temp\$PackagingLayoutFile"
#CleanUp tool 1.0
#Copyright (C) 2020 Microsoft Corporation
#Tool to clean PowerToys settings inside AppData folder and registry

#Deleting json settings files in %AppData%/Local/Microsoft/PowerToys.

[String]$SettingsPath = $Env:LOCALAPPDATA + '\Microsoft\PowerToys'

if (Test-Path -Path $SettingsPath -PathType Any)
{
    Remove-Item Path $SettingsPath Recurse
}

#Deleting SuperFancyZones registry key

[String]$SuperFancyZones = "HKCU:\Software\SuperFancyZones"

if (Test-Path -Path $SuperFancyZones -PathType Any)
{
    Remove-Item Path $SuperFancyZones Recurse
}

#Deleting PowerRename registry key

[String]$PowerRename = "HKCU:\Software\Microsoft\PowerRename"

if (Test-Path -Path $PowerRename -PathType Any)
{
    Remove-Item Path $PowerRename Recurse
}

#Deleting ImageResizer registry key

[String]$ImageResizer = "HKCU:\Software\Microsoft\ImageResizer"

if (Test-Path -Path $ImageResizer -PathType Any)
{
    Remove-Item Path $ImageResizer Recurse
}

#Deleting DontShowThisDialogAgain registry key

[String]$DontShowThisDialogAgain = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\DontShowMeThisDialogAgain\{e16ea82f-6d94-4f30-bb02-d6d911588afd}"

if (Test-Path -Path $DontShowThisDialogAgain -PathType Any)
# List of resource folders
$input_resource_folder_list = @("src\settings-ui\Microsoft.PowerToys.Settings.UI\Strings\")
$output_resource_folder_list = @("src\settings-ui\Microsoft.PowerToys.Settings.UI\Strings\")

# Hash table to get the folder language code from the code used in the file name
$languageHashTable = @{ "en" = "en-us";
                        "cs" = "cs-cz";
                        "de" = "de-de";
                        "es" = "es-es";
                        "fr" = "fr-fr";
                        "hu" = "hu-hu";
                        "it" = "it-it";
                        "ja" = "ja-jp";
                        "ko" = "ko-kr";
                        "nl" = "nl-nl";
                        "pl" = "pl-pl";
                        "pt-BR" = "pt-br";
                        "pt-PT" = "pt-pt";
                        "ru" = "ru-ru";
                        "sv" = "sv-se";
                        "tr" = "tr-tr";
                        "zh-Hans" =  "zh-cn";
                        "zh-Hant" = "zh-tw"
                        }

# Iterate over all folders
for ($i=0; $i -lt $input_resource_folder_list.length; $i++) {
    Get-ChildItem $input_resource_folder_list[$i] -Filter Resources.*.resw | 
    Foreach-Object {
        # Get language code from file name
        $lang = "en"
        $tokens = $_.Name -split "\."
        if ($tokens.Count -eq 3) {
            $lang = $tokens[1]
        }
        $langPath = $languageHashTable[$lang]

        # Skip for en-us as it already exists in correct folder
        if ($lang -eq "en") {
            continue
        }

        # Create language folder if it doesn't exist
        $output_path = $output_resource_folder_list[$i] + $langPath
        if (!(Test-Path -Path $output_path))
        {
            $paramNewItem = @{
                Path      = $output_path
                ItemType  = 'Directory'
                Force     = $true
            }

            New-Item @paramNewItem
        }

        # UWP projects expect the file to be in the path Strings\langCode\Resources.resw where langCode is the hyphenated language code
        $input_file = $input_resource_folder_list[$i] + $_.Name
        $output_file = $output_path + "\" + "Resources.resw"

        Move-Item -Path $input_file -Destination $output_file
# This script is used to move the resources from all the resx files in the directory (args[0]) to a .rc and .h file for use in C++ projects.

# Root directory which contains the resx files
$parentDirectory = $args[0]

# File name of the base resource.h which contains all the non-localized resource definitions
$baseHeaderFileName = $args[1]

# Target file name of the resource header file, which will be used in code - Example: resource.h
$generatedHeaderFileName = $args[2]

# File name of the base ProjectName.rc which contains all the non-localized resources
$baseRCFileName = $args[3]

# Target file name of the resource rc file, which will be used in code - Example: ProjectName.rc
$generatedRCFileName = $args[4]

# Optional argument: Initial resource id in the resource header file. By default it is 101
if ($args.Count -eq 6)
{
    $initResourceID = $args[5]
}
else
{    
    $initResourceID = 101
}

# Temporary file created used for resgen
$tempFile = "temporaryResourceFile.txt"

# Flags to check if the first updated has occurred
$headerFileUpdated = $false
$rcFileUpdated = $false

# Output folder for the new resource files. It will be in ProjectDir\Generated Files so that the files are ignored by .gitignore
$generatedFilesFolder = $parentDirectory + "\Generated Files"

# Create Generated Files folder if it doesn't exist
if (!(Test-Path -Path $generatedFilesFolder))
{
    $paramNewItem = @{
        Path      = $generatedFilesFolder
        ItemType  = 'Directory'
        Force     = $true
    }

    New-Item @paramNewItem
}

# Hash table to get the language codes from the code used in the file name
$languageHashTable = @{ "en" = @("ENU", "ENGLISH", "ENGLISH_US", "English (United States)");
                        "zh-Hans" =  @("CHS", "CHINESE", "NEUTRAL", "Chinese (Simplified)");
                        "cs" = @("CSY", "CZECH", "NEUTRAL", "Czech");
                        "hu" = @("HUN", "HUNGARIAN", "NEUTRAL", "Hungarian");
                        "pl" = @("PLK", "POLISH", "NEUTRAL", "Polish");
                        "ro" = @("ROM", "ROMANIAN", "NEUTRAL", "Romanian");
                        "sk" = @("SKY", "SLOVAK", "NEUTRAL", "Slovak");
                        "bg" = @("BGR", "BULGARIAN", "NEUTRAL", "Bulgarian");
                        "ru" = @("RUS", "RUSSIAN", "NEUTRAL", "Russian");
                        "ca" = @("CAT", "CATALAN", "NEUTRAL", "Catalan");
                        "de" = @("DEU", "GERMAN", "NEUTRAL", "German");
                        "es" = @("ESN", "SPANISH", "NEUTRAL", "Spanish");
                        "fr" = @("FRA", "FRENCH", "NEUTRAL", "French");
                        "it" = @("ITA", "ITALIAN", "NEUTRAL", "Italian");
                        "nl" = @("NLD", "DUTCH", "NEUTRAL", "Dutch");
                        "nb-NO" = @("NOR", "NORWEGIAN", "NORWEGIAN_BOKMAL", "Norwegian Bokml (Norway)");
                        "pt-BR" = @("PTB", "PORTUGUESE", "PORTUGUESE_BRAZILIAN", "Portuguese (Brazil)");
                        "eu-ES" = @("EUQ", "BASQUE", "DEFAULT", "Basque (Basque)");
                        "tr" = @("TRK", "TURKISH", "NEUTRAL", "Turkish");
                        "he" = @("HEB", "HEBREW", "NEUTRAL", "Hebrew");
                        "ar" = @("ARA", "ARABIC", "NEUTRAL", "Arabic");
                        "ja" = @("JPN", "JAPANESE", "NEUTRAL", "Japanese");
                        "ko" = @("KOR", "KOREAN", "NEUTRAL", "Korean");
                        "sv" = @("SVE", "SWEDISH", "NEUTRAL", "Swedish");
                        "pt-PT" = @("PTG", "PORTUGUESE", "PORTUGUESE", "Portuguese (Portugal)");
                        "zh-Hant" = @("CHT", "CHINESE", "CHINESE_TRADITIONAL", "Chinese (Traditional)")
                        }

# Store the content to be written to a buffer
$headerFileContent = ""
$rcFileContent = ""

# Iterate over all resx files in parent directory
Get-ChildItem $parentDirectory -Filter *.resx | 
Foreach-Object {
    # Use resgen to parse resx to txt. More details at https://docs.microsoft.com/en-us/dotnet/framework/tools/resgen-exe-resource-file-generator#converting-between-resource-file-types
    try {
        resgen $_.FullName $tempFile
    }
    catch {
        echo "resgen failed to convert resx file"
        exit 0
    }

    # Get language code from file name
    $lang = "en"
    $tokens = $_.Name -split "\."
    if ($tokens.Count -eq 3) {
        $lang = $tokens[1]
    }
    $langData = $languageHashTable[$lang]

    $newLinesForRCFile = ""
    $newLinesForHeaderFile = ""
    $count = $initResourceID

    try {        
        foreach ($line in (Get-Content $tempFile -Encoding unicode)) {
            # Each line of the resgen text file is of the form ResourceName=ResourceValue with no spaces.
            $content = $line -split "=", 2

            $culture = [System.Globalization.CultureInfo]::GetCultureInfo('en-US')
            # Each resource is named as IDS_ResxResourceName, in uppercase. Escape occurrences of double quotes in the string
            $lineInRCFormat = "IDS_" + $content[0].ToUpper($culture) + " L`"" + $content[1].Replace("`"", "`"`"") + "`""
            $newLinesForRCFile = $newLinesForRCFile + "`r`n    " + $lineInRCFormat

            # Resource header file needs to be updated only for one language
            if (!$headerFileUpdated) {
                $lineInHeaderFormat = "#define IDS_" + $content[0].ToUpper($culture) + " " + $count.ToString()
                $newLinesForHeaderFile = $newLinesForHeaderFile + "`r`n" + $lineInHeaderFormat
                $count++
            }
        }
    }
    catch {
        echo "Failed to read temporary file."
        exit 0
    }

    # Delete temporary text file used by resgen
    Remove-Item $tempFile

    # Add string table syntax
    $newLinesForRCFile = "`r`nSTRINGTABLE`r`nBEGIN" + $newLinesForRCFile + "`r`nEND"

    $langStart = "`r`n/////////////////////////////////////////////////////////////////////////////`r`n// " + $langData[3]  + " resources`r`n`r`n"
    $langStart += "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_" + $langData[0] + ")`r`nLANGUAGE LANG_" + $langData[1] + ", SUBLANG_" + $langData[2] + "`r`n"

    $langEnd = "`r`n`r`n#endif    // " + $langData[3] + " resources`r`n/////////////////////////////////////////////////////////////////////////////`r`n"

    $newLinesForRCFile = $langStart + $newLinesForRCFile + $langEnd

    # Initialize the rc file with an auto-generation warning and content from the base rc
    if (!$rcFileUpdated) {
        $rcFileContent = "// This file was auto-generated. Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.`r`n"
        try {
            $rcFileContent += (Get-Content $parentDirectory\$baseRCFileName -Raw)
        }
        catch {
            echo "Failed to read base rc file."
            exit 0
        }
        $rcFileUpdated = $true
    }

    # Add in the new string table to the rc file
    $rcFileContent += $newLinesForRCFile

    # Resource header file needs to be set only once, with an auto-generation warning, content from the base resource header followed by #define for all the resources
    if (!$headerFileUpdated) {
        $headerFileContent = "// This file was auto-generated. Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.`r`n"
        try {
            $headerFileContent += (Get-Content $parentDirectory\$baseHeaderFileName  -Raw)
        }
        catch {
            echo "Failed to read base header file."
            exit 0
        }
        $headerFileContent += $newLinesForHeaderFile
        $headerFileUpdated = $true
    }
}

# Write to header file if the content has changed or if the file doesnt exist
try {
    if (!(Test-Path -Path $generatedFilesFolder\$generatedHeaderFileName) -or (($headerFileContent + "`r`n") -ne (Get-Content $generatedFilesFolder\$generatedHeaderFileName -Raw))) {
        Set-Content -Path $generatedFilesFolder\$generatedHeaderFileName -Value $headerFileContent
    }
    else {
        # echo "Skipping write to generated header file"
    }
}
catch {
    echo "Failed to access generated header file."
    exit 0
}

# Write to rc file if the content has changed or if the file doesnt exist
try {
    if (!(Test-Path -Path $generatedFilesFolder\$generatedRCFileName) -or (($rcFileContent + "`r`n") -ne (Get-Content $generatedFilesFolder\$generatedRCFileName -Raw))) {
        Set-Content -Path $generatedFilesFolder\$generatedRCFileName -Value $rcFileContent -Encoding unicode
    }
    else {    
        # echo "Skipping write to generated rc file"
    }
# This script is used to move the resources from a string table txt file to a resx file

# File containing only the rows of the string table
$stringTableFile = $args[0]

# Output resx file
$resxFile = $args[1]

# Temporary text file used by resgen
$tempFile = "temporaryResourceFile.txt"

$newLinesForTempFile = ""
foreach ($line in Get-Content $stringTableFile) {
    # Each line of string table text file is of the form IDS_ResName L"ResourceValue" where there can be any number of spaces between the two.
    $content = $line.Trim() -split "\s+", 2
    
    # Each line of the resgen text input needs to be of the form ResourceName=ResourceValue with no spaces. 
    # For the resource name for the resx file, we remove the IDS_ prefix and convert the words to title case. This can be imperfect since the parts between underscores may also comprise of multiple words, so that will have to be manually tweaked
    # For the resource value we only keep the content inside L""
    $lineInTempFileFormat = (Get-Culture).TextInfo.ToTitleCase($content[0].Substring(4).Replace("_", " ").ToLower()).Replace(" ", "_") + "=" + $content[1].Substring(2, $content[1].Length - 3)
    $newLinesForTempFile = $newLinesForTempFile + "`r`n" + $lineInTempFileFormat
}

# Save the text to a file
Set-Content -Path $tempFile -Value $newLinesForTempFile

# Use resgen to parse the txt to resx. More details at https://docs.microsoft.com/en-us/dotnet/framework/tools/resgen-exe-resource-file-generator#converting-between-resource-file-types
resgen $tempFile $resxFile

# Delete temporary text file used by resgen
[CmdletBinding()]
Param(
  [Parameter(Mandatory=$True,Position=1)]
  [string]$versionNumber = "0.0.1",

  [Parameter(Mandatory=$True,Position=2)]
  [AllowEmptyString()]
  [string]$DevEnvironment = "Local"
)

Write-Host $PSScriptRoot
$versionRegex = "(\d+)\.(\d+)\.(\d+)"

if($versionNumber -match $versionRegEx)
{
  $buildDayOfYear = (Get-Date).DayofYear;
  $buildTime = Get-Date -Format HH;
  # $buildTime = Get-Date -Format HHmmss;
  # $buildYear = Get-Date -Format yy;
  # $revision = [string]::Format("{0}{1}{2}", $buildYear, $buildDayOfYear, $buildTime )

  # max UInt16, 65535
  #$revision = [string]::Format("{0}{1}", $buildDayOfYear, $buildTime )
  #Write-Host "Revision" $revision

  $versionNumber = [int]::Parse($matches[1]).ToString() + "." + [int]::Parse($matches[2]).ToString() + "." + [int]::Parse($matches[3]).ToString() # + "." + $revision
  Write-Host "Version Number" $versionNumber
}
else{
	throw "Build format does not match the expected pattern (buildName_w.x.y.z)"
}

$verPropWriteFileLocation = $PSScriptRoot + '/../../src/Version.props';
$verPropReadFileLocation = $verPropWriteFileLocation;

[XML]$verProps = Get-Content $verPropReadFileLocation
$verProps.Project.PropertyGroup.Version = $versionNumber;
$verProps.Project.PropertyGroup.DevEnvironment = $DevEnvironment;

Write-Host "xml" $verProps.Project.PropertyGroup.Version 
cd $PSScriptRoot
cd ..\..
$cwd = Get-Location
$SolutionDir = $cwd,"" -join "\"
cd $SolutionDir
$BuildArgs = "/p:Configuration=Release /p:Platform=x64 /p:BuildProjectReferences=false /p:SolutionDir=$SolutionDir"

$ProjectsToBuild = 
  ".\src\runner\runner.vcxproj",
  ".\src\modules\shortcut_guide\shortcut_guide.vcxproj",
  ".\src\modules\fancyzones\lib\FancyZonesLib.vcxproj",
  ".\src\modules\fancyzones\dll\FancyZonesModule.vcxproj"

$ProjectsToBuild | % {
  Invoke-Expression "msbuild $_ $BuildArgs"
#requires -version 6.1

<#
.SYNOPSIS
Scan source code and build a list of supported VT sequences.
.DESCRIPTION
Scan source code and build a list of supported VT sequences.
TODO: add more details
#>
[cmdletbinding(DefaultParameterSetName="stdout")]
param(
    [parameter(ParameterSetName="file", mandatory)]
    [string]$OutFile,
    [parameter(ParameterSetName="file")]
    [switch]$Force, # for overwriting $OutFile if it exists

    [parameter(ParameterSetName="stdout")]
    [parameter(ParameterSetName="file")]
    [switch]$NoLogo, # no logo in summary
    [parameter(ParameterSetName="stdout")]
    [switch]$SummaryOnly, # no markdown generated
    [parameter(ParameterSetName="stdout")]
    [parameter(ParameterSetName="file")]
    [switch]$Quiet, # no summary or logo

    [parameter(ParameterSetName="file")]
    [parameter(ParameterSetName="stdout")]
    [string]$SolutionRoot = "..\..",
    [parameter(ParameterSetName="file")]
    [parameter(ParameterSetName="stdout")]
    [string]$InterfacePath = $(join-path $solutionRoot "src\terminal\adapter\ITermDispatch.hpp"),
    [parameter(ParameterSetName="file")]
    [parameter(ParameterSetName="stdout")]
    [string]$ConsoleAdapterPath = $(join-path $solutionRoot "src\terminal\adapter\adaptDispatch.hpp"),
    [parameter(ParameterSetName="file")]
    [parameter(ParameterSetName="stdout")]
    [string]$TerminalAdapterPath = $(join-path $solutionRoot "src\cascadia\terminalcore\terminalDispatch.hpp")
)

if ($PSCmdlet.ParameterSetName -eq "stdout") {
    Write-Verbose "Emitting markdown to STDOUT"
}

<#
    GLOBALS
#>

[semver]$myVer = "0.6-beta"
$sequences = import-csv ".\master-sequence-list.csv"
$base = @{}
$conhost = @{}
$terminal = @{}
$prefix = "https://vt100.net/docs/vt510-rm/"
$repo = "https://github.com/oising/terminal/tree/master"
$conhostUrl = $ConsoleAdapterPath.TrimStart($SolutionRoot).replace("\", "/")
$terminalUrl = $TerminalAdapterPath.TrimStart($SolutionRoot).replace("\", "/")

function Read-SourceFiles {
    # extract base interface
    $baseScanner = [regex]'(?x)virtual\s\w+\s(?<method>\w+)(?s)[^;]+;(?-s).*?(?<seq>(?<=\/\/\s).+)'

    $baseScanner.Matches(($src = get-content -raw $interfacePath)) | foreach-object {
        $match = $_
        #$line = (($src[0..$_.Index] -join "") -split "`n").Length
        #$decl = $_.groups[0].value
        $_.groups["seq"].value.split(",") | ForEach-Object {
            $SCRIPT:base[$_.trim()] = $match.groups["method"].value
        }
    }

    # match overrides of ITermDispatch
    $scanner = [regex]'(?x)\s+\w+\s(?<method>\w+)(?s)[^;]+override;'

    $scanner.Matches(($src = Get-Content -raw $consoleAdapterPath)) | ForEach-Object {
        $line = (($src[0..$_.Index] -join "") -split "`n").Length
        $SCRIPT:conhost[$_.groups["method"].value] = $line
    }

    $scanner.Matches(($src = Get-Content -raw $terminalAdapterPath)) | ForEach-Object {
        $line = (($src[0..$_.Index] -join "") -split "`n").Length
        #write-verbose $_.groups[0].value
        $SCRIPT:terminal[$_.groups["method"].value] = $line
    }
}

function Get-SequenceIndexMarkdown {
    # "Sequence","Parent","Description","Origin","Heading","Subheading", "ImplementedBy", "ConsoleHost","Terminal"

    $heading = $null
    $subheading = $null
<#
    Emit markdown

    TODO:
    - auto-generate TOC
#>
@"
# VT Function Support

## Table of Contents

* [Code Extension Functions](#code-extension-functions)
    * [Control Coding](#control-coding)
    * [Character Coding](#character-coding)
    * [Graphic Character Sets](#graphic-character-sets)
* [Terminal Management Functions](#terminal-management-functions)
    * [Identification, status, and Initialization](#identification-status-and-initialization)
    * [Emulations](#emulations)
    * [Set-Up](#set-up)
* [Display Coordinate System and Addressing](#display-coordinate-system-and-addressing)
    * [Active Position and Cursor](#active-position-and-cursor)
    * [Margins and Scrolling](#margins-and-scrolling)
    * [Cursor Movement](#cursor-movement)
    * [Horizontal Tabulation](#horizontal-tabulation)
    * [Page Size and Arrangement](#page-size-and-arrangement)
    * [Page Movement](#page-movement)
    * [Status Display](#status-display)
    * [Right to Left](#right-to-left)
* [Window Management](#window-management)
* [Visual Attributes and Renditions](#visual-attributes-and-renditions)
    * [Line Renditions](#line-renditions)
    * [Character Renditions](#character-renditions)
* [Audible Indicators](#audible-indicators)
* [Mode States](#mode-states)
    * [ANSI](#ansi)
    * [DEC Private](#dec-private)
* [Editing Functions](#editing-functions)
* [OLTP Features](#OLTP-features)
    * [Rectangular Area Operations](#rectangular-area-operations)
    * [Data Integrity](#data-integrity)
    * [Macros](#macros)
* [Saving and Restoring Terminal State](#saving-and-restoring-terminal-state)
    * [Cursor Save Buffer](#cursor-save-buffer)
    * [Terminal State Interrogation](#terminal-state-interrogation)
* [Keyboard Processing Functions](#keyboard-processing-functions)
* [Soft Key Mapping (UDK)](#soft-key-mapping-UDK)
* [Soft Fonts (DRCS)](#soft-fonts-drcs)
* [Printing](#printing)
* [Terminal Communication and Synchronization](#terminal-communication-and-synchronization)
* [Text Locator Extension](#text-locator-extension)
* [Session Management Extension](#session-management-extension)
* [Documented Exceptions](#documented-exceptions)

$($sequences | ForEach-Object {
    if ($method = $base[$_.sequence]) {
        $_.ImplementedBy = $method
        $_.ConsoleHost = $conhost[$method]
        $_.Terminal = $terminal[$method]
    }
    # "Sequence","Associated","Description","Origin","Heading","Subheading", "ImplementedBy", "ConsoleHost","Terminal"
    $c0 = "[$($_.Sequence)]($prefix$($_.sequence).html ""View page on vt100.net"")"
    $c1 = "$($_.description)"
    $c2 = "$($_.origin)"
    $c3 = $(if ($_.consolehost) {"[&#x2713;](${repo}/${conhostUrl}#L$($_.consolehost) ""View console host implementation"")"})
    $c4 = $(if ($_.terminal) {"[&#x2713;](${repo}/${terminalUrl}#L$($_.terminal)} ""View windows terminal implementation"")"})

    $shouldRenderHeader = $false

    if ($heading -ne $_.heading) {
        $heading = $_.heading
@"

## $heading

"@
        $shouldRenderHeader = $true
    }

    if ($subheading -ne $_.subheading) {
        $subheading = $_.subheading
@"

### $subheading

"@
        $shouldRenderHeader = $true
    }

    if ($shouldRenderHeader) {
@"

|Symbol|Function|Origin&nbsp;&#x1F5B3;|Console Host|Terminal|
|:-|:--|:--:|:--:|:--:|
"@
    }
@"

|$c0|$c1|$c2|$c3|$c4|
"@
})

---
Generated on $(get-date -DisplayHint DateTime)
"@
}

function Show-Summary {
    write-host "`n$(' '*7)Windows Terminal Sequencer v${myVer}"
    if (-not $NoLogo.IsPresent) {
        Get-Content .\windows-terminal-logo.ans | ForEach-Object { Write-Host $_ }
    }
    $summary = @"
       `e[1mSequence Support:`e[0m

       `e[7m {0:000} `e[0m known in master-sequence-list.csv.
       `e[7m {1:000} `e[0m common members in ITermDispatch base, of which:
       `e[7m {2:000} `e[0m are implemented by ConsoleHost.
       `e[7m {3:000} `e[0m are implemented by Windows Terminal.

"@ -f $sequences.Count, $base.count, $conhost.count, $terminal.Count

    write-host $summary
}

<#
    Entry Point
#>

Read-SourceFiles

if (-not $SummaryOnly.IsPresent) {

    $markdown = Get-SequenceIndexMarkdown

    if ($PSCmdlet.ParameterSetName -eq "file") {
        # send to file and overwrite
        $markdown | Out-File -FilePath $OutFile -Force:$Force.IsPresent -Encoding utf8NoBOM
    } else {
        # send to STDOUT
        $markdown
    }

    if (-not $Quiet.IsPresent) {
        Show-Summary
    }
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

################################
# This script takes a range of commits and generates
# a commit log with the git2git-excluded file changes
# filtered out.
#
# It also replaces GitHub issue numbers with GH-XXX so
# as to not confuse Git2Git or Azure DevOps.
# Community contributions are tagged with CC- so they
# can be detected later.

[CmdletBinding()]
Param(
    [string]$RevisionRange
)

Function Test-MicrosoftPerson($email) {
    Return $email -like "*@microsoft.com"
}

# Replaces github PR numbers with GH-XXX or CC-XXX (community contribution)
# and issue numbers with GH-XXX
Function Mangle-CommitMessage($object) {
    $Prefix = "GH-"
    If (-Not (Test-MicrosoftPerson $object.Email)) {
        $Prefix = "CC-"
    }

    $s = $object.Subject -Replace "\(#(\d+)\)", "(${Prefix}`$1)"
    $s = $s -Replace "#(\d+)","GH-`$1"
    $s
}

Function Get-Git2GitIgnoresAsExcludes() {
    $filters = (Get-Content (Join-Path (& git rev-parse --show-toplevel) consolegit2gitfilters.json) | ConvertFrom-Json)
    $excludes = $filters.ContainsFilters | ? { $_ -Ne "/." } | % { $_ -Replace "^/","" }
    $excludes += $filters.SuffixFilters | % { "**/*$_"; "*$_" }
    $excludes += $filters.PrefixFilters | % { "**/$_*"; "$_*" }
    $excludes | % { ":(top,exclude)$_" }
}

$Excludes = Get-Git2GitIgnoresAsExcludes
Write-Verbose "IGNORING: $Excludes"
$Entries = & git log $RevisionRange "--pretty=format:%an%x1C%ae%x1C%s" -- $Excludes |
    ConvertFrom-CSV -Delimiter "`u{001C}" -Header Author,Email,Subject

Write-Verbose ("{0} unfiltered log entries" -f $Entries.Count)

$Grouped = $Entries | Group Email
$Grouped | % {
    $e = $_.Group[0].Email
    $p = $_.Group[0].Author
    "$p ($($_.Group.Count))"
    $_.Group | % {
        If ($_.Subject -Imatch "^Merge") {
            # Skip merge commits
            Return
        }
# This script is used for taking a json file and stamping it into a header with
# the contents of that json files as a constexpr string_view in the header.

param (
    [parameter(Mandatory=$true, Position=0)]
    [string]$JsonFile,

    [parameter(Mandatory=$true, Position=1)]
    [string]$OutPath,

    [parameter(Mandatory=$true, Position=2)]
    [string]$VariableName
)

# Load the xml files.
$jsonData = Get-Content $JsonFile

Write-Output "// Copyright (c) Microsoft Corporation" | Out-File -FilePath $OutPath -Encoding ASCII
Write-Output "// Licensed under the MIT license." | Out-File -FilePath $OutPath -Encoding ASCII -Append
Write-Output "" | Out-File -FilePath $OutPath -Encoding ASCII -Append
Write-Output "// THIS IS AN AUTO-GENERATED FILE" | Out-File -FilePath $OutPath -Encoding ASCII -Append
Write-Output "// Generated from " | Out-File -FilePath $OutPath -Encoding ASCII -Append -NoNewline
$fullPath = Resolve-Path -Path $JsonFile
Write-Output $fullPath.Path | Out-File -FilePath $OutPath -Encoding ASCII -Append
Write-Output "constexpr std::string_view $($VariableName){ R`"(" | Out-File -FilePath $OutPath -Encoding ASCII -Append -NoNewline
# This is a helper script to figure out which target corresponds to the project
# in this directory. Parses the solution's .metaproj file looking for the
# project file in this directory, to be able to get the project's name.

$projects = Get-Childitem -Path .\ -Filter *.vcxproj -File
if ($projects.length -eq 0)
{
    exit -1
}
$projectPath = $projects.FullName


# Parse the solution's metaproj file.
[xml]$Metaproj = Get-Content "$env:OPENCON\OpenConsole.sln.metaproj"

$targets = $Metaproj.Project.Target

# Most projects are in OpenConsole.sln.metaproj as "<project>.*proj.metaproj".
# We'll filter to search for these first and foremost.
$msBuildCondition = "'%(ProjectReference.Identity)' == '$projectPath.metaproj'"

# Filter to project targets that match our metaproj file.
# For Conhost\Server, this will match:
#   [Conhost\Server, Conhost\Server:Clean, Conhost\Server:Rebuild, Conhost\Server:Publish]
$matchingTargets = $targets | Where-Object { $_.MSBuild.Condition -eq $msBuildCondition }

# If we didn't find a target, it's possible that the project didn't have a
# .metaproj in OpenConsole.sln.metaproj. Try filtering again, but leave off the
# .metaproj extension.
if ($matchingTargets.length -eq 0)
{
    $conditionNoMeta = "'%(ProjectReference.Identity)' == '$projectPath'"
    $matchingTargets = $targets | Where-Object { $_.MSBuild.Condition -eq $conditionNoMeta }
}

# This script is used for taking all the activatable classes from a SxS manifest
# and adding them as Extensions to an Appxmanifest.xml.
# Params:
#  - SxSManifest: The path to the SxS manifest to get the types from
#  - AppxManifestPrototype: The path to an AppxManifest.xml-style XML document to add the Extensions to
#  - SxSManifest: The path to write the updated XML doc to.

param (
    [parameter(Mandatory=$true, Position=0)]
    [string]$SxSManifest,

    [parameter(Mandatory=$true, Position=1)]
    [string]$AppxManifestPrototype,

    [parameter(Mandatory=$true, Position=2)]
    [string]$OutPath
)

# Load the xml files.
[xml]$manifestData = Get-Content $SxSManifest
[xml]$appxPrototypeData = Get-Content $AppxManifestPrototype

# You need to make sure each element we add is part of the same namespace as the
# Package, otherwise powershell will append a bunch of `xmlns=""` properties
# that will make the appx deployment reject the manifest.
$rootNS = $appxPrototypeData.Package.NamespaceURI

# Create an XML element for all the extensions we're adding.
$Extensions = $appxPrototypeData.CreateNode("element", "Extensions", $rootNS)

$assembly = $manifestData.assembly
$files = $assembly.file
$files | ForEach-Object {

    $Extension = $appxPrototypeData.CreateNode("element", "Extension", $rootNS)
    $Extension.SetAttribute("Category", "windows.activatableClass.inProcessServer")

    $InProcessServer = $appxPrototypeData.CreateNode("element", "InProcessServer", $rootNS)
    $Path = $appxPrototypeData.CreateNode("element", "Path", $rootNS)

    # You need to stash the result here, otherwise a blank line will be echoed to
    # the console.
    $placeholder = $Path.InnerText = $_.name

    $InProcessServer.AppendChild($Path)
    $Extension.AppendChild($InProcessServer) | Out-Null

    foreach($class in $_.activatableClass) {
        $ActivatableClass = $appxPrototypeData.CreateNode("element", "ActivatableClass", $rootNS)
        $ActivatableClass.SetAttribute("ActivatableClassId", $class.name)
        $ActivatableClass.SetAttribute("ThreadingModel", $class.threadingModel)

        $InProcessServer.AppendChild($ActivatableClass) | Out-Null
    }

    $Extensions.AppendChild($Extension) | Out-Null

}

# Add our fully constructed list of extensions to the original Appxmanifest prototype
$appxPrototypeData.Package.AppendChild($Extensions) | Out-Null

# Write the modified xml back out.
$appxPrototypeData.save($OutPath)

# Left as a helper for debugging:
# $StringWriter = New-Object System.IO.StringWriter;
# $XmlWriter = New-Object System.Xml.XmlTextWriter $StringWriter;
# $XmlWriter.Formatting = "indented";
# $appxPrototypeData.WriteTo($XmlWriter);
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

#Requires -Version 7
# (we use the null coalescing operator)

################################################################################
# This script generates the an array suitable for replacing the body of
# src/types/CodepointWidthDetector.cpp from a Unicode UCD XML document[1]
# compliant with UAX#42[2].
#
# This script supports a quasi-mandatory "overrides" file, overrides.xml.
# If you do not have overrides, supply the -NoOverrides parameter. This was
# developed for use with the CodepointWidthDetector, which has some override
# ranges.
#
# This script was developed against the flat "no han unification" UCD
# "ucd.nounihan.flat.xml".
# It does not support the grouped database format.
# significantly smaller, which would provide a performance win on the admittedly
# extremely rare occasion that we should need to regenerate our table.
#
# Invoke as ./Generate-xxx ucd.nounihan.flat.xml -Pack | Out-File -Encoding
#           UTF-8 Temporary.cpp
#
# [1]: https://www.unicode.org/Public/UCD/latest/ucdxml/
# [2]: https://www.unicode.org/reports/tr42/

[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingPositionalParameters', '')]
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseProcessBlockForPipelineCommand', '')]
[CmdletBinding()]
Param(
    [Parameter(Position=0, ValueFromPipeline=$true, ParameterSetName="Parsed")]
    [System.Xml.XmlDocument]$InputObject,

    [Parameter(Position=1, ValueFromPipeline=$true, ParameterSetName="Parsed")]
    [System.Xml.XmlDocument]$OverrideObject,

    [Parameter(Position=0, ValueFromPipelineByPropertyName=$true, ParameterSetName="Unparsed")]
    [string]$Path = "ucd.nounihan.flat.xml",

    [Parameter(Position=1, ValueFromPipelineByPropertyName=$true, ParameterSetName="Unparsed")]
    [string]$OverridePath = "overrides.xml",

    [switch]$Pack, # Pack tightly based on width
    [switch]$NoOverrides, # Do not include overrides
    [switch]$Full = $False # Include Narrow codepoints
)

Enum CodepointWidth {
    Narrow;
    Wide;
    Ambiguous;
    Invalid;
}

# UCD Functions {{{
Function Get-UCDEntryRange($entry) {
    $s = $e = 0
    if ($null -ne $v.cp) {
        # Individual Codepoint
        $s = $e = [int]("0x"+$v.cp)
    } ElseIf ($null -ne $v."first-cp") {
        # Range of Codepoints
        $s = [int]("0x"+$v."first-cp")
        $e = [int]("0x"+$v."last-cp")
    }
    $s
    $e
}

Function Get-UCDEntryWidth($entry) {
    If ($entry.Emoji -eq "Y" -and $entry.EPres -eq "Y") {
        [CodepointWidth]::Wide
        Return
    }

    Switch($entry.ea) {
        "N"  { [CodepointWidth]::Narrow; Return }
        "Na" { [CodepointWidth]::Narrow; Return }
        "H"  { [CodepointWidth]::Narrow; Return }
        "W"  { [CodepointWidth]::Wide; Return }
        "F"  { [CodepointWidth]::Wide; Return }
        "A"  { [CodepointWidth]::Ambiguous; Return }
    }
    [CodepointWidth]::Invalid
}

Function Get-UCDEntryFlags($entry) {
    If ($script:Pack) {
        # If we're "pack"ing entries, only the computed width matters for telling them apart
        Get-UCDEntryWidth $entry
        Return
    }

    $normalizedEAWidth = $entry.ea
    $normalizedEAWidth = $normalizedEAWidth -eq "F" ? "W" : $normalizedEAWidth;
    "{0}{1}{2}" -f $normalizedEAWidth, $entry.Emoji, $entry.EPres
}
# }}}

Class UnicodeRange : System.IComparable {
    [int]$Start
    [int]$End
    [CodepointWidth]$Width
    [string]$Flags
    [string]$Comment

    UnicodeRange([System.Xml.XmlElement]$ucdEntry) {
        $this.Start, $this.End = Get-UCDEntryRange $ucdEntry
        $this.Width = Get-UCDEntryWidth $ucdEntry
        $this.Flags = Get-UCDEntryFlags $ucdEntry

        If (-not $script:Pack -and $ucdEntry.Emoji -eq "Y" -and $ucdEntry.EPres -eq "Y") {
            $this.Comment = "Emoji=Y EPres=Y"
        }

        If ($null -ne $ucdEntry.comment) {
            $this.Comment = $ucdEntry.comment
        }
    }

    [int] CompareTo([object]$Other) {
        If ($Other -is [int]) {
            Return $this.Start - $Other
        }
        Return $this.Start - $Other.Start
    }

    [bool] Merge([UnicodeRange]$Other) {
        # If there's more than one codepoint between them, don't merge
        If (($Other.Start - $this.End) -gt 1) {
            Return $false
        }

        # Comments are different: do not merge
        If ($this.Comment -ne $Other.Comment) {
            Return $false
        }

        # Flags are different: do not merge
        If ($this.Flags -ne $Other.Flags) {
            Return $false
        }

        $this.End = $Other.End
        Return $true
    }

    [int] Length() {
        return $this.End - $this.Start + 1
    }
}

Class UnicodeRangeList : System.Collections.Generic.List[Object] {
    UnicodeRangeList([int]$Capacity) : base($Capacity) { }

    [int] hidden _FindInsertionPoint([int]$codepoint) {
        $l = $this.BinarySearch($codepoint)
        If ($l -lt 0) {
            # Return value <0: value was not found, return value is bitwise complement the index of the first >= value
            Return -bNOT $l
        }
        Return $l
    }

    ReplaceUnicodeRange([UnicodeRange]$newRange) {
        $subset = [System.Collections.Generic.List[Object]]::New(3)
        $subset.Add($newRange)

        $i = $this._FindInsertionPoint($newRange.Start)

        # Left overlap can only ever be one (_FindInsertionPoint always returns the
        # index immediately after the range whose Start is <= than ours).
        $prev = $null
        If($i -gt 0 -and $this[$i - 1].End -ge $newRange.Start) {
            $prev = $i - 1
        }

        # Right overlap can be Infinite (because we didn't account for End)
        # Find extent of right overlap
        For($next = $i; ($next -lt $this.Count - 1) -and ($this[$next+1].Start -le $newRange.End); $next++) { }
        If ($this[$next].Start -gt $newRange.End) {
            # It turns out we didn't damage the following range; clear it
            $next = $null
        }

        If ($null -ne $next) {
            # Replace damaged elements after I with a truncated range
            $last = $this[$next]
            $this.RemoveRange($i, $next - $i + 1) # Remove damaged elements after I
            $last.Start = $newRange.End + 1
            If ($last.Start -le $last.End) {
                $subset.Add($last)
            }
        }

        If ($null -ne $prev) {
            # Replace damaged elements before I with a truncated range
            $first = $this[$prev]
            $this.RemoveRange($prev, $i - $prev) # Remove damaged elements (b/c we may not need to re-add them!)
            $first.End = $newRange.Start - 1
            If ($first.End -ge $first.Start) {
                $subset.Insert(0, $first)
            }
            $i = $prev # Update the insertion cursor
        }

        $this.InsertRange($i, $subset)
    }
}

# Ingest UCD
If ($null -eq $InputObject) {
    $InputObject = [xml](Get-Content $Path)
}

$UCDRepertoire = $InputObject.ucd.repertoire.ChildNodes | Sort-Object {
    # Sort by either cp or first-cp (for ranges)
    if ($null -ne $_.cp) {
        [int]("0x"+$_.cp)
    } ElseIf ($null -ne $_."first-cp") {
        [int]("0x"+$_."first-cp")
    }
}

If (-not $Full) {
    $UCDRepertoire = $UCDRepertoire | Where-Object {
        # Select everything Wide/Ambiguous/Full OR Emoji w/ Emoji Presentation
        ($_.ea -notin "N", "Na", "H") -or ($_.Emoji -eq "Y" -and $_.EPres -eq "Y")
    }
}

$ranges = [UnicodeRangeList]::New(1024)

$c = 0
ForEach($v in $UCDRepertoire) {
    $range = [UnicodeRange]::new($v)
    $c += $range.Length()

    If ($ranges.Count -gt 0 -and $ranges[$ranges.Count - 1].Merge($range)) {
        # Merged into last entry
        Continue
    }
    $ranges.Add([object]$range)
}

If (-not $NoOverrides) {
    If ($null -eq $OverrideObject) {
        $OverrideObject = [xml](Get-Content $OverridePath)
    }

    $OverrideRepertoire = $OverrideObject.ucd.repertoire.ChildNodes
    $overrideCount = 0
    ForEach($v in $OverrideRepertoire) {
        $range = [UnicodeRange]::new($v)
        $overrideCount += $range.Length()
        $range.Comment = $range.Comment ?? "overridden without comment"
        $ranges.ReplaceUnicodeRange($range)
    }
}

# Emit Code
"    // Generated by {0} -Pack:{1} -Full:{2} -NoOverrides:{3}" -f $MyInvocation.MyCommand.Name, $Pack, $Full, $NoOverrides
"    // on {0} (UTC) from {1}." -f (Get-Date -AsUTC), $InputObject.ucd.description
"    // {0} (0x{0:X}) codepoints covered." -f $c
If (-not $NoOverrides) {
"    // {0} (0x{0:X}) codepoints overridden." -f $overrideCount
"    // Override path: {0}" -f $OverridePath
}
"    static constexpr std::array<UnicodeRange, {0}> s_wideAndAmbiguousTable{{" -f $ranges.Count
ForEach($_ in $ranges) {
    $comment = ""
    if ($null -ne $_.Comment) {
        # We only vend comments when we aren't packing tightly

# The project's root directory.
Set-Item -force -path "env:OpenConsoleRoot" -value "$PSScriptRoot\.."

#.SYNOPSIS
# Finds and imports a module that should be local to the project
#.PARAMETER ModuleName
# The name of the module to import
function Import-LocalModule
{
    [CmdletBinding()]
    param(
        [parameter(Mandatory=$true, Position=0)]
        [string]$Name
    )

    $ErrorActionPreference = 'Stop'

    $modules_root = "$env:OpenConsoleRoot\.PowershellModules"

    $local = $null -eq (Get-Module -Name $Name)

    if (-not $local)
    {
        return
    }

    if (-not (Test-Path $modules_root)) {
        New-Item $modules_root -ItemType 'directory' | Out-Null
    }

    if (-not (Test-Path "$modules_root\$Name")) {
        Write-Verbose "$Name not downloaded -- downloading now"
        $module = Find-Module "$Name"
        $version = $module.Version

        Write-Verbose "Saving $Name to $modules_root"
        Save-Module -InputObject $module -Path $modules_root
        Import-Module "$modules_root\$Name\$version\$Name.psd1"
    } else {
        Write-Verbose "$Name already downloaded"
        $versions = Get-ChildItem "$modules_root\$Name" | Sort-Object

        Get-ChildItem -Path "$modules_root\$Name\$($versions[0])\$Name.psd1" | Import-Module
    }
}

#.SYNOPSIS
# Grabs all environment variable set after vcvarsall.bat is called and pulls
# them into the Powershell environment.
function Set-MsbuildDevEnvironment
{
    [CmdletBinding()]
    param(
        [switch]$Prerelease
    )

    $ErrorActionPreference = 'Stop'

    Import-LocalModule -Name 'VSSetup'

    Write-Verbose 'Searching for VC++ instances'
    $vsinfo = `
        Get-VSSetupInstance  -All -Prerelease:$Prerelease `
        | Select-VSSetupInstance `
            -Latest -Product * `
            -Require 'Microsoft.VisualStudio.Component.VC.Tools.x86.x64'

    $vspath = $vsinfo.InstallationPath

    switch ($env:PROCESSOR_ARCHITECTURE) {
        "amd64" { $arch = "x64" }
        "x86" { $arch = "x86" }
        default { throw "Unknown architecture: $switch" }
    }

    $vcvarsall = "$vspath\VC\Auxiliary\Build\vcvarsall.bat"

    Write-Verbose 'Setting up environment variables'
    cmd /c ("`"$vcvarsall`" $arch & set") | ForEach-Object {
        if ($_ -match '=')
        {
            $s = $_.Split("=");
            Set-Item -force -path "env:\$($s[0])" -value "$($s[1])"
        }
    }

    Write-Host "Dev environment variables set" -ForegroundColor Green
}

#.SYNOPSIS
# Runs a Taef test suite in a new OpenConsole window.
#
#.PARAMETER OpenConsolePath
# Path to the OpenConsole.exe to run.
#
#.PARAMETER $TaefPath
# Path to the taef.exe to run.
#
#.PARAMETER $TestDll
# Path to the test DLL to run with Taef.
#
#.PARAMETER $TaefArgs
# Any arguments to path to Taef.
function Invoke-TaefInNewWindow()
{
    [CmdletBinding()]
    Param (
        [parameter(Mandatory=$true)]
        [string]$OpenConsolePath,

        [parameter(Mandatory=$true)]
        [string]$TaefPath,

        [parameter(Mandatory=$true)]
        [string]$TestDll,

        [parameter(Mandatory=$false)]
        [string[]]$TaefArgs
    )

    Start-Process $OpenConsolePath -Wait -ArgumentList "powershell.exe $TaefPath $TestDll $TaefArgs; Read-Host 'Press enter to continue...'"
}

#.SYNOPSIS
# Runs OpenConsole's tests. Will only run unit tests by default. Each ft test is
# run in its own window. Note that the uia tests will move the mouse around, so
# it must be left alone for the duration of the test.
#
#.PARAMETER AllTests
# When set, all tests will be run.
#
#.PARAMETER FTOnly
# When set, only ft tests will be run.
#
#.PARAMETER Test
# Can be used to specify that only a particular test should be run.
# Current values allowed are: host, interactivityWin32, terminal, adapter,
# feature, uia, textbuffer.
#
#.PARAMETER TaefArgs
# Used to pass any additional arguments to the test runner.
#
#.PARAMETER Platform
# The platform of the OpenConsole tests to run. Can be "x64" or "x86".
# Defaults to "x64".
#
#.PARAMETER Configuration
# The configuration of the OpenConsole tests to run. Can be "Debug" or
# "Release". Defaults to "Debug".
function Invoke-OpenConsoleTests()
{
    [CmdletBinding()]
    Param (
        [parameter(Mandatory=$false)]
        [switch]$AllTests,

        [parameter(Mandatory=$false)]
        [switch]$FTOnly,

        [parameter(Mandatory=$false)]
        [ValidateSet('host', 'interactivityWin32', 'terminal', 'adapter', 'feature', 'uia', 'textbuffer', 'til', 'types', 'terminalCore', 'terminalApp', 'localTerminalApp', 'localSettingsModel', 'unitRemoting')]
        [string]$Test,

        [parameter(Mandatory=$false)]
        [string[]]$TaefArgs,

        [parameter(Mandatory=$false)]
        [ValidateSet('x64', 'x86')]
        [string]$Platform = "x64",

        [parameter(Mandatory=$false)]
        [ValidateSet('Debug', 'Release')]
        [string]$Configuration = "Debug"

    )

    if (($AllTests -and $FTOnly) -or ($AllTests -and $Test) -or ($FTOnly -and $Test))
    {
        Write-Host "Invalid combination of flags" -ForegroundColor Red
        return
    }
    $OpenConsolePlatform = $Platform
    $TestHostAppPath = "$env:OpenConsoleRoot\$OpenConsolePlatform\$Configuration\TestHostApp"
    if ($Platform -eq 'x86')
    {
        $OpenConsolePlatform = 'Win32'
        $TestHostAppPath = "$env:OpenConsoleRoot\$Configuration\TestHostApp"
    }
    $OpenConsolePath = "$env:OpenConsoleroot\bin\$OpenConsolePlatform\$Configuration\OpenConsole.exe"
    $TaefExePath = "$env:OpenConsoleRoot\packages\Taef.Redist.Wlk.10.57.200731005-develop\build\Binaries\$Platform\te.exe"
    $BinDir = "$env:OpenConsoleRoot\bin\$OpenConsolePlatform\$Configuration"

    [xml]$TestConfig = Get-Content "$env:OpenConsoleRoot\tools\tests.xml"

    # check if WinAppDriver needs to be started
    $WinAppDriverExe = $null
    if ($AllTests -or $FtOnly -or $Test -eq "uia")
    {
        $WinAppDriverExe = [Diagnostics.Process]::Start("$env:OpenConsoleRoot\dep\WinAppDriver\WinAppDriver.exe")
    }

    # select tests to run
    if ($AllTests)
    {
        $TestsToRun = $TestConfig.tests.test
    }
    elseif ($FTOnly)
    {
        $TestsToRun = $TestConfig.tests.test | Where-Object { $_.type -eq "ft" }
    }
    elseif ($Test)
    {
        $TestsToRun = $TestConfig.tests.test | Where-Object { $_.name -eq $Test }
    }
    else
    {
        # run unit tests by default
        $TestsToRun = $TestConfig.tests.test | Where-Object { $_.type -eq "unit" }
    }

    # run selected tests
    foreach ($t in $TestsToRun)
    {
        if ($t.type -eq "unit")
        {
            if ($t.runInHostApp -eq "true")
            {
                & $TaefExePath "$TestHostAppPath\$($t.binary)" $TaefArgs
            }

            & $TaefExePath "$BinDir\$($t.binary)" $TaefArgs
        }
        elseif ($t.type -eq "ft")
        {
            Invoke-TaefInNewWindow -OpenConsolePath $OpenConsolePath -TaefPath $TaefExePath -TestDll "$BinDir\$($t.binary)" -TaefArgs $TaefArgs
        }
        else
        {
            Write-Host "Invalid test type $t.type for test: $t.name" -ForegroundColor Red
            return
        }
    }

    # stop running WinAppDriver if it was launched
    if ($WinAppDriverExe)
    {
        Stop-Process -Id $WinAppDriverExe.Id
    }
}


#.SYNOPSIS
# Builds OpenConsole.sln using msbuild. Any arguments get passed on to msbuild.
function Invoke-OpenConsoleBuild()
{
    & "$env:OpenConsoleRoot\dep\nuget\nuget.exe" restore "$env:OpenConsoleRoot\OpenConsole.sln"
    msbuild.exe "$env:OpenConsoleRoot\OpenConsole.sln" @args
}

#.SYNOPSIS
# Launches an OpenConsole process.
#
#.PARAMETER Platform
# The platform of the OpenConsole executable to launch. Can be "x64" or "x86".
# Defaults to "x64".
#
#.PARAMETER Configuration
# The configuration of the OpenConsole executable to launch. Can be "Debug" or
# "Release". Defaults to "Debug".
function Start-OpenConsole()
{
    [CmdletBinding()]
    Param (
        [parameter(Mandatory=$false)]
        [string]$Platform = "x64",

        [parameter(Mandatory=$false)]
        [string]$Configuration = "Debug"
    )
    if ($Platform -like "x86")
    {
        $Platform = "Win32"
    }
    & "$env:OpenConsoleRoot\bin\$Platform\$Configuration\OpenConsole.exe"
}

#.SYNOPSIS
# Launches an OpenConsole process and attaches the default debugger.
#
#.PARAMETER Platform
# The platform of the OpenConsole executable to launch. Can be "x64" or "x86".
# Defaults to "x64".
#
#.PARAMETER Configuration
# The configuration of the OpenConsole executable to launch. Can be "Debug" or
# "Release". Defaults to "Debug".
function Debug-OpenConsole()
{
    [CmdletBinding()]
    Param (
        [parameter(Mandatory=$false)]
        [string]$Platform = "x64",

        [parameter(Mandatory=$false)]
        [string]$Configuration = "Debug"
    )
    if ($Platform -like "x86")
    {
        $Platform = "Win32"
    }
    $process = [Diagnostics.Process]::Start("$env:OpenConsoleRoot\bin\$Platform\$Configuration\OpenConsole.exe")
    Debug-Process -Id $process.Id
}

#.SYNOPSIS
# runs clang-format on list of files
#
#.PARAMETER Path
# The full paths to the files to format
function Invoke-ClangFormat {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [string[]]$Path,

        [Parameter(Mandatory=$false)]
        [string]$ClangFormatPath = "clang-format" # (whichever one is in $PATH)
    )

    Begin {
        $BatchSize = [int]64
        $Paths = @()
    }

    Process {
        ForEach($_ in $Path) {
            $Paths += Get-Item $_ -ErrorAction Stop | Select -Expand FullName
        }
    }

    End {
        For($i = [int]0; $i -Lt $Paths.Length; $i += $BatchSize) {
            Try {
                & $ClangFormatPath -i $Paths[$i .. ($i + $BatchSize - 1)]
            } Catch {
                Write-Error $_
            }
        }
    }
}

#.SYNOPSIS
# runs code formatting on all c++ files
function Invoke-CodeFormat() {
    & "$env:OpenConsoleRoot\dep\nuget\nuget.exe" restore "$env:OpenConsoleRoot\tools\packages.config"
    $clangPackage = ([xml](Get-Content "$env:OpenConsoleRoot\tools\packages.config")).packages.package | Where-Object id -like "clang-format*"
    $clangFormatPath = "$env:OpenConsoleRoot\packages\$($clangPackage.id).$($clangPackage.version)\tools\clang-format.exe"
    Get-ChildItem -Recurse "$env:OpenConsoleRoot/src" -Include *.cpp, *.hpp, *.h |
      Where FullName -NotLike "*Generated Files*" |
# Displaying progress is unnecessary and is just distracting.
$ProgressPreference = "SilentlyContinue"

$dependencyFiles = Get-ChildItem -Filter "*Microsoft.VCLibs.*.appx"

foreach ($file in $dependencyFiles)
{
    Write-Host "Adding dependency $($file)..."

    Add-AppxPackage $file
Param(
    [Parameter(Mandatory = $true)] 
    [string]$WttInputPath,

    [Parameter(Mandatory = $true)] 
    [string]$WttSingleRerunInputPath,

    [Parameter(Mandatory = $true)] 
    [string]$WttMultipleRerunInputPath,

    [Parameter(Mandatory = $true)] 
    [string]$XUnitOutputPath,

    [Parameter(Mandatory = $true)] 
    [string]$TestNamePrefix
)

# Ideally these would be passed as parameters to the script. However ps makes it difficult to deal with string literals containing '&', so we just 
# read the values directly from the environment variables
$helixResultsContainerUri = $Env:HELIX_RESULTS_CONTAINER_URI
$helixResultsContainerRsas = $Env:HELIX_RESULTS_CONTAINER_RSAS

$rerunPassesRequiredToAvoidFailure = $env:rerunPassesRequiredToAvoidFailure

Add-Type -Language CSharp -ReferencedAssemblies System.Xml,System.Xml.Linq,System.Runtime.Serialization,System.Runtime.Serialization.Json (Get-Content $PSScriptRoot\HelixTestHelpers.cs -Raw)
$scriptDirectory = $script:MyInvocation.MyCommand.Path | Split-Path -Parent

# List all processes to aid debugging:
Write-Host "All processes running:"
Get-Process

tasklist /svc

# Add this test directory as an exclusion for Windows Defender
Write-Host "Add $scriptDirectory as Exclusion Path"
Add-MpPreference -ExclusionPath $scriptDirectory
Write-Host "Add $($env:HELIX_CORRELATION_PAYLOAD) as Exclusion Path"
Add-MpPreference -ExclusionPath $env:HELIX_CORRELATION_PAYLOAD
Get-MpPreference
Get-MpComputerStatus


# Minimize all windows:
$shell = New-Object -ComObject "Shell.Application"
$shell.minimizeall()

# Kill any instances of Windows Security Alert:
$windowTitleToMatch = "*Windows Security Alert*"
$procs = Get-Process | Where {$_.MainWindowTitle -like "*Windows Security Alert*"}
foreach ($proc in $procs)
{
    Write-Host "Found process with '$windowTitleToMatch' title: $proc"
    $proc.Kill();
}

# Kill processes by name that are known to interfere with our tests:
$processNamesToStop = @("Microsoft.Photos", "WinStore.App", "SkypeApp", "SkypeBackgroundHost", "OneDriveSetup", "OneDrive")
foreach($procName in $processNamesToStop)
{
    Write-Host "Attempting to kill $procName if it is running"
    Stop-Process -ProcessName $procName -Verbose -ErrorAction Ignore   
}
Write-Host "All processes running after attempting to kill unwanted processes:"
Get-Process

tasklist /svc

$platform = $env:testbuildplatform
if(!$platform)
{
    $platform = "x86"
}

function UninstallApps {
    Param([string[]]$appsToUninstall)

    foreach($pkgName in $appsToUninstall)
    {
        foreach($pkg in (Get-AppxPackage $pkgName).PackageFullName) 
        {
            Write-Output "Removing: $pkg" 
            Remove-AppxPackage $pkg
        } 
    }
}

function UninstallTestApps {
    Param([string[]]$appsToUninstall)

    foreach($pkgName in $appsToUninstall)
    {
        foreach($pkg in (Get-AppxPackage $pkgName).PackageFullName) 
        {
            Write-Output "Removing: $pkg" 
            Remove-AppxPackage $pkg
        }

        # Sometimes an app can get into a state where it is no longer returned by Get-AppxPackage, but it is still present
        # which prevents other versions of the app from being installed.
        # To handle this, we can directly call Remove-AppxPackage against the full name of the package. However, without
        # Get-AppxPackage to find the PackageFullName, we just have to manually construct the name.
        $packageFullName = "$($pkgName)_1.0.0.0_$($platform)__8wekyb3d8bbwe" 
        Write-Host "Removing $packageFullName if installed"
        Remove-AppPackage $packageFullName -ErrorVariable appxerror -ErrorAction SilentlyContinue 
        if($appxerror)
        {
            foreach($error in $appxerror)
            {
                # In most cases, Remove-AppPackage will fail due to the package not being found. Don't treat this as an error.
                if(!($error.Exception.Message -match "0x80073CF1"))
                {
                    Write-Error $error
                }
            }
        }
        else
        {
            Write-Host "Successfully removed $packageFullName"
        }
    }
}

Write-Host "Uninstall AppX packages that are known to cause issues with our tests"
UninstallApps("*Skype*", "*Windows.Photos*")

Write-Host "Uninstall any of our test apps that may have been left over from previous test runs"
UninstallTestApps("NugetPackageTestApp", "NugetPackageTestAppCX", "IXMPTestApp", "MUXControlsTestApp")

Write-Host "Uninstall MUX Framework package that may have been left over from previous test runs"
# We don't want to uninstall all versions of the MUX Framework package, as there may be other apps preinstalled on the system 
# that depend on it. We only uninstall the Framework package that corresponds to the version of MUX that we are testing.
[xml]$versionData = (Get-Content "version.props")
$versionMajor = $versionData.GetElementsByTagName("MUXVersionMajor").'#text'
$versionMinor = $versionData.GetElementsByTagName("MUXVersionMinor").'#text'
UninstallApps("Microsoft.UI.Xaml.$versionMajor.$versionMinor")
Param(
    [Parameter(Mandatory = $true)] 
    [string]$WttInputPath,

    [Parameter(Mandatory = $true)] 
    [string]$WttSingleRerunInputPath,

    [Parameter(Mandatory = $true)] 
    [string]$WttMultipleRerunInputPath,

    [Parameter(Mandatory = $true)] 
    [string]$TestNamePrefix
)

# Ideally these would be passed as parameters to the script. However ps makes it difficult to deal with string literals containing '&', so we just 
# read the values directly from the environment variables
$helixResultsContainerUri = $Env:HELIX_RESULTS_CONTAINER_URI
$helixResultsContainerRsas = $Env:HELIX_RESULTS_CONTAINER_RSAS

Add-Type -Language CSharp -ReferencedAssemblies System.Xml,System.Xml.Linq,System.Runtime.Serialization,System.Runtime.Serialization.Json (Get-Content $PSScriptRoot\HelixTestHelpers.cs -Raw)

$testResultParser = [HelixTestHelpers.TestResultParser]::new($TestNamePrefix, $helixResultsContainerUri, $helixResultsContainerRsas)
[System.Collections.Generic.Dictionary[string, string]]$subResultsJsonByMethodName = $testResultParser.GetSubResultsJsonByMethodName($WttInputPath, $WttSingleRerunInputPath, $WttMultipleRerunInputPath)

$subResultsJsonDirectory = [System.IO.Path]::GetDirectoryName($WttInputPath)

foreach ($methodName in $subResultsJsonByMethodName.Keys)
{
    $subResultsJson = $subResultsJsonByMethodName[$methodName]
    $subResultsJsonPath = [System.IO.Path]::Combine($subResultsJsonDirectory, $methodName + "_subresults.json")
function GetAzureDevOpsBaseUri
{
    Param(
        [string]$CollectionUri,
        [string]$TeamProject
    )

    return $CollectionUri + $TeamProject
}

function GetQueryTestRunsUri
{
    Param(
        [string]$CollectionUri,
        [string]$TeamProject,
        [string]$BuildUri,
        [switch]$IncludeRunDetails
    )

    if ($IncludeRunDetails)
    {
        $includeRunDetailsParameter = "&includeRunDetails=true"
    }
    else
    {
        $includeRunDetailsParameter = ""
    }

    $baseUri = GetAzureDevOpsBaseUri -CollectionUri $CollectionUri -TeamProject $TeamProject
    $queryUri = "$baseUri/_apis/test/runs?buildUri=$BuildUri$includeRunDetailsParameter&api-version=5.0"
Param(
    [string]$AccessToken = $env:SYSTEM_ACCESSTOKEN,
    [string]$HelixAccessToken = $env:HelixAccessToken,
    [string]$CollectionUri = $env:SYSTEM_COLLECTIONURI,
    [string]$TeamProject = $env:SYSTEM_TEAMPROJECT,
    [string]$BuildUri = $env:BUILD_BUILDURI,
    [string]$OutputFolder = "HelixOutput"
)

$helixLinkFile = "$OutputFolder\LinksToHelixTestFiles.html"

$accessTokenParam = ""
if($HelixAccessToken)
{
    $accessTokenParam = "?access_token=$HelixAccessToken"
}

function Generate-File-Links
{
    Param ([Array[]]$files,[string]$sectionName)
    if($files.Count -gt 0)
    {
        Out-File -FilePath $helixLinkFile -Append -InputObject "<div class=$sectionName>"
        Out-File -FilePath $helixLinkFile -Append -InputObject "<h4>$sectionName</h4>"
        Out-File -FilePath $helixLinkFile -Append -InputObject "<ul>"
        foreach($file in $files)
        {
            Out-File -FilePath $helixLinkFile -Append -InputObject "<li><a href=$($file.Link)>$($file.Name)</a></li>"
        }
        Out-File -FilePath $helixLinkFile -Append -InputObject "</ul>"
        Out-File -FilePath $helixLinkFile -Append -InputObject "</div>"
    }
}

#Create output directory
New-Item $OutputFolder -ItemType Directory

$azureDevOpsRestApiHeaders = @{
    "Accept"="application/json"
    "Authorization"="Basic $([System.Convert]::ToBase64String([System.Text.ASCIIEncoding]::ASCII.GetBytes(":$AccessToken")))"
}

. "$PSScriptRoot/AzurePipelinesHelperScripts.ps1"

$queryUri = GetQueryTestRunsUri -CollectionUri $CollectionUri -TeamProject $TeamProject -BuildUri $BuildUri -IncludeRunDetails
Write-Host "queryUri = $queryUri"

$testRuns = Invoke-RestMethod -Uri $queryUri -Method Get -Headers $azureDevOpsRestApiHeaders
$webClient = New-Object System.Net.WebClient
[System.Collections.Generic.List[string]]$workItems = @()

foreach ($testRun in $testRuns.value)
{
    $testResults = Invoke-RestMethod -Uri "$($testRun.url)/results?api-version=5.0" -Method Get -Headers $azureDevOpsRestApiHeaders
    $isTestRunNameShown = $false

    foreach ($testResult in $testResults.value)
    {
        if ("comment" -in $testResult)
        {
            $info = ConvertFrom-Json $testResult.comment
            $helixJobId = $info.HelixJobId
            $helixWorkItemName = $info.HelixWorkItemName

            $workItem = "$helixJobId-$helixWorkItemName"

            if (-not $workItems.Contains($workItem))
            {
                $workItems.Add($workItem)
                $filesQueryUri = "https://helix.dot.net/api/2019-06-17/jobs/$helixJobId/workitems/$helixWorkItemName/files$accessTokenParam"
                $files = Invoke-RestMethod -Uri $filesQueryUri -Method Get

                $screenShots = $files | where { $_.Name.EndsWith(".jpg") }
                $dumps = $files | where { $_.Name.EndsWith(".dmp") }
                $pgcFiles = $files | where { $_.Name.EndsWith(".pgc") }
                if ($screenShots.Count + $dumps.Count + $pgcFiles.Count -gt 0)
                {
                    if(-Not $isTestRunNameShown)
                    {
                        Out-File -FilePath $helixLinkFile -Append -InputObject "<h2>$($testRun.name)</h2>"
                        $isTestRunNameShown = $true
                    }
                    Out-File -FilePath $helixLinkFile -Append -InputObject "<h3>$helixWorkItemName</h3>"
                    Generate-File-Links $screenShots "Screenshots"
                    Generate-File-Links $dumps "CrashDumps"
                    Generate-File-Links $pgcFiles "PGC files"
                    $misc = $files | where { ($screenShots -NotContains $_) -And ($dumps -NotContains $_) -And ($visualTreeVerificationFiles -NotContains $_) -And ($pgcFiles -NotContains $_) }
                    Generate-File-Links $misc "Misc"

                    foreach($pgcFile in $pgcFiles)
                    {
                        $flavorPath = $pgcFile.Name.Split('.')[0]
                        $archPath = $pgcFile.Name.Split('.')[1]
                        $fileName = $pgcFile.Name.Remove(0, $flavorPath.length + $archPath.length + 2)
                        $fullPath = "$OutputFolder\PGO\$flavorPath\$archPath"
                        $destination = "$fullPath\$fileName"

                        Write-Host "Copying $($pgcFile.Name) to $destination"

                        if (-Not (Test-Path $fullPath))
                        {
                            New-Item $fullPath -ItemType Directory
                        }

                        $link = "$($pgcFile.Link)$accessTokenParam"
                        $webClient.DownloadFile($link, $destination)
                    }
                }
            }
        }
[CmdLetBinding()]
Param(
    [Parameter(Mandatory = $true)] 
    [string]$TestFile,

    [Parameter(Mandatory = $true)] 
    [string]$OutputProjFile,

    [Parameter(Mandatory = $true)] 
    [string]$JobTestSuiteName,

    [Parameter(Mandatory = $true)] 
    [string]$TaefPath,

    [string]$TaefQuery
)

Class TestCollection
{
    [string]$Name
    [string]$SetupMethodName
    [string]$TeardownMethodName
    [System.Collections.Generic.Dictionary[string, string]]$Properties

    TestCollection()
    {
        if ($this.GetType() -eq [TestCollection])
        {
            throw "This class should never be instantiated directly; it should only be derived from."
        }
    }

    TestCollection([string]$name)
    {
        $this.Init($name)
    }

    hidden Init([string]$name)
    {
        $this.Name = $name
        $this.Properties = @{}
    }
}

Class Test : TestCollection 
